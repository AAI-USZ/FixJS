function(a){var c="";switch(a){case osg.ShaderGeneratorType.VertexInit:c="\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\n\n";
break;case osg.ShaderGeneratorType.VertexFunction:c="\nvec3 computeNormal() {\n   return vec3(NormalMatrix * vec4(Normal, 0.0));\n}\n\nvec3 computeEyeVertex() {\n   return vec3(ModelViewMatrix * vec4(Vertex,1.0));\n}\n\nfloat getLightAttenuation(vec3 lightDir, float constant, float linear, float quadratic) {\n    \n    float d = length(lightDir);\n    float att = 1.0 / ( constant + linear*d + quadratic*d*d);\n    return att;\n}\n";break;case osg.ShaderGeneratorType.VertexMain:c="\n  vec3 vertexEye = computeEyeVertex();\n  FragEyeVector = -vertexEye;\n  FragNormal = computeNormal();\n";
break;case osg.ShaderGeneratorType.FragmentInit:c="varying vec3 FragNormal;\nvarying vec3 FragEyeVector;\nvec4 LightColor = vec4(0.0);\n";break;case osg.ShaderGeneratorType.FragmentFunction:c="\nvec4 computeLightContribution(vec4 materialEmission,\n                              vec4 materialAmbient,\n                              vec4 materialDiffuse,\n                              vec4 materialSpecular,\n                              float materialShininess,\n                              vec4 lightAmbient,\n                              vec4 lightDiffuse,\n                              vec4 lightSpecular,\n                              vec3 normal,\n                              vec3 eye,\n                              vec3 lightDirection,\n                              vec3 lightSpotDirection,\n                              float lightCosSpotCutoff,\n                              float lightCosSpotCutoffEnd,\n                              float lightAttenuation)\n{\n    vec3 L = lightDirection;\n    vec3 N = normal;\n    float NdotL = max(dot(L, N), 0.0);\n    vec4 ambient = lightAmbient;\n    vec4 diffuse = vec4(0.0);\n    vec4 specular = vec4(0.0);\n    float spot = 0.0;\n\n    if (NdotL > 0.0) {\n        vec3 E = eye;\n        vec3 R = reflect(-L, N);\n        float RdotE = pow( max(dot(R, E), 0.0), materialShininess );\n\n        vec3 D = lightSpotDirection;\n        spot = 1.0;\n        if (lightCosSpotCutoff > 0.0) {\n          float cosCurAngle = dot(L, D);\n          float cosInnerMinusOuterAngle = lightCosSpotCutoff - lightCosSpotCutoffEnd;\n\n          spot = clamp((cosCurAngle - lightCosSpotCutoffEnd) / cosInnerMinusOuterAngle, 0.0, 1.0);\n        }\n        diffuse = lightDiffuse * NdotL;\n        specular = lightSpecular * RdotE;\n    }\n\n    return materialEmission + (materialAmbient*ambient + (materialDiffuse*diffuse + materialSpecular*specular) * spot) * lightAttenuation;\n}\n";
break;case osg.ShaderGeneratorType.FragmentMain:c="\n  vec3 normal = normalize(FragNormal);\n  vec3 eyeVector = normalize(FragEyeVector);\n";break;case osg.ShaderGeneratorType.FragmentEnd:c="\n  fragColor *= LightColor;\n"}return c}