function traverse(node) {
    if (!Array.isArray(node)) {
      throw new TypeError('Incorrect AST node: ' + util.inspect(node));
    }

    function runtime(func, args) {
      return [
        'call',
        ['dot', ['name', '$$runtime'], '$' + func],
        args.map(traverse)
      ];
    }

    switch (node[0]) {
      case 'var':
        // Not generated by parser! (Internal)
        return node;
      case 'number':
        return ['num', node[1]];
      case 'string':
        return node;
      case 'name':
        // Handle non-object (non-existent) access
        return node;
      case 'true':
      case 'false':
        return ['name', node[0]];
      case 'nil':
        return ['name', 'undefined'];
      case 'break':
      case 'continue':
        return [node[0], undefined];
      case 'return':
        return ['return', traverse(node[1])];
      case 'if':
      case 'while':
        return [node[0]].concat(node.slice(1).map(function(node) {
          if (!node) return;
          return traverse(node);
        }));
      case 'block':
        return ['block', node[1].map(function(node) {
          return ['stat', traverse(node)];
        })];
      case 'pre-unop':
        return ['unary-prefix', node[1], traverse(node[2])];
      case 'post-unop':
        return ['unary-postfix', node[1], traverse(node[2])];
      case 'binop':
        return ['binary', node[1], traverse(node[2]), traverse(node[3])];
      case 'assign':
        // Handle property set
        if (node[1][0] === 'member') {
          if (node[1][2][0] === 'property') {
            return runtime('setProperty', [
              node[1][1],
              ['string', node[1][2][1]],
              node[2]
            ]);
          } else {
            return runtime('setProperty', [
              node[1][1],
              node[1][2],
              node[2]
            ]);
          }
        }
        return ['assign', true, traverse(node[1]), traverse(node[2])];
      case 'member':
        if (node[2][0] === 'property') {
          return runtime('getProperty', [node[1], ['string', node[2][1]]]);
        } else {
          return runtime('getProperty', [node[1], node[2]]);
        }
      case 'call':
        // TODO: Handle self and vararg
        return ['call', traverse(node[1]), node[2].map(traverse)];
      case 'function':
        // TODO: Handle vararg
        var fn = [
          'function',
          null,
          node[2].map(function(node) {
            return node[1];
          }),
          node[3].map(traverse)
        ];

        if (node[1] !== null) {
          return ['assign', true, node[1], fn];
        } else {
          return fn;
        }
      case 'object':
        return [
          'object',
          node[1].map(function(kv) {
            if (kv[0][1][0] === 'property') {
              return [['name', kv[0][1][1]], traverse(kv[1])];
            }
            return [kv[0][1], traverse(kv[1])];
          })
        ];
      case 'array':
        return [ 'array', node[1].map(traverse) ];
      case 'typeof':
      case 'keysof':
      case 'sizeof':
      case 'clone':
        return runtime(node[0], [node[1]]);
      case 'delete':
        return ['unary-prefix', 'delete', traverse(node[1])];
      default:
        throw new Error('Unexpected node: ' + util.inspect(node));
    }
  }