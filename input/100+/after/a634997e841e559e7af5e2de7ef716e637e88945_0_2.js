function traverse(node) {
    if (!Array.isArray(node)) {
      throw new TypeError('Incorrect AST node: ' + util.inspect(node));
    }

    function runtime(func, args, rawArgs) {
      return [
        'call',
        func.split(/\./g).reduce(function(whole, part) {
          return ['dot', whole, '$' + part];
        }, ['name', '$$runtime']),
        rawArgs ? args : args.map(traverse)
      ];
    }

    switch (node[0]) {
      case 'var':
        // Not generated by parser! (Internal)
        return node;
      case 'number':
        return ['num', node[1]];
      case 'string':
      case 'name':
        return node;
      case 'true':
      case 'false':
        return ['name', node[0]];
      case 'nil':
        return ['name', 'undefined'];
      case 'break':
      case 'continue':
        return [node[0], undefined];
      case 'return':
        return ['return', traverse(node[1])];
      case 'if':
      case 'while':
        return [node[0]].concat(node.slice(1).map(function(node) {
          if (!node) return;
          return traverse(node);
        }));
      case 'block':
        return ['block', node[1].map(function(node) {
          return ['stat', traverse(node)];
        })];
      case 'pre-unop':
        if (node[1] === '!') {
          return ['unary-prefix', '!', runtime('toBoolean', [node[2]])];
        }

        if (node[1] === '+' || node[1] === '-') {
          return ['unary-prefix', node[1], runtime('toNumber', [node[2]])];
        }

        if (node[2][0] === 'name') {
          return traverse([
            'assign', node[2],
            ['binop', node[1].slice(1), node[2], ['number', 1]]
          ]);
        } else if (node[2][0] === 'member') {
          return runtime('math.prefixUnop', [
            ['string', node[1]],
            node[2][1],
            node[2][2][0] === 'property' ?
                ['string', node[2][2][1]]
                :
                node[2][2]
          ]);
        }
        return ['unary-prefix', node[1], traverse(node[2])];
      case 'post-unop':
        if (node[2][0] === 'name') {
          // (tmp = a), ++a, tmp
          return [
            'seq',
            ['assign', true, ['name', '$$tmp'], node[2]],
            [
              'seq',
              traverse(['pre-unop', node[1], node[2]]),
              ['name', '$$tmp']
            ]
          ];
        } else if (node[2][0] === 'member') {
          return runtime('math.postfixUnop', [
            ['string', node[1]],
            node[2][1],
            node[2][2][0] === 'property' ?
                ['string', node[2][2][1]]
                :
                node[2][2]
          ]);
        }
        return ['unary-postfix', node[1], traverse(node[2])];
      case 'binop':
        if (node[1] === '||' || node[1] === '&&') {
          // Inline op
          return ['binary', node[1], traverse(node[2]), traverse(node[3])];
        } else {
          // Call runtime
          return runtime('math.binary', [
            ['string', node[1]],
            node[2],
            node[3]
          ]);
        }
      case 'assign':
        // Handle property set
        if (node[1][0] === 'member') {
          if (node[1][2][0] === 'property') {
            return runtime('setProperty', [
              node[1][1],
              ['string', node[1][2][1]],
              node[2]
            ]);
          } else {
            return runtime('setProperty', [
              node[1][1],
              node[1][2],
              node[2]
            ]);
          }
        }
        return ['assign', true, traverse(node[1]), traverse(node[2])];
      case 'member':
        if (node[2][0] === 'property') {
          return runtime('getProperty', [node[1], ['string', node[2][1]]]);
        } else {
          return runtime('getProperty', [node[1], node[2]]);
        }
      case 'call':
        // TODO: Handle vararg
        return runtime('call', [node[1], ['array', node[2]]]);
      case 'colonCall':
        // TODO: Handle vararg
        return runtime('colonCall', [
          node[1][1], // host object
          node[1][2], // property
          ['array', node[2]]
        ]);
      case 'function':
        // TODO: Handle vararg
        var fn = [
          'function',
          null,
          node[2].map(function(node) {
            return node[1];
          }),
          node[3].map(traverse)
        ];

        fn = runtime('markFunction', [fn], true);

        if (node[1] !== null) {
          return ['assign', true, node[1], fn];
        } else {
          return fn;
        }
      case 'object':
        return [
          'object',
          node[1].map(function(kv) {
            if (kv[0][1][0] === 'property') {
              return [['name', kv[0][1][1]], traverse(kv[1])];
            }
            return [kv[0][1], traverse(kv[1])];
          })
        ];
      case 'array':
        return [ 'array', node[1].map(traverse) ];
      case 'typeof':
      case 'keysof':
      case 'sizeof':
      case 'clone':
        return runtime(node[0], [node[1]]);
      case 'delete':
        return ['unary-prefix', 'delete', traverse(node[1])];
      default:
        throw new Error('Unexpected node: ' + util.inspect(node));
    }
  }