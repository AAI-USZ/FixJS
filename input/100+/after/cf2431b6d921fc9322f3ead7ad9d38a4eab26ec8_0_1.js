function(a){var c="";switch(a){case osg.ShaderGeneratorType.VertexInit:c="\nvarying vec3 FragNormal;\nvarying vec3 FragEyeVector;\n\n";
break;case osg.ShaderGeneratorType.VertexFunction:c="\nvec3 computeNormal() {\n   return vec3(NormalMatrix * vec4(Normal, 0.0));\n}\n\nvec3 computeEyeVertex() {\n   return vec3(ModelViewMatrix * vec4(Vertex,1.0));\n}\n\n";break;case osg.ShaderGeneratorType.VertexMain:c="\n  FragEyeVector = computeEyeVertex();\n  FragNormal = computeNormal();\n";break;case osg.ShaderGeneratorType.FragmentInit:c="varying vec3 FragNormal;\nvarying vec3 FragEyeVector;\nvec4 LightColor = vec4(0.0);\n";break;case osg.ShaderGeneratorType.FragmentFunction:c=
"\nfloat getLightAttenuation(vec3 lightDir, float constant, float linear, float quadratic) {\n    \n    float d = length(lightDir);\n    float att = 1.0 / ( constant + linear*d + quadratic*d*d);\n    return att;\n}\nvec4 computeLightContribution(vec4 materialEmission,\n                              vec4 materialAmbient,\n                              vec4 materialDiffuse,\n                              vec4 materialSpecular,\n                              float materialShininess,\n                              vec4 lightAmbient,\n                              vec4 lightDiffuse,\n                              vec4 lightSpecular,\n                              vec3 normal,\n                              vec3 eye,\n                              vec3 lightDirection,\n                              vec3 lightSpotDirection,\n                              float lightCosSpotCutoff,\n                              float lightCosSpotCutoffEnd,\n                              float lightAttenuation)\n{\n    vec3 L = lightDirection;\n    vec3 N = normal;\n    float NdotL = max(dot(L, N), 0.0);\n    float halfTerm = NdotL;\n    //halfTerm *= halfTerm;\n    vec4 ambient = lightAmbient;\n    vec4 diffuse = vec4(0.0);\n    vec4 specular = vec4(0.0);\n    float spot = 0.0;\n\n    if (NdotL > 0.0) {\n        vec3 E = eye;\n        vec3 R = reflect(-L, N);\n        float RdotE = pow( max(dot(R, E), 0.0), materialShininess );\n\n        vec3 D = lightSpotDirection;\n        spot = 1.0;\n        if (lightCosSpotCutoff > 0.0) {\n          float cosCurAngle = dot(L, D);\n          float cosInnerMinusOuterAngle = lightCosSpotCutoff - lightCosSpotCutoffEnd;\n\n          spot = clamp((cosCurAngle - lightCosSpotCutoffEnd) / cosInnerMinusOuterAngle, 0.0, 1.0);\n        }\n        diffuse = lightDiffuse * ((halfTerm));\n        specular = lightSpecular * RdotE;\n    }\n\n    return materialEmission + (materialAmbient*ambient + (materialDiffuse*diffuse + materialSpecular*specular) * spot) * lightAttenuation;\n}\nfloat linearrgb_to_srgb1(float c)\n{\n  float v = 0.0;\n  if(c < 0.0031308) {\n    if ( c > 0.0)\n      v = c * 12.92;\n  } else {\n    v = 1.055 * pow(c, 1.0/2.4) - 0.055;\n  }\n  return v;\n}\nvec4 linearrgb_to_srgb(vec4 col_from)\n{\n  vec4 col_to;\n  col_to.r = linearrgb_to_srgb1(col_from.r);\n  col_to.g = linearrgb_to_srgb1(col_from.g);\n  col_to.b = linearrgb_to_srgb1(col_from.b);\n  col_to.a = col_from.a;\n  return col_to;\n}\n";
break;case osg.ShaderGeneratorType.FragmentMain:c="\n  vec3 normal = normalize(FragNormal);\n  vec3 eyeVector = normalize(-FragEyeVector);\n";break;case osg.ShaderGeneratorType.FragmentEnd:c="\n  fragColor *= LightColor;\n"}return c}