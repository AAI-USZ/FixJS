function ( ) { var validators = hd . validators ; hd . binders [ "number" ] = function bindNumber ( view , options ) { if ( typeof options !== "object" ) options = { value : options } ; if ( ! options . toModel ) options . toModel = validators . toNum ( ) ; if ( ! options . toView ) options . toView = validators . toString ( ) ; hd . binders [ "textbox" ] ( view , options ) ; } }
function ( bus ) { this . destinations . push ( bus ) ; if ( bus === Gibberish . MASTER ) { Gibberish . connect ( this ) ; } else { bus . connectUgen ( this , 1 ) ; } this . dirty = true ; Gibberish . dirty = true ; }
function ( variable , amount ) { console . log ( "CONNECTING" ) ; amount = isNaN ( amount ) ? 1 : amount ; this . senders . push ( { type : "*" , operands : [ variable , amount ] } ) ; variable . destinations . push ( this ) ; this . dirty = true ; Gibberish . dirty = true ; }
function ( ugen ) { for ( var i = 0 ; i < this . senders . length ; i ++ ) { if ( this . senders [ i ] . operands [ 0 ] === ugen ) { this . senders . splice ( i , 1 ) ; this . senders . dirty = true ; break ; } } this . dirty = true ; Gibberish . dirty = true ; }
function ( name , modulator , type ) { var type = type || "+" ; var m = { type : type , operands : [ this [ name ] , modulator ] , name : name } ; this [ name ] = m ; modulator . modding . push ( { ugen : this , mod : m } ) ; this . mods . push ( m ) ; Gibberish . generate ( this ) ; Gibberish . dirty = true ; this . dirty = true ; return modulator ; }
function ( ) { var mod = this . mods . get ( arguments [ 0 ] ) ; delete this [ mod . name ] ; this . mods . remove ( mod ) ; var val = mod . operands [ 0 ] ; this [ mod . name ] = val ; Gibberish . defineProperties ( this , [ "frequency" ] ) ; Gibberish . generate ( this ) ; Gibberish . dirty = true ; this . dirty = true ; }
function ( decoded ) { that . buffer = decoded . channels [ 0 ] ; that . bufferLength = decoded . length ; that . _function = Gibberish . make [ "Sampler" ] ( that . buffer ) ; window [ that . name ] = that . _function ; Gibberish . dirty = true ; that . dirty = true ; }
function ( ) { $ ( this . el ) . bind ( 'pagebeforeshow' , this . render ) ; $ ( this . el ) . find ( '.save' ) . click ( this . save ) ; }
function ( map , opt_force ) { var _this = this ; this . map = map ; this . forEach ( function ( feature ) { return feature . setMap ( _this . map , opt_force ) ; } ) ; return this . handleMapEvents ( ) ; }
function isStrictCompletion ( inputValue , completion ) { inputValue = inputValue . replace ( /^\s*/ , '' ) ; return completion . indexOf ( inputValue ) === 0 ; }
function drawGDO ( g2 , gdo ) { for ( var r = 0 ; r < gdo . divider ; r ++ ) { for ( var c = 0 ; c < gdo . divider ; c ++ ) { drawLines ( g2 , gdo . edgeSquares [ r ] [ c ] . edges ) ; } } }
function stateIsValid ( state , obstacles ) { if ( ! ( state . p . x > 0 && state . p . x < CANVAS_WIDTH && state . p . y > 0 && state . p . y < CANVAS_HEIGHT ) ) return false ; for ( var i = 0 ; i < obstacles . length ; i ++ ) { if ( pointInPoly ( state . p , obstacles [ i ] ) ) { return false ; } } return true ; }
function ( idx , value ) { console . log ( 'restoring block %s' , idx ) ; var block = Block ( value ) ; workspace . append ( block ) ; block . css ( { position : 'relative' , left : 0 , top : 0 , display : 'block' } ) ; block . trigger ( 'add_to_workspace' ) ; $ ( '.scripts_workspace' ) . trigger ( 'add' ) ; }
function ( result ) { result . file = result . file . replace ( /^\.\// , '' ) ; if ( ! files [ result . file ] ) { files [ result . file ] = [ ] ; } files [ result . file ] . push ( { severity : 'error' , line : result . line , column : result . character , message : result . reason , source : result . raw } ) ; }
function ( x , y , username ) { this . x = x ; this . y = y ; this . username = username ; this . sessionId = sessionId ; }
function ( event ) { var title = $ ( '#new_question_title' ) . val ( ) ; var body = $ ( '#new_question_body' ) . val ( ) ; if ( user_id && title && body ) { rqra . createQuestion ( title , body , function ( data ) { if ( data ) { if ( data . errorcode === 0 ) { $ ( '#error' ) . text ( 'OK OK REFRESH NOW' ) ; } } else { $ ( '#error' ) . text ( 'CANNOT CONNECT TO DATABASE' ) ; } } ) } }
function ( ) { var mouse = g . input . mouse ; var x = mouse . X - this . left - parseInt ( $ ( '#origins' ) . css ( 'left' ) ) ; var y = mouse . Y - this . top - parseInt ( $ ( '#origins' ) . css ( 'top' ) ) ; if ( this . clickMap [ x ] [ y ] == 1 ) { if ( mouse . click ) { this . clicked = true ; } return true ; } return false ; }
function ( key , block ) { if ( this . has ( key ) ) { return this . _values [ key ] ; } else { if ( block === undefined ) return null ; if ( isFunction ( block ) ) { return block ( ) ; } else { return block ; } } }
function ( index , key , value ) { if ( this . has_key ( key ) ) { throw "Key[" + key + "] already exists" ; } ; this . _keys . splice ( index , 0 , value ) ; this . _values [ key ] = value ; this . length ++ ; }
function iterateOverObject ( obj , fn ) { var key ; for ( key in obj ) { if ( ! hasOwnProperty ( obj , key ) ) continue ; fn . call ( obj , key , obj [ key ] ) ; } }
function ( d , loc , n , format ) { var str = loc [ '12hr' ] [ d . getHours ( ) / 12 | 0 ] ; if ( format . length === 1 ) str = str . first ( ) ; if ( format . first ( ) === 'T' ) str = str . toUpperCase ( ) ; return str ; }
function ( u , i ) { var value = set [ u . unit ] , fraction = value % 1 ; if ( fraction ) { set [ DateUnitsReversed [ i ] . unit ] = ( fraction * ( u . unit === 'second' ? 1000 : 60 ) ) . round ( ) ; set [ u . unit ] = value | 0 ; } }
function ( u ) { var isDay = u . unit === 'day' ; if ( paramExists ( u . unit ) || ( isDay && paramExists ( 'weekday' ) ) ) { params . specificity = u . unit ; return false ; } else if ( reset && u . unit !== 'week' && ( ! isDay || ! paramExists ( 'week' ) ) ) { callDateMethod ( d , 'set' , utc , u . method , ( isDay ? 1 : 0 ) ) ; } }
function getAdjustedUnit ( ms ) { var next , ams = ms . abs ( ) , value = ams , unit = 0 ; DateUnitsReversed . slice ( 1 ) . forEach ( function ( u , i ) { next = ( ams / u . multiplier ( ) * 10 ) . round ( ) / 10 | 0 ; if ( next >= 1 ) { value = next ; unit = i + 1 ; } } ) ; return [ value , unit , ms ] ; }
function ( iso ) { var offset = this . utc ? 0 : this . getTimezoneOffset ( ) ; var colon = iso === true ? ':' : '' ; if ( ! offset && iso ) return 'Z' ; return ( - offset / 60 ) . round ( ) . pad ( 2 , true ) + colon + ( offset % 60 ) . pad ( 2 ) ; }
function runReplacements ( word , table ) { var matched = false ; table . forEach ( function ( inflection ) { if ( ! matched && word . match ( inflection . rule ) ) { word = word . replace ( inflection . rule , inflection . replacement ) ; matched = true ; } } ) ; return word ; }
function ( place , sign , base ) { var num = this , str = num . abs ( ) . toString ( base || 10 ) ; str = repeatString ( place - str . replace ( /\.\d+/ , '' ) . length , '0' ) + str ; if ( sign || num < 0 ) { str = ( num < 0 ? '-' : '+' ) + str ; } return str ; }
function ( w ) { chrome . tabs . getSelected ( w . id , function ( tab ) { d . callback ( tab ) ; } ) ; }
function ok ( tab ) { var ary ; if ( that . queue . length !== 0 ) { ary = that . queue ; that . queue = [ ] ; ary . push ( url ) ; } else { ary = [ url ] ; } var code = '(' + executor . toString ( ) + '(' + JSON . stringify ( ary ) + ')())' ; chrome . tabs . executeScript ( tab . id , { code : code } , function ( ) { } ) ; }
function ( event , notification ) { if ( widget . options . removeLocalstorageOnIgnore ) { _ . each ( restorables , function ( instance ) { widget . _removeLocal ( instance ) ; } ) ; } notification . close ( ) ; restorables = [ ] ; }
function ( event , notification ) { if ( widget . options . removeLocalstorageOnIgnore ) { _ . each ( restorables , function ( instance ) { widget . _removeLocal ( instance ) ; } ) ; } notification . close ( ) ; restorables = [ ] ; }
function calibrator ( value ) { fs . unlinkSync ( "unit_" + id . toString ( ) + ".json" ) console . log ( "Deleted old calibration table" ) res_table = "null" rfixed = parseFloat ( value ) calibrate = false counter = 0 calloop = 0 queuer . push ( "R0255" ) setTimeout ( function ( ) { calibrate = true } , 100 ) }
function ( $rootScope ) { var old$on = $rootScope . prototype . $on ; $rootScope . protoype . $on = function ( name , listener ) { if ( name . length > 3 && name . substr ( 0 , 3 ) === 'ss-' ) { ss . event . on ( name , function ( message ) { scope . $apply ( function ( ) { scope . $broadcast ( name , message ) ; } ) ; } ) ; } old$on . apply ( this , arguments ) ; } ; }
function ( value ) { var year = value . substring ( 0 , 4 ) ; var month = value . substring ( 5 , 7 ) - 1 ; var day = value . substring ( 8 , 10 ) ; var dateValue = new Date ( year , month , day , 0 , 0 , 0 , 0 ) ; return Globalize . format ( dateValue , "d" ) ; }
function ( value ) { if ( value != null && typeof ( value ) != 'undefined' ) { value = value . substring ( 0 , 10 ) ; } this . $editor . datepicker ( "setDate" , value ) ; }
function ( data ) { selectedData . collectionItems = data . results ; sakai . api . Util . TemplateRenderer ( "collectionviewer_list_item_template" , { data : selectedData , sakai : sakai , collectionName : getCollectionName ( ) , collectionId : sakai . api . Content . Collections . getCollectionPoolId ( collectionviewer . contextId ) , isManager : sakai . api . Content . Collections . canCurrentUserManageCollection ( collectionviewer . contextId ) } , $ ( "#collectionviewer_expanded_content_container" , $rootel ) ) ; sakai . api . Widgets . widgetLoader . insertWidgets ( tuid ) ; }
function ( parsedContent ) { collectionData [ ( collectionviewer . page - 1 ) ] = parsedContent ; showData ( ) ; }
function ( ) { if ( $ ( ".collectionviewer_check:checked:visible" ) . length ) { $ ( "#collections_remove_button" ) . removeAttr ( "disabled" ) ; $ ( "#collections_savecontent_button" ) . removeAttr ( "disabled" ) ; } else { $ ( "#collections_remove_button" ) . attr ( "disabled" , true ) ; $ ( "#collections_savecontent_button" ) . attr ( "disabled" , true ) ; $ ( "#collectionviewer_select_all" ) . removeAttr ( "checked" ) ; } updateButtonData ( ) ; }
function ( i , item ) { idArr . push ( $ ( item ) . attr ( "data-entityid" ) ) ; titleArr . push ( $ ( item ) . attr ( "data-entityname" ) ) ; }
function ( ) { var idArr = [ ] ; var titleArr = [ ] ; $ ( ".collectionviewer_check:checked:visible" ) . each ( function ( i , item ) { idArr . push ( $ ( item ) . attr ( "data-entityid" ) ) ; titleArr . push ( $ ( item ) . attr ( "data-entityname" ) ) ; } ) ; $ ( "#collections_savecontent_button" ) . attr ( "data-entityid" , idArr ) ; $ ( "#collections_savecontent_button" ) . attr ( "data-entityname" , titleArr ) ; }
function ( data ) { collectionviewer . listStyle = $ . bbq . getState ( "ls" ) || "list" ; $ ( "#collectionviewer_add_content_button > div" ) . text ( data . total ) ; collectionviewer . total = data . total ; collectionData [ pageNumber ] = data . results ; renderGridOrList ( false , true ) ; sakai . api . Util . progressIndicator . hideProgressIndicator ( ) ; }
function ( ) { $ . bbq . pushState ( { "ls" : "list" , "lp" : collectionviewer . page , "item" : "" } ) ; fetchCollectionData = true ; }
function ( ) { $ ( this ) . hide ( ) ; $ ( "#collectionviewer_edit_collection_button" , $rootel ) . show ( ) ; $ . bbq . pushState ( { "ls" : "carousel" } ) ; }
function ( ) { if ( $ ( this ) . is ( ":checked" ) ) { $ ( ".collectionviewer_check:visible" ) . attr ( "checked" , true ) ; } else { $ ( ".collectionviewer_check:visible" ) . removeAttr ( "checked" ) ; } checkEditingEnabled ( ) ; }
function ( success ) { sakai . api . Util . progressIndicator . showProgressIndicator ( sakai . api . i18n . getValueForKey ( "REMOVING_CONTENT_FROM_COLLECTION" , "collectionviewer" ) , sakai . api . i18n . getValueForKey ( "PROCESSING" , "collectionviewer" ) ) ; $ ( ".collectionviewer_check:checked:visible" ) . parents ( "li" ) . hide ( "slow" ) ; setTimeout ( refreshCollection , 1500 ) ; }
function ( responseData , success ) { if ( success ) { $ ( window ) . trigger ( "updateContentActivity.entity.sakai" , "CONTENT_ADDED_COMMENT" ) ; if ( ! rootel . parents ( ".collectionviewer_collection_item_comments" ) . length ) { $ ( window ) . trigger ( "sakai.entity.updatecountcache" , { increment : true } ) ; } } }
function render ( target , repos ) { var i = 0 , fragment = '' , t = $ ( target ) [ 0 ] ; for ( i = 0 ; i < repos . length ; i ++ ) { fragment += '<li><a href="' + repos [ i ] . url + '">' + repos [ i ] . name + '</a><p>' + repos [ i ] . description + '</p></li>' ; } t . innerHTML = fragment ; }
function onLocationDetected ( ok , e ) { if ( e ) { console . log ( 'onLocationDetected :: ' + e ) ; } else { drawISPList ( ) ; map . setLocation ( { isp : isp , status : status , lat : loc . lat , lng : loc . lng } ) ; return ; if ( ! initialized ) { map . getMarkers ( ) ; mdl . setLocation ( loc . city , loc . state , isps ) ; initialized = true ; } } }
function ( force ) { if ( ! force && this . options . promptOnCancel && this . dirty ( ) ) { if ( confirm ( "You have unsaved changes. Are you " + "sure you want to discard them?" ) ) { this . cancel ( true ) ; } return ; } this . hideEditor ( ) ; this . element . triggerHandler ( "cancel" , [ this . _initialValue ] ) ; }
function ( errorText , xhrError ) { if ( typeof ( xhrError === "object" ) ) { var responseText = dojo . fromJson ( xhrError . xhr . response ) ; error ( responseText . error ) ; } else { error ( errorText || "undefined error" ) ; } }
function ( selector , interval , repeat , delay ) { interval = interval || 0 ; cc . Assert ( selector , "Argument must be non-nil" ) ; cc . Assert ( interval >= 0 , "Argument must be positive" ) ; repeat = repeat || cc . REPEAT_FOREVER ; delay = delay || 0 ; this . getScheduler ( ) . scheduleSelector ( selector , this , interval , ! this . _isRunning , repeat , delay ) ; }
function ( ) { this . _super ( ) ; this . centerSprites ( 1 ) ; var action = cc . Sequence . create ( cc . MoveBy . create ( 2.0 , cc . ccp ( 200 , 0 ) ) , cc . CallFunc . create ( this . _grossini , this . removeFromParentAndCleanup , true ) , null ) ; this . _grossini . runAction ( action ) ; }
function ( frameName ) { goog . net . xpc . logger . finest ( 'checking for receive frame: ' + frameName ) ; try { var winObj = this . channel_ . getPeerWindowObject ( ) . frames [ frameName ] ; if ( ! winObj || winObj . location . href . indexOf ( this . rcvUri_ ) != 0 ) { return false ; } } catch ( e ) { return false ; } return true ; }
function ( ) { var values = $form . serializeArray ( ) ; $form . find ( "input[type='datetime-local']" ) . each ( function ( ) { var $i = $ ( this ) ; values . push ( { name : $i . attr ( "name" ) , value : $i . val ( ) } ) ; } ) ; localStorage . setObject ( opts . objName , values ) ; }
function ( ) { if ( xmlhttp . readyState == 4 && xmlhttp . status == 200 ) { var json = xmlhttp . responseText ; json = eval ( '(' + json + ')' ) ; print_resolvers ( json ) ; } }
function ( ) { var fileCount = 0 ; for ( var x in editor . getFiles ( ) ) { fileCount ++ ; } expect ( fileCount ) . to ( be , 3 ) ; }
function ( ) { $ ( this ) . css ( { position : 'absolute' , left : '0px' , right : '0px' , top : '0px' , bottom : '0px' } ) ; this . callSuper ( 'init' ) ; this . invalidateSize ( ) ; var target = this ; this . callTick = function ( ) { target . tick ( ) ; } $ ( window ) . bind ( 'resize' , $ . proxy ( function ( ) { this . invalidateSize ( ) ; } , this ) ) ; }
function ( ) { this . callSuper ( 'createAttributes' ) ; this . createAttribute ( 'paddingLeft' , '0' ) ; this . createAttribute ( 'paddingRight' , '0' ) ; this . createAttribute ( 'paddingTop' , '0' ) ; this . createAttribute ( 'paddingBottom' , '0' ) ; }
function ( err , contents ) { if ( err ) { if ( err . code == 'ENOENT' ) { wwenc ( self . socket , "550 Not Found\r\n" ) ; } else { wwenc ( self . socket , "550 Not Accessible\r\n" ) ; self . _traceIf ( 0 , "Error at read other than ENOENT " + err , self ) ; } } else { if ( pasvconn . readyState == 'open' ) pasvconn . write ( contents ) pasvconn . end ( ) ; wwenc ( self . socket , "226 Closing data connection, sent " + self . totsize + " bytes\r\n" ) ; } }
function ( node ) { var dp = self . getPanel ( node . registration ( ) . divisionId ( ) ) ; var panels = ko . toJS ( self . panels ) ; var index = _ . indexOf ( panels , dp ( ) ) + 1 ; var result = panels [ index ] || panels [ 0 ] ; dp ( result ) ; }
function ( n ) { var $this = $ ( this ) , opts = $this . data ( datakey ) ; if ( ! $ . isObject ( opts ) ) return ; if ( opts . link_class ) $this . removeClass ( opts . link_class ) ; if ( opts . span_class ) $this . children ( '.' + opts . span_class ) . remove ( ) ; $this . attr ( 'target' , opts . orig_target ? opts . orig_target : null ) ; }
function fixlatinv ( n ) { return ( n > 90 ? n - 90 : n - 90 ) ; }
function ( ) { var elm = $ ( this ) ; var responseName = elm . attr ( 'rel' ) ; if ( elm . hasClass ( 'normal' ) ) formResponseMngr . addResponseToSelectOneFilter ( responseName ) ; else formResponseMngr . removeResponseFromSelectOneFilter ( responseName ) ; formResponseMngr . callback = filterSelectOneCallback ; fields = getBootstrapFields ( ) ; formResponseMngr . loadResponseData ( { } , 0 , null , fields ) ; formResponseMngr . loadResponseData ( { } ) ; refreshHexOverLay ( ) ; }
function getBootstrapFields ( ) { var fields = [ ] ; var idx , question ; if ( ! constants ) throw "ERROR: constants not found; please include main/static/js/formManagers.js" ; for ( idx in formJSONMngr . selectOneQuestions ) { question = formJSONMngr . selectOneQuestions [ idx ] ; fields . push ( question [ constants . NAME ] ) ; } for ( idx in formJSONMngr . geopointQuestions ) { question = formJSONMngr . geopointQuestions [ idx ] ; fields . push ( question [ constants . NAME ] ) ; } return fields ; }
function ( ) { $ ( '#handPhone' ) . animate ( { opacity : 1 , bottom : '-950' , left : '590px' , width : '492px' } , 3000 , function ( ) { $ ( '.phoneSlideshowSmall' ) . fadeIn ( ) ; phonesmall = 1 ; } ) ; }
function ( e ) { return e . nextSibling ; }
function getSpanVal ( td , name ) { return parseInt ( td . getAttribute ( name ) || 1 ) ; }
function ( arr , type ) { if ( arr && arr . length > 0 ) { for ( var i = 0 ; i < arr . length ; i ++ ) { if ( ! ( arr [ i ] instanceof type ) ) { cc . Log ( "element type is wrong!" ) ; return false ; } } } }
function ( connParams , options ) { options = options || { } ; var client = new Client ( connParams , options ) ; client . connect ( ) ; this . Base = new Base ( client ) ; this . client = client ; this . options = options ; return this ; }
function addConstraint ( cc , strength ) { var ccc = cc . inner ; if ( ! ccc ) { if ( strength === undefined ) strength = Strength . REQUIRED ; ccc = new Solver . Constraint ( cc , strength ) ; this . constraints . push ( ccc ) ; if ( strength === Strength . REQUIRED ) { this . unenforcedCnsQueue . push ( ccc ) ; } LOG ( cc + " added to constraint graph." ) ; } return ccc ; }
function writeFocused ( view , truthy ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; if ( truthy ) { if ( ! view . is ( ":focus" ) ) view . focus ( ) ; } else { if ( view . is ( ":focus" ) ) view . blur ( ) ; } }
function bindTextbox ( view , options ) { var hdtSaved = HOTDRINK_DEBOUNCE_THRESHOLD ; if ( typeof options === "object" ) { var value = options . value ; if ( options . debounce ) HOTDRINK_DEBOUNCE_THRESHOLD = options . debounce ; } else { var value = options ; } subbind ( view , value ) ; HOTDRINK_DEBOUNCE_THRESHOLD = hdtSaved ; }
function bind ( model , elts ) { if ( ! elts ) elts = $ ( 'body' ) ; if ( ! ( elts instanceof jQuery ) ) elts = $ ( elts ) ; LOG ( "Binding " + elts . attr ( "id" ) ) ; subbind ( elts , model ) ; }
function precondition ( commands , fn ) { if ( ! Array . isArray ( commands ) ) commands = [ commands ] ; commands = commands . map ( function ( proxy ) { ASSERT ( hd . isCommand ( proxy ) , "expected precondition to guard command" ) ; return proxy . unwrap ( ) ; } ) ; var vv = factory . addComputedVariable ( "precondition" , fn ) ; vv . guarded = commands ; }
function constraint ( variables ) { if ( ! variables ) variables = [ ] ; if ( ! Array . isArray ( variables ) ) variables = [ variables ] ; variables = variables . map ( function ( proxy ) { ASSERT ( hd . isVariable ( proxy ) , "expected variable as subject of constraint" ) ; return proxy . unwrap ( ) ; } ) ; return new ConstraintFactory ( variables ) ; }
function ( err , res , body ) { try { if ( typeof body === 'string' ) { body = JSON . parse ( body ) ; } } catch ( e ) { return callback ( e ) ; } if ( body . errors ) return callback ( body . errors ) ; return callback ( null , body ) ; }
function ( entry ) { var id = getRegistrationId ( entry . registrationId ) ; var division = self . registrations [ id ] . divisionId ( ) ; self . divisionPanels [ division ] = self . divisionPanels [ division ] || ko . observable ( entry . panel ) ; }
function ( ) { $submenu = $ ( this ) . children ( 'ul.sub-menu' ) ; if ( ! $submenu . is ( ':visible' ) ) { $submenu . fadeIn ( 75 , function ( ) { $ ( document ) . one ( 'click' , function ( ) { $submenu . fadeOut ( 100 ) ; } ) ; } ) ; } else $submenu . fadeOut ( 100 ) ; return false ; }
function ( key , flag ) { var storage = _selectStorage ( flag ) , selectKey = storage . getItem ( key ) ; if ( typeof key !== 'string' ) { throw new Error ( '1st argument should be strings' ) ; } if ( typeof key === 'string' ) { if ( selectKey ) { return true ; } else { return false ; } } }
function ( ) { if ( ! document . getElementById ( 'cartodb_logo' ) ) { var cartodb_link = document . createElement ( "a" ) ; cartodb_link . setAttribute ( 'id' , 'cartodb_logo' ) ; cartodb_link . setAttribute ( 'style' , "position:absolute; bottom:8px; left:8px; display:block;" ) ; cartodb_link . setAttribute ( 'href' , 'http://www.cartodb.com' ) ; cartodb_link . setAttribute ( 'target' , '_blank' ) ; cartodb_link . innerHTML = "<img src='http://cartodb.s3.amazonaws.com/static/new_logo.png' alt='CartoDB' title='CartoDB' />" ; this . options . map . _container . appendChild ( cartodb_link ) ; } }
function ( feature ) { if ( feature ) { bean . fire ( interaction , 'on' , { parent : parent ( ) , data : feature , formatter : gm . formatter ( ) . format , pos : pos , e : e } ) ; } else { bean . fire ( interaction , 'off' ) ; } }
function ( x , y ) { cp . _reuse_v [ 0 ] = x ; cp . _reuse_v [ 1 ] = y ; return cp . _reuse_v ; }
function ( err , data ) { if ( err ) return cb ( err , null ) ; var widgId = data . app . guid , payload = { type : type , guid : fileId , path : path , name : name , appId : widgId } ; api . doFileCall ( options , "delete" , payload , "Error deleting file: " , cb ) ; }
function ( options , appId , target , cb ) { var payload = { payload : { guid : appId , deploytarget : target , action : 'list' } } ; log . verbose ( payload , 'Listing logs' ) ; api . doAppCall ( options , "logs" , payload , "Error getting logs: " , cb ) ; }
function ( appId , logName , target , cb ) { var payload = { payload : { guid : appId , deploytarget : target , logname : logName , action : 'get' } } ; log . verbose ( payload , 'Getting logs' ) ; api . doAppCall ( options , "logs" , payload , "" , cb ) ; }
function ( options , appId , logName , target , cb ) { var payload = { payload : { guid : appId , deploytarget : target , action : 'delete' , logname : logName } } ; log . verbose ( payload , 'Deleting log' ) ; api . doAppCall ( options , "logs" , payload , "Error deleting log: " , cb ) ; }
function ( ) { if ( ! elm . hasClass ( 'fixed' ) && window . pageYOffset > attrs . uiScrollfix ) { elm . addClass ( 'fixed' ) ; } else if ( elm . hasClass ( 'fixed' ) && window . pageYOffset < attrs . uiScrollfix ) { elm . removeClass ( 'fixed' ) ; } }
function ( ) { if ( ! elm . hasClass ( 'fixed' ) && window . pageYOffset > attrs . uiScrollfix ) { elm . addClass ( 'fixed' ) ; } else if ( elm . hasClass ( 'fixed' ) && window . pageYOffset < attrs . uiScrollfix ) { elm . removeClass ( 'fixed' ) ; } }
function ( user ) { this . append ( user + ' disconnected.' ) ; users . fetch ( ) ; }
function ( collection , query , event , data ) { if ( arguments . length === 4 ) { session . emitToUsers ( collection , query , event , data ) ; } else if ( arguments . length === 2 ) { event = collection ; data = query ; session . emitToAll ( event , data ) ; } }
function ( element ) { element . delay ( 5000 ) . animate ( { top : 0 } , 3000 , "easeInBounce" ) . promise ( ) . pipe ( function ( ) { element . delay ( 2000 ) . animate ( { top : - element . height ( ) } ) ; } ) . promise ( ) . pipe ( function ( ) { start_animation ( element ) ; } ) ; }
function ( accessToken , instanceUrl , userIdentityUrl , success , error , complete ) { var url = getBaseUrl ( ) + '/services/apexrest/oauth2/prepareSession' ; var data = 'accessToken=' + accessToken + '&instanceUrl=' + instanceUrl + '&identityUrl=' + userIdentityUrl ; this . ajax ( 'POST' , url , data , success , error , complete ) ; }
function ( accessToken , instanceUrl , userIdentityUrl , success , error , complete ) { var url = getBaseUrl ( ) + '/services/apexrest/oauth2/prepareSession' ; var data = 'accessToken=' + accessToken + '&instanceUrl=' + instanceUrl + '&identityUrl=' + userIdentityUrl ; this . ajax ( 'POST' , url , data , success , error , complete ) ; }
function ( options ) { try { options . element = document . id ( options . element ) || options . element ; if ( options . element === null ) { throw ( "DOM object not found" ) ; } } catch ( e ) { if ( console ) { console . log ( e ) ; } throw e ; } if ( ! options . element . getProperty ( "multiple" ) ) { return new StyleSelect . Simple ( options ) ; } else { return new StyleSelect . Multiple ( options ) ; } }
function ( newVal , oldVal , scope ) { if ( newVal === prevVal ) { return ; } if ( loaded ) { initialize ( newVal ) ; if ( attrs . multiple !== undefined && ! newVal ) { elm . select2 ( 'val' , '' ) ; } } prevVal = newVal ; }
function ( newVal , oldVal , scope ) { if ( newVal === prevVal ) { return ; } if ( loaded ) { initialize ( newVal ) ; if ( attrs . multiple !== undefined && ! newVal ) { elm . select2 ( 'val' , '' ) ; } } prevVal = newVal ; }
function ( ) { this . h = new konoha . kObjectHeader ( ) ; this . packid = null ; this . pakdom = null ; this . parentNULL = null ; this . fmat = null ; this . syntaxMapNN = null ; this . gluehdr = null ; this . scrNUL = new konoha . kObject ( ) ; this . static_cid = null ; this . function_cid = null ; this . methods = new konoha . kArray ( ) ; this . cl = null ; }
function ( ) { for ( var i = 0 ; i < typewriter . getCharacters ( ) . length ; i ++ ) { var char = typewriter . getCharacters ( ) . charAt ( i ) ; var entry = '' ; entry += '<tr id="status_' + char + '">' ; entry += '</tr>' ; $ ( "#statusbar_table" ) . append ( entry ) ; this . updateStatus ( char ) ; } }
function ( ) { console . log ( "I'm a new comment!" ) ; var m = new Comment ( { } ) ; this . model . get ( "comments" ) . add ( m ) ; }
function $A ( iterable ) { if ( ! iterable ) return [ ] ; if ( 'toArray' in Object ( iterable ) ) return iterable . toArray ( ) ; var length = iterable . length || 0 , results = new Array ( length ) ; while ( length -- ) results [ length ] = iterable [ length ] ; return results ; }
function merge ( array , args ) { array = slice . call ( array , 0 ) ; return update ( array , args ) ; }
function argumentNames ( ) { var names = this . toString ( ) . match ( /^[\s\(]*function[^(]*\(([^)]*)\)/ ) [ 1 ] . replace ( /\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g , '' ) . replace ( /\s+/g , '' ) . split ( ',' ) ; return names . length == 1 && ! names [ 0 ] ? [ ] : names ; }
function ( res ) { clearTimeout ( failSafe ) ; ok ( res , 'The login response has data' ) ; equal ( res . status , 'okay' , 'Login status is "okay"' ) ; ok ( res . email , 'The login has an email: ' + res . email ) ; equal ( res . email , butter . cornfield . user ( ) , "Email is stored" ) ; start ( ) ; }
function ( ) { if ( OPAQUE_BACKGROUND && ( this . _autohide || OPAQUE_BACKGROUND_ALWAYS ) ) { this . _backgroundBox . show ( ) ; this . _fadeInBackground ( ANIMATION_TIME , 0 ) ; } else if ( ! OPAQUE_BACKGROUND || ( ! this . _autohide && ! OPAQUE_BACKGROUND_ALWAYS ) ) { this . _fadeOutBackground ( ANIMATION_TIME , 0 ) ; } }
function ( ) { if ( this . _autohide == true ) { this . _autohide = false ; this . _removeAnimations ( ) ; this . _animateIn ( ANIMATION_TIME , 0 ) ; if ( OPAQUE_BACKGROUND && ! OPAQUE_BACKGROUND_ALWAYS ) this . _fadeOutBackground ( ANIMATION_TIME , 0 ) ; if ( this . _dashShowTimeout > 0 ) Mainloop . source_remove ( this . _dashShowTimeout ) ; } }
function ( notify ) { var positions = this . documentData . positions , selection = { } ; forEachProperty ( this . selection , function ( p , n ) { if ( positions [ n ] ) { selection [ n ] = p ; } } ) ; this . selection = selection ; if ( notify ) { this . emit ( 'selectionChanged' ) ; } }
function ( ) { dojo . subscribe ( "/animwidget/selectObject" , this , "onUpdate" ) ; dojo . subscribe ( "/animwidget/updateObject" , this , "onUpdate" ) ; dojo . subscribe ( "/resourceitem/updateResource" , this , "updateResourceList" ) ; }
function ( e ) { e . preventDefault ( ) ; var newStarredStatus = false ; self . messagesRep [ self . currentConversationId ] . each ( function ( msg ) { msg . set ( "Starred" , ! msg . attributes [ "Starred" ] ) ; newStarredStatus = msg . attributes [ "Starred" ] ; } ) ; $ . getJSON ( 'Messages/ChangeStarredStatusForConversation' , { convID : self . currentConversationId , newStarredStatus : newStarredStatus } , function ( data ) { console . log ( data ) ; } ) ; }
function ( ) { this . transport . config . set ( "url" , this . config . get ( "submissionProxyURL" ) ) ; this . request ( $ . extend ( this . config . get ( "data" ) , { "content" : this . _AS2KVL ( this . config . get ( "data.content" ) ) } ) ) ; }
function expandDirectoryWithRegexp ( directory , regexp ) { var paths = [ ] ; var scannedPaths = findit . sync ( directory ) ; scannedPaths . forEach ( function ( path ) { if ( regexp . test ( path ) ) paths . push ( path ) ; } ) ; return paths ; }
function ( ) { directory = createSpy ( "directory" ) ; regexp = createSpyWithStubs ( "regexp" , { test : null } ) ; innerPaths = [ createSpy ( "inner path 1" ) , createSpy ( "inner path 2" ) , createSpy ( "inner path 3" ) ] ; spyOn ( findit , 'sync' ) . andReturn ( innerPaths ) ; }
function ( ) { if ( attr = this . getAttribute ( opts . attribute ) ) { absolutify . href = attr ; this . setAttribute ( 'x-src' , getImageURL ( absolutify . href , opts ) ) } }
function ( err , reply ) { if ( err ) { var cur = self . queue [ index ] ; if ( typeof cur [ cur . length - 1 ] === "function" ) { cur [ cur . length - 1 ] ( err ) ; } else { throw new Error ( err ) ; } self . queue . splice ( index , 1 ) ; } }
function loadLists ( ) { lists [ - 1 ] = "Herdict Web" ; lists [ 2 ] = "EFF" ; lists [ 3 ] = "Reporters without Borders" ; doneLoadingLists ( ) ; }
function ( test ) { var mp = new ks_macros . MacroProcessor ( { loader_class : ks_test_utils . JSONifyLoader } ) ; processFixture ( test , mp , 'macros-document-double-brace.txt' , function ( errors , result ) { test . ok ( ! errors , "There should be no errors" ) ; test . done ( ) ; } ) ; }
function ( str ) { return str . replace ( /\-/g , '--' ) . replace ( /\%/g , '-A' ) . replace ( /\?/g , '-B' ) . replace ( /\&/g , '-C' ) . replace ( /\:/g , '-D' ) . replace ( /\//g , '-E' ) ; }
function ( str ) { return str . replace ( /\-A/g , '%' ) . replace ( /\-B/g , '?' ) . replace ( /\-C/g , '&' ) . replace ( /\-D/g , ':' ) . replace ( /\-E/g , '/' ) . replace ( /\-\-/g , '-' ) ; }
function ( full , script ) { var flashvars = exports . stripFlashvars ( script ) ; if ( ! flashvars ) return full ; console . log ( flashvars ) ; var flvurl = flashvars . url_encoded_fmt_stream_map . url ; flashvars . flvurl = 'https://ssl.nowall.be/' + utils . encodeSymboUrl ( flvurl ) ; return template . render ( player , flashvars ) ; }
function doneSeeking ( ) { try { var canvas = document . createElement ( 'canvas' ) ; canvas . width = THUMBNAIL_WIDTH ; canvas . height = THUMBNAIL_HEIGHT ; var ctx = canvas . getContext ( '2d' ) ; ctx . drawImage ( testplayer , 0 , 0 , THUMBNAIL_WIDTH , THUMBNAIL_HEIGHT ) ; videodata . poster = canvas . mozGetAsFile ( 'poster' , 'image/jpeg' ) ; } catch ( e ) { console . error ( 'Failed to create a poster image:' , e ) ; } addVideo ( videodata ) ; }
function ( models ) { models . Feeding = Backbone . Model . extend ( { idAttribute : "_id" , defaults : { "_id" : null , "date" : new Date ( ) , "side" : "" , "time" : "" , "excrement" : "P" , "remarks" : "" } , url : '../api/feedings' } ) ; }
function ( row ) { var reTextContent = /ReferenceError\:\s*undefinedVariable is not defined\s*var test = undefinedVariable;\s*issue5525.html\s*\(line 10\)/ ; FBTest . compare ( reTextContent , row . textContent , "Text content must match." ) ; var br = row . getElementsByClassName ( "errorBreak" ) [ 0 ] ; FBTest . click ( br ) ; FBTest . selectPanel ( "script" ) ; var panel = FBTest . selectSidePanel ( "breakpoints" ) ; var panelNode = panel . panelNode ; var rows = panelNode . getElementsByClassName ( "breakpointRow" ) ; FBTest . compare ( rows . length , 1 , "There must be one breakpoint" ) ; FBTest . testDone ( "console.error.DONE" ) ; }
function ( ) { if ( bb . menuBar . menuOpen && ! bb . menuBar . activeClick && ! bb . menuBar . ignoreClick ) { bb . menuBar . hideMenuBar ( ) ; } bb . menuBar . activeClick = false ; bb . menuBar . ignoreClick = false ; }
function ( ) { if ( bb . menuBar . menuOpen && ! bb . menuBar . activeClick && ! bb . menuBar . ignoreClick ) { bb . menuBar . hideMenuBar ( ) ; } bb . menuBar . activeClick = false ; bb . menuBar . ignoreClick = false ; }
function ( ) { if ( bb . menuBar . menuOpen && ! bb . menuBar . activeClick && ! bb . menuBar . ignoreClick ) { bb . menuBar . hideMenuBar ( ) ; } bb . menuBar . activeClick = false ; bb . menuBar . ignoreClick = false ; }
function ( context , tile ) { var tilingScheme = this . tilingScheme ; var ellipsoid = tilingScheme . ellipsoid ; var extent = tile . extent ; var granularity = computeDesiredGranularity ( tilingScheme , tile ) ; var center = tile . get3DBoundingSphere ( ) . center ; var buffers = ExtentTessellator . computeBuffers ( { ellipsoid : ellipsoid , extent : extent , granularity : granularity , generateTextureCoords : true , interleave : true , relativeToCenter : center } ) ; tile . geometry = buffers ; tile . state = TileState . TRANSFORMED ; }
function ( ) { var selector = '.' + name ; $ ( '.chart :not(' + selector + ')' ) . fadeOut ( 'slow' ) ; $ ( '.legend :not(' + selector + ')' ) . fadeOut ( 'slow' ) ; $ ( selector ) . addClass ( 'back' ) . fadeIn ( 'fast' ) . removeClass ( 'back' ) ; if ( name === 'treemap' ) { showTreemap ( metricName ) ; } if ( name === 'toxicity' ) { showToxicity ( ) ; } }
function loadTreemap ( fxcopData , filename ) { var treemapData = treemapDataBuilder ( fxcopData , filename ) ; selection . treemap = d3 . select ( '.treemap' ) . data ( [ treemapData ] ) ; treemap . depth ( dataBuilder . getDepth ( selection . treemap ) ) ; }
function ( tree ) { if ( ! tree . children ) return 0 ; var maxChildDepth = 0 ; for ( var i = 0 ; i < tree . children . length ; i ++ ) { var childDepth = getDepth ( tree . children [ i ] ) ; maxChildDepth = Math . max ( maxChildDepth , childDepth ) ; } return maxChildDepth + 1 ; }
function ( embed , embedReqStatus ) { $ ( '#confabulation' ) . after ( embed . html ) ; }
function ( prop , val ) { if ( ! this . hasOwnProperty ( prop ) ) { return this ; } this [ prop ] = val ; this . emit ( 'update:' + prop , val ) ; return this ; }
function ( e ) { switch ( e . keyCode ) { case 40 : case 74 : e . preventDefault ( ) ; v . hasNext ( ) && v . setScrollPosition ( v . getNext ( ) . $el . offset ( ) . top + 1 ) ; break ; case 38 : case 75 : e . preventDefault ( ) ; v . hasPrev ( ) && v . setScrollPosition ( v . getPrev ( ) . $el . offset ( ) . top - 1 ) ; break ; } }
function ( offset ) { $ ( document ) . scrollTop ( offset ) ; return this ; }
function ( m ) { var _m = require ( '/app/models/' + m . name ) , mName = m . name . toLowerCase ( ) ; models [ mName ] = new _m ( Como ) ; if ( m . truncate ) { models [ mName ] . truncate ( ) ; } }
function ( e ) { clearTimeout ( shipClickable . shipClickableTimer ) ; shipClickable . shipClickableTimer = setTimeout ( shipClickable . doMouseOver , 250 ) ; shipClickable . ship = gamedata . getShip ( $ ( this ) . data ( "id" ) ) ; if ( $ ( this ) . hasClass ( 'shiplistentry' ) ) shipClickable . testStacked = false ; else shipClickable . testStacked = true ; }
function ( ) { animation . animateActiveship ( ) ; if ( animation . animating ) { if ( animation . animationloopdelay > 0 ) { animation . animationloopdelay -- ; } else { animation . animating ( ) ; } } setTimeout ( animation . animationLoop , 30 ) ; }
function ( ship ) { var amount = 0 ; for ( var i in gamedata . ships ) { var elint = gamedata . ships [ i ] ; if ( elint == ship || ! shipManager . isElint ( elint ) ) continue ; var fdew = ew . getEWByType ( "SDEW" , elint , ship ) * 0.5 ; if ( fdew > amount ) amount = fdew ; } return amount ; }
function ( ship ) { var amount = 0 ; for ( var i in gamedata . ships ) { var elint = gamedata . ships [ i ] ; if ( ! shipManager . isElint ( elint ) || ! ew . checkInELINTDistance ( ship , elint , 20 ) ) continue ; var fdew = ew . getEWByType ( "BDEW" , elint ) * 0.25 ; if ( fdew > amount ) amount = fdew ; } return amount ; }
function ( start , end , percentage ) { var x = start . x + percentage * ( end . x - start . x ) ; var y = start . y + percentage * ( end . y - start . y ) ; return { x : x , y : y } ; }
function ( ship , system ) { var d = damageManager . getDamage ( ship , system ) ; var stru = shipManager . systems . getStructureSystem ( ship , system . location ) ; if ( stru && stru != system && shipManager . systems . isDestroyed ( ship , stru ) ) return true ; if ( system . fighter && shipManager . criticals . hasCritical ( system , "DisengagedFighter" ) ) return true ; return ( d >= system . maxhealth ) ; }
function ( ship , location ) { for ( var i in ship . systems ) { if ( ship . systems [ i ] . location == location && ship . systems [ i ] . name == "structure" ) return ship . systems [ i ] ; } return null ; }
function ( track ) { track . center . chart . fetch ( { data : $ . param ( { min : rover . get ( 'min' ) , max : rover . get ( 'max' ) } ) } ) ; }
function ( ) { if ( $ ( '.navigation' ) . length == 0 ) return ; posy = $ ( '.navigation' ) . offset ( ) . top ; wtop = $ ( window ) . scrollTop ( ) ; if ( wtop >= posy ) { $ ( '.navigation' ) . css ( { position : 'fixed' , top : 0 , width : navwidth } ) ; } if ( posy < navtop ) { $ ( '.navigation' ) . css ( { position : 'inherit' } ) ; } }
function ( ) { var theme = this . model . get ( "current_theme" ) ; if ( theme === "default" ) theme = "default-theme" ; $ ( this . getBody ( ) ) . css ( { "color" : this . themes [ theme ] [ "color" ] , "background-color" : this . themes [ theme ] [ "background-color" ] } ) ; this . renderMoPlaying ( ) ; }
function ( ) { this . running = true ; var self = this ; this . loop_id = setInterval ( function ( ) { var cycles = self . cycles ; while ( self . cycles < cycles + 10000 ) { self . run ( self . _read_memory ( self . PC ++ ) ) ; } self . draw ( ) ; if ( ! self . running ) { clearInterval ( self . loop_id ) ; } } , 20 ) ; }
function ( ) { for ( var i = 0 ; i < 65536 ; i ++ ) { this . memory [ i ] = 0 ; } }
function fetch_control_set ( thesaurus ) { if ( ! _acs_cache_by_at [ thesaurus ] ) { var at = pcrud . retrieve ( "at" , thesaurus , { "flesh" : 1 , "flesh_fields" : { "at" : [ "control_set" ] } } ) ; _acs_cache_by_at [ thesaurus ] = at . control_set ( ) ; } return _acs_cache_by_at [ thesaurus ] ; }
function ( ) { var next = self . registry [ this . peers . random ( ) . load ] ; if ( Math . random ( ) < self . reach ) { return next . hop ( ) ; } else { return next ; } }
function ( url ) { if ( fileProtocol || /^\./ . test ( url ) ) { return false ; } if ( /^\/\// . test ( url ) ) { return true ; } var match = url . match ( /^([^\/\:]+\:)\/\/([^\/]+)/ ) ; return match && ( match [ 1 ] != locationProtocol || match [ 2 ] != locationHost ) ; }
function ( params ) { params . context = Echo . Events . _initContext ( params . topic , params . context ) ; Echo . Events . _executeForDeepestContext ( params . topic , params . context , function ( obj , lastContext , restContexts ) { Echo . Events . _callHandlers ( obj [ lastContext ] , params , restContexts ) ; } ) ; if ( ! params . bubble && params . context !== "empty" ) { params . context = "empty" ; Echo . Events . publish ( params ) ; } }
function ( ) { var user = Echo . UserSession ( { "appkey" : "test.aboutecho.com" } ) ; QUnit . ok ( ! user . is ( "logged" ) , "Check if the user is not logged in using user.is(\"logged\") function" ) ; QUnit . equal ( user . is ( "logged" ) , user . _isLogged ( ) , "Check \"is\" function delegation using \"logged\" property" ) ; this . checkBasicOperations ( ) ; QUnit . start ( ) ; }
function ( i , valueControl ) { if ( that . conditions [ i ] . attribute === attribute ) { values . push ( valueControl . val ( ) ) ; } }
function ( ) { var availableValues = this . possibleValues ( this . currentAttribute ) , selectedValues = this . attributeValue ( ) ; $ . each ( this . attributeValue ( ) . split ( " " ) , function ( i , value ) { var index = availableValues . indexOf ( value ) ; if ( index !== - 1 ) { availableValues . splice ( index , 1 ) ; } } ) ; return availableValues ; }
function _lintCSS ( files , done ) { var rules = JSON . parse ( fs . readFileSync ( __dirname + "/../.csslintrc" , "utf-8" ) ) , options = [ "--rules=" + rules , "--format=compact" ] ; _spawn ( 'csslint' , files . concat ( options ) , done ) ; }
function ( ) { var listener = jasmine . createSpy ( ) ; systemEvent . deviceBatteryStateChange ( listener ) ; _run ( 20 , [ function ( ) { event . trigger ( "DeviceBatteryStateChanged" , [ false ] ) ; } , function ( ) { expect ( listener ) . toHaveBeenCalledWith ( 3 ) ; } ] ) ; }
function ( ) { var listener = jasmine . createSpy ( ) ; systemEvent . deviceBatteryStateChange ( listener ) ; _run ( 20 , [ function ( ) { systemEvent . deviceBatteryStateChange ( null ) ; } , function ( ) { event . trigger ( "DeviceBatteryStateChanged" , [ false ] ) ; } , function ( ) { expect ( listener ) . not . toHaveBeenCalled ( ) ; } ] ) ; }
function ( ) { expect ( window . foo ) . toBeDefined ( ) ; expect ( window . bar ) . toBeDefined ( ) ; expect ( window . woot ) . toBeDefined ( ) ; expect ( window . foo ) . toBe ( _emulatedFrame . contentWindow . foo ) ; expect ( window . bar ) . toBe ( _emulatedFrame . contentWindow . bar ) ; expect ( window . woot ) . toBe ( _emulatedFrame . contentWindow . woot ) ; }
function ( ) { var graphics , grid , snake ; snake = new Game . Snake ; grid = new Game . Grid ( snake ) ; graphics = new Game . Graphics ( grid ) ; grid . startGame ( ) ; }
function ( ) { function Game ( ) { } Game . debug = false ; Game . log = function ( message ) { if ( ! Game . debug ) { return ; } return console . log ( message ) ; } ; return Game ; }
function ( pair ) { pair . x %= this . squaresX ; pair . y %= this . squaresY ; if ( pair . x < 0 ) { pair . x = this . squaresX - 1 ; } if ( pair . y < 0 ) { pair . y = this . squaresY - 1 ; } return pair ; }
function ( sX , sY , radius , alpha ) { if ( HEALCIRCLE == null ) { HEALCIRCLE = new Kinetic . Circle ( { x : sX , y : sY , radius : radius , fill : Team . getColor ( ) . getStringAlpha ( alpha ) } ) ; } else if ( Type != TankKindEnum . BASE ) HEALCIRCLE . setPosition ( sX , sY ) ; return HEALCIRCLE ; }
function ( pipeline ) { _ ( self . pipelines ( ) ) . each ( function ( existing_pipeline ) { if ( existing_pipeline . name ( ) == pipeline . name ) { existing_pipeline . refresh ( pipeline ) ; } } ) ; }
function ( ) { Radiator . MonitorStore . all ( function ( data ) { _ ( data ) . each ( function ( monitorData , index ) { var monitor = new Radiator . Monitor ( monitorData ) ; self . monitors . push ( monitor ) ; monitor . start ( ) ; } ) ; } , self . showError ) ; }
function ( name ) { var path = this . get ( 'path' ) ; if ( this . get ( 'Tree' ) . findFolder ( path = path . concat ( name ) ) ) { this . set ( 'path' , path ) ; this . trigger ( 'change:downLevel' ) ; } }
function processError ( errors ) { if ( response . errors [ 0 ] . code && response . errors [ 0 ] . code == "0200" ) { logout ( ) ; } else { alert ( response . errors [ 0 ] . text ) } }
function TorBirdy ( ) { this . wrappedJSObject = this ; this . prefs = Cc [ "@mozilla.org/preferences-service;1" ] . getService ( Ci . nsIPrefBranch ) ; this . acctMgr = Cc [ "@mozilla.org/messenger/account-manager;1" ] . getService ( Ci . nsIMsgAccountManager ) ; this . setPrefs ( ) ; this . setAccountPrefs ( ) ; dump ( "TorBirdy registered!\n" ) ; }
function ( ) { this . attr ( { y : 290 , x : 290 , scale : 0.5 , filters : filter . opacity ( 0.5 ) } ) ; stage . addChild ( this ) ; }
function ( ) { this . attr ( { y : 430 , x : 10 , scale : 0.5 , filters : filter . dropShadow ( [ 0 , 0 , 5 , '#000' ] ) } ) ; stage . addChild ( this ) ; }
function ( d ) { function pad ( n ) { return n < 10 ? '0' + n : n } return d . getUTCFullYear ( ) + '-' + pad ( d . getUTCMonth ( ) + 1 ) + '-' + pad ( d . getUTCDate ( ) ) + 'T' + pad ( d . getUTCHours ( ) ) + ':' + pad ( d . getUTCMinutes ( ) ) + ':' + pad ( d . getUTCSeconds ( ) ) + 'Z' }
function ( error , value ) { message ++ ; if ( message === 1 ) { test . ok ( error instanceof Error ) ; test . ok ( typeof value === 'undefined' ) ; test . ok ( error . message . match ( /\{"1":2\}/ ) ) ; } else { test . equal ( error , null ) ; test . equal ( value , 5 ) ; test . done ( ) ; } }
function ( error , value ) { message ++ ; if ( message === 1 ) { test . ok ( error instanceof Error ) ; test . ok ( typeof value === 'undefined' ) ; test . ok ( error . message . match ( /\{"1":2\}/ ) ) ; } else { test . equal ( error , null ) ; test . equal ( value , 5 ) ; test . done ( ) ; } }
function ( error , value ) { message ++ ; if ( message === 1 ) { test . ok ( error instanceof Error ) ; test . ok ( typeof value === 'undefined' ) ; test . ok ( error . message . match ( /\{"1":2\}/ ) ) ; } else { test . equal ( error , null ) ; test . equal ( value , 5 ) ; test . done ( ) ; } }
function ( error , value ) { message ++ ; if ( message === 1 ) { test . ok ( error instanceof Error ) ; test . ok ( typeof value === 'undefined' ) ; test . ok ( error . message . match ( /\{"1":2\}/ ) ) ; } else { test . equal ( error , null ) ; test . equal ( value , 5 ) ; test . done ( ) ; } }
function run ( ) { updateSelected ( ) ; $ ( ".runButton" ) . hide ( ) ; $ ( document . body ) . addClass ( 'running' ) ; $ ( '.test, #header' ) . removeClass ( 'passed' ) . removeClass ( 'failed' ) ; $ . ajax ( { type : 'GET' , url : initTestRunnerLink , success : function ( ) { runNextTest ( ) ; } , error : function ( request ) { testError ( request . responseText ) ; } } ) ; }
function ( req , res ) { var cid = req . params . cid ; var t = new Date ( req . params . yyyy , req . params . mm , req . params . dd ) ; var options = { } ; query . getProgramListByDate ( cid , t , function ( err , list ) { err ? next ( err ) : res . json ( list ) ; } ) ; }
function ( ) { it ( "returns a tree representing the concatenation of the elements of its parameter" , function ( ) { expect ( noamRe . tree . makeSeq ( [ literal_a , literal_b ] ) . tag ) . toEqual ( noamRe . tree . tags . SEQ ) ; } ) ; }
function ( ) { var eps = noamRe . tree . makeEps ( ) ; var automaton = noamRe . tree . toAutomaton ( eps ) ; expect ( noamFsm . isStringInLanguage ( automaton , [ ] ) ) . toBeTruthy ( ) ; expect ( noamFsm . isStringInLanguage ( automaton , [ "a" ] ) ) . toBeFalsy ( ) ; }
function Mu_normalize ( context , name ) { var val = context [ name ] ; if ( typeof val === 'function' ) { val = val . call ( context ) ; } return typeof val === 'undefined' ? '' : val . toString ( ) ; }
function ( item ) { return ExtensionLoader . loadAllExtensionsInNativeDirectory ( FileUtils . getNativeBracketsDirectoryPath ( ) + "/extensions/" + item , "extensions/" + item ) ; }
function ( suite ) { var results = suite . results ( ) , passed , data = this . _topLevelSuiteMap [ suite . getFullName ( ) ] ; if ( ( suite . getFullName ( ) === this . _paramMap . spec ) && data ) { passed = results . passed ( ) ; data . $badgeAll . hide ( ) ; } }
function ( ) { var openDocs = testWindow . brackets . test . DocumentManager . getAllOpenDocuments ( ) ; openDocs . forEach ( function resetDoc ( doc ) { if ( doc . isDirty ) { doc . refreshText ( doc . getText ( ) , doc . diskTimestamp ) ; } } ) ; testWindow . close ( ) ; }
function closeTestWindow ( ) { runs ( function ( ) { var openDocs = testWindow . brackets . test . DocumentManager . getAllOpenDocuments ( ) ; openDocs . forEach ( function resetDoc ( doc ) { if ( doc . isDirty ) { doc . refreshText ( doc . getText ( ) , doc . diskTimestamp ) ; } } ) ; testWindow . close ( ) ; } ) ; }
function clickDialogButton ( buttonId ) { var $dlg = testWindow . $ ( ".modal.instance" ) , promise = $dlg . data ( "promise" ) ; expect ( $dlg . length ) . toBe ( 1 ) ; var dismissButton = $dlg . find ( ".dialog-button[data-button-id='" + buttonId + "']" ) ; expect ( dismissButton . length ) . toBe ( 1 ) ; dismissButton . click ( ) ; waitsForDone ( promise ) ; }
function makeAbsolute ( paths ) { var fullPath = testWindow . brackets . test . ProjectManager . getProjectRoot ( ) . fullPath ; function prefixProjectPath ( path ) { if ( path . indexOf ( fullPath ) === 0 ) { return path ; } return fullPath + path ; } if ( Array . isArray ( paths ) ) { return paths . map ( prefixProjectPath ) ; } else { return prefixProjectPath ( paths ) ; } }
function makeRelative ( paths ) { var fullPath = testWindow . brackets . test . ProjectManager . getProjectRoot ( ) . fullPath , fullPathLength = fullPath . length ; function removeProjectPath ( path ) { if ( path . indexOf ( fullPath ) === 0 ) { return path . substring ( fullPathLength ) ; } return path ; } if ( Array . isArray ( paths ) ) { return paths . map ( removeProjectPath ) ; } else { return removeProjectPath ( paths ) ; } }
function ( ) { if ( $ ( this ) . attr ( 'providerId' ) && $ ( this ) . attr ( 'providerId' ) != "" ) { if ( ! providerMap . hasOwnProperty ( $ ( this ) . attr ( 'providerId' ) ) ) providerMap [ $ ( this ) . attr ( 'providerId' ) ] = providerColorCodes [ colorPos ] ; colorPos = ( colorPos + 1 ) % 10 ; } }
function ( e , ui ) { _this . updateVisualElement ( ui . value ) ; _this . updateSliderInput ( ui . value ) ; _this . saveValue ( ui . value ) }
function lookupHandler ( lookup , type , begin , reached ) { data = { type : 'node' , time : new Date ( ) . getTime ( ) - begin , reached : reached . size ( ) , queries : lookup . _mapped . length , closest : reached . size ( ) > 0 ? reached . getPeer ( 0 ) . getDistanceTo ( lookup . _target ) : - 1 , rejected : lookup . isRejected ( ) } ; emit ( 'iterative_find' , data ) ; }
function ( event ) { event . preventDefault ( ) ; this . set ( 'uncomittedChanges' , false ) ; this . set ( 'refreshAvailable' , false ) ; this . inputView . controlGroup ( ) . removeClass ( 'warning' ) ; this . inputView . controlGroup ( ) . removeClass ( 'error' ) ; this . set ( 'isDisabled' , true ) ; this . inputView . $ ( ) . val ( JSON . stringify ( this . item . get ( 'value' ) , null , 2 ) ) ; }
function ( ) { try { var oldValueJSON = JSON . stringify ( parent . get ( 'item' ) . get ( 'value' ) ) ; var newValueJSON = JSON . stringify ( JSON . parse ( this . $ ( ) . val ( ) ) ) ; if ( newValueJSON == oldValueJSON ) { this . set ( 'uncomittedChanges' , false ) ; } } catch ( e ) { } }
function ( bookmark , comment ) { var Tree = this ; _ ( bookmark . paths ) . each ( function ( path ) { Tree . getFolder ( path ) . takeBookmark ( bookmark ) ; } ) ; bookmark . commentParser ( comment ) ; _ ( bookmark . paths ) . each ( function ( chawan ) { Tree . getFolder ( chawan , true ) . addBookmark ( bookmark ) ; } ) ; this . trigger ( 'change' ) ; }
function ( ) { var n = arguments [ 0 ] || arguments [ 0 ] === 0 || 1 ; if ( this . get ( 'path' ) . length ) { for ( var i = 0 ; i < n ; i ++ ) { this . get ( 'path' ) . pop ( ) ; } this . trigger ( 'change:path' ) ; } }
function ( id ) { var songIndex = - 1 ; for ( var i = 0 ; i < _songs . length ; i ++ ) { if ( _songs [ i ] . id === id ) { songIndex = i ; break ; } } if ( songIndex == - 1 ) throw "Couldn't find song with UID: " + id ; return songIndex ; }
function ( currentTimeInSeconds ) { var currentTime = currentTimeInSeconds ? currentTimeInSeconds : Player . getCurrentTime ( ) ; _currentTimeLabel . text ( Date . secondsToPrettyPrintTime ( currentTime ) ) ; var totalTime = Player . getTotalTime ( ) ; _totalTimeLabel . text ( Date . secondsToPrettyPrintTime ( totalTime ) ) ; }
function ( event , ui ) { if ( typeof ( ui . item . value ) == 'string' ) { _showSongSuggestions ( ui . item . value ) ; } else { event . preventDefault ( ) ; Player . addSongById ( ui . item . value . videoId ) ; songListHeader . flashMessage ( 'Thanks!' , 2000 ) ; } }
function ( text , callback ) { $ . getJSON ( this . _suggestUrl + text , function ( response ) { var suggestions = [ ] ; for ( entry in response [ 1 ] ) { suggestions . push ( response [ 1 ] [ entry ] [ 0 ] ) ; } callback ( suggestions ) ; } ) ; }
function ( data ) { var songName = data . entry . title . $t ; YTHelper . search ( songName , function ( videos ) { var playableSong = null ; for ( var videoIndex = 0 ; videoIndex < videos . length ; videoIndex ++ ) { if ( YTHelper . _isVideoPlayable ( videos [ videoIndex ] ) ) { playableSong = videos [ videoIndex ] ; break ; } } callback ( playableSong ) ; } ) ; }
function ( id ) { var playlistIndex = - 1 ; for ( var i = 0 ; i < _playlists . length ; i ++ ) { if ( _playlists [ i ] . id === id ) { playlistIndex = i ; break ; } } if ( playlistIndex == - 1 ) throw "Couldn't find playlist with UID: " + id ; return playlistIndex ; }
function ( ) { _addInput . css ( 'opacity' , 0 ) . css ( 'cursor' , "pointer" ) . val ( '' ) . blur ( ) ; _addCancelIcon . css ( 'right' , '-30px' ) ; _addButton . width ( '120px' ) . one ( 'click' , _expand ) ; return false ; }
function ( message , durationInMilliseconds ) { var placeholder = _addInput . attr ( 'placeholder' ) ; _addInput . val ( '' ) . blur ( ) . attr ( 'placeholder' , message ) ; window . setTimeout ( function ( ) { _addInput . attr ( 'placeholder' , placeholder ) ; } , durationInMilliseconds ) ; }
function foreground ( ) { var _uiElements = uiElements ( ) ; var _listen = function ( ) { chrome . extension . onConnect . addListener ( function ( port ) { port . onMessage . addListener ( function ( message ) { if ( message . errorMessage ) alert ( message . errorMessage ) ; _uiElements . updateWithMessage ( message ) ; } ) ; } ) ; } ( ) ; }
function ( e ) { var distanceToMove = $ ( this ) . width ( ) - _header . width ( ) ; var timeToTakeMoving = 30 * distanceToMove ; $ ( this ) . animate ( { marginLeft : "-" + distanceToMove + "px" } , timeToTakeMoving ) ; }
function playlistsTab ( ) { var _contentHeader = contentHeader ( '#PlaylistDisplay' , 'Add Playlist' , 'Enter a playlist name' ) var _playlistList = playlistList ( _contentHeader ) ; var playlistsTab = { setContentHeaderTitle : function ( title ) { _contentHeader . setTitle ( title ) ; } , reloadList : function ( ) { _playlistList . reload ( ) ; } } return playlistsTab ; }
function ( ) { var elapsedTime = _selector . val ( ) ; var totalTime = _selector . prop ( 'max' ) ; var fill = totalTime != 0 ? elapsedTime / totalTime : 0 ; var backgroundImage = '-webkit-gradient(linear,left top, right top, from(#ccc), color-stop(' + fill + ',#ccc), color-stop(' + fill + ',rgba(0,0,0,0)), to(rgba(0,0,0,0)))' ; _selector . css ( 'background-image' , backgroundImage ) }
function ( ) { "use strict" ; return { mongodb : { host : "129.59.105.195" , port : 27017 , database : "test" , collection : "storage" } , parser : { persistingLimit : 1000 , reportingTime : 2000 } , reader : { concurrentReads : 100 , reportingTime : 2000 } } ; }
function ( overlay , index , orig ) { overlay . setMap ( me . komooMap . googleMap ) ; if ( overlay . setIcon ) { overlay . setIcon ( overlay . getIconUrl ( me . komooMap . googleMap . getZoom ( ) ) ) ; } if ( overlay . getMarker ( ) ) { if ( zoom < me . komooMap . options . clustererMaxZoom ) { } else { overlay . setMap ( me . komooMap . googleMap ) ; } } }
function ( komooMap ) { this . komooMap = komooMap ; this . addrLatLngCache = { } ; this . loadedOverlays = { } ; this . tileSize = new google . maps . Size ( 256 , 256 ) ; this . maxZoom = 32 ; this . name = "Wikimapia Data" ; this . alt = "Wikimapia Data Tile Map Type" ; this . key = "Add here your wikimapia key" ; }
function ( e ) { if ( komooMap . addPanel . is ( ":hidden" ) ) { komooMap . setCurrentOverlay ( null ) ; } if ( komooMap . mode == komoo . Mode . SELECT_CENTER ) { komooMap . _emit_center_selected ( e . latLng ) ; } komooMap . _emit_mapclick ( e ) ; }
function ( ) { var bounds = komooMap . googleMap . getBounds ( ) ; if ( komooMap . options . autoSaveLocation ) { komooMap . saveLocation ( ) ; } komooMap . keptOverlays . forEach ( function ( overlay , index , orig ) { if ( ! bounds . intersects ( overlay . getBounds ( ) ) ) { overlay . setMap ( null ) ; } } ) ; komooMap . keptOverlays . clear ( ) ; }
function ( e ) { if ( ! komooMap . overlayView ) { google . maps . event . trigger ( komooMap . googleMap , "projection_changed" ) ; } var overlay = komooMap . currentOverlay ; if ( overlay && overlay . getProperties ( ) && overlay . getProperties ( ) . userCanEdit ) { komooMap . deleteNode ( e ) ; } }
function ( center ) { if ( ! center ) { center = this . googleMap . getCenter ( ) ; } var zoom = this . googleMap . getZoom ( ) ; komoo . utils . createCookie ( "lastLocation" , center . toUrlValue ( ) , 90 ) ; komoo . utils . createCookie ( "lastZoom" , zoom , 90 ) ; }
function ( category , index , orig ) { if ( komooMap . overlaysByType [ type ] [ category ] ) { komooMap . overlaysByType [ type ] [ category ] . forEach ( function ( overlay , index , orig ) { if ( ! opt_strict || ! overlay . getProperties ( ) . categories || overlay . getProperties ( ) . categories . length == 1 ) { overlays . push ( overlay ) ; } } ) ; } }
function ( e ) { var overlay_ = this ; if ( overlay_ . getProperties ( ) && overlay_ . getProperties ( ) . userCanEdit && overlay_ == komooMap . currentOverlay ) { if ( ! komooMap . overlayView ) { google . maps . event . trigger ( komooMap . googleMap , "projection_changed" ) ; } komooMap . deleteNode ( e ) ; } }
function button_click ( ) { $ ( ".map-menuitem.selected" , komooMap . addMenu ) . removeClass ( "selected" ) ; $ ( ".frozen" , komooMap . mainPanel ) . removeClass ( "frozen" ) ; komooMap . drawingManager . setDrawingMode ( null ) ; panel . hide ( ) ; }
function ( item , index , orig ) { var overlay = komooMap . overlays . pop ( ) ; overlay . setMap ( null ) ; }
function ( overlay , id ) { var overlayType ; if ( typeof overlay == "string" ) { overlayType = overlay ; overlay = this . getOverlay ( overlayType , id ) ; } if ( ! overlay ) { return false ; } this . panTo ( overlay . getCenter ( ) , false ) ; return true ; }
function ( opts ) { var infoWindowOptions = { pixelOffset : new google . maps . Size ( 0 , - 20 ) , closeBoxMargin : '10px' , boxStyle : { cursor : 'pointer' , background : 'url(/static/img/infowindow-arrow.png) no-repeat 0 10px' , width : '200px' } } ; this . object_ = new InfoBox ( infoWindowOptions ) ; this . customize_ ( ) ; }
function ( ) { var overlayCenter ; if ( this . object_ . getCenter ) { overlayCenter = this . object_ . getCenter ( ) ; } else if ( this . object_ . getPosition ) { overlayCenter = this . object_ . getPosition ( ) ; } else if ( this . getBounds ( ) ) { overlayCenter = this . getBounds ( ) . getCenter ( ) ; } return overlayCenter ; }
function ( opts ) { var options = opts || { clickable : true , zIndex : this . getDefaultZIndex ( ) , strokeColor : this . getBorderColor ( ) , strockOpacity : this . getBorderOpacity ( ) , strokeWeight : this . getBorderSize ( ) } ; this . setObject ( new google . maps . Polyline ( options ) ) ; }
function ( opts ) { var options = opts || { clickable : true , zIndex : this . getDefaultZIndex ( ) , strokeColor : this . getBorderColor ( ) , strockOpacity : this . getBorderOpacity ( ) , strokeWeight : this . getBorderSize ( ) } ; this . options_ = options ; this . setObject ( new MultiPolyline ( options ) ) ; }
function ( opts ) { var options = opts || { clickable : true , zIndex : this . getDefaultZIndex ( ) , fillColor : this . getBackgroundColor ( ) , fillOpacity : this . getBackgroundOpacity ( ) , strokeColor : this . getBorderColor ( ) , strockOpacity : this . getBorderOpacity ( ) , strokeWeight : this . getBorderSize ( ) } ; this . setObject ( new google . maps . Polygon ( options ) ) ; }
function ( event ) { var obj_id = parseInt ( $ ( this ) . attr ( "id" ) . match ( /[0-9]+$/ ) [ 0 ] ) ; obj_id = parseInt ( obj_id ) ; var obj_type = $ ( this ) . attr ( "id" ) . match ( /^(.+)-/ ) [ 1 ] ; editor . highlightOverlay ( obj_type , obj_id ) ; }
function ( ) { alert var $this = $ ( this ) ; var $parent = $this . parent ( ) ; var objectType = $parent . attr ( "data-object-type" ) ; if ( objectType ) { if ( $ ( "input[type=checkbox]" , $parent ) . attr ( "checked" ) ) { editor . showOverlaysByType ( objectType ) ; } else { editor . hideOverlaysByType ( objectType ) ; } } }
function ( i , subitem ) { var $subitem = $ ( subitem ) ; var overlayType = $subitem . attr ( "data-overlay-type" ) ; $subitem . click ( function ( e ) { if ( editor . addPanel . is ( ":visible" ) ) { return ; } editor . setDrawingMode ( type , overlayType ) ; $ ( "#map-panel-add .selected" ) . removeClass ( "selected" ) ; $subitem . addClass ( "selected" ) ; } ) ; }
function ( obj ) { var o = game . _old_add ( window [ obj . constructorName ] , executeJSON ( game , obj . param ) ) ; o . _id = obj . _id ; game . objectsmap [ o . _id ] = o ; }
function ( ) { user = game . newUser ( event ) ; game . event . emit ( "entry" , user ) ; game . _users . push ( user ) ; var env = game . wholeEnvironment ( ) ; socket . emit ( "init" , { env : env , user_id : user . _id , } ) ; }
function ( ) { if ( this . _ibus ) this . _ibus . destroy ( ) ; this . _ibus = null ; this . _engines = { } ; this . _ready = false ; }
function ( ) { this . _ibus . list_engines_async ( - 1 , null , Lang . bind ( this , this . _initEngines ) ) ; this . _ibus . connect ( 'disconnected' , Lang . bind ( this , this . _clear ) ) ; }
function ( ibus , result ) { let enginesList = this . _ibus . list_engines_async_finish ( result ) ; if ( enginesList ) { for ( let i = 0 ; i < enginesList . length ; ++ i ) { let name = enginesList [ i ] . get_name ( ) ; this . _engines [ name ] = enginesList [ i ] ; } this . _ready = true ; if ( this . _readyCallback ) this . _readyCallback ( ) ; } else { this . _clear ( ) ; } }
function ( ) { $ . cookie ( 'TimedText.Preferences' , JSON . stringify ( this . config ) ) ; this . prevText = [ ] ; mw . log ( 'TimedText:: bind menu refresh display' ) ; this . buildMenu ( this . menuTarget , false ) ; this . resizeInterface ( ) ; this . displayTextTarget ( $ ( '<span /> ' ) . text ( '' ) ) ; this . monitor ( ) ; }
function ( beforeExit ) { assert . response ( server , { url : '/api/Auth' , method : 'GET' } , { body : '{"id":null}' , status : 200 } , function ( res ) { assert . ok ( ! res . headers [ 'set-cookie' ] ) ; } ) ; }
function ( res ) { assert . ok ( /^connect.sid=;/ . test ( res . headers [ 'set-cookie' ] [ 0 ] ) ) ; assert . response ( server , { url : '/api/Auth' , method : 'GET' } , { body : '{"id":null}' , status : 200 } , function ( res ) { assert . ok ( ! res . headers [ 'set-cookie' ] ) ; } ) ; }
function ( ) { var token = 'a' + auth . encryptExpiringRequest ( user . id , model . secret ( ) , user . password ) ; assert . response ( server , { url : '/reset-password/' + token } , { body : /Invalid login token/ , status : 403 } ) ; }
function ( res ) { assert . response ( server , { url : '/api/Auth' , headers : { 'cookie' : res . headers [ 'set-cookie' ] [ 0 ] . replace ( /;.+$/ , '' ) } } , { body : '{"id":"resetpassword","email":"test@example.com"}' , status : 200 } ) ; assert . response ( server , { url : '/reset-password/' + token } , { body : /Invalid login token/ , status : 403 } ) ; }
function ( ) { clearInterval ( this . locks . load_recommended_feed ) ; this . locks . load_recommended_feed = setInterval ( _ . bind ( function ( ) { this . load_recommended_feed ( 0 , true ) ; } , this ) , 10 * 60 * 1000 ) ; }
function newWindow ( theTitle , x ) { var newID = ( "Window" + eid ) ; $ ( '#Window' ) . html ( "<div id='" + newID + "'>" + x + "</div>" ) ; $ ( '#' + newID ) . dialog ( { title : theTitle , width : '60%' , height : 450 } ) ; $ ( '#' + newID ) . fadeIn ( ) ; eid ++ ; }
function ( item ) { for ( j = 0 ; j < folders . length ; j ++ ) { if ( item . indexOf ( folders [ j ] ) !== - 1 ) { return true ; } } return false ; }
function ( err , venue ) { if ( ! err ) { if ( venue == null ) { res . send ( 500 , 'The specified venue does not seem to exist' ) ; } else { event . save ( function ( err ) { if ( err ) { res . send ( err ) ; } else { res . send ( req . url + '/' + event . _id ) ; } } ) ; } } else { res . send ( err ) ; } }
function ( err , doc ) { if ( ! err ) { res . send ( req . url . substring ( 0 , req . url . length - _id . length - 1 ) ) ; } else res . send ( 404 , req . url + " not found" ) ; }
function ( err ) { if ( ! err ) { console . log ( "patch updated" ) ; res . send ( req . url ) ; } else { console . log ( "Error updating patch" ) ; res . send ( 404 , req . url + " not found" ) ; } }
function ( err , doc ) { if ( ! err ) { res . send ( req . url . substring ( 0 , req . url . length - _id . length - 1 ) ) ; } else res . send ( 404 , req . url + " not found" ) ; }
function ( req , res ) { var usr = createUserFromParams ( req ) ; console . log ( usr ) ; User . find ( usr ) . exec ( function ( err , users ) { if ( ! err ) { console . log ( users ) ; res . send ( users ) ; } else { res . send ( err ) ; } } ) ; }
function ( err ) { if ( ! err ) { console . log ( "user updated" ) ; res . send ( req . url ) ; } else { console . log ( err ) ; console . log ( "Error updating user" ) ; res . send ( 404 , req . url + " not found" ) ; } }
function ( err , doc ) { if ( ! err ) { res . send ( req . url . substring ( 0 , req . url . length - _id . length - 1 ) ) ; } else res . send ( 404 , req . url + " not found" ) ; }
f if ( ! err ) { user . patches . push ( { claimed : req . params . claimed , patch : req . params . patch , timestamp : new Date ( ) } ) ; user . save ( function ( err ) { if ( ! err ) { res . send ( 'users/' + user . _id ) ; } else { res . send ( err ) ; } } ) ; } else res . send ( 404 , req . url + " not found" ) ; } ) ;
f if ( ! err ) { user . patches = [ ] ; user . save ( function ( err ) { if ( ! err ) { res . send ( '/users/' + user . _id ) ; } else { res . send ( err ) ; } } ) ; } else res . send ( 500 , err ) ; } ) ;
function ( err , friend ) { if ( err ) res . send ( 500 , err ) ; else { if ( friend . checkins . length > 0 ) output . push ( friend ) ; count ++ ; if ( count == user . friends . length ) { res . send ( output . sort ( compare ) . reverse ( ) ) ; } } }
function ( err , friend ) { if ( err ) res . send ( 500 , '3' + err ) ; else { user . friends . push ( { friend : friend . _id } ) ; user . save ( function ( err ) { if ( err ) res . send ( '4' + err ) ; else { count ++ ; if ( count == friends . length ) { res . send ( '/users/' + _id ) ; } } } ) ; } }
function ( req , res ) { _id = req . params . _id ; Venue . findOne ( { _id : _id } , function ( err , doc ) { if ( ! err ) { res . send ( doc ) ; } } ) ; }
function ( data , status ) { var fileURL = $ ( data ) . find ( 'file_url' ) . text ( ) ; var error = $ ( data ) . find ( 'error' ) . text ( ) ; if ( error != '' ) { alert ( error ) ; } else { imageUrl . attr ( 'value' , appUrl + fileURL ) ; } }
function ( json ) { markup . chooseButton . showInlineBlock ( ) markup . loadingButton . hide ( ) json = self . recordsToItems ( json ) cache [ request . term ] = json response ( json ) }
function ( e , ui ) { if ( $ ( self ) . data ( 'previous' ) ) { self . selectItem ( $ ( self ) . data ( 'previous' ) , { blurring : true } ) } }
function ( ) { var dSlides = $ . Deferred ( ) , dConfig = $ . Deferred ( ) ; $ . when ( dSlides , dConfig ) . done ( init ) ; sliderio . view . editor . slider . build ( function ( ) { dSlides . resolve ( ) ; } ) ; sliderio . view . editor . config . build ( function ( ) { dConfig . resolve ( ) ; } ) ; }
function ( data , err ) { if ( err && err !== "success" ) { sliderio . view . status . error ( ) ; } else { sliderio . view . status . success ( 'Saved' ) ; if ( callback ) callback ( ) ; } }
function ( options ) { currentSliderIndex = ( options && options . sliderIndex ) || 0 ; slides = ( options && options . slides ) || [ ] ; onMove = ( options && options . onMove ) || function ( ) { } ; onInsertSlide = ( options && options . onInsertSlide ) || function ( ) { } ; onRemoveSlide = ( options && options . onRemoveSlide ) || function ( ) { } ; attachEvents ( ) ; rebuildMoveCtrls ( ) ; }
function ( wizard , oldStep , newStep ) { if ( newStep . getXType ( ) === 'summaryTreePanel' ) { var groupWizard = wizard . up ( 'groupWizardPanel' ) ; var treePanel = newStep ; treePanel . getStore ( ) . setRootNode ( Admin . plugin . Diff . compareGroups ( groupWizard . getData ( ) , groupWizard . modelData ) ) ; } }
function ( wizard , oldStep , newStep ) { var userstoreWizard = wizard . up ( 'userstoreWizardPanel' ) ; if ( newStep . getXType ( ) === 'summaryTreePanel' ) { var treePanel = newStep ; treePanel . getStore ( ) . setRootNode ( Admin . plugin . Diff . compareUserstores ( userstoreWizard . getData ( ) , userstoreWizard . modelData ) ) ; } }
function ( ) { width = image . width ; height = image . height ; canvas = document . getElementById ( "bombs" ) ; y = ( index - ( index % numFrames ) ) / numFrames * frameSize ; x = ( index % numFrames ) * frameSize ; context = canvas . getContext ( "2d" ) ; context . drawImage ( image , x , y , frameSize , frameSize , xpos * mul , ypos * mul , frameSize , frameSize ) ; }
function ( e , data ) { var $begin = $ ( '.NB-modal-submit-begin' , this . $modal ) ; this . trainer_data = data ; if ( ! data || ! data . length ) { this . make_trainer_outro ( ) ; this . reload_modal ( ) ; } else { $begin . text ( 'Begin Training' ) . addClass ( 'NB-modal-submit-green' ) . removeClass ( 'NB-modal-submit-close' ) . removeClass ( 'NB-disabled' ) ; } }
function ( ) { var $count = $ ( '.NB-module-account-feedcount' ) ; var $site_count = $ ( '.NB-module-account-trainer-site-count' ) ; var $button = $ ( '.NB-module-account-upgrade' ) ; var approve_list = this . approve_list ; $count . text ( approve_list . length ) ; $site_count . text ( Inflector . pluralize ( 'site' , approve_list . length , true ) ) ; $button . removeClass ( 'NB-modal-submit-green' ) . addClass ( 'NB-modal-submit-close' ) ; $ ( '.NB-module-account-trainer' ) . removeClass ( 'NB-hidden' ) . hide ( ) . slideDown ( 500 ) ; }
function ( data , follow_user ) { this . $ ( '.NB-loading' ) . removeClass ( 'NB-active' ) ; this . model . set ( follow_user ) ; var $button = this . $ ( '.NB-profile-badge-action-follow' ) ; $button . text ( 'Following' ) ; $button . removeClass ( 'NB-modal-submit-green' ) . removeClass ( 'NB-modal-submit-red' ) . addClass ( 'NB-modal-submit-close' ) ; $button . removeClass ( 'NB-profile-badge-action-follow' ) . addClass ( 'NB-profile-badge-action-unfollow' ) ; NEWSBLUR . app . feed_list . make_social_feeds ( ) ; }
function ( data , unfollow_user ) { this . $ ( '.NB-loading' ) . removeClass ( 'NB-active' ) ; this . model . set ( unfollow_user ) ; var $button = this . $ ( '.NB-profile-badge-action-follow' ) ; $button . text ( 'Unfollowed' ) ; $button . removeClass ( 'NB-modal-submit-close' ) . addClass ( 'NB-modal-submit-red' ) ; $button . removeClass ( 'NB-profile-badge-action-unfollow' ) . addClass ( 'NB-profile-badge-action-follow' ) ; NEWSBLUR . app . feed_list . make_social_feeds ( ) ; }
function ( err , stdout , stderr ) { console . log ( stderr ) ; if ( err ) { res . json ( err , 404 ) ; } else { res . setHeader ( 'Expires' , new Date ( Date . now ( ) + 604800000 ) ) ; stdout . pipe ( res ) ; } }
function ( err , window ) { _ . extend ( global , { window : window , document : window . document , jQuery : window . jQuery , QUnit : { module : QUnit . module } , } ) ; _ . extend ( global , QUnit ) ; options . deps . forEach ( _require , true ) ; options . code . forEach ( _require , true ) options . tests . forEach ( function ( res ) { _require ( res , false ) ; } ) ; }
function _treeDataProvider ( treeNode , callback ) { var parent = ( treeNode === - 1 ) ? { children : [ currentEventTrace ] } : treeNode . data ( 'trace' ) ; var children = _traceChildrenForTree ( parent , treeNode === - 1 ) ; callback ( children ) ; }
function ( value ) { var f ; if ( typeof value === "string" ) { if ( ( f = Easing . Functions [ value ] ) !== undefined ) { this . _ . type = value ; this . _ . func = f ; } } else if ( typeof value === "function" ) { this . _ . type = "function" ; this . _ . func = value ; } }
function ( value ) { var _ = this . _ ; if ( typeof value === "number" ) { if ( 0 <= value && value <= 1.0 ) { _ . wet = value ; _ . wet0 = Math . sin ( 0.25 * Math . PI * value ) ; _ . dry0 = Math . cos ( 0.25 * Math . PI * value ) ; } } }
function ( value ) { var f ; if ( typeof value === "string" ) { if ( ( f = Filter . Types [ value ] ) !== undefined ) { this . _ . type = value ; this . _ . set_params = f . set_params ; } } }
function ( value ) { var _ = this . _ ; if ( typeof value === "number" ) { value = value | 0 ; if ( value < 0 ) value = _ . value . length + value ; if ( 0 <= value && value < _ . value . length ) { _ . index = value ; changeTheValue . call ( this , value ) ; } } }
function ( value ) { var _ = this . _ ; if ( typeof value === "number" ) { _ . status = 0 ; _ . start = _ . value ; _ . stop = value ; _ . samples = ( timbre . samplerate * ( _ . delay / 1000 ) ) | 0 ; _ . x0 = 0 ; _ . dx = 0 ; } }
function ( value ) { if ( typeof value === "string" ) { if ( this . _ . src !== value ) { this . _ . src = value ; this . _ . isloaded = false ; } } else if ( timbre . platform === "web" && value instanceof File ) { this . _ . src = value ; this . _ . isloaded = false ; } }
function ( value ) { var _ = this . _ ; _ . reversed = ! ! value ; if ( _ . reversed && _ . phase === 0 ) { _ . phase = Math . max ( 0 , _ . buffer . length - 1 ) ; } }
function ( value ) { var _ = this . _ ; if ( typeof value === "number" ) { if ( 0 <= value && value <= _ . duration ) { _ . phase = ( ( value / 1000 ) * timbre . samplerate ) | 0 ; } } }
function ( value ) { if ( typeof value === "number" ) { while ( value >= 1.0 ) value -= 1.0 ; while ( value < 0.0 ) value += 1.0 ; this . _ . phase = value ; this . _ . x = 1024 * this . _ . phase ; } }
function ( value ) { var _ = this . _ ; if ( typeof value === "number" && value > 0 ) { _ . recTime = value ; _ . buffer = new Float32Array ( ( timbre . samplerate * _ . recTime / 1000 ) | 0 ) ; } }
function ( value ) { var _ = this . _ ; if ( typeof value === "number" ) { _ . interval = value ; _ . interval_samples = ( timbre . samplerate * ( value / 1000 ) ) | 0 ; if ( _ . interval_samples < _ . buffer . length ) { _ . interval_samples = _ . buffer . length ; _ . interval = _ . buffer . length * timbre . samplerate / 1000 ; } } }
function ( value ) { var mode ; if ( typeof value === "string" ) { if ( ( mode = ResonantFilter . Types [ value ] ) !== undefined ) { this . _ . type = value ; this . _ . mode = mode ; } } }
function ( value ) { var _ = this . _ ; if ( typeof value === "string" && Scale . Scales [ value ] !== undefined ) { _ . scale = value ; _ . list = Scale . Scales [ value ] ; } else if ( value instanceof Array ) { _ . scale = "" ; _ . list = value ; } }
function ( value ) { var synth , _ = this . _ ; if ( typeof value === "string" ) { if ( value !== _ . version ) { if ( ( synth = AwesomeTimbre . Versions [ value ] ) !== undefined ) { _ . version = value ; if ( _ . synth && _ . synth . destroy ) { _ . synth . destroy ( this ) ; } _ . synth = synth ( this ) ; } } } }
function ( value ) { var _ = this . _ ; _ . reversed = ! ! value ; if ( _ . reversed && _ . phase === 0 ) { _ . phase = Math . max ( 0 , _ . buffer . length - 1 ) ; } }
function ( value ) { var _ = this . _ ; _ . reversed = ! ! value ; if ( _ . reversed && _ . phase === 0 ) { _ . phase = Math . max ( 0 , _ . buffer . length - 1 ) ; } }
function cb ( err , s ) { if ( ! -- pending ) { db . close ( ) ; done ( ) ; } if ( Array . isArray ( s ) ) s = s [ 0 ] ; assert . strictEqual ( null , err ) ; assert . equal ( false , s . isSelected ( 'name' ) ) ; assert . strictEqual ( undefined , s . name ) ; }
function cb ( err , s ) { if ( ! -- pending ) { db . close ( ) ; done ( ) ; } if ( Array . isArray ( s ) ) s = s [ 0 ] ; assert . strictEqual ( null , err ) ; assert . strictEqual ( true , s . isSelected ( 'name' ) ) ; assert . equal ( s . name , 'the included' ) ; }
function ( data , e ) { this . tree . fireEvent ( "enddrag" , this . tree , data . node , e ) ; }
function LocalActHandler ( options ) { options = options || { } ; ActHandler . call ( this , options ) ; this . cloud = options . cloud || "./cloud/" ; this . main = options . main || "main.js" ; this . listen = options . listen || true ; this . env = null ; this . legacy = false ; this . init ( ) ; if ( this . listen ) { this . listenTo ( this . cloud ) ; } }
function ( act , params , cb ) { try { this . env [ act ] ( params , cb ) ; } catch ( e ) { cb ( e ) ; } }
function ( success , fail , service , action , args , sync ) { var uri = "bridge/exec/" + service + "/" + action , request = new RemoteFunctionCall ( uri ) , name ; for ( name in args ) { if ( Object . hasOwnProperty . call ( args , name ) ) { request . addParam ( name , args [ name ] ) ; } } request [ sync ? "makeSyncCall" : "makeAsyncCall" ] ( success , fail ) ; }
function ( ) { spyOn ( plugin , "get" ) . andCallFake ( function ( request , succ , fail , body ) { succ ( [ "MyFeatureId" ] ) ; } ) ; req . params . service = "extensions" ; req . params . action = "get" ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : 1 , data : [ "MyFeatureId" ] } ) ; }
function ( ) { spyOn ( plugin , "get" ) . andCallFake ( function ( request , succ , fail , body ) { fail ( - 1 , "ErrorMessage" ) ; } ) ; req . params . service = "extensions" ; req . params . action = "get" ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : - 1 , data : null , msg : "ErrorMessage" } ) ; }
function ( ) { req = { params : { service : "bridge" , action : "exec" , ext : "blackberry.app" , method : "author" , args : null , origin : null } , headers : { host : "" } , url : "" , body : "" } ; res = { send : jasmine . createSpy ( ) } ; }
function ( program ) { this . program = program ; for ( var name in this . attributes ) { this . attributes [ name ] . location = ( name in program . locations ) ? program . locations [ name ] : null ; } return this ; }
function ( name ) { var mod ; name = name . indexOf ( "." ) === 0 ? Path . join ( process . cwd ( ) , name ) : name ; mod = require ( name ) ; Object . keys ( mod ) . forEach ( function ( k ) { definitions [ k ] = mod [ k ] ; } ) ; }
function ( i , el ) { $el = $ ( this ) ; mod . selectItem ( $el ) ; }
function ( ) { var offset = this . container . offset ( ) ; var height = this . container . outerHeight ( ) ; var width = this . container . outerWidth ( ) ; var css = { top : offset . top + height , left : offset . left , width : width } this . dropdown . css ( css ) ; }
function _addCss ( css ) { for ( var i = 0 ; i < css . length ; ++ i ) { _addCssFile ( css [ i ] ) ; } }
function _addCssFile ( filename ) { var stylesheet = doc . createElement ( "link" ) ; stylesheet . setAttribute ( "rel" , "stylesheet" ) ; stylesheet . setAttribute ( "type" , "text/css" ) ; stylesheet . setAttribute ( "href" , filename ) ; doc . getElementsByTagName ( "head" ) [ 0 ] . appendChild ( stylesheet ) ; }
function ( data ) { if ( data . redirect ) { window . location = data . redirect ; } _addCss ( data . css ) ; doc . title = data . title ; doc . getElementById ( data . id ) . innerHTML = data . content ; for ( var i in data . js ) { _js_queue . push ( data . js [ i ] ) ; } _processQueue ( ) ; }
function runJS ( ) { try { console . log ( 'hh' ) ; var customJS = Settings . get ( 'configure.js' ) ; if ( customJS ) { eval ( customJS ) ; if ( typeof frontendExec != "undefined" ) { frontendExec ( ) ; } } } catch ( e ) { console . debug ( "Custom JS failed to load" , e ) ; } }
function ( er , data ) { if ( er ) { log . error ( "Could not read data for " + pkg + "@" + ver ) return cb ( er ) } tar . unpack ( path . join ( npm . cache , pkg , ver , "package.tgz" ) , unpackTarget , dMode , fMode , uid , gid , cb ) }
function ( arg ) { if ( typeof arg !== "string" ) { return util . inspect ( arg , false , 5 , colored ) + "\n" } if ( ! colored ) arg = arg . replace ( /\033\[[0-9;]*m/g , '' ) if ( ! npm . config . get ( "unicode" ) ) { arg = arg . replace ( /└/g , "`" ) . replace ( /─/g , "-" ) . replace ( /├/g , "+" ) . replace ( /┬/g , "-" ) } return arg }
function ( val ) { this . setHeader ( 'content-type' , 'application/json' ) this . setHeader ( 'accept' , 'application/json' ) if ( typeof val === 'boolean' ) { if ( typeof this . body === 'object' ) this . body = JSON . stringify ( this . body ) } else { this . body = JSON . stringify ( val ) } return this }
function ( agentOptions , optionsArg ) { var options = { } if ( agentOptions ) { for ( option in optionsArg ) { options [ option ] = optionsArg [ option ] } } options . agent = new ForeverAgent ( agentOptions ) return request . defaults ( options ) }
function ( uri , options , callback ) { var params = initParams ( uri , options , callback ) ; params . options . method = 'HEAD' if ( options . body || options . requestBodyStream || options . json || options . multipart ) { throw new Error ( "HTTP HEAD requests MUST NOT include a request body." ) } return request ( params . uri , params . options , params . callback ) }
function ( k ) { return tree [ k ] . what . split ( "@" ) }
function ( l , r ) { var parentDir = r [ 3 ] , parent = r [ 2 ] , where = r [ 1 ] , what = r [ 0 ] l [ where ] = { parentDir : parentDir , parent : parent , children : [ ] , where : where , what : what } return l } , { }
function ( target , cb ) { log ( target . _id , "installOne" ) var newWrap = wrap ? wrap [ target . name ] . dependencies || { } : null var newContext = { family : newPrev , ancestors : newAnc , parent : parent , explicit : false , wrap : newWrap } installOne ( target , where , newContext , cb ) }
function ( er , files ) { if ( er ) return cb ( er ) if ( files . indexOf ( "wscript" ) !== - 1 ) { exec ( "node-waf" , [ "clean" ] , null , false , f , thenBuild ) } else if ( files . indexOf ( "Makefile" ) !== - 1 ) { exec ( "make" , [ "clean" ] , null , false , f , thenBuild ) } else thenBuild ( ) }
function ( er , files ) { if ( er && p === original ) return cb ( er ) if ( er ) return cb ( null , original ) if ( files . indexOf ( "node_modules" ) !== - 1 || files . indexOf ( "package.json" ) !== - 1 ) { return cb ( null , p ) } return findPrefix_ ( path . dirname ( p ) , original , cb ) }
function ( orig , name , i , s ) { return process . env [ name ] || orig }
function timeToPixels ( date , limit ) { limit = limit || g . zeroTime ; var time = ( date . valueOf ( ) - limit . valueOf ( ) ) / g . MILLISECONDS_IN_HOUR ; var pixels = Math . floor ( time * g . HOUR_WIDTH ) ; return pixels ; }
function ensureContainerEditable ( container ) { if ( ! container ) { return ; } if ( isHtmlElement ( container . lastChild , "br" ) ) { return ; } if ( $_ ( container . childNodes ) . some ( isVisible ) ) { return ; } if ( ! jQuery . browser . msie ) { container . appendChild ( createEndBreak ( ) ) ; } }
function ( c ) { return this . each ( function ( ) { $ ( this ) . hover ( function ( ) { $ ( this ) . addClass ( c ) ; } , function ( ) { $ ( this ) . removeClass ( c ) ; } ) ; } ) ; }
function show_selected_hosts ( event ) { var selected = $ ( selected_objects ( ) ) ; if ( selected . size ( ) < 1 ) { show_error_dialog ( "対象がなにも選択されていません" ) ; return false ; } ; window . location . href = '/ybz/host/' + selected . get ( ) . join ( '-' ) ; }
function show_bricks_of_hosts ( event ) { var selected = $ ( selected_objects ( ) ) ; if ( selected . size ( ) < 1 ) { show_error_dialog ( "対象がなにも選択されていません" ) ; return false ; } ; window . location . href = '/ybz/brick/list/hosts/' + selected . get ( ) . join ( '-' ) ; }
function show_selected_bricks ( event ) { var selected = $ ( selected_objects ( ) ) ; if ( selected . size ( ) < 1 ) { show_error_dialog ( "対象がなにも選択されていません" ) ; return false ; } ; window . location . href = '/ybz/brick/' + selected . get ( ) . join ( '-' ) ; }
function ( xhr ) { show_error_dialog ( xhr . responseText , on_error_callback ) ; }
function ( ) { if ( self . hasBeenDefined ( '$' ) ) callback ( 'Could not load Zepto (needed for testing)' ) ; else callback ( null , self ) ; }
function ( audioId ) { if ( this . audioPlayer . isPlaying && this . audioPlayer . media . id == audioId ) { this . audioPlayer . pause ( ) ; } else { this . audioPlayer . play ( audioId ) ; } }
function ( ) { console . log ( "I'm a new comment!" ) ; var m = new Comment ( { } ) ; this . model . get ( "comments" ) . add ( m ) ; }
function ( ) { console . log ( "I'm a new comment!" ) ; var m = new Comment ( { } ) ; this . model . get ( "comments" ) . add ( m ) ; }
function onRefreshCache ( data ) { GOLFER_CACHE = { } ; for ( var i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] . tp === "golfer" ) { GOLFER_CACHE [ data [ i ] . val ] = data [ i ] . lbl ; } } setSelectOptions ( "#golfScoreForm select[name=golfer_id]" , GOLFER_CACHE ) ; }
function ( rslt ) { logMsg ( resourceActionInfo + " Responded" , rslt . requestId ) ; if ( ! validateServerResponse ( rslt ) ) { logMsg ( resourceActionInfo + " Failed to validate the server response - " + rslt [ 'errorMsg' ] ) ; rslt [ 'serverSideFail' ] = true ; } successCallback ( rslt ) ; }
function ( ) { that . $targetInput . select2 ( { tags : collections . metrics . autocomplete_names ( ) , width : "17em" } ) ; that . $targetInput2 . select2 ( { tags : collections . metrics . autocomplete_names ( ) , width : "17em" } ) ; }
function ( ) { if ( this . opened ( ) ) return ; this . container . addClass ( "select2-dropdown-open" ) . addClass ( "select2-container-active" ) ; this . updateResults ( true ) ; this . dropdown . show ( ) ; this . focusSearch ( ) ; }
function addTimeout ( timeout , channel , callback ) { var runner = setTimeout ( function ( ) { var error = util . createErrorResponse ( "TimeoutExpired" , "Timeout after " + timeout + "ms" ) ; callback ( error ) ; channel . close ( ) ; } , timeout ) ; channel . on ( "closing" , function ( ) { clearTimeout ( runner ) ; } ) ; }
function ( value ) { if ( this . stringifyProperty != null ) { return value [ this . stringifyProperty ] ; } var name = null ; var lookup = this . getLookup ( ) ; lookup . some ( function ( item ) { if ( item . value === value ) { name = item . name ; return true ; } return false ; } , this ) ; return name ; }
function ( Component ) { var Arena = Component . extend ( { init : function ( ) { this . element = $ ( '<div>' ) ; } , adopt : function ( component ) { this . element . append ( component . element ) ; } } ) ; return Arena ; }
function ( $ ) { $ . SetValue ( "__IsNumeric__" , true ) ; $ . SetValue ( "__IsIntegral__" , isIntegral ) ; JSIL . MakeCastMethods ( $ . publicInterface , $ . typeObject , isIntegral ? "integer" : "number" ) ; }
function ( array ) { if ( Array . isArray ( array ) ) { return Array . prototype . slice . call ( array ) ; } else if ( Object . getPrototypeOf ( array ) === JSIL . MultidimensionalArray . prototype ) { return new JSIL . MultidimensionalArray ( array . _type , array . _dimensions , array . _items ) ; } else { throw new Error ( "Invalid array" ) ; } }
function ( text ) { var result = new Array ( text . length ) ; for ( var i = 0 , l = text . length ; i < l ; i ++ ) result [ i ] = text . charCodeAt ( i ) & 0xFF ; return result ; }
function ( text ) { var result = new Array ( text . length ) ; for ( var i = 0 , l = text . length ; i < l ; i ++ ) result [ i ] = text [ i ] ; return result ; }
function ( e ) { console . log ( "ws message: " + e ) ; var reply = JSON . parse ( e . data ) ; if ( reply . status === 'OK' ) { self . dispatched_callback ( reply . host , reply . port ) ; } else if ( reply . status === 'FULL' ) { alert ( "BrowserQuest is currently at maximum player population. Please retry later." ) ; } else { alert ( "Unknown error while connecting to BrowserQuest." ) ; } }
function ( ) { var colspan = $ ( this ) . data ( 'colspan' ) ; $ ( this ) . width ( ( ( 100 / columns ) * colspan ) + '%' ) ; i ++ ; }
function ( shape , params ) { this . shape = shape ; this . delay = ( params && params . delay > 0 ) ? params . delay : 0 ; this . mover = ( params && params . mover ) ? params . mover : Mover ; this . events = [ this . shape . connect ( "onmousedown" , this , "onMouseDown" ) ] ; }
function ( e ) { var x = e . clientX ; var y = e . clientY ; this . host . onMove ( this , { dx : x - this . lastX , dy : y - this . lastY } ) ; this . lastX = x ; this . lastY = y ; evt . stop ( e ) ; }
function ( ) { arr . forEach ( this . events , connect . disconnect ) ; var h = this . host ; if ( h && h . onMoveStop ) { h . onMoveStop ( this ) ; } this . events = this . shape = null ; }
function ( ) { if ( ! this . svg ) { this . svg = Raphael ( this . canvas [ 0 ] ) ; this . svg . renderfix ( ) ; var style = this . svg . canvas . style ; style . position = "absolute" ; } return this . svg ; }
function ( ) { var peers = $Peers . create ( ) ; peers . tread ( 'hello' , 5 ) . tread ( 'foo' , 4 ) ; deepEqual ( Object . keys ( peers . toJSON ( ) ) , [ 'hello' , 'foo' ] , "Peers properties sent to JSON" ) ; equal ( JSON . stringify ( peers ) , '{"hello":' + JSON . stringify ( peers . lookup . hello ) + ',"foo":' + JSON . stringify ( peers . lookup . foo ) + '}' , "Full peers JSON" ) ; }
function ( f , scope ) { var length = this . length , index = 0 ; checkFirstArgumentExists ( arguments ) ; while ( index < length ) { if ( index in this && ! multiMatch ( this [ index ] , f , scope , [ index , this ] ) ) { return false ; } index ++ ; } return true ; }
function ( f , scope ) { var length = this . length , index = 0 ; checkFirstArgumentExists ( arguments ) ; while ( index < length ) { if ( index in this && multiMatch ( this [ index ] , f , scope , [ index , this ] ) ) { return true ; } index ++ ; } return false ; }
function ( f , scope ) { var length = this . length , index = 0 , result = [ ] ; checkFirstArgumentExists ( arguments ) ; while ( index < length ) { if ( index in this && multiMatch ( this [ index ] , f , scope , [ index , this ] ) ) { result . push ( this [ index ] ) ; } index ++ ; } return result ; }
function ( f ) { i = 0 ; while ( i < arr . length ) { if ( multiMatch ( arr [ i ] , f , arr , [ i , arr ] ) ) { arr . splice ( i , 1 ) ; } else { i ++ ; } } }
function setLevel ( ) { levels [ 0 ] ; }
function removeBrick ( ) { if ( y < closeBrick ) return ; for ( var i = 0 ; i < bricks . length ; i ++ ) { if ( rectToBallCollide ( bricks [ i ] ) ) { addScore ( bricks [ i ] . score ) ; bricks . splice ( i , 1 ) ; dy *= - 1 ; return ; } } }
function ( ) { grid . encode ( [ 1 , 2 , 3 , 4 ] ) . should . equal ( "01020304" ) ; }
function ( ) { var grid = new Tilekit . Grid ( document . createElement ( "canvas" ) , { tileset : "images/tileset.png" , data : "000100\n010000\n010000" } ) ; grid . on ( "ready" , function ( ) { var course = grid . plotCourse ( { x : 2 , y : 2 } , { x : 1 , y : 1 } ) ; course . should . deep . equal ( [ 90 , 180 ] ) ; } ) ; }
function ( ctx ) { var mouse = this . get ( "mouse" ) . position , size = this . get ( "size" ) ; ctx . strokeStyle = "white" ; ctx . strokeRect ( mouse . x , mouse . y , size , size ) ; }
function ( target , options , callback ) { if ( typeof ( options ) === 'function' ) { callback = options , options = { } } this . connection . replicate ( cradle . merge ( { source : name , target : target } , options ) , callback ) ; }
function checkFillBlanksReason ( select , selectID ) { if ( selectID . toLowerCase ( ) === select . val ( ) ) { var parent = $ ( select . parent ( ) ) ; select . remove ( ) ; parent . append ( selectID ) ; return true ; } return false ; }
function remove ( fn ) { if ( this . _removing ) return this ; var promise = this . _removing = new Promise ( fn ) , self = this ; this . collection . remove ( { _id : this . _doc . _id } , tick ( function ( err ) { if ( err ) { this . _removing = null ; return promise . error ( err ) ; } promise . complete ( ) ; self . emit ( 'remove' ) ; } ) ) ; return this ; }
function ( err ) { db . close ( ) ; should . strictEqual ( null , err ) ; zang . _shardval . name . should . equal ( 'Zangief' ) ; zang . _shardval . age . should . equal ( 33 ) ; }
function ( obj , key , parent , type ) { if ( key === 'id' && parent . id ) { parent . _id = parent . id ; delete parent . id ; } }
function ( err , results ) { debug ( "Get listener called back with" , err || results ) ; if ( err ) { return fn ( err ) ; } if ( query . id && Array . isArray ( results ) ) return fn ( null , results [ 0 ] ) ; fn ( null , results ) ; }
function ( filename ) { return path . extname ( filename ) . toLowerCase ( ) === '.js' ; }
function wrapWord ( text ) { if ( ! text . length ) { return null ; } var shadow = shadowNode . cloneNode ( ) , orig = origNode . cloneNode ( ) , copy = copyNode . cloneNode ( ) ; shadow . appendChild ( copy ) ; shadow . appendChild ( orig ) ; shadow . appendChild ( document . createTextNode ( " " ) ) ; orig . appendChild ( document . createTextNode ( text ) ) ; copy . appendChild ( document . createTextNode ( text ) ) ; return shadow ; }
function ( event ) { that . filters = [ ] ; $ ( that . eloutput ) . empty ( ) ; that . logr . resetFrom ( that . from ) ; that . from = null ; that . listFilters ( ) ; }
function ( callback ) { this . timer = null ; this . filters = [ ] ; this . callback = callback ; this . cursor = ( ( new Date ( ) ) . getTime ( ) / 1000.0 ) - 1.0 ; this . getLogs ( ) ; }
function ( logs ) { if ( logs . data !== null ) { that . callback ( logs ) ; that . updateCursor ( logs . to ) ; } else { } that . timer = setTimeout ( $ . proxy ( that . getLogs , that ) , 1000 ) ; }
function ( ) { var position = forcePositionIntoWindow ( { top : SurfaceTypeManager . pinTop , left : SurfaceTypeManager . pinLeft } ) ; SurfaceTypeManager . setFloatingPosition ( position ) ; surface . $element . css ( { 'position' : 'fixed' , 'top' : position . top , 'left' : position . left } ) ; }
function ( ) { var newKeywords ; switch ( keyType ) { case 'metaphone' : newKeywords = this . metaKeywords ( ) ; case 'stem' : newKeywords = this . stemKeywords ( ) ; case 'plain' : newKeywords = this . plainKeywords ( ) ; } this . set ( keywordsPath , newKeywords ) ; return newKeywords ; }
function ( ) { var p = new Person ( { name : { last : 'agent' , first : 'smith' } } ) ; assert . ok ( p . keywordize ( ) instanceof Array ) ; assert . equal ( 2 , p . keywordize ( ) . length ) ; }
function ( ) { var s = new Schema ( { name : String } ) ; var opts = { fields : 'name' , upper : true } ; s . plugin ( keywords , opts ) ; var A = mongoose . model ( 'A' , s ) ; var a = new A ; a . name = 'Stravinsky' assert . equal ( a . keywordize ( ) [ 0 ] , 'Stravinsky' ) ; }
function ( next ) { var p = new Person ( { name : { last : 'heckmann' } } ) ; assert . equal ( p . keywords . length , 0 ) ; p . save ( function ( err ) { if ( err ) return next ( err ) ; assert . equal ( p . keywords . length , 1 ) ; assert . equal ( p . keywords [ 0 ] , 'heckmann' ) ; next ( ) ; } ) ; }
function ( url ) { var sep ; if ( ( this . api_key != null ) && ( url != null ) ) { sep = url . indexOf ( '?' ) > 0 ? '&' : '?' ; return url + sep + 'api_key=' + this . api_key ; } else { return url ; } }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Inspector.evaluateForTestInFrontend' , [ 'testCallId' , 'script' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Inspector.inspect' , [ 'object' , 'hints' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Inspector.didCreateWorker' , [ 'id' , 'url' , 'isShared' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Inspector.didDestroyWorker' , [ 'id' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Inspector' , this ) ; }
function ( frameId , url , query , caseSensitive , isRegex , opt_callback ) { var paramObject = { 'frameId' : frameId , 'url' : url , 'query' : query , 'caseSensitive' : caseSensitive , 'isRegex' : isRegex , } ; chrome . devtools . remoteDebug . sendCommand ( 'Page.searchInResource' , paramObject , opt_callback ) ; }
function ( width , height , fontScaleFactor , fitWindow , opt_callback ) { var paramObject = { 'width' : width , 'height' : height , 'fontScaleFactor' : fontScaleFactor , 'fitWindow' : fitWindow , } ; chrome . devtools . remoteDebug . sendCommand ( 'Page.setDeviceMetricsOverride' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Page.domContentEventFired' , [ 'timestamp' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Page.loadEventFired' , [ 'timestamp' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Page.frameNavigated' , [ 'frame' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Page.frameDetached' , [ 'frameId' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Page' , this ) ; }
function ( expression , objectGroup , includeCommandLineAPI , doNotPauseOnExceptionsAndMuteConsole , contextId , returnByValue , opt_callback ) { var paramObject = { 'expression' : expression , 'objectGroup' : objectGroup , 'includeCommandLineAPI' : includeCommandLineAPI , 'doNotPauseOnExceptionsAndMuteConsole' : doNotPauseOnExceptionsAndMuteConsole , 'contextId' : contextId , 'returnByValue' : returnByValue , } ; chrome . devtools . remoteDebug . sendCommand ( 'Runtime.evaluate' , paramObject , opt_callback ) ; }
function ( objectId , functionDeclaration , arguments , doNotPauseOnExceptionsAndMuteConsole , returnByValue , opt_callback ) { var paramObject = { 'objectId' : objectId , 'functionDeclaration' : functionDeclaration , 'arguments' : arguments , 'doNotPauseOnExceptionsAndMuteConsole' : doNotPauseOnExceptionsAndMuteConsole , 'returnByValue' : returnByValue , } ; chrome . devtools . remoteDebug . sendCommand ( 'Runtime.callFunctionOn' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Console.messageAdded' , [ 'message' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Console.messageRepeatCountUpdated' , [ 'count' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Console.messagesCleared' , [ '' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Console' , this ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Database.addDatabase' , [ 'database' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Database.sqlTransactionSucceeded' , [ 'transactionId' , 'columnNames' , 'values' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Database.sqlTransactionFailed' , [ 'transactionId' , 'sqlError' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Database' , this ) ; }
function ( requestId , frameId , databaseName , objectStoreName , indexName , skipCount , pageSize , keyRange , opt_callback ) { var paramObject = { 'requestId' : requestId , 'frameId' : frameId , 'databaseName' : databaseName , 'objectStoreName' : objectStoreName , 'indexName' : indexName , 'skipCount' : skipCount , 'pageSize' : pageSize , 'keyRange' : keyRange , } ; chrome . devtools . remoteDebug . sendCommand ( 'IndexedDB.requestData' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'DOMStorage.addDOMStorage' , [ 'storage' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'DOMStorage.domStorageUpdated' , [ 'storageId' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'DOMStorage' , this ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'ApplicationCache.applicationCacheStatusUpdated' , [ 'frameId' , 'manifestURL' , 'status' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'ApplicationCache.networkStateUpdated' , [ 'isNowOnline' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'ApplicationCache' , this ) ; }
function ( x , y , width , height , color , outlineColor , opt_callback ) { var paramObject = { 'x' : x , 'y' : y , 'width' : width , 'height' : height , 'color' : color , 'outlineColor' : outlineColor , } ; chrome . devtools . remoteDebug . sendCommand ( 'DOM.highlightRect' , paramObject , opt_callback ) ; }
function ( nodeId , forcedPseudoClasses , includePseudo , includeInherited , opt_callback ) { var paramObject = { 'nodeId' : nodeId , 'forcedPseudoClasses' : forcedPseudoClasses , 'includePseudo' : includePseudo , 'includeInherited' : includeInherited , } ; chrome . devtools . remoteDebug . sendCommand ( 'CSS.getMatchedStylesForNode' , paramObject , opt_callback ) ; }
function ( styleId , propertyIndex , text , overwrite , opt_callback ) { var paramObject = { 'styleId' : styleId , 'propertyIndex' : propertyIndex , 'text' : text , 'overwrite' : overwrite , } ; chrome . devtools . remoteDebug . sendCommand ( 'CSS.setPropertyText' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'CSS.mediaQueryResultChanged' , [ '' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'CSS.styleSheetChanged' , [ 'styleSheetId' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'CSS' , this ) ; }
function ( lineNumber , url , urlRegex , columnNumber , condition , opt_callback ) { var paramObject = { 'lineNumber' : lineNumber , 'url' : url , 'urlRegex' : urlRegex , 'columnNumber' : columnNumber , 'condition' : condition , } ; chrome . devtools . remoteDebug . sendCommand ( 'Debugger.setBreakpointByUrl' , paramObject , opt_callback ) ; }
function ( scriptId , query , caseSensitive , isRegex , opt_callback ) { var paramObject = { 'scriptId' : scriptId , 'query' : query , 'caseSensitive' : caseSensitive , 'isRegex' : isRegex , } ; chrome . devtools . remoteDebug . sendCommand ( 'Debugger.searchInContent' , paramObject , opt_callback ) ; }
function ( callFrameId , expression , objectGroup , includeCommandLineAPI , doNotPauseOnExceptionsAndMuteConsole , returnByValue , opt_callback ) { var paramObject = { 'callFrameId' : callFrameId , 'expression' : expression , 'objectGroup' : objectGroup , 'includeCommandLineAPI' : includeCommandLineAPI , 'doNotPauseOnExceptionsAndMuteConsole' : doNotPauseOnExceptionsAndMuteConsole , 'returnByValue' : returnByValue , } ; chrome . devtools . remoteDebug . sendCommand ( 'Debugger.evaluateOnCallFrame' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Worker.workerCreated' , [ 'workerId' , 'url' , 'inspectorConnected' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Worker.workerTerminated' , [ 'workerId' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Worker.dispatchMessageFromWorker' , [ 'workerId' , 'message' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Worker.disconnectedFromWorker' , [ '' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Worker' , this ) ; }
function loadCodon ( sequence ) { var i , codonArray = [ ] , currentCodon ; for ( i = 0 ; i < sequence . length ; i += 3 ) { currentCodon = sequence . substring ( i , i + 3 ) ; codonArray . push ( currentCodon ) ; } return codonArray ; }
function ( button , event , options ) { if ( form . getForm ( ) . isValid ( ) ) { var v = form . getForm ( ) . getFieldValues ( true ) , m = form . getForm ( ) . getRecord ( ) ; if ( ! m ) return ; for ( var e in v ) m . set ( e , v [ e ] ) ; store . sync ( ) ; } }
function ( hex ) { var cm = this . editor . _codeMirror ; var end = { line : this . pos . line , ch : this . pos . ch + this . color . length } ; cm . replaceRange ( hex , this . pos , end ) ; this . color = hex ; }
function ( elementName , attributes ) { var formattedAttributes = [ ] ; for ( attribute in attributes || { } ) { if ( Object . prototype . hasOwnProperty . call ( attributes , attribute ) ) { formattedAttributes . push ( attribute + '="' + this . xmlAttributeEncode ( attributes [ attribute ] ) + '"' ) ; } } return '<' + elementName + ' ' + formattedAttributes . join ( ' ' ) + '>' ; }
function ( cmd ) { if ( cmd === 'quit' ) { con . ok ( 'All done, shutting down.' ) ; forwards . forEach ( function ( f ) { f . end ( ) ; } ) ; rl . close ( ) ; stopVPN ( config , process . exit ) ; } else { if ( cmd !== '' ) { con . error ( 'Invalid command "' + cmd + '"' ) ; } rl . prompt ( ) ; } }
function ( code , signal ) { var gitsha = buf . toString ( ) . trim ( ) ; if ( gitsha && gitsha . length === 7 ) { sha = gitsha logger . info ( 'code version (via git) is: ' + module . exports ( ) ) ; } else { logger . warn ( 'code version (randomly generated) is: ' + module . exports ( ) ) ; } }
function ( err ) { callback ( "[server.fontomas.font.download] File not found: " + req . url ) ; }
function ( err ) { callback ( "File not found" ) ; callback ( "[server.static] File not found: " + req . url ) ; }
function ( event ) { if ( event . ctrlKey && ( event . keyCode == 13 || event . keyCode == 10 ) ) { $ ( "#commentform" ) . submit ( ) ; } }
function ( arguments_to_next ) { this . emit ( "work:done" , [ this ] ) ; this . $__fired = false ; this . $__queued . shift ( ) ; if ( arguments_to_next ) { this . $__args = Array . from ( arguments_to_next ) ; } this . fire ( true ) ; }
function ( ) { Iterable_it = new $ . Iterable ( ) . set ( "field1" , "value1" ) . set ( "field2" , 2 ) . set ( "field3" , { } ) . set ( "field4" , [ ] ) . set ( "field5" , new Date ( ) ) ; }
function ( obj , selector , method ) { var self = this ; if ( ! util . isAgility ( obj ) ) { throw "agility.js: append argument is not an agility object" ; } this . _container . children [ obj . _id ] = obj ; this . trigger ( method , [ obj , selector ] ) ; obj . bind ( 'destroy' , function ( event , id ) { self . _container . remove ( id ) ; } ) ; return this ; }
function ( ) { var fileNames , idx , numFiles ; numFiles = this . storageImpl . length ; idx = 0 ; fileNames = [ ] ; while ( idx < numFiles ) { fileNames . push ( localStorage . key ( idx ) ) ; ++ idx ; } return fileNames ; }
function ( ) { $ ( "table.scoreDisplay" ) . dataTable ( { "bPaginate" : true , "bLengthChange" : true , "bFilter" : true , "bSort" : true , "bInfo" : true , "bAutoWidth" : false , "aaSorting" : [ [ 3 , 'desc' ] , [ 0 , 'asc' ] ] } ) ; $ ( ".scoreContent" ) . show ( ) ; midas . challenge . competitor . showscoreSetup ( ) ; }
function ( ) { var noop = function ( ) { } , textManager = new TextManager ( ) ; textManager . writeText ( "foo" ) ; textManager . render ( { context : { fillText : noop } } , 0 ) ; equal ( textManager . items . length , 0 , "buffer cleared by renderText" ) ; }
function ( server , image , resolution , sds , contrast , k , x , y ) { var r = this . num_resolutions - resolution ; var f = this . getMultiplier ( r , this . tileSize . w ) ; var djatoka_x = x * f ; var djatoka_y = y * f ; var src = server + this . url_ver + image + "&svc_id=" + this . svc_id + "&svc_val_fmt=" + this . svc_val_fmt + "&svc.format=image/jpeg&svc.level=" + resolution + "&svc.rotate=0&svc.region=" + djatoka_y + "," + djatoka_x + ",256,256" ; return src ; }
function ( response ) { var p = eval ( "(" + response + ")" ) ; var w = parseInt ( p . width ) ; var h = parseInt ( p . height ) ; var num_resolutions = parseInt ( p . levels ) + 1 ; var result = { 'max_size' : { w : w , h : h } , 'tileSize' : { w : 256 , h : 256 } , 'num_resolutions' : num_resolutions } ; return result ; }
function ( result ) { if ( result . await != null ) { $timeout ( makeMatch , 5000 ) ; return ; } $scope . isMyTurn = true ; $scope . waitingForOpponent = false ; loadGame ( result . game_id ) ; }
function ( chunk ) { seq ++ ; console . log ( wsResponse . id ) ; connection . sendBytes ( wslib . loadWsChunk ( wsResponse . id , chunk , 1 , seq ) , function ( err ) { if ( err ) { console . error ( "send()data error: " + err ) ; } } ) ; }
function ( ) { seq ++ ; console . log ( wsResponse . id ) ; connection . sendBytes ( wslib . loadWsChunk ( wsResponse . id , '' , 8 , seq ) , function ( err ) { if ( err ) console . error ( "send()end error: " + err ) ; } ) ; }
function ( a , b ) { return _ . indexOf ( self . state . get ( 'columnsOrder' ) , a . id ) > _ . indexOf ( self . state . get ( 'columnsOrder' ) , b . id ) ; }
function ( a , b ) { return _ . indexOf ( self . state . get ( 'columnsOrder' ) , a . id ) > _ . indexOf ( self . state . get ( 'columnsOrder' ) , b . id ) ; }
function render ( target , repos ) { var i = 0 , t = $ ( target ) [ 0 ] ; var fragment = '<li class="nav-header">My GitHub Repos</li>' ; for ( i = 0 ; i < repos . length ; i ++ ) { fragment += '<li><a href="' + repos [ i ] . url + '">' + repos [ i ] . name + '</a><p>' + repos [ i ] . description + '</p></li>' ; } t . innerHTML = fragment ; }
function init ( ) { disableDefaultKeys ( ) ; bindKeypress ( ) ; setLesson ( ) ; }
function ( ) { text_field = $ ( '#text-field' ) ; input_field = $ ( '#input-field' ) ; training_text = '' ; lecture = new Lecture ( ) ; time1 = false , time2 = false ; View = new VIEW ( ) ; Model = new MODEL ( ) ; Controller = new CONTROLLER ( ) ; }
function ( data , textStatus , jqXHR ) { console . log ( 'args.success' ) ; if ( data [ 0 ] == AJAX_ERROR ) { if ( args . error != undefined ) args . error ( data [ 1 ] ) ; else console . error ( 'AJAX Error: ' + data [ 1 ] ) ; } else s_fn ( data [ 1 ] ) ; }
function ( e ) { var $this = $ ( this ) , data = $this . data ( 'spritespin' ) ; Spin . updateInput ( e , data ) ; if ( data . currentX > data . width / 2 ) { $this . spritespin ( "frame" , data . frame + 1 ) ; } else { $this . spritespin ( "frame" , data . frame - 1 ) ; } }
function ( e ) { var $this = $ ( this ) , data = $this . data ( 'spritespin' ) ; if ( data . onDrag ) { data . onDrag = false ; $this . spritespin ( "animate" , $this . spritespin ( "animate" ) ) ; } return false ; }
function ( e , data ) { if ( data . ddX !== 0 ) { data . frameTime = data . frameTime + 1 ; $ ( this ) . spritespin ( "animate" , false ) ; if ( data . frameTime < 62 ) { $ ( this ) . spritespin ( "animate" , true ) ; } } else { $ ( this ) . spritespin ( "animate" , false ) ; } return false ; }
function ( data , andInit ) { if ( andInit ) { data . module . initialize ( data ) ; } Spin . prepareBackground ( data ) ; Spin . preloadImages ( data , function ( ) { Spin . rebindEvents ( data ) ; data . module . reload ( data ) ; data . target . trigger ( "onLoad" , data ) ; } ) ; }
function ( ) { data . preload . fadeOut ( 250 ) ; data . stage . show ( ) ; callback . apply ( data . target , [ data ] ) ; }
function ( data , andInit ) { if ( andInit ) { data . module . initialize ( data ) ; } Spin . prepareBackground ( data ) ; Spin . preloadImages ( data , function ( ) { Spin . rebindEvents ( data ) ; data . module . reload ( data ) ; data . target . trigger ( "onLoad" , data ) ; } ) ; }
function ( ) { data . preload . fadeOut ( 250 ) ; data . stage . show ( ) ; callback . apply ( data . target , [ data ] ) ; }
function ( e ) { var $this = $ ( this ) , data = $this . data ( 'spritespin' ) ; Spin . updateInput ( e , data ) ; if ( data . currentX > data . width / 2 ) { $this . spritespin ( "frame" , data . frame + 1 ) ; } else { $this . spritespin ( "frame" , data . frame - 1 ) ; } }
function ( e ) { var $this = $ ( this ) , data = $this . data ( 'spritespin' ) ; if ( data . onDrag ) { data . onDrag = false ; $this . spritespin ( "animate" , $this . spritespin ( "animate" ) ) ; } return false ; }
function ( e , data ) { if ( data . ddX !== 0 ) { data . frameTime = data . frameTime + 1 ; $ ( this ) . spritespin ( "animate" , false ) ; if ( data . frameTime < 62 ) { $ ( this ) . spritespin ( "animate" , true ) ; } } else { $ ( this ) . spritespin ( "animate" , false ) ; } return false ; }
function ( ) { console . log ( 'drawMap' ) console . log ( '**ispName = ' + ispName ) ; for ( var i = markers . length - 1 ; i >= 0 ; i -- ) { markers [ i ] . inCircle = searchCircle . contains ( markers [ i ] . getPosition ( ) ) ; } tintSearchCircle ( ) ; }
function ( ) { if ( document . namespaces && ! document . namespaces [ this . ns ] ) { document . namespaces . add ( this . ns , 'urn:schemas-microsoft-com:vml' ) ; } if ( window . attachEvent ) { window . attachEvent ( 'onbeforeunload' , function ( ) { DD_belatedPNG = null ; } ) ; } }
function ( el ) { el . runtimeStyle . cssText = '' ; this . vmlFill ( el ) ; this . vmlOffsets ( el ) ; this . vmlOpacity ( el ) ; if ( el . isImg ) { this . copyImageBorders ( el ) ; } }
function ( el ) { var styles = { 'borderStyle' : true , 'borderWidth' : true , 'borderColor' : true } ; for ( var s in styles ) { el . vml . color . shape . style [ s ] = el . currentStyle [ s ] ; } }
function ( ) { nock . restore ( ) ; ret = nock . recorder . play ( ) ; t . equal ( ret . length , 1 ) ; t . equal ( ret [ 0 ] . indexOf ( "\nnock('expensecat.iriscouch.com')\n  .post('/'\"ABCDEF\")\n  .reply(" ) , 0 ) ; t . end ( ) ; }
function ( chunk , context , bodies , params ) { if ( params && params . key ) { var key = params . key ; key = this . tap ( key , chunk , context ) ; return chunk . render ( bodies . block , context . push ( { isSelect : true , isResolved : false , value : context . get ( key ) } ) ) ; } else { _console . log ( "No key given in the select helper!" ) ; } return chunk ; }
function ( size , color ) { var g = new Graphics ( ) ; if ( color === undefined ) color = Graphics . getRGB ( 255 , 255 , 255 , 1 ) ; g . beginFill ( color ) ; g . drawCircle ( 0 , 0 , size ) ; var shape = new Shape ( g ) ; stage . addChild ( shape ) ; objects . push ( shape ) ; }
function ( index , x , y , rotation , scaleX , scaleY , alpha ) { objects [ index ] . x = x ; objects [ index ] . y = y ; objects [ index ] . rotation = rotation ; objects [ index ] . scaleX = scaleX ; objects [ index ] . scaleY = scaleY ; objects [ index ] . alpha = alpha ; }
function ( tag_obj ) { if ( ! this . sound_manager ) { this . sound_manager = this . manager . sound_manager ; } if ( ! this . xml_manager ) { this . xml_manager = this . manager . xml_manager ; } this . manager . setMaxEndTime ( this . sound_manager . add ( this . xml_manager . replaceVars ( tag_obj . src ) ) ) ; return null ; }
function ( ) { 'use strict' ; jQuery ( document ) . ready ( function ( ) { jQuery ( 'ul.repo_filterer li a' ) . each ( function ( ) { try { var elem = jQuery ( this ) , selector = elem . attr ( 'rel' ) , elements = jQuery ( 'ul.repo_list' ) . find ( 'li.' + selector ) ; elem . append ( ' (' + elements . size ( ) + ')' ) ; } catch ( e ) { } } ) ; } ) ; }
function ( phonetic ) { var code = phonetic . charCodeAt ( 0 ) ; if ( code === 90 || code === 74 ) return 0 ; if ( code >= 65 && code <= 73 ) return ( code - 64 ) ; if ( code >= 75 && code <= 77 ) return ( code - 65 ) ; if ( code >= 78 && code <= 89 ) return ( 0 - ( code - 78 ) ) ; }
function ( key ) { var name = data . departments [ key ] [ 0 ] ; var id = data . departments [ key ] [ 1 ] ; $ ( "#dept_doc_v" ) . append ( "<option val=" + id + ">" + name + "</option>" ) ; }
function ( service , callback ) { var self = this ; var cached = self . _services [ service ] ; if ( ! cached ) { throw new Error ( "Unknown service" ) ; } else if ( cached . ready ) { callback ( null , cached . context ) ; } else { self . use ( service , function ( error ) { if ( error ) return callback ( error ) ; callback ( null , self . _services [ service ] . introspected ) ; } ) ; } }
function ( data ) { console . log ( data . message ) ; }
function ( username , channelName , channelServer , msg_object ) { Channel . findOne ( { name : channelName . toLowerCase ( ) , user : username } , function ( err , channel ) { if ( ! channel ) { var channel = new Channel ( { name : channelName . toLowerCase ( ) , server : channelServer . toLowerCase ( ) , user : username } ) ; } channel . messages . push ( msg_object ) ; channel . save ( ) ; } ) ; }
function ( $slider , showNextSlide , movingSlides ) { var $sliderContainer = $ ( $slider . children ( ) . get ( 0 ) ) , $slides = $sliderContainer . children ( ) , $selectedSlides = showNextSlide ? $slides . slice ( 0 , movingSlides ) : $slides . slice ( - 1 * movingSlides ) ; showNextSlide ? $sliderContainer . append ( $selectedSlides ) : $sliderContainer . prepend ( $selectedSlides ) ; }
function ( e , showNextSlide ) { var $slider = $this ; if ( $slider . filter ( ":animated" ) . length === 0 ) { var visibleSlides = Math . ceil ( $slider . outerWidth ( ) / $slider . find ( '.responSlider-slide' ) . outerWidth ( ) ) ; _effects [ _options . effect ] ( $slider , showNextSlide , Math . min ( _options . movingSlides , visibleSlides ) ) ; } }
function ( ) { var spr_count = $ ( "input[name^='speaker_row']" ) . length + 1 ; var spr = 'speaker_row[new_' + spr_count + ']' ; $ ( '#speaker_row_container' ) . append ( '<input type="text" name="' + spr + '" class="speaker_row"/>' ) ; speaker_row_ct ++ ; }
function ( ) { for ( var i = 0 ; i < gco . level ; i ++ ) { this . objectives . push ( Math . floor ( Math . random ( ) * 25 ) + 35 ) ; this . progress . push ( 0 ) ; } }
function ( ) { var completion = [ ] ; for ( var i = 0 ; i < gco . level ; i ++ ) { if ( this . progress [ i ] >= this . objectives [ i ] ) { } else { return false ; } } return true ; }
function ( event , pos , item ) { if ( ! item ) { $ ( "#hover_tooltip" ) . remove ( ) ; previousPoint = null ; } else if ( previousPoint != item . dataIndex ) { previousPoint = item . dataIndex ; $ ( "#hover_tooltip" ) . remove ( ) ; var contents = generate_tooltip ( item , "hover_tooltip" ) ; show_tooltip ( item . pageX + 10 , item . pageY , contents ) ; } }
function ( ev ) { switch ( ev . which ) { case 8 : if ( this . value == "" && confirm ( 'Frage löschen?' ) ) { removeQuestion ( $ ( this ) . parent ( ) ) ; return false ; } break ; } }
function ( jqXHR , textStatus , errorThrown ) { if ( jqXHR . status == 403 ) { alert ( 'Sitzung abgelaufen. Neu anmelden' ) ; location . reload ( ) ; } else { alert ( "Fehler: " + textStatus + " (" + errorThrown + ")" ) ; } }
function buildQuestions ( ) { if ( exam != null ) { $ ( exam . Question ) . each ( function ( index , question ) { addQuestion ( index , $ ( '#questions' ) ) ; } ) ; } else { alert ( "Empty exam" ) ; } }
function addQuestionCounter ( el , className ) { $ ( '<div class="' + className + '"></div>' ) . append ( "Frage " ) . append ( $ ( '<span id="questions-answers-count">0</span>' ) ) . append ( " von " ) . append ( $ ( '<span id="questions-total-count">0</span>' ) ) . appendTo ( $ ( el ) ) ; }
function getDialog ( content ) { var modal = $ ( '<div class="dialog-modal"></div>' ) ; var div_content = $ ( '<div class="dialog-modal-content"></div>' ) . append ( content ) . append ( $ ( '<a class="dialog-modal-btn-close button"></a>' ) . text ( 'close' ) . click ( function ( ) { modal . hide ( ) ; } ) ) . appendTo ( modal ) ; return modal ; }
function appendComment ( target , comment ) { target . append ( $ ( "<p class='comment'></p>" ) . html ( comment . comment ) . append ( $ ( "<span class='comment-author'></span>" ) . text ( ( comment . User . username ) ? comment . User . username : "unbekannt" ) ) ) ; }
function ( ) { curSlide = slideNum ; var items = NW . Dom . select ( '.experis-slider > ul li' , wrapper . parentNode ) ; for ( var n = 0 , item ; item = items [ n ++ ] ; ) { item . className = item . className . replace ( ' selected' , '' ) ; } items [ curSlide - 1 ] . className += ' selected' ; if ( mouseStatus === 'out' ) startSlider ( ) ; }
function ( path ) { if ( typeof path !== "string" ) { console . log ( "String type is needed for file which is to be read." ) ; return false ; } var url = fsUtils . fs . root . toURL ( ) + path ; return url ; }
function get_chrome ( uri , tag , callback ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( 'GET' , uri , true ) ; xhr . overrideMimeType ( 'text/plain; charset=x-user-defined' ) ; xhr . responseType = 'arraybuffer' ; xhr . onload = function ( e ) { if ( this . status == 200 ) { callback ( findOgg ( this . response , tag ) , tag , uri ) ; } } xhr . send ( ) ; }
function ( script_url , callback ) { $ . ajax ( { url : script_url , dataType : "script" , success : callback , async : callback != undefined } ) }
function ( ) { $ ( '#rightbar-actions .icon-arrow-left' ) . removeClass ( 'icon-arrow-left' ) . addClass ( 'icon-arrow-right' ) ; $ ( 'div#rightbar' ) . show ( ) ; $ ( 'div#rightbar' ) . animate ( { right : 0 , opacity : 100 } , animationSpeed ) ; $ ( 'div#content' ) . animate ( { right : 250 } , animationSpeed , function ( ) { return setUpMapDimensions ( ) ; } ) ; return this ; }
function ( map ) { this . _map = map ; if ( ! this . _image ) { this . _initImage ( ) ; } map . _panes . overlayPane . appendChild ( this . _image ) ; map . on ( 'viewreset' , this . _reset , this ) ; this . _reset ( ) ; }
function ( ) { this . _image = L . DomUtil . create ( 'img' , 'leaflet-image-layer leaflet-zoom-hide' ) ; this . _image . style . visibility = 'hidden' ; this . _updateOpacity ( ) ; L . Util . extend ( this . _image , { galleryimg : 'no' , onselectstart : L . Util . falseFn , onmousemove : L . Util . falseFn , onload : L . Util . bind ( this . _onImageLoad , this ) , src : this . _url } ) ; }
function ( ) { var container = this . _container , stroke , fill ; if ( this . options . stroke ) { stroke = this . _stroke = this . _createElement ( 'stroke' ) ; stroke . endcap = 'round' ; container . appendChild ( stroke ) ; } if ( this . options . fill ) { fill = this . _fill = this . _createElement ( 'fill' ) ; container . appendChild ( fill ) ; } this . _updateStyle ( ) ; }
function ( response ) { var obj = jQuery . parseJSON ( response ) ; var urladdress = obj . picture ; var msg = "<image src=" + urladdress + " width= 220px; height=150px />" ; msg += "<button id='changePicture_btn' style='position:absolute; left:160px; top:50px' onclick='showChangeProfileDialog()'> Change </button>" ; document . getElementById ( 'profilePictureDiv' ) . innerHTML = msg ; $ ( "#changePicture_btn" ) . hide ( ) ; }
function ( ) { TissueStack . Utils . adjustScreenContentToActualScreenSize ( 0 ) ; _this . addToOrReplaceSelectedDataSets ( dataSet . id , 0 ) ; _this . showDataSet ( 1 ) ; TissueStack . InitUserInterface ( ) ; TissueStack . BindDataSetDependentEvents ( ) ; }
function ( ) { return $ ( '<a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>' ) . attr ( 'data-url' , this . _get_uri ) . attr ( 'counturl' , this . _get_uri ) . attr ( 'data-via' , this . options . reply_to ) . attr ( 'data-lang' , this . options . language ) . attr ( 'data-related' , this . options . reply_to ) . attr ( 'data-dnt' , true ) ; }
function ( ) { $ . ajax ( { url : "../template/BlogListEntry.tmpl" , dataType : "html" , success : function ( data ) { $ ( "head" ) . append ( data ) ; } } ) ; for ( var i = 0 ; i < $ ( 'article' ) . length ; i ++ ) { $ ( "#postButton" + i ) . on ( 'click' , function ( ) { App . openBlogPost ( i ) ; return false ; } ) ; } }
function checkMustAuth ( ) { var must_auth = true ; if ( uid && req . session . userid === uid ) { must_auth = false ; } else if ( ! uid && typeof req . session . pendingCreation === 'string' && req . query . token === req . session . pendingCreation ) { must_auth = false ; } res . json ( { success : true , email : email , must_auth : must_auth } ) ; }
function onInitialize ( signal , deferred ) { var self = this ; var $element = self [ _$ELEMENT ] = self [ $ELEMENT ] ; self [ $ELEMENT ] = $ ( $element . get ( 0 ) . contentDocument ) ; if ( deferred ) { deferred . resolve ( ) ; } }
function _getAttribute ( aAttribute ) { this . logInfo ( "@" + aAttribute + "=" + this [ "@" + aAttribute ] ) ; return this . convertSpecialCharatersFromXML ( this [ "@" + aAttribute ] ) ; }
function getCanvasData ( elem ) { var data = $ . data ( elem , 'jCanvas' ) ; if ( ! data ) { data = $ . data ( elem , 'jCanvas' , { layers : [ ] , intersects : [ ] , drag : { } , events : { x : [ ] , y : [ ] } } ) ; } return data ; }
function ( event ) { eventCache . x [ 1 ] = eventCache . x [ 0 ] ; eventCache . y [ 1 ] = eventCache . y [ 0 ] ; eventCache . x [ 0 ] = event . offsetX ; eventCache . y [ 0 ] = event . offsetY ; eventCache . type = helperEventName ; $elem . drawLayers ( TRUE ) ; event . preventDefault ( ) ; }
function ( ) { this . copyObj . draw ( this . canvas ) ; this . overlay . ctx . clearRect ( 0 , 0 , this . width , this . height ) ; this . endDraw ( clip ) ; }
function ( id ) { if ( id == "logoutbtn" ) { pokki . rpc ( 'pokki.openPopup()' ) ; pokki . rpc ( 'showLogoutPopup()' ) ; GoogleReader . logout ( ) ; pokki . resetContextMenu ( ) ; } else if ( id == "markallasread" ) { BackgroundWorker . markAllAsRead ( ) ; } }
function ( result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , question : result . _id } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 } ) ) ; }
function ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 } ) ) ; }
function ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 } ) ) ; }
function ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 } ) ) ; }
function ( context , expr , type , mayUnbox ) { if ( ! this . isConvertibleTo ( context , expr , type , mayUnbox ) ) { context . errors . push ( new CompileError ( this . _token , "cannot apply operator '" + this . _token . getValue ( ) + "' to type '" + exprType . toString ( ) + "'" ) ) ; return false ; } return true ; }
function ( ) { var manifest = this . manifest ; if ( ! manifest . css ) return ; Echo . Utils . addCSS ( this . substitute ( manifest . css ) , "plugins-" + manifest . name ) ; }
function ( ) { if ( ! self . vars . cache . itemTemplate ) { self . vars . cache . itemTemplate = $ . isFunction ( template ) ? template . apply ( this , arguments ) : template ; } return self . vars . cache . itemTemplate ; }
function ( element ) { var content = this . config . get ( "data.object.content" ) ; if ( content ) { element . val ( content ) ; } return element . iHint ( { "text" : this . config . get ( "actionString" ) , "className" : "echo-secondaryColor" } ) ; }
function ( element ) { var component = this . component ; return element . text ( this . config . get ( "data.actor.title" ) || component . labels . get ( "guest" ) ) ; }
function ( e ) { e . preventDefault ( ) ; window . location . hash = $ ( e . target ) . attr ( 'href' ) ; }
function ( e ) { e . preventDefault ( ) ; var d = new HAL . Views . QueryUriDialog ( { href : $ ( e . target ) . attr ( 'href' ) } ) . render ( ) ; d . $el . dialog ( { title : 'Query URI Template' , width : 400 } ) ; window . foo = d ; }
function ( e ) { e . preventDefault ( ) ; on . emit ( e . target , "click" , { cancelable : true , bubbles : true } ) ; }
function ( ) { var toReturn = [ ] ; for ( var i = 0 ; i < args . length ; i ++ ) { toReturn . push ( '' + args [ i ] ) ; } return toReturn . join ( "" ) ; }
function ( $jc$ ) { var p = $jc$ . pstack [ $jc$ . pscope ] . join ( ', ' ) , str = 'var f = function (' + p + ') {\n$jc$.sstack.push([]);\n$jc$.scope++;\nvar r = (function () {\n' + $jc$ . compile ( node . children [ 1 ] , true ) + '})();\n$jc$.sstack.pop();\n$jc$.scope--;\nreturn r;\n}; f;' ; return eval ( str ) ; }
function compileHandler ( ) { var worked = false ; console . log ( 'compile' ) ; try { worked = $ . hakadoo . validate ( questionIndex , you . getValue ( ) ) ; $ ( '#console' ) . prepend ( '<li class="positive">Congratulations! You win!</li>' ) ; } catch ( e ) { worked = false ; $ ( '#console' ) . prepend ( '<li>' + e . message + '</li>' ) ; } socket . emit ( 'compile' , { worked : worked } ) ; }
function openKeyCursor ( evt ) { event = evt ; shouldBeEqualToString ( "event.target.result" , "key2" ) ; self . request = evalAndLog ( "indexObject.openKeyCursor()" ) ; request . onsuccess = cursor1Continue ; request . onerror = unexpectedErrorCallback ; }
function openObjectCursor ( evt ) { event = evt ; shouldBeNull ( "event.target.result" ) ; self . request = evalAndLog ( "indexObject.openCursor()" ) ; request . onsuccess = cursor2Continue ; request . onerror = unexpectedErrorCallback ; }
function deleteExisting ( ) { self . trans = evalAndLog ( "trans = event.target.result" ) ; shouldBeNonNull ( "trans" ) ; trans . onabort = unexpectedAbortCallback ; deleteAllObjectStores ( db ) ; self . objectStore = evalAndLog ( "db.createObjectStore('someObjectStore')" ) ; self . nextToAdd = 0 ; addData ( ) ; }
function ( ) { NavMain . unlinkMainMenuItems ( ) ; $ ( '#nav-main-menu' ) . attr ( 'aria-hidden' , 'true' ) ; $ ( document ) . click ( NavMain . handleDocumentClick ) ; $ ( 'a, input, textarea, button, :focus' ) . focus ( NavMain . handleDocumentFocus ) ; NavMain . smallMode = true ; }
function ( ) { NavMain . relinkMainMenuLinks ( ) ; $ ( '#nav-main-menu' ) . removeAttr ( 'aria-hidden' ) ; $ ( document ) . unbind ( 'click' , NavMain . handleDocumentClick ) ; $ ( 'a, input, textarea, button, :focus' ) . unbind ( 'focus' , NavMain . handleDocumentFocus ) ; NavMain . smallMode = false ; NavMain . smallMenuOpen = false ; }
function ( direction ) { switch ( direction ) { case d_down : animation . y ++ ; break ; case d_up : animation . y -- ; break ; case d_left : animation . x -- ; break ; case d_right : animation . x ++ ; break ; default : break ; } if ( oldState != direction ) { this . setDirection ( direction ) ; oldState = direction ; } }
function test_localContacts_setup ( ) { param = { } ; param . usr = "" ; param . pwd = "" ; param . type = "local" ; param . addressBookName = ( document . URL . split ( '/' ) . slice ( 0 , - 1 ) . join ( '/' ) + '/' + "abook.mab" ) . replace ( "file://" , "" ) ; alert ( param . addressBookName ) ; }
function ( e , contents ) { if ( e ) { return callback ( e ) ; } self . lint ( path , contents . replace ( rshebang , '' ) , settings , callback ) ; }
function ( value ) { if ( ! value . message ) { throw new Error ( linter + " didn't return a message for a '" + type + "', bad formatting" ) ; } else if ( ! value . line ) { throw new Error ( linter + " didn't return a line number for a '" + type + "', bad formatting" ) ; } else if ( ! value . character ) { throw new Error ( linter + " didn't return a character number for a '" + type + "', bad formatting" ) ; } if ( ! value . path ) { value . path = path ; } }
function ( name ) { var self = this , indx = - 1 ; for ( var i = 0 , len = self . _players . length ; i < len ; ++ i ) { if ( player . name == name ) { indx = i ; break ; } } if ( indx > - 1 ) { self . _players . splice ( indx , 1 ) ; return true ; } else { return false ; } }
function ( str ) { var i , player , parts = str . match ( /^([0-9\-: ]+) \[INFO\] ([^\s]+) lost connection: ([\w\. ]+)$/ ) ; if ( parts ) { this . emit ( 'player::disconnect' , parts [ 2 ] ) ; this . _removePlayer ( parts [ 2 ] ) ; this . log . debug ( 'Player disconnected: ' + parts [ 2 ] ) ; } }
function ( str ) { str = str . stripColors ; var parts = str . match ( /^([0-9\-: ]+) \[INFO\] <([^>]+)> (.*)$/ ) ; if ( parts ) { this . log . debug ( 'Player ' + parts [ 2 ] + ' chatted: ' + parts [ 3 ] ) ; this . emit ( 'player::chat' , parts [ 2 ] , parts [ 3 ] ) ; } }
function ( err , proc ) { if ( err ) { psm . log . error ( err , 'Failed to start minecraft process.' ) ; if ( cb ) cb ( err ) ; return ; } self . outputs . setStream ( proc . stderr ) ; if ( cb ) cb ( null ) ; }
function ( err , response ) { console . log ( '' ) ; console . log ( 'Value for key ' + key + ' = ' + response ) ; process . exit ( 0 ) ; }
function ( err , result ) { if ( err ) { return cb ( new Error ( err ) ) ; } return cb ( null , result ) ; }
function ( folder ) { var partialDirectory = utils . fileJoin ( folder , '_partials' ) ; if ( path . existsSync ( partialDirectory ) ) { partials = loadPartials ( partialDirectory ) ; } imbue . addFilters ( fmjFilters ) ; var siteFiltersFile = utils . fileJoin ( process . cwd ( ) , folder , '_filters.js' ) ; var specific ; if ( path . existsSync ( siteFiltersFile ) ) { specific = require ( siteFiltersFile ) ; imbue . addFilters ( specific ) ; } }
function ( e ) { if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : e . preventDefault ( ) this . prev ( ) break case 40 : e . preventDefault ( ) this . next ( ) break } e . stopPropagation ( ) }
function ( e ) { if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : e . preventDefault ( ) this . prev ( ) break case 40 : e . preventDefault ( ) this . next ( ) break } e . stopPropagation ( ) }
function ( key ) { var val = obj [ key ] , signed = exports . unsign ( val , secret ) ; if ( signed ) { ret [ key ] = signed ; delete obj [ key ] ; } }
function ( ) { it ( 'should return an instance of a bulldog' , function ( ) { var dog = Bulldog . watch ( 'http://fernetjs.com' , 3600 ) ; dog . should . be . a ( Bulldog ) ; } ) ; it ( 'should receive x and y??="#=$#?=' ) ; }
function _addKeyBindingToMenuItem ( $menuItem , key , displayKey ) { var $shortcut = $menuItem . find ( ".menu-shortcut" ) ; if ( $shortcut . length === 0 ) { $shortcut = $ ( "<span class='menu-shortcut'/>" ) ; $menuItem . append ( $shortcut ) ; } $shortcut . data ( "key" , key ) ; $shortcut . text ( KeyBindingManager . formatKeyDescriptor ( displayKey ) ) ; }
function ( require , exports , module ) { 'use strict' ; console . log ( "and a file that foo depends on!" ) ; exports . bar = function bar ( ) { console . log ( "in bar in secondary!" ) ; window . setTimeout ( function ( ) { require ( "main" ) . bar ( ) ; } , 300 ) ; } ; }
function includeCommentInNextRule ( ) { if ( ruleStartChar !== - 1 ) { return false ; } if ( stream . start > 0 && lines [ line ] . substr ( 0 , stream . start ) . indexOf ( '}' ) !== - 1 ) { return false ; return true ; }
function ( template ) { var wrap = $ ( "#editor-holder" ) [ 0 ] ; this . dialog = wrap . insertBefore ( window . document . createElement ( "div" ) , wrap . firstChild ) ; this . dialog . className = "CodeMirror-dialog" ; this . dialog . innerHTML = '<div>' + template + '</div>' ; }
function setSearchFieldValue ( prefix , initialString ) { prefix = prefix || "" ; initialString = initialString || "" ; initialString = prefix + initialString ; var $field = $ ( 'input#quickOpenSearch' ) ; if ( $field ) { $field . val ( initialString ) ; $field . get ( 0 ) . setSelectionRange ( prefix . length , initialString . length ) ; } }
function ( require , exports , module ) { 'use strict' ; var CommandManager = require ( "command/CommandManager" ) ; function executeCommand ( eventName ) { var evt = window . document . createEvent ( "Event" ) ; evt . initEvent ( eventName , false , true ) ; CommandManager . execute ( eventName , { evt : evt } ) ; return evt . defaultPrevented ; } exports . executeCommand = executeCommand ; }
function updateNowPlaying ( _song , _cover ) { dynplayModel . set ( { "artist" : _song . artist , "song" : _song } ) ; var coverImg = new ui . SPImage ( _cover ) ; coverImg . node . setAttribute ( "id" , "cover_placeholder" ) ; document . getElementById ( "np_cover" ) . replaceChild ( coverImg . node , document . getElementById ( "cover_placeholder" ) ) ; enablePlayerControls ( ) ; }
function displayTabs ( _index ) { var t = [ ] ; for ( var i = 0 ; i < numTabs ; i ++ ) { t [ i ] = $ ( "#tabarea_" + i ) ; } for ( var i = 0 ; i < numTabs ; i ++ ) { if ( i == _index ) { t [ i ] . attr ( "style" , "display:block;" ) ; } else { t [ i ] . attr ( "style" , "display:none;" ) ; } } }
function ( _tid ) { url = "http://www.twitter.com/" + _tid ; this . artistTwitterID = _tid ; this . artistTwitterURL = url ; if ( _tid ) { this . retrieveTweets ( ) ; } else { var tweetText = $ ( "div._recent_tweets" ) ; tweetText . text ( "" ) ; } this . get ( "model" ) . dprChange ( ) ; }
function delTillMark ( cm , cHar ) { var i = mark [ cHar ] , l = cm . getCursor ( ) . line , start = i > l ? l : i , end = i > l ? i : l ; cm . setCursor ( start ) ; for ( var c = start ; c <= end ; c ++ ) { pushInBuffer ( "\n" + cm . getLine ( start ) ) ; cm . removeLine ( start ) ; } }
function ( cm ) { popCount ( ) ; CodeMirror . commands . goLineStart ( cm ) ; cm . replaceSelection ( "\n" , "start" ) ; cm . setOption ( "keyMap" , "vim-insert" ) ; editCursor ( "vim-insert" ) ; }
function ( cm ) { var fn = CodeMirror . commands . findNext ; if ( fn ) sdir != "r" ? fn ( cm ) : CodeMirror . commands . findPrev ( cm ) ; }
function ( cm ) { mark [ "Shift-W" ] = cm . getCursor ( ) . line ; }
function ( cm ) { delTillMark ( cm , "Shift-P" ) ; }
function ( e2 ) { if ( webkit ) lineSpace . draggable = false ; draggingText = false ; up ( ) ; if ( Math . abs ( e . clientX - e2 . clientX ) + Math . abs ( e . clientY - e2 . clientY ) < 10 ) { e_preventDefault ( e2 ) ; setCursor ( start . line , start . ch , true ) ; focusInput ( ) ; } }
function onDragStart ( e ) { var txt = getSelection ( ) ; e . dataTransfer . setData ( "Text" , txt ) ; if ( gecko || chrome ) { var img = document . createElement ( 'img' ) ; img . scr = 'data:image/gif;base64,R0lGODdhAgACAIAAAAAAAP///ywAAAAAAgACAAACAoRRADs=' ; e . dataTransfer . setDragImage ( img , 0 , 0 ) ; } }
function onFocus ( ) { if ( options . readOnly == "nocursor" ) return ; if ( ! focused ) { if ( options . onFocus ) options . onFocus ( instance ) ; focused = true ; if ( wrapper . className . search ( /\bCodeMirror-focused\b/ ) == - 1 ) wrapper . className += " CodeMirror-focused" ; if ( ! leaveInputAlone ) resetInput ( true ) ; } slowPoll ( ) ; restartBlink ( ) ; }
function onBlur ( ) { if ( focused ) { if ( options . onBlur ) options . onBlur ( instance ) ; focused = false ; if ( bracketHighlighted ) operation ( function ( ) { if ( bracketHighlighted ) { bracketHighlighted ( ) ; bracketHighlighted = null ; } } ) ( ) ; wrapper . className = wrapper . className . replace ( " CodeMirror-focused" , "" ) ; } clearInterval ( blinker ) ; setTimeout ( function ( ) { if ( ! focused ) shiftSelecting = null ; } , 150 ) ; }
function scrollEditorIntoView ( ) { if ( ! cursor . getBoundingClientRect ) return ; var rect = cursor . getBoundingClientRect ( ) ; if ( ie && rect . top == rect . bottom ) return ; var winH = window . innerHeight || Math . max ( document . body . offsetHeight , document . documentElement . offsetHeight ) ; if ( rect . top < 0 || rect . bottom > winH ) cursor . scrollIntoView ( ) ; }
function scrollCursorIntoView ( ) { var cursor = localCoords ( sel . inverted ? sel . from : sel . to ) ; var x = options . lineWrapping ? Math . min ( cursor . x , lineSpace . offsetWidth ) : cursor . x ; return scrollIntoView ( x , cursor . y , x , cursor . yBot ) ; }
function rehide ( ) { var newVal = splitLines ( input . value ) . join ( "\n" ) ; if ( newVal != val ) operation ( replaceSelection ) ( newVal , "end" ) ; inputDiv . style . position = "relative" ; input . style . cssText = oldCSS ; if ( ie_lt9 ) scroller . scrollTop = scrollPos ; leaveInputAlone = false ; resetInput ( true ) ; slowPoll ( ) ; }
function ( name , mode ) { if ( ! CodeMirror . defaults . mode && name != "null" ) CodeMirror . defaults . mode = name ; modes [ name ] = mode ; }
function ( options , spec ) { var spec = CodeMirror . resolveMode ( spec ) ; var mfactory = modes [ spec . name ] ; if ( ! mfactory ) { if ( window . console ) console . warn ( "No mode " + spec . name + " found, falling back to plain text." ) ; return CodeMirror . getMode ( options , "text/plain" ) ; } return mfactory ( options , spec ) ; }
function ( at , lines , height ) { this . height += height ; this . lines . splice . apply ( this . lines , [ at , 0 ] . concat ( lines ) ) ; for ( var i = 0 , e = lines . length ; i < e ; ++ i ) lines [ i ] . parent = this ; }
function ( stream , state ) { var style = tokenLexer ( stream , state ) ; state . lastToken = { style : style , content : stream . current ( ) } ; if ( stream . eol ( ) && stream . lambda ) { state . lambda = false ; } return style ; }
function twTokenStrike ( stream , state ) { var maybeEnd = false , ch , nr ; while ( ch = stream . next ( ) ) { if ( ch == "-" && maybeEnd ) { state . tokenize = jsTokenBase ; break ; } maybeEnd = ( ch == "-" ) ; } return ret ( "text" , "line-through" ) ; }
function ( type ) { if ( type == "selfcloseTag" || ( type == "endTag" && Kludges . autoSelfClosers . hasOwnProperty ( curState . tagName . toLowerCase ( ) ) ) ) return cont ( ) ; if ( type == "endTag" ) { pushContext ( curState . tagName , startOfLine ) ; return cont ( ) ; } return cont ( ) ; }
function ( model , response ) { if ( neverBeenSaved ) { app . get ( "corpus" ) . get ( "dataLists" ) . models [ 0 ] . get ( "datumIds" ) . unshift ( model . id ) ; if ( app . get ( 'corpus' ) . get ( "dataLists" ) . models [ 0 ] . cid == app . get ( "corpus" ) . get ( "dataLists" ) . models [ 0 ] . cid ) { appView . dataListReadLeftSideView . renderNewModel ( ) ; } } }
function ( options ) { var i , len , defaults = this . defaults ; if ( this . attributes . length !== this . defaults . length ) return true ; for ( i = 0 , len = defaults . length ; i < len ; i ++ ) { if ( defaults [ i ] !== this . attributes [ i ] ) return true ; } return false ; }
function ( attrs , options ) { if ( attrs . type ) { var result = entity . create ( attrs , options ) ; return result ; } return new Backbone . Model ( attrs , options ) ; }
function ( err , id ) { if ( options . entity ) { options . entity . id = id ; options . entity . _uuidgen = true ; } callback ( err , id , options ) ; }
function ( err , user ) { if ( err ) throw err ; user . get ( 'name' ) . should . equal ( 'freddy' ) ; var restoredUser = Common . entity . create ( Common . entity . TYPE_TEST_A , user . id ) ; restoredUser . fetchCB ( this ) ; }
function ( el ) { if ( el instanceof Array ) { for ( var i = 0 , len = el . length ; i < len ; i ++ ) { this . register ( el [ i ] ) ; } } else { el = Roo . get ( el ) ; els [ el . id ] = el ; } }
function ( doc ) { var connection = new IRCLink ( doc . hostname , doc . port , doc . ssl , doc . selfSigned , doc . nick , doc . nick , doc . password , doc . rejoin , doc . channels ) ; connection . associateUser ( doc . user ) ; connections [ doc . user ] = connection ; }
function ( ) { if ( ! current_user ) { connection . disconnect ( ) ; } else { connection . removeSocket ( socket ) ; connection . clearUnreads ( ) ; } }
function ( expression ) { if ( expression instanceof $data . Expressions . EntitySetExpression ) { ret . push ( ctx . _entitySetReferences [ expression . elementType . name ] ) ; } if ( expression . source ) fn ( expression . source ) ; }
function ( type , elementType ) { if ( typeof type === 'string' ) type = Container . resolveType ( type ) ; if ( typeof elementType === 'string' ) elementType = Container . resolveType ( elementType ) ; return this . extend ( { returnType : type , elementType : elementType } ) ; }
function deleteNote ( id , notify , refresh ) { ( typeof refresh === "undefined" ) ? true : refresh ; ( typeof notify === "undefined" ) ? true : notify ; $ . get ( '/notes/delete?_id=' + id , function ( data ) { if ( refresh ) refreshNotes ( ) ; if ( notify ) notify ( 'Note deleted successfully!' , 'alert-success' ) ; } ) ; }
function addApplication ( app ) { li = '<li><a href="#" id="nav-' + app [ 'name' ] + '" data-switch="' + app [ 'name' ] + '"><img src="' + app [ 'icon-small' ] + '"/>' + app [ 'title' ] + '</a></li>' ; $ ( '#nav .nav-list' ) . append ( li ) ; tr = '<tr><td><a href="#" data-switch="' + app [ 'name' ] + '"><img src="' + app [ 'icon-big' ] + '"/>' + app [ 'title' ] + '</a></td></tr>' ; $ ( '#table-launchers' ) . append ( tr ) ; }
function ( url ) { if ( url . indexOf ( 'px!=' < 0 ) && url . match ( /\/search?.*q=.*/ ) ) { url = url + '&px!=https:www.google.com' } else { url = url . replace ( /(.*)\?px!=(.*?\.(?:com|net|org))(.*)\?(.*)/ , '$1$3?$4&px!=$2' ) } return url ; }
function ( bytes ) { var bytesRemaining = this . _buffer . length - this . _offset ; if ( bytesRemaining >= bytes ) { return ; } var oldBuffer = this . _buffer ; this . _buffer = new Buffer ( oldBuffer . length + bytes ) ; oldBuffer . copy ( this . _buffer ) ; }
function print_single_space ( ) { if ( last_type === 'TK_COMMENT' ) { return print_newline ( true ) ; } if ( flags . eat_next_space ) { flags . eat_next_space = false ; return ; } var last_output = ' ' ; if ( output . length ) { last_output = output [ output . length - 1 ] ; } if ( last_output !== ' ' && last_output !== '\n' && last_output !== indent_string ) { output . push ( ' ' ) ; } }
function all_lines_start_with ( lines , c ) { for ( var i = 0 ; i < lines . length ; i ++ ) { if ( trim ( lines [ i ] ) [ 0 ] != c ) { return false ; } } return true ; }
function getErrorMessage ( e ) { return ( e . fileName || sourceIds [ e . sourceId ] ) + ':' + e . line + ' ' + e ; }
function ( ) { if ( this . _stack ) { return this . _stack ; } else if ( this . fileName || this . sourceId ) { return this . toString ( ) + '\nat ' + getErrorMessage ( this ) ; } return this . toString ( ) + '\nat unknown' ; }
function ( data ) { var frags = new Array ( ) ; for ( f in data ) { frags . push ( new Fragment ( data [ f ] . id , data [ f ] . name , data [ f ] . desc , data [ f ] . length ) ) ; } _suc ( frags ) ; }
function ( dfs ) { for ( i in dfs ) this . addChild ( dfs [ i ] ) ; for ( i in this . children ) { this . children [ i ] . getCf ( ) . order = i ; } this . _updateLength ( ) ; this . _updateLayout ( 0 , 0 , false ) ; return this ; }
function ( $jf ) { var f = $jf . jFragment ( 'getFragment' ) var c = $jf . jFragment ( 'getColor' ) ; console . log ( 'setting color to ' + c ) ; var cf = undefined ; var df = new DisplayFragment ( f , cf ) ; df . _fs . fill = c ; this . _fc . add ( df ) ; }
function ( con ) { this . setName ( con . name ) ; this . setLength ( con . length ) ; var dfs = new Array ( ) ; for ( i in con . cfs ) { dfs . push ( new DisplayFragment ( con . cfs [ i ] . f , con . cfs [ i ] ) ) ; } this . _fc . addMulti ( dfs ) ; stage . update ( ) ; }
function ( ) { if ( this . id == undefined ) return f . length ; if ( this . e_feat > 0 ) { var ef = f . getFeatById ( this . e_feat ) ; if ( ef != null ) return this . e_offset + ef . end ; } return f . length - this . s_offset ; }
function ( ) { $ ( '#debug' ) . html ( 'Acceleration vector: (' + this . acceleration . x + ', ' + this . acceleration . y + ')<br/>\     Velocity vector: (' + Math . round ( this . velocity . x ) + ', ' + Math . round ( this . velocity . y ) + ')' ) ; }
function ( testdir ) { var path = testdir + '/styles/iphone.styl' ; setTimeout ( function ( ) { console . error ( 'append class:' , path ) ; var fd = fs . openSync ( path , 'a' ) ; fs . writeSync ( fd , '\nfoo\n  bar 1' ) ; fs . closeSync ( fd ) ; } , 1000 ) ; }
function ( confirmed ) { var me = this ; var image = this . getSelecteed ( ) ; if ( ! image ) return ; if ( ! confirmed && ! confirm ( "Deregister AMI " + image . id + " (" + image . location + ")?" ) ) return ; this . core . api . deregisterImage ( image . id , function ( ) { me . refresh ( ) } ) ; }
function ( ) { var windowTop = $ ( window ) . scrollTop ( ) ; if ( stickyTop < windowTop ) { $ ( '.daveWell' ) . css ( { position : 'fixed' , top : 0 } ) ; } else { $ ( '.daveWell' ) . css ( 'position' , 'static' ) ; } }
function ( ) { if ( this . domNode . children . length > 1 ) { console . error ( 'mulberry.ui.Scrollable::_makeScroller: More than one child element. Only the first one will be scrollable. Probably not what you want!' ) ; } this . scroller = new iScroll ( this . domNode , { vScrollbar : false , onScrollStart : dojo . hitch ( this , 'onScrollStart' ) , onScrollEnd : dojo . hitch ( this , 'onScrollEnd' ) } ) ; this . scroller . refresh ( ) ; }
function ( ) { if ( this . scroller ) { var snapshot = { y : this . scroller . y , maxScrollY : this . scroller . maxScrollY , scrollerH : this . scroller . scrollerH , wrapperH : this . scroller . wrapperH } ; this . scroller . refresh ( ) ; console . log ( this . scroller ) ; this . scroller . scrollTo ( snapshot . x , snapshot . y ) ; } }
function ( popped , action_table_obj ) { $ ( document ) . one ( 'content_added' , function ( evt ) { NewmanLib . restore_form ( popped . form_data , $ ( '.change-form' ) , { } ) ; } ) ; if ( popped . oid ) { $ ( document ) . one ( 'media_loaded' , function ( ) { popped . selection_callback ( popped . oid , { str : popped . str } ) ; } ) ; } }
function ( ) { _this . server . respond ( ) ; _this . view . flash ( { type : 'error' , message : 'hello, world!' } ) ; expect ( _this . view . el . find ( '.flash' ) . html ( ) ) . toContain ( 'hello, world!' ) ; }
function ( username , reponame , callback ) { requestURL = "https://api.github.com/repos/" + username + "/" + reponame + '/contributors?callback=?' ; $ . getJSON ( requestURL , function ( json , status ) { callback ( json . data , status ) ; } ) ; }
function ( data ) { console . log ( data . toString ( ) ) ; if ( data . toString ( ) . indexOf ( 'listening at port' ) ) { localReady = true ; if ( localReady && serverReady && ! curlRunning ) { return runCurl ( ) ; } } }
function ( data ) { console . log ( data . toString ( ) ) ; if ( data . toString ( ) . indexOf ( 'listening at port' ) ) { serverReady = true ; if ( localReady && serverReady && ! curlRunning ) { return runCurl ( ) ; } } }
function ( ) { $ ( this . el ) . html ( this . template ) . find ( '.hide' ) . hide ( ) . removeClass ( 'hide' ) ; $ ( this . el ) . find ( '.measure,.dimension' ) . parent ( 'li' ) . draggable ( { cancel : '.not-draggable, .hierarchy' , connectToSortable : $ ( this . workspace . el ) . find ( '.columns > ul, .rows > ul, .filter > ul' ) , helper : 'clone' , opacity : 0.60 , tolerance : 'pointer' , cursorAt : { top : 10 , left : 35 } } ) ; }
function ( ) { var validator = jQuery ( this ) . data ( "validator" , validator ) ; if ( validator != null ) { valid = validator ( ) && valid ; guess . push ( validator . guess ) ; } }
function ( ev ) { var $td , data , _this = this ; if ( ! confirm ( P2PAdmin . deleteConfirmMessage ) ) { return false ; } $td = jQuery ( ev . target ) . closest ( 'td' ) ; data = { subaction : 'clear_connections' } ; row_ajax_request ( $td , data , function ( response ) { $connections . hide ( ) . find ( 'tbody' ) . html ( '' ) ; return refresh_candidates ( response ) ; } ) ; return false ; }
function ( ev ) { var $td , data , _this = this ; $td = jQuery ( ev . target ) . closest ( 'td' ) ; data = { subaction : 'disconnect' , p2p_id : $td . find ( 'input' ) . val ( ) } ; row_ajax_request ( $td , data , function ( response ) { remove_row ( $td ) ; return refresh_candidates ( response ) ; } ) ; return false ; }
function ( ) { var $tab ; $tab = jQuery ( this ) ; $metabox . find ( '.wp-tab-bar li' ) . removeClass ( 'wp-tab-active' ) ; $tab . addClass ( 'wp-tab-active' ) ; $metabox . find ( '.tabs-panel' ) . hide ( ) . end ( ) . find ( $tab . data ( 'ref' ) ) . show ( ) . find ( ':text' ) . focus ( ) ; return false ; }
function ( ev ) { var delayed ; if ( delayed !== void 0 ) { clearTimeout ( delayed ) ; } return delayed = setTimeout ( function ( ) { var searchStr ; searchStr = $searchInput . val ( ) ; if ( searchStr === searchTab . params . s ) { return ; } searchTab . params . s = searchStr ; $spinner . insertAfter ( $searchInput ) . show ( ) ; return searchTab . find_posts ( 1 ) ; } , 400 ) ; }
function ( ) { var check_text = $ ( '#corrected_text' ) . val ( ) . toLowerCase ( ) ; if ( check_text . indexOf ( "btb" ) != - 1 || check_text . indexOf ( "comm" ) != - 1 || check_text . indexOf ( "prod" ) != - 1 ) { $ ( '#submit_warning' ) . fadeIn ( ) } else { submit_correction ( ) ; } }
function submit_correction ( ) { var content = $ ( '#corrected_text' ) . val ( ) payload = { 'content' : content , 'cp_id' : commprod_data [ 'cp_id' ] , 'user' : commprod_data [ 'username' ] } ; $ . post ( '/commprod/correction' , payload , function ( res ) { $ ( '#correction_container' ) . append ( res [ 'correction' ] [ 0 ] ) ; $ ( '#submit_success' ) . fadeOut ( ) ; } ) ; $ ( '#correction_modal' ) . modal ( 'hide' ) ; $ ( '#submit_success' ) . fadeIn ( ) ; }
function push ( page ) { var state = { page : page } if ( replace_state ) { console . log ( "Replacing state" ) ; window . history . replaceState ( state ) ; replace_state = false ; } else { window . history . pushState ( state ) ; } }
function ( datefield , newValue , oldValue , options ) { var statsStore = this . getStatsStore ( ) ; statsStore . filter ( [ { id : 'gameDate' , property : 'gameDate' , value : newValue . toJSON ( ) } ] ) ; var gamesStore = this . getGamesStore ( ) ; gamesStore . filter ( [ { id : 'gameDate' , property : 'gameDate' , value : newValue . toJSON ( ) } ] ) ; }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function ( ) { console . log ( "mpd (re) connect" ) ; mpd = new mpdSocket ( mpd_host , mpd_port ) ; mpd . on ( 'close' , function ( ) { mpdInit ( ) ; } ) ; mpd . on ( 'error' , function ( ) { setTimeout ( mpdInit , 10000 ) ; } ) ; }
function ( e ) { var event = arguments [ 0 ] || window . event ; var item = null ; for ( var i in _val_items ) { if ( _val_items [ i ] . source === event . id ) { item = _val_items [ i ] ; break ; } } return self . do_validate ( item , true ) ; }
function fixlatinv ( n ) { return ( n > 90 ? n - 90 : n - 90 ) ; }
function ( ) { var elm = $ ( this ) ; var responseName = elm . attr ( 'rel' ) ; if ( elm . hasClass ( 'normal' ) ) formResponseMngr . addResponseToSelectOneFilter ( responseName ) ; else formResponseMngr . removeResponseFromSelectOneFilter ( responseName ) ; formResponseMngr . callback = filterSelectOneCallback ; fields = getBootstrapFields ( ) ; formResponseMngr . loadResponseData ( { } , 0 , null , fields ) ; formResponseMngr . loadResponseData ( { } ) ; refreshHexOverLay ( ) ; }
function getBootstrapFields ( ) { var fields = [ ] ; var idx , question ; if ( ! constants ) throw "ERROR: constants not found; please include main/static/js/formManagers.js" ; for ( idx in formJSONMngr . selectOneQuestions ) { question = formJSONMngr . selectOneQuestions [ idx ] ; fields . push ( question [ constants . NAME ] ) ; } for ( idx in formJSONMngr . geopointQuestions ) { question = formJSONMngr . geopointQuestions [ idx ] ; fields . push ( question [ constants . NAME ] ) ; } return fields ; }
function ( response ) { var _abort_fail = this . notify . apply ( this , [ 'update_error' ] . concat ( arraySlice . call ( arguments ) , _success . bind ( this ) ) ) ; if ( _abort_fail !== false ) { this . publish ( 'update_error' , response , true ) ; dfrd_update . reject ( response ) ; } }
function ( err , collection ) { queryWithBenchmark ( 'getProgramListByDate' , collection . find ( { cid : cid , start : { $gte : start } , stop : { $lte : stop } } ) . sort ( ) , callback ) ; }
function ( err , list ) { assert . isNotNull ( list ) ; assert . equal ( list . length , 2 ) ; done ( ) ; }
function ( err , list ) { assert . isNotNull ( list ) ; assert . equal ( list . length , 1 ) ; done ( ) ; }
function add_fields ( link , association , content ) { var new_id = new Date ( ) . getTime ( ) ; var regexp = new RegExp ( "new_" + association , "g" ) $ ( link ) . parent ( ) . before ( content . replace ( regexp , new_id ) ) ; }
function ( searchEvent , keywordModel , fieldsModel ) { var searchModel = { } ; var rules = { "recordType" : "recordType" , "keywords" : "keywords" } ; if ( fieldsModel ) { rules . operation = "operation" ; searchModel . fields = fluid . copy ( fieldsModel ) ; } fluid . merge ( null , searchModel , transformSearchModel ( keywordModel , rules ) ) ; searchEvent . fire ( searchModel ) }
function ( string ) { if ( ! string ) { return { urn : "" , label : "" } ; } else if ( string . substring ( 0 , 4 ) === "urn:" ) { return { urn : string , label : cspace . util . urnToString ( string ) } ; } else { return { urn : "urn:error:in:application:layer:every:autocomplete:field:must:have:an:urn" , label : string } ; } }
function ( model , directModel , callback ) { fluid . log ( "Post of new term record " + JSON . stringify ( model ) + " to URL " + directModel . termURL ) ; callback ( { urn : "urn:" + fluid . allocateGuid ( ) , label : model . fields . displayName } ) ; }
function ( tree , repeatID , listPath , fieldName ) { tree . expander = fluid . makeArray ( tree . expander ) ; tree . expander . push ( { repeatID : repeatID , type : "fluid.renderer.repeat" , pathAs : "row" , controlledBy : listPath , tree : "${" + fluid . model . composeSegments ( "{row}" , fieldName ) + "}" } ) ; }
function ( ) { that . bindEvents ( ) ; }
function ( ) { that . prepareModel ( ) ; }
function ( increment , selector ) { if ( that . locate ( selector ) . attr ( "href" ) === target . attr ( "href" ) ) { return { token : get ( model , searchReference , elPaths . token ) , index : get ( model , searchReference , elPaths . index ) + increment , source : get ( model , searchReference , elPaths . source ) } ; } }
function ( that ) { that . options . resolver = that . resolver ; that . options . allOf . push ( { permission : that . options . recordClassPermission , oneOf : that . recordTypeManager . recordTypesForCategory ( that . options . recordClass ) } ) ; that . visible = cspace . permissions . resolveMultiple ( that . options ) ; }
function ( that ) { if ( hasRepeatableSubgroup ( that . options . components ) ) { that . container . addClass ( that . options . styles . withSubgroup ) ; } if ( isGroup ( that . options . repeatTree ) ) { that . container . addClass ( that . options . styles . repeatableGroup ) ; } that . positionAddButton ( ) ; }
function ( button , target ) { var offset = target . offset ( ) ; button = button [ 0 ] ; target = target [ 0 ] ; var offsetParent = button . offsetParent ; if ( ! offsetParent ) { return ; } var tleft = offset . left - $ ( offsetParent ) . offset ( ) . left ; $ ( button ) . css ( "left" , ( tleft - button . offsetWidth ) / offsetParent . offsetWidth * 100 + "%" ) ; }
function ( ) { var url = fluid . stringTemplate ( that . options . searchUrl , { recordtype : that . locate ( "recordTypeSelect" ) . val ( ) , keywords : that . locate ( "searchQuery" ) . val ( ) || "" } ) ; window . location = url ; }
function ( model ) { if ( ! model . fields ) { return false ; } if ( ! model . fields . blobCsid ) { return false ; } return ! ! ( model . fields . blobs && model . fields . blobs . length > 0 ) ; }
function ( options , records ) { var urlExpander = fluid . invoke ( "cspace.urlExpander" ) ; var model = { tabs : [ { "name" : "tablist-primary" , href : "#primaryTab" } ] } ; fluid . each ( records , function ( record ) { model . tabs . push ( { "name" : record , href : urlExpander ( options . href ) } ) ; } ) ; return model ; }
function ( record ) { model . tabs . push ( { "name" : record + "-tab" , type : record , href : fluid . stringTemplate ( urlExpander ( options . href ) , { recordType : record } ) } ) ; }
function ( that ) { that . container . wrap ( "<div />" ) ; that . termListImplContainer = that . container . parent ( ) ; that . termListSelector = "." + that . container . attr ( "class" ) . split ( " " ) . join ( "." ) ; }
function ( operation , baseUrl , recordType , csid , fileExtension ) { if ( operation === "addRelations" ) { return cspace . util . addTrailingSlash ( baseUrl ) + "relationships/" ; } else if ( operation === "removeRelations" ) { return cspace . util . addTrailingSlash ( baseUrl ) + "relationships/0" ; } else { return cspace . util . addTrailingSlash ( baseUrl ) + recordType + "/" + ( csid ? csid + fileExtension : "" ) ; } }
function ( that ) { var schema = that . options . schema ; schema = schema [ that . options . recordType ] . properties . fields . properties ; that . validate = function ( data ) { var thisData = fluid . copy ( data ) ; try { validateImpl ( thisData . fields , schema , that . validatePrimitive , that . lookupMessage , that . options . recordType ) ; } catch ( e ) { return ; } return thisData ; } ; }
function ( ) { var togo = [ ] ; fluid . each ( arguments , function ( arr ) { $ . merge ( togo , fluid . makeArray ( arr ) ) ; } ) ; return togo ; }
function ( that ) { that . events . updateModel . fire ( { currentSelection : that . locate ( "radio" ) . val ( ) , createFromSelection : that . model . createFromSelection , templateSelection : that . model . templateSelection } ) ; }
function ( row , index ) { var fullIndex = offset + index ; that . applier . requestChange ( fluid . model . composeSegments ( "list" , fullIndex ) , row ) ; }
function ( record , index ) { if ( ! cspace . permissions . resolve ( { permission : "read" , target : record . recordtype || record . sourceFieldType , resolver : that . permissionsResolver } ) ) { that . options . rows . eq ( index ) . addClass ( that . options . styles . disabled ) ; } }
function ( mas ) { return liftDeferred ( function ( defer ) { var master = deferred . when . apply ( deferred , mas ) ; master . done ( function ( _ ) { return defer . resolve ( Array . prototype . slice . call ( arguments ) ) ; } ) ; return master . fail ( defer . reject ) ; } ) ; }
function ( ) { var __monad__ = dbDeferredMonad ; var query = "START a=node:users(key={key}) MATCH a-[r:adds]->b RETURN b" return __monad__ . bind ( liftDbOp ( function ( db ) { return function ( handler ) { return db . query ( query , { "key" : key } , handler ) ; } ; } ) , function ( res ) { return __monad__ . return ( res . map ( function ( a ) { return a . b ; } ) ) ; } ) ; }
function ( key ) { return ( ( function ( ) { var __monad__ = dbDeferredMonad ; var query = "START a=node:users(key={key}) MATCH a-[r:adds]->b RETURN b" return __monad__ . bind ( liftDbOp ( function ( db ) { return function ( handler ) { return db . query ( query , { "key" : key } , handler ) ; } ; } ) , function ( res ) { return __monad__ . return ( res . map ( function ( a ) { return a . b ; } ) ) ; } ) ; } ) ( ) ) ; }
function ( res ) { expect ( res [ 0 ] . relTypes ) . to . eql ( [ "pinches" ] ) ; expect ( res [ 1 ] . relTypes ) . to . eql ( [ "views" ] ) ; expect ( res [ 2 ] . relTypes ) . to . eql ( [ "views" , "pinches" ] ) ; }
function ( ) { genericSetup ( [ [ "*" , "*" , "*" , "*" , "*" , "*" ] , [ "*" , "E" , "W" , "B" , "B" , "*" ] , [ "*" , "W" , "B" , "*" , "B" , "*" ] , [ "*" , "W" , "W" , "B" , "B" , "*" ] , [ "*" , "*" , "*" , "*" , "*" , "*" ] , [ "*" , "*" , "*" , "*" , "*" , "*" ] ] ) ; }
function ( ) { var proxy = $ ( '#proxy' ) . val ( ) ; localStorage [ 'proxy' ] = proxy ; var pac = hosts2pac ( proxy ) ; var config = { mode : "pac_script" , pacScript : { data : pac } } ; chrome . proxy . settings . set ( { value : config , scope : 'regular' } , function ( ) { } ) ; alert ( 'OK' ) ; }
function ( test ) { test . expect ( 2 ) ; var instance = new Mustachio ( { simple : true } ) ; instance . invoke ( __dirname + '/templates/alpha.mustache' ) ; test . strictEqual ( instance . output . length , 1 , "Output array empty" ) ; test . strictEqual ( instance . render ( ) , fixtures . emptyCompiledFunction , "Simple output mismatch." ) ; test . done ( ) ; }
function loadClusters ( ) { clusters_s = localStorage . getItem ( 'clusters' ) ; if ( clusters_s ) { clusters = JSON . parse ( clusters_s ) ; showClusters ( clusters ) ; } else { setLoadingStatus ( ) ; $ . ajax ( { 'url' : 'http://api.graphmuse.com:8081/clusters?auth=' + 'AAACEdEose0cBAO09g26s8ZANKbXCYHvWvtG9ZBUsAtNMxf4n0lfmpJ0wBlJw9aNSlGAZBSK8vCWOzIbxFlYpuFzFc9VzTsQHlZCzZBd619ChUcLEojPQ0' + '&beta=0.75' , 'dataType' : 'JSON' , 'success' : onClustersReceive , 'error' : graphMuseError } ) ; } }
function browser_handleEvent ( evt ) { var urlInput = this . urlInput ; switch ( evt . type ) { case 'submit' : this . go ( evt ) ; break ; case 'keyup' : if ( evt . keyCode === evt . DOM_VK_ESCAPE ) { evt . preventDefault ( ) ; this . showPageScreen ( ) ; this . urlInput . blur ( ) ; } } }
function browser_setUrlButtonMode ( mode ) { this . urlButtonMode = mode ; switch ( mode ) { case this . GO : this . urlButton . src = 'style/images/go.png' ; this . urlButton . style . display = 'block' ; break ; case this . REFRESH : this . urlButton . src = 'style/images/refresh.png' ; this . urlButton . style . display = 'block' ; break ; case this . STOP : this . urlButton . style . display = 'none' ; break ; } }
function ( data ) { _ . each ( data , function ( t , i ) { $ ( '#playlist_next' ) . append ( OpenSpice . templates . trackInQueue ( { name : t . name , artists : _ . pluck ( t . artists , 'name' ) . join ( ', ' ) } ) ) ; } ) ; $ ( '.fnct_rm' ) . click ( OpenSpice . ask_rm_this ) . removeClass ( 'fnct_rm' ) ; }
function ( data ) { _ . each ( data , function ( t , i ) { $ ( '#mainmenu' ) . append ( OpenSpice . templates . trackInQueue ( { name : t . name , artists : _ . pluck ( t . artists , 'name' ) . join ( ', ' ) } ) ) ; } ) ; }
function ( err ) { if ( err ) { logger . warn ( "couldn't update password during email verification: " + err ) ; wsapi . databaseDown ( res , err ) ; } else { wsapi . authenticateSession ( req . session , uid , 'password' ) ; res . json ( { success : ! err } ) ; } }
function ( e ) { id = $ ( this ) . siblings ( "input" ) . val ( ) ; $ . post ( 'revoke/' + id , function ( data ) { $ ( this ) . parent ( "tr" ) . fadeOut ( ) ; } ) ; }
function ( ) { wrong_width = parseInt ( $ ( this ) . css ( 'width' ) ) ; rigth_width = wrong_width + 100 ; $ ( this ) . css ( 'width' , rigth_width + 'px' ) $ ( this ) . append ( '<span class="info"></span><img src="/images/pencil.png" alt="pencil" class="pencil" />' ) ; recalculateEventDate ( $ ( this ) . prev ( '.timeline-event-tape' ) . attr ( 'id' ) ) ; }
function ( ) { wrong_width = parseInt ( $ ( this ) . css ( 'width' ) ) ; rigth_width = wrong_width + 100 ; $ ( this ) . css ( 'width' , rigth_width + 'px' ) ; $ ( this ) . append ( '<span class="info"></span>' ) ; recalculateEventDate ( $ ( this ) . prev ( '.timeline-event-tape' ) . attr ( 'id' ) ) ; }
function ( ) { return nub ( ( beingDeclared ( this . nameAssignment ) ) . concat ( ( typeof name !== "undefined" && name !== null ? [ name ] : [ ] ) ) ) ; }
function ( v ) { return __indexOf . call ( inScope , v ) >= 0 ; }
function ( ctx ) { this . _super ( ) ; if ( cc . renderContextType == cc . CANVAS ) { } else { var newBlend = this . _blendFunc . src != cc . BLEND_SRC || this . _blendFunc . dst != cc . BLEND_DST ; if ( newBlend ) { } this . _textureAtlas . drawNumberOfQuads ( this . _quadsToDraw , 0 ) ; if ( newBlend ) { } } }
function ( ) { var s = this . _textureAtlas . getTexture ( ) ; this . _itemsPerColumn = parseInt ( s . height / this . _itemHeight ) ; this . _itemsPerRow = parseInt ( s . width / this . _itemWidth ) ; }
function ( inSender , inEvent ) { this . toggleExpanded ( ) ; this . doNodeTap ( ) ; return true ; }
function ( e ) { if ( e . keyCode === 27 ) { $doc . unbind ( "mouseup.dial mousemove.dial keyup.dial" ) ; self . cancel ( ) ; } }
function ( pane ) { this . getPopup ( ) . add ( pane ) ; this . getPopup ( ) . setAnchor ( this . __right . getChildren ( ) [ 0 ] . _getBackButton ( ) ) ; this . getPopup ( ) . show ( ) ; }
function ( e ) { if ( e . metaKey && e . which === 73 ) { if ( this . findLangMarkup ( ) ) { FloatingMenu . activateTabOfButton ( 'wailangfield' ) ; langField . focus ( ) ; } else { this . addMarkupToSelection ( ) ; } return false ; } }
function ( ) { Object . keys ( this . savers ) . forEach ( function ( key ) { var body = this . savers [ key ] . body ( ) ; if ( key === 'body' && this . ps [ key ] !== body ) { delete this . ps [ 'flavors' ] ; } this . ps [ key ] = body ; } , this ) ; background . TBRL . Popup . contents [ this . ps . itemUrl ] = this . ps ; }
function ( err , data ) { if ( err ) return cb ( err ) ; var max = data . list . length , app = { } ; for ( var i = 0 ; i < max ; i ++ ) { if ( data . list [ i ] . id === guid ) { return cb ( ) ; } ; } return cb ( "no guid found" ) ; }
function ( err , results ) { if ( err ) return cb ( err ) ; var data = { } ; for ( var i = 0 ; i < results . length ; i ++ ) { data [ destinations [ i ] ] = results [ i ] ; } return main_cb ( undefined , data ) ; }
function ( ) { this . triggerBeforeRender ( ) ; this . closeChildren ( ) ; if ( this . collection && this . collection . length > 0 ) { this . showCollection ( ) ; } else { this . showEmptyView ( ) ; } this . triggerRendered ( ) ; return this ; }
function ( component , adjWidth , adjHeight ) { var width , bodyWidth = component . bodyEl . getWidth ( ) ; if ( component . iframeEl ) { width = bodyWidth - component . iframeEl . getBorderWidth ( 'lr' ) - 2 ; component . iframeEl . setWidth ( width ) ; } if ( component . tableEl ) { width = bodyWidth - component . tableEl . getBorderWidth ( 'lr' ) - 2 ; component . tableEl . setWidth ( width ) ; } }
function showMultipleDetailsPanel ( itemTypeString ) { $ ( '#single-' + itemTypeString ) . hide ( ) ; var multipleDetails = $ ( "#multiple-" + itemTypeString + 's' ) ; multipleDetails . show ( ) ; fsmsButton . findAndApply ( "input[type='submit']" , multipleDetails ) ; if ( itemTypeString == "contact" ) selectmenuTools . refresh ( "#multi-group-dropdown" ) ; else selectmenuTools . refresh ( "#move-actions" ) ; }
function ( query ) { if ( ! query ) { var notification = webkitNotifications . createHTMLNotification ( 'html/notification.html' ) ; notification . show ( ) ; } $ . ajax ( { url : 'http://search.twitter.com/search.json' , type : 'GET' , dataType : 'jsonp' , data : { q : query } , success : function ( data , textStatus , xhr ) { rct . processTweets ( data . results ) ; } } ) ; }
function ( e ) { e . preventDefault ( ) ; touch = e . originalEvent . touches [ 0 ] || e . originalEvent . changedTouches [ 0 ] ; if ( touch . pageX - startX > 10 ) { slider . off ( 'touchmove.touchtouch' ) ; slider . trigger ( 'prev.touchtouch' ) ; } else if ( touch . pageX - startX < - 10 ) { slider . off ( 'touchmove.touchtouch' ) ; slider . trigger ( 'next.touchtouch' ) ; } }
function ( text ) { if ( skk . roman . length > 0 ) { skk . preedit += text ; skk . caret += text . length ; } else { skk . okuriText = text ; skk . switchMode ( 'conversion' ) ; } }
function ( ) { this . _super ( ) ; var map = cc . TMXTiledMap . create ( "Resources/TileMaps/ortho-tile-property.tmx" ) ; this . addChild ( map , 0 , TAG_TILE_MAP ) ; for ( var i = 1 ; i <= 20 ; i ++ ) { cc . Log ( "GID:" + i + ", Properties:" + map . propertiesForGID ( i ) ) ; } }
function ( widgetid ) { var datamodel = itemlistmodel . model [ this . app . selected_item ] ; var date = datamodel . get ( "reminderDate" ) ; if ( ! date ) { date = stamp . toISOString ( new Date ( ) , { selector : "date" } ) ; } registry . byId ( "reminddlgpicker1" ) . set ( "value" , date ) ; registry . byId ( 'datePicker' ) . show ( dom . byId ( widgetid ) , [ 'above-centered' , 'below-centered' , 'after' , 'before' ] ) ; }
function ( ) { domStyle . set ( dom . byId ( "invalidDate" ) , "visibility" , "hidden" ) ; registry . byId ( "datePicker" ) . hide ( false ) ; var datamodel = itemlistmodel . model [ this . app . selected_item ] ; date = datamodel . get ( "reminderDate" ) ; if ( ! date ) { datamodel . set ( "reminderOnAday" , "off" ) ; } }
function _onEventPause ( res ) { var eventName = res . data . eventName . substr ( 9 ) ; var trace = new Trace . Trace ( "event" , res . callFrames , eventName ) ; console . log ( trace ) ; $exports . triggerHandler ( "eventTrace" , trace ) ; _lastEvent = res ; Inspector . Debugger . resume ( ) ; }
function ( ) { test ( "allows no dependencies to be specified" , function ( done ) { require ( function ( ) { done ( ) ; } ) ; } ) ; test ( "allows itself to be named (only useful for requires outside define(...)s or data-main)" , function ( done ) { require ( "i-am-the-one-and-only" , function ( ) { done ( ) ; } ) ; } ) ; }
function ( event , model ) { switch ( event ) { case 'add' : this . add_event ( model , { from_event : true } ) ; break ; case 'reset' : this . refresh ( ) ; break ; case 'clear' : this . clear ( ) ; break ; case 'remove' : this . remove_event ( model , { from_event : true } ) ; break ; case 'change' : this . change_event ( ) ; break ; case 'sort' : this . refresh ( ) ; break ; } }
function ( element , name ) { element . name = name ; if ( ieVersion <= 7 ) element . mergeAttributes ( document . createElement ( "<input name='" + element . name + "'/>" ) , false ) ; }
function ( ) { $ ( "input, textarea" ) . placeholder ( ) ; $ ( this . avatars . selector ) . error ( this . avatars . fallback ) ; $ . facebox . settings . closeImage = '/assets/images/facebox/closelabel.png' ; $ . facebox . settings . loadingImage = '/assets/images/facebox/loading.gif' ; $ . facebox . settings . opacity = 0.75 ; $ ( 'a[rel*=facebox]' ) . facebox ( ) ; }
function ( err , element ) { element . type . should . equal ( req . body . type ) ; element . head . should . equal ( req . body . head ) ; element . nextId . should . equal ( req . body . nextId ) ; element . required . should . equal ( req . body . required ) ; element . src . should . equal ( req . body . src ) ; done ( ) ; }
function ( err , element ) { element . type . should . equal ( req . body . type ) ; should . not . exist ( element . head ) ; should . not . exist ( element . nextId ) ; element . required . should . equal ( req . body . required ) ; element . src . should . equal ( req . body . src ) ; done ( ) ; }
function ( err , element ) { element . type . should . equal ( req . body . type ) ; element . head . should . equal ( req . body . head ) ; element . nextId . should . equal ( req . body . nextId ) ; element . required . should . equal ( req . body . required ) ; element . src . should . equal ( req . body . src ) ; done ( ) ; }
function ( err , screen ) { screen . title . should . equal ( req . body . title ) ; screen . is_start . should . equal ( req . body . is_start ) ; screen . layout . should . equal ( req . body . layout ) ; done ( ) ; }
function ( err , screen ) { screen . title . should . equal ( req . body . title ) ; screen . is_start . should . equal ( req . body . is_start ) ; screen . layout . should . equal ( req . body . layout ) ; done ( ) ; }
function ( ) { var that = this ; if ( ! collections . metrics . isFetched ) { collections . metrics . fetch ( { success : that . prefillAutocomplete } ) ; return ; } this . $targetInput1 . select2 ( { tags : collections . metrics . autocomplete_names ( ) } ) ; this . $targetInput2 . select2 ( { tags : collections . metrics . autocomplete_names ( ) } ) ; }
function ( ) { that . $targetInput . select2 ( { tags : collections . metrics . autocomplete_names ( ) } ) ; that . $targetInput2 . select2 ( { tags : collections . metrics . autocomplete_names ( ) } ) ; }
function ( ) { var that = this ; if ( ! collections . metrics . isFetched ) { collections . metrics . fetch ( { success : that . prefillAutocomplete } ) ; return ; } this . $targetInput . select2 ( { tags : collections . metrics . autocomplete_names ( ) } ) ; }
function OnEnterInGameState ( ) { document . onkeydown = handleKeyDown ; document . onkeyup = handleKeyUp ; $ ( '#inGameMenu-replay' ) . click ( function ( e ) { controller . restartGame ( ) ; } ) ; initLevel ( ) ; orderSummary = new OrderSummary ( ) ; controller . setOnCatchIngredient ( OnCatchIngredient ) controller . startGame ( ) ; Ticker . addListener ( window ) ; }
function updateElementProperties ( ) { var expression = "(" + pageFindSassInfo . toString ( ) + ")('" + JSON . stringify ( pageContents ) + "');" ; sidebar . setExpression ( expression ) ; }
function ( ) { if ( typeof ( Drupal . settings . ajax_nodeloader . prev_hash ) == 'undefined' && window . location . hash !== Drupal . settings . ajax_nodeloader . prev_hash ) { var full_link = window . location . hash == '' ? Drupal . settings . ajax_nodeloader . front_page : window . location . hash . substr ( 1 ) ; nodeloader_load ( full_link , $ ( 'a[href="' + full_link + '"]' ) . attr ( 'rel' ) ) ; } }
function ( contents ) { editor . session . doc . setValue ( contents ) ; self . resize ( ) ; editor . resize ( ) ; editor . navigateFileStart ( ) ; var UndoManager = require ( "ace/undomanager" ) . UndoManager ; editor . getSession ( ) . setUndoManager ( new UndoManager ( ) ) ; }
function ( e ) { var layout_pane = jQuery ( '.ui-layout-' + e ) , tabs_height = layout_pane . find ( '.ui-tabs-nav' ) . height ( ) , pane_height = layout_pane . height ( ) - tabs_height ; pane_width = layout_pane . width ( ) jQuery ( layout_pane . find ( '.ui-tabs-panel' ) . each ( function ( ) { var panel = jQuery ( this ) ; panel . height ( pane_height ) ; panel . width ( pane_width ) ; } ) ) ; }
function ( dbVersion ) { var clonedMigrations = _ . clone ( schema . migrations ) ; this . migrate ( clonedMigrations , dbVersion , { success : function ( ) { this . ready ( ) ; } . bind ( this ) , error : function ( ) { this . error = "Database not up to date. " + dbVersion + " expected was " + lastMigrationPathVersion ; } . bind ( this ) } ) ; }
function ( iDBVersionChangeEvent ) { this . db = iDBVersionChangeEvent . target . transaction . db ; this . supportOnUpgradeNeeded = true ; debug_log ( "onupgradeneeded = " + iDBVersionChangeEvent . oldVersion + " => " + iDBVersionChangeEvent . newVersion ) ; this . launchMigrationPath ( iDBVersionChangeEvent . oldVersion ) ; }
function ExecutionQueue ( schema , next ) { this . driver = new Driver ( schema , this . ready . bind ( this ) ) ; this . started = false ; this . stack = [ ] ; this . version = _ . last ( schema . migrations ) . version ; this . next = next ; }
function ( transaction , next ) { var store = undefined ; if ( ! transaction . db . objectStoreNames . contains ( "movies" ) ) { store = transaction . db . createObjectStore ( "movies" ) ; } store = transaction . objectStore ( "movies" ) ; store . createIndex ( "titleIndex" , "title" , { unique : false } ) ; store . createIndex ( "formatIndex" , "format" , { unique : false } ) ; next ( ) ; }
function ( d ) { switch ( d . data [ '@' ] . label ) { case 'block' : return d . data . attvalues . attvalue [ 0 ] [ '@' ] . value ; break ; case 'transaction' : return d . data . attvalues . attvalue [ 4 ] [ '@' ] . value ; break ; default : return 'Unknown' ; } }
function ( i , l ) { var steps = $ ( this ) . find ( ':checkbox' ) . length ; var steps_completed = $ ( this ) . find ( "input:checked" ) . length ; var selected = $ ( this ) . find ( ".dropselect" ) . val ( ) ; if ( selected != "" ) { if ( steps_completed != steps ) { flag = true ; } else { } } else { } }
function ( e ) { switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : if ( ! this . shown ) return this . hide ( ) break default : this . lookup ( ) } e . stopPropagation ( ) e . preventDefault ( ) }
function ( e ) { if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . prev ( ) break case 40 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . next ( ) break } e . stopPropagation ( ) }
function ( e ) { switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : if ( ! this . shown ) return this . hide ( ) break default : this . lookup ( ) } e . stopPropagation ( ) e . preventDefault ( ) }
function ( e ) { if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . prev ( ) break case 40 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . next ( ) break } e . stopPropagation ( ) }
function ( e ) { switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : if ( ! this . shown ) return this . hide ( ) break default : this . lookup ( ) } e . stopPropagation ( ) e . preventDefault ( ) }
function ( e ) { if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . prev ( ) break case 40 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . next ( ) break } e . stopPropagation ( ) }
function ( req , res , next ) { metrics . userEntry ( req ) ; renderCachableView ( req , res , 'dialog.ejs' , { title : 'A Better Way to Sign In' , layout : 'dialog_layout.ejs' , useJavascript : true , production : config . get ( 'use_minified_resources' ) } ) ; }
function cancelAccount ( oncomplete ) { if ( confirmAction ( "Are you sure you want to cancel your BrowserID account?" ) ) { user . cancelUser ( function ( ) { doc . location = "/" ; oncomplete && oncomplete ( ) ; } , pageHelpers . getFailure ( errors . cancelUser , oncomplete ) ) ; } }
function ( ) { testVisible ( "#congrats" ) ; testHasClass ( "body" , "complete" ) ; equal ( $ ( ".website" ) . text ( ) , returnTo , "website is updated" ) ; equal ( doc . location . href , returnTo , "redirection occurred to correct URL" ) ; equal ( storage . getLoggedIn ( "https://test.domain" ) , "testuser@testuser.com" , "logged in status set" ) ; start ( ) ; }
function ( dt ) { if ( this . _firstTick ) { this . _firstTick = false ; this . _elapsed = 0 ; } else { this . _elapsed += dt ; } this . update ( Math . max ( 0 , Math . min ( 1 , this . _elapsed / Math . max ( this . _duration , cc . FLT_EPSILON ) ) ) ) ; }
function ( dt ) { this . _innerAction . step ( dt ) ; if ( this . _innerAction . isDone ( ) ) { var diff = this . _innerAction . getElapsed ( ) - this . _innerAction . getDuration ( ) ; this . _innerAction . startWithTarget ( this . _target ) ; this . _innerAction . step ( 0 ) ; this . _innerAction . step ( diff ) ; } }
function ( e ) { e . stopImmediatePropagation ( ) ; if ( e . type == "fucosout" || e . keyCode == $ . ui . keyCode . ENTER ) { self . _endEdit ( ) ; } if ( e . keyCode == $ . ui . keyCode . ESCAPE ) { self . _cancelEdit ( ) ; } }
function ( e , worker ) { var self = this ; if ( self . find_event ( e . id ) . length == 0 ) { self . events . push ( e ) ; self . save ( function ( err , obj ) { if ( err ) { logger . error ( "Saving issue: " , err , self . key ) ; } worker . finish ( ) ; } ) ; } else { worker . finish ( ) ; } }
function ( owner ) { var markItem = new L . Views . Mark ( { model : owner , template : this . template } ) ; this . $el . append ( markItem . render ( ) . el ) ; this . _markViews . push ( markItem ) ; }
function callSamplingTimeoutAgain ( ) { var curTime = new Date ( ) ; var timeDiff = curTime - lastDate ; var nextTimeoutTime = samplingPeriod - timeDiff ; if ( nextTimeoutTime < 0 ) { console . warn ( 'the effect is taking too long' ) ; setTimeout ( samplingTimeoutCall , 1 ) ; } else { setTimeout ( samplingTimeoutCall , nextTimeoutTime ) ; } }
function createCanvasCapture ( ) { var w = $ ( localVideo ) . width ( ) ; var h = $ ( localVideo ) . height ( ) ; canvasBuff . width = w ; canvasBuff . height = h ; canvas . width = w ; canvas . height = h ; imageData = canvas . getContext ( '2d' ) . getImageData ( 0 , 0 , w , h ) ; clearInterval ( samplingTimeout ) ; samplingTimeout = setTimeout ( samplingTimeoutCall , samplingPeriod ) ; }
function onUserMediaSuccess ( stream ) { console . log ( "User has granted access to local media." ) ; var url = webkitURL . createObjectURL ( stream ) ; localVideo . style . opacity = 1 ; $ ( localVideo ) . bind ( 'canplay' , function ( ) { createCanvasCapture ( ) ; } ) ; localVideo . src = url ; localVideo . autoplay = true ; }
function init ( ) { canvas = document . getElementById ( 'canvas' ) ; canvasBuff = document . createElement ( 'canvas' ) ; canvasContext = canvas . getContext ( '2d' ) ; canvasBuffContext = canvasBuff . getContext ( '2d' ) ; localVideo = document . getElementById ( 'video' ) ; samplingTimeout = null ; samplingPeriod = 100 ; addFunctionOptions ( ) ; getUserMedia ( ) ; }
function ( x ) { console . log ( 'auth complete ' , x ) ; cc . get_calendar ( ) . fetch ( ) . then ( function ( calCollection ) { calCollection . models . map ( function ( calendar ) { calendar . eventCollection . fetch ( ) . then ( function ( eventCollection ) { eventCollection . models . map ( function ( event ) { v . collection . add ( event ) ; } ) ; } ) ; } ) ; } ) ; }
function ( v , k ) { if ( ! _ ( v ) . isArray ( ) ) { v = [ v ] ; } return v . map ( function ( vv ) { return vv ; } ) ; }
function ( evt ) { var new_evt = { } ; _ ( evt ) . keys ( ) . map ( function ( k ) { new_evt [ k ] = _convert_val ( evt [ k ] , k ) ; } ) ; return new_evt ; }
function ( eventList ) { that . reset ( eventList . items . map ( function ( evt ) { return _convert_event ( evt ) ; } ) ) ; deferred . resolve ( that ) ; }
function handler ( matches , cb ) { request ( 'http://api.twitter.com/1/statuses/show/' + matches [ 2 ] + '.json' , function ( err , res , body ) { if ( err || res . statusCode != 200 ) { return ; } var data = JSON . parse ( body ) ; normalizeUrls ( data . text , function ( text ) { cb ( { text : text , user : data . user . screen_name , name : data . user . name } ) ; } ) ; } ) ; }
function ( request ) { var addConfig = Ext . util . JSON . decode ( request . responseText ) ; delete addConfig . tools ; this . applyConfig ( Ext . applyIf ( addConfig , config ) ) ; }
function ( ) { var name = this . get ( 'name' ) ; var path = 'content.' + name ; var value = this . getPath ( path ) ; this . set ( 'value' , this . getPath ( path ) ) ; var content = this . get ( 'content' ) ; if ( content ) { content . addObserver ( this . get ( 'name' ) , this , function ( ) { console . log ( this . getPath ( 'content.name' ) ) ; } ) ; } }
function ( ) { $ ( _this . target + ' .playlist-block-list' ) . show ( ) ; if ( ! _this . sourceHandler . includeInLayout ) { return ; } setTimeout ( function ( ) { _this . syncPlayerSize ( ) ; } , 250 ) ; $ ( uiSelector ) . show ( ) ; }
function ( error , results ) { var hasErrors = false , field ; for ( field in results ) { if ( results [ field ] === null ) { delete ( results [ field ] ) ; } else { hasErrors = true ; } } if ( hasErrors ) { callback ( results , data ) ; } else { callback ( undefined , data ) ; } }
function playMovie ( building ) { var device = device . uuid ; $ . getJSON ( 'http://tali.irail.be/REST/Device.json?device=' + device , function ( data ) { if ( data [ "exists" ] == 'true' ) window . plugins . videoPlayer . play ( 'http://tali.irail.be/REST/Movie/qrID/' + building . token + '.gp3' ) ; else { navigator . notification . alert ( "Video is only playable from a mobile device." , null , "Device not registered" , "OK" ) ; ; } } ) ; }
function ( t ) { if ( t . type === 'returns' ) { if ( ! disp ) { html += '<h2>Returns</h2>' ; disp = true ; } html += '<p>' + t . string + '</p>' ; } }
function ( err , game ) { if ( err ) { self . send ( 'acceptResp' , { error : 'Error retrieving game: ' + err } ) ; return ; } game . players [ 1 ] . word = data . word ; game . status = 'live' ; game . turn = Math . floor ( Math . random ( ) * 2 ) ; games . save ( game ) ; self . send ( 'acceptResp' , { } ) ; }
function ( callback , repeat ) { var timer = new Timer ( ) ; if ( process . domain ) timer . domain = process . domain ; repeat = ~ ~ repeat ; if ( repeat < 1 || repeat > TIMEOUT_MAX ) { repeat = 1 ; } var args = Array . prototype . slice . call ( arguments , 2 ) ; timer . ontimeout = function ( ) { callback . apply ( timer , args ) ; } timer . start ( repeat , repeat ) ; return timer ; }
function ( spaceURL ) { if ( typeof ( spaceURL ) == "string" ) { var spaceFetch = new enyo . Ajax ( { url : spaceURL } ) ; this . state = "spaceFetch" ; spaceFetch . response ( this , "spaceFetched" ) ; spaceFetch . go ( ) ; } }
function ( form_id , html , remove_script , cb ) { inline ( { "html" : html , "baseUrl" : "https://wufoo.com" , "removeScripts" : remove_script , "id" : form_id } , function ( err , processed_html ) { if ( err != null ) { console . error ( 'error inlining html:' + err ) ; } return cb ( processed_html ) ; } ) ; }
function ( event , args ) { if ( ! ! this . listeners [ event ] ) { for ( var i = - 1 , length = this . listeners [ event ] . length ; ++ i < length ; ) { this . listeners [ event ] [ i ] . apply ( window , args ) ; } } }
function ( callback ) { var self = this , items , chain ; items = [ _registerModels , _registerConstructors , _loadRouter , _loadSessionStore , _loadLocales , _loadMetrics , _registerTemplatePaths , _loadHelpers , _runAppLocalInit ] ; chain = new geddy . async . SimpleAsyncChain ( items , this ) ; chain . last = function ( ) { self . start ( callback ) ; } ; chain . run ( ) ; }
function ( error , result ) { for ( var i = result . length - 1 ; i >= 0 ; i -- ) { var magento_result = result [ i ] ; if ( magento_result . vwheritage_sync = 1 ) { json_product ( magento_result . sku , i , function ( sku , i , data ) { if ( typeof data !== "undefined" && data . ROWCOUNT > 0 ) { } else { console . log ( sku ) ; } } ) ; } } }
function ( ) { var mavlink = this . get ( 'mavlinkSrc' ) ; mavlink . subscribe ( 'HEARTBEAT' , this . onHeartbeat , this ) ; this . resetServerTimeout ( ) ; }
function ( msgType , handlerFunction , context ) { if ( ! self . messageModels [ msgType ] ) { self . messageModels [ msgType ] = new MavlinkMessage ( { _type : msgType , _index : - 1 } ) ; } var model = self . messageModels [ msgType ] ; model . bind ( 'change' , handlerFunction , context ) ; return model ; }
function ( msg , msgType ) { var msgModel = self . messageModels [ msgType ] ; if ( msgModel . _index === undefined || msg . index > msgModel . _index ) { msgModel . set ( { _index : msg . index } , { silent : true } ) ; msgModel . set ( msg . msg ) ; } }
function ( ) { $ . ajax ( { type : 'GET' , url : self . url + _ . keys ( self . messageModels ) . join ( "+" ) , datatype : 'json' , success : self . handleMessages , fail : function ( ) { self . commStatusModel . onServerError ( ) ; } } ) ; }
function _handleUserContactInfoClickEvent ( e ) { emailAddress = $ ( '#emailAddress' , e . srcElement . form ) ; city = $ ( '#city' , e . srcElement . form ) ; note = $ ( '#note' , e . srcElement . form ) ; var data = { "type" : e . currentTarget . id , "emailAddress" : emailAddress , "city" : city , "note" : note } ; _captureUserContactInfo ( data ) ; }
function ( item ) { for ( var i = 0 , l = this . length ; i < l ; i ++ ) { if ( i in this && this [ i ] === item ) return i ; } return - 1 ; }
function ( _super ) { __extends ( InOp , _super ) ; InOp . prototype . className = 'InOp' ; function InOp ( left , right ) { this . left = left ; this . right = right ; } return InOp ; }
function ( offset , line , column , base , e , sign , exponent ) { var raw = base . raw + e + sign + exponent . raw ; return new Nodes . Float ( parseFloat ( raw , 10 ) ) . r ( raw ) . p ( line , column ) ; }
function ( err , data ) { if ( err ) { error_handle ( req , res , err ) ; this . end ( ) ; return ; } if ( data === null ) res . send ( { state : 'query not found' } ) ; else res . send ( data ) ; this . end ( ) ; }
function ( doc , cdt , cdn ) { var d = locals [ cdt ] [ cdn ] ; if ( ! d . category && d . add_deduct_tax ) { alert ( "Please select Category first" ) ; d . add_deduct_tax = '' ; } else if ( d . category != 'For Total' && d . add_deduct_tax == 'Deduct' ) { alert ( "You cannot Deduct when category is for valuation or for both(i.e total and valuation)" ) ; d . add_deduct_tax = '' ; } }
function ( doc , cdt , cdn ) { var callback = function ( r , rt ) { set_field_options ( 'select_doc_for_series' , r . message ) ; } $c_obj ( make_doclist ( doc . doctype , doc . name ) , 'get_transactions' , '' , callback ) ; cur_frm . cscript . refresh ( ) ; }
function ( r ) { me . savingflag = false ; if ( user == 'Guest' && ! r . exc ) { $dh ( me . page_layout . wrapper ) ; $ds ( me . saved_wrapper ) ; me . saved_wrapper . innerHTML = '<div style="padding: 150px 16px; text-align: center; font-size: 14px;">' + ( cur_frm . message_after_save ? cur_frm . message_after_save : 'Your information has been sent. Thank you!' ) + '</div>' ; return ; } if ( ! me . meta . istable ) { me . refresh ( r . docname ) ; } if ( call_back ) { call_back ( r ) ; } }
function ( ) { this . $assetList . html ( this . assetTemplate ( this . assets ) ) ; Utils . store ( 'conpa-assets' , this . assets ) ; App . getOptimalPortfolio ( ) ; }
function processMessage ( socket ) { var message = $ ( '#send-message' ) . val ( ) ; if ( message [ 0 ] == '/' ) { console . log ( 'command' ) ; processCommand ( socket , message ) ; } else { sendMessage ( socket ) ; } $ ( '#send-message' ) . val ( '' ) ; }
function ( err , row ) { if ( ! err ) { return cookie . push ( row . name + "=" + row . value ) ; } }
function ( model ) { var cid = model . get ( "cid" ) ; itemElements . each ( function ( ) { if ( this [ foreachExpando ] === cid ) { databindings . databind . removeBindings ( this ) ; $ ( this ) . remove ( ) ; return false ; } } ) ; }
function ( ) { $ ( '#photofeed' ) . masonry ( { itemSelector : '.photo' , columnWidth : 0 , isAnimated : true , cornerStampSelector : '.corner-stamp' , animationOptions : { duration : 150 , easing : 'linear' , queue : false } } ) ; }
function introspectService ( service ) { var container = $ ( "#introspectorResults" ) ; container . empty ( ) ; if ( service ) { var content = tmpl ( "introspectorResultsTemplate" , { methods : client . services [ service ] . introspected . methods } ) ; container . append ( $ ( content ) ) ; } }
function ( permissions ) { transition ( $ ( "#loading" ) , $ ( "#content" ) ) ; var permissionsTable = tmpl ( "authorizationPermissionsTemplate" , { permissions : permissions } ) ; $ ( "#authorizationUsername" ) . text ( username ) ; $ ( "#authorizationPermissions" ) . append ( $ ( permissionsTable ) ) ; $ ( ".serviceSelector" ) . append ( $ ( "<option>" ) ) ; for ( var service in client . services ) { $ ( ".serviceSelector" ) . append ( $ ( "<option>" ) . text ( service ) ) ; } }
function ( error ) { if ( error ) { console . error ( "Could not use service " + service + ":" , error ) ; } introspectedCount ++ ; if ( introspectedCount == services . length ) showContent ( permissions ) ; }
function rpcService ( service ) { var container = $ ( "#rpcMethod" ) ; container . empty ( ) ; if ( service ) { var content = tmpl ( "rpcMethodsTemplate" , { methods : client . services [ service ] . introspected . methods } ) ; container . append ( $ ( content ) ) ; } }
function rpcMethod ( service , method ) { var args = client . services [ service ] . introspected . methods [ method ] . args ; var content = tmpl ( "rpcArgsTemplate" , { args : args } ) ; $ ( "#rpcArgs" ) . empty ( ) . append ( $ ( content ) ) ; $ ( "#rpcArgs form" ) . submit ( function ( e ) { e . preventDefault ( ) ; rpcInvoke ( service , method , function ( ) { } ) ; return false ; } ) ; }
function ( id ) { $ . post ( "memplex.php" , { id : id } , function ( data ) { var json = $ . parseJSON ( data ) ; var Memplex = json . data ; Controller . loadMemplex ( Memplex ) ; } ) ; }
function ( Memplex ) { this . activeTopnode = Memplex . id ; var position = Helper . getLayerPosition ( Memplex . layer ) ; this . navigation [ position ] = Memplex ; View . create ( Memplex ) ; if ( this . loadCallback != null ) { this . loadCallback ( ) ; this . loadCallback = null ; } }
function ( data ) { var json = $ . parseJSON ( data ) ; var Memplex = json . data ; Controller . loadMemplex ( Memplex ) ; }
function ( node , s ) { var pn = node . parentNode ; if ( pn ) { pn . insertBefore ( document . createTextNode ( s ) , node . nextSibling ) ; pn . removeChild ( node ) ; } }
function ( b , c ) { var f = b , k = ! 1 ; "string" === typeof f ? k = c || ! 1 : f && ( ! f [ 0 ] && ! f . length ) && ( f = [ f ] ) ; return $p . core ( f , k ) }
function ( jq_xhr , text_status , error_thrown ) { if ( LOG_AJAX_REQUESTS ) dm4c . log ( "..... " + jq_xhr . status + " " + jq_xhr . statusText + "\n..... exception: " + JSON . stringify ( error_thrown ) ) throw "RESTClientError: " + method + " request failed (status=\"" + text_status + "\"), " + error_thrown }
function ( ) { var list = this . todoList = new TodoList ( ) ; list . after ( 'add' , this . add , this ) ; list . after ( 'reset' , this . reset , this ) ; list . after ( [ 'add' , 'reset' , 'remove' , 'todoModel:doneChange' ] , this . render , this ) ; list . load ( ) ; }
function ( todo ) { todo . destroy ( { 'delete' : true } ) ; }
function ( ) { var container = this . container , model = this . model , done = model . get ( 'done' ) ; container . setContent ( Y . Lang . sub ( this . template , { checked : done ? 'checked' : '' , text : model . getAsHTML ( 'text' ) } ) ) ; container [ done ? 'addClass' : 'removeClass' ] ( 'todo-done' ) ; this . inputNode = container . one ( '.todo-input' ) ; return this ; }
function ( ) { this . container . removeClass ( 'editing' ) ; this . model . set ( 'text' , this . inputNode . get ( 'value' ) ) . save ( ) ; }
function ( expected ) { var actual ; if ( this . args ) { actual = this . subject . apply ( null , this . args ) ; } else { actual = this . subject ; } return _eq ( expected , actual ) ; }
function ( expected ) { var actual ; if ( this . args ) { actual = this . subject . apply ( null , this . args ) ; } else { actual = this . subject ; } var r = _eq ( expected , actual ) ; r . success = ! r . success ; return r ; }
function ( e ) { tab . screenshot = e . target . result ; if ( ! isCurrentTab ) { this . setTabVisibility ( tab , false ) ; } if ( this . currentScreen === this . TABS_SCREEN ) { this . showTabScreen ( ) ; } }
function browser_handleEvent ( evt ) { var urlInput = this . urlInput ; switch ( evt . type ) { case 'submit' : this . go ( evt ) ; break ; case 'keyup' : if ( evt . keyCode === evt . DOM_VK_ESCAPE ) { evt . preventDefault ( ) ; this . showPageScreen ( ) ; this . urlInput . blur ( ) ; } } }
function browser_navigate ( url ) { this . showPageScreen ( ) ; this . currentTab . title = null ; this . currentTab . url = url ; this . currentTab . dom . setAttribute ( 'src' , url ) ; this . urlInput . value = url ; }
function browser_setUrlButtonMode ( mode ) { this . urlButtonMode = mode ; switch ( mode ) { case this . GO : this . urlButton . src = 'style/images/go.png' ; this . urlButton . style . display = 'block' ; break ; case this . REFRESH : this . urlButton . src = 'style/images/refresh.png' ; this . urlButton . style . display = 'block' ; break ; case this . STOP : this . urlButton . style . display = 'none' ; break ; } }
function browser_showTopSitesTab ( ) { this . deselectAwesomescreenTabs ( ) ; this . topSitesTab . classList . add ( 'selected' ) ; this . topSites . classList . add ( 'selected' ) ; Places . getTopSites ( this . showTopSites . bind ( this ) ) ; }
function browser_selectTab ( id ) { this . currentTab = this . tabs [ id ] ; this . urlInput . value = this . currentTab . title ; this . tabCover . setAttribute ( 'src' , this . currentTab . screenshot ) ; this . updateSecurityIcon ( ) ; this . refreshButtons ( ) ; }
function places_addBookmark ( uri , title , callback ) { if ( ! title ) title = uri ; var bookmark = { uri : uri , title : title , timestamp : new Date ( ) . getTime ( ) } ; this . addPlace ( uri , ( function ( ) { this . db . saveBookmark ( bookmark , callback ) ; } ) . bind ( this ) ) ; }
function ( event ) { var place = event . target . result ; if ( place ) { if ( callback ) callback ( ) ; return ; } else { place = { uri : uri , title : uri , frecency : 0 } ; } var writeRequest = objectStore . add ( place ) ; writeRequest . onsuccess = function onsucess ( event ) { if ( callback ) callback ( ) ; } ; writeRequest . onerror = function onerror ( event ) { console . log ( 'error writing place' ) ; } ; }
function ( window ) { function Settings ( options ) { Calendar . View . apply ( this , arguments ) ; } Settings . prototype = { __proto__ : Object . create ( Calendar . View . prototype ) , selectors : { element : '#settings' } } ; Calendar . ns ( 'Views' ) . Settings = Settings ; }
function ( ) { assert . deepEqual ( subject . _routeViewFn , { } ) ; assert . instanceOf ( subject . timeController , Calendar . Controllers . Time ) ; assert . instanceOf ( subject . db , Calendar . Db ) ; assert . instanceOf ( subject . router , Calendar . Router ) ; }
function ( ) { var first = list [ 'local-first' ] ; assert . instanceOf ( first , Calendar . Provider . Calendar . Local ) ; assert . equal ( first . provider , subject ) ; assert . equal ( first . id , 'local-first' ) ; assert . equal ( first . name , 'your_device' ) ; }
function ( ) { db = testSupport . calendar . db ( ) ; subject = new Calendar . Store . Abstract ( db ) ; }
function ( done ) { db = testSupport . calendar . db ( ) ; subject = db . getStore ( 'Account' ) ; db . open ( function ( err ) { assert . ok ( ! err ) ; done ( ) ; } ) ; }
function ( done ) { var trans = db . transaction ( 'accounts' , 'readwrite' ) ; var accounts = trans . objectStore ( 'accounts' ) ; var res = accounts . clear ( ) ; res . onerror = function ( ) { done ( new Error ( 'could not wipe accounts db' ) ) ; } res . onsuccess = function ( ) { done ( ) ; } }
function ( done ) { eventFired = null ; subject . once ( 'load' , function ( data ) { eventFired = data ; } ) ; subject . _accounts = { } ; subject . load ( function ( err , data ) { if ( err ) { return done ( err ) ; } result = data ; setTimeout ( function ( ) { done ( ) ; } , 0 ) ; } ) ; }
function ( ) { subject . _accounts [ 1 ] = { preset : 'A' } ; assert . isTrue ( subject . presetActive ( 'A' ) ) ; assert . isFalse ( subject . presetActive ( 'B' ) ) ; }
function ( ) { var model = new Calendar . Models . Account ( ) ; var store = app . store ( 'Account' ) ; store . _accounts [ '1' ] = model ; var data = subject . _updateModel ( '1' ) ; assert . equal ( model , data ) ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . id = 'test' ; div . innerHTML = [ '<div id="wrapper"></div>' , '<div id="settings">' , '<div id="settings-calendars"></div>' , '<div id="settings-accounts"></div>' , '</div>' ] . join ( '' ) ; document . body . appendChild ( div ) ; app = testSupport . calendar . app ( ) ; controller = app . timeController ; subject = new Calendar . Views . Settings ( { app : app } ) ; }
function al_updateAlarmEnableState ( enabled , alarm ) { if ( alarm . enabled == enabled ) return ; alarm . enabled = enabled ; var self = this ; AlarmsDB . putAlarm ( alarm , function al_putAlarmList ( ) { self . refresh ( ) ; } ) ; if ( enabled ) { FakeAlarmManager . set ( alarm ) ; } else { FakeAlarmManager . cancel ( alarm ) ; } }
function showBody ( ) { document . documentElement . lang = navigator . mozL10n . language . code ; document . documentElement . dir = navigator . mozL10n . language . direction ; document . body . classList . remove ( 'hidden' ) ; ClockView . init ( ) ; AlarmList . init ( ) ; AlarmEditView . init ( ) ; RepeatPickerView . init ( ) ; SoundPickerView . init ( ) ; SnoozePickerView . init ( ) ; ColorPickerView . init ( ) ; }
function rv_init ( ) { this . updateTime ( ) ; document . addEventListener ( 'mozvisibilitychange' , this ) ; document . getElementById ( 'ring-btn-snooze' ) . addEventListener ( 'click' , this ) ; document . getElementById ( 'ring-btn-close' ) . addEventListener ( 'click' , this ) ; }
function _sendDelete ( feedback ) { if ( feedback ) IMEFeedback . triggerFeedback ( ) ; if ( _requireIME ( ) && _currentLayoutMode === LAYOUT_MODE_DEFAULT ) { _getCurrentEngine ( ) . click ( KeyboardEvent . DOM_VK_BACK_SPACE ) ; return ; } window . navigator . mozKeyboard . sendKey ( KeyboardEvent . DOM_VK_BACK_SPACE , 0 ) ; }
function kc_showIME ( type ) { delete IMERender . ime . dataset . hidden ; IMERender . ime . classList . remove ( 'hide' ) ; _currentInputType = _mapType ( type ) ; _draw ( _baseLayoutName , _currentInputType , _currentLayoutMode , _isUpperCase ) ; if ( _requireIME ( ) ) { if ( _getCurrentEngine ( ) . show ) { _getCurrentEngine ( ) . show ( type ) ; } } _notifyShowKeyboard ( true ) ; }
function calculator_appendValue ( value ) { if ( this . toClear ) { this . stack = [ ] ; this . toClear = false ; } this . stack . push ( value ) ; this . updateDisplay ( ) ; }
function evaluatePostFix_inner ( token ) { if ( ! this . isOperator ( token ) ) { stack . push ( token ) ; } else { var op2 = stack . pop ( ) ; var op1 = stack . pop ( ) ; var result = this . evaluate [ token ] ( op1 , op2 ) ; stack . push ( result ) ; } }
function ( event ) { console . log ( "===== network becomes: " + event . status ) ; var req = settings . getLock ( ) . get ( 'wifi.enabled' ) ; req . onsuccess = function wf_stateGet ( ) { if ( req . result [ 'wifi.enabled' ] ) { updateNetworkState ( ) ; if ( event . status == 'connected' ) { gNetworkList . scan ( ) ; } } } }
function setWifiEnabled ( val ) { gWifiCheckBox . checked = val ; console . log ( "===== network enabled: " + val ) ; if ( val ) { updateNetworkState ( ) ; gNetworkList . clear ( true ) ; gNetworkList . scan ( ) ; } else { gWifiInfoBlock . textContent = _ ( 'disabled' ) ; gNetworkList . clear ( false ) ; gNetworkList . autoscan = false ; } }
function thlui_init ( ) { this . delNumList = [ ] ; this . deleteAllButton . addEventListener ( 'click' , this . deleteAllThreads . bind ( this ) ) ; this . deleteSelectedButton . addEventListener ( 'click' , this . deleteThreads . bind ( this ) ) ; }
function thlui_cleanForm ( ) { var inputs = this . view . getElementsByTagName ( 'input' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; } }
function thui_init ( ) { this . sendButton . addEventListener ( 'click' , this . sendMessage . bind ( this ) ) ; this . pickButton . addEventListener ( 'click' , this . pickContact . bind ( this ) ) ; this . deleteAllButton . addEventListener ( 'click' , this . deleteAllMessages . bind ( this ) ) ; this . deleteSelectedButton . addEventListener ( 'click' , this . deleteMessages . bind ( this ) ) ; this . input . addEventListener ( 'input' , this . updateInputHeight . bind ( this ) ) ; }
function thui_updateHeaderData ( ) { var number = MessageManager . getNumFromHash ( ) ; ThreadUI . title . innerHTML = number ; ContactDataManager . getContactData ( number , function gotContact ( contact ) { if ( contact && contact . length > 0 ) { ThreadUI . title . innerHTML = contact [ 0 ] . name ; } } ) ; }
function thui_cleanForm ( ) { var inputs = this . view . getElementsByTagName ( 'input' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; } }
function onsave ( msg ) { if ( ! msg ) { console . log ( 'Message app - pending message save failed!' ) ; PendingMsgManager . saveToMsgDB ( message , this ) ; } if ( window . location . hash == '#new' ) { window . location . hash = '#num=' + num ; } MessageManager . getMessages ( ThreadListUI . renderThreads ) ; }
function ( evt ) { this . container . addEventListener ( evt , this ) ; }
function ns_tap ( notificationNode ) { var notificationID = notificationNode . dataset . notificationID ; var event = document . createEvent ( 'CustomEvent' ) ; event . initCustomEvent ( 'mozContentEvent' , true , true , { type : 'desktop-notification-click' , id : notificationID } ) ; window . dispatchEvent ( event ) ; this . removeNotification ( notificationNode ) ; UtilityTray . hide ( ) ; }
function sb_updateAll ( ) { this . updateClock ( ) ; this . updateBattery ( ) ; this . updateConnection ( ) ; this . updateWifi ( ) ; }
function ( db , router ) { this . db = db ; this . router = router ; this . _views = Object . create ( null ) ; this . _routeViewFn = Object . create ( null ) ; this . timeController = new Calendar . Controllers . Time ( ) ; }
function ( id , callback ) { var self = this ; var trans = this . db . transaction ( 'accounts' , 'readwrite' ) ; var store = trans . objectStore ( 'accounts' ) ; var req = store . delete ( parseInt ( id ) ) ; trans . onerror = function ( event ) { callback ( event ) ; } trans . oncomplete = function ( ) { delete self . _accounts [ id ] ; callback ( null , id ) ; self . emit ( 'remove' , id ) ; } }
function BlueskyStore ( options ) { options = options || { } ; Store . call ( this , options ) ; this . table = new bluesky . storage ( { account : options . account , key : options . key } ) . table ( options . table ) ; }
function ( err , rows ) { try { if ( err ) { callback ( err ) ; } if ( rows . length === 0 ) return callback ( ) ; callback ( null , JSON . parse ( rows [ 0 ] . data ) ) ; } catch ( err ) { callback ( err ) ; } }
function ( param ) { if ( param . expr ) { data [ param . name ] = this . _eval ( param . expr , datamodelForNextStep , eventSet ) ; } else if ( param . location ) { data [ param . name ] = this . _datamodel [ param . location ] . get ( ) ; } }
function ( name ) { return this . _datamodel [ name ] ; }
function makeDatamodelClosures ( datamodel ) { var vars = [ ] ; for ( var id in datamodel ) { vars . push ( '"' + id + '" : {\n' + '"set" : function(v){ return ' + id + ' = v; },\n' + '"get" : function(){ return ' + id + ';}' + '\n}' ) ; } return vars . length ? '{\n' + vars . join ( ',\n' ) + '\n}' : '' ; }
function ( attack , decay ) { var val = 0 ; if ( state === 0 ) { val = phase / attack ; if ( ++ phase % attack === 0 ) { state ++ ; phase = decay ; } } else if ( state === 1 ) { val = phase / decay ; if ( -- phase === 0 ) state ++ ; ; } return val ; }
function ( k ) { if ( arguments . length == 3 ) { k ( arguments [ 1 ] ) ; } else { var args = [ ] ; for ( var i = 1 ; i < arguments . length - 1 ; i ++ ) { args . push ( arguments [ i ] ) ; } k ( new ValuesWrapper ( args ) ) ; } }
function ( clipboardEvent ) { if ( ! this . application . ninja . currentDocument || ( this . application . ninja . currentDocument && this . application . ninja . currentDocument . currentView === "code" ) ) { return ; } if ( document . activeElement . nodeName !== "BODY" ) { if ( ! document . activeElement . getAttribute ( "data-montage-id" ) === "menuItemButton" ) { return ; } } if ( this . clipboardContext === "stage" ) { ElementsClipboardAgent . copy ( clipboardEvent ) ; } clipboardEvent . preventDefault ( ) ; }
function ( clipboardEvent ) { if ( this . application . ninja . currentDocument . currentView === "code" ) return ; if ( document . activeElement . nodeName !== "BODY" ) { if ( ! document . activeElement . getAttribute ( "data-montage-id" ) === "menuItemButton" ) { return ; } } if ( this . clipboardContext === "stage" ) { ElementsClipboardAgent . cut ( clipboardEvent ) ; } clipboardEvent . preventDefault ( ) ; }
function ( ) { this . gotgps = false ; console . log ( 'mmap model initialize' ) ; }
function ( loc ) { var req = JSON . stringify ( { command : 'FLYTO' , location : loc } ) console . log ( req ) ; $ . ajax ( { type : 'POST' , url : '/command' , data : req } ) ; }
function ( msg , mtype ) { if ( mtype in self . mtable ) { self . mtable [ mtype ] ( msg ) ; } if ( mtype == "HEARTBEAT" ) { if ( msg . index > self . heartbeatIndex ) { self . heartbeatIndex = msg . index ; self . commStatusModel . onHeartbeat ( ) ; } } }
function ( newmsg ) { if ( newmsg . index > lastidx ) { lastidx = newmsg . index ; model . set ( newmsg . msg ) ; } }
function ( d , i ) { var id = '#w_' + d . name + '_chart' var el = d3 . select ( id ) ; var svg = d3 . select ( '#chart' ) . select ( 'svg' ) [ 0 ] [ 0 ] el . style ( 'opacity' , 0 ) ; svg . insertBefore ( el [ 0 ] [ 0 ] , svg . firstChild ) }
function ( d ) { noderadius = d3 . event . srcElement . value ; d3 . select ( '#chart' ) . selectAll ( 'circle.node' ) . attr ( 'r' , noderadius ) }
function ( delta ) { var state = this ; if ( ! ( state . frame % 30 ) ) { this . add ( new Enemy ( { x : Math . random ( ) * state . gameArea . width , y : state . gameArea . height , xSpeed : - ( Math . random ( ) * 10 ) + 5 , ySpeed : 5 , scale : 2 , angle : 180 , image : 'characters/marisa.png' , tasks : [ addCircle ] } ) ) ; } }
function ( data ) { app . collections . pages . reset ( data . links ) ; if ( ! data . items ) return ; return data . items . map ( function ( item ) { return new Models . Article ( item ) ; } ) ; }
function _onError ( error ) { console . error ( error . message ) ; }
function ( ) { var defaults = { projectPath : _getDefaultProjectPath ( ) , projectTreeState : "" } ; _prefs = PreferencesManager . getPreferenceStorage ( PREFERENCES_CLIENT_ID , defaults ) ; $ ( FileViewController ) . on ( "documentSelectionFocusChange" , _documentSelectionFocusChange ) ; $ ( "#open-files-container" ) . on ( "contentChanged" , function ( ) { _redraw ( false ) ; } ) ; CommandManager . register ( Strings . CMD_OPEN_FOLDER , Commands . FILE_OPEN_FOLDER , openProject ) ; }
function ( expected ) { var i ; for ( i = 0 ; i < this . actual . length ; ++ i ) { if ( this . actual [ i ] . isDirectory && this . actual [ i ] . name === expected ) { return true ; } } return false ; }
function ( expected ) { var i ; for ( i = 0 ; i < this . actual . length ; ++ i ) { if ( this . actual [ i ] . isFile && this . actual [ i ] . name === expected ) { return true ; } } return false ; }
function requestNativeFileSystemSuccessCB ( nfs ) { var reader = nfs . createReader ( ) ; var successCallback = function ( e ) { entries = e ; readComplete = true ; } ; var errorCallback = function ( ) { readComplete = true ; gotError = true ; } ; reader . readEntries ( successCallback , errorCallback ) ; }
function ( err ) { errorCalled = true ; error = err ; }
function ( e ) { if ( $ ( e . target ) . parents ( ".CodeMirror-gutter" ) . length !== 0 ) { return ; } var editor = EditorManager . getFocusedEditor ( ) ; if ( editor ) { if ( ! editor . hasSelection ( ) ) { editor . selectWordAt ( editor . getCursorPos ( ) ) ; } editor_cmenu . open ( e ) ; } }
function setCurrentDocument ( document ) { if ( _currentDocument === document ) { return ; } var perfTimerName = PerfUtils . markStart ( "setCurrentDocument:\t" + ( ! document || document . file . fullPath ) ) ; if ( ! ProjectManager . isWithinProject ( document . file . fullPath ) ) { addToWorkingSet ( document . file ) ; } if ( ! _documentNavPending ) { _markMostRecent ( document ) ; } _currentDocument = document ; $ ( exports ) . triggerHandler ( "currentDocumentChange" ) ; PerfUtils . addMeasurement ( perfTimerName ) ; }
function findMatchingRules ( selector , htmlDocument ) { var result = new $ . Deferred ( ) , cssFilesResult = FileIndexManager . getFileInfoList ( "css" ) , resultSelectors = [ ] ; if ( htmlDocument ) { _findMatchingRulesInStyleBlocks ( htmlDocument , selector , resultSelectors ) ; } _findMatchingRulesInCSSFiles ( selector , resultSelectors ) . done ( function ( ) { result . resolve ( resultSelectors ) ; } ) . fail ( function ( error ) { result . reject ( error ) ; } ) ; return result . promise ( ) ; }
function addToWorkingSetAndSelect ( fullPath ) { CommandManager . execute ( Commands . FILE_ADD_TO_WORKING_SET , { fullPath : fullPath } ) ; return openAndSelectDocument ( fullPath , WORKING_SET_VIEW ) ; }
function ( result ) { if ( typeof callback === "function" ) { callback ( result . value ) ; } }
function ( data ) { this . log . info ( 'Handshake authorized' ) ; this . authorized = true ; this . packetQueue . forEach ( this . sendPacket . bind ( this ) ) this . packetQueue . length = 0 if ( this . server ) { this . server . emit ( 'client' , this , data ) ; } this . emit ( 'connect' , data ) ; }
function OutgoingPacket ( client , type , length ) { if ( length > OutgoingPacket . MAX_SIZE ) { throw new Error ( 'Packet to big' ) ; } Buffer . call ( this , length + 3 ) ; this . writeUInt16BE ( length + 1 , 0 ) ; this . writeUInt8 ( type , 2 ) ; this . index = 3 ; this . packetType = type ; this . client = client ; }
function ( ) { this . client . log . debug ( 'Handle error packet' ) ; var args = this . readArgs ( ) ; if ( ! args ) { return ; } args . unshift ( 'error' ) ; this . client . $emit . apply ( this . client , args ) ; }
function ( ) { this . client . log . debug ( 'Handle callback packet' ) ; var id = this . readUInt16BE ( id ) ; var cb = this . client . callbacks [ id ] ; if ( ! cb ) { this . client . $emit ( 'error' , new Error ( 'Cant find callback' ) ) ; return ; } var args = this . readArgs ( ) ; if ( ! args ) { return ; } cb . apply ( null , args ) ; }
function ( ) { this . client . log . debug ( 'Handle callback gc packet' ) var id = this . readUInt16BE ( id ) var cb = this . client . callbacks [ id ] if ( ! cb ) { this . client . $emit ( 'error' , new Error ( 'Cant find callback' ) ) return ; } delete this . client . callbacks [ id ] }
function ( ) { this . client . log . debug ( 'Handle message packet' ) ; var args = this . readArgs ( ) ; if ( ! args ) { return ; } args . unshift ( 'message' ) ; this . client . $emit . apply ( this , args ) ; }
function ( req , socket , upgradeHead ) { var resource = self . options . resource if ( req . url . substr ( 0 , resource . length ) !== resource ) { if ( self . options . destroyUpgrade ) { socket . end ( ) self . log . debug ( 'destroying non-besio upgrade' ) } return } socket . write ( 'HTTP/1.1 101 Switching Protocols\r\n' + 'Upgrade: Besio\r\n' + 'Connection: Upgrade\r\n' + '\r\n' ) client . onSocket ( socket , upgradeHead ) }
function ( data ) { var packet = this . createPacket ( BesioStream . TYPE_DATA , binson . calculate ( data ) ) ; packet . writeBinson ( data ) ; this . log . debug ( 'Send stream data' ) ; return this . client . sendPacket ( packet ) ; }
function ( ) { if ( this . paused ) { return ; } this . paused = true ; if ( this . remoteId === null ) { return ; } this . log . debug ( 'Send stream pause' ) ; var packet = this . createPacket ( BesioStream . TYPE_PAUSE , 0 ) ; this . client . sendPacket ( packet ) ; }
function ( ) { if ( ! this . paused ) { return ; } this . paused = false ; if ( this . remoteId === null ) { return ; } this . log . debug ( 'Send stream resume' ) ; var packet = this . createPacket ( BesioStream . TYPE_RESUME , 0 ) ; this . client . sendPacket ( packet ) ; }
function ( data ) { if ( data ) { this . write ( data ) ; } this . log . debug ( 'Send stream end' ) ; var packet = this . createPacket ( BesioStream . TYPE_END , 0 ) ; this . client . sendPacket ( packet ) ; this . destroySoon ( ) ; }
function ( model , resp ) { if ( error ) error ( model , resp ) ; error ( model , resp ) ; if ( model . __fetchErrorCallback ) { var tmp = model . __fetchErrorCallback ; model . __fetchErrorCallback = null ; tmp . apply ( model ) ; } }
function ( ) { var active = $ ( '#list' ) . find ( '.active' ) ; KT . panel . panelAjax ( active , active . attr ( "data-ajax_url" ) , $ ( '#panel' ) , false ) ; }
function ( ) { var id = $ ( this ) . attr ( 'id' ) ; if ( ! overseerContainer [ id ] ) { var overseer = new OverseerStatement ( that , this ) ; overseerContainer [ id ] = overseer ; if ( ! that . activeStatement ) { that . activeStatement = overseer ; } } else { overseerContainer [ id ] . addTextBlock ( this ) ; } }
function ( ) { if ( this . futureBlock ) { this . block = this . futureBlock ; delete this . futureBlock ; } if ( this . block >= this . textBlocks . length ) { this . block = this . textBlocks . length - 1 ; } }
function ( parent , xmlData ) { this . id = $ ( xmlData ) . attr ( 'id' ) ; if ( ! $ ( xmlData ) . attr ( 'highlight' ) ) { this . highlight = $ ( xmlData ) . attr ( 'highlight' ) ; } }
function ( query ) { if ( query ) { if ( this . hashTagSearchRE . test ( query ) ) { this . query = this . formatHashTagQuery ( query ) ; } else { this . query = this . formatSearchQuery ( query ) ; } } else { this . query = false ; } this . clear ( false ) ; this . requestData ( ) ; }
function invokeAll ( facet , wire ) { var options = facet . options ; if ( typeof options == 'string' ) { return invoke ( options , facet , [ ] , wire ) ; } else { var promises , func ; promises = [ ] ; for ( func in options ) { promises . push ( invoke ( func , facet , options [ func ] , wire ) ) ; } return whenAll ( promises ) ; } }
function protoFactory ( resolver , spec , wire ) { var parentRef , promise ; parentRef = spec . prototype ; promise = typeof parentRef === 'string' ? wire . resolveRef ( parentRef ) : wire ( parentRef , spec . id ) ; when ( promise , Object . create ) . then ( resolver . resolve , resolver . reject ) ; }
function handleModule ( module ) { function resolve ( resolvedArgs ) { return createComponent ( module , resolvedArgs , isConstructor ) ; } if ( typeof module == 'function' ) { return args ? when ( wire ( asArray ( args ) , name ) , resolve ) : resolve ( [ ] ) ; } else { return Object . create ( module ) ; } }
function ( ) { var el = document . createElement ( 'bootstrap' ) , transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'oTransitionEnd' , 'msTransition' : 'MSTransitionEnd' , 'transition' : 'transitionend' } , name for ( name in transEndEventNames ) { if ( el . style [ name ] !== undefined ) { return transEndEventNames [ name ] } } }
function ( prompt , length ) { this . _prompt = prompt ; if ( length ) { this . _promptLength = length ; } else { var lines = prompt . split ( /[\r\n]/ ) ; var lastLine = lines [ lines . length - 1 ] ; this . _promptLength = Buffer . byteLength ( lastLine ) ; } }
function ( options ) { options = options || { } options . dialect = options . dialect || 'mysql' return new Sequelize ( config [ options . dialect ] . database , config [ options . dialect ] . username , config [ options . dialect ] . password , { logging : false , dialect : options . dialect , port : config [ options . dialect ] . port } ) }
function ( ) { var db = self . _openreq . result ; if ( db . objectStoreNames . contains ( self . STORENAME ) ) db . deleteObjectStore ( self . STORENAME ) ; db . createObjectStore ( self . STORENAME , { keyPath : 'date' } ) ; }
function ( item ) { var terrain ; if ( item === '\n' ) { r += 1 ; c = self . left ; } else { terrain = parseSourceItem ( item ) ; self . tiles . push ( self . _entityFactory . createTile ( c , r , terrain ) ) ; c += 1 ; } }
function ( response ) { if ( response . files ) { for ( name in response . files ) { appendFiles ( name , response . files [ name ] ) ; } } }
function ( data ) { if ( self . closed ) return ; data = JSON . stringify ( data ) + ";\r\n" ; console . log ( "S>" + data + "<" ) ; self . stream . write ( data , function ( err ) { if ( err ) { console . error ( err ) ; self . stream . emit ( "end" ) ; } } ) ; }
function ( key , value , callback ) { new Request . JSON ( { url : '/frog/pref/' , noCache : true , headers : { "X-CSRFToken" : Cookie . read ( 'csrftoken' ) } , onSuccess : function ( res ) { Object . append ( this , res . value ) ; if ( callback ) { callback ( ) ; } } . bind ( this ) } ) . POST ( { key : key , val : value } ) ; }
function ( res ) { obj = { id : f . id , file : f . name , size : f . size , percent : 0 , unique : res . value === true } if ( obj . isUnique ) { obj . date = new Date ( ) ; } else { obj . date = new Date ( res . value . created ) ; } var item = self . uploaderList . store . add ( obj ) ; }
function ( property , config ) { this . prototype . __animation [ property ] = config ; }
function pygmentize ( args , callback ) { if ( ! Array . isArray ( args ) ) { args = args . split ( ' ' ) . filter ( function ( arg ) { return arg . trim ( ) . length > 0 ; } ) ; } var pygmentizeReq = { task : 'pygmentize' , args : args } ; request ( pygmentizeReq , callback ) ; }
function ( data ) { var widgetName = this . _widgetName ( data ) ; data . disabled = false ; if ( typeof jQuery ( data . element ) [ widgetName ] !== 'function' ) { throw new Error ( widgetName + ' widget is not available' ) ; } jQuery ( data . element ) [ widgetName ] ( data ) ; jQuery ( data . element ) . data ( 'createWidgetName' , widgetName ) ; return jQuery ( data . element ) ; }
function ( data ) { var widgetName = this . collectionWidgetName ( data ) ; data . disabled = false ; if ( typeof jQuery ( data . element ) [ widgetName ] !== 'function' ) { throw new Error ( widgetName + ' widget is not available' ) ; } jQuery ( data . element ) [ widgetName ] ( data ) ; jQuery ( data . element ) . data ( 'createCollectionWidgetName' , widgetName ) ; return jQuery ( data . element ) ; }
function ( data ) { var widgetName = this . _widgetName ( data ) ; data . disabled = false ; if ( typeof jQuery ( data . element ) [ widgetName ] !== 'function' ) { throw new Error ( widgetName + ' widget is not available' ) ; } jQuery ( data . element ) [ widgetName ] ( data ) ; jQuery ( data . element ) . data ( 'createWidgetName' , widgetName ) ; return jQuery ( data . element ) ; }
function ( data ) { var widgetName = this . collectionWidgetName ( data ) ; data . disabled = false ; if ( typeof jQuery ( data . element ) [ widgetName ] !== 'function' ) { throw new Error ( widgetName + ' widget is not available' ) ; } jQuery ( data . element ) [ widgetName ] ( data ) ; jQuery ( data . element ) . data ( 'createCollectionWidgetName' , widgetName ) ; return jQuery ( data . element ) ; }
function ( newFrame ) { this . setNodeDirty ( ) ; this . _unflippedOffsetPositionFromCenter = newFrame . getOffset ( ) ; var pNewTexture = newFrame . getTexture ( ) ; if ( pNewTexture != this . _texture ) { this . setTexture ( pNewTexture ) ; } this . _rectRotated = newFrame . isRotated ( ) ; if ( this . _rectRotated ) this . setRotation ( - 90 ) ; this . setTextureRect ( newFrame . getRect ( ) , this . _rectRotated , newFrame . getOriginalSize ( ) ) ; }
function ( turn ) { console . log ( 'turn' , turn ) ; appendTurnToLog ( turn ) ; processTurnScore ( turn ) ; if ( turn . player != ui . playerNumber ) { placeTurnTiles ( turn ) ; } if ( turn . whosTurn == ui . playerNumber ) { ui . playAudio ( "yourturn" ) ; ui . boardLocked ( false ) ; } displayWhosTurn ( turn . whosTurn ) ; }
function ( ) { var sizeInBytes = 3 * Float32Array . BYTES_PER_ELEMENT ; var vertices = new ArrayBuffer ( sizeInBytes ) ; var positions = new Float32Array ( vertices ) ; positions [ 0 ] = 1 ; positions [ 1 ] = 2 ; positions [ 2 ] = 3 ; buffer = context . createVertexBuffer ( sizeInBytes , BufferUsage . STATIC_DRAW ) ; buffer . copyFromArrayView ( vertices ) ; }
function ( ) { buffer = context . createIndexBuffer ( 6 , BufferUsage . STREAM_DRAW , IndexDatatype . UNSIGNED_SHORT ) ; expect ( buffer . getSizeInBytes ( ) ) . toEqual ( 6 ) ; expect ( buffer . getUsage ( ) ) . toEqual ( BufferUsage . STREAM_DRAW ) ; expect ( buffer . getIndexDatatype ( ) ) . toEqual ( IndexDatatype . UNSIGNED_SHORT ) ; expect ( buffer . getBytesPerIndex ( ) ) . toEqual ( 2 ) ; expect ( buffer . getNumberOfIndices ( ) ) . toEqual ( 3 ) ; }
function ( options ) { this . users = options . users || this . users || [ ] ; if ( ! ( this . users instanceof Array ) ) this . users = [ this . users ] ; if ( this . users . length > 0 ) { this . src_types . push ( 'user' ) ; } }
function ( options ) { this . categories = options . categories || this . categories || [ ] ; if ( ! ( this . categories instanceof Array ) ) this . categories = [ this . categories ] ; if ( this . categories . length > 0 ) { this . dest_types . push ( 'category' ) ; } }
function ( options , callback ) { if ( this . categories . length > 0 ) { this . core . domainInCategories ( options . domain , this . categories , function ( in_category ) { callback ( null , in_category ) ; } ) ; } else { callback ( null , false ) ; } }
function ( domain , category , callbacks ) { delete self . categories [ domain ] [ category ] ; self . domainInCategories ( domain , category . split ( '_' ) , function ( answer ) { for ( var i in callbacks ) { callbacks [ i ] ( answer ) ; } } ) ; }
function ( options ) { this . file_types = options . file_types || this . file_types || [ ] ; if ( ! ( this . file_types instanceof Array ) ) this . file_types = [ this . file_types ] ; if ( this . file_types . length > 0 ) { this . dest_types . push ( 'filetype' ) ; } }
function ( options , callback ) { var parts = url . parse ( options . url ) ; for ( var i in this . file_types ) { if ( parts . pathname . match ( '\\.' + this . file_types [ i ] ) ) { callback ( null , true ) ; return ; } } callback ( null , false ) ; }
function ( options ) { this . groups = options . groups || this . groups || [ ] ; if ( ! ( this . groups instanceof Array ) ) this . groups = [ this . groups ] ; if ( this . groups . length > 0 ) { this . src_types . push ( 'group' ) ; } }
function ( user ) { if ( user && user . memberOf ) { for ( var i in user . memberOf ) { if ( self . groups . indexOf ( user . memberOf [ i ] ) != - 1 ) { callback ( null , true ) ; return ; } } } callback ( null , false ) ; }
function ( options , callback ) { for ( var i in this . ips ) { if ( this . ips [ i ] . contains ( options . ip ) ) { callback ( null , true ) ; return ; } } callback ( null , false ) ; }
function ( options , callback ) { for ( var i in this . matches ) { if ( options . domain . match ( this . matches [ i ] ) ) { callback ( null , true ) ; return ; } } callback ( null , false ) ; }
function ( options ) { this . ous = options . ous || this . ous || [ ] ; if ( ! ( this . ous instanceof Array ) ) this . ous = [ this . ous ] ; if ( this . ous . length > 0 ) { this . src_types . push ( 'ou' ) ; } }
function ( user ) { if ( user && user . memberOf ) { if ( self . ous . indexOf ( user . dn . replace ( /^CN=(.+?),/ , '' ) ) != - 1 ) { callback ( null , true ) ; return ; } } callback ( null , false ) ; }
function ( options ) { var self = this ; this . times = options . times || this . times || [ ] ; if ( ! ( this . times instanceof Array ) ) this . times = [ this . times ] ; if ( this . times . length > 0 ) { this . misc_types . push ( 'time' ) ; checkTime ( self ) ; setInterval ( function ( ) { checkTime ( self ) ; } , 1000 * 60 ) ; } }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj [ 0 ] . name , 'nodejitsu' ) ; assert . equal ( obj [ 1 ] . name , 'flatiron' ) ; assert . equal ( obj [ 0 ] . resource , 'Forum' ) ; assert . equal ( obj [ 1 ] . resource , 'Forum' ) ; }
function ( APIKEY , respondToCrewmember ) { console . log ( 'New cremember asking for supervisor for APIKEY: ' + APIKEY ) ; if ( apikeys [ APIKEY ] && apikeys [ APIKEY ] . allowed ) { var thisSupervisor = getSupervisor ( APIKEY ) ; supervisorNamespace = setupForeman ( APIKEY , supervisor ) ; console . log ( 'New cremember reporting to: /' + supervisorNamespace ) ; respondToCrewmember ( supervisorNamespace ) ; } }
function ( ele ) { return ele . nodeType === 1 ? ele . innerHTML . toLowerCase ( ) : null ; }
function updateLocation ( loc ) { var isChange = currentLocation != loc ; if ( currentLocation != loc && getLocation ( ) != loc ) { location . hash = loc ; } currentLocation = loc ; return isChange ; }
function ( ) { args . css ( 'height' , height ( 37 ) ) ; hideAllWindows ( ) ; argsDiv . css ( 'display' , 'block' ) ; args . focus ( ) ; }
function scrollAnimation ( ) { console . log ( 'scrollPosition: ' + scrollPosition + ' scrollAmount: ' + scrollAmount + ' scrollAdjusted: ' + scrollAdjusted + ' scrollPercent: ' + scrollPercent + ' scrollScale: ' + scrollScale ) ; $ ( '.item' ) . each ( function ( index ) { move ( index + 1 ) ; } ) ; }
function ( ) { try { var logger = goog . debug . Logger . getLogger ( 'showcase.init' ) ; logger . info ( 'Starting...' ) ; var jCombo = $ ( '#comboBox' ) ; if ( ! jCombo . length ) return ; s . config . set ( 'user.auth.performLocalAuth' , true ) ; s . config . set ( 'user.auth.ext.fb.app_id' , '186392014808053' ) ; s . config . set ( 'user.auth.ext.fb.permissions' , 'email,publish_stream' ) ; s . init ( ) ; } catch ( e ) { ss . error ( e ) ; } }
function ( ) { this . _configApply ( ssd . Config . getInstance ( ) . get ( ssd . user . auth . CONFIG_PATH ) ) ; this . _extSupportedSources . forEach ( function ( key , value ) { value . init ( ) ; } ) ; }
function ( data , textStatus , jqXHR ) { if ( data . match ( matchString ) ) { $ ( dialog_selector ) . html ( data ) . modal ( 'show' ) ; return false ; } if ( onSuccessHandler && typeof onSuccessHandler == 'function' ) { onSuccessHandler ( ) ; } $ ( dialog_selector ) . modal ( 'hide' ) ; }
function ( ) { if ( ! this . editor ) return ; try { this . editor . removeEventListener ( "keypress" , this . onKeyPress ) ; } catch ( err ) { } this . editor . removeEventListener ( CONTEXT_MENU , this . onContextMenu ) ; this . editor . removeEventListener ( TEXT_CHANGED , this . onTextChanged ) ; this . editor . destroy ( ) ; this . editor = null ; }
function ( event ) { Firebug . CommandLine . update ( Firebug . currentContext ) ; switch ( event . keyCode ) { case KeyEvent . DOM_VK_RETURN : if ( Events . isControl ( event ) ) this . onExecute ( ) ; break ; case KeyEvent . DOM_VK_ESCAPE : this . onEscape ( ) ; event . preventDefault ( ) ; break ; } }
function ( adjust ) { if ( ! this . editor || ! this . editor . _view ) return ; if ( typeof ( SourceEditor ) != "undefined" ) { var doc = this . editor . _view . _frame . contentDocument ; } else { this . editor . textBox . style . fontSizeAdjust = adjust ; } }
function ( context ) { var visible = Firebug . CommandLine . Popup . isVisible ( ) ; if ( visible && context . panelName != "console" ) return this . getSingleRowCommandLine ( ) ; return Firebug . commandEditor ? this . getCommandEditor ( ) : this . getSingleRowCommandLine ( ) ; }
function ( file ) { var text = "" ; if ( file . responseStatus ) text += file . responseStatus + " " ; if ( file . responseStatusText ) text += file . responseStatusText ; return text ? Str . cropString ( text ) : " " ; }
function ( ) { this . unregisterObservers ( ) ; TraceModule . removeListener ( this . traceListener ) ; var netInfoBody = Firebug . NetMonitor . NetInfoBody ; if ( "removeListener" in netInfoBody ) netInfoBody . removeListener ( this . NetInfoBody ) ; }
function ( ) { Firebug . Module . initializeUI . apply ( this , arguments ) ; if ( FBTrace . DBG_INITIALIZE ) FBTrace . sysout ( "StartButton.initializeUI;" ) ; }
function ( err , res ) { return callback ( err , obj ) ; }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . above ( 0 ) ; Tester . setAuthUser ( res . body . sess , res . body . userId ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . above ( 0 ) ; Tester . setAuthUser ( res . body . sess , res . body . userId ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . above ( 0 ) ; Tester . setAuthUser ( res . body . sess , res . body . userId ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . above ( 0 ) ; Tester . setAuthUser ( res . body . sess , res . body . userId ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_UNAUTHORIZED' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 401 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_UNAUTHORIZED' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 401 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'postId' ) ; res . body . should . have . property ( 'views' ) ; res . body . views . should . above ( Tester . getPostViewsCount ( ) ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_INVALID_USER_ID' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 607 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'removedCount' ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_EMPTY_RESULTS' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 601 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . equal ( 0 ) ; Tester . setSession ( res . body . sess ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_INVALID_KEY' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 602 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_INVALID_KEY' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 602 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_INVALID_KEY' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 602 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( array ) { var tagged = arr ( ) , count = 0 , i = array . length , item ; while ( i -- ) { item = array [ i ] ; if ( item && ! item . hasOwnProperty ( uniqueTag ) ) { item [ uniqueTag ] = count ; tagged [ count ++ ] = item ; } } i = tagged . length ; while ( i -- ) { delete tagged [ i ] [ uniqueTag ] ; } return tagged ; }
function togglebinary ( toggleNum , toggleVal ) { if ( ( toggleNum >= 1 ) && ( toggleNum <= 52 ) ) { var start = toggleBinaryGlobal . substring ( 0 , toggleNum ) ; var end = toggleBinaryGlobal . substring ( toggleNum + 1 ) ; toggleBinaryGlobal = start + toggleVal + end ; save_toggles ( ) ; } }
function ( Y , theTopic ) { var section = document . getElementById ( "section-" + theTopic ) ; var secatag = document . getElementById ( "sectionatag-" + theTopic ) ; if ( ( section != null ) && ( secatag != null ) ) { toggleexacttopic ( section , secatag , theTopic , true ) ; } }
function ( pokemon ) { pokemon . addVolatile ( 'trace' ) ; }
function ( ) { return this ; } , G = F . bind ( { hello : "world" }
function F ( ) { this . foo = "bar" ; }
function ( e ) { e . preventDefault ( ) ; var jqXHR = $ . ajax ( { url : $ ( this ) . attr ( 'href' ) , context : $ ( this ) , doNotRetry : false } ) ; if ( jqXHR ) { jqXHR . done ( function ( data ) { $ ( this ) . parents ( ) . first ( ) . replaceWith ( data ) ; } ) ; } jqXHR . fail ( alert ( "Erro ao conectar o servidor" ) ) ; }
function ( ) { var type = this . ingredients [ Math . random ( ) * this . ingredients . length | 0 ] ; var width = utils . getIngredientWidth ( ) ; var height = utils . getIngredientHeight ( type ) ; var ingredient = new Ingredient ( type , width , height ) ; ingredient . x = BOUND_LEFT + Math . random ( ) * BOUND_RIGHT ; ingredient . y = - 100 ; return ingredient ; }
function cancelFullScreen ( ) { if ( document . exitFullscreen ) { document . exitFullscreen ( ) ; } else if ( document . mozCancelFullScreen ) { document . mozCancelFullScreen ( ) ; } else if ( document . webkitCancelFullScreen ) { document . webkitCancelFullScreen ( ) ; } $ ( document ) . off ( 'fullscreenchange mozfullscreenchange webkitfullscreenchange' ) ; }
function ( fullScreen ) { if ( ! fullScreen ) { elem . removeClass ( options . fullscreenClass ) . insertBefore ( fs ) ; fs . remove ( ) ; } options . callback ( fullScreen ) ; }
function ( boundingBox ) { var focusHandle = Widget . _hDocFocus , mouseHandle = this . _hDocMouseDown ; if ( focusHandle ) { if ( focusHandle . listeners > 0 ) { focusHandle . listeners -- ; } else { focusHandle . detach ( ) ; Widget . _hDocFocus = null ; } } if ( WEBKIT && mouseHandle ) { mouseHandle . detach ( ) ; } }
function ( boundingBox ) { var focusHandle = Widget . _hDocFocus , mouseHandle = this . _hDocMouseDown ; if ( focusHandle ) { if ( focusHandle . listeners > 0 ) { focusHandle . listeners -- ; } else { focusHandle . detach ( ) ; Widget . _hDocFocus = null ; } } if ( WEBKIT && mouseHandle ) { mouseHandle . detach ( ) ; } }
function ( ) { x = parseInt ( $P . pointer_x / $P . width * $P . iconSize ) y = parseInt ( $P . pointer_y / $P . height * $P . iconSize ) if ( $P . pointer_x >= 0 && $P . pointer_x < $P . width && $P . pointer_y >= 0 && $P . pointer_y < $P . height ) { $C . fillRect ( x * $P . pixelSize , y * $P . pixelSize , $P . intPixelSize , $P . intPixelSize ) } }
function findFile ( paths , file ) { for ( var i = 0 ; i < paths . length ; i ++ ) { var filePath = path . resolve ( paths [ i ] , file ) if ( path . existsSync ( filePath ) ) { return filePath } } return null }
function ( ) { this . move ( 1 ) ; var props = this . peek ( 1 ) == '}' ? [ ] : this . readProperties ( ) ; this . move ( 1 ) ; var marker = null ; if ( this . current == '$' ) { marker = this . readNumber ( ) ; this . move ( 1 ) ; } else marker = null ; if ( this . current != '}			throw new Error("Unexpected character ' " + this.current + "
function ( count ) { if ( count == 0 ) return ; if ( count > this . remaining ) throw new Error ( "Unexpected end of pattern." ) ; this . remaining -= count ; this . position += count ; this . current = this . source [ this . position ] ; }
function ( bookmark ) { app . restoreState = app . getState ( ) ; app . loadState ( bookmark . state ) ; app . viewModel . error ( "restoreState" ) ; $ ( '#bookmark-popover' ) . hide ( ) ; }
function ( ) { if ( mplayer != undefined ) { var newVol = ( volume + 3 ) > 100 ? 100 : ( volume + 3 ) ; mplayer . stdin . write ( "set_property volume " + newVol ) ; setTimeout ( MPlayer . getVolume , 1000 ) ; } }
function ( ) { if ( mplayer != undefined ) { var newVol = ( volume - 3 ) > 100 ? 100 : ( volume - 3 ) ; mplayer . stdin . write ( "set_property volume " + newVol ) ; setTimeout ( MPlayer . getVolume , 1000 ) ; } }
function ( ) { var _this = this ; if ( $ ( '#' + this . playerProxy . id ) . data ( 'hasPlayerReciveApi' ) ) { mw . log ( "Error trying to add player api for:" + this . playerProxy . id + " that already has one" ) ; return ; } $ ( '#' + this . playerProxy . id ) . data ( 'hasPlayerReciveApi' , true ) ; $ . receiveMessage ( function ( event ) { _this . handleReceiveMessage ( event ) ; } , this . iframeServer ) ; }
function tilesetSelectChange ( ) { var info = JSON . parse ( tilesetSelect . val ( ) ) ; if ( info [ 0 ] . length > 0 ) { tileset . load ( info [ 0 ] , ! serverInfo . paths . merge_folders ? info [ 3 ] : false ) ; } else { tileset . unload ( ) ; } }
function ( resource , plotID , container , series ) { var config = SunstoneMonitoringConfig [ resource ] . monitor [ plotID ] var options = config . plotOptions $ . plot ( container , series , options ) }
function ( monitoring ) { $ ( '#totalUsers' , $dashboard ) . text ( monitoring [ 'totalUsers' ] ) if ( ! $dashboard . is ( ':visible' ) ) return ; var container = $ ( 'div#usersPerGroup' , $dashboard ) ; SunstoneMonitoring . plot ( 'USER' , 'usersPerGroup' , container , monitoring [ 'usersPerGroup' ] ) ; }
function ( ) { label = this . monitor_resources ; id_suffix = label . replace ( /,/g , '_' ) ; id_suffix = id_suffix . replace ( /\//g , '_' ) ; id = id_prefix + id_suffix ; str += '<table class="info_table">\                 <thead><tr><th colspan="1">' + this . title + '</th></tr></thead>\                 <tr><td id="legend_' + id_suffix + '"></td></tr>\                 <tr><td style="border:0">\                 <div id="' + id + '" style="width:' + width + 'px; height:150px;margin-bottom:10px;position:relative;left:-20px;">' + spinner + '</div>\               </td></tr></table>' ; }
function ( ) { $ ( 'div#cluster_tab_' + cluster . ID + ' div.plot' ) . trigger ( 'resize' ) ; }
function ( monitoring ) { $ ( '#totalHosts' , $dashboard ) . text ( monitoring [ 'totalHosts' ] ) delete monitoring [ 'totalHosts' ] if ( ! $dashboard . is ( ':visible' ) ) return ; for ( plotID in monitoring ) { var container = $ ( 'div#' + plotID , $dashboard ) ; if ( ! container . length ) continue ; SunstoneMonitoring . plot ( "HOST" , plotID , container , monitoring [ plotID ] ) ; } ; }
function ( ) { var isFormValid = true ; var $form = $$ ( this ) ; $$ ( '*[data-fjs-error_for]' ) . html ( '' ) ; $form . find ( ':input' ) . each ( function ( ) { isFormValid = singleFieldValidate ( $$ ( this ) ) && isFormValid ; } ) ; if ( isFormValid && $form . attr ( 'data-fjs-form-ajax' ) ) { $$ . fjs . forms . ajaxSubmit ( $form ) ; return false ; } return isFormValid ; }
function ( title , message , options ) { this . notificationAudio . play ( ) ; return this . notimoo . show ( Object . merge ( { title : title || '' , message : message || '' } , options ) ) ; }
function ( e ) { e = new Event ( e ) ; this . layout . cursor . setStyles ( { 'top' : e . page . y - this . layout . overlay . getTop ( ) - curH , 'left' : e . page . x - this . layout . overlay . getLeft ( ) - curW } ) ; this . overlayDrag . call ( this ) ; this . layout . drag . start ( e ) ; }
function ( e ) { e = new Event ( e ) ; this . layout . arrows . setStyle ( 'top' , e . page . y - this . layout . slider . getTop ( ) + this . snippet ( 'slider' ) - arwH ) ; this . sliderDrag . call ( this ) ; this . layout . sliderDrag . start ( e ) ; }
function createJob ( found , $_done ) { console . log ( 'found: ' , found ) if ( found ) console . log ( 'REMOVED OLD JOB ' + envelope . id ) ; console . log ( '  creating job ' + envelope . jobData . title + '...' ) $_done ( null , JOBS . create ( envelope . jobType , envelope . jobData ) ) }
function ( event ) { var input = $ ( this ) ; if ( event . which == 9 && ! event . shiftKey && input . is ( '.start' ) ) { input . nextAll ( 'input.end' ) . show ( ) . focus ( ) ; event . preventDefault ( ) ; } }
function ( event ) { var input = $ ( this ) , date = input . val ( ) , validated = input . data ( 'validated' ) ; if ( date == '' ) { empty ( input ) ; } else if ( date != validated ) { validate ( input , date , true ) ; } }
function ( event ) { marker . setPosition ( event . latLng ) ; $ ( '#SiteLatDec' ) . val ( event . latLng . lat ( ) ) $ ( '#SiteLonDec' ) . val ( event . latLng . lng ( ) ) gmap . panTo ( event . latLng ) ; }
function ( event ) { udm ( event ) ; var z = gmap . getZoom ( ) ; if ( z < 16 ) { z = Math . ceil ( z * 1.15 ) ; gmap . setZoom ( z ) ; } wc . demLookup ( ) ; }
function ( ctx ) { x3dom . nodeTypes . Inline . superClass . call ( this , ctx ) ; this . addField_MFString ( ctx , 'url' , [ ] ) ; this . addField_SFBool ( ctx , 'load' , true ) ; this . addField_MFString ( ctx , 'nameSpaceName' , [ ] ) ; this . addField_SFBool ( ctx , 'mapDEFToID' , false ) ; this . count = 0 ; this . currentInline = ctx . xmlNode ; }
function ( ) { $ ( this ) . data ( 'originalHeight' , $ ( this ) . height ( ) ) ; $ ( this ) . data ( 'originalWidth' , $ ( this ) . width ( ) ) ; $ . tiSlideshow . adjustSize ( ) ; }
function ( ) { $ ( '.tiSlideshowPlaceSliderPicture img' ) . data ( 'originalHeight' , $ ( '.tiSlideshowPlaceSliderPicture img' ) . height ( ) ) ; $ ( '.tiSlideshowPlaceSliderPicture img' ) . data ( 'originalWidth' , $ ( '.tiSlideshowPlaceSliderPicture img' ) . width ( ) ) ; $ . tiSlideshow . adjustSize ( ) ; $ ( '.tiSlideshowPlaceSliderPicture img' ) . show ( ) ; $ ( '.tiSlideshowPlaceControlThumbnailsSelected' ) . removeClass ( 'tiSlideshowPlaceControlThumbnailsSelected' ) ; $ ( '.tiSlideshowPlaceControlThumbnails .tiSlideshowPlaceControlThumbnailsThumbnail:eq(' + self . currentImageIndex + ')' ) . addClass ( 'tiSlideshowPlaceControlThumbnailsSelected' ) ; if ( callback ) callback ( ) ; }
function ( oldObj , newObj ) { if ( typeof oldObj != "number" ) { var idx = jQuery . inArray ( oldObj , this ) ; if ( idx > - 1 ) { this . splice ( idx , 1 , newObj ) ; } } else { this . splice ( oldObj , 1 , newObj ) ; } }
function ( oldObj , newObj ) { if ( typeof oldObj != "number" ) { var idx = this . indexOf ( oldObj ) ; if ( idx > - 1 ) { this . splice ( idx , 1 , newObj ) ; } } else { this . splice ( oldObj , 1 , newObj ) ; } }
function ( ) { $ ( 'html' ) . on ( 'click.dropdown.data-api' , clearMenus ) $ ( 'body' ) . on ( 'click.dropdown.data-api' , toggle , Dropdown . prototype . toggle ) }
function ( options ) { options = $ . extend ( { } , $ . fn [ this . type ] . defaults , options , this . $element . data ( ) ) if ( options . delay && typeof options . delay == 'number' ) { options . delay = { show : options . delay , hide : options . delay } } return options }
function ( e ) { var self = $ ( e . currentTarget ) [ this . type ] ( this . _options ) . data ( this . type ) if ( ! self . options . delay || ! self . options . delay . show ) { self . show ( ) } else { self . hoverState = 'in' setTimeout ( function ( ) { if ( self . hoverState == 'in' ) { self . show ( ) } } , self . options . delay . show ) } }
function ( ) { var title , $e = this . $element , o = this . options title = $e . attr ( 'data-original-title' ) || ( typeof o . title == 'function' ? o . title . call ( $e [ 0 ] ) : o . title ) title = title . toString ( ) . replace ( /(^\s*|\s*$)/ , "" ) return title }
function ( ) { var $tip = this . tip ( ) , title = this . getTitle ( ) , content = this . getContent ( ) $tip . find ( '.popover-title' ) [ $ . type ( title ) == 'object' ? 'append' : 'html' ] ( title ) $tip . find ( '.popover-content > *' ) [ $ . type ( content ) == 'object' ? 'append' : 'html' ] ( content ) $tip . removeClass ( 'fade top bottom left right in' ) }
function ( ) { var content , $e = this . $element , o = this . options content = $e . attr ( 'data-content' ) || ( typeof o . content == 'function' ? o . content . call ( $e [ 0 ] ) : o . content ) content = content . toString ( ) . replace ( /(^\s*|\s*$)/ , "" ) return content }
function ( target ) { var active this . activeTarget = target this . $body . find ( this . selector ) . parent ( '.active' ) . removeClass ( 'active' ) active = this . $body . find ( this . selector + '[href="' + target + '"]' ) . parent ( 'li' ) . addClass ( 'active' ) if ( active . parent ( '.dropdown-menu' ) ) { active . closest ( 'li.dropdown' ) . addClass ( 'active' ) } }
function next ( ) { $active . removeClass ( 'active' ) . find ( '> .dropdown-menu > .active' ) . removeClass ( 'active' ) element . addClass ( 'active' ) if ( transition ) { element [ 0 ] . offsetWidth element . addClass ( 'in' ) } else { element . removeClass ( 'fade' ) } if ( element . parent ( '.dropdown-menu' ) ) { element . closest ( 'li.dropdown' ) . addClass ( 'active' ) } callback && callback ( ) }
function ( ) { var pos = $ . extend ( { } , this . $element . offset ( ) , { height : this . $element [ 0 ] . offsetHeight } ) this . $menu . css ( { top : pos . top + pos . height , left : pos . left } ) this . $menu . show ( ) this . shown = true return this }
function ( $1 , match ) { return '<strong>' + match + '</strong>' }
function ( e ) { e . stopPropagation ( ) e . preventDefault ( ) switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : this . hide ( ) break default : this . lookup ( ) } }
function ( e ) { e . stopPropagation ( ) if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : e . preventDefault ( ) this . prev ( ) break case 40 : e . preventDefault ( ) this . next ( ) break } }
function ( error , results ) { var hasErrors = false , field ; for ( field in results ) { if ( results [ field ] === null ) { delete ( results [ field ] ) ; } else { hasErrors = true ; } } if ( hasErrors ) { callback ( results , undefined ) ; } else { callback ( undefined , data ) ; } }
function ( checked ) { if ( checked ) { showQuestion ( ) ; } else { reset ( ) ; } $ ( actionCheckboxes ) . attr ( "checked" , checked ) . parent ( ) . parent ( ) . toggleClass ( options . selectedClass , checked ) ; }
function ( tweet , tweetReqStatus ) { console . log ( 'tweet: ' , tweet ) ; $ . ajax ( { url : 'http://api.twitter.com/1/statuses/oembed.json?' + 'id=' + tweet . id_str + 'omit_script=1' + '&hide_thread=1' , success : function ( embed , embedReqStatus ) { $ ( '#rendered-tweets' ) . prepend ( embed . html ) ; if ( tweet . in_reply_to_status_id_str ) { $ . ajax ( { url : 'http://api.twitter.com/1/statuses/show/' + tweet . in_reply_to_status_id_str + '.json?' + 'trim_user=1' , success : loadConfabulatedTweets } ) ; } } } ) ; }
function showNotificationMenu ( ) { var menu = document . getElementById ( "notificationList" ) ; menu . style . opacity = 1.0 ; menu . style . cursor = "pointer" ; menuTimer = 0 ; timeout = setTimeout ( function ( ) { menuOpened = true ; } , 500 ) ; }
function hideNotificationMenu ( event ) { if ( menuOpened && timeout ) { var menu = document . getElementById ( "notificationList" ) ; menu . style . opacity = 0.0 ; menu . style . cursor = "default" ; menuOpened = false ; clearTimeout ( timeout ) ; } }
function ( e ) { var frame = e . frame ; for ( var i = 0 ; i < this . _goals . length ; i ++ ) this . _goals [ i ] . Update ( frame ) ; for ( var i = 0 ; i < this . _goals . length ; i ++ ) { var goal = this . _goals [ i ] ; if ( goal . IsActive ) { goal . Behave ( frame ) ; break ; } } }
function ( other ) { return other != null && this . Faction === other . Faction ; }
function ( x , y ) { var from = this . GetCenterRounded ( ) ; var to = { x : x , y : y } ; this . _pendingPath = NavigationManager . GetPathFinder ( ) . FindPath ( from , to ) ; this . _advancePath ( ) ; }
function ( ) { var entity = Crafty . e ( "2D, DOM, Mouse, Body, Damageable, BodyAnimations, AbilityUser, NavigationHandle, AI, " + this . _getRandomSprite ( ) ) . attr ( { TileWidth : this . Width , TileHeight : this . Height , IsStatic : false , MovementSpeed : this . Speed , Faction : Factions . Ghost } ) . AddAbility ( "Primary" , new Ability_Shoot ( ) ) ; this . set ( { 'entity' : entity } ) ; }
function ( ) { var center = this . GetCenterReal ( ) ; var x0 = center . x - Crafty . viewport . width / 2 , y0 = center . y - Crafty . viewport . height / 2 ; if ( x0 < 0 ) x0 = 0 ; if ( y0 < 0 ) y0 = 0 ; Crafty . viewport . x = - x0 ; Crafty . viewport . y = - y0 ; }
function ( w , h ) { for ( var y = 0 ; y < this . h ; y ++ ) { for ( var x = 0 ; x < this . w ; x ++ ) { this . setCell ( x , y , this . tiles . unused ) ; } } if ( this . createRoom ( 11 , 11 , 'n' ) ) console . log ( this . map ) ; return this ; }
function NoClickDelay ( el , options ) { this . element = $j ( el ) ; this . options = options || { } ; if ( window . Touch ) this . element . off ( 'touchstart' ) . on ( 'touchstart' , this ) ; }
function ( e ) { switch ( e . type ) { case 'touchstart' : this . onTouchStart ( e ) ; break ; case 'touchmove' : this . onTouchMove ( e ) ; break ; case 'touchend' : this . onTouchEnd ( e ) ; break ; } }
function ( session ) { var worker = new WorkerClient ( [ "ace" ] , "ace/worker/json" , "JsonWorker" ) ; worker . attachToDocument ( session . getDocument ( ) ) ; worker . on ( "error" , function ( e ) { session . setAnnotations ( [ e . data ] ) ; } ) ; worker . on ( "ok" , function ( ) { session . clearAnnotations ( ) ; } ) ; return worker ; }
function ( ) { log . history = log . history || [ ] ; log . history . push ( arguments ) ; arguments . callee = arguments . callee . caller ; if ( this . console ) console . log ( Array . prototype . slice . call ( arguments ) ) ; }
function ( ) { window . bridge . recorderWindow = null ; window . bridge . shutdown ( ) ; }
function ( data ) { if ( data . repositoryVersion > 1 ) { callback ( null , "Plugin list data format is too new. Please upgrade Builder." ) ; } else { var result = [ ] ; for ( var i = 0 ; i < data . plugins . length ; i ++ ) { if ( data . plugins [ i ] . browsers [ bridge . browserType ( ) ] ) { result . push ( data . plugins [ i ] ) ; } } callback ( result ) ; } }
function ( result ) { if ( JSON . parse ( result ) . value === "NOT FOUND" ) { window . bridge . getRecordingWindow ( ) . document . title = title_identifier ; window . setTimeout ( builder . selenium2 . playback . sessionStartTimeout , 1000 ) ; return ; } builder . selenium2 . playback . sessionId = JSON . parse ( result ) . value ; builder . selenium2 . playback . playStep ( ) ; }
function ( value ) { var dateValue = this . convertToDate ( value ) , output = dateValue . getUTCFullYear ( ) + '-' + pad ( dateValue . getUTCMonth ( ) + 1 ) + '-' + pad ( dateValue . getUTCDate ( ) ) + 'T' + pad ( dateValue . getUTCHours ( ) ) + ':' + pad ( dateValue . getUTCMinutes ( ) ) + ':' + pad ( dateValue . getUTCSeconds ( ) ) + 'Z' ; return output ; }
function ( value ) { var dateValue = this . convertToDate ( value ) , output = dateValue . getUTCFullYear ( ) + '-' + pad ( dateValue . getUTCMonth ( ) + 1 ) + '-' + pad ( dateValue . getUTCDate ( ) ) + 'T' + pad ( dateValue . getUTCHours ( ) ) + ':' + pad ( dateValue . getUTCMinutes ( ) ) + ':' + pad ( dateValue . getUTCSeconds ( ) ) + this . getReadableTimezone ( dateValue , true ) ; return output ; }
function ( value ) { var dateValue = this . convertToDate ( value ) , output = this . getDayShort ( dateValue ) + ', ' + dateValue . getDate ( ) + ' ' + this . getMonthShort ( dateValue ) + ' ' + dateValue . getUTCFullYear ( ) + ' ' + pad ( dateValue . getUTCHours ( ) ) + ':' + pad ( dateValue . getUTCMinutes ( ) ) + ':' + pad ( dateValue . getUTCSeconds ( ) ) + ' ' + this . getReadableTimezone ( dateValue ) ; return output ; }
function ( dateObj , addDelimiter ) { dateObj = dateObj || new Date ( ) ; addDelimiter = addDelimiter || false ; var offset = - dateObj . getTimezoneOffset ( ) , hours = Math . floor ( offset / 60 ) , minutes = ( offset - ( hours * 60 ) ) , output = ( ( hours > 0 ) ? '+' : '-' ) + pad ( hours ) + ( addDelimiter ? ':' : '' ) + pad ( minutes ) ; return output ; }
function ( ) { expect ( 1 ) ; var props = { "tabindex" : "tabIndex" , "readonly" : "readOnly" , "for" : "htmlFor" , "class" : "className" , "maxlength" : "maxLength" , "cellspacing" : "cellSpacing" , "cellpadding" : "cellPadding" , "rowspan" : "rowSpan" , "colspan" : "colSpan" , "usemap" : "useMap" , "frameborder" : "frameBorder" , "contenteditable" : "contentEditable" } ; if ( ! jQuery . support . enctype ) { props . enctype = "encoding" ; } deepEqual ( props , jQuery . propFix , "jQuery.propFix passes integrity check" ) ; }
function ( ) { expect ( 2 ) ; equal ( jQuery ( "#text1" ) . attr ( "value" , function ( ) { return this . id ; } ) [ 0 ] . value , "text1" , "Set value from id" ) ; equal ( jQuery ( "#text1" ) . attr ( "title" , function ( i ) { return i ; } ) . attr ( "title" ) , "0" , "Set value with an index" ) ; }
function ( ) { expect ( 2 ) ; var old = "This link has class=\"blog\": Simon Willison's Weblog" ; jQuery ( "#sap" ) . text ( function ( i , val ) { equal ( val , old , "Make sure the incoming value is correct." ) ; return "foobar" ; } ) ; equal ( jQuery ( "#sap" ) . text ( ) , "foobar" , "Check for merged text of more then one element." ) ; QUnit . reset ( ) ; }
function ( ) { expect ( 4 ) ; jQuery ( "#form" ) . append ( "<input type='checkbox' name='arrayTest' value='1' /><input type='checkbox' name='arrayTest' value='2' /><input type='checkbox' name='arrayTest' value='3' checked='checked' /><input type='checkbox' name='arrayTest' value='4' />" ) ; var elements = jQuery ( "input[name=arrayTest]" ) . val ( [ 1 , 2 ] ) ; ok ( elements [ 0 ] . checked , "First element was checked" ) ; ok ( elements [ 1 ] . checked , "Second element was checked" ) ; ok ( ! elements [ 2 ] . checked , "Third element was unchecked" ) ; ok ( ! elements [ 3 ] . checked , "Fourth element remained unchecked" ) ; elements . remove ( ) ; }
function TestCommand1 ( ) { var command1 = CommandManager . get ( "custom.command1" ) ; if ( ! command1 ) { return ; } var command2 = CommandManager . get ( "custom.command2" ) ; if ( ! command2 ) { return ; } var checked = command1 . getChecked ( ) ; if ( checked ) { alert ( "Unchecking self. Disabling next." ) ; command2 . setEnabled ( false ) ; } else { alert ( "Checking self. Enabling next." ) ; command2 . setEnabled ( true ) ; } command1 . setChecked ( ! checked ) ; }
function ( line , fntFile ) { var value ; value = /id=(\d+)/gi . exec ( line ) [ 1 ] ; cc . Assert ( parseInt ( value ) == 0 , "LabelBMFont file could not be found" ) ; value = /file="([a-zA-Z0-9\-\._]+)/gi . exec ( line ) [ 1 ] ; this . atlasName = cc . FileUtils . fullPathFromRelativeFile ( value , fntFile ) ; }
function ( plistFile ) { var ret = false ; this . _plistFile = plistFile ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( this . _plistFile ) ; cc . Assert ( dict != null , "Particles: file not found" ) ; return this . initWithDictionary ( dict ) ; }
function ( plist ) { cc . Assert ( plist , "Invalid texture file name" ) ; var path = cc . FileUtils . fullPathFromRelativePath ( plist ) ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( path ) ; cc . Assert ( dict , "cc.AnimationCache: File could not be found" ) ; this . addAnimationsWithDictionary ( dict ) ; }
function ( plist ) { var path = cc . FileUtils . fullPathFromRelativePath ( plist ) ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( path ) ; this . _removeSpriteFramesFromDictionary ( dict ) ; if ( cc . ArrayContainsObject ( this . _loadedFileNames , plist ) ) { cc . ArrayRemoveObject ( plist ) ; } }
function getWMBSJobsTotal ( request ) { var aData = _dataByWorkflow [ request ] ; return ( _get ( aData , "status.success" , 0 ) + _get ( aData , "status.cooloff" , 0 ) + _get ( aData , "status.canceled" , 0 ) + failureTotal ( request ) + queuedTotal ( request ) + submittedTotal ( request ) ) ; }
function failureTotal ( request ) { var aData = _dataByWorkflow [ request ] ; return ( _get ( aData , "status.failure.create" , 0 ) + _get ( aData , "status.failure.submit" , 0 ) + _get ( aData , "status.failure.exception" , 0 ) ) ; }
function submittedTotal ( request ) { var aData = _dataByWorkflow [ request ] ; return ( _get ( aData , "status.submit.first" , 0 ) + _get ( aData , "status.submit.retry" , 0 ) ) ; }
function ( ) { this . _super ( ) ; this . _ignoreAnchorPointForPosition = true ; var director = cc . Director . sharedDirector ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . setContentSize ( director . getWinSize ( ) ) ; }
function ( dt ) { this . unschedule ( this . _setNewScene ) ; var director = cc . Director . sharedDirector ( ) ; this . _isSendCleanupToScene = director . isSendCleanupToScene ( ) ; director . replaceScene ( this . _inScene ) ; cc . TouchDispatcher . sharedDispatcher ( ) . setDispatchEvents ( true ) ; this . _outScene . setVisible ( true ) ; }
function ( data ) { $ ( '#tableFieldsId tr:eq(1) td:eq(0)' ) . html ( data . field_type ) ; $ ( '#tableFieldsId tr:eq(1) td:eq(1)' ) . html ( data . field_collation ) ; $ ( '#tableFieldsId tr:eq(1) td:eq(2)' ) . html ( data . field_operators ) ; $ ( '#tableFieldsId tr:eq(1) td:eq(3)' ) . html ( data . field_value ) ; xLabel = $ ( '#tableid_0' ) . val ( ) ; $ ( '#types_0' ) . val ( data . field_type ) ; xType = data . field_type ; $ ( '#collations_0' ) . val ( data . field_collations ) ; }
function ( data ) { $ ( '#tableFieldsId tr:eq(3) td:eq(0)' ) . html ( data . field_type ) ; $ ( '#tableFieldsId tr:eq(3) td:eq(1)' ) . html ( data . field_collation ) ; $ ( '#tableFieldsId tr:eq(3) td:eq(2)' ) . html ( data . field_operators ) ; $ ( '#tableFieldsId tr:eq(3) td:eq(3)' ) . html ( data . field_value ) ; yLabel = $ ( '#tableid_1' ) . val ( ) ; $ ( '#types_1' ) . val ( data . field_type ) ; yType = data . field_type ; $ ( '#collations_1' ) . val ( data . field_collations ) ; }
function ( data ) { $ ( '#tableFieldsId tr:eq(6) td:eq(0)' ) . html ( data . field_type ) ; $ ( '#tableFieldsId tr:eq(6) td:eq(1)' ) . html ( data . field_collation ) ; $ ( '#tableFieldsId tr:eq(6) td:eq(2)' ) . html ( data . field_operators ) ; $ ( '#tableFieldsId tr:eq(6) td:eq(3)' ) . html ( data . field_value ) ; $ ( '#types_2' ) . val ( data . field_type ) ; $ ( '#collations_2' ) . val ( data . field_collations ) ; }
function ( data ) { $ ( '#tableFieldsId tr:eq(8) td:eq(0)' ) . html ( data . field_type ) ; $ ( '#tableFieldsId tr:eq(8) td:eq(1)' ) . html ( data . field_collation ) ; $ ( '#tableFieldsId tr:eq(8) td:eq(2)' ) . html ( data . field_operators ) ; $ ( '#tableFieldsId tr:eq(8) td:eq(3)' ) . html ( data . field_value ) ; $ ( '#types_3' ) . val ( data . field_type ) ; $ ( '#collations_3' ) . val ( data . field_collations ) ; }
function ( ) { var screenWidth = widget . _screenWidth . val ( ) ; widget . _projectDevice . rotating = ! widget . _projectDevice . rotating ; $ . rib . pmUtils . pInfoDirty = true ; widget . _screenWidth . val ( widget . _screenHeight . val ( ) ) ; widget . _screenHeight . val ( screenWidth ) ; widget . _setDevice ( ) ; }
function ( data ) { markerFeatures = new Array ( ) ; $ . each ( data . building , function ( key , val ) { addMarker ( buildingLayer , val . longitude , val . latitude , val . buildingID , val . name ) ; latDestination = val . latitude ; lonDestination = val . longitude ; } ) ; }
function ( ) { var transport = self . transports [ id ] ; if ( self . closed [ id ] && self . closed [ id ] . length && transport ) { if ( transport . open ) { transport . payload ( self . closed [ id ] ) ; self . closed [ id ] = [ ] ; } } }
function ( id ) { if ( this . open [ id ] ) { delete this . open [ id ] ; } this . closed [ id ] = [ ] ; var self = this ; this . store . subscribe ( 'dispatch:' + id , function ( packet , volatile ) { if ( ! volatile ) { self . onClientDispatch ( id , packet ) ; } } ) ; }
function ( file ) { console . log ( timestamp ( ) , '- processing file:       ' , file ) ; if ( ! path . existsSync ( file ) ) { console . log ( 'file: ' , file , ' does not exist.' ) ; switch ( params . file_err ) { case 'break' : console . log ( timestamp ( ) , ' - terminating build.' ) ; return ; case 'continue' : break ; } } src += Templ8 . format ( '\n{0}' , fs . readFileSync ( file , params . encoding ) ) ; }
function Shader_defaultSourceForType ( type ) { var src = '' ; switch ( type ) { case this . context . FRAGMENT_SHADER : src += 'void main(void) { gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);}' ; break ; case this . context . VERTEX_SHADER : src += 'attribute vec3 aVertex;\n' ; src += '\n' ; src += 'uniform mat4 uMVMatrix;\n' ; src += 'uniform mat4 uPMatrix;\n' ; src += 'void main (void) {\n' ; src += '    vec4 v = vec4(aVertex, 1);\n' ; src += '    gl_Position = uPMatrix * uMVMatrix * v;\n' ; src += '}\n' ; break ; default : } return src ; }
function ( path , cb ) { jQuery . ajax ( { type : 'GET' , url : makeURL ( path ) , dataType : 'text' , error : function ( data ) { cb ( data ) ; } , success : function ( data ) { cb ( null , fixDoctypeHeadBodyMunging ( data ) , baseURL + path ) ; } } ) ; }
function ( button , e , options ) { Util . logoutUser ( ) ; var logconfirm = Ext . getCmp ( 'LogoutConfirmPanelID' ) ; logconfirm . hide ( ) ; }
function ( list , index , node , record ) { if ( ! this . showContact ) { this . showContact = Ext . create ( 'RaxaEmr.Outpatient.view.patient.more' ) ; } this . showContact . setRecord ( record ) ; this . getMain ( ) . push ( this . showContact ) ; }
function loadWidget ( manifest ) { require ( [ manifest . WidgetRepositoryURL + "/" + manifest . WidgetName + "/" + manifest . WidgetName + ".js" ] , function ( WidgetModule ) { WidgetModule . load ( manifest , digest ) ; } ) ; }
function ( mnfst , dgst ) { this . manifest = mnfst ; this . digest = dgst ; _ . bindAll ( this ) ; this . init ( ) ; var that = this ; $ ( "#" + mnfst . WidgetName + "-widget-settings" ) . click ( function ( ) { console . log ( "widget settings..." ) ; that . settings ( ) ; } ) ; }
function ( template ) { var html = template . render ( { "manifest" : that . manifest } ) ; App . makeModal ( html ) ; that . loadWidgetSettings ( ) ; }
function ( ) { var that = this ; App . loadMustacheTemplate ( "applications/calendar/tabs/dashboards/dashboardsTabTemplates.html" , "widgetSettings" , function ( template ) { var html = template . render ( { "manifest" : that . manifest } ) ; App . makeModal ( html ) ; that . loadWidgetSettings ( ) ; } ) ; }
function ( ) { var that = this ; require ( [ "text!" + this . manifest . WidgetRepositoryURL + "/" + this . manifest . WidgetName + "/settings.mustache" ] , function ( html ) { var selector = "#" + that . manifest . WidgetName + "-widgetSettings" ; $ ( selector ) . replaceWith ( html ) ; } ) ; }
function ( ) { $ ( '[data-tooltip]' ) . each ( function ( ) { $ ( this ) . tooltip ( { title : $ ( this ) . data ( 'tooltip' ) } ) ; } ) ; }
function ( event ) { var $this = $ ( this ) ; var options = $this . data ( 'alchemy-overlay' ) ; event . preventDefault ( ) ; Alchemy . openWindow ( $this . attr ( 'href' ) , options . title , options . size_x , options . size_y , options . resizable , options . overflow ) ; return false ; }
function next ( ) { S . prev = S . token ; if ( S . peeked ) { S . token = S . peeked ; S . peeked = null ; } else { S . token = S . input ( ) ; } return S . token ; }
function ( ) { ++ S . in_function ; var loop = S . in_loop ; S . in_loop = 0 ; var a = block_ ( ) ; -- S . in_function ; S . in_loop = loop ; return a ; }
function readySite ( data ) { var iframe = $ ( "#" + String ( data . site_id ) ) ; insertHTMLIntoIframe ( data . src , iframe ) ; Notes [ data . site_id ] = data . notes ; }
function remove ( fn ) { if ( this . _removing ) return this ; var promise = this . _removing = new Promise ( fn ) , self = this ; this . collection . remove ( { _id : this . _doc . _id } , tick ( function ( err ) { if ( err ) { this . _removing = null ; return promise . error ( err ) ; } promise . complete ( ) ; self . emit ( 'remove' ) ; } ) ) ; return this ; }
function ( err ) { db . close ( ) ; should . strictEqual ( null , err ) ; zang . _shardval . name . should . equal ( 'Zangief' ) ; zang . _shardval . age . should . equal ( 33 ) ; }
function ( ) { if ( _doc ) { var wrapper = _doc . getElementById ( 'HTMLCS-wrapper' ) ; if ( wrapper ) { _doc . querySelector ( 'body' ) . removeChild ( wrapper ) ; var pointerEl = pointer . pointer ; if ( pointerEl && pointerEl . parentNode ) { pointerEl . parentNode . removeChild ( pointerEl ) ; } if ( _options . closeCallback ) { _messages = _options . closeCallback . call ( this ) ; } } } }
function ( startStopID , goalStopID ) { var closedset = [ ] ; var startNodes = _ . map ( this . routes , function ( r ) { _ ( r . stops ) . filter ( function ( s ) { return s . id === startStopID ; } ) . map ( function ( s ) { return { stop : s , route : r } ; } ) ; } ) ; console . log ( startNodes ) ; var openset = _ . clone ( startNodes ) ; }
function ( ) { if ( ! this . patientView ) { this . patientView = Ext . create ( 'Screener.view.PatientView' ) ; } this . getDoctorList ( ) . deselectAll ( ) ; this . getView ( ) . push ( this . patientView ) ; }
function ( m , x , b , maxExtent ) { var xBoundary ; var candidateY = m * x + b ; if ( candidateY > maxExtent . top ) { xBoundary = ( 90 - b ) / m ; } else if ( candidateY < maxExtent . bottom ) { xBoundary = ( - 90 - b ) / m ; } else { xBoundary = x ; } return new OpenLayers . Geometry . Point ( xBoundary , m * xBoundary + b ) ; }
function ( selected_values ) { var formatted_filters = [ { 'entity' : { 'expression' : this . model . get ( 'grouping_entity' ) . expression } , 'op' : '>=' , 'value' : selected_values [ 'selection_min' ] } , { 'entity' : { 'expression' : this . model . get ( 'grouping_entity' ) . expression } , 'op' : '<=' , 'value' : selected_values [ 'selection_max' ] } ] ; return formatted_filters ; }
function ( val , key ) { if ( key == '_id' ) { return ; } if ( _ . isUndefined ( this_ . get ( key ) ) ) { this_ . _add_property_models ( model , val ) ; } else { this_ . trigger ( "change" , p ) ; } }
function ( structure , value ) { for ( var i in structure ) { if ( structure . hasOwnProperty ( i ) ) { structure [ i ] . _canEdit = value ; structure [ i ] . _canSubedit = value ; } } return structure ; }
function ( pagestructure ) { pagestructure = sakai . api . Server . cleanUpSakaiDocObject ( pagestructure ) ; pagestructure . structure0 = setManagerProperty ( pagestructure . structure0 , sakai_global . content_profile . content_data . isManager ) ; if ( getPageCount ( pagestructure ) >= 3 ) { setColumnLayout ( true , true ) ; } else { setColumnLayout ( true , false ) ; } globalPageStructure = pagestructure ; generateNav ( pagestructure ) ; }
function ( ) { if ( sakai . config . enableCategories ) { sakai . api . Util . TemplateRenderer ( $ ( "#explore_categories_template" ) , { } , $ ( "#explore_categories" ) ) ; } }
function ( ) { self . _createDraftComment ( ) ; gCommentDlg . setDraftComment ( self . draftComment ) . setCommentsList ( self . comments , "comment" ) . css ( { left : $ ( document ) . scrollLeft ( ) + ( $ ( window ) . width ( ) - gCommentDlg . width ( ) ) / 2 , top : self . endRow . offset ( ) . top + self . endRow . height ( ) } ) . open ( self . el ) ; }
function ( ) { var alt_error = this . navControllerOutput . get ( 'alt_error' ) ; var aspd_error = this . navControllerOutput . get ( 'aspd_error' ) ; if ( Math . abs ( alt_error ) > 0 ) { this . pfd . setTargetAltitude ( this . vfrHud . get ( 'alt' ) + alt_error ) ; } if ( Math . abs ( aspd_error ) > 0 ) { this . pfd . setTargetAltitude ( this . vfrHud . get ( 'airspeed' ) + aspd_error ) ; } }
function ( ) { $ . get ( '/player/' , function ( data , textStatus , jqXHR ) { if ( data . status ) { $ ( '#current' ) . append ( data . response . html ) ; } else { $ ( '#current' ) . load ( 'not-connected.html' ) ; } } ) ; $ ( '#controls button' ) . click ( function ( ) { $ . get ( '/player/' + this . id , function ( data , textStatus , jqXHR ) { } ) ; } ) ; }
function onmessage ( msg ) { var result = { } ; msg = IPC . decode ( msg ) ; if ( msg && msg . type && this . _events [ msg . type ] ) { this . emit ( msg . type , msg . msg , result ) ; } return IPC . encode ( 'result' in result ? result . result : result ) ; }
function cell_delete ( id ) { if ( $ . inArray ( id , queue_id_list ) !== - 1 ) { async_request ( worksheet_command ( 'interrupt' ) ) ; } async_request ( worksheet_command ( 'delete_cell' ) , cell_delete_callback , { id : id } ) ; }
function cell_delete_output ( id ) { id = toint ( id ) ; if ( $ . inArray ( id , queue_id_list ) !== - 1 ) { async_request ( worksheet_command ( 'interrupt' ) ) ; } async_request ( worksheet_command ( 'delete_cell_output' ) , cell_delete_output_callback , { id : id } ) ; }
function ( ) { t . deepEqual ( Array . from ( arguments ) , [ "say" , "hello" ] , "args error" ) ; t . deepEqual ( this , { iamthis : "root" } , "args error" ) ; t . end ( ) ; } . args ( [ "say" , "hello" ] , { iamthis : "root" }
function ( ) { t . deepEqual ( Array . from ( arguments ) , [ "say" , "hello" , "thidparam!" ] , "args error" ) ; t . deepEqual ( this , { iamthis : "root" } , "args error" ) ; t . end ( ) ; } . args ( [ "say" , "hello" ] , { iamthis : "root" }
function ( ) { t . deepEqual ( Array . from ( arguments ) , [ "dont mind your args" ] , "args error" ) ; t . deepEqual ( this , { iamthis : "root" } , "args error" ) ; t . end ( ) ; } . pass ( [ "dont mind your args" ] , { whoami : "root" }
function ( s , el ) { try { with ( this . datamodel ) { return eval ( s ) } } catch ( e ) { this . internalQueue . push ( new SCxml . Error ( "error.execution" , el , e ) ) throw e } }
function ( target , event ) { console . log ( "sending a " + event . name + " event to " + target ) var sid if ( ( sid = target . match ( /^#_scxml_(.+)$/ ) ) && ( sid = sid [ 1 ] ) ) { if ( sid in SCxml . sessions && SCxml . sessions [ sid ] ) SCxml . sessions [ sid ] . onEvent ( event ) else throw "target SCXML session doesn't exist" } else { } }
function ( ) { for ( var td in this . tds ) this . tds [ td ] . children ( ) . remove ( ) ; this . tds . boardTd . append ( this . boardDiv ) ; this . tds . pgnTd . append ( this . pgnDiv ) ; this . tds . descriptionsTd . append ( this . descriptionsDiv ) ; }
function getDefaultComponent ( req ) { return { type : req . body . type , layout : req . body . layout , action : req . body . action } ; }
function getDefaultElement ( req ) { return { type : req . body . type , head : req . body . head , nextId : req . body . nextId , name : req . body . name , required : req . body . required || false , src : req . body . src , text : req . body . text , level : req . body . level } ; }
function validateProject ( req , beingCreated ) { var title = req . body . title ; if ( ! title || title . length === 0 ) { return 'Project must have a title.' ; } else if ( title . length > 25 ) { return 'Project must have a title less than 25 characters long.' ; } return true ; }
function validateScreen ( req , beingCreated ) { var title = req . body . title ; if ( ! title || title . length === 0 ) { return 'Screen must have a title.' ; } else if ( title . length > 25 ) { return 'Screen must have a title less than 25 characters long.' ; } return true ; }
function ( ) { var title = this . $input . val ( ) . trim ( ) ; var that = this ; this . model . save ( { title : title } , { error : tooltipErrorHandler ( this . $input ) , success : function ( model ) { that . $el . removeClass ( 'editing' ) ; } } ) ; }
function ( $component , type ) { $component . removeClass ( type + '-container' ) ; $component . removeClass ( 'active' ) ; $component . addClass ( 'empty' ) ; $component . empty ( ) ; }
function ( event ) { if ( $ ( 'input[type="text"]:focus, textarea:focus' ) . length === 0 ) { if ( event . which === 8 && this . layoutView . $activeElement ) { this . layoutView . trigger ( 'removeElement' ) ; event . preventDefault ( ) ; } if ( event . which === 27 ) { this . layoutView . resetActiveElement ( ) ; } } }
function ( e ) { var val = $ ( '#searchfield' ) . val ( ) ; if ( val != '' ) { search_string = '' ; $ ( '#searchfield' ) . val ( search_string ) ; $ ( '#searchfield' ) . trigger ( 'input' ) ; } }
function ( e ) { var val = $ ( '#searchfield' ) . val ( ) ; var fullname = $ ( item ) . data ( 'fullname' ) ; if ( val != '' ) { search_string = '' ; } else { search_string = fullname ; } $ ( '#searchfield' ) . val ( search_string ) ; $ ( '#searchfield' ) . trigger ( 'input' ) ; }
function set_number_of_reps ( number_of_reps ) { $ ( '#profiles-number-of-reps' ) . html ( number_of_reps ) ; if ( number_of_reps === 1 ) { $ ( '#profiles-number-of-reps-plural' ) . html ( '' ) ; } else { $ ( '#profiles-number-of-reps-plural' ) . html ( 's' ) ; } }
function ( name , data ) { var design = this . getDesign ( ) ; if ( ! design ) { console . warn ( "Warning: no root design found to fire model event" ) ; return ; } design . fireEvent ( name , data ) ; }
function ( ) { var title = strip ( $ ( this ) . find ( '.info li:nth-child(2)' ) . html ( ) ) ; title = title . replace ( "Song: " ) ; var artist = $ ( this ) . find ( ".bucketblock h4" ) . text ( ) ; Playgrub . playlist . add_track ( artist , title ) ; }
function ( positionIndex , axisId , value ) { if ( this . matrix [ positionIndex ] == null ) this . matrix [ positionIndex ] = [ ] ; this . matrix [ positionIndex ] [ axisprefix + axisId ] = value ; for ( var i = 1 ; i < positionIndex ; i ++ ) { if ( this . matrix [ i ] == null ) this . matrix [ i ] = [ ] ; } }
function ( el , ev ) { this . options . andVor . attr ( "andVor" , el . val ( ) ) ; CourseData . workspace . attr ( "display.andVor" , el . val ( ) ) ; }
function squashTokens ( tokens ) { var lastToken ; for ( var i = 0 ; i < tokens . length ; ++ i ) { token = tokens [ i ] ; if ( lastToken && lastToken . type === "text" && token . type === "text" ) { lastToken . value += token . value ; tokens . splice ( i -- , 1 ) ; } else { lastToken = token ; } } }
function getUrlParts ( url ) { var parts = url . split ( '/' ) ; var baseAndParams = parts . pop ( ) . split ( '?' ) ; var basename = baseAndParams . shift ( ) . toLowerCase ( ) ; var fileAndFragment = basename . split ( '#' ) ; var filename = fileAndFragment . shift ( ) ; var fragment = fileAndFragment . pop ( ) ; return { filename : filename , fragment : fragment } ; }
function getIdentifiersFromUrl ( url ) { var urlParts = getUrlParts ( url ) ; var identifiers = [ urlParts . filename . split ( '.' ) . pop ( ) ] ; if ( urlParts . fragment ) { var args = urlParts . fragment . split ( '=' ) , i ; if ( ( i = args . indexOf ( 'sight' ) ) > - 1 ) { identifiers . unshift ( args [ i + 1 ] ) ; } } return identifiers ; }
function ( error , job_in_progress ) { if ( error ) { console . log ( util . inspect ( error , false , 7 , true ) ) ; return ; } if ( job_in_progress ) { self . _status = "processing" ; self . _processing = job_in_progress ; self . _heartbeats = 0 ; job_in_progress . o && self . _broadcast ( job_in_progress . o , { "command" : "processJob" , "params" : job_in_progress } ) ; } printHeartbeat ( ) ; }
function ( error , upd ) { if ( error ) { console . log ( util . inspect ( error , false , 7 , true ) ) ; return ; } console . log ( "[processing] job " + job . _id . toString ( ) ) ; self . _status = "processing" ; self . _processing = upd ; upd . o && self . _broadcast ( upd . o , { "command" : "processJob" , "params" : upd } ) ; }
function ( error , documents ) { if ( error ) { console . log ( util . inspect ( error , false , 7 , true ) ) ; return callback && callback ( ) ; } self . _broadcast ( owner , { "command" : "scheduledJob" , "params" : ( documents && documents [ 0 ] ) || { } } ) ; return callback && callback ( ) ; }
function ( error ) { if ( error ) { console . log ( error . message ) ; console . log ( error . stack ) ; console . log ( util . inspect ( error , false , 7 , true ) ) ; return ; } }
function ( resolverName , name , options ) { var deferred , resolver ; deferred = when . defer ( ) ; if ( resolverName ) { resolver = this . _resolvers [ resolverName ] ; if ( resolver ) { resolver ( deferred . resolver , name , options || { } , this . _pluginApi ) ; } else { deferred . reject ( "No resolver plugin found: " + resolverName ) ; } } else { deferred . reject ( "Cannot resolve ref: " + name ) ; } return deferred . promise ; }
function ( id , offset , span , color ) { if ( id === '<definitions>' ) { this . defn . highlight ( id , offset , span , color ) ; } else if ( this . interactions . previousInteractionsTextContainers [ id ] ) { this . interactions . previousInteractionsTextContainers [ id ] . highlight ( id , offset , span , color ) ; } }
function ( index ) { if ( repeatmodel [ index - 1 ] . First . value !== "" ) { var insert = mvc . newStatefulModel ( { "data" : { "First" : "" , "Last" : "" , "Location" : "CA" , "Office" : "" , "Email" : "" , "Tel" : "" , "Fax" : "" } } ) ; repeatmodel . add ( index , insert ) ; setDetailsContext ( index ) ; nextIndexToAdd ++ ; } else { setDetailsContext ( index - 1 ) ; } }
function InspectorExtensionAPI ( ) { this . audits = new Audits ( ) ; this . inspectedWindow = new InspectedWindow ( ) ; this . panels = new Panels ( ) ; this . network = new Network ( ) ; defineDeprecatedProperty ( this , "webInspector" , "resources" , "network" ) ; this . timeline = new Timeline ( ) ; this . console = new ConsoleAPI ( ) ; this . onReset = new EventSink ( events . Reset ) ; }
function ( origin , port ) { if ( ! this . _registeredExtensions . hasOwnProperty ( origin ) ) { if ( origin !== window . location . origin ) console . error ( "Ignoring unauthorized client request from " + origin ) ; return ; } port . _extensionOrigin = origin ; port . addEventListener ( "message" , this . _onmessage . bind ( this ) , false ) ; port . start ( ) ; }
function ( timestamp ) { if ( typeof timestamp === 'number' ) { console . log ( 'PASS low-level event' ) ; } else { console . error ( 'FAIL wrong argument to loadEventFired' ) ; } chrome . devtools . remoteDebug . removeDomainListener ( 'Page' , domainListener ) ; testHighLevel ( ) ; }
function ( story ) { var visible = story . score ( ) >= score ; var same_story = include_active_story && story . id == active_story_id ; var read = ! ! story . get ( 'read_status' ) ; return visible && ( ! read || same_story ) ; }
function ( left ) { if ( this . id && this . has_children ) { this . span = this . build_link ( $ ( document . createElement ( 'span' ) ) ) ; this . span . css ( 'left' , left + 'px' ) ; } return this . span ; }
function ( left ) { if ( this . id && this . title ) { this . link = this . build_link ( $ ( document . createElement ( 'a' ) ) ) ; this . link . css ( 'marginLeft' , left + 'px' ) . text ( this . title ) ; } return this . link ; }
function ( left ) { if ( this . id && this . has_children ) { this . span = this . build_link ( $ ( document . createElement ( 'span' ) ) ) ; this . span . css ( 'left' , left + 'px' ) ; } return this . span ; }
function ( left ) { if ( this . id && this . title ) { this . link = this . build_link ( $ ( document . createElement ( 'a' ) ) ) ; this . link . css ( 'marginLeft' , left + 'px' ) . text ( this . title ) ; } return this . link ; }
function ( data , state ) { var sanitizedData , specs ; if ( state !== apf . SUCCESS ) { return ; } sanitizedData = data . replace ( /^\./gm , "" ) ; sanitizedData = sanitizedData . replace ( /^\/node_modules\/.*/gm , "" ) ; specs = sanitizedData . match ( /^.*\.spec\.(js|coffee)$/gm ) ; return _this . addFiles ( specs , modelTestsJasmine . queryNode ( "repo[1]" ) ) ; }
function ( options ) { if ( this != navigator . id ) throw new Error ( "all navigator.id calls must be made on the navigator.id object" ) ; options = options || { } ; checkCompat ( false ) ; return internalRequest ( options ) ; }
function fixture ( options ) { "use strict" ; var square = this ; square . emit ( 'plugin.fixture:init' , options , this ) ; return function middleware ( output , next ) { square . emit ( 'plugin.fixture:call' , output , this ) ; next ( ) ; } ; }
function callCallbacks ( cb , err ) { for ( var i = 0 ; i < cb . length ; i ++ ) { if ( err ) cb [ i ] ( err ) ; else cb [ i ] ( null , cachedViews [ filename ] ) ; } }
function ( e , t ) { if ( t . fields [ e . id ] . ajaxValues ) { Traveler . prototype . showFieldValues ( e . value , t , e . id ) ; } }
function ( aState , details , pos , args ) { if ( aState === undefined || ( positionStack [ positionStack . length - 1 ] === undefined ) ) { throwUncoloredCheckError ( aState , details , pos , args ) ; } else { throwColoredCheckError ( aState , details , pos , args ) ; } }
function ( aState , details , pos , args ) { if ( aState === undefined || ( positionStack [ positionStack . length - 1 ] === undefined ) ) { throwUncoloredCheckError ( aState , details , pos , args ) ; } else { throwColoredCheckError ( aState , details , pos , args ) ; } }
function ( ) { var args = argsNet ; argsNet = undef ; if ( def . useNet !== false ) { if ( ! args || args . ex ) { def . reject ( new Error ( ( args . ex || 'define() missing or duplicated: url' ) . replace ( 'url' , def . url ) ) ) ; } else { core . resolveResDef ( def , args ) ; } } }
function ( ) { log . history = log . history || [ ] ; log . history . push ( arguments ) ; arguments . callee = arguments . callee . caller ; if ( this . console ) console . log ( Array . prototype . slice . call ( arguments ) ) ; }
function ( ) { if ( lastMuted !== youtubeObject . isMuted ( ) ) { lastMuted = youtubeObject . isMuted ( ) ; media . dispatchEvent ( "volumechange" ) ; } if ( lastVolume !== youtubeObject . getVolume ( ) ) { lastVolume = youtubeObject . getVolume ( ) ; media . dispatchEvent ( "volumechange" ) ; } setTimeout ( volumeupdate , 250 ) ; }
function ( val ) { if ( val != 0 || options . cue_in == 0 ) { currentTime = seekTime = + val ; seeking = true ; media . dispatchEvent ( "seeked" ) ; media . dispatchEvent ( "timeupdate" ) ; youtubeObject . seekTo ( currentTime ) ; } else if ( val == 0 && options . cue_in == 0 ) { media . dispatchEvent ( "timeupdate" ) ; } return currentTime ; }
function ( val ) { if ( youtubeObject . isMuted ( ) !== val ) { if ( val ) { youtubeObject . mute ( ) ; } else { youtubeObject . unMute ( ) ; } lastMuted = youtubeObject . isMuted ( ) ; media . dispatchEvent ( "volumechange" ) ; } return youtubeObject . isMuted ( ) ; }
function ( val ) { if ( youtubeObject . getVolume ( ) / 100 !== val ) { youtubeObject . setVolume ( val * 100 ) ; lastVolume = youtubeObject . getVolume ( ) ; media . dispatchEvent ( "volumechange" ) ; } return youtubeObject . getVolume ( ) / 100 ; }
function ensureModuleTemplates ( context ) { if ( ! moduleStartTemplate ) { moduleStartTemplate = Handlebars . compile ( context . config . attributes . moduleStartTemplate || DEFAULT_MODULE_START_TEMPLATE ) ; } if ( ! moduleEndTemplate ) { moduleEndTemplate = Handlebars . compile ( context . config . attributes . moduleEndTemplate || DEFAULT_MODULE_END_TEMPLATE ) ; } }
function ensureTemplateTemplates ( context ) { if ( ! templateTemplate ) { templateTemplate = Handlebars . compile ( context . config . attributes . templateTemplate || DEFAULT_TEMPLATE_TEMPLATE ) ; } if ( ! precompiledTemplate ) { precompiledTemplate = Handlebars . compile ( context . config . attributes . precompiledTemplate || PRECOMPILED_TEMPLATE ) ; } }
function ( ) { var pDirector = cc . Director . sharedDirector ( ) ; pDirector . setDisplayFPS ( true ) ; pDirector . setAnimationInterval ( 1.0 / 60 ) ; var pScene = Game . scene ( ) ; pDirector . runWithScene ( pScene ) ; return true ; }
function ( pSender ) { var scene = cc . Scene . create ( ) ; scene . addChild ( SysMenu . create ( ) ) ; cc . Director . sharedDirector ( ) . replaceScene ( cc . TransitionFade . create ( 1.2 , scene ) ) ; }
function removeTodoById ( id ) { var i , l ; for ( i = 0 , l = todos . length ; i < l ; i ++ ) { if ( todos [ i ] . id === id ) { todos . splice ( i , 1 ) ; } } }
function ( full , script ) { var flashvars = exports . stripFlashvars ( script ) ; if ( ! flashvars ) return full ; console . log ( flashvars ) ; var flvurl = flashvars . url_encoded_fmt_stream_map . url ; flashvars . flvurl = 'https://ssl.nowall.be' + utils . encodeSymboUrl ( flvurl ) ; return template . render ( player , flashvars ) ; }
function dragstart ( e ) { e . dataTransfer . effectAllowed = "copy" ; var realtarget = $ ( e . target ) . closest ( ".tracker-div" ) ; e . dataTransfer . setData ( "Text" , realtarget . attr ( "id" ) ) ; }
function drop ( e ) { e . preventDefault ( ) ; var realtarget = $ ( e . target ) . closest ( ".tracker-div" ) ; var data = e . dataTransfer . getData ( "Text" ) ; console . log ( "Dropped on " + realtarget . attr ( "id" ) + ", with data: " + data ) ; }
function ( battle , source , effect ) { if ( effect && effect . effectType === 'Ability' ) { this . effectData . duration = 0 ; this . add ( '-weather' , 'RainDance' , '[from] ability: Drizzle' , '[of] ' + source ) ; } else { this . add ( '-weather' , 'RainDance' ) ; } }
function ( battle , source , effect ) { if ( effect && effect . effectType === 'Ability' ) { this . effectData . duration = 0 ; this . add ( '-weather' , 'SunnyDay' , '[from] ability: Drought' , '[of] ' + source ) ; } else { this . add ( '-weather' , 'SunnyDay' ) ; } }
function ( battle , source , effect ) { if ( effect && effect . effectType === 'Ability' ) { this . effectData . duration = 0 ; this . add ( '-weather' , 'Sandstorm' , '[from] ability: Sand Stream' , '[of] ' + source ) ; } else { this . add ( '-weather' , 'Sandstorm' ) ; } }
function ( battle , source , effect ) { if ( effect && effect . effectType === 'Ability' ) { this . effectData . duration = 0 ; this . add ( '-weather' , 'Hail' , '[from] ability: Snow Warning' , '[of] ' + source ) ; } else { this . add ( '-weather' , 'Hail' ) ; } }
function ( damage , attacker , defender , effect ) { var GossamerWingUsers = { "Butterfree" : 1 , "Masquerain" : 1 , "Beautifly" : 1 , "Mothim" : 1 } ; if ( GossamerWingUsers [ defender . template . species ] ) { if ( effect && effect . id === 'stealthrock' ) { return damage / 2 ; } } }
function ( doc , width , height ) { var html = serializeToXML ( doc ) , imgWidth = width || 100 , imgHeight = height || 100 ; return ( '<svg xmlns="http://www.w3.org/2000/svg" width="' + imgWidth + '" height="' + imgHeight + '">' + '<foreignObject width="100%" height="100%">' + html + '</foreignObject>' + '</svg>' ) ; }
function ( playerColor , number , channel ) { color = playerColor ; playerNumber = number ; channelNumber = channel ; socket . on ( 'ready' , function ( ready ) { time = new Date ( ) ; logTime ( time ) ; log += " level " + level + " started" ; Crafty . scene ( "main" ) ; } ) ; }
function ( xpos , ypos ) { placeBox ( xpos , ypos ) ; if ( blocksPlaced . length > 3 ) { blocksPlaced [ 0 ] . destroy ( ) ; blocksPlaced = blocksPlaced . slice ( 1 ) ; } currentTime = new Date ( ) ; logTime ( currentTime ) ; log += " block placed at (" + xpos + "," + ypos + ")" }
function ( key ) { if ( key . which == 13 ) { var message = [ $ ( '#msg' ) . val ( ) , channelNumber ] ; $ ( '#msg' ) . val ( '' ) ; socket . emit ( 'sendMessage' , message ) ; } }
function ( message ) { $ ( "#data_received" ) . append ( "<br /> \r\n" + message ) ; currentTime = new Date ( ) ; logTime ( currentTime ) ; log += " " + message ; var objDiv = document . getElementById ( "data_received" ) ; objDiv . scrollTop = objDiv . scrollHeight ; }
function ( key ) { if ( key . which == 13 ) { var message = [ $ ( '#msg' ) . val ( ) , channelNumber ] ; $ ( '#msg' ) . val ( '' ) ; socket . emit ( 'sendMessage' , message ) ; } }
function ( ) { currentTime = new Date ( ) ; logTime ( currentTime ) ; log += " Winner" ; if ( playerNumber == 1 ) { socket . emit ( "log" , log ) ; } Crafty . background ( '#000' ) ; message = Crafty . e ( "2D, DOM, Text" ) . attr ( { w : 400 , h : 20 , x : 200 , y : 390 } ) . text ( "!!!!   YOU WIN   !!!!" ) . css ( { "text-align" : "center" } ) ; }
function ( ) { this . pending = [ ] ; this . promises = [ ] ; this . timeout = setTimeout ( noop , 1e13 ) ; this . monitor = createPromise . monitor && createPromise . monitor ( ) ; }
function ( params ) { params = params || { } ; this . mode = null ; this . truncate = false ; this . templato = params . templato ; this . afterLoaded = params . afterLoaded ; this . source = '' ; this . markup = undefined ; this . templateText = params . text || this . getTemplateTextFromNode ( params . node ) ; if ( typeof this . templateText == 'undefined' ) { this . getTemplateTextFromUrl ( params ) ; } }
function ( index , value ) { var search = new RegExp ( input_value , 'gi' ) ; if ( value . txt . match ( search ) ) { info . data . search_values [ index ] = { 'val' : value . val , 'txt' : value . txt } ; } }
function ( ) { cur_index = $ ( this ) . attr ( 'data-index' ) ; info . data . values [ cur_index ] = { 'val' : info . data . orig_select [ cur_index ] . val , 'txt' : info . data . orig_select [ cur_index ] . txt } ; }
function Identifier ( node , resolve ) { if ( resolve === undefined ) resolve = true ; return function ( locals , env , data ) { var entry = env [ node . name ] ; if ( entry . get && resolve ) return entry . get ( env , data ) ; return entry ; } ; }
function ( locals , env , data , index ) { var i = index . shift ( ) ; if ( typeof i == 'function' ) i = i ( locals , env , data ) ; try { return content [ i ] ( locals , env , data , index ) ; } catch ( e ) { return content [ defaultIndex ] ( locals , env , data , index ) ; } }
function ( locals , env , data , index ) { var key = index . shift ( ) ; if ( typeof key == 'function' ) key = key ( locals , env , data ) ; try { return content [ key ] ( locals , env , data , index ) ; } catch ( e ) { return content [ defaultKey ] ( locals , env , data , index ) ; } }
function ( elem ) { parts . push ( elem ( locals , env , data ) ) ; }
function UnaryOperator ( token ) { if ( token == '-' ) return function ( operand ) { return - operand ; } ; if ( token == '+' ) return function ( operand ) { return + operand ; } ; if ( token == '!' ) return function ( operand ) { return ! operand ; } ; }
function ( locals , env , data ) { return expression ( locals , env , data , property ) ; }
function ( env , data ) { var attrs = { } ; for ( var i in this . attributes ) { var attr = this . attributes [ i ] ; attrs [ attr . id ] = attr . get ( { __this__ : this } , env , data ) ; } return attrs ; }
function compile ( ast , obj ) { for ( var i = 0 , elem ; elem = ast [ i ] ; i ++ ) { if ( elem . type == 'entity' ) obj [ elem . id ] = new Entity ( elem ) ; else if ( elem . type == 'macro' ) obj [ elem . id ] = new Macro ( elem ) ; } }
function ( data ) { if ( data . success === 1 ) { app . fireEvent ( 'deleteList' , list ) ; app . dom . show ( app . dom . get ( 'showable' , 'delete-list-twipsy' ) ) ; app . dom . hide ( app . dom . get ( 'showable' , 'delete-list-window' ) ) ; } else { } }
function ( ) { var shards = 6 , branchName = $ ( this ) . html ( ) , $ol = $ ( '<ol></ol>' ) ; for ( var index = 1 ; index <= shards ; index ++ ) { $ ( '<li>Checking...</li>' ) . appendTo ( $ol ) . jenGit ( { url : "http://builder.soundcloud.com/job/soundcloud_" + branchName + "_specs_00" + index + "/lastBuild/api/json" } ) ; } $ ( ".content-body.markdown-body.markdown-format:first" ) . append ( $ ( '<div class="jengit"><b>Tests:</b></div>' ) . append ( $ol ) ) ; }
function postInject ( ) { prepareSite ( ) ; if ( ! testMode || ! Khan . query . problem ) { var problems = exercises . children ( ".problems" ) . children ( ) ; weighExercises ( problems ) ; problemBag = makeProblemBag ( problems , 10 ) ; } var answerType = makeProblem ( ) ; maybeEnqueueReviewProblems ( ) ; }
function ( entries ) { var start = + new Date ( ) ; loop ( async , function ( index ) { return entries [ index ] . remove ( ) ; } , limit ) . then ( function ( ) { ret . callback ( ( + new Date ) - start ) ; } , comb . hitch ( ret , "errback" ) ) ; }
function ( header , module , limit , durations ) { console . log ( header ) ; var msg = "%-15s (%02s runs): Average duration % 8dms for %d items" ; for ( var testName in durations ) { if ( testName != "total" ) { console . log ( format ( msg , testName , durations . total , durations [ testName ] / durations . total ) , limit ) ; } } module . disconnect ( ) ; }
function ( fname ) { var ext = path . extname ( fname ) , fileDir = path . dirname ( fname ) . replace ( o . inputDir , '' ) ; paths . push ( { input : fname , output : path . join ( o . outputDir , fileDir , path . basename ( fname , ext ) + o . outputExt ) } ) ; }
function ( dir , mode ) { mode = mode || '0777' ; var paths = dir . split ( '/' ) , prev = '' , cur ; for ( var i = 0 , n = paths . length ; i < n ; i += 1 ) { cur = path . join ( prev , paths [ i ] ) ; if ( ! path . existsSync ( cur ) ) { fs . mkdirSync ( cur , mode ) ; } prev = cur ; } }
function ( ) { var cur_id = find_dir_index ( $ ( this ) . attr ( 'id' ) ) ; var initial_dir = $ ( "#new_root_dir_" + cur_id ) . val ( ) ; $ ( this ) . nFileBrowser ( edit_root_dir , { initialDir : initial_dir , which_id : cur_id } ) ; }
function reffedValue ( deref ) { var tmp ; if ( ! deref ) { return this ; } else { tmp = this ; if ( this . unmemoized ) { console . log ( "DEREF: " + this . main + "()  [" + this . unmemoized + "()]" ) ; } return tmp . copyWith ( "" + tmp . main + "()" ) ; } }
function ( ) { var ast ; ast = LZ . getNthBody ( ( LZ . parseFull ( '\\pairF . \\l1 . \\l2 . pairF (head l1) (_append pairF (tail l1) l2)' ) ) [ 0 ] , 4 ) ; console . log ( "TEST 34, AST: " + ( Parse . print ( ast ) ) ) ; return assertEq ( LZ . primGen ( ast , 0 , ast , new LZ . Code ( ) , null , arrayToCons ( [ '_append' , 'pairF' , 'tail' , 'l1' , 'l2' ] ) , true , 'test' , "Parse." , true ) . main , "_pairF()((function(){var $m; return (function(){return $m || ($m = (_head()(_l1)))})})())((function(){var $m; return (function(){return $m || ($m = (__append()(_pairF)((function(){var $m; return (function(){return $m || ($m = (_tail()(_l1)))})})())(_l2)))})})())" ) ; }
function ( scene , dynamicObjectCollection ) { if ( typeof scene === 'undefined' ) { throw new DeveloperError ( 'scene is required.' ) ; } this . _scene = scene ; this . _unusedIndexes = [ ] ; this . _primitives = scene . getPrimitives ( ) ; this . _polylineCollection = [ ] ; this . _dynamicObjectCollection = undefined ; this . setDynamicObjectCollection ( dynamicObjectCollection ) ; }
function ( dynamicObjectCollection , dynamicObjects ) { var thisPolylineCollection = this . _polylineCollection ; var thisUnusedIndexes = this . _unusedIndexes ; for ( var i = dynamicObjects . length - 1 ; i > - 1 ; i -- ) { var dynamicObject = dynamicObjects [ i ] ; var polylineVisualizerIndex = dynamicObject . _polylineVisualizerIndex ; if ( typeof polylineVisualizerIndex !== 'undefined' ) { var polyline = thisPolylineCollection [ polylineVisualizerIndex ] ; polyline . show = false ; thisUnusedIndexes . push ( polylineVisualizerIndex ) ; dynamicObject . _polylineVisualizerIndex = undefined ; } } }
function ( ) { var dynamicObjectCollection = new DynamicObjectCollection ( ) ; visualizer = new DynamicPolylineVisualizer ( scene , dynamicObjectCollection ) ; expect ( visualizer . getScene ( ) ) . toEqual ( scene ) ; expect ( visualizer . getDynamicObjectCollection ( ) ) . toEqual ( dynamicObjectCollection ) ; expect ( scene . getPrimitives ( ) . getLength ( ) ) . toEqual ( 0 ) ; }
function ( selector , interval , repeat , delay ) { interval = interval || 0 ; cc . Assert ( selector , "Argument must be non-nil" ) ; cc . Assert ( interval >= 0 , "Argument must be positive" ) ; repeat = repeat || cc . REPEAT_FOREVER ; delay = delay || 0 ; this . _scheduler . scheduleSelector ( selector , this , interval , ! this . _isRunning , repeat , delay ) ; }
function ( ) { this . _super ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . _ignoreAnchorPointForPosition = true ; var director = cc . Director . sharedDirector ( ) ; if ( ! director ) { return false ; } this . setContentSize ( director . getWinSize ( ) ) ; this . _isTouchEnabled = false ; this . _isAccelerometerEnabled = false ; }
function ( ) { this . _ignoreAnchorPointForPosition = true ; var director = cc . Director . sharedDirector ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . setContentSize ( director . getWinSize ( ) ) ; }
function ( cleanup ) { if ( this . _usesBatchNode ) { if ( this . _children != null ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { if ( this . _children [ i ] instanceof cc . Sprite ) { this . _batchNode . removeSpriteFromAtlas ( this . _children [ i ] ) ; } } } } this . _super ( cleanup ) ; this . _hasChildren = false ; }
function ( value ) { this . _dirty = this . _recursiveDirty = value ; if ( this . _children != null ) { for ( var i in this . _children ) { if ( this . _children [ i ] instanceof cc . Sprite ) { this . _children [ i ] . setDirtyRecursively ( true ) ; } } } }
function ( newFrame ) { this . setNodeDirty ( ) ; this . _unflippedOffsetPositionFromCenter = newFrame . getOffsetInPixels ( ) ; var pNewTexture = newFrame . getTexture ( ) ; if ( pNewTexture != this . _texture ) { this . setTexture ( pNewTexture ) ; } this . _rectRotated = newFrame . isRotated ( ) ; if ( this . _rectRotated ) this . setRotation ( - 90 ) ; this . setTextureRectInPixels ( newFrame . getRectInPixels ( ) , newFrame . isRotated ( ) , newFrame . getOriginalSizeInPixels ( ) ) ; }
function ( animationName , frameIndex ) { cc . Assert ( animationName , "" ) ; var a = cc . AnimationCache . sharedAnimationCache ( ) . animationByName ( animationName ) ; cc . Assert ( a , "" ) ; var frame = a . getFrames ( ) [ frameIndex ] ; cc . Assert ( frame , "" ) ; this . setDisplayFrame ( frame ) ; }
function ( ) { if ( cc . renderContextType == cc . CANVAS ) { return cc . SpriteFrame . _frameWithTextureForCanvas ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSize ) ; } else { return cc . SpriteFrame . create ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSize ) ; } }
function ( spriteFrame ) { var sprite = new cc . Sprite ( ) ; if ( sprite && sprite . initWithSpriteFrame ( spriteFrame ) ) { return sprite ; } return null ; }
function ( base ) { if ( base . el . tagName === 'INPUT' ) { return false ; } base . insertText ( '\t' ) ; }
function ( os_path ) { return [ os_path + '/lib/vendor/base64.js' , os_path + '/lib/boot.js' , os_path + '/lib/vendor/accounting.js' , os_path + '/lib/utils/utils.js' , os_path + '/lib/aggregator.js' , os_path + '/lib/vendor/bubbletree/2.0/bubbletree.js' , os_path + '/lib/vendor/vis4.js' , os_path + '/lib/vendor/Tween.js' , os_path + '/lib/vendor/jquery.history.js' , os_path + '/lib/vendor/bubbletree/1.0/bubbletree.css' , os_path + '/lib/vendor/datatables/js/jquery.dataTables.js' , os_path + '/lib/vendor/datatables/dataTables.bootstrap.js' , os_path + '/app/data_table/openspending.data_table.js' , 'css/map.css' , '/img/functions/functions.js' , '/js/bubblemap.js' ] ; }
function ( msgid ) { if ( window . json_locale_data && json_locale_data [ "client" ] ) { var dict = json_locale_data [ "client" ] ; if ( dict [ msgid ] && dict [ msgid ] . length >= 2 && dict [ msgid ] [ 1 ] . trim ( ) != "" ) { return dict [ msgid ] [ 1 ] ; } } return msgid ; }
function ( draggedId , droppedOnId ) { var group = findGroup ( droppedOnId ) ; group . addCard ( draggedId ) ; game . trigger ( "CardAddedToGroup" , group . groupId , draggedId ) ; game . selectGroup ( droppedOnId ) ; }
function ( draggedCardId , droppedOnCardId ) { var group = findGroupContainingCard ( droppedOnCardId ) ; group . addCard ( draggedCardId , droppedOnCardId ) ; game . trigger ( "CardAddedToGroup" , group . groupId , draggedCardId ) ; game . selectGroup ( group . groupId ) ; }
function ( top ) { const overviewHeight = 90 ; const sectionMinHeight = 100 ; top = Number . constrain ( top , overviewHeight + sectionMinHeight , this . element . offsetHeight - sectionMinHeight ) ; this . splitView . element . style . height = ( top - overviewHeight ) + "px" ; this . _timelineMemorySplitter . style . top = ( top - 2 ) + "px" ; this . _memoryStatistics . setTopPosition ( top ) ; }
function ( sql , args , callback ) { if ( ! callback && typeof args === 'function' ) { callback = args ; args = undefined ; } return callNative ( 'eachAsync' , sql , args , function ( row ) { callback ( toObject ( row ) ) ; } ) . then ( function ( ) { return that ; } , wrapComException ) ; }
function ( value ) { return ( '00000000' + ( value >>> 0 ) . toString ( 16 ) ) . slice ( - 8 ) ; }
function ( ) { var b = new BitArray ( ) ; b . set ( 0 , true ) ; b . set ( 4 , true ) ; b . set ( 31 , true ) ; assert . equal ( b . get ( 0 ) , true , 'set(0, true).get(0)' ) ; assert . equal ( b . get ( 4 ) , true , 'set(4, true).get(4)' ) ; assert . equal ( b . get ( 31 ) , true , 'set(31, true).get(31)' ) ; }
function ( ) { $ ( '.bouncer-container' ) . append ( $ ( '#bouncer-template' ) . html ( ) ) ; $ ( '.bouncer-container' ) . find ( '.bouncer' ) . addClass ( 'move-bouncer' ) ; $ ( '.bouncer-container' ) . find ( '.mask' ) . addClass ( 'move-mask' ) ; }
function ( ) { var subcurve = this . getSubCurves ( ) ; this . p1x = subcurve . b0 . p1x ; this . p1y = subcurve . b0 . p1y ; this . c1x = subcurve . b0 . c1x ; this . c1y = subcurve . b0 . c1y ; var p = this . getPath ( ) ; p . insertEdgeAfter ( this , subcurve . b1 ) ; }
function ( value , key ) { var valueFn = value . filter || _ . identity ; self [ key ] = valueFn ( sample [ key ] || undefined ) ; }
function ( value , key ) { var valueFn = value . filter || _ . identity ; Object . defineProperty ( self , key , { value : valueFn ( sample [ key ] || undefined ) , writable : false , enumerable : true } ) ; }
function ( value , key ) { var withLabel = key ; withLabel = withLabel [ 0 ] . toUpperCase ( ) + withLabel . slice ( 1 , withLabel . length ) ; withLabel = 'with' + withLabel ; constructor . prototype [ withLabel ] = function ( value ) { var adjust = { } ; adjust [ key ] = value ; return this . with_ ( adjust ) ; } }
function ( value , key ) { var valueFn = value . filter || _ . identity ; self [ key ] = valueFn ( sample [ key ] || undefined ) ; }
function ( value , key ) { var valueFn = value . filter || _ . identity ; Object . defineProperty ( self , key , { value : valueFn ( sample [ key ] || undefined ) , writable : false , enumerable : true } ) ; }
function ( ) { var Cons = b . struct ( { x : { } , } ) , eg ; eg = new Cons ( { x : 13 } ) ; raises ( function ( ) { eg . x = 14 ; } ) ; }
function ( ) { var Cons = b . struct ( { y : { } , } ) , eg ; eg = new Cons ( { y : 10 } ) ; eg . y = 11 ; equal ( 11 , eg . y , "in non-strict mode, changing properties does (sadly) work" ) ; eg = eg . with_ ( { } ) ; equal ( 10 , eg . y , 'but with_ will restore the original value.' ) ; }
function ( e ) { if ( e . success ) { var user = e . users [ 0 ] ; alert ( 'Welcome to ShootNSell!' ) ; loginWin . close ( ) ; homeWin . open ( ) ; } else { } }
function ( e ) { Ti . API . info ( 'Function entered' ) if ( e . success ) { var user = e . users [ 0 ] ; alert ( 'Welcome to ShootNSell!' ) ; loginWin . close ( ) ; homeWin . open ( ) ; } else { login ( email ) ; } }
function ( req , res , next ) { console . log ( 'processing session or abort' ) ; if ( req . session !== undefined && req . session . st ) { console . log ( 'have session.  steady as she goes' ) ; return next ( ) ; } else { console . log ( 'no session, switch to next route' ) ; return next ( 'route' ) ; } }
function ( i , elt ) { elt . alpha = 0 ; elt . textElement . css ( "opacity" , 0 ) ; elt . textElement . animate ( { opacity : 0.4 , } , textFadeDuration * 1000 , function ( ) { $ ( this ) . css ( "opacity" , "" ) ; } ) ; $ ( "body" ) . append ( elt . textElement ) ; }
function ( data ) { var events = data . split ( "\n" ) ; for ( i in events ) { try { this . handle_event ( events [ i ] ) ; } catch ( err ) { console . error ( "Error while handling event: " , events [ i ] , err ) ; } } }
function ( state , i ) { console . error ( last_x , state , i ) ; var current_width = state / sum * self . width ; self . parts [ i ] . animate ( { x : last_x , width : current_width } , t ) . attr ( { title : state } ) ; last_x += current_width ; }
function is_user_entry_is_empty ( entry ) { if ( entry . online ) return false ; if ( entry . reserved . length ) return false ; found = false ; for ( idx in claims ) { if ( claims [ idx ] [ 'owner' ] == entry . user_nick ) { found = true ; break ; } } if ( found ) return false ; return true ; }
function ( ) { this . _inputElem . attr ( 'disabled' , 'true' ) ; }
function ( ) { if ( this . isInEditMode ( ) ) { return false ; } this . _isInEditMode = true ; this . _subject . addClass ( this . UI_CLASS + '-ineditmode' ) ; $ . each ( this . _interfaces , function ( index , elem ) { elem . startEditing ( ) ; } ) ; return true ; }
function ( event , ui ) { var id = extractCanvasId ( this . id ) ; if ( ! id ) { return ; } triggerQueuedRedraw ( id , this . value , actualDataSet ) ; }
function ( confirmed ) { var me = this ; var image = this . getSelecteed ( ) ; if ( ! image ) return ; if ( ! confirmed && ! confirm ( "Deregister AMI " + image . id + " (" + image . location + ")?" ) ) return ; this . core . api . deregisterImage ( image . id , function ( ) { me . refresh ( ) } ) ; }
function stepContains ( substring , frames , symbols ) { for ( var i = 0 ; i < frames . length ; i ++ ) { var frameSym = symbols [ frames [ i ] ] . functionName || symbols [ frames [ i ] ] . symbolName ; if ( frameSym . indexOf ( substring ) != - 1 ) { return true ; } } return false ; }
function indexForFunction ( functionName , libraryName ) { var resolve = functionName + "_LIBNAME_" + libraryName ; if ( resolve in functionIndices ) return functionIndices [ resolve ] ; var newIndex = functions . length ; functions [ newIndex ] = { functionName : functionName , libraryName : libraryName } ; functionIndices [ resolve ] = newIndex ; return newIndex ; }
function parseSymbol ( symbol ) { var info = getFunctionInfo ( symbol ) ; return { symbolName : symbol , functionName : info . functionName , functionIndex : indexForFunction ( info . functionName , info . libraryName ) , lineInformation : info . lineInformation } ; }
function ( ) { if ( arguments . length >= 2 ) { charm . display ( 'reset' ) ; charm . display ( arguments [ 0 ] ) ; return cwrite . apply ( null , arguments . slice ( 1 ) ) ; } }
function ( ) { var args ; args = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; cwrite . apply ( null , args ) ; return this ; }
function ( ) { charm . background ( ix ++ ) . write ( ' ' ) ; if ( ix === 256 ) { clearInterval ( iv ) ; charm . write ( '\n' ) ; exit ( ) ; } }
function toArray ( obj ) { var undef , out , i ; if ( obj && ! obj . splice ) { out = [ ] ; for ( i = 0 ; true ; i ++ ) { if ( obj [ i ] ) out [ i ] = obj [ i ] ; else break ; } return out ; } return obj ; }
function ( error , oauth_token , oauth_token_secret , results ) { if ( error ) { console . log ( error ) ; res . send ( "yeah no. didn't work." ) } else { req . session . oauth = { token : oauth_token , token_secret : oauth_token_secret } ; res . redirect ( 'https://trello.com/1/OAuthAuthorizeToken?oauth_token=' + oauth_token ) } }
function ( err ) { if ( err && err . advice ) { if ( err . advice === 'reconnect' && this . connected ) { this . disconnect ( ) ; this . reconnect ( ) ; } } this . publish ( 'error' , err && err . reason ? err . reason : err ) ; }
function ( ) { attrs = { 'foo' : 1 , 'bar' : 2 , 'baz' : 3 } ; a = new Backbone . Model ( attrs ) ; ok ( a . isNew ( ) , "it should be new" ) ; attrs = { 'foo' : 1 , 'bar' : 2 , 'baz' : 3 , 'id' : - 5 } ; ok ( a . isNew ( ) , "any defined ID is legal, negative or positive" ) ; }
function ( tx , ty , tz , scl , id , time ) { this . pos = V3 . $ ( tx , ty , tz ) ; this . scl = scl ; this . id = id ; this . time = Math . random ( ) * 100 ; this . speed = Math . random ( ) * 0.5 + 0.5 ; this . alive = 1 ; }
function ( ) { var dataPoints = $ . toJSON ( drawingPoints ) ; var doodleToSave = new Doodle ( dataPoints ) ; doodleToSave . send ( ) ; }
function ( ) { var m = new DatumField ( { "state" : this . $el . find ( ".add_input" ) . val ( ) , "color" : this . $el . find ( ".add_color_chooser" ) . val ( ) } ) ; this . model . get ( "datumStates" ) . add ( m ) ; this . datumStatesView . add ( m ) ; }
function _handleUserContactInfoClickEvent ( e ) { var emailAddress = $ ( '#emailAddress' , e . srcElement . form ) . val ( ) ; var city = $ ( '#city' , e . srcElement . form ) . val ( ) ; var note = $ ( '#note' , e . srcElement . form ) . val ( ) ; var data = { "type" : e . currentTarget . id , "emailAddress" : emailAddress , "city" : city , "note" : note } ; _captureUserContactInfo ( data ) ; }
function ( child , parent ) { if ( ! child ) { return false ; } var document = child . ownerDocument ; var body = document . body ; var element = child ; while ( element && element != body ) { if ( element == parent ) { return true ; } element = element . parentNode ; } return ( element == parent ) ; }
function ( event ) { console . log ( event ) ; if ( event === 'error' ) { console . log ( 'cannot play ' + this . model . get ( 'name' ) ) ; this . destroy ( ) ; } }
function ( heading ) { }
function addToHistory ( page ) { if ( pageHistory [ pageHistory . length - 1 ] !== page ) { pageHistory . push ( page ) ; } }
function displayError ( heading , text ) { showPage ( 'error-page' ) ; $ ( '#error-page textarea' ) . val ( heading + ':\n' + text ) ; }
function ( ) { if ( arguments . length === 2 ) { return new XMLElement ( arguments [ 0 ] , arguments [ 1 ] , null , null ) ; } return new XMLElement ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] , arguments [ 3 ] ) ; }
function ( r , g , b ) { var col = color$4 ( r , g , b , 0 ) ; var normalizedCol = [ ( ( col & PConstants . RED_MASK ) >>> 16 ) / 255 , ( ( col & PConstants . GREEN_MASK ) >>> 8 ) / 255 , ( col & PConstants . BLUE_MASK ) / 255 ] ; curContext . useProgram ( programObject3D ) ; uniformf ( "specular3d" , programObject3D , "specular" , normalizedCol ) ; }
function ( v1 , v2 , v3 ) { curContext . useProgram ( programObject3D ) ; uniformi ( "usingMat3d" , programObject3D , "usingMat" , true ) ; var col = p . color ( v1 , v2 , v3 ) ; uniformf ( "mat_ambient3d" , programObject3D , "mat_ambient" , p . color . toGLArray ( col ) . slice ( 0 , 3 ) ) ; }
function ( v1 , v2 , v3 ) { curContext . useProgram ( programObject3D ) ; uniformi ( "usingMat3d" , programObject3D , "usingMat" , true ) ; var col = p . color ( v1 , v2 , v3 ) ; uniformf ( "mat_emissive3d" , programObject3D , "mat_emissive" , p . color . toGLArray ( col ) . slice ( 0 , 3 ) ) ; }
function ( v1 , v2 , v3 ) { curContext . useProgram ( programObject3D ) ; uniformi ( "usingMat3d" , programObject3D , "usingMat" , true ) ; var col = p . color ( v1 , v2 , v3 ) ; uniformf ( "mat_specular3d" , programObject3D , "mat_specular" , p . color . toGLArray ( col ) . slice ( 0 , 3 ) ) ; }
function ( w ) { DrawingShared . prototype . strokeWeight . apply ( this , arguments ) ; curContext . useProgram ( programObject2D ) ; uniformf ( "pointSize2d" , programObject2D , "pointSize" , w ) ; curContext . useProgram ( programObjectUnlitShape ) ; uniformf ( "pointSizeUnlitShape" , programObjectUnlitShape , "pointSize" , w ) ; curContext . lineWidth ( w ) ; }
function ( ) { if ( this . isRemote ) { return this . sourceImg ; } if ( ! this . __isDirty ) { return this . imageData ; } var canvasData = getCanvasData ( this . imageData ) ; return canvasData . context . getImageData ( 0 , 0 , this . width , this . height ) ; }
function ( size ) { if ( size !== curTextSize ) { curTextFont = PFont . get ( curFontName , size ) ; curTextSize = size ; curTextAscent = curTextFont . ascent ; curTextDescent = curTextFont . descent ; curTextLeading = curTextFont . leading ; var curContext = drawing . $ensureContext ( ) ; curContext . font = curTextFont . css ; } }
function ( ) { var view = pane . view ( 'with value' ) ; SC . RunLoop . begin ( ) ; view . set ( 'value' , null ) ; SC . RunLoop . end ( ) ; equals ( view . get ( 'fieldValue' ) , '' , 'should have empty fieldValue' ) ; pane . verifyEmpty ( view , 'Full Name' ) ; }
function ( ) { var thisClass = $ ( this ) . attr ( 'class' ) ; $ ( this ) . parent ( ) . siblings ( "tr." + thisClass + '_param' ) . show ( ) ; }
function ( ) { var thisClass = $ ( this ) . attr ( 'class' ) ; $ ( this ) . parent ( ) . siblings ( "tr." + thisClass + "_param" ) . hide ( ) ; }
function ( ) { _this = this ; var treeData = [ ] ; if ( TissueStack . dataSetStore . getSize ( ) == 0 ) { treeData [ 0 ] = { title : "No Data Sets Found" , tooltip : "No Data Sets Found" } ; } _this . addDataSetToTabletTree ( ) ; }
function ( plane ) { if ( typeof ( plane ) != "string" || ! ( plane == 'x' || plane == 'y' || plane == 'z' ) ) { throw new Error ( "plane has to be one of the following: 'z', 'y' or 'z'" ) ; } this . plane = plane ; }
function ( ) { TissueStack . dataSetNavigation = new TissueStack . DataSetNavigation ( ) ; TissueStack . dataSetNavigation . addToOrReplaceSelectedDataSets ( TissueStack . dataSetStore . getDataSetByIndex ( 0 ) . id , 0 ) ; TissueStack . InitUserInterface ( ) ; TissueStack . BindDataSetDependentEvents ( ) ; TissueStack . BindGlobalEvents ( ) ; if ( TissueStack . desktop ) { TissueStack . admin = new TissueStack . Admin ( ) ; } }
function ( e ) { if ( e . keyCode === window . Game . Keys . D ) { window . Game . Debugging = ! window . Game . Debugging ; } else if ( engine . onKeydown ( e ) ) { e . preventDefault ( ) ; return false ; } }
function ( ) { console . log ( 'refresh start' ) var _this = this ; this . target . fadeTo ( 1000 , 0.5 ) . spin ( 'small' ) ; this . fetch ( { success : function ( ) { console . log ( 'refresh success' ) _this . target . spin ( false ) ; _this . renderCollection ( ) ; } } ) }
function ( options ) { var locale = undefined ; if ( exists ( options ) ) locale = options [ "locale" ] ; if ( ! exists ( locale ) ) locale = this . locale ; return locale ; }
function ( e ) { if ( ! e . target . hasClass ( this . oCss . d ) ) { this . _fnAlterClass ( e . target , aLI , this . oCss . c ) ; this . _setSelected ( ) ; } }
function ( command ) { var deferred = $q . defer ( ) ; ss . rpc . apply ( ss , [ command ] . concat ( arguments . slice ( 1 , arguments . length - 1 ) ) , function ( response ) { $rootScope . $apply ( function ( ) { deferred . resolve ( response ) ; } ) ; } ) ; return deferred . promise ; }
function ( amount ) { var stageMovedX = game_ . match_ . deltaX_ ; if ( ! ! stageMovedX ) { amount = 0.5 * ( Math . abs ( amount ) * ( Math . abs ( stageMovedX ) / stageMovedX ) ) ; this . MoveX ( amount ) ; } }
function BaseController ( app , req , res ) { this . app = app ; this . req = req ; this . res = res ; this . view = { } ; this . before ( ) ; this [ this . req . route . action || 'actionIndex' ] ( ) ; this . after ( ) ; }
function ( ) { expect ( test . range_input1 . value ) . toBe ( 0 ) ; var eventInfo = { target : test . range_input1 . element , clientX : test . range_input1 . element . offsetLeft + 30 , clientY : test . range_input1 . element . offsetTop + 5 } ; testPage . clickOrTouch ( eventInfo ) ; expect ( test . range_input1 . value ) . toBeGreaterThan ( 0 ) ; }
function ( position ) { var x = this . _positionOfElement ( this . element ) . x ; var positionX = ( position - ( x + ( this . _handleWidth / 2 ) ) ) ; if ( positionX < 0 ) { positionX = 0 ; } this . _positionX = positionX ; }
function GetDirectoryName ( path ) { var index = path . lastIndexOf ( "\\" ) ; if ( index >= 0 ) { return path . substr ( 0 , index ) ; } return "" ; }
function GetFileName ( path ) { var index = path . lastIndexOf ( "\\" ) ; if ( index >= 0 ) { return path . substr ( index + 1 ) ; } return path ; }
function GetFileNameWithoutExtension ( path ) { var index = path . lastIndexOf ( "\\" ) ; if ( index >= 0 ) { path = path . substr ( index + 1 ) ; } index = path . indexOf ( "." ) ; if ( index >= 0 ) path = path . substr ( 0 , index ) ; return path ; }
function Dialog ( options ) { Emitter . call ( this ) ; options = options || { } ; this . template = render ( 'dialog' ) ; this . el = $ ( this . template ) ; this . render ( options ) ; if ( active && ! active . hiding ) active . hide ( ) ; if ( Dialog . effect ) this . effect ( Dialog . effect ) ; active = this ; }
function ( ) { nodeWillBecomeActive ( node , function ( ) { nodeDidBecomeActive ( node , function ( ) { that . refresh ( ) ; flushWaitTasks ( function ( ) { flowObservers . forEach ( function ( observer ) { if ( observer . update ) { observer . update ( ) ; } } ) ; cb ( ) ; } ) ; } ) ; } ) ; }
function ( id , value ) { if ( same && id !== 'action' ) { if ( id === 'node' ) { same = a . node === b . node ; } else { same = ! different ( value , b [ id ] ) ; } } }
function ( id , value ) { if ( same && id !== 'action' ) { if ( id === 'node' ) { same = b . node === a . node ; } else { same = ! different ( value , a [ id ] ) ; } } }
function ( event ) { self . orientation [ 'alpha' ] = Math . round ( event . alpha ) ; self . orientation [ 'beta' ] = Math . round ( event . beta ) ; self . orientation [ 'gamma' ] = Math . round ( event . gamma ) ; self . acceleration . x = Math . round ( event . gamma ) / 100 ; self . acceleration . y = Math . round ( event . beta ) / 100 ; }
function ( ) { this . acceleration . validate ( ) ; this . velocity . iadd ( this . acceleration ) ; var speed = this . velocity . length ( ) ; if ( speed > this . speedLimit ) { this . velocity . idiv ( speed / this . speedLimit ) ; } this . position . iadd ( this . velocity ) ; this . acceleration . zero ( ) ; this . debug ( ) ; }
function ( err , stats ) { if ( err ) { stats . status = 404 ; cb ( err ) ; } else { fs . unlink ( path , function ( err ) { if ( err ) { err . status = 500 ; cb ( err ) ; } else { cb ( ) ; } } ) ; } }
function ( ) { if ( ! isPrepared ) { isPrepared = true ; Class . PrototypeMixin . applyPartial ( Class . prototype ) ; hasChains = ! ! meta ( Class . prototype , false ) . chains ; } return this . prototype ; }
function ( key ) { var desc = meta ( get ( this , 'proto' ) , false ) . descs [ key ] ; ember_assert ( "metaForProperty() could not find a computed property with key '" + key + "'." , ! ! desc && desc instanceof Ember . ComputedProperty ) ; return desc . _meta || { } ; }
function ( callback , binding ) { var proto = get ( this , 'proto' ) , descs = meta ( proto ) . descs , empty = { } , property ; for ( var name in descs ) { property = descs [ name ] ; if ( property instanceof Ember . ComputedProperty ) { callback . call ( binding || this , name , property . _meta || empty ) ; } } }
function ( oldIndex , oldPage ) { if ( oldPage && oldPage !== page ) { oldPage . index = pages . length ; pages . push ( oldPage ) ; } else if ( currentPage && page === currentPage ) { if ( pages . length ) { newCurrentPage = pages [ pages . length - 1 ] ; } else { newCurrentPage = this . pages [ oldIndex + 1 ] ; } } }
function ( cfg ) { var node = this . get ( 'node' ) ; Y . log ( node ) ; if ( node ) { this . registerNavigableContainer ( node ) ; Y . log ( this . container , 'debug' ) ; } }
function ( y ) { this . anim = new Y . Anim ( { node : 'window' , from : { scroll : [ Y . DOM . docScrollX ( ) , Y . DOM . docScrollY ( ) ] } , to : { scroll : [ Y . DOM . docScrollX ( ) , y ] } , duration : 0.5 , easing : Y . Easing . easeOutStrong } ) . run ( ) ; }
function ( childIndexInFocus ) { var container = this . container , numofChildren = container . children . length ; if ( childIndexInFocus != - 1 ) { container . children [ childIndexInFocus ] . removeClass ( 'highlight' ) ; } if ( childIndexInFocus === numofChildren - 1 ) { childIndexInFocus = - 1 ; this . wasChildLast = true ; } else { this . wasChildLast = false ; } childIndexInFocus ++ ; return childIndexInFocus ; }
function ( childInFocus ) { childInFocus . addClass ( 'highlight' ) . focus ( ) ; if ( this . wasChildLast ) { Y . log ( 'last child' ) ; if ( this . anim && this . anim . get ( 'running' ) ) { this . anim . pause ( ) ; } childInFocus . scrollIntoView ( ) ; } this . scrollToCenter ( childInFocus ) ; }
function ( e ) { this . wasChildLast = false ; e . preventDefault ( ) ; var container = this . container , numofChildren = container . children . length , childIndexInFocus = container . childIndexInFocus , newindex = this . getNextIndex ( childIndexInFocus ) ; Y . log ( 'onkeydown:infocus:' + newindex ) ; this . bringChildtoFocus ( container . children [ newindex ] ) ; container . childIndexInFocus = newindex ; }
function ( e ) { e . preventDefault ( ) ; var container = this . container , numofChildren = container . children . length , childIndexInFocus = container . childIndexInFocus ; newindex = this . getPreviousIndex ( childIndexInFocus ) ; Y . log ( 'onkeyup:Infocus:' + newindex ) ; this . bringChildtoFocus ( container . children [ newindex ] ) ; container . childIndexInFocus = newindex ; }
function ( y ) { this . anim = new Y . Anim ( { node : 'window' , from : { scroll : [ Y . DOM . docScrollX ( ) , Y . DOM . docScrollY ( ) ] } , to : { scroll : [ Y . DOM . docScrollX ( ) , y ] } , duration : 0.5 , easing : Y . Easing . easeOutStrong } ) . run ( ) ; }
function ( childIndexInFocus ) { var container = this . container , numofChildren = container . children . length ; if ( childIndexInFocus != - 1 ) { container . children [ childIndexInFocus ] . removeClass ( 'highlight' ) ; } if ( childIndexInFocus === numofChildren - 1 ) { childIndexInFocus = - 1 ; this . wasChildLast = true ; } else { this . wasChildLast = false ; } childIndexInFocus ++ ; return childIndexInFocus ; }
function ( childInFocus ) { childInFocus . addClass ( 'highlight' ) . focus ( ) ; if ( this . wasChildLast ) { if ( this . anim && this . anim . get ( 'running' ) ) { this . anim . pause ( ) ; } childInFocus . scrollIntoView ( ) ; } this . scrollToCenter ( childInFocus ) ; }
function ( e ) { this . wasChildLast = false ; e . preventDefault ( ) ; var container = this . container , numofChildren = container . children . length , childIndexInFocus = container . childIndexInFocus , newindex = this . getNextIndex ( childIndexInFocus ) ; this . bringChildtoFocus ( container . children [ newindex ] ) ; container . childIndexInFocus = newindex ; }
function ( e ) { e . preventDefault ( ) ; var container = this . container , numofChildren = container . children . length , childIndexInFocus = container . childIndexInFocus ; newindex = this . getPreviousIndex ( childIndexInFocus ) ; this . bringChildtoFocus ( container . children [ newindex ] ) ; container . childIndexInFocus = newindex ; }
function ( cfg ) { var node = this . get ( 'node' ) ; Y . log ( node ) ; if ( node ) { this . registerNavigableContainer ( node ) ; Y . log ( this . container , 'debug' ) ; } }
function ( y ) { this . anim = new Y . Anim ( { node : 'window' , from : { scroll : [ Y . DOM . docScrollX ( ) , Y . DOM . docScrollY ( ) ] } , to : { scroll : [ Y . DOM . docScrollX ( ) , y ] } , duration : 0.5 , easing : Y . Easing . easeOutStrong } ) . run ( ) ; }
function ( childIndexInFocus ) { var container = this . container , numofChildren = container . children . length ; if ( childIndexInFocus != - 1 ) { container . children [ childIndexInFocus ] . removeClass ( 'highlight' ) ; } if ( childIndexInFocus === numofChildren - 1 ) { childIndexInFocus = - 1 ; this . wasChildLast = true ; } else { this . wasChildLast = false ; } childIndexInFocus ++ ; return childIndexInFocus ; }
function ( childInFocus ) { childInFocus . addClass ( 'highlight' ) . focus ( ) ; if ( this . wasChildLast ) { Y . log ( 'last child' ) ; if ( this . anim && this . anim . get ( 'running' ) ) { this . anim . pause ( ) ; } childInFocus . scrollIntoView ( ) ; } this . scrollToCenter ( childInFocus ) ; }
function ( e ) { this . wasChildLast = false ; e . preventDefault ( ) ; var container = this . container , numofChildren = container . children . length , childIndexInFocus = container . childIndexInFocus , newindex = this . getNextIndex ( childIndexInFocus ) ; Y . log ( 'onkeydown:infocus:' + newindex ) ; this . bringChildtoFocus ( container . children [ newindex ] ) ; container . childIndexInFocus = newindex ; }
function ( e ) { e . preventDefault ( ) ; var container = this . container , numofChildren = container . children . length , childIndexInFocus = container . childIndexInFocus ; newindex = this . getPreviousIndex ( childIndexInFocus ) ; Y . log ( 'onkeyup:Infocus:' + newindex ) ; this . bringChildtoFocus ( container . children [ newindex ] ) ; container . childIndexInFocus = newindex ; }
function euclidDist ( p1 , p2 ) { var xd = p1 . x - p2 . x , yd = p1 . y - p2 . y ; return Math . sqrt ( xd * xd + yd * yd ) ; }
function transition ( ) { for ( var i = 0 ; i < particleList . length ; i ++ ) { var newParticle = null ; while ( newParticle == null || ! stateIsValid ( newParticle ) ) { newParticle = createNewState ( particleList [ i ] , Math . random ( ) * 40 - 20 , Math . random ( ) * Math . PI / 3 - Math . PI / 6 ) ; } particleList [ i ] = newParticle ; } }
function randomDistribution ( num ) { var list = [ ] ; for ( var i = 0 ; i < num ; i ++ ) { var particle = null ; while ( particle == null || ! stateIsValid ( particle ) ) { particle = createState ( Math . random ( ) * CANVAS_WIDTH , Math . random ( ) * CANVAS_HEIGHT , Math . random ( ) * 2 * Math . PI ) ; } list . push ( particle ) ; } return list ; }
function cutAngle ( angle ) { if ( angle < 0 ) angle += Math . PI * 2 ; angle = angle - Math . floor ( angle / ( Math . PI * 2 ) ) * ( Math . PI * 2 ) ; return angle ; }
function stateIsValid ( state ) { return state . p . x > 0 && state . p . x < CANVAS_WIDTH && state . p . y > 0 && state . p . y < CANVAS_HEIGHT ; }
function wf_loop ( ) { var leftDist = readDistSensors ( ) [ 0 ] ; var normal = leftDist - 100 ; if ( normal < - 10 ) { wfpow1 = .4 ; wfpow2 = - .4 ; } else if ( normal > 10 ) { wfpow1 = .4 ; wfpow2 = .6 ; } else { wfpow1 = .8 ; wfpow2 = .8 ; } setMotorPowers ( wfpow1 , wfpow2 ) ; }
function ( ) { var data = testUtilities . cloneObj ( testData . xml2jsConfig ) ; data [ "rim:invoke-target" ] = { "@" : { "id" : "com.domain.subdomain.appName.app" } } ; mockParsing ( data ) ; expect ( function ( ) { configParser . parse ( configPath , session , function ( configObj ) { } ) ; } ) . toThrow ( localize . translate ( "EXCEPTION_INVOKE_TARGET_INVALID_TYPE" ) ) ; }
function ( resource ) { if ( path . existsSync ( resource ) ) { try { config = JSON . parse ( fs . readFileSync ( resource ) ) } catch ( err ) { throw new Error ( "Could not parse JSON config at " + path . resolve ( resource ) ) } } }
function execute ( ) { var stmt , result = [ ] ; while ( stmt = this . parseStatement ( ) ) { result . push ( stmt ) ; } if ( this . peek ( ) . type !== 'end' ) { if ( ! this . error ) throw new Error ( 'Unexpected parser error!' ) ; throw new Error ( 'Parser failed at: ' + this . error . offset + '\n' + this . error . message ) ; } return result ; }
function ( readyHandler ) { log . debug ( "[PC] = Preparing an offer" ) ; this . _endpoints = [ ] ; this . _offeringClient = true ; this . _offer = this . _nativePC . createOffer ( { audio : true , video : true } ) ; this . _nativePC . setLocalDescription ( this . _nativePC . SDP_OFFER , this . _offer ) ; this . _nativePC . startIce ( ) ; this . _offerReadyHandler = readyHandler ; this . state = CA . PeerConnection . ConnectionState . CONNECTING ; log . debug ( "[PC] = Offer prepared; waiting for ICE endpoints" ) ; }
function ( candidate , moreToFollow ) { this . _endpoints . push ( new CA . ClientEndpoint ( candidate ) ) ; if ( ! moreToFollow ) { if ( this . _offeringClient ) { this . _offerReadyHandler ( new CA . ClientDetails ( this . _offer , this . _endpoints ) ) ; } else { this . _answerReadyHandler ( new CA . ClientDetails ( this . _answer , this . _endpoints ) ) ; } } }
function ( memo , ap ) { return memo + ap . switchDPID + "-" + ap . port + " " }
function ( success , data ) { $ ( "#areapermissions_content_container" ) . html ( sakai . api . Util . TemplateRenderer ( "areapermissions_content_template" , { "roles" : sortedroles , "visibility" : visibility , "manager" : contextData . isManager , "groupPermissions" : sakai_global . group . groupData [ "sakai:group-visible" ] , "sakai" : sakai , "area" : currentArea . _title , "meRole" : data . id } ) ) ; }
function ( success ) { sakai . api . Util . progressIndicator . showProgressIndicator ( sakai . api . i18n . getValueForKey ( 'REMOVING_CONTENT_FROM_COLLECTION' , 'collectionviewer' ) , sakai . api . i18n . getValueForKey ( 'PROCESSING' , 'collectionviewer' ) ) ; $ ( '.collectionviewer_check:checked:visible' , $rootel ) . parents ( 'li:not(.contentauthoring_row_container)' ) . hide ( 'slow' ) ; setTimeout ( refreshCollection , 1500 ) ; }
function ( ev , val ) { var num = parseInt ( $ ( "#entity_participants_count" ) . text ( ) , 10 ) ; var newNum = num + val ; $ ( "#entity_participants_count" ) . text ( newNum ) ; if ( newNum === 1 ) { $ ( "#entity_participants_text" ) . text ( sakai . api . i18n . getValueForKey ( "PARTICIPANT" , "entity" ) ) ; } else { $ ( "#entity_participants_text" ) . text ( sakai . api . i18n . getValueForKey ( "PARTICIPANTS" , "entity" ) ) ; } }
function ( responses ) { if ( responses && responses . length > 0 ) { var html = responses [ 0 ] . formatted_address ; updateInfoWindow ( html ) ; } else { $ ( window ) . trigger ( 'show.mapsnotification.sakai' , { subject : sakai . api . i18n . Widgets . getValueForKey ( 'googlemaps' , 'NO_ADDRESS' ) , body : sakai . api . i18n . Widgets . getValueForKey ( 'googlemaps' , 'CANNOT_DETERMINE_ADDRESS_AT_THIS_LOCATION' ) } ) ; } }
function Placeholder ( el , cfg ) { if ( isSupport ) return ; var self = this ; var defaultCfg = { wrap : true } ; if ( self instanceof placeholder ) { var config = Y . merge ( defaultCfg , cfg ) ; self . _init ( el , config ) ; return ; } return new placeholder ( el , cfg ) ; }
function ( error , result , more ) { for ( var i = 0 ; i < result . length ; i ++ ) { self . _services [ result [ i ] ] = { ready : false , context : null , introspected : null } ; } callback ( error , self ) ; }
function ( e ) { $ ( '#taxon_browser .loading:first' ) . show ( ) ; var params = $ ( this ) . serialize ( ) + '&partial=browse' ; $ . get ( $ ( this ) . attr ( 'action' ) , params , function ( data , status ) { $ ( '#taxon_browser' ) . html ( data ) ; TaxonBrowser . ajaxify ( ) ; } ) ; return false ; }
function ( ) { TaxonBrowser . ajaxify ( ) }
function ( assert ) { nano . db . destroy ( "db_replicate" , function ( err ) { assert . equal ( err , undefined , "Failed to destroy database" ) ; nano . db . destroy ( "db_replica" , function ( err ) { assert . equal ( err , undefined , "Failed to destroy replica database" ) ; assert . ok ( mock . isDone ( ) , "Some mocks didn't run" ) ; } ) ; } ) ; }
function ( senderID , eventCallback , successCallback , failureCallback ) { if ( typeof eventCallback != "string" ) { var e = new Array ( ) ; e . msg = 'eventCallback must be a STRING name of the routine' ; e . rc = - 1 ; failureCallback ( e ) ; return ; } alert ( 'GCM.register() called!' ) ; return Cordova . exec ( successCallback , failureCallback , 'GCMPlugin' , 'register' , [ { email : senderID , ecb : eventCallback } ] ) ; }
function ( ) { if ( Ext . isIE6 || Ext . isIE7 || Ext . isIE8 || ( Ext . isIE && this . document . documentMode < 9 ) ) { Ext . each ( this . config . customTags , function ( tag ) { this . document . createElement ( tag ) ; } , this ) ; } }
function ( e ) { var paginator = this , bb = paginator . _bb ; bb . addClass ( CLASS_PAGED ) ; }
function ( e ) { var paginator = this , host = paginator . _host , bb = host . _bb , isForward = e . wheelDelta < 0 , axis = paginator . get ( AXIS ) ; if ( bb . contains ( e . target ) && axis === DIM_Y ) { if ( isForward ) { paginator . next ( ) ; } else { paginator . prev ( ) ; } e . preventDefault ( ) ; return paginator . _prevent ; } }
function ( e ) { var paginator = this , host = this . _host , index = paginator . _cIndex ; paginator . cards [ index ] . scrollY = host . get ( 'scrollY' ) ; paginator . _optimize ( ) ; paginator . _uiEnable ( ) ; }
function ( e ) { var paginator = this , host = this . _host , index = e . newVal ; host . set ( 'scrollY' , paginator . cards [ index ] . scrollY , { src : 'ui' } ) ; paginator . _cIndex = index ; if ( e . src !== UI ) { paginator . scrollToIndex ( index ) ; } }
function ( e ) { var sv = this , gesture = sv . _gesture , duration = e . duration , easing = e . easing , val = e . newVal ; if ( e . src !== UI ) { if ( e . attrName === SCROLL_X ) { sv . scrollTo ( val , gesture . startY , duration , easing ) ; } else { sv . scrollTo ( gesture . startX , val , duration , easing ) ; } } }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( i , side ) { var size = ( parseInt ( $ . curCSS ( elem , 'padding' + side ) , 10 ) || 0 ) + Math . max ( ( parseInt ( $ . curCSS ( elem , 'margin' + side ) , 10 ) || 0 ) , 0 ) + ( parseInt ( $ . curCSS ( elem , 'border' + side + 'Width' ) , 10 ) || 0 ) ; data . text . css ( 'padding' + side , size ) ; }
function ( msg ) { ProtView . Global . prot = msg ; $ ( '#protein' ) . svg ( { onLoad : ProtView . Graphic . draw , settings : { width : "800px" , height : "800px" , xmlns : "http://www.w3.org/2000/svg" , style : "display:inline; float: left; z-index: 1;" } } ) ; }
function ( a ) { f . de . valueMissing [ a ] = "Bitte w\u00e4hlen Sie eine Option aus" } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { f . de . rangeUnderflow [ a ] = "{%value} ist zu fr\u00fch. {%min} ist die fr\u00fcheste Zeit, die Sie benutzen k\u00f6nnen." } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { f . de . rangeOverflow [ a ] = "{%value} ist zu sp\u00e4t. {%max} ist die sp\u00e4teste Zeit, die Sie benutzen k\u00f6nnen." }
function ( args , callback ) { Tag . deleteTag ( args , function ( error , deletedTag ) { if ( ! error ) { callback ( null , deletedTag ) ; } else { callback ( error , null ) ; } } ) }
function require ( arg1 , arg2 , arg3 , arg4 ) { var args = parse ( arg1 , arg2 , arg3 , arg4 ) ; ready ( extend ( { } , defaults , args . config ) , args . path || lookup ( args . config , "baseUrl" ) , args . dependencies , args . closure ) ; return makeRequire ( args . config ) ; }
function showGame ( ) { document . onclick = null ; if ( menuLoop ) cancelAnimationFrame ( menuLoop ) ; document . onkeydown = gameKeydown ; document . onkeyup = gameKeyup ; gameLoop = requestAnimationFrame ( drawGame ) ; return false ; }
function ( evt ) { keydown = true ; keycode = evt . keyCode ; console . log ( String . fromCharCode ( keycode ) ) }
function chooseMap ( ) { var input = document . createElement ( 'input' ) ; input . setAttribute ( 'type' , 'file' ) ; input . setAttribute ( 'accept' , 'application/json' ) ; input . addEventListener ( 'change' , applyMap , false ) ; var evt = document . createEvent ( 'MouseEvents' ) ; evt . initMouseEvent ( 'click' , true , true , window , 0 , 0 , 0 , 0 , false , false , false , false , 0 , null ) ; input . dispatchEvent ( evt ) ; return false ; }
function UITitle ( text ) { function draw ( ctx ) { ctx . fillStyle = '#900' ; ctx . font = '100pt "Press Start 2P"' ; ctx . textAlign = 'center' ctx . fillText ( text , WIDTH / 2 , 270 ) ; } return new UIElement ( text , 0 , 0 , WIDTH , 80 , draw ) ; }
function ( ) { var $el = $ ( this . el ) ; $el . html ( this . template ( this . model . toJSON ( ) ) ) ; $el . toggleClass ( 'done' , this . model . get ( 'done' ) ) ; this . input = this . $ ( '.edit' ) ; return this ; }
function ( ) { this . input = this . $ ( "#new-todo" ) ; this . allCheckbox = this . $ ( "#toggle-all" ) [ 0 ] ; Todos . on ( 'add' , this . addOne , this ) ; Todos . on ( 'reset' , this . addAll , this ) ; Todos . on ( 'all' , this . render , this ) ; this . $footer = $ ( '#footer' ) ; this . $main = $ ( '#main' ) ; Todos . fetch ( ) ; }
function ( item ) { var index = item . getAttribute ( 'index' ) ; var disabled = item . getAttribute ( 'dis' ) ; if ( disabled == 1 ) { return ; } this . hideLayer ( ) ; this . setSelectedIndex ( parseInt ( index , 10 ) , true ) ; }
function validateEmail ( email ) { if ( email ) { for ( var domain in config . ALLOWED_DOMAINS ) { var canidate = config . ALLOWED_DOMAINS [ domain ] ; canidate = canidate . replace ( /[-[\]{}()*+?.,\\^$|#\s]/g , "\\$&" ) ; if ( email . match ( "^.*@" + canidate + "$" ) ) { return true ; } } } return false ; }
function ( ) { return $ ( "#resultText" ) . val ( cozy2md . translate ( $ ( "#resultText" ) . val ( ) ) ) ; }
function ( ) { id = $ ( this ) . parent ( ) . attr ( 'id' ) ; id = id . split ( '-' ) [ 1 ] ; $ ( '#item-' + id ) . remove ( ) ; }
function ( ) { args . css ( 'height' , height ( 37 ) ) ; hideAllWindows ( ) ; argsDiv . css ( 'display' , 'block' ) ; args . focus ( ) ; }
function ( ha_level ) { this . ha_level = ha_level ; if ( ha_level < 1 ) { Ext . MessageBox . alert ( 'Hak Akses' , 'Maaf, Anda tidak memiliki hak akses untuk melihat Safety Metrics!' ) ; this . panel . setDisabled ( true ) ; return ; } else { this . panel . setDisabled ( false ) ; } }
function ( text ) { var func = type . renderer ( id , text ) , d = new can . Deferred ( ) ; d . resolve ( func ) if ( $view . cache ) { $view . cached [ id ] = d ; } return d ; }
function showGame ( ) { console . log ( 'showGame' ) ; document . onclick = null ; if ( menuLoop ) cancelAnimationFrame ( menuLoop ) ; document . onkeydown = gameKeydown ; document . onkeyup = gameKeyup ; gameLoop = requestAnimationFrame ( drawGame ) ; return false ; }
function findCollision ( xOffset , yOffset ) { var tilesX = Math . round ( ( character . position . x + xOffset ) / 32 ) ; var tilesY = Math . round ( ( character . position . y + yOffset ) / 32 ) ; var location = world [ tilesY ] [ tilesX ] ; if ( location . collision ) location [ 0 ] . debug ( ) ; if ( frame % 30 === 0 ) { console . log ( location ) ; } return location . collision ; }
function ( ) { ctx . strokeStyle = 'red' ; ctx . strokeRect ( this . x + WIDTH / 2 - character . position . x , this . y + HEIGHT / 2 - character . position . y , this . w , this . h ) ; }
function ( ) { return $ ( "<div></div>" , { "class" : "select2-container" , "style" : "width: " + this . getContainerWidth ( ) } ) . html ( [ "    <a href='javascript:void(0)' class='select2-choice'><input type='text' class='select2-offscreen select2-focusser'/>" , "   <span></span><abbr class='select2-search-choice-close' style='display:none;'></abbr>" , "   <div><b></b></div>" , "</a>" , "    <div class='select2-drop' style='display:none;'>" , "   <div class='select2-search'>" , "       <input type='text' autocomplete='off' class='select2-input'/>" , "   </div>" , "   <ul class='select2-results'>" , "   </ul>" , "</div>" ] . join ( "" ) ) ; }
function ( ) { this . close ( ) ; this . selection . focus ( ) ; }
function ( data ) { var old = this . opts . element . val ( ) ; this . opts . element . val ( this . id ( data ) ) ; this . updateSelection ( data ) ; this . close ( ) ; this . selection . focus ( ) ; if ( ! equal ( old , this . id ( data ) ) ) { this . triggerChange ( ) ; } }
function ( cb ) { var self = this ; self . setVolume ( 70 ) ; this . increaser = setInterval ( function ( ) { self . setVolume ( self . volume ) ; self . volume += 1 ; if ( self . volume >= 100 ) { clearInterval ( self . increaser ) ; cb ( null ) ; } } , 1200 ) ; }
function ( ) { console . log ( 'launched' ) ; play . sound ( { file : __dirname + '/two.mp3' , volume : 0 , soundcard : 'hw:0,0' } ) ; play . increaseSlowly ( function ( ) { } ) ; }
function ( err , email , uid ) { if ( err ) { logger . warn ( "couldn't complete email verification: " + err ) ; wsapi . databaseDown ( res , err ) ; } else { delete req . session . pendingCreation ; wsapi . authenticateSession ( req . session , uid , 'password' , config . get ( 'ephemeral_session_duration_ms' ) ) ; res . json ( { success : true } ) ; } }
function ( ) { var pack = this . template . cloneNode ( true ) ; pack . id = 'package_block_' + ++ this . packageIncrement ; pack . addClassName ( 'package-block' ) ; pack . select ( '.package-number span' ) [ 0 ] . update ( this . packageIncrement ) ; this . packagesContent . insert ( { top : pack } ) ; pack . select ( '.AddSelectedBtn' ) [ 0 ] . hide ( ) ; pack . show ( ) ; }
function getProjectDir ( directory ) { if ( directory ) { var pp = path . join ( directory , 'package.json' ) ; if ( path . existsSync ( pp ) ) { return directory ; } else { return getProjectDir ( path . dirname ( directory ) ) ; } } else { return getProjectDir ( getProject ( ) . id ) ; } }
function ( ) { mediator . publish ( "kpi_data" , { number_emails : 1 } ) ; testHelpers . testObjectValuesEqual ( controller . getCurrent ( ) , { number_emails : 1 } ) ; start ( ) ; }
function ( ) { createController ( ) ; network . withContext ( function ( ) { mediator . publish ( "kpi_data" , { number_emails : 1 } ) ; testHelpers . testObjectValuesEqual ( controller . getCurrent ( ) , { number_emails : 1 } ) ; start ( ) ; } ) ; }
function loadFromDirectory ( dir ) { var newData = this . parseBestMatch ( pathUtils . join ( dir , this . file ) ) ; this . result = Object . merge ( newData , this . result ) ; if ( this . options . debug ) console . error ( 'Loading config from "' + dir + '", now having' , newData ) ; return this ; }
function ( ) { it ( 'should log without doing anything bad' , function ( ) { var visited = false , prevLog = console . error ; console . error = function ( ) { visited = true ; } new ConfigLoader ( { debug : true } ) . load ( CONFIG_FILE ) ; console . error = prevLog ; assert ( visited , 'Nothing was logged in debug mode!' ) ; } ) }
function ( info ) { if ( info . type === "primary" ) { createPrimaryUser . call ( self , info , oncomplete ) ; } else { enterPasswordState . call ( self , info ) ; oncomplete && oncomplete ( ! isRegistered ) ; } }
function ( ) { doc . location . href = redirectTo ; complete ( oncomplete , verified ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { testEmail ( ) ; ok ( $ ( ".siteinfo" ) . is ( ":visible" ) , "siteinfo is visible when we say what it is" ) ; equal ( $ ( ".website:nth(0)" ) . text ( ) , returnTo , "website is updated" ) ; testHasClass ( "body" , "complete" ) ; equal ( doc . location . href , returnTo , "redirection occurred to correct URL" ) ; equal ( storage . getLoggedIn ( "https://test.domain" ) , "testuser@testuser.com" , "logged in status set" ) ; start ( ) ; }
function startService ( name , options ) { if ( runningService ) { serviceManager . stop ( runningService ) ; } var module = serviceManager . start ( name , options ) ; if ( module ) { runningService = name ; } mediator . publish ( "service" , { name : name } ) ; bid . resize ( ) ; return module ; }
function ( options ) { var self = this , templateData = helpers . extend ( { } , options , { privacy_url : options . privacyURL || null , tos_url : options . tosURL || null } ) ; self . renderDialog ( "add_email" , templateData ) ; self . click ( "#cancel" , cancelAddEmail ) ; Module . sc . start . call ( self , options ) ; }
function onAddressInfo ( info ) { addressInfo = info ; if ( info . type === "primary" ) { self . close ( "primary_user" , info , info ) ; } else if ( info . known ) { enterPasswordState . call ( self ) ; } else { createSecondaryUser . call ( self ) ; } }
function ( e ) { this . list . removeClass ( this . oCss . e ) ; this . list . fireEvent ( "blur" , e ) ; document . removeEvent ( "keydown" , this . fnNavigate ) ; }
function ( e ) { var oTarget = ( e . target == oLI ) ? e . target : oLI ; if ( ! oTarget . hasClass ( this . oCss . d ) ) { if ( e . control ) { oTarget . addClass ( this . oCss . c ) ; } else { this . _fnAlterClass ( oTarget , aLI , this . oCss . c ) ; } this . _setSelected ( ) ; this . list . fireEvent ( "focus" , e ) ; } }
function ia_init ( ) { eval ( "ia_green_update=function (green) {var me=green;" + document . getElementById ( "code" ) . value + "}" ) ; }
function ( ) { if ( ! lockslide ) { } lockslide = false ; inanimation = false ; }
function ( event , callback ) { var iframeUrl = mw . getMwEmbedPath ( ) + 'mwEmbedFrame.php' ; iframeUrl += '/wid/' + embedPlayer . kwidgetid + '/uiconf_id/' + embedPlayer . kuiconfid + '/entry_id/' + embedPlayer . kentryid + '/' + '?' + kWidget . flashVarsToUrl ( ctrlObj . embedPlayer . getFlashvars ( ) ) ; callback ( iframeUrl ) ; }
function drawLines ( context , x , y , width ) { for ( var j = 0 ; j < context . nb_cordes ; j ++ ) { context . svg . line ( x , y + ( j * 10 ) , x + width , y + ( j * 10 ) , { stroke : "black" } ) ; } }
function is_wrong_value ( val ) { var possibilities = [ 4 , 2 , 1 , 0.5 , 0.25 , 0.125 , 0.0625 ] ; for ( var i = 0 ; i < 7 ; i ++ ) { if ( val == possibilities [ i ] ) { return null ; } } alert ( "wrong value  :" + val ) ; return null ; }
function get_first_duration ( duration ) { var possibilities = [ 4 , 2 , 1 , 0.5 , 0.25 , 0.125 , 0.0625 ] ; for ( var i = 0 ; i < 7 ; i ++ ) { if ( Math . floor ( duration / possibilities [ i ] ) != 0 ) { return possibilities [ i ] ; } } alert ( "wrong value" ) ; return null ; }
function ( params ) { var x = new XMLHttpRequest ( ) ; x . open ( params . method || 'get' , params . uri , true ) ; x . addEventListener ( 'load' , function ( e ) { params . successCallback ( x . response ) ; } , false ) ; x . send ( params . data ) ; return x ; }
function ( global ) { 'use strict' ; var xhr = function ( params ) { var x = new XMLHttpRequest ( ) ; x . open ( params . method || 'get' , params . uri , true ) ; x . addEventListener ( 'load' , function ( e ) { params . successCallback ( x . response ) ; } , false ) ; x . send ( params . data ) ; return x ; } ; return xhr ; }
function ( ) { var developerNames = $ ( '#modal .developer_names_form' ) . find ( 'input[type="text"]' ) ; var developerNamesList = [ ] ; $ ( developerNames ) . each ( function ( ) { var developerName = this . value . trim ( ) ; if ( ! ( developerName == "" ) ) { developerNamesList . push ( developerName ) ; } } ) if ( developerNamesList . length > 0 ) { create_cookies_initial_data_and_write_to_cookies ( developerNamesList ) ; hide_modal ( ) ; window . location . reload ( ) } }
function add_new_developer ( ) { var newDevName = $ ( '#add_new_dev_modal .developer_name' ) . find ( 'input[type="text"]' ) [ 0 ] . value ; var devNames = read_cookie ( dev_names_cookie_names ) ; var newDevNamesList = "" ; $ ( devNames ) . each ( function ( index , value ) { newDevNamesList += value + "," ; } ) ; newDevNamesList += newDevName ; update_dev_names_cookie ( newDevNamesList ) ; window . location . reload ( ) ; }
function ( ) { var data = read_cookie ( pair_cookie_name ) ; if ( data == null ) { show_popup_modal ( ) return } construct_pair_ladder ( ) ; $ ( "#pair_ladder_table .remove_developer" ) . click ( function ( ) { remove_a_dev ( this ) ; return false ; } ) ; var resizeTimer ; $ ( window ) . resize ( function ( ) { clearTimeout ( resizeTimer ) ; resizeTimer = setTimeout ( construct_pair_ladder , 1000 ) ; } ) ; init_hover_animation ( ) ; }
function soundManager_repeatKey ( callback ) { callback ( ) ; clearTimeout ( this . _timer ) ; if ( ! this . kRepeatTimeout ) return ; this . _timer = window . setTimeout ( ( function volumeTimeout ( ) { actionCallback ( ) ; this . _timer = setInterval ( function volumeInterval ( ) { callback ( ) ; } , this . kRepeatRate ) ; } ) . bind ( this ) , this . kRepeatTimeout ) ; }
function ( response , request ) { Ext . Viewport . unmask ( ) ; if ( response . result != 'OK' ) { Ext . Msg . alert ( 'Login Error' , response . message , Ext . emptyFn ) ; } else { Ext . Msg . alert ( 'Login OK' ) ; var locationsStore = Ext . getStore ( 'Locations' ) ; locationsStore . load ( ) ; } }
function ( error ) { if ( tries > 10 ) { errorFinish ( ) ; } else { console . error ( error . message ) ; console . error ( error . stack ) ; tries ++ ; console . error ( "asset retry(" + tries + ") '" + url + "'" ) ; setTimeout ( fetchFileAndFinish , 500 ) ; } }
function ( ) { clearAbortTimer ( ) ; if ( fileBuffer === null ) { errorFinish ( ) ; } else { try { var newbuf = new Buffer ( fileBuffer ) . slice ( 0 , fileWritten ) ; callback ( originalUrl , newbuf , statusCode , mimeType ) ; } catch ( e ) { console . error ( e . message ) ; console . error ( e . stack ) ; errorFinish ( ) ; } } }
function ( status ) { status = status || 500 ; console . error ( new Date ( ) ) ; console . error ( "errorFinish(" + status + ")" ) ; console . trace ( ) ; var newbuf = new Buffer ( 0 ) ; callback ( originalUrl , newbuf , status ) ; }
function ( buffer , contentType , httpStatusCode ) { try { response . writeHead ( httpStatusCode , { 'Content-Type' : contentType , 'Content-Length' : buffer . length , 'Cache-Control' : 'max-age=2592000' } ) ; options . stats . dataCount [ request . connection . remoteAddress ] += buffer . length ; response . end ( buffer , 'binary' ) ; } catch ( e ) { } }
function ( err , type ) { if ( err ) { cb ( err ) ; } else { gs . close ( function ( ) { cb ( null , new Buffer ( data ) , type ) ; gs . collection ( function ( err , collection ) { if ( ! err ) { increaseAccessCount ( filename , collection ) ; } } ) ; } ) ; } }
function ( headers ) { var newheaders = { } ; for ( var i in headers ) { newheaders [ i ] = headers [ i ] ; } if ( newheaders . location ) { newheaders . location = that . getNewResponseLocationField ( newheaders . location ) ; } newheaders [ 'content-length' ] = that . soupData . length ; return newheaders ; }
function ( data ) { var buf = null ; data = data . toString ( ) ; if ( isRss ( data ) ) { buf = modifyRssAndReturnBuffer ( data ) ; } else if ( isHtml ( data ) ) { buf = modifyHtmlAndReturnBuffer ( data ) ; } else { buf = new Buffer ( replaceSoupLinksInString ( data ) ) ; } callback ( buf ) ; }
function ( headers ) { headers = that . setAcceptEncoding ( headers ) ; headers = that . setNewRequestHost ( headers ) ; headers = that . setNewReferrer ( headers ) ; return headers ; }
function ( chunk ) { try { var newbuf = new Buffer ( that . soupData . length + chunk . length ) ; that . soupData . copy ( newbuf , 0 , 0 ) ; newbuf . write ( chunk , that . soupData . length , chunk . length , 'binary' ) ; that . soupData = newbuf ; } catch ( e ) { console . error ( e . message ) ; console . error ( e . stack ) ; } }
function ( data ) { that . soupData = data ; that . writeResponseHead ( ) ; if ( data . length > 0 ) { options . stats . dataCount [ that . request . connection . remoteAddress ] += data . length ; that . response . write ( data ) ; } that . response . end ( ) ; }
function ( ) { that . writeResponseHead ( ) ; if ( that . soupData . length > 0 && that . request . method != 'HEAD' ) { var data = that . soupData ; options . stats . dataCount [ that . request . connection . remoteAddress ] += that . soupData . length ; that . response . write ( data ) ; } that . response . end ( ) ; }
function ( ) { var now = new Date ( ) ; var diff = ( now - start ) / 1000 / 60 ; var s = 'redirects: ' + ( options . stats . redirects || 0 ) + '\n' ; var reqs = ( options . stats . requests || 0 ) ; var rpm = Math . floor ( ( reqs / diff ) * 10 ) / 10 ; s += 'requests: ' + reqs + ' ' + rpm + '/min' ; return s ; }
function ( request , response ) { var html = "<html><head>" ; html += '<script type="text/javascript">' + '   console.log("autorefresh");' + '   window.setTimeout(function() {' + '       window.location.reload(true)' + '   }, 2000);' + '</script>' ; html += "</head><body>" + options . statPrinter . getStatus ( ) . replace ( / /g , "&nbsp;" ) . replace ( /\n/g , "<br/>" ) + "</body></html>" ; response . writeHead ( 200 , { 'Content-Length' : html . length , 'Content-Type' : 'text/html' } ) ; response . end ( html ) ; }
function ( ) { if ( $ ( this ) . text ( ) . match ( matcher ) ) { $ ( input ) . val ( $ ( this ) . text ( ) ) ; this . selected = valid = true ; var option = $ ( this ) $ ( self . element ) . trigger ( "autocomplete-selected" , event , { item : option } ) ; return false ; } }
function ( ) { this . loader = new Backbone . Notifier ( { el : this . $el , position : 'center' , loader : true , message : 'loading...' , ms : null , modal : true } ) ; this . loader . notify ( { } ) ; window . parseCommitHistory = $ . proxy ( this . parseResponse , this ) ; jQuery . ajax ( { url : 'https://api.github.com/repos/ewebdev/backbone.notifier/commits?callback=parseCommitHistory' , dataType : "jsonp" , jsonp : true } ) ; }
function ( ) { if ( this . _cssPos === 'absolute' ) { return this . attributes . zIndex ; } var z = this . attributes . zIndex + 1 , scope = this ; _ . each ( scope . current , function ( view ) { z = view . zIndex > z ? view . zIndex : z ; } ) ; return ++ z ; }
function ( view ) { if ( view . settings [ keyFilter ] === valueFilter ) { view . destroy . call ( view ) ; i ++ ; } }
function initializeSearchPane ( ) { var icons = { header : "ui-icon-circle-arrow-e" , headerSelected : "ui-icon-circle-arrow-s" } ; $ ( '#search-section' ) . accordion ( { collapsible : true , icons : icons , change : function ( event , ui ) { if ( ui . options . active == 0 ) $ ( '#search-section-header' ) . text ( "Show Search Pane" ) ; else $ ( '#search-section-header' ) . text ( "Hide Search Pane" ) ; } } ) ; $ ( '#search-section' ) . accordion ( "option" , "active" , true ) ; }
function ( event ) { if ( myFormat . name == "HTML" ) { builder . dialogs . exportscript . do_export_sel1 ( myFormat ) ; } else { builder . dialogs . rc . show ( builder . dialogs . exportscript . node , null , function ( hostPort , browserString ) { builder . dialogs . exportscript . do_export_sel1 ( myFormat , hostPort , browserString ) ; } , "Save" ) ; } }
function ( ) { builder . dialogs . runall . requestStop = true ; jQuery ( '#edit-suite-playing' ) . hide ( ) ; jQuery ( '#edit-suite-stopping' ) . show ( ) ; try { builder . dialogs . runall . currentPlayback . stopTest ( ) ; } catch ( e ) { } }
function ( elem , options ) { if ( elem instanceof jQuery ) { elem = $ ( elem ) . get ( 0 ) ; } var defaults = { skelton : true } ; var opts = $ . extend ( defaults , options ) ; var lessObj = makeLessObj ( elem , null , opts ) ; less_src = generate ( lessObj , opts ) ; return less_src ; }
function makeLessSrc ( lessObj , options ) { for ( var i in lessObj ) { if ( i == "@style" ) continue ; dist += indent ( depth ) + ( i + "{\n" ) + indent ( depth + 1 ) + ( lessObj [ i ] [ "@style" ] || '' ) + "\n" ; depth ++ ; makeLessSrc ( lessObj [ i ] , options ) ; depth -- ; dist += indent ( depth ) + "}\n" ; } }
function ( ) { $ ( ".nano" ) . nanoScroller ( ) ; }
function ( ) { var loader , shaderUniforms ; this . shaderUniforms = shaderUniforms = { normal : { type : "t" , value : 0 , texture : THREE . ImageUtils . loadTexture ( "resources/normal.png" ) } , time : { type : "f" , value : 1.0 } } ; loader = new THREE . CTMLoader ( this . renderer . context ) ; loader . load ( "resources/map1.ctm" , this . onMeshLoaded , false , false ) ; }
function ( ) { if ( ! app . base . pageView . prototype . initialize . apply ( this , arguments ) ) { return false ; } if ( _ . isFunction ( this . saved ) ) { this . model . once ( 'saved' , this . saved ) ; } if ( _ . isFunction ( this . error ) ) { this . model . bind ( 'error' , this . error ) ; } }
function ( html ) { this . $el . html ( html ) ; this . handler = new app . formHandler ( this ) ; this . handler . link ( ) ; }
function ( responses ) { if ( responses && responses . length > 0 ) { var html = responses [ 0 ] . formatted_address ; updateInfoWindow ( html ) ; } else { $ ( window ) . trigger ( 'show.mapsnotification.sakai' , { subject : sakai . api . i18n . Widgets . getValueForKey ( 'googlemaps' , 'NO_ADDRESS' ) , body : sakai . api . i18n . Widgets . getValueForKey ( 'googlemaps' , 'CANNOT_DETERMINE_ADDRESS_AT_THIS_LOCATION' ) } ) ; } }
function swap ( ele , options , callback ) { var defaultVal = { } , result ; for ( var i in options ) { defaultVal [ i ] = ele . style [ i ] ; ele . style [ i ] = options [ i ] ; } result = callback . call ( ele ) ; for ( var i in options ) { ele . style [ i ] = defaultVal [ i ] ; } return result ; }
function ( val ) { if ( ! ~ delString . indexOf ( val ) ) { rect += parseFloat ( tang . getCurrentStyle ( val + cssExpand [ 0 ] ) ) || 0 ; rect += parseFloat ( tang . getCurrentStyle ( val + cssExpand [ 1 ] ) ) || 0 ; } else { delString = delString . replace ( new RegExp ( '\\|?' + item + '\\|?' ) , '' ) ; } }
function testGet ( tag ) { var el = create ( tag ) ; equal ( baidu . dom ( el ) . outerWidth ( ) , 100 , "check " + tag + " outerWidth()" ) ; equal ( baidu . dom ( el ) . outerWidth ( true ) , 120 , "check " + tag + " outerWidth( true )" ) ; el . parentNode . removeChild ( el ) ; }
function create ( tag ) { var layer = document . createElement ( tag ) ; layer . style . width = layer . style . height = layer . style . margin = layer . style . padding = "20px" ; layer . style . border = "20px solid #fff" ; document . body . appendChild ( layer ) ; return layer ; }
function ( ) { equal ( baidu . dom ( window ) . width ( ) , document . body . clientWidth , "window" ) ; equal ( baidu . dom ( document ) . width ( ) , document . body . clientWidth , "document" ) ; }
function create ( tag ) { if ( typeof tag == "object" ) return tag ; var el = document . createElement ( tag ) ; var parent ; el . style . width = el . style . height = "0" ; el . style . overflow = "hidden" ; if ( tag == "body" ) { parent = document . documentElement ; } else { parent = document . body ; } parent . appendChild ( el ) ; return el ; }
function ( ele ) { return baidu . dom . _getWidthOrHeight ( ele , item ) + 'px' ; }
function ( ) { equal ( baidu . dom ( window ) . height ( ) , document . body . clientHeight , "window" ) ; equal ( baidu . dom ( document ) . height ( ) , document . body . clientHeight , "document" ) ; }
function testGet ( tag ) { var el = create ( tag ) ; equal ( baidu . dom ( el ) . innerHeight ( ) , 60 , "check " + tag + " innerHeight" ) ; el . parentNode . removeChild ( el ) ; }
function create ( tag ) { var layer = document . createElement ( tag ) ; layer . style . width = layer . style . height = layer . style . margin = layer . style . padding = "20px" ; layer . style . border = "20px solid #fff" ; document . body . appendChild ( layer ) ; return layer ; }
function testGet ( tag ) { var el = create ( tag ) ; equal ( baidu . dom ( el ) . innerWidth ( ) , 60 , "check " + tag + " innerWidth" ) ; el . parentNode . removeChild ( el ) ; }
function create ( tag ) { var layer = document . createElement ( tag ) ; layer . style . width = layer . style . height = layer . style . margin = layer . style . padding = "20px" ; layer . style . border = "20px solid #fff" ; document . body . appendChild ( layer ) ; return layer ; }
function testGet ( tag ) { var el = create ( tag ) ; equal ( baidu . dom ( el ) . outerHeight ( ) , 100 , "check " + tag + " outerHeight()" ) ; equal ( baidu . dom ( el ) . outerHeight ( true ) , 120 , "check " + tag + " outerHeight( true )" ) ; el . parentNode . removeChild ( el ) ; }
function create ( tag ) { var layer = document . createElement ( tag ) ; layer . style . width = layer . style . height = layer . style . margin = layer . style . padding = "20px" ; layer . style . border = "20px solid #fff" ; document . body . appendChild ( layer ) ; return layer ; }
f var alias = alias || 'value' , key = key && key . substr ( 1 ) ; var _iterate = 'i' + _counter ++ ; return '<% for(var ' + _iterate + ' in ' + _name + ') {' + 'if(' + _name + '.hasOwnProperty(' + _iterate + ')) {' + 'var ' + alias + '=' + _name + '[' + _iterate + '];' + ( key ? ( 'var ' + key + '=' + _iterate + ';' ) : '' ) + '}' + ' %>' ; } )
function ( n ) { return n > 9 ? n : "0" + n }
function ( ) { var t = this , f = t . clone ( ) , i = 0 , e ; f [ P ] = Object . create ( t [ P ] ) ; while ( e = arguments [ i ++ ] ) for ( t in e ) if ( e . hasOwnProperty ( t ) ) f [ P ] [ t ] = e [ t ] ; return f ; }
function ( steps , units ) { }
function ( name , attr ) { var t = this , n = typeof ( name ) == "string" ? new XML . node ( name , attr ) : name n . up = t n . root = t . root n . id = t . childs . length t . childs [ n . id ] = n return n }
function ( ev ) { var t = this ; if ( "_e" in t && ev in t . _e ) { for ( var i = 0 , e = t . _e [ ev ] , a = e . slice . call ( arguments , 1 ) ; ev = e [ i ++ ] ; ) ev [ 0 ] . apply ( ev [ 1 ] || t , a ) ; } return t ; }
function ( ) { var a = arguments , i = ! ! instance || this instanceof f , k = keyFn ? keyFn ( a , t ) : i + ":" + a . length + ":" + A . join . call ( a ) return k in c ? c [ k ] : ( c [ k ] = i ? t . construct ( a ) : t . apply ( this , a ) ) }
function ( ) { var t = this , f = t . clone ( ) , i = 0 , e f [ P ] = Object . create ( t [ P ] ) while ( e = arguments [ i ++ ] ) for ( t in e ) if ( e . hasOwnProperty ( t ) ) f [ P ] [ t ] = e [ t ] ; return f }
function ( o ) { var s = this , a = arguments , r if ( typeof o == "object" ) Object . each ( o , function ( v , k ) { a [ 0 ] = k a [ 1 ] = v r = t . apply ( s , a ) } ) else r = t . apply ( s , a ) return r }
function ( ) { clearTimeout ( s ) ms && t . apply ( null , arguments ) }
function ( ms ) { var t = this , n = 0 return function ( ) { var d = + new Date if ( d > n ) { n = d + ms t . apply ( null , arguments ) } } }
function ( ) { return this . replace ( /&/g , "&amp;" ) . replace ( /</g , "&lt;" ) . replace ( />/g , "&gt;" ) . replace ( /\"/g , "&quot;" ) }
function ( ) { var t = ( this + ".0.0.0" ) . split ( "." ) return ( ( t [ 0 ] << 24 ) | ( t [ 1 ] << 16 ) | ( t [ 2 ] << 8 ) | ( t [ 3 ] ) ) >>> 0 }
function ( ) { return ( new Date ( this . getFullYear ( ) , this . getMonth ( ) + 1 , 0 ) ) . getDate ( ) }
function uncacheEvent ( el , type , fn ) { var _e = el . _e || { } if ( type in _e && "_fn_id" in fn && fn . _fn_id in _e [ type ] ) { var _fn = _e [ type ] [ fn . _fn_id ] delete _e [ type ] [ fn . _fn_id ] return _fn } return fn }
function ( el , ev , fn ) { var _fn = cacheEvent ( el , ev , fn , fn ) ev == "mousewheel" && el . addEventListener ( "DOMMouseScroll" , _fn , false ) el . addEventListener ( ev , _fn , false ) return Event }
function ( el , ev , fn ) { var _fn = uncacheEvent ( el , ev , fn ) ev == "mousewheel" && el . removeEventListener ( "DOMMouseScroll" , _fn , false ) el . removeEventListener ( ev , _fn , false ) return Event }
function ( e ) { if ( "changedTouches" in e ) e = e . changedTouches [ 0 ] return e . pageY || e . clientY + d . body . scrollTop || 0 }
function ( item ) { var t = this , m = item . lists ; if ( m . length != m . remove ( t ) . length ) { t . items . remove ( item ) ; t . trigger ( "remove" , item ) ; } }
function ( ) { return new qx . ui . mobile . container . Scroll ( ) ; }
function ( e ) { if ( _pasteMetaKeyPressed && ( e . which == 91 || e . which == 86 ) ) $ ( this ) . blur ( ) ; window . setTimeout ( function ( ) { _pasteMetaKeyPressed = e . metaKey ; } , 250 ) ; }
function ( error , results ) { console . log ( error ) ; console . log ( results ) ; callback ( error , results ) ; }
function ( err , data ) { console . log ( 'collection error' ) ; console . log ( err ) ; var o_id = m . ObjectID . createFromHexString ( id ) ; data . findOne ( { _id : o_id } , function ( err , result ) { console . log ( err ) ; console . log ( result ) ; callback ( result ) ; } ) ; }
function execute ( ) { var stmt , result = [ ] ; while ( this . trimCr ( ) , stmt = this . parseStatement ( ) ) { result . push ( stmt ) ; } if ( this . peek ( ) . type !== 'end' ) { if ( ! this . error ) throw new Error ( 'Unexpected parser error!' ) ; throw new Error ( 'Parser failed at: ' + this . error . offset + '\n' + this . error . message ) ; } return result ; }
function ( textStatus , response ) { self . _subject . removeClass ( self . UI_CLASS + '-waiting' ) ; waitMsg . remove ( ) ; self . _toolbar . _elem . show ( ) ; self . _apiCallErr ( textStatus , response , apiAction ) ; }
function changeSelectedEarthquake ( value ) { if ( ! isSelectable [ value ] || value == selectedEarthquake ) return ; selectedEarthquake = value table = document . getElementById ( "earthquakeTable" ) ; earthquakes = table . getElementsByTagName ( "tr" ) ; earthquakes [ value ] . className = "highlight" ; earthquakes [ selectedEarthquake ] . className = "" ; }
function ( ) { console . log ( "highlight" ) ; if ( earthquake . className == "highlight" ) earthquake . className = "" ; else earthquake . className = "highlight" ; if ( selectedEarthquake == 1 ) { earthquake . className = "highlight" ; tutorial . eventFinished ( ) ; window . clearInterval ( interval ) ; } }
function addButton ( title , parent , onClickFunction ) { var button = document . createElement ( "button" ) ; button . textContent = title ; button . onclick = onClickFunction ; button . setAttribute ( "id" , title ) ; parent . appendChild ( button ) ; }
function ( i ) { var t = $ ( this ) , cell = $ ( 'li[data-val="' + that . temp [ i ] + '"]' , t ) , x = cell . index ( ) , v = scrollToValid ( cell , x , i , dir ) , sc = i == index || index === undefined ; if ( x != v || sc ) that . scroll ( $ ( this ) , v , sc ? time : 0 , orig , i ) ; }
function ( ) { var v = $ ( this ) . attr ( 'value' ) ; main [ '_' + v ] = $ ( this ) . text ( ) ; if ( $ ( this ) . prop ( 'disabled' ) ) invalid . push ( v ) ; }
function ( ) { $ ( this ) . parent ( ) . children ( '.msg_head' ) . css ( 'background-image' , 'url("../images/div_opened.gif")' ) ; $ . cookies . set ( key , $ ( this ) . css ( 'display' ) ) ; }
function ( event ) { event . stopPropagation ( ) ; that . sortList ( listProps . colModel [ i ] , this ) ; }
function ( string ) { var u = url . parse ( string ) ; if ( u . pathname == '/' ) { u . path_as_array = [ ] ; } else { u . path_as_array = u . pathname . split ( '/' ) ; u . path_as_array . shift ( ) ; } return u ; }
function ( user , repo , cb ) { $ . ajax ( { url : 'http://github.com/api/v2/json/commits/list/' + user + '/' + repo + '/master' , dataType : 'jsonp' , success : function ( json ) { var latest = json . commits [ 0 ] ; cb ( latest ) ; } } ) ; }
function ( user , repo , cb ) { $ . ajax ( { url : 'http://github.com/api/v2/json/commits/list/' + user + '/' + repo + '/master' , dataType : 'jsonp' , success : function ( json ) { var latest = json . commits [ 0 ] ; cb ( latest ) ; } } ) ; }
function ( ) { el = $ ( '<div></div>' ) ; options = { max : 37 , min : 6 , orientation : 'horizontal' , step : 1 , value : 50 } ; el . slider ( options ) ; ok ( el . slider ( "option" , "value" ) === options . value , "value option is not contained by max" ) ; ok ( el . slider ( "value" ) === options . max , "value method is contained by max" ) ; el . slider ( 'destroy' ) ; }
function ( ) { el = $ ( '<div></div>' ) ; options = { max : 37 , min : 6 , orientation : 'vertical' , step : 1 , value : 2 } ; el . slider ( options ) ; ok ( el . slider ( "option" , "value" ) === options . value , "value option is not contained by min" ) ; ok ( el . slider ( "value" ) === options . min , "value method is contained by min" ) ; el . slider ( 'destroy' ) ; }
function ( ) { spyOnPromise ( Mongo , 'deleteTarget' ) . andCallSuccess ( ) ; spyOnPromise ( Mongo , 'findTargetById' ) . andCallSuccess ( ) ; spyOnPromise ( Mongo , 'deleteTargetById' ) . andCallSuccess ( ) ; req . params . id = '12345678901234567890abcd' ; API . deleteTarget ( req , res , next ) ; expect ( Mongo . deleteTargetById ) . toHaveBeenCalledWith ( '12345678901234567890abcd' ) ; expectStatus ( res ) . toEqual ( 204 ) ; }
function ( e ) { if ( isDragging ) { resizingL = false ; resizingR = false resizingB = false ; resizingT = false ; resizingM = false ; if ( ! draggingBar ) { kb . resizeHeight ( ) ; } kb . html . style . zIndex = _oldZIndex ; kb . html . focus ( ) ; document . onmousemove = null ; document . onselectstart = null ; isDragging = false ; isDragged = true ; } }
function formatToURL ( hash ) { if ( TDConfig ( "rest.port" ) == 80 ) { return "http://" + TDConfig ( "rest.host" ) + "/" + hash ; } else { return "http://" + TDConfig ( "rest.host" ) + ":" + TDConfig ( "rest.port" ) + "/" + hash ; } }
function _push ( message ) { if ( isLocalSocket ) { _pushLocal ( message ) ; } else if ( _activeRequest != null || _sse != null ) { _pushAjaxMessage ( message ) ; } else if ( _ieStream != null ) { _pushIE ( message ) ; } else if ( _jqxhr != null ) { _pushJsonp ( message ) ; } else if ( _websocket != null ) { _pushWebSocket ( message ) ; } }
function ( ) { var _ref ; return { nodeType : this . className , isOwn : this . isOwn , keyAssignee : this . keyAssignee . toJSON ( ) , valAssignee : ( _ref = this . valAssignee ) != null ? _ref . toJSON ( ) : void 0 , expression : this . expr . toJSON ( ) , filterExpression : this . filterExpr . toJSON ( ) , block : this . block . toJSON ( ) } ; }
function ( offset , line , column , ws0 , args , ws1 ) { var raw = "[" + ws0 + args . raw + ws1 + "]" ; args = args ? args . list : [ ] ; return new Nodes . ArrayInitialiser ( args ) . r ( raw ) . p ( line , column ) ; }
function ( offset , line , column , ws , members , t ) { var raw = "{" + ws + ( members ? members [ 0 ] . raw + members [ 1 ] : '' ) + t + "}" ; members = members ? members [ 0 ] . list : [ ] ; return new Nodes . ObjectInitialiser ( members ) . r ( raw ) . p ( line , column ) ; }
function ( ) { this . timeout ( 1 ) ; var r = recur ( ) . on ( 7 ) . hour ( ) ; var start = new Date ( '2012-02-28T22:34:15Z' ) ; var expected = new Date ( '2012-02-29T07:00:00Z' ) ; var l = later ( ) . getNext ( r , start ) ; l . should . eql ( expected ) ; }
function ( ) { this . timeout ( 1 ) ; var r = recur ( ) . on ( 6 ) . hour ( ) ; var start = new Date ( '2012-012-31T23:42:15' ) ; var expected = new Date ( '2013-01-01T06:00:00' ) ; var l = later ( 1 , true ) . getNext ( r , start ) ; l . should . eql ( expected ) ; }
function ( ) { this . timeout ( 1 ) ; var r = recur ( ) . at ( '09:14:21' ) var start = new Date ( '2012-012-31T23:42:15' ) ; var expected = new Date ( '2013-01-01T09:14:21' ) ; var l = later ( 1 , true ) . getNext ( r , start ) ; l . should . eql ( expected ) ; }
function ( ) { this . timeout ( 1 ) ; var r = recur ( ) . on ( 4 ) . dayOfWeek ( ) ; var start = new Date ( '2012-012-31T23:42:15Z' ) ; var expected = new Date ( '2013-01-02T00:00:00Z' ) ; var l = later ( ) . getNext ( r , start ) ; l . should . eql ( expected ) ; }
function ( ) { this . timeout ( 1 ) ; var r = recur ( ) . on ( 4 ) . dayOfWeekCount ( ) ; var start = new Date ( '2012-012-31T23:42:15Z' ) ; var expected = new Date ( '2013-01-22T00:00:00Z' ) ; var l = later ( ) . getNext ( r , start ) ; l . should . eql ( expected ) ; }
function ( ) { this . timeout ( 1 ) ; var r = recur ( ) . on ( 6 ) . dayOfMonth ( ) ; var start = new Date ( '2012-012-31T23:42:15Z' ) ; var expected = new Date ( '2013-01-06T00:00:00Z' ) ; var l = later ( ) . getNext ( r , start ) ; l . should . eql ( expected ) ; }
function ( ) { this . timeout ( 1 ) ; var r = recur ( ) . on ( 7 ) . month ( ) ; var start = new Date ( '2012-012-31T23:42:15Z' ) ; var expected = new Date ( '2013-07-01T00:00:00Z' ) ; var l = later ( ) . getNext ( r , start ) ; l . should . eql ( expected ) ; }
function ( ) { this . timeout ( 1 ) ; var r = recur ( ) . on ( 12 ) . dayOfYear ( ) ; var start = new Date ( '2012-012-31T23:42:15Z' ) ; var expected = new Date ( '2013-01-12T00:00:00Z' ) ; var l = later ( ) . getNext ( r , start ) ; l . should . eql ( expected ) ; }
function ( ) { this . timeout ( 1 ) ; var r = recur ( ) . on ( 6 ) . hour ( ) ; var start = new Date ( '2012-06-05' ) ; var expected = new Date ( '2012-06-05T06:00:00' ) ; var l = later ( 1 , true ) . getNext ( r , start ) ; l . should . eql ( expected ) ; }
function ( event ) { var sCursorStyle = 'default' ; if ( oDynamicTable . oTableResizeHandleData ) { return ; } sBoundaryLocation = MouseLocationDetector . getCoveredBoundaries ( event , this ) ; if ( sBoundaryLocation == 's' || sBoundaryLocation == 'se' || sBoundaryLocation == 'e' ) { sCursorStyle = sBoundaryLocation + '-resize' ; } jQuery ( 'body' ) . css ( 'cursor' , sCursorStyle ) ; }
function ( event ) { var sCursorStyle = 'default' ; if ( oDynamicTable . oTableDragHandleData ) { return ; } sBoundaryLocation = MouseLocationDetector . getCoveredBoundaries ( event , this ) ; if ( sBoundaryLocation == 'n' ) { sCursorStyle = 'move' ; } jQuery ( 'body' ) . css ( 'cursor' , sCursorStyle ) ; }
function dh_thisWeekStarted ( ) { var now = new Date ( ) ; var dayOfTheWeek = now . getDay ( ) ; var offset = 1 - dayOfTheWeek ; var firstDay = now . valueOf ( ) + offset * 86400000 ; return this . getMidnight ( firstDay ) ; }
function ( ) { var now = new Date ( ) ; var weekStartedTimestamp = DateHelper . thisWeekStarted ( ) ; var weekStarted = new Date ( weekStartedTimestamp ) ; assert . equal ( true , weekStartedTimestamp <= now . valueOf ( ) ) ; assert . equal ( weekStarted . getDay ( ) , 1 ) ; assertMidnight ( weekStarted ) ; }
function testGeocode ( address ) { geocoder = new google . maps . Geocoder ( ) ; geocoder . geocode ( { 'address' : address } , function ( results , status ) { if ( status == google . maps . GeocoderStatus . OK ) { return true ; } else { return false ; } } ) ; }
function ( ) { if ( this . _highlighted ) { this . _highlighted . $node . removeClass ( 'highlight' ) ; if ( this . options . highlightableGridModelField ) { this . _highlighted . options . model . set ( this . options . highlightableGridModelField , false ) ; } delete this . _highlighted ; this . trigger ( 'unhighlight' ) ; } return this ; }
function ( err , stats ) { if ( err != null ) { return this . skip ( ) ; } else { if ( ! stats . isDirectory ( ) ) { return this . skip ( ) ; } else { info ( "start watching directory: " + String ( dir ) . bold ) ; fs . watch ( dir , function ( event , filename ) { return onDirChanged ( opts ) ; } ) ; return fs . readdir ( dir , this . next ) ; } } }
function ( param ) { var name , params , _j , _len3 , _ref3 ; if ( param != null ) { params = [ ] ; for ( _j = 0 , _len3 = param . length ; _j < _len3 ; _j ++ ) { _ref3 = param [ _j ] , name = _ref3 . name , type = _ref3 . type ; params . push ( "" + name + ":" + type ) ; } return params . join ( ", " ) ; } else { return "" ; } }
function ( file ) { this . local . detail = { file : file } ; this . global . details . push ( this . local . detail ) ; return fs . readFile ( this . local . detail . file , "utf8" , this . next ) ; }
function ( num , length , pad ) { var str ; if ( length == null ) length = 2 ; if ( pad == null ) pad = "0" ; str = num . toString ( 10 ) ; while ( str . length < length ) { str = pad + str ; } return str ; }
function ( data ) { var url = "" ; if ( typeof data . album !== "undefined" ) { url = _ . find ( data . album . image , function ( i ) { return i . size == size ; } ) [ "#text" ] ; if ( typeof url === "undefined" || url == "" ) url = "/img/default_" + size + ".png" ; } else { url = "/img/default_" + size + ".jpg" ; } cb ( url ) ; }
function ( ) { var target = $ ( this ) . data ( 'navbar' ) ; var left = $ ( target ) . offset ( ) [ 'left' ] ; navbar_img . animate ( { left : left } , { duration : 'slow' , easing : 'easeOutBack' } ) ; }
function ( $ , parser , Entry ) { var absHref = document . location . pathname . replace ( /[^\/]*$/ , '' ) ; parser . parse ( absHref , $ ( 'body' ) ) ; $ ( '#data-apache-autoindex' ) . remove ( ) ; var entry = Entry . get ( absHref ) ; entry . status = 'h5ai' ; if ( entry . parent ) { entry . parent . isParentFolder = true ; } return entry ; }
function ( ) { if ( ! this . layout . rendered ) { throw "settings not available" ; } var fields = [ "controller" , "action" , "template" ] ; var form = this . getLayout ( ) . getForm ( ) ; var element = null ; var settings = this . getLayout ( ) . getForm ( ) . getFieldValues ( ) ; return settings ; }
function ( ) { if ( ! this . layout . rendered ) { throw "settings not available" ; } var fields = [ "controller" , "action" , "template" ] ; var form = this . getLayout ( ) . getForm ( ) ; var element = null ; var settings = this . getLayout ( ) . getForm ( ) . getFieldValues ( ) ; return settings ; }
function ( e ) { var el = $ ( e . target ) ; Router . setPage ( "search?q=" + el . val ( ) , "search" ) ; Session . set ( "signal" , null ) e . preventDefault ( ) ; }
function getKeywords ( signal ) { return signal . title . split ( " " ) . concat ( signal . text . split ( " " ) ) ; }
function ( ) { if ( this . _currentDocument . model . currentView !== 'design' ) { this . _currentDocument . model . switchViewTo ( 'design' ) ; this . btnCode . setAttribute ( 'class' , 'inactive' ) ; this . btnDesign . removeAttribute ( 'class' ) ; } }
function stub ( ) { stub . called = true ; if ( Object . prototype . toString . call ( stub . args ) === '[object Array]' ) { stub . args . push ( arguments ) ; } else if ( stub . args ) { stub . args = [ stub . args , arguments ] ; } else { stub . args = arguments ; } stub . thisArg = this ; return returnValue ; }
function ( ) { var map = { } ; map [ onePath ] = 'foo\n!bar' ; map [ twoPath ] = '!raz\ndwa\n' ; a ( invoked , data , "#3 invoked" ) ; invoked = false ; a ( data . root , pgPath , '#3 Root' ) ; a . deep ( omap ( data . map , String ) , map , '#3 Data' ) ; return writeFile ( rootFile , 'one\n\ntwo\n!three\n' ) ; }
function ( ) { var map = { } ; map [ pgPath ] = 'one\n\ntwo\n!three\n' ; map [ onePath ] = 'foo\n!bar' ; map [ twoPath ] = '!raz\ndwa\n' ; a ( invoked , data , "#4 invoked" ) ; invoked = false ; a ( data . root , pgPath , '#4 Root' ) ; a . deep ( omap ( data . map , String ) , map , '#4 Data' ) ; return mkdir ( gitTwo ) ; }
function ( ) { ++ c ; if ( c == cdb . files . length ) { if ( ready ) ready ( ) ; } }
function ( options ) { var self = this ; events . EventEmitter . call ( self ) ; options = options || { } ; self . log = options . logger ; self . worker = options . worker ; self . paths = options . paths ; self . backup = options . backup ; self . worlds = options . worlds ; self . ramWorlds = options . ramWorlds ; self . _setupBackupCrons ( ) ; }
function ( cb ) { var self = this , status = { running : self . proc . running , players : self . outputs . players , version : self . outputs . version } ; cb ( null , status ) ; }
function ( ) { var _this = this ; this . el . on ( 'change' , this . options . target , function ( ) { _this . el . submit ( ) ; } ) ; if ( this . options . button ) { _this . sandbox . $ ( _this . options . button ) . hide ( ) ; } }
function ( ) { var data = that . getdata ( ) ; my . prop . onsave ( data ) ; that . trigger ( "onsaved.tpledit" , $ . extend ( data , $ . extend ( that . position ( ) , { width : that . width ( ) , height : that . height ( ) } ) ) ) ; }
function ( ) { var position = that . position ( ) ; that . trigger ( "gotoedit.tplview" , $ . extend ( that . position ( ) , { width : that . width ( ) , height : that . height ( ) } ) ) ; that . find ( '.note' ) . qtip ( "hide" ) ; _remove ( ) ; }
function ( data , callback ) { $ . ajax ( { type : "DELETE" , url : _ . str . sprintf ( "/%s/tpl/%s/paramset/%s" , userid , data . nid , data . paramsetid ) , async : true , contentType : "application/json; charset=utf-8" , success : function ( ) { console . log ( "request end." ) ; callback ( ) ; } , error : function ( xhr ) { console . log ( "http request failure." ) ; } } ) ; }
function ( data ) { console . log ( "put tpl data." ) ; $ . ajax ( { type : "PUT" , url : _ . str . sprintf ( "/%s/tpl/%s" , userid , data . nid ) , async : true , contentType : "application/json; charset=utf-8" , data : JSON . stringify ( data ) , success : function ( ) { console . log ( "put request end." ) ; } , error : function ( xhr ) { console . log ( "http request failure." ) ; } } ) ; }
function ( ) { same ( menu . find ( ":focus" ) . length , 1 , "item in open select menu (" + menu . length + ") has focus" ) ; select . selectmenu ( "close" ) ; }
function ( ) { var expected , userData ; user . namespace = 'user' ; userData = user . toJSON ( { namespace : false } ) ; expected = { firstName : 'Andreas' , lastName : 'Gursky' } ; return expect ( userData ) . toEqual ( expected ) ; }
function ( ) { this . WebOS2Events ( "stop" ) ; var position = this . map . getCenter ( ) ; this . controller . stageController . pushScene ( { 'name' : 'street' , transition : Mojo . Transition . none } , position ) ; }
function ( ) { Mojo . Event . stopListening ( this . controller . get ( "map_canvas" ) , 'mousedown' , this . mousedownInterruptsFollowHandler ) ; this . followMap = false ; this . BlockScreenTimeout ( false ) ; this . feedMenuModel . items [ 1 ] . items [ 3 ] . iconPath = 'images/menu-icon-mylocation.png' ; this . controller . modelChanged ( this . feedMenuModel ) ; this . MapHeadingRotate ( 0 ) ; this . SetTopMenuText ( $L ( "Google Maps" ) ) ; }
function ( e ) { this . GestureCenter = this . map . getCenter ( ) ; this . Zooming = true ; this . previouszoom = this . map . getZoom ( ) ; this . previousScale = e . scale ; this . previousS = 0 ; }
function ( event ) { if ( event . type === Mojo . Event . command ) { if ( event . command == 'goBack' ) { this . controller . stageController . popScene ( ) ; } } }
function ( ) { this . FillIndexList ( 0 , this . NearbyListModel ) ; this . controller . modelChanged ( this . NearbyListModel ) ; this . FillIndexList ( 1 , this . MarkersListModel ) ; this . controller . modelChanged ( this . MarkersListModel ) ; }
function ( ) { expect ( L . VERSION ) . toBeDefined ( ) ; var L2 = L . noConflict ( ) ; expect ( L ) . toEqual ( 'test' ) ; expect ( L2 . VERSION ) . toBeDefined ( ) ; this . after ( function ( ) { window . L = L2 ; } ) ; }
function ( embedPlayer ) { if ( embedPlayer . getKalturaConfig ( 'target' ) == "{controllersVbox}" || embedPlayer . getKalturaConfig ( 'target' ) == "{controlsHolder}" || embedPlayer . getKalturaConfig ( 'target' ) == "{controllerVertical}" ) { embedPlayer . overlaycontrols = true ; } else { embedPlayer . overlaycontrols = false ; } }
function ( mw , $ ) { "use strict" ; var faderPlugin = function ( embedPlayer ) { if ( embedPlayer . getKalturaConfig ( 'target' ) == "{controllersVbox}" || embedPlayer . getKalturaConfig ( 'target' ) == "{controlsHolder}" || embedPlayer . getKalturaConfig ( 'target' ) == "{controllerVertical}" ) { embedPlayer . overlaycontrols = true ; } else { embedPlayer . overlaycontrols = false ; } } ; mw . addKalturaConfCheck ( function ( embedPlayer , callback ) { faderPlugin ( embedPlayer ) ; callback ( ) ; } ) ; }
function findStateContainers ( currentNode ) { if ( currentNode . _maqAppStates ) { allStateContainers . push ( currentNode ) ; } for ( var i = 0 ; i < currentNode . children . length ; i ++ ) { findStateContainers ( currentNode . children [ i ] ) ; } }
function findStateContainers ( currentNode ) { if ( currentNode . _maqAppStates ) { allStateContainers . push ( currentNode ) ; } for ( var i = 0 ; i < currentNode . children . length ; i ++ ) { findStateContainers ( currentNode . children [ i ] ) ; } }
function ( string ) { var stack = walker . stack ( ) , node = stack [ stack . length - 1 ] ; if ( ! Object . prototype . hasOwnProperty . call ( occurrencesByString , string ) ) { occurrencesByString [ string ] = [ ] ; } occurrencesByString [ string ] . push ( node ) ; }
function ( name ) { seenNames [ name ] = true ; if ( name in globalsObj ) { var stack = walker . stack ( ) , node = stack [ stack . length - 1 ] ; if ( ! occurrencesByGlobalName . hasOwnProperty ( name ) ) { occurrencesByGlobalName [ name ] = [ ] ; } occurrencesByGlobalName [ name ] . push ( node ) ; } }
function ( ) { var form = jQuery ( "#form" ) ; if ( jQuery ( "input[type='checkbox']:checked" , form ) . length > 0 ) { if ( confirm ( "Are you sure?" ) ) { form . submit ( ) ; } } else { alert ( "Please choose objects for deleting" ) ; return false ; } }
function ( oData ) { oTabs = oData . tabs ; $ . merge ( items , responseToItems ( oData , { section : 'stash' , page : parseInt ( oTabs [ oData . tabIndex ] . n ) } ) ) }
function ( ) { var type = this . ingredients [ Math . random ( ) * this . ingredients . length | 0 ] ; var width = utils . getIngredientWidth ( ) ; var height = utils . getIngredientHeight ( type ) ; var ingredient = new Ingredient ( type , width , height ) ; ingredient . x = utils . lerp ( BOUND_LEFT , BOUND_RIGHT , Math . random ( ) ) ; ingredient . y = - 100 ; return ingredient ; }
function ( name , value ) { var names = name . split ( d3_selection_classedWhitespace ) , n = names . length , i = - 1 ; if ( arguments . length > 1 ) { while ( ++ i < n ) d3_selection_classed . call ( this , names [ i ] , value ) ; return this ; } else { while ( ++ i < n ) if ( ! d3_selection_classed . call ( this , names [ i ] ) ) return false ; return true ; } }
function ( callback ) { for ( var j = - 1 , m = this . length ; ++ j < m ; ) { for ( var group = this [ j ] , i = - 1 , n = group . length ; ++ i < n ; ) { var node = group [ i ] ; if ( node ) callback . call ( node , node . __data__ , i , j ) ; } } return this ; }
function ( value ) { var groups = this ; return groups . each ( typeof value === "function" ? function ( d , i , j ) { groups [ j ] [ i ] . delay = value . apply ( this , arguments ) | 0 ; } : ( value = value | 0 , function ( d , i , j ) { groups [ j ] [ i ] . delay = value ; } ) ) ; }
function ( value ) { var groups = this ; return groups . each ( typeof value === "function" ? function ( d , i , j ) { groups [ j ] [ i ] . duration = Math . max ( 1 , value . apply ( this , arguments ) | 0 ) ; } : ( value = Math . max ( 1 , value | 0 ) , function ( d , i , j ) { groups [ j ] [ i ] . duration = value ; } ) ) ; }
function path ( d , i ) { if ( typeof pointRadius === "function" ) { pointCircle = d3_path_circle ( pointRadius . apply ( this , arguments ) ) ; } return pathType ( d ) || null ; }
function ( o ) { var path = [ ] , features = o . features , i = - 1 , n = features . length ; while ( ++ i < n ) path . push ( pathType ( features [ i ] . geometry ) ) ; return path . join ( "" ) ; }
function ( o ) { var path = [ ] , geometries = o . geometries , i = - 1 , n = geometries . length ; while ( ++ i < n ) path . push ( pathType ( geometries [ i ] ) ) ; return path . join ( "" ) ; }
function ( ) { var a = typeof source === "function" ? source . apply ( this , arguments ) : source , b = typeof target === "function" ? target . apply ( this , arguments ) : target ; return d3_geo_greatArcInterpolate ( a , b ) . d ; }
function ( a ) { for ( var i = 0 ; i < this . deferred . length ; i ++ ) a . codeBlock . extend ( this . deferred [ i ] ) ; this . deferred = [ ] ; }
function ( s ) { if ( typeof s !== "string" ) { throw error ( "Invalid string value '" + s + "'" , { compiler : this . compiler } ) ; } return _op ( "mov" , this . gen_mref ( photon . send ( photon . symbol , "__intern__" , s ) ) , _EAX ) ; }
function ( ctrlSeq , html , text ) { if ( ! text ) text = ctrlSeq && ctrlSeq . length > 1 ? ctrlSeq . slice ( 1 ) : ctrlSeq ; html = html . replace ( /<([^\/>][^>]*)>/g , '<$1 #mqCmdId>' ) ; _super . init . call ( this , ctrlSeq , html , [ text ] ) ; }
function ( _ ) { _ . ctrlSeq = '\\sqrt' ; _ . htmlTemplate = '<span class="sqrt" #mqCmdId>' + '<span class="non-leaf sqrt-prefix">&radic;</span>' + '<span class="sqrt-stem" #mqBlockId:0>#mqBlock:0</span>' + '</span>' ; _ . textTemplate = [ 'sqrt(' , ')' ] ; _ . redraw = function ( ) { var block = this . lastChild . jQ ; scale ( block . prev ( ) , 1 , block . innerHeight ( ) / + block . css ( 'fontSize' ) . slice ( 0 , - 2 ) - .1 ) ; } ; }
function ( _ , _super ) { _ . htmlTemplate = '<sup class="nthroot non-leaf" #mqCmdId #mqBlockId:0>#mqBlock:0</sup>' + '<span class="non-leaf" #mqCmdId>' + '<span class="sqrt-prefix non-leaf">&radic;</span>' + '<span class="sqrt-stem non-leaf" #mqBlockId:1>#mqBlock:1</span>' + '</span>' ; _ . textTemplate = [ 'sqrt[' , '](' , ')' ] ; _ . latex = function ( ) { return '\\sqrt[' + this . firstChild . latex ( ) + ']{' + this . lastChild . latex ( ) + '}' ; } ; }
function ( open , close , ctrlSeq , end ) { _super . init . call ( this , '\\left' + ctrlSeq , '<span class="non-leaf" #mqCmdId>' + '<span class="non-leaf paren">' + open + '</span>' + '<span class="non-leaf" #mqBlockId:0>#mqBlock:0</span>' + '<span class="non-leaf paren">' + close + '</span>' + '</span>' , [ open , close ] ) ; this . end = '\\right' + end ; }
function ( cb ) { if ( config . googleReader ) { var text = $ ( "#current-entry .entry-container a.entry-title-link" ) . text ( ) ; if ( ! text ) text = $ ( '.entry' ) . first ( ) . find ( ".entry-container a.entry-title-link" ) . text ( ) ; cb ( text ) ; } else if ( document . getSelection ( ) != false ) { cb ( '"' + document . getSelection ( ) . toString ( ) + '"' ) ; } else { cb ( document . title ) ; } }
function ( result , code ) { $result . addClass ( result ) . fadeIn ( ) ; if ( result === 'done' ) { return set_result_text ( '采集成功！' ) ; } else if ( result === 'fail' ) { console . log ( code ) ; switch ( code ) { case 404 : set_result_text ( '无法获取资源！' ) ; break ; case 410 : set_result_text ( '无法获取资源！' ) ; break ; case 408 : set_result_text ( '获取资源超时！' ) ; break ; case 406 : set_result_text ( '不符合要求的资源地址！' ) ; break ; } } }
function ( event ) { event . preventDefault ( ) ; $result . fadeOut ( ) ; var $request = jQuery . ajax ( { url : request_url , type : 'POST' , data : { 'url' : $ ( this ) . find ( '.url-field' ) . val ( ) } } ) ; $request . done ( function ( ) { set_result_elm ( 'done' ) ; } ) ; $request . fail ( function ( xhr ) { set_result_elm ( 'fail' , xhr . status ) ; } ) ; }
function center ( ) { if ( ! window . map || ! window . map . map || ! window . map . map . center ) return [ 52.20531805547327 , 0.10361167127326709 ] ; return [ map . map . center . $a , map . map . center . ab ] ; }
function click ( e ) { console . log ( [ e . latLng . $a , e . latLng . ab ] ) ; $ ( "#rooms-descriptions" ) . val ( $ ( "#rooms-descriptions" ) . val ( ) + "\n" + JSON . stringify ( [ e . latLng . $a , e . latLng . ab ] ) ) ; inputChanged ( ) ; }
function OnLoad ( ) { var searchControl = new google . search . SearchControl ( ) ; var imageSearch = new google . search . ImageSearch ( ) ; searchControl . addSearcher ( imageSearch ) ; var drawOptions = new google . search . DrawOptions ( ) ; drawOptions . setSearchFormRoot ( document . getElementById ( "search" ) ) ; searchControl . draw ( document . getElementById ( "search_control" ) , drawOptions ) ; imageSearch . setSearchCompleteCallback ( this , SearchComplete , [ imageSearch ] ) ; imageSearch . execute ( 'sky' ) ; }
function ( req , res ) { var auth = 'guest' ; if ( 'admin' === req . session . user . role || 'superadmin' === req . session . user . Id ) { auth = 'admin' ; } res . render ( 'board/write' , { title : 'write' , id : req . params . id , auth : auth , session : req . session . user } ) ; }
function ( comments , length ) { var json_comments = JSON . stringify ( comments ) ; res . render ( 'board/show' , { title : 'Show Contents' , board : docs , board_id : board_id , comment : json_comments , length : length , sessionId : req . session . user . Id , session : req . session . user } ) ; }
function ( v ) { arr . push ( v ) ; if ( arr . length >= nvals ) { acc = oldAcc ; acc ( arr ) ; } }
function ( v , isEnd ) { if ( ! isEnd ) { arr . push ( v ) ; } else { acc = oldAcc ; acc ( arr ) ; } }
function ( elCell , oRecord , oColumn , oData ) { if ( ! oData ) { $ ( elCell ) . html ( oData ) ; return ; } var outputContainer = $ ( "<span/>" ) ; var removed = oData . replace ( /[\n|\r\n]/g , " " ) ; var broken = pub . breakOnToken ( removed , " " , 400 ) ; outputContainer . html ( broken . replace ( /[\n|\r\n]/g , "<br/>" ) ) ; $ ( elCell ) . html ( "" ) ; elCell . appendChild ( outputContainer [ 0 ] ) ; }
function ( mousemove_event , handle_index ) { var evt_pos = { x : mousemove_event . pageX , y : mousemove_event . pageY } , selection_rect = this . image_selection . getSelectionRect ( ) , selection_pos = selection_rect . getAbsolutePosition ( ) , selection_width = selection_rect . getWidth ( ) , selection_height = selection_rect . getHeight ( ) , delta = this . calculateEventDelta ( handle_index , evt_pos ) ; this . image_selection . setSelection ( this . mode . apply ( handle_index , delta ) ) ; this . last_mousepos = evt_pos ; }
function ( err , collection ) { if ( err ) { param_cb ( err , null ) ; } var cursor = collection . find ( { uuid : param_uuid } ) ; var results = [ ] ; cursor . each ( function ( err , doc ) { if ( doc ) { if ( doc . timeoutOccured ) { } else { results . push ( doc ) ; } } else { param_cb ( err , results ) ; } } ) ; }
function ( param_settings ) { if ( cluster . isMaster ) { if ( ! this . uuid ) { this . uuid = this . _generateUuid ( ) ; } ; if ( param_settings ) { this . logTarget = param_settings . logTarget ; if ( param_settings . uuid ) { this . uuid = param_settings . uuid ; } ; } ; } ; }
function ( result ) { results . push ( result ) ; suitesFinished ++ ; if ( suitesFinished === suitesCreated ) { that . logger . log ( results ) ; that . _closeDb ( ) ; } }
function loadSharing ( configData ) { loadingMessages . style . display = "none" ; var shareData = getCharacterPhrasesAndTiming ( configData ) ; var validationStatus = validateData ( shareData , configData ) ; if ( validationStatus === true ) { console . log ( "Valid Data, Ready to Go" , shareData ) ; } else { loadingMessages . style . display = "block" ; loadingMessages . innerHTML = "Parameters in URL have been determined to be invalid.<br/><br/>" + validationStatus ; } }
function loadSharing ( configData ) { loadingMessages . style . display = "none" ; var shareData = getCharacterPhrasesAndTiming ( configData ) ; var validationStatus = validateData ( shareData , configData ) ; if ( validationStatus === true ) { console . log ( "Valid Data, Ready to Go" , shareData ) ; } else { loadingMessages . style . display = "block" ; loadingMessages . innerHTML = "Parameters in URL have been determined to be invalid.<br/><br/>" + validationStatus ; } }
function addStyleLink ( href ) { var head , link ; head = document . getElementsByTagName ( 'head' ) [ 0 ] ; if ( ! head ) { return ; } link = document . createElement ( 'link' ) ; link . type = 'text/css' ; link . rel = 'stylesheet' ; link . media = 'all' ; link . href = href ; head . appendChild ( link ) ; }
function stop_wheel ( ) { clearTimeout ( spinTimeout ) ; freeze_board ( ) ; var radiansSpun = startAngle - ( 1.5 * Math . PI ) ; var unitsSpun = radiansSpun / arc ; var number = Math . ceil ( unitsSpun % 37 ) ; if ( number == 0 ) { number = 37 ; } var index = 37 - number ; context . save ( ) ; var winningNumber = numbers [ index ] ; determine_outcome ( winningNumber ) ; update_view ( 'neither' , null ) ; }
function ( ctx ) { ctx . drawImage ( this . sprite , this . animate_idx * 32 , this . direction * 32 , 32 , 32 , this . x - characterInfo . x , this . y - characterInfo . y , 32 , 32 ) ; }
function ( prop ) { if ( prop . name == "width" ) { this . textBox . set ( "value" , prop . value ) ; hasWidth = true ; } }
function ( ) { if ( $ ( this ) . is ( '.red' ) ) { var timeout = setTimeout ( function ( ) { red_explanation ( 'reserve' ) } , 2 ) ; } else if ( $ ( this ) . is ( '.red_expired' ) ) { var timeout = setTimeout ( function ( ) { red_explanation ( 'expire' ) } , 2 ) ; } }
function ( full , script ) { var flashvars = exports . stripFlashvars ( script ) ; if ( ! flashvars ) return full ; console . log ( flashvars ) ; flashvars . flvurl = flashvars . url_encoded_fmt_stream_map . url ; flashvars . vid = vid ; flashvars . thumbnail = 'https://i3.ytimg.com/vi/' + vid + '/default.jpg' ; return template . render ( player , flashvars ) ; }
function ( rule ) { var name = rule [ 1 ] || '' ; buf . push ( ast [ 1 ] , '.prototype[' , JSON . stringify ( name ) , ']' , ' = function $' + name . replace ( /[^\w]+/g , '' ) + '() {' ) ; args ( rule [ 2 ] ) ; buf . push ( 'return ' ) ; body ( rule [ 3 ] , ' && ' ) ; buf . push ( '};' ) ; }
function $func ( ) { var args , body ; return this . _skip ( ) && ( args = this . _getIntermediate ( ) , true ) && this . _rule ( "curlyTrans" , false , [ ] , null , this [ "curlyTrans" ] ) && ( body = this . _getIntermediate ( ) , true ) && this . _exec ( [ "func" , args , body ] ) ; }
function $default ( ) { var y ; return this . _rule ( "trans" , false , [ ] , null , this [ "trans" ] ) && ( y = this . _getIntermediate ( ) , true ) && this . _exec ( [ "default" , y ] ) ; }
function $unop ( ) { var op , x ; return this . _skip ( ) && ( op = this . _getIntermediate ( ) , true ) && this . _rule ( "trans" , false , [ ] , null , this [ "trans" ] ) && ( x = this . _getIntermediate ( ) , true ) && this . _exec ( "(" + op + " " + x + ")" ) ; }
function $set ( ) { var lhs , rhs ; return this . _rule ( "trans" , false , [ ] , null , this [ "trans" ] ) && ( lhs = this . _getIntermediate ( ) , true ) && this . _rule ( "trans" , false , [ ] , null , this [ "trans" ] ) && ( rhs = this . _getIntermediate ( ) , true ) && this . _exec ( "(" + lhs + "=" + rhs + ")" ) ; }
function ( ) { return this . _atomic ( function ( ) { return this . _rule ( "trans" , false , [ ] , null , this [ "trans" ] ) ; } ) ; } ) && ( props = this . _getIntermediate ( ) , true ) && this . _exec ( "({" + props . join ( "," ) +
function ( ) { var sql , params , callback ; sql = arguments [ 0 ] ; if ( arguments [ 1 ] instanceof Array ) { params = arguments [ 1 ] ; callback = arguments [ 2 ] ; sql = this . driver . _updateSubstitutes ( sql , params ) ; } else { callback = arguments [ 1 ] ; } return this . _runSqlAll ( sql , params , callback ) ; }
function toArray ( obj ) { var undef , out , i ; if ( obj && ! obj . splice ) { out = [ ] ; for ( i = 0 ; true ; i ++ ) { if ( obj [ i ] ) out [ i ] = obj [ i ] ; else break ; } return out ; } return obj ; }
function ( ) { var _k , _len2 , _ref2 , _results2 ; _ref2 = markerTypeObject . markers ; _results2 = [ ] ; for ( _k = 0 , _len2 = _ref2 . length ; _k < _len2 ; _k ++ ) { marker = _ref2 [ _k ] ; _results2 . push ( this . addMarker ( marker , otherInfo , false , defaultValue , myCallBack ) ) ; } return _results2 ; }
function ( domEvt ) { if ( this . _mousePressed && domEvt . currentTarget == this . currTarget ) { this . _performAction ( domEvt ) ; } this . currTarget = null ; if ( this . _cfg ) { this . _mousePressed = false ; this . _updateState ( ) ; } }
function ( domEvt ) { if ( domEvt . keyCode == aria . DomEvent . KC_SPACE || domEvt . keyCode == aria . DomEvent . KC_ENTER ) { this . _keyPressed = true ; this . _updateState ( ) ; domEvt . stopPropagation ( ) ; return false ; } else { return true ; } }
function ( domEvt ) { if ( domEvt . keyCode == aria . DomEvent . KC_SPACE || domEvt . keyCode == aria . DomEvent . KC_ENTER ) { this . _keyPressed = false ; this . _updateState ( ) ; if ( ! this . _performAction ( domEvt ) ) { domEvt . stopPropagation ( ) ; return false ; } } return true ; }
function ( e ) { var that = e . data . fileupload , dataTransfer = e . dataTransfer = e . originalEvent . dataTransfer ; if ( that . _trigger ( 'dragover' , e ) === false ) { return false ; } if ( dataTransfer ) { dataTransfer . dropEffect = dataTransfer . effectAllowed = 'copy' ; } e . preventDefault ( ) ; }
function ( data ) { if ( ! data || this . options . disabled ) { return ; } data . files = $ . each ( $ . makeArray ( data . files ) , this . _normalizeFile ) ; this . _onAdd ( null , data ) ; }
function ( reAdd ) { var totalBuffer = new Buffer ( this . length ) ; var lastFreeIndex = 0 ; while ( buffer = this . buffersList . shift ( ) ) { buffer . copy ( totalBuffer , lastFreeIndex ) ; lastFreeIndex += buffer . length ; } this . length = 0 ; reAdd && this . add ( totalBuffer ) ; return totalBuffer ; }
function ( ) { var $badge = $ ( '.NB-friends-findfriends-profile' , this . $modal ) . empty ( ) ; var $profile_badge ; var profile = this . profile ; $profile_badge = new NEWSBLUR . Views . SocialProfileBadge ( { model : profile } ) ; $badge . append ( $profile_badge ) ; }
function ( data ) { $ ( '.NB-modal-loading' , this . $modal ) . removeClass ( 'NB-active' ) ; this . profile = this . model . user_profile ; this . services = data . services ; this . make_profile_section ( ) ; this . make_profile_photo_chooser ( ) ; this . choose_color ( ) ; callback && callback ( ) ; }
function EmbeddedDocument ( obj , parentArr , skipId ) { if ( parentArr ) { this . parentArray = parentArr ; this . parent = parentArr . _parent ; } Document . call ( this , obj , undefined , skipId ) ; var self = this ; this . on ( 'isNew' , function ( val ) { self . isNew = val ; } ) ; }
function ( path ) { if ( ! this . parentArray ) return ; this . _activePaths . modify ( path ) ; if ( this . isNew ) { this . parentArray . _markModified ( ) ; } else this . parentArray . _markModified ( this , path ) ; }
function ( fn ) { if ( ! this . parentArray ) return this ; var _id ; if ( ! this . willRemove ) { _id = this . _doc . _id ; if ( ! _id ) { throw new Error ( 'For your own good, Mongoose does not know ' + 'how to remove an EmbeddedDocument that has no _id' ) ; } this . parentArray . pull ( { _id : _id } ) ; this . willRemove = true ; } if ( fn ) fn ( null ) ; return this ; }
function ( path , err ) { if ( ! this . parent ) return false ; var index = this . parentArray . indexOf ( this ) ; var parentPath = this . parentArray . _path ; var fullPath = [ parentPath , index , path ] . join ( '.' ) ; this . parent . invalidate ( fullPath , err ) ; return true ; }
function ( err ) { assert . ok ( a . parent . _validationError instanceof ValidationError ) ; assert . equal ( a . parent . errors [ 'jsconf.ar.0.work' ] . name , 'ValidatorError' ) ; assert . equal ( a . parent . _validationError . toString ( ) , 'ValidationError: Validator "required" failed for path test, Validator failed for path work' ) ; done ( ) ; }
function TestDoc ( schema ) { var Subdocument = function ( ) { EmbeddedDocument . call ( this , { } , new DocumentArray ) ; } ; Subdocument . prototype . __proto__ = EmbeddedDocument . prototype ; var SubSchema = new Schema ( { title : { type : String } } ) ; Subdocument . prototype . setSchema ( schema || SubSchema ) ; return Subdocument ; }
function ( err , result ) { if ( err ) { error_handle ( req , res , err ) ; this . end ( ) ; return ; } res . send ( result ) ; this . end ( ) ; }
function ( ) { TorrentCollection . initialize ( ) ; namespace . rootLayout = new DefaultLayout ( ) ; namespace . rootLayout . render ( ) ; namespace . app . vent = new Marionette . EventAggregator ( ) ; require ( [ "scripts/router" ] , function ( Router ) { Router . initialize ( ) ; } ) ; }
function ( Marionette , namespace , TorrentCollection , DefaultLayout ) { var initialize = function ( ) { TorrentCollection . initialize ( ) ; namespace . rootLayout = new DefaultLayout ( ) ; namespace . rootLayout . render ( ) ; namespace . app . vent = new Marionette . EventAggregator ( ) ; require ( [ "scripts/router" ] , function ( Router ) { Router . initialize ( ) ; } ) ; } ; return { initialize : initialize , } ; }
function ( ) { require . config ( { baseUrl : '../' , paths : { 'jquery' : 'scripts/lib/jquery-1.7.1.min' , 'order' : 'scripts/lib/order' , 'underscore' : 'scripts/lib/underscore-min' , 'transitions' : 'scripts/plugin/bootstrap-transition' , 'collapse' : 'scripts/plugin/bootstrap-collapse' , 'backbone' : 'scripts/lib/backbone-min' , 'underscore' : 'scripts/lib/underscore-min' , 'bootstrap' : 'scripts/lib/bootstrap.min' , 'bootstrap-collapse' : 'scripts/lib/plugin/bootstrap-collapse' , 'text' : 'scripts/lib/text' , 'mustache' : 'scripts/lib/requirejs.mustache' , 'marionette' : 'scripts/lib/backbone.marionette.min' , 'mock-ajax' : 'scripts/lib/mock-ajax' , 'fake-ajax' : 'scripts/lib/jasmine-fake-ajax-0.3.4' , } } ) ; }
function ( ele ) { return ele . nodeType === 1 ? ele . innerHTML . toLowerCase ( ) : null ; }
function run ( ast ) { var context = { 'local' : { } , 'global' : { } , 'value' : null } ; for ( i = 0 ; i < ast . length ; i ++ ) { var node = ast [ i ] ; context = evaluate ( node , context ) ; } return context ; }
function validateSync ( observable , rule , ctx ) { if ( ! rule . validator ( observable ( ) , ctx . params || true ) ) { observable . error = ko . validation . formatMessage ( ctx . message || rule . message , ctx . params ) ; observable . errorRule = rule ; observable . __valid__ ( false ) ; return false ; } else { return true ; } }
function ( val ) { val = val || 0 ; if ( ! isInt ( val ) ) { self . handleError ( 'ERROR: Cannot increment a non-integer value.' ) ; return ; } var newValue = val + increment ; setValue ( osName , trans , uuid , key , newValue , function ( res ) { cb . call ( self , res === 'OK' ? newValue : 'ERR' ) ; } , errback , self ) ; }
function ( val ) { val = val || 0 ; if ( ! isInt ( val ) ) { self . handleError ( 'ERROR: Cannot increment a non-integer value.' ) ; return ; } var newValue = val + increment ; setValue ( osName , trans , uuid , key , newValue , function ( res ) { cb . call ( self , res === 'OK' ? newValue : 'ERR' ) ; } , errback , self ) ; }
function ( renderer_uri ) { var renderer = simple_renderers [ renderer_uri ] if ( ! renderer ) { throw "PluginManagerError: simple renderer \"" + renderer_uri + "\" is unknown" } return renderer }
function ( topic_or_association_or_renderer_uri ) { if ( typeof ( topic_or_association_or_renderer_uri ) == "string" ) { var renderer_uri = topic_or_association_or_renderer_uri } else { var type = topic_or_association_or_renderer_uri . get_type ( ) var renderer_uri = type . get_page_renderer_uri ( ) } var renderer = page_renderers [ renderer_uri ] if ( ! renderer ) { throw "PluginManagerError: page renderer \"" + renderer_uri + "\" is unknown" } return renderer }
function register_internal_plugins ( plugins ) { for ( var i = 0 , plugin ; plugin = plugins [ i ] ; i ++ ) { register_plugin ( "/de.deepamehta.webclient/script/internal_plugins/" + plugin ) } }
function load_simple_renderers ( ) { if ( dm4c . LOG_PLUGIN_LOADING ) dm4c . log ( "Loading " + simple_renderer_sources . length + " simple renderers:" ) for ( var i = 0 , simple_renderer_source ; simple_renderer_source = simple_renderer_sources [ i ] ; i ++ ) { if ( dm4c . LOG_PLUGIN_LOADING ) dm4c . log ( "..... " + simple_renderer_source ) dm4c . load_script ( simple_renderer_source ) } }
function load_multi_renderers ( ) { if ( dm4c . LOG_PLUGIN_LOADING ) dm4c . log ( "Loading " + multi_renderer_sources . length + " multi renderers:" ) for ( var i = 0 , multi_renderer_source ; multi_renderer_source = multi_renderer_sources [ i ] ; i ++ ) { if ( dm4c . LOG_PLUGIN_LOADING ) dm4c . log ( "..... " + multi_renderer_source ) dm4c . load_script ( multi_renderer_source ) } }
function ( ) { error ( 'Cloning ' + self . url ) ; var handler = errorHandler ( 'Error cloning ' + self . url + ' to ' + self . basePath , done , done ) ; exec ( 'git' , [ 'clone' , '--mirror' , self . url , self . basePath ] , { cwd : './' , quietError : true } , handler ) ; }
function ( err , diff ) { assert . ifError ( err ) ; assert . lengthOf ( diff , 1 ) ; var diff0 = diff [ 0 ] ; assert . equal ( diff0 . before . path , diff0 . after . path ) ; assert . equal ( diff0 . before . sha1 , 'd7f0dbb626c1007fc9c98cb96a09636c76655ea0' ) ; assert . equal ( diff0 . after . sha1 , '9e7d57c75f8ec3caf31156d5fbd19185e713e0ee' ) ; }
function down ( event ) { cursorElmnt . show ( ) ; cursorElmnt . removeClass ( 'off' ) ; var curpos = cursorElmnt . position ( ) ; mouseStartDelta = { x : event . clientX - curpos . left , y : event . clientY - curpos . top } ; }
function ( ) { $ ( "#nextPathButton" ) . prop ( "disabled" , true ) adore . switchToNextPath ( ) ; pathIDSpan . text ( ( adore . getActivePathIndex ( ) + 1 ) . toString ( ) + " of " + adore . getPathCount ( ) ) ; $ ( "#nextPathButton" ) . prop ( "disabled" , false ) ; }
function ( ) { var i ; Y . one ( '#filterYear' ) . on ( 'change' , this . filterYear , this ) ; Y . one ( '#filterTeacher' ) . on ( 'change' , this . filterTeacher , this ) ; Y . one ( '#filterCategory' ) . on ( 'change' , this . filterCategory , this ) ; }
function ( content ) { content = $ ( "<div/>" ) . html ( content ) . text ( ) ; for ( var key in validAlias ) { var regex = new RegExp ( key , "g" ) ; content = content . replace ( regex , function ( ) { return validAlias [ key ] } ) ; } content = $ ( "<div/>" ) . text ( content ) . html ( ) ; return content . replace ( /:([a-z0-9\+\-_]+):/g , emojiReplacer ) ; }
function ( ) { this . key . press = this . pressed [ 0 ] ; var returnKey = helper . cloneObj ( this . key ) ; returnKey . value = returnKey . values [ 0 ] ; this . pressed [ 0 ] = false ; return returnKey ; }
function ( key , item ) { if ( errorMessage != null ) { messageList += " - <b>" + item . Title + "</b>, " + item . Message + "<br />" ; } }
function ( ) { var embedPlayer = this . embedPlayer ; mw . log ( "PlayerControlBuilder::syncPlayerSize: window:" + $ ( window ) . width ( ) + ' player: ' + $ ( embedPlayer ) . width ( ) ) ; if ( embedPlayer . playlist && ! this . inFullScreen ) { embedPlayer . playlist . syncPlayerSize ( ) ; } else { embedPlayer . resizePlayer ( this . getWindowSize ( ) ) ; } }
function ( hvlist ) { set_suggests ( hvlist ) ; $ ( 'select.host_hypervisor' ) . html ( $ ( get_suggests ( ) ) . slice ( 0 , 10 ) ) . prepend ( suggest_head ( ) ) . append ( suggest_foot ( ) ) ; $ ( 'span.loading.hypervisor' ) . hide ( ) ; $ ( 'select.host_hypervisor' ) . show ( ) ; }
function show_hosts_history ( event ) { var selected = $ ( selected_objects ( ) ) ; if ( selected . size ( ) < 1 ) { show_error_dialog ( "対象がなにも選択されていません" ) ; return false ; } ; window . location . href = '/ybz/host/history/' + selected . get ( ) . join ( '-' ) ; }
function show_bricks_history ( event ) { var selected = $ ( selected_objects ( ) ) ; if ( selected . size ( ) < 1 ) { show_error_dialog ( "対象がなにも選択されていません" ) ; return false ; } ; window . location . href = '/ybz/brick/history/' + selected . get ( ) . join ( '-' ) ; }
function show_operations ( event ) { var start = $ ( "input[name='start_date']" ) . val ( ) ; var end = $ ( "input[name='end_date']" ) . val ( ) ; var url = "/ybz/operations" ; if ( start != null && end != null ) { if ( start . length != 8 || end . length != 8 ) { alert ( "日付入力は8桁 yyyymmdd で入力してください" ) ; return false ; } url = url + '/' + start + '/' + end ; } window . location . href = url ; }
function show_detailbox_without_selection ( event , modelname ) { var target = $ ( event . target ) . closest ( '.selectable,.unselectable' ) ; var oid = target . attr ( "id" ) ; if ( oid == null || oid == "" ) { return false ; } show_detailbox ( modelname , oid , event . pageY - detailbox_offset ( ) , false ) ; }
function ( n , i ) { return ( $ ( n ) . attr ( 'name' ) . match ( /^localips\d+$/ ) && $ ( n ) . val ( ) . length > 0 ) ; } ) . map ( function ( n ) { return $ ( n ) . val ( ) }
function ( ) { var order_by = this . get_full_column_name ( [ this . sort_by_select . val ( ) ] ) + ' ' + this . sort_order_select . val ( ) if ( this . sort_by_next_select . val ( ) ) { order_by += ', ' + this . get_full_column_name ( [ this . sort_by_next_select . val ( ) ] ) + ' ' + this . sort_order_next_select . val ( ) } return order_by ; }
function ( file ) { var params = Url . parseURLParams ( file . href ) ; var result = params . map ( function ( o ) { return o . name + ": " + o . value ; } ) ; System . copyToClipboard ( result . join ( Str . lineBreak ( ) ) ) ; }
function browser_handleTabsBadgeClicked ( ) { if ( this . currentScreen === this . TABS_SCREEN ) { var tabId = this . createTab ( ) ; this . selectTab ( tabId ) ; this . showAwesomeScreen ( ) ; return ; } if ( this . currentScreen === this . AWESOME_SCREEN && this . previousScreen === this . PAGE_SCREEN ) { this . showPageScreen ( ) ; return ; } this . showTabScreen ( ) ; }
function ( objToTest , expected , msg ) { for ( var key in expected ) { equal ( objToTest [ key ] , expected [ key ] , key + " set to: " + expected [ key ] + ( msg ? " - " + msg : "" ) ) ; } }
function ( ) { $ . post ( "../command/rdf-extension/addService" , { "datasource" : "sparql" , "name" : name , "url" : endpoint , "type" : type , "graph" : graph_uri , properties : prop_uris } , function ( data ) { self . _dismissBusy ( ) ; RdfReconciliationManager . registerService ( data , self . _level ) ; } , "json" ) ; }
function ( data , textStatus , jqXHR ) { if ( data == null || data . length == 0 ) return null ; var article = new Article ( ) ; article . load ( data [ 0 ] ) ; articles . push ( article ) ; callback ( article ) ; }
function ( move ) { var jsonCard = move [ 'card' ] ; var seqNo = move [ 'sequenceNumber' ] ; var card = new Card ( jsonCard [ 'rank' ] , jsonCard [ 'suit' ] ) ; var player = game . getPlayerById ( move [ 'playerId' ] ) ; moves . push ( new PlayerMove ( { 'player' : player , 'card' : card , 'seqNo' : seqNo } ) ) ; }
function ( content , subscript ) { var x = constants . WIDTH * 0.78 ; var y = constants . HEIGHT * 0.7 ; this . drawMainText ( content , x , y ) ; var newLineCount = this . countNewLines ( content ) ; var subY = y + ( newLineCount * 36 ) ; console . debug ( "subY" + subY ) ; this . drawSubText ( subscript , x , subY ) ; }
function ( ) { var ignoredTags , selectors ; ignoredTags = [ 'navbar.navbar-fixed-top' , '#blueBar.fixed_elem' , '#onegoogbar' , '#gb' , '#mngb' , '.topbar .global-nav' , '#navBar.fixed' ] ; selectors = ignoredTags . join ( ', ' ) ; if ( $ ( selectors ) . length > 0 ) { return true ; } else { return false ; } }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 740 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 762 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 803 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 833 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 933 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 740 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 762 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 803 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 833 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 933 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 740 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 762 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 803 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 833 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 933 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( msgid ) { if ( json_locale_data && json_locale_data [ "client" ] ) { var dict = json_locale_data [ "client" ] ; if ( dict [ msgid ] && dict [ msgid ] . length >= 2 && dict [ msgid ] [ 1 ] . trim ( ) != "" ) { return dict [ msgid ] [ 1 ] ; } } return msgid ; }
function ( record ) { this . periodRecord = record ; this . getActions ( ) . setTitle ( record . get ( 'long_name' ) ) ; this . setBreadcrumb ( this . periodRecord ) ; this . _setMenuLabels ( ) ; this . getAdminsbox ( ) . setBasenodeRecord ( this . periodRecord , this . _getPath ( ) ) ; this . getBasenodehierlocation ( ) . setLocation ( this . periodRecord ) ; }
function getOnScreenFeatures ( layer_features ) { for ( i = 0 ; i < layer_features . length ; i ++ ) { var feature = layer_features [ i ] ; if ( feature . onScreen ( ) === true ) { onscreen_features . push ( feature ) } } }
function bindIf ( view , variable , context ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; var template = view . contents ( ) . detach ( ) ; view . data ( hdRenderName , function renderIf ( ) { var copy = template . clone ( ) ; hd . bindTree ( copy , context ) ; return copy ; } ) ; hd . bindWrite ( variable , view , { write : write } ) ; return true ; }
function ( story ) { var singleView = new storiesSingleView ( { model : story , thumb : true } ) ; $ ( this . el ) . prepend ( singleView . render ( ) . el ) ; }
function ( ) { var data = { story : this . model , _ : _ } ; if ( this . options . thumb ) { var compiledTemplate = _ . template ( storyThumbTemplate , data ) ; $ ( this . el ) . html ( compiledTemplate ) ; } else { var compiledTemplate = _ . template ( storySingleTemplate , data ) ; $ ( "#page" ) . prepend ( compiledTemplate ) ; } return this ; }
function ( d , h ) { var m = d , u = false ; if ( typeof m === "string" ) u = h || false ; else if ( m && ! m [ 0 ] && ! m . length ) m = [ m ] ; return $p . core ( m , u ) }
function formatPrice ( field ) { var pattern = new RegExp ( /[^0-9\-\.]+/g ) ; var price = field . value . replace ( pattern , '' ) ; field . value = $ ( ) . number_format ( price , { numberOfDecimals : 2 , decimalSeparator : '.' , thousandSeparator : ' ' } ) ; }
function formatQty ( field ) { var pattern = new RegExp ( /[^0-9\.]+/g ) ; var price = field . value . replace ( pattern , '' ) ; field . value = $ ( ) . number_format ( price , { numberOfDecimals : 0 , decimalSeparator : '.' , thousandSeparator : '' } ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( e ) { var key ; if ( e == null ) return ; key = e . which ; _this . handleKeyPress ( key ) ; if ( KEYSTATES [ key ] != null ) clearTimeout ( KEYSTATES [ key ] ) ; }
function ( ) { $ ( ".nano" ) . nanoScroller ( ) ; }
function ( ) { var highest = 0 ; $ ( this ) . parent ( ) . find ( "." + dt . class_prefix + "cell" ) . each ( function ( ) { var thisheight = $ ( this ) . height ( ) + dt . get_extras ( this ) ; if ( thisheight > highest ) { highest = thisheight ; } } ) ; $ ( this ) . css ( "height" , highest ) ; $ ( this ) . css ( "min-height" , highest ) ; }
function ( uri , data ) { if ( ! ( uri in dt . data ) ) { dt . data [ uri ] = { } ; dt . add_new_row ( uri ) ; } dt . add_data_to_row ( uri , data ) ; }
function ( data ) { var dt = this ; $ . each ( data , function ( uri , data ) { if ( ! ( uri in dt . data ) ) { dt . data [ uri ] = { } ; dt . add_new_row ( uri ) ; } dt . add_data_to_row ( uri , data ) ; } ) ; }
function ( iocfg ) { iocfg . method = 'POST' ; iocfg . headers = { 'Content-Type' : 'application/json' , } ; var data = this . toJSON ( ) ; data . lastTaskCount = 0 ; iocfg . data = Y . JSON . stringify ( data ) ; Y . io ( '/data/project/create' , iocfg ) ; }
function ( iocfg ) { iocfg . method = 'POST' ; iocfg . headers = { 'Content-Type' : 'application/json' , } ; var data = this . toJSON ( ) ; data . lastTaskCount = Y . Task . lastCount ; iocfg . data = Y . JSON . stringify ( data ) ; Y . io ( '/data/project/update' , iocfg ) ; }
function ( ) { if ( this . width > this . tl . view . width ) this . width = this . tl . view . width ; if ( this . width < this . tl . sliderHandleWidth * 2 ) this . width = this . tl . sliderHandleWidth * 2 ; this . length = this . width / this . tl . view . width ; this . tl . view . length = Math . round ( this . length * this . tl . length ) ; }
function getPageBlockedAnswer ( event ) { if ( event . name === pckg + ".pageBlockAnswer" ) { if ( event . message === true ) { console . log ( "page should be blocked " + location . href ) ; location . href = safari . extension . baseURI + "close.html" ; } else { console . log ( "page is ok" ) ; } } }
function ( ) { TissueStack . Utils . adjustScreenContentToActualScreenSize ( 0 ) ; _this . addToOrReplaceSelectedDataSets ( dataSet . id , 0 ) ; _this . showDataSet ( 1 ) ; TissueStack . InitUserInterface ( ) ; TissueStack . BindDataSetDependentEvents ( ) ; }
function ( e ) { var obj = ( e . target || e . srcElement ) ; if ( obj . href || obj . type ) return true ; $ ( this ) . toggleClass ( 'trSelected' ) ; if ( p . singleSelect ) $ ( this ) . siblings ( ) . removeClass ( 'trSelected' ) ; }
function ( ) { page . evaluate ( function ( ) { window . addEventListener ( 'keydown' , function ( event ) { window . loggedEvent = window . loggedEvent || { } ; window . loggedEvent . keydown = event ; } , false ) ; } ) ; page . sendEvent ( 'keydown' , 65 ) ; }
function ( ) { page . evaluate ( function ( ) { window . addEventListener ( 'keyup' , function ( event ) { window . loggedEvent = window . loggedEvent || { } ; window . loggedEvent . keyup = event ; } , false ) ; } ) ; page . sendEvent ( 'keyup' , 65 ) ; }
function ( ) { page . evaluate ( function ( ) { window . addEventListener ( 'keypress' , function ( event ) { window . loggedEvent = window . loggedEvent || { } ; window . loggedEvent . keypress = event ; } , false ) ; } ) ; page . sendEvent ( 'keypress' , 65 ) ; }
function ( ) { page . content = '<input type="text">' ; page . evaluate ( function ( ) { document . querySelector ( 'input' ) . focus ( ) ; } ) ; page . sendEvent ( 'keypress' , 65 ) ; var text = page . evaluate ( function ( ) { return document . querySelector ( 'input' ) . value ; } ) ; expect ( text ) . toEqual ( "A" ) ; }
function ( error ) { if ( error ) { if ( callback ) { callback ( 0 ) ; } console . log ( "Couldn't delete database " + error ) ; } else { if ( callback ) { callback ( 1 ) ; } console . log ( "Database " + dbName + " deleted" ) ; } mysql . end ( ) ; }
function ( req , res ) { console . log ( "Received from WSS: " + req . body . data ) ; wss . emit ( "latlng" , req . body . data ) console . log ( "Tracking provider: " + TrackingProvider ) trackingProvider . save ( req . body . data , function ( error , docs ) { console . log ( "???" ) } ) ; res . end ( "OK" ) ; }
function ( ) { var num = $ ( '#' + elementContainerId ) . children ( "." + childElement . title + 'Instance' ) . length ; if ( ( num == undefined ) || ( num == 0 ) ) num = 1 ; else num = num + 1 ; createElement ( childElement , xml , parentPath + '/' + element . elementTitle . replace ( /\\/g , "" ) + '[' + count + ']' , num , '#' + elementContainerId , indent ) ; }
function ( data ) { data = JSON . parse ( data . toString ( ) ) ; if ( data . code === 'received message' ) { check ( 'worker' , data . echo === 'message from master' ) ; } else { throw new Error ( 'worng TCP message recived: ' + data ) ; } }
function ( props , callback ) { if ( ! props . from || ! props . to ) { callback ( new Error ( "Need 'from' and 'to'" ) , null ) ; return ; } props . from = Identifier . canonical ( props . from ) ; props . to = Identifier . canonical ( props . to ) ; props . fromto = Edge . makeFromTo ( props . from , props . to ) ; props . created = props . modified = Date . now ( ) ; callback ( null , props ) ; }
function ( ) { this . base ( arguments , false ) ; this . setTitle ( "Maps" ) ; this . setShowBackButton ( true ) ; this . setBackButtonText ( "Back" ) ; }
function ( ) { var layout = new qx . ui . mobile . layout . VBox ( ) . set ( { alignX : "center" , alignY : "middle" } ) ; var mapContainer = new qx . ui . mobile . container . Composite ( layout ) ; mapContainer . setId ( "osmMap" ) ; return mapContainer ; }
function ( ) { self . _map = new OpenLayers . Map ( "osmMap" ) ; var mapnik = new OpenLayers . Layer . OSM ( "mapnik" , null , { } ) ; self . _map . addLayer ( mapnik ) ; self . _getGeoPosition ( ) ; }
function openHKTemplateList ( ) { $ ( '#hk_list' ) . remove ( ) ; prepareHKContainer ( hkconf . hk_pwtemplates , 'Edit <a href="' + config . urls . admin + 'setup/template/">Template</a>:' , 'setup/template/edit' ) ; $ ( '#hk_list' ) . fadeIn ( ) . find ( 'input:first' ) . focus ( ) ; }
function ( latlon ) { var center = LatLon . fromLonLat ( this . map . getCenter ( ) ) ; return ( latlon . lat == center . lat ) && ( latlon . lon == center . lon ) ; }
function ( ) { var latlon = new LatLon ( 52 , 4 ) ; var ol = latlon . getLonLat ( ) ; expect ( ol . lat ) . toEqual ( 6800125.4534507 ) ; expect ( ol . lon ) . toEqual ( 445277.96311111 ) ; }
function ( key , val ) { var img = $ ( '<img src="' + val . thumb + '" rel="' + val . image + '" />' ) ; $ ( '#redactor_image_box' ) . append ( img ) ; $ ( img ) . click ( $ . proxy ( this . imageSetThumb , this ) ) ; }
function ( rs , mapper ) { var i , objs , _i , _ref ; objs = [ ] ; for ( i = _i = 0 , _ref = rs . rows . length ; 0 <= _ref ? _i < _ref : _i > _ref ; i = 0 <= _ref ? ++ _i : -- _i ) { objs . push ( mapper ( rs . rows . item ( i ) ) ) ; } return objs ; }
function ( tx , data ) { var i , tags , _i , _ref ; tags = [ ] ; for ( i = _i = 0 , _ref = data . rows . length ; 0 <= _ref ? _i < _ref : _i > _ref ; i = 0 <= _ref ? ++ _i : -- _i ) { tags . push ( new Readings . Tag ( data . rows . item ( i ) ) ) ; } return callback ( tags ) ; }
function ( ) { if ( Readings . initialized != null ) { return ; } Readings . config = new Readings . Config ( { wlurl : 'http://readings.local' , categories : { 'author' : 'autor' , 'epoch' : 'epoka' , 'genre' : 'gatunek' , 'kind' : 'rodzaj' } , show_filter : [ 'authors' , 'themes' ] , show_dividers : [ 'authors' , 'themes' ] , db_version : '1.0' } ) ; Readings . catalogue = new Readings . Catalogue ( ) . open ( ) ; return Readings . initialized = true ; }
function ( name , url , options ) { options = $ . extend ( { } , { status : 0 , toolbar : 0 , location : 0 , titlebar : 0 , menubar : 0 , resizable : 1 , scrollbars : 1 , width : 1024 , height : 600 } , options ) var os = 'directories=0' $ . each ( options , function ( k , v ) { os += ',' + k + '=' + v } ) window . open ( url , options . name , os ) }
function ( dom ) { if ( ! dom ) return null ; if ( ! dom . nodeType ) dom = { namespaceURI : dom , tagName : arguments [ 1 ] , nodeType : 1 } ; if ( dom . nodeType !== 1 ) return null ; var ns = dom . namespaceURI == "urn:DAV" ? "DAV:" : dom . namespaceURI ; return "{" + ns + "}" + dom . tagName . toLowerCase ( ) . replace ( "d:" , "" ) ; }
function ( type , cb ) { }
function ( value , record ) { if ( value ) { var date = value . split ( /[\-T:]/ ) ; return new Date ( date [ 0 ] , date [ 1 ] - 1 , date [ 2 ] , date [ 3 ] ) ; } else { return new Date ( ) ; } }
function ( value , record ) { if ( value ) { var date = value . split ( /[\-T:]/ ) ; return new Date ( date [ 0 ] , date [ 1 ] - 1 , date [ 2 ] , date [ 3 ] ) ; } else { return new Date ( ) ; } }
function ( ) { $ ( this ) . css ( { 'background-image' : "url('/logo.png')" , "background-repeat" : "no-repeat" , "width" : "130px" } ) . animate ( { height : '92px' } , { duration : 1000 } ) . animate ( { opacity : 1 } , { duration : 1000 } ) ; }
function md_init ( ) { this . getAllElements ( ) ; var elements = this . elements ; window . addEventListener ( 'mozbrowsershowmodalprompt' , this ) ; for ( var id in elements ) { if ( elements [ id ] . tagName . toLowerCase ( ) == 'button' ) { elements [ id ] . addEventListener ( 'click' , this ) ; } } }
function closeWindow ( origin , callback ) { var app = runningApps [ origin ] ; closeFrame = app . frame ; closeCallback = callback || function ( ) { } ; var evt = document . createEvent ( 'CustomEvent' ) ; evt . initCustomEvent ( 'appwillclose' , true , false , { } ) ; closeFrame . dispatchEvent ( evt ) ; closeFrame . blur ( ) ; closeFrame . setVisible ( false ) ; sprite . classList . remove ( 'faded' ) ; sprite . classList . add ( 'close' ) ; }
function ( e ) { if ( e . keyCode === e . DOM_VK_ESCAPE && ! ModalDialog . blocked && ! e . defaultPrevented && displayedApp !== null ) { setDisplayedApp ( null ) ; } if ( e . keyCode === e . DOM_VK_ESCAPE && ModalDialog . blocked ) { ModalDialog . cancelHandler ( ) ; } }
function keyupHandler ( e ) { if ( e . keyCode !== e . DOM_VK_HOME ) return ; if ( ! keydown ) return ; keydown = false ; if ( timer !== null ) { clearInterval ( timer ) ; timer = null ; if ( ! ModalDialog . blocked && ! LockScreen . locked && ! e . defaultPrevented ) { if ( ! e . defaultPrevented ) setDisplayedApp ( null ) ; if ( CardsView . cardSwitcherIsShown ( ) ) CardsView . hideCardSwitcher ( ) ; } } e . stopPropagation ( ) ; }
function popup_init ( ) { var popup_id_list = [ 'popup_link_user' , 'popup_link_status' , 'popup_status_delete' , 'popup_status_retweet' , 'popup_status_quote' , 'upopup_user_block' , 'upopup_user_unblock' , 'upopup_user_spam' ] ; for ( var x = 0 ; x < popup_id_list . length ; x ++ ) $ ( popup_id_list [ x ] ) . innerHTML = _ ( $ ( popup_id_list [ x ] ) . innerHTML ) ; }
function popup_hide ( ) { callPlugins ( "popup_hide" ) ; $ ( 'popup' ) . style . display = 'none' ; $ ( 'userinfo_popup' ) . style . display = 'none' ; $ ( 'popup_hide' ) . style . display = 'none' ; popup_user = popup_id = popup_ele = null ; }
function ( aEvent ) { that . _logger . debug ( "In image onerror" ) ; if ( that . _currentImage != aImageSrc ) { return ; } that . _hideCaption ( ) ; that . _logToConsole ( "ThumbnailZoomPlus: >>> error loading\n" + aImageSrc ) ; that . _logger . debug ( "image onerror: show warning briefly since error loading image (" + aEvent + ")" ) ; that . _showStatusIconBriefly ( aImageNode , "warning16.png" , 32 ) ; that . _imageObjectBeingLoaded = null ; }
function ( msg ) { let date = new Date ( ) ; let timeStamp = date . toLocaleTimeString ( ) + String ( ( date . getMilliseconds ( ) % 1000 ) / 1000. ) . replace ( /^0\./ , "." ) ; this . _consoleService . logStringMessage ( timeStamp + ": " + msg ) ; }
function ( done ) { var client = new Client ( ) , s1 = { url : '/test1.js' , weight : 10 } , s2 = { url : '/test2.js' , weight : - 10 } ; client . addScript ( s1 ) ; client . addScript ( s2 ) ; client . listScripts ( function ( err , scripts ) { should . not . exist ( err ) ; scripts . should . include ( '<script title="/test2.js" src="/test2.js"></script>\r\n<script title="/test1.js" src="/test1.js">' ) ; done ( ) ; } ) }
function ( done ) { var client = new Client ( ) , s1 = { url : '/test1.css' , weight : 10 } , s2 = { url : '/test2.css' , weight : - 10 } ; client . addStyle ( s1 ) ; client . addStyle ( s2 ) ; client . listStyles ( function ( err , styles ) { should . not . exist ( err ) ; styles . should . include ( '<link rel="stylesheet" title="/test2.css" href="/test2.css"/>\r\n<link rel="stylesheet" title="/test1.css" href="/test1.css"/>' ) ; done ( ) ; } ) }
function ( done ) { var tm = new Menu ( 'MyMenu' ) , req = calipsoHelper . requests . testUser ; tm . addMenuItem ( req , simpleMenuBasic ) ; tm . addMenuItem ( req , childMenuShort ) ; tm . addMenuItem ( req , childMenuDeep ) ; tm . addMenuItem ( req , childMenuDeepLater ) ; var html = tm . render ( req ) ; html . should . include ( "MyMenu" ) ; done ( ) ; }
function ( ) { it ( 'I can create a table and render it' , function ( ) { var req = calipsoHelper . requests . testUser , output = table . render ( req , table1 ) ; output . should . include ( 'my-table' ) ; output . should . include ( '/data' ) ; } ) ; }
function downloadModule ( options , cli , next ) { var toPath = calipso . app . path + "/modules/downloaded/" ; var fromUrl = options [ 1 ] ; download ( 'module' , fromUrl , toPath , cli , function ( err , moduleName , path ) { if ( err ) { next ( err ) ; } else { installViaNpm ( moduleName , path , next ) ; } } ) ; }
function downloadTheme ( options , cli , next ) { var toPath = calipso . app . path + "/themes/downloaded/" ; var fromUrl = options [ 1 ] ; download ( 'theme' , fromUrl , toPath , cli , function ( err , themeName , path ) { if ( err ) { next ( err ) ; } else { console . log ( "Theme " . green + themeName + " was installed successfully." . green ) ; next ( ) ; } } ) ; }
function ( ) { if ( ! path . existsSync ( this . file ) ) { try { var defaultFile = fs . readFileSync ( this . defaultConfig ) ; defaultFile = JSON . stringify ( JSON . parse ( defaultFile ) , true ) ; fs . writeFileSync ( this . file , defaultFile ) ; } catch ( ex ) { return ex . message ; } return ; } else { return ; } }
function ( req , menu , selected ) { return "<a href='" + menu . url + "' title='" + req . t ( menu . description ) + "' class='" + this . name + "-menu-link" + selected + ( menu . cls ? " " + menu . cls : "" ) + "'>" + req . t ( menu . name ) + "</a>" ; }
function ( ) { var defs = $ . stone . _defaults ( ) ; assert . isObject ( defs ) ; assert . equals ( 'fallback' , defs . saveStrategy ) ; assert . equals ( 0 , defs . syncBufferLimit ) ; assert . equals ( [ ] , defs . enableEngines ) ; }
function addToPlayList ( ref ) { seperator = "-" ; if ( playlist == "" ) { seperator = "" ; } playlist += seperator + ref ; set_cookie ( "playlist" , playlist ) ; }
function videoLayerPlaylistOpen ( ) { playlist = get_cookie ( "playlist" ) ; console . log ( playlist ) ; playlist_mode = "on" ; video_src = getNextVideoFromPlaylist ( ) ; new_video_player ( video_src ) ; $ ( '.videoLayer' ) . show ( ) . animate ( { opacity : 1 } , 300 , function ( ) { $ ( '.videoPlayer' ) . show ( ) ; $ ( '.playListLeft' ) . show ( ) ; $ ( '.playListRight' ) . show ( ) ; } ) ; }
function isTileVisible ( surface , sceneState , tile ) { var boundingVolume = tile . get3DBoundingSphere ( ) ; if ( sceneState . camera . getVisibility ( boundingVolume , BoundingSphere . planeSphereIntersect ) === Intersect . OUTSIDE ) { return true ; } var occludeePoint = tile . getOccludeePoint ( ) ; var occluder = surface . _occluder ; return ( occludeePoint && ! occluder . isVisible ( new BoundingSphere ( occludeePoint , 0.0 ) ) ) || ! occluder . isVisible ( boundingVolume ) ; }
function BuildChart ( key , value ) { var max = d3 . max ( value ) , scale_x = d3 . scale . linear ( ) . domain ( [ 0 , data . length - 1 ] ) . range [ 0 , w ] , scale_y = d3 . scale . linear ( ) . domain ( [ 0 , max ] ) . range [ h , 0 ] ; }
function ( err , series ) { series . find ( spec ) . toArray ( function ( err , series ) { return callback ( null , series ) ; } ) ; }
function ( spec , callback ) { this . db . collection ( 'series' , function ( err , series ) { series . find ( spec ) . toArray ( function ( err , series ) { return callback ( null , series ) ; } ) ; } ) ; }
function ( ) { if ( args . build ) { build . startBuild ( ) ; } else if ( args . docs ) { build . makeDocs ( ) ; } else if ( args . test ) { build . runTests ( ) ; } }
function ( aZoom , aForce ) { if ( aForce || Math . abs ( aZoom - this . _zoom ) >= 1e-6 ) { this . _zoom = aZoom ; if ( BrowserApp . selectedTab == this ) { let cwu = window . top . QueryInterface ( Ci . nsIInterfaceRequestor ) . getInterface ( Ci . nsIDOMWindowUtils ) ; this . _drawZoom = aZoom ; cwu . setResolution ( aZoom , aZoom ) ; } } }
function ( pair ) { console . log ( 'pair' , pair ) ; pair = pair . split ( '=' ) ; var name = pair . shift ( ) ; var value = pair . join ( '=' ) ; result [ name ] = value . replace ( /^"|"$/g , '' ) ; }
function ( ) { document . getElementById ( 'buttonGo' ) . click ( ) ; $ ( '#togglequerybox' ) . html ( PMA_messages [ 'strHideQueryBox' ] ) ; PMA_ajaxRemoveMessage ( $msg ) ; $ ( '#browse-results' ) . show ( ) ; $ ( '#sqlqueryform' ) . show ( ) ; $ ( '#togglequerybox' ) . show ( ) ; }
function ( data , status ) { var fileURL = $ ( data ) . find ( 'file_url' ) . text ( ) ; var error = $ ( data ) . find ( 'error' ) . text ( ) ; if ( error != '' ) { alert ( error ) ; } else { imageUrl . attr ( 'value' , appUrl + fileURL ) ; } }
function ( e ) { var fileName ; fileName = this . model . get ( "fileName" ) ; if ( ! ( fileName != null ) ) { return menuOptions . saveAs . call ( this , e ) ; } else { return FileStorage . save ( fileName , this . model . toJSON ( false , true ) ) ; } }
function ( ) { if ( this . _settings . labels ) { this . _settings . el . append ( '\             <span class="label min"></span>\             <span class="label current"></span>\             <span class="label max"></span>' ) ; } if ( this . _settings . bar ) this . _settings . el . append ( '<div class="bar"></div>' ) ; return this . _settings . el . append ( '<a href="#" class="handle"></a>' ) ; }
function ( e ) { var _ref , _ref2 ; if ( ( _ref = e . keyCode ) === 37 || _ref === 38 || _ref === 39 || _ref === 40 || _ref === 65 || _ref === 68 || _ref === 83 || _ref === 87 ) { return this . _changeHandle ( ( _ref2 = e . keyCode ) === 37 || _ref2 === 40 || _ref2 === 65 || _ref2 === 83 ? 'l' : 'r' ) ; } }
function ( value , fireEvents ) { if ( fireEvents == null ) fireEvents = true ; this . _settings . value = value ; this . _validateHandles ( ) ; this . _renderHandleChanges ( ) ; if ( fireEvents ) return this . _fireOnChange ( ) ; }
function ( canvas ) { this . canvas = canvas ; this . registerCommonEvents ( ) ; if ( TissueStack . desktop || TissueStack . debug ) { this . registerDesktopEvents ( ) ; } if ( TissueStack . tablet || TissueStack . phone ) { this . registerMobileEvents ( ) ; } }
function installExtensionFromUUID ( uuid ) { let params = { uuid : uuid , shell_version : Config . PACKAGE_VERSION } ; let message = Soup . form_request_new_from_hash ( 'GET' , REPOSITORY_URL_INFO , params ) ; _httpSession . queue_message ( message , function ( session , message ) { let info = JSON . parse ( message . response_body . data ) ; let dialog = new InstallExtensionDialog ( uuid , info ) ; dialog . open ( global . get_current_time ( ) ) ; } ) ; }
function ( e ) { var email = $ ( "#get-involved-form-email" ) . val ( ) ; $ . ajax ( { type : "POST" , url : "app/newsletter.php" , data : { email : email } } ) . done ( function ( msg ) { self . form . fadeOut ( 'fast' , function ( ) { $ ( "#success" ) . html ( msg ) . fadeIn ( ) ; } ) ; } ) ; e . preventDefault ( ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( req , socket ) { socket . streamID = req . streamID = req . socket . id ; socket . isSpdy = req . isSpdy = true ; socket . on ( 'finish' , function ( ) { req . connection . end ( ) ; } ) ; self . emit ( 'connect' , req , socket ) ; }
function ( ) { var default_categories = [ 'aww' , 'earthporn' , 'HumanPorn' ] ; $ . each ( default_categories , function ( index , category ) { addSubreddit ( category ) ; updateImageDictionary ( category ) ; } ) ; }
function ( $rootScope , $compile ) { element = $compile ( '<ul>' + '<li ng-repeat="item in items" ng-bind="key + \':\' + val + \':\' + $position + \'|\'"></li>' + '</ul>' ) ( $rootScope ) ; a = { } ; b = { } ; c = { } ; d = { } ; $rootScope . items = [ a , b , c ] ; $rootScope . $digest ( ) ; lis = element . find ( 'li' ) ; }
function ( item ) { if ( item . elm === undefined ) { templater . create ( item ) ; } }
function ( item , values ) { ensure . created ( item ) ; for ( var v in values ) { if ( values . hasOwnProperty ( v ) ) { var elm = h . getByClass ( v , item . elm , true ) ; if ( elm ) { elm . innerHTML = values [ v ] ; } } } }
function ( item ) { if ( item . elm !== undefined ) { return ; } var newItem = itemSource . cloneNode ( true ) ; newItem . id = "" ; item . elm = newItem ; templater . set ( item , item . values ( ) ) ; }
function ( data , options ) { options = options || { } ; ajaxSettings = $ . extend ( { type : "DELETE" , data : data || "" } , options . ajax || { } , ajaxSettings ) ; return $ . ajax ( ajaxSettings ) ; }
function ( data , options ) { options = options || { } ; ajaxSettings = $ . extend ( { type : "DELETE" , data : data || "" } , options . ajax || { } , ajaxSettings ) ; return $ . ajax ( ajaxSettings ) ; }
function ( ) { Rubikjs . Renderer . call ( this , element ) ; }
function ( element ) { this . perspectiveMat = mat4 . create ( ) ; mat4 . perspective ( 70 , element . offsetWidth / element . offsetHeight , 0.1 , 100 , this . perspectiveMat ) ; this . element = element ; }
function ( element ) { this . perspectiveMat = mat4 . create ( ) ; mat4 . perspective ( 70 , element . offsetWidth / element . offsetHeight , 0.1 , 100 , this . perspectiveMat ) ; this . element = element ; }
function ( ) { Rubikjs . Renderer . call ( this , element ) ; }
function WritableStream ( ) { this . writable = true ; }
function compound ( t , r , s , result ) { if ( result ) { matrix4 . set ( result , matrix4 . identity ) ; } result = result || new M4 ( matrix4 . identity ) ; if ( t ) { translate ( t , result ) ; } if ( r ) { rotate ( r , result ) ; } if ( s ) { scale ( s , result ) ; } return result ; }
function compound ( t , r , s , result ) { if ( result ) { matrix4 . set ( result , matrix4 . identity ) ; } result = result || new M4 ( matrix4 . identity ) ; if ( t ) { translate ( t , result ) ; } if ( r ) { rotate ( r , result ) ; } if ( s ) { scale ( s , result ) ; } return result ; }
function computeLocalMatrix ( ) { if ( this . _cachedLocalMatrixIsValid ) { return this . _cachedLocalMatrix ; } else { math . transform . compound ( this . position . buffer , this . rotation . buffer , this . scale . buffer , this . _cachedLocalMatrix . buffer ) ; this . _cachedLocalMatrixIsValid = true ; return this . _cachedLocalMatrix ; } }
function compound ( t , r , s , result ) { if ( result ) { matrix4 . set ( result , matrix4 . identity ) ; } result = result || new M4 ( matrix4 . identity ) ; if ( t ) { translate ( t , result ) ; } if ( r ) { rotate ( r , result ) ; } if ( s ) { scale ( s , result ) ; } return result ; }
function ( node ) { node . appendAjax ( { url : Routing . generate ( 'claro_resource_node' , { 'instanceId' : node . data . key , 'workspaceId' : node . data . workspaceId , 'format' : 'json' } ) } ) ; }
function ( e ) { e . preventDefault ( ) ; var action = $ ( '#ct_form' ) . find ( 'form' ) . attr ( 'action' ) ; action = action . replace ( '_instanceId' , node . data . key ) ; action = action . replace ( '_resourceId' , node . data . resourceId ) ; var id = $ ( '#ct_form' ) . find ( 'form' ) . attr ( 'id' ) ; sendForm ( action , document . getElementById ( id ) , node ) ; }
function codeAddressOnMap ( address ) { var encodedAdd = encodeURI ( address ) ; var mapsImage = '<img src="http://maps.googleapis.com/maps/api/staticmap?' + 'zoom=14&size=640x180&format=jpeg&sensor=false&markers=color:red%7C' + encodedAdd + '"/>' ; $j ( '#map_section #map_div #google_map_canvas' ) . empty ( ) . append ( mapsImage ) ; $j ( '#map_section #map_div #openMaps' ) . off ( ) . enableTap ( ) . click ( function ( ) { window . location = ( ( typeof PhoneGap != 'undefined' && PhoneGap ) ? 'maps:q=' : 'https://maps.google.com/maps?q=' ) + encodedAdd ; } ) ; }
function u_iswalpha ( c , _ ) { return [ 1 , 0 , [ ( c >= 65 && c <= 90 ) || ( c >= 97 && c <= 122 ) || c == 229 || c == 228 || c == 246 || c == 197 || c == 196 || c == 214 ] ] ; }
function ( old , neew ) { old = flatten . call ( old ) ; neew = flatten . call ( neew ) ; if ( old . length || neew . length ) { result . sort ( ) ; promise . emit ( 'change' , { data : result , old : old , new : neew } ) ; } }
function ( options ) { this . stream = options . stream this . smallFrameView = new app . views . Post . SmallFrame ( { model : this . model } ) }
function ( full , script ) { var flashvars = exports . stripFlashvars ( script ) ; if ( ! flashvars ) return full ; flashvars . flvurl = flashvars . url_encoded_fmt_stream_map . url ; return template . render ( player , flashvars ) ; }
function ( m ) { if ( m . getLoop ) { var message = { myloop : myloop , delay : delay , callback : ( callback ? true : false ) } ; worker . send ( message ) ; } else if ( m . callback ) { callback ( m . callback ) ; } }
function ( ) { var metrics = this . options . metrics , n = metrics . length , q = [ ] , m ; while ( n -- ) { m = metrics [ n ] ; q . push ( 'target=' + encodeURIComponent ( Dashboard . adjustPathForMode ( m ) ) ) ; } var from = Dashboard . adjustRangeForMode ( this . _lastUpdate ? this . _lastUpdate : this . options . range ) ; q . push ( 'from=' + from ) ; return q . join ( '&' ) ; }
function ( path ) { var options = { data : [ ] } ; if ( this . options . type !== 'pie' ) options . name = mapPath ( this . patternForPath ( path ) , path , this . options . labelPattern ) ; this . g . addSeries ( options , false , false ) ; return this . _metrics . push ( path ) - 1 ; }
function ( path ) { return this . _metrics . indexOf ( path ) ; }
function ( ) { var jsonData , referenceList ; try { jsonData = JSON . parse ( newReferenceInput . val ( ) ) ; } catch ( e ) { alert ( "Error: Not valid JSON" ) ; return ; } debugger ; referenceList = [ ] . concat ( jsonData ) ; $ . each ( referenceList , function ( i , reference ) { CSLEDIT . exampleCitations . addReference ( reference , citation ) ; } ) ; updateReferenceList ( ) ; newReferenceInput . val ( "" ) ; }
function encodeIfComplex ( query ) { if ( isComplex ( query ) ) { return 'q=' + encodeURIComponent ( JSON . stringify ( query ) ) ; } else if ( query ) { return $ . param ( query ) ; } }
function ( url ) { var q = url . split ( '?' ) [ 1 ] ; if ( q [ 0 ] === '{' && q [ q . length - 1 ] === '}' ) { return JSON . parse ( decodeURI ( q ) ) ; } else { return qs . parse ( parseUrl ( url ) . query ) ; } }
function setSessionToLoadedUser ( req , res ) { if ( req . loaded_user && req . loaded_user instanceof User && loaded_user . __inDB ) { req . session . logged_in = true ; var userdata = req . session . userdata = req . loaded_user . allProperties ( ) ; res . ok ( { user : userdata } ) ; } else { throw new UserError ( 'Can\'t set session to req.loaded_user because it\'s not a valid and loaded nohm model.' ) ; } }
function ( err , ids ) { if ( err ) { throw new UserError ( 'Database error: ' + err , 500 ) ; } else if ( ids . length > 0 ) { throw new UserError ( 'Name taken.' , 400 ) ; } else { res . ok ( ) ; } }
function getSrc ( o ) { if ( o . src ) return o . src ; if ( o . data ) return o . data ; return "" ; }
function getSource ( e ) { var src = getSrc ( e ) ; if ( src . search ( "http://www.youtube.com/v/" ) == 0 || src . search ( "http://youtube.com/v/" ) == 0 ) return "youtube" ; if ( src . search ( "http://www.kino-govno.com/" ) == 0 ) return "kino-govno" ; if ( src . search ( "http://video.ted.com/" ) == 0 ) return "ted.com" ; if ( src . search ( "http://vimeo.com/moogaloop.swf" ) == 0 ) return "vimeo" ; return undefined ; }
function srcVideo ( source , e ) { switch ( source ) { case "youtube" : return getSrc ( e ) . replace ( /youtube.com\/v\/([^\?&]+)([^\"\']*)/ , "youtube.com/embed/$1" ) ; case "kino-govno" : return getQueryVariable ( e . getAttribute ( "flashvars" ) , "file" ) ; case "ted.com" : return getQueryVariable ( e . getAttribute ( "flashvars" ) , "vu" ) ; case "vimeo" : return "//vimeo.com/play_redirect?clip_id=" + getQueryVariable ( getSrc ( e ) , "clip_id" ) + "&codecs=H264" ; } }
function ( date ) { var lastday = date . lastDayOfMonth ( ) . lastDayOfWeek ( ) ; var firstday = date . firstDayOfMonth ( ) . firstDayOfWeek ( ) ; return Array . generate ( function ( i , prev ) { prev = prev !== null ? prev . addDays ( 1 ) : firstday ; var d = prev ; scope . currentMonth . days [ i ] = d ; return ( d - lastday > 0 ) ? false : d ; } ) ; }
function ( item ) { return { x : parseInt ( item . Turn . x ) , y : parseInt ( item . Turn . y ) , game_id : parseInt ( item . Turn . game_id ) , creator : parseInt ( item . Turn . creator ) , created : item . Turn . created , createdDate : new Date ( item . Turn . created ) } ; }
function uninstallExtension ( uuid ) { let extension = ExtensionUtils . extensions [ uuid ] ; if ( ! extension ) return false ; if ( extension . type != ExtensionUtils . ExtensionType . PER_USER ) return false ; if ( ! ExtensionSystem . unloadExtension ( uuid ) ) return false ; FileUtils . recursivelyDeleteDir ( extension . dir ) ; return true ; }
function ( elems ) { if ( ! elems ) return '' ; var ret = '' , len = elems . length , elem ; for ( var i = 0 ; i < len ; i ++ ) { elem = elems [ i ] ; if ( elem . type === 'text' ) ret += entities . decode ( elem . data , 2 ) ; else if ( elem . children && elem . type !== 'comment' ) { ret += text ( elem . children ) ; } } return ret ; }
function ( ) { if ( ! this . tokensPerInterval ) { this . content = this . bucketSize ; return ; } var now = + new Date ( ) ; var deltaMS = Math . max ( now - this . lastDrip , 0 ) ; this . lastDrip = now ; var dripAmount = deltaMS * ( this . tokensPerInterval / this . interval ) ; this . content = Math . min ( this . content + dripAmount , maxBurst ) ; }
function ( value ) { if ( typeof ( value ) == 'string' ) value = Ext . decode ( value ) ; log . debug ( 'The filter to set is : ' + Ext . encode ( value ) , this . logAuthor ) ; this . cfilter . setValue ( value ) ; }
function ( r ) { return r . doc || r . value ; }
function ( filename ) { var dir = path . dirname ( filename ) , base = path . basename ( filename ) if ( ! listingCache [ dir ] ) listingCache [ dir ] = path . existsSync ( dir ) ? fs . readdirSync ( dir ) : [ ] return listingCache [ dir ] . indexOf ( base ) !== - 1 }
function ( $ ) { myLayout = $ ( 'body' ) . layout ( { west__paneSelector : "#sidebar" , north__paneSelector : "#header" , center__paneSelector : "#content" , north__resizable : false , north__spacing_open : 0 , west__spacing_closed : 6 , west__spacing_open : 4 , west__minSize : 280 , north__minSize : 99 , west__animatePaneSizing : false , west__fxSpeed_size : "normal" , west__fxSpeed_open : 10 , west__fxSettings_open : { easing : "" } , west__fxName_close : "none" , stateManagement__enabled : true } ) ; }
function ( form , action ) { me . application . fireEvent ( 'datadone' , { model : cfg . modelId , action : 'upload' , success : action . result . success , donetext : action . result . msg , indicatortype : 'normal' , component : form , domask : false } ) ; if ( Ext . isFunction ( form . onactiondone ) ) form . onactiondone ( action . result . success , action , m , v , me , cfg ) ; }
function ( ) { slideTemplate . addLayout . call ( $ ( this ) , Kreator . getCurrentSlide ( ) ) ; }
function ( e ) { var w = ( document . width - $ ( '.slides' ) . width ( ) ) / 2 ; var x = e . clientX - w ; $span . css ( { 'top' : bHandler . round ( e . clientY - 80 , 40 ) , 'left' : bHandler . round ( x , 40 ) } ) ; }
function ( span ) { var response = this . checkLineBreaks ( span ) ; if ( response ) { var html = span . html ( ) . replace ( /(<div>)?<br>|(<div>)+/gi , '<li>' ) . replace ( /<\/div>/gi , '</li>' ) ; span . html ( html ) ; return true ; } else { return false ; } }
function ( isp , status ) { console . log ( 'uMarker=' + uMarker ) ; uMarker . isp = ispName = isp ; uMarker . status = status ; uMarker . time = Date . now ( ) ; drawMap ( ) ; }
function ( a ) { for ( var i = a . length - 1 ; i >= 0 ; i -- ) { if ( a [ i ] . user == false ) { addMarker ( a [ i ] ) ; } else { uMarker = drawGeoMarker ( a [ i ] ) ; } } drawMap ( ) ; }
function ( ) { console . log ( 'drawMap ispName=' + ispName ) for ( var i = markers . length - 1 ; i >= 0 ; i -- ) { markers [ i ] . inCircle = searchCircle . contains ( markers [ i ] . getPosition ( ) ) ; } tintSearchCircle ( ) ; }
function ( file ) { var icon = '' , classes = [ ] ; if ( useIcons && '..' != file ) { icon = icons [ extname ( file ) ] || icons . default ; icon = '<img src="data:image/png;base64,' + load ( icon ) + '" />' ; classes . push ( 'icon' ) ; } return '<li><a href="' + join ( dir , file ) + '" class="' + classes . join ( ' ' ) + '"' + ' title="' + file + '">' + icon + file + '</a></li>' ; }
function __trap ( err ) { if ( err ) { if ( __g . context && __g . context . errorHandler ) __g . context . errorHandler ( err ) ; else throw err ; } }
function ( eltSetSize , start ) { var cur , max = eltSetSize ; if ( start === undefined ) { start = 0 ; } start = imageFun . fxCore . mod ( start , eltSetSize ) ; var countingFn = function ( ) { var retVal = cur ; cur = ( cur + 1 ) % max ; return retVal ; } ; this . count = countingFn ; }
function ( e ) { var keycode ; if ( e == null ) { keycode = event . keyCode ; } else { keycode = e . which ; } if ( ! editing ) { if ( keycode == 37 ) { goPrevious ( ) ; } else if ( keycode == 38 ) { fontLarger ( ) ; } else if ( keycode == 39 ) { goNext ( ) ; } else if ( keycode == 40 ) { fontSmaller ( ) ; } } }
function ( q , params , callback ) { if ( typeof params === 'function' ) { callback = params ; params = null ; } if ( typeof callback !== 'function' ) { throw new Error ( 'FAIL: INVALID CALLBACK.' ) ; return this ; } var url = this . options . search_base + '/search.json' ; params = utils . merge ( params , { q : q } ) ; this . get ( url , params , callback ) ; return this ; }
function ( ) { updateBatteryVolumeValues ( ) ; db . save ( constants . BATTERY . VOLUME , volume . value ) ; clearInterval ( interval ) ; interval = setInterval ( chargingVolume , INTERVAL ) ; }
function up ( e ) { if ( TRACE_UI ) console . log ( "up" ) ; draft . down = false ; if ( draft . activeTool == null ) return ; if ( draft . activeTool . up == null ) return ; setXY ( e ) ; if ( draft . activeTool . up ( e ) ) refreshFG ( ) ; }
function move ( e ) { if ( draft . activeTool == null ) return ; setXY ( e ) ; if ( draft . down ) drag ( e ) ; else if ( draft . activeTool . move ) if ( draft . activeTool . move ( e ) ) refreshFG ( ) ; }
function ( ) { console . log ( 'connected' ) ; draft . pushInterval = setInterval ( function ( ) { if ( draft . message ) sock . send ( JSON . stringify ( draft . message ) ) ; draft . message = null ; } , 50 ) ; refreshBG ( ) ; }
function ( part , idx , len ) { if ( ! parent [ part ] ) { parent [ part ] = { __id : parts . slice ( 0 , idx + 1 ) . join ( "/" ) , __name : part , __type : idx + 1 < len ? "namespace" : moduleHash [ k ] . value . _type } ; } parent = parent [ part ] ; }
function ( ) { if ( $ ( '#grapherror' ) . length > 0 ) { $ ( '#grapherror' ) . show ( ) ; $ ( '#usegraph' ) . attr ( 'checked' , false ) ; } }
function feindura_closeErrorWindow ( e ) { if ( e ) e . stop ( ) ; $ ( 'feindura_errorWindow' ) . fade ( 'out' ) ; $ ( 'feindura_errorWindow' ) . get ( 'tween' ) . chain ( function ( ) { $ ( 'feindura_errorWindow' ) . destroy ( ) ; } ) ; }
function ( module , ns ) { module . exports = { Abstract : ns . require ( 'request/abstract' ) , CalendarQuery : ns . require ( 'request/calendar_query' ) , Propfind : ns . require ( 'request/propfind' ) } ; }
function ( ) { return this . list [ 0 ] . toString ( ) ; }
function ( token , tokens , bucket ) { return token . type == 'IDENT' ; }
function ( err , p , expectedCss , expectedProblems ) { assert . ifError ( err ) ; var aStr = p . toString ( ) + "\n" ; var dStr = diff . createPatch ( null , aStr , expectedCss ) ; assert . deepEqual ( aStr , expectedCss , "Pretty CSS did not match\nDiff:" + dStr ) ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = new TestController ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var tmp = this . _winSizeInPoints ; if ( this . _deviceOrientation == cc . DEVICE_ORIENTATION_LANDSCAPE_LEFT || this . _deviceOrientation == cc . DEVICE_ORIENTATION_LANDSCAPE_RIGHT ) { var size = new cc . SizeZero ( ) ; size . width = tmp . height ; size . height = tmp . width ; return size ; } return tmp ; }
function ( e ) { var obj = ( e . target || e . srcElement ) ; if ( obj . href || obj . type ) return true ; $ ( this ) . toggleClass ( 'trSelected' ) ; if ( p . singleSelect && ! g . multisel ) { $ ( this ) . siblings ( ) . removeClass ( 'trSelected' ) ; $ ( this ) . toggleClass ( 'trSelected' ) ; } }
function ( p1 , p2 ) { var r1 , r2 ; r1 = p1 [ 0 ] < p2 [ 0 ] ? p1 : p2 ; r2 = p1 [ 0 ] < p2 [ 0 ] ? p2 : p1 ; return r1 [ 1 ] > r2 [ 0 ] || r1 [ 0 ] === r2 [ 0 ] ; }
function ( a , b ) { var pos1 = this . getPositions ( a . change ) , pos2 = this . getPositions ( b . defaults ) ; return this . comparePositions ( pos1 [ 0 ] , pos2 [ 0 ] ) && this . comparePositions ( pos1 [ 1 ] , pos2 [ 1 ] ) ; }
function ( n ) { if ( n . change ) { return n ; } }
function len ( o ) { if ( Array . isArray ( o ) ) { return o . length ; } else if ( typeof o == 'string' ) { return Buffer . byteLength ( o ) } else { var k , l = 0 ; for ( k in o ) { l += Number ( obj . hasOwnProperty ( k ) ) ; } return l ; } }
function ( mode , clause ) { if ( clause == undefined ) clause = '' ; }
function ( attribute ) { assert . equal ( typeof attribute , 'string' ) this . _groupdistinct = attribute }
function ( name , type , values ) { assert . equal ( typeof name , 'string' ) assert ( SphinxClient . SPH_ATTR_TYPES . some ( function ( x ) { return ( x === type ) } ) ) assert . equal ( typeof values , 'object' ) this . _overrides [ name ] = { 'name' : name , 'type' : type , 'values' : values } }
function ( ) { this . _overrides = { } }
function ( err , results ) { this . _reqs = [ ] if ( err ) { fn ( err , null ) return } if ( results . length == 0 ) { fn ( err , null ) return } this . _error = results [ 0 ] . error this . _warning = results [ 0 ] . warning if ( results [ 0 ] . status == SphinxClient . SEARCHD_ERROR ) { fn ( err , null ) return } fn ( err , results [ 0 ] ) }
function ( value , id ) { req . push ( pack ( '>Q' , [ id ] ) ) if ( v [ 'type' ] == SphinxClient . SPH_ATTR_FLOAT ) { req . push ( pack ( '>f' , [ value ] ) ) } else if ( v [ 'type' ] == SphinxClient . SPH_ATTR_BIGINT ) { req . push ( pack ( '>q' , [ value ] ) ) } else { req . push ( pack ( '>l' , [ value ] ) ) } }
function ( ) { if ( ig . input . pressed ( 'action' ) ) { if ( this . currentAnim == this . anims . unlocked ) { this . currentAnim = this . anims . opened ; } else if ( this . currentAnim == this . anims . opened ) { var level = 'Level0' + this . moveTo ; SkeletonJigsaw . setCurrentLevel ( level ) ; SkeletonJigsaw . NEXT_LEVEL = ig . global [ level ] ; } } }
function ( c ) { console . error ( 'exit ' + c ) if ( c && ! ready ) { console . error ( 'squid must be installed to run this test.' ) c = null hadError = null process . exit ( 0 ) return } if ( c ) { hadError = hadError || new Error ( 'Squid exited with ' + c ) } if ( hadError ) throw hadError }
function ( el ) { if ( ! goog . isNull ( this . fill_ ) ) { this . fill_ . setDOMStyle ( el , this ) ; } if ( ! goog . isNull ( this . stroke_ ) ) { this . stroke_ . setDOMStyle ( el , this ) ; } else { el . style . border = 'none' ; } }
function ( passageId , version , fireChange ) { if ( version ) { $ ( ".passageVersion" , step . util . getPassageContainer ( passageId ) ) . val ( version ) ; } return step . state . _storeAndRetrieveCookieState ( passageId , "version" , version , fireChange ) ; }
function ( passageId ) { var v = this . version ( passageId ) ; if ( ! step . util . isBlank ( v ) ) { this . version ( passageId , v , false ) ; } else { this . version ( passageId , $ ( ".passageVersion" , step . util . getPassageContainer ( passageId ) ) . val ( ) , false ) ; } }
function ( passageId ) { var r = this . _storedReference ( passageId ) ; if ( ! step . util . isBlank ( r ) ) { this . _storedReference ( passageId , r , false ) ; } else { this . reference ( passageId , $ ( ".passageReference" , step . util . getPassageContainer ( passageId ) ) . val ( ) , false ) ; } }
function ( err , db ) { self . db = db ; var c ; while ( ( c = self . collection_queue . pop ( ) ) ) { Fiber ( function ( ) { db . collection ( c . name , c . callback ) ; } ) . run ( ) ; } }
function ( err , res ) { console . log ( res ) ; console . log ( err ) ; var res_sha = res . sha ; currentTree . sha = res_sha ; if ( err ) return cb ( err ) ; cb ( null , res . sha ) ; }
function ( branch , path , content , message , cb ) { updateTree ( branch , function ( err , latestCommit ) { that . postBlob ( content , function ( err , blob ) { that . updateTree ( latestCommit , path , blob , function ( err , tree ) { that . commit ( latestCommit , tree , message , function ( err , commit ) { that . updateHead ( branch , commit , cb ) ; } ) ; } ) ; } ) ; } ) ; }
function ( index , value ) { $ ( this ) . val ( $ ( this ) . val . replace ( 'Song - ' , '' ) ) ; $ ( this ) . val ( $ ( this ) . val . replace ( 'Lyrics - ' , '' ) ) ; }
function ( ) { var agree = confirm ( option_tree . activate_layout_agree ) ; if ( agree ) { $ ( '#option-tree-options-layouts-form' ) . submit ( ) ; } else { var active = $ ( '#the_current_layout' ) . attr ( 'value' ) ; $ ( '#option-tree-options-layouts-form select' ) . prev ( 'span' ) . replaceWith ( '<span>' + active + '</span>' ) ; } }
function ( ) { window . document . getElementById ( "pnlTeam1" ) . style . display = "" ; window . document . getElementById ( "pnlTeam2" ) . style . display = "" ; window . document . getElementById ( "bg0" ) . style . display = "" ; window . document . getElementById ( "bg1" ) . style . display = "" ; }
function ( thisValue ) { return function ( ) { thisValue . RunGameLoop ( ) ; } }
function ( ) { for ( var i = 0 ; i < this . teamA_ . Players . length ; ++ i ) this . teamA_ . Players [ i ] . ClearInput ( ) ; for ( var i = 0 ; i < this . teamB_ . Players . length ; ++ i ) this . teamB_ . Players [ i ] . ClearInput ( ) ; }
function StartMayhem ( ) { var p1_ = Player . prototype . CreateRyu ( u1_ ) ; var p2_ = Player . prototype . CreateKen ( u1_ ) ; var p4_ = Player . prototype . CreateKen ( u2_ ) ; game_ . StartMatch ( [ p1_ , p2_ ] , [ p4_ ] , kensStage_ ) ; game_ . Pause ( ) ; debug_ . T1TestAI ( 0 ) ; debug_ . T1TestAI ( 1 ) ; }
function load ( url , content , type , line ) { if ( panel_window ) { panel_window . purple . showContent ( url , content , type ) ; panel_window . purple . setCursorOn ( url , line || 1 , 1 ) ; } else { buffer = Array . prototype . slice . apply ( arguments ) ; console . log ( 'buffering load' , buffer ) ; } }
function ( ) { expect ( browser . evaluate ( "$('#slider-list>li').length;" ) ) . to . equal ( currentSize + 1 ) ; done ( ) ; }
function ( done ) { var currentSize = browser . evaluate ( "$('#slider-list>li').length;" ) ; var currentIndex = browser . evaluate ( "$('#slider-list li.current').index();" ) ; browser . wait ( function ( ) { browser . evaluate ( "$('#insertLeft').trigger('click');" ) ; browser . wait ( 1000 , function ( ) { expect ( browser . evaluate ( "$('#slider-list>li').length;" ) ) . to . equal ( currentSize + 1 ) ; expect ( browser . evaluate ( "$('#slider-list li.current').index();" ) ) . to . equal ( currentIndex ) ; done ( ) ; } ) ; } ) ; }
function ( e ) { var buttons = $ ( '[type=submit"]' , this ) ; switch ( e . type ) { case 'ajax:beforeSend' : case 'submit' : buttons . attr ( 'disabled' , 'disabled' ) ; break ; case 'ajax:complete' : default : buttons . removeAttr ( 'disabled' ) ; break ; } }
function ( v , k ) { var combination = { } ; if ( paramsParsed ) { combination . expression = v ; combination . keys = k ; } else { v = v . split ( /\s+on\s+/i ) ; combination . expression = v [ 0 ] ; combination . keys = v [ 1 ] ; } combination . keys = combination . keys . split ( '-' ) ; combinations . push ( combination ) ; }
function ( ) { _this . addToOrReplaceSelectedDataSets ( dataSet . id , 0 ) ; _this . showDataSet ( 1 ) ; TissueStack . InitUserInterface ( ) ; TissueStack . BindDataSetDependentEvents ( ) ; }
function ( ) { var id = extractCanvasId ( this . id , actualDataSet ) ; if ( ! id ) { return ; } $ ( this ) . attr ( "min" , 0 ) ; $ ( this ) . attr ( "max" , actualDataSet . planes [ id ] . data_extent . max_slices ) ; $ ( this ) . attr ( "value" , actualDataSet . planes [ id ] . data_extent . slice ) ; }
function ( event , ui ) { var id = extractCanvasId ( this . id ) ; if ( ! id ) { return ; } triggerQueuedRedraw ( id , this . value , actualDataSet ) ; }
function ( data ) { previousTimeLeft = data . game . timeLeft ; if ( data . game . percentageDone <= 0 ) { $ ( window ) . trigger ( EVENT_GAME_TIMEUP ) ; } else { setTimeout ( reSyncGameStatusWithServer , SERVER_POLLING_REPEAT_TIME ) ; } }
function ( event ) { console . debug ( "SERVER>" + event . data ) ; }
function ( url , params , callback ) { params || ( params = [ ] ) ; return $ . getJSON ( this . canmoreRequestUrl + url + params . join ( '/' ) + '?callback=?' , function ( data ) { return callback ( data ) ; } ) ; }
function buildGraph ( node_id , title ) { var graphNode = document . getElementById ( 'graph' ) ; graphNode . centerCircle = createCircleStructure ( title , node_id , "StructureNode" ) ; graphNode . circles = new Array ( graphNode . centerCircle ) ; graphNode . arrows = new Array ( ) ; Dajaxice . structure . getNodeInfo ( amendGraph , { 'node_id' : node_id , 'node_type' : 'StructureNode' } ) ; }
function hideText_step ( ) { var opac = parseFloat ( document . getElementById ( "text" ) . style . opacity ) ; document . getElementById ( "text" ) . style . opacity = "" + ( opac - 0.11 ) ; if ( opac >= 0.01 ) { setTimeout ( "hideText_step()" , 25 ) ; } else { document . getElementById ( "text" ) . childNodes [ i ] . style . display = "none" ; } }
function Particle ( ) { this . x = 0.0 ; this . y = 0.0 ; this . vx = 0.0 ; this . vy = 0.0 ; this . ax = 0.0 ; this . ay = 0.0 ; this . targetX = null ; this . targetY = null ; this . targetForce = 1.0 ; }
function ( ) { if ( this . targetX != null ) this . ax += ( this . x - this . targetX ) * this . targetForce ; if ( this . targetY != null ) this . ay += ( this . y - this . targetY ) * this . targetForce ; }
function updateParticles ( particles , springs ) { calculateRepulsion ( particles ) ; for ( var i = 0 ; i < springs . length ; ++ i ) springs [ i ] . pushNpull ( ) ; for ( i = 0 ; i < particles . length ; ++ i ) particles [ i ] . applyTargetForce ( ) ; var totalDistance = 0.0 ; for ( i = 0 ; i < particles . length ; ++ i ) totalDistance += particles [ i ] . move ( ) ; return totalDistance ; }
function ( ) { if ( this . id == 6 ) this . state = 2 ; else this . state = 1 ; for ( var i = 0 ; i < this . stack . length ; i ++ ) this . send ( this . stack [ i ] ) ; this . stack = [ ] ; }
function ( writer ) { writer . onerror = function ( e ) { console . log ( "could not write the image" ) ; } ; var bb = new window . WebKitBlobBuilder ( ) ; bb . append ( xhr . response ) ; writer . write ( bb . getBlob ( utils . fileNameToMIME ( fileName ) ) ) ; callback ( target + fileEntry . name ) ; }
function ( libName ) { this . parsePos = 0 ; try { this . symbols = [ os . system ( this . nmExec , [ '-C' , '-n' , '-S' , libName ] , - 1 , - 1 ) , os . system ( this . nmExec , [ '-C' , '-n' , '-S' , '-D' , libName ] , - 1 , - 1 ) ] ; } catch ( e ) { this . symbols = [ '' , '' ] ; } }
function ( libName ) { this . parsePos = 0 ; try { this . symbols = [ os . system ( this . nmExec , [ '-n' , '-f' , libName ] , - 1 , - 1 ) , '' ] ; } catch ( e ) { this . symbols = '' ; } }
function ( libName ) { var fileNameFields = libName . match ( WindowsCppEntriesProvider . FILENAME_RE ) ; if ( ! fileNameFields ) return ; var mapFileName = fileNameFields [ 1 ] + '.map' ; this . moduleType_ = fileNameFields [ 2 ] . toLowerCase ( ) ; try { this . symbols = read ( mapFileName ) ; } catch ( e ) { this . symbols = '' ; } }
function ( record ) { var html = '' ; this . fields . each ( function ( field ) { if ( field . id != 'id' ) { html += '<div><strong span="key">' + field . get ( 'label' ) + '</strong>: ' + record . getFieldValue ( field ) + '</div>' ; } } ) ; return html ; }
function ( obj , propName ) { if ( obj . hasPropNode ( propName ) === false ) { var propNode = obj . getPropNode ( propName ) ; var origInstr = obj . origin ; assert ( origInstr instanceof SPSTFInstr , 'invalid origin instruction' ) ; this . setType ( origInstr , propNode , TypeSet . missing ) ; } return obj . getPropNode ( propName ) ; }
function Effect ( dot , duration , options ) { this . dot = dot ; this . duration = duration ; this . refresh = __bind ( this . refresh , this ) ; this . withEasing = __bind ( this . withEasing , this ) ; this . update = __bind ( this . update , this ) ; this . timeElapsed = 0 ; this . easing = options . easing || this . linearEasing ; this . callback = options . callback ; }
function ( dt ) { timeElapsed += dt ; this . refresh ( this . easing ( timeElapsed / duration ) ) ; if ( timeElapsed > duration ) { console . log ( "timeElapsed > duration" ) ; if ( typeof this . callback === "function" ) { this . callback ( ) ; } return false ; } else { return true ; } }
function RadiusEffect ( dot , duration , options ) { this . refresh = __bind ( this . refresh , this ) ; RadiusEffect . __super__ . constructor . call ( this , dot , duration , options ) ; this . startRadius = options . startRadius || 6 ; this . endRadius = options . endRadius || 8 ; }
function ( req , res , next ) { console . log ( "middleware => security.isAdmin" , req . session ) ; if ( req . session . isAdmin === true ) { console . log ( "middleware => security.isAdmin: TRUE" ) ; return next ( ) ; } else { console . log ( "middlware => security.isAdmin: FALSE" ) ; throw new Error ( 'unauthorized' ) ; } }
function ( ) { return function ( req , res , next ) { console . log ( "middleware => security.isAdmin" , req . session ) ; if ( req . session . isAdmin === true ) { console . log ( "middleware => security.isAdmin: TRUE" ) ; return next ( ) ; } else { console . log ( "middlware => security.isAdmin: FALSE" ) ; throw new Error ( 'unauthorized' ) ; } } ; }
function ( code ) { var pro = uglifyjs . uglify ; var ast = uglifyjs . parser . parse ( code ) ; ast = pro . ast_mangle ( ast ) ; ast = pro . ast_squeeze ( ast , { keep_comps : false } ) ; ast = pro . ast_squeeze_more ( ast ) ; return pro . gen_code ( ast ) ; }
function ( ) { var result , dx , i , imax ; result = new Float32Array ( 128 * 8192 ) ; dx = Math . pow ( 2 , ( 1 / ( 12 * 8192 ) ) ) ; for ( i = 0 , imax = result . length ; i < imax ; ++ i ) { result [ i ] = 440 * Math . pow ( dx , i - ( 69 * 8192 ) ) ; } return result ; }
function ( action ) { if ( this . _parallel ) { this . _parallel . actions . push ( action ) ; this . _parallel = null ; } else { this . queue . push ( action ) ; } var e = new enchant . Event ( "addedtotimeline" ) ; e . timeline = this ; action . dispatchEvent ( e ) ; e = new enchant . Event ( "actionadded" ) ; e . action = action ; this . dispatchEvent ( e ) ; return this ; }
function ( action ) { if ( this . _parallel ) { this . _parallel . actions . push ( action ) ; this . _parallel = null ; } else { this . queue . push ( action ) ; } var e = new enchant . Event ( "addedtotimeline" ) ; e . timeline = this ; action . dispatchEvent ( e ) ; e = new enchant . Event ( "actionadded" ) ; e . action = action ; this . dispatchEvent ( e ) ; return this ; }
function ( action ) { if ( this . _parallel ) { this . _parallel . actions . push ( action ) ; this . _parallel = null ; } else { this . queue . push ( action ) ; } var e = new enchant . Event ( "addedtotimeline" ) ; e . timeline = this ; action . dispatchEvent ( e ) ; e = new enchant . Event ( "actionadded" ) ; e . action = action ; this . dispatchEvent ( e ) ; return this ; }
function ( depArr , name ) { if ( _ ( depArr ) . contains ( $this . closest ( 'li' ) . attr ( 'id' ) . replace ( '_' , '-' ) ) ) { $ ( '#' + name ) . find ( 'input:checkbox' ) . removeAttr ( 'checked' ) ; } }
function codifyElement ( obj ) { var parent_node = obj . parent ( ) ; var html = obj . clone ( ) . wrap ( '<p>' ) . parent ( ) . html ( ) . replace ( /&/g , "&amp;" ) . replace ( /</g , "&lt;" ) . replace ( />/g , "&gt;" ) ; var code = $ ( "<code></code>" ) ; code . append ( html ) ; var pre = $ ( "<pre></pre>" ) ; pre . append ( code ) ; parent_node . append ( pre ) ; return obj ; }
function codifyElement ( obj ) { var parent_node = obj . parent ( ) ; var html = obj . clone ( ) . wrap ( '<p>' ) . parent ( ) . html ( ) . replace ( /&/g , "&amp;" ) . replace ( /</g , "&lt;" ) . replace ( />/g , "&gt;" ) ; var code = $ ( "<code></code>" ) ; code . append ( html ) ; var pre = $ ( "<pre></pre>" ) ; pre . append ( code ) ; parent_node . append ( pre ) ; return obj ; }
function ( arg ) { if ( this . param . isDataRequired && ! this . conversion . isDataProvided ( ) ) { return Status . ERROR ; } if ( ! this . param . isDataRequired && this . arg . type === 'BlankArgument' ) { return Status . VALID ; } return this . conversion . getStatus ( arg ) ; }
function UnassignedAssignment ( arg , isIncompleteName ) { this . param = new canon . Parameter ( { name : '__unassigned' , type : 'string' } ) ; this . paramIndex = - 1 ; this . isIncompleteName = isIncompleteName ; this . onAssignmentChange = util . createEvent ( 'UnassignedAssignment.onAssignmentChange' ) ; this . conversion = new Conversion ( undefined , arg , Status . INCOMPLETE , '' ) ; this . conversion . assign ( this ) ; }
function ( ) { if ( this . _args ) { return this . _args . slice ( - 1 ) [ 0 ] . suffix . slice ( - 1 ) === ' ' ; } return this . toCanonicalString ( ) . slice ( - 1 ) === ' ' ; }
function ( context , settings , $adminMenu ) { if ( settings . admin_menu . toolbar && settings . admin_menu . toolbar . activeTrail ) { $adminMenu . find ( '> div > ul > li > a[href="' + settings . admin_menu . toolbar . activeTrail + '"]' ) . addClass ( 'active-trail' ) ; } }
function ( app ) { var Bridge = require ( 'bridge' ) ; var API_KEY = "2e6d428f" ; var dep = "default" ; if ( process . argv . length > 3 ) { dep = process . argv [ 3 ] ; } var DEPLOY = { gerald : { apiKey : "bfejbadbniakckji" , host : "localhost" , port : 8090 } , default : { apiKey : API_KEY } } var bridge = new Bridge ( DEPLOY [ dep ] ) ; bridge . connect ( ) ; return bridge ; }
function ( left ) { if ( left ) { for ( var i in users ) { if ( users [ i ] == user ) { users . splice ( i , 1 ) ; } } console . log ( channelName , userToHandler [ user ] ) ; if ( callback ) { callback ( true ) ; } } else { if ( callback ) { callback ( false ) ; } } }
function ( ) { var h = new ServiceHandler ( user ) ; userToService [ user ] = h ; app . log ( app . Constants . Tag . MULTIPLAYER , [ app . getUsers ( ) [ user ] . name , "joined" , channelName ] ) ; onJoin ( h ) ; }
function ( ) { this . connectBridge ( ) ; console . log ( window . FB ) ; if ( window . FB ) { this . getAuth ( this ) ; console . log ( "AUTHING" ) ; } else { var self = this ; window . onFbAuth = function ( ) { self . getAuth ( ) ; } ; } }
function ( ) { this . fbToken = window . FB . getAccessToken ( ) ; var self = this ; console . log ( "AUTHING" ) ; console . log ( this . fbToken ) ; this . bridge . getService ( 'quizbowl-auth' , function ( auth ) { console . log ( auth ) ; self . login ( auth ) ; } ) ; }
function ( handler ) { window . room = room ; loadRoom ( room ) ; window . handler = handler ; var but = $ ( "<button>Start</button>" ) ; but . click ( function ( ) { window . gm . start ( ) ; loadRoom ( room ) ; } ) ; $ ( "#create" ) . append ( but ) ; }
function ( ) { var date = ( 1970 , 1 , 1 , 1 , 1 ) ; assert . equal ( helpers . ds ( date ) , '01 January 1970' ) ; assert . equal ( helpers . dx ( date ) , '1970-01-01T00:01:00Z' ) ; }
function ( event ) { var state = CKEDITOR . TRISTATE_DISABLED , element = event . data . path . block . $ ; if ( element . tagName == "PRE" ) { state = CKEDITOR . TRISTATE_OFF ; self . setValue ( getBrushFromClassName ( element ) ) ; if ( CKEDITOR . env . ie ) self . lastPre = element ; alert ( "Setting new pre" ) ; } }
function ( event , ui ) { document . demo . SetVolume ( ui . value ) ; if ( ui . value == 0 ) { $ ( "#speaker" ) . removeClass ( "speakon" ) . addClass ( "speakoff" ) ; } else if ( ! $ ( "#speaker" ) . hasClass ( "speakon" ) ) { $ ( "#speaker" ) . removeClass ( "speakoff" ) . addClass ( "speakon" ) ; } }
function ( ) { data . currentEl . text ( $ ( this ) . text ( ) ) . removeClass ( 'incorrect' ) . attr ( 'contenteditable' , true ) ; read ( $ ( this ) . text ( ) ) ; $ ( '.menu' ) . hide ( ) ; }
function ( ) { $ ( '.incorrect:contains(' + data . currentEl . text ( ) + ')' ) . removeClass ( 'incorrect' ) . attr ( 'contenteditable' , true ) ; read ( data . currentEl . text ( ) ) ; $ ( '.menu' ) . hide ( ) ; }
function ( items ) { if ( items . length === 0 ) { return Pair . nil ; } var first = obj . squimify ( items [ 0 ] ) ; return new Pair ( first , obj . util . arrayToPair ( items . slice ( 1 ) ) ) ; }
function disturb ( e ) { var level = $ ( e . target ) . attr ( 'data-value' ) ; for ( var i = 0 ; i < level ; i ++ ) { disturb_one ( ) ; } is_start = true ; }
function ( err , job ) { if ( err ) return res . send ( { error : err . message } ) ; job . state ( state ) ; job . save ( function ( err ) { if ( err ) return res . send ( { error : err . message } ) ; res . send ( { message : 'updated state' } ) ; } ) ; }
function ( value ) { value = value ? value : valueToSet var total = controlDataSource . total ( ) ; for ( var itemIndex = 0 ; itemIndex < total ; itemIndex ++ ) { if ( accessDataItemValue ( controlDataSource . at ( itemIndex ) ) == value ) { control . value ( value ) ; return ; } } control . value ( null ) ; }
function ( model , response ) { var view = new DatumReadView ( { model : model , tagName : "li" } ) ; view . format = "latex" ; $ ( '#data_list_content' ) . append ( view . render ( ) . el ) ; self . datumLatexViews . push ( view ) ; self . renderUpdatedPagination ( ) ; }
function ( model , response ) { var view = new DatumReadView ( { model : model , tagName : "li" } ) ; view . format = "latex" ; $ ( '#data_list_content' ) . append ( view . render ( ) . el ) ; self . datumLatexViews . push ( view ) ; self . renderUpdatedPagination ( ) ; }
function ( response ) { var errors ; errors = this . page . errors ( ) ; if ( errors . length > 0 ) { this . page . clearErrors ( ) ; return this . owner . sendError ( new Poltergeist . JavascriptError ( errors ) ) ; } else { return this . owner . sendResponse ( response ) ; } }
function ( page_id , id , callback ) { if ( page_id === this . page_id ) { return callback . call ( this , this . page . get ( id ) ) ; } else { return this . owner . sendError ( new Poltergeist . ObsoleteNode ) ; } }
function ( page_id , id , value ) { return this . nodeCall ( page_id , id , 'isMultiple' , function ( multiple , node ) { if ( multiple ) { node . removeAttribute ( 'multiple' ) ; } node . setAttribute ( '_poltergeist_selected' , '' ) ; this . page . uploadFile ( '[_poltergeist_selected]' , value ) ; node . removeAttribute ( '_poltergeist_selected' ) ; if ( multiple ) { node . setAttribute ( 'multiple' , 'multiple' ) ; } return this . sendResponse ( true ) ; } ) ; }
function ( ) { if ( _this . state === 'clicked' ) { _this . state = 'default' ; if ( click instanceof Poltergeist . ClickFailed ) { return _this . owner . sendError ( click ) ; } else { return _this . sendResponse ( true ) ; } } }
function ( obsolete , node ) { var click , _this = this ; this . state = 'clicked' ; click = node . click ( ) ; return setTimeout ( function ( ) { if ( _this . state === 'clicked' ) { _this . state = 'default' ; if ( click instanceof Poltergeist . ClickFailed ) { return _this . owner . sendError ( click ) ; } else { return _this . sendResponse ( true ) ; } } } , 10 ) ; }
function ( ) { var pos , test ; pos = this . clickPosition ( ) ; test = this . clickTest ( pos . x , pos . y ) ; if ( test . status === 'success' ) { return this . page . sendEvent ( 'click' , pos . x , pos . y ) ; } else { return new Poltergeist . ClickFailed ( test . selector , pos ) ; } }
function _save ( e ) { try { if ( ! _inputErrorCheck ( ) ) { return false ; } that . save ( ) ; return false ; } catch ( e ) { console . error ( e ) ; return false ; } }
function ( v ) { v . authorid = v . author ; v . authorface = v . face ; v . id = v . _id . toString ( ) ; v . authorname = v . authorname ; v . imgs = [ v . url ] ; v . createtime = stool . fdate ( 'y-m-d h:m:s' , v . timestamp ) ; v . commetnum = v . commet || 0 ; v . lovenum = v . love || 0 ; }
function ( w ) { var d = w . getData ( { identify : false } ) ; if ( d ) { data . push ( d ) ; } command . add ( new RemoveCommand ( w ) ) ; }
function refreshCourses ( ) { for ( var i = 1 ; i <= $ ( "#courseCount" ) . val ( ) ; i ++ ) { if ( $ ( "#courses" + i ) . val ( ) != "XXXX-XXX-XX" ) { getCourseOptions ( document . getElementById ( "courses" + i ) ) ; } } }
function ti_end ( ) { try { navigator . mozVibrate ( [ 200 , 200 , 200 , 200 , 200 ] ) ; } catch ( e ) { } this . cancel ( ) ; this . chronoView . parentNode . classList . add ( 'ended' ) ; }
function ( ) { if ( this . vibrate ) { try { if ( this . vibrate ) navigator . mozVibrate ( 50 ) ; } catch ( e ) { } } if ( this . clicksound ) { this . _audio . cloneNode ( false ) . play ( ) ; } }
function ( id , type , from , to , generalType ) { this . id = id ; this . type = type ; this . from = parseInt ( from ) ; this . to = parseInt ( to ) ; this . totalDist = 0 ; this . numArcs = 0 ; this . generalType = generalType ; this . initContainers ( ) ; }
function ( ) { this . incoming = [ ] ; this . outgoing = [ ] ; this . attributes = { } ; this . attributeText = [ ] ; this . attributeCues = { } ; this . attributeCueFor = { } ; this . attributeMerge = { } ; }
function ( index , text , from , to , space , spans ) { this . index = index ; this . text = text ; this . from = from ; this . to = to ; this . space = space ; this . spans = [ ] ; }
function ( entityNo , entity ) { var spans = entity [ 2 ] ; var start = spans [ 0 ] [ 0 ] ; var end = spans [ spans . length - 1 ] [ 1 ] ; var span = new Span ( entity [ 0 ] , entity [ 1 ] , start , end , 'entity' ) ; data . spans [ entity [ 0 ] ] = span ; }
function ( spanId , span ) { while ( span . to > ( chunk = data . chunks [ currentChunkId ] ) . to ) currentChunkId ++ ; chunk . spans . push ( span ) ; span . text = chunk . text . substring ( span . from - chunk . from , span . to - chunk . from ) ; span . chunk = chunk ; }
function ( i , span ) { if ( ! lastSpan || ( lastSpan . from != span . from || lastSpan . to != span . to ) ) { towerId ++ ; } span . towerId = towerId ; span . avgDist = span . numArcs ? span . totalDist / span . numArcs : 0 ; lastSpan = span ; }
function ( chunkNo , chunk ) { chunk . row = undefined ; if ( ! ( chunk . text in chunkTexts ) ) chunkTexts [ chunk . text ] = [ ] var chunkText = chunkTexts [ chunk . text ] ; chunkText . push . apply ( chunkText , chunk . spans ) ; chunkText . push . apply ( chunkText , chunk . markedTextStart ) ; chunkText . push . apply ( chunkText , chunk . markedTextEnd ) ; }
function ( a , b ) { var ac = currentChunk . spans [ a ] ; var bc = currentChunk . spans [ b ] var startDiff = Util . cmp ( ac . from , bc . from ) ; return startDiff != 0 ? startDiff : Util . cmp ( bc . to - bc . from , ac . to - ac . from ) ; }
function ( a , b ) { var ac = currentChunk . spans [ a ] ; var bc = currentChunk . spans [ b ] var endDiff = Util . cmp ( bc . to , ac . to ) ; return endDiff != 0 ? endDiff : Util . cmp ( bc . to - bc . from , ac . to - ac . from ) ; }
function ( evt ) { var target = $ ( evt . target ) ; target . removeClass ( 'badTarget' ) ; dispatcher . post ( 'hideComment' ) ; if ( highlight ) { svg . remove ( highlight ) ; highlight = undefined ; } if ( highlightSpans ) { highlightArcs . removeClass ( 'highlight' ) ; highlightSpans . removeClass ( 'highlight' ) ; highlightSpans = undefined ; } forceRedraw ( ) ; }
function ( ) { $ ( '#f1' ) . val ( "New value" ) ; $ ( '#f1' ) . change ( ) ; equal ( $ ( '#f1' ) . val ( ) , "New value" , "Value should be changed to 'New value'." ) ; ok ( ! $ ( '#f1' ) . hasClass ( 'example' ) , "The example class should no longer be set." ) ; $ ( '#f1' ) . val ( '' ) ; }
function goToToday ( servlet ) { var date = new Date ( ) ; window . location = servlet + "&selectedyear=" + date . getFullYear ( ) + "&selectedmonth=" + date . getMonth ( ) + "&selectedweek=" + date . getWeek ( ) + "&selectedday=" + date . getDate ( ) ; }
function ( uri ) { var dt = this ; var character = "#" ; if ( uri . indexOf ( "#" ) == - 1 ) { character = "/" ; } return uri . substr ( uri . lastIndexOf ( character ) + 1 ) ; }
function ( newString ) { this . _string = newString ; if ( this . _children ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var node = this . _children [ i ] ; if ( node ) { node . setIsVisible ( false ) ; } } } this . createFontChars ( ) ; }
function ( callback ) { console . log ( "===> redmine.js : workflow" ) ; if ( ! issuesStored ) { redmineExtract . storeAllIssues ( callback ) ; } else if ( ! notesStored ) { redmineExtract . storeAllNotes ( callback ) ; } }
function ( ) { var centerX = this . _tileX + ( this . TileWidth - 1 ) / 2 ; var centerY = this . _tileY + ( this . TileHeight - 1 ) / 2 ; return { x : centerX , y : centerY } }
function ( x , y ) { var oldCenter = this . GetCenter ( ) ; this . _tileX = x - ( this . TileWidth - 1 ) / 2.0 ; this . _tileY = y - ( this . TileHeight - 1 ) / 2.0 ; this . _spritePosDirty = true ; this . trigger ( "BodyMoved" , { from : oldCenter , to : { x : x , y : y } } ) ; }
function ( ) { for ( var i = 0 ; i < this . _world . Regions . length ; i ++ ) { var region = this . _world . Regions [ i ] ; if ( region . _spawnPoint != null ) this . SetCenter ( region . Center . x , region . Center . y ) ; } }
function ( ) { this . _world . RemovePawn ( this ) ; }
function ( id , type , pos ) { id = id || this . Regions . length ; var region = this . RegionFactory . Spawn ( this , id , type , pos ) ; this . Regions . push ( region ) ; return region ; }
function ( result ) { var network_options = $ ( "[id$=_network]" ) . empty ( ) ; $ . each ( result , function ( ) { network_options . append ( $ ( "<option />" ) . val ( this . id ) . text ( this . name ) ) ; } ) ; }
function PMA_ajaxRemoveMessage ( $this_msgbox ) { if ( $this_msgbox != undefined && $this_msgbox instanceof jQuery ) { $this_msgbox . stop ( true , true ) . fadeOut ( 'medium' ) ; if ( $this_msgbox . is ( '.dismissable' ) ) { $this_msgbox . qtip ( 'hide' ) ; } else { $this_msgbox . remove ( ) ; } } }
function ( _data_c , status ) { winkstart . request ( 'accounts_manager.limits.get' , { account_id : account_id , api_url : winkstart . apps [ 'accounts' ] . api_url , } , function ( _data_l , status ) { var tmp = { account_id : account_id , limits : _data_l . data , credits : _data_c . data } ; THIS . render_credits_limits_popup ( tmp ) ; } ) ; }
function ( test ) { var success = ( test . result === ! test . todo ) ; if ( success && ++ this . collapsedMessages < this . MAX_COLLAPSED_MESSAGES ) { return ; } if ( this . collapsedMessages ) { this . _log ( { "result" : true , "todo" : false , "message" : "Elided " + this . collapsedMessages + " passes or known failures." } ) ; } this . collapsedMessages = 0 ; this . _log ( test ) ; }
function ( event ) { var req = settings . getLock ( ) . get ( 'wifi.enabled' ) ; req . onsuccess = function wf_stateGet ( ) { if ( req . result [ 'wifi.enabled' ] ) { updateNetworkState ( ) ; if ( event . status == 'connected' ) { gNetworkList . scan ( ) ; } } } }
function updateNetworkState ( ) { var currentNetwork = wifiManager . connection . network ; var networkStatus = wifiManager . connection . status ; if ( networkStatus === "associated" || networkStatus === "connecting" ) { gWifiInfoBlock . textContent = _ ( 'fullStatus-connecting' , currentNetwork ) ; } else if ( networkStatus === "connected" ) { gWifiInfoBlock . textContent = _ ( 'fullStatus-connected' , currentNetwork ) ; } else { gWifiInfoBlock . textContent = _ ( 'fullStatus-disconnected' ) ; } }
function start ( response , postData ) { console . log ( "Request handler 'start' was called." ) ; fs . readFile ( "./index.html" , function ( err , content ) { if ( err ) { throw err ; } else { response . writeHead ( 200 , { "Content-Type" : "text/html" } ) ; response . write ( content ) ; response . end ( ) ; } } ) ; }
function upload ( response , postData ) { console . log ( "Request handler 'upload' was called." ) ; response . writeHead ( 200 , { "Content-Type" : "text/plain" } ) ; response . write ( "You've sent the text: " + querystring . parse ( postData ) . text ) ; response . end ( ) ; }
function ( data ) { var sender = 'unregistered' ; socket . get ( 'nickname' , function ( err , name ) { console . log ( 'Chat message by ' , name ) ; console . log ( 'error ' , err ) ; sender = name ; } ) ; socket . broadcast . emit ( 'chat' , { msg : data , msgr : sender } ) ; }
function ( ) { var newValue = this . input . val ( ) ; if ( newValue == this . placeholder ) return false ; if ( newValue . length < this . minimumCharacters ) return false ; if ( newValue == this . value ) return false ; this . value = newValue ; this . fetch ( ) ; }
function ( ) { $ ( 'tracker_reminder' ) . show ( ) ; $ ( 'add_reminder' ) . observe ( 'click' , function ( evt ) { var url = codendi . tracker . base_url + '?func=display_reminder_form&tracker=' + $ ( 'add_reminder' ) . value ; var target = 'tracker_reminder' ; var myAjax = new Ajax . Updater ( target , url , { method : 'get' } ) ; } ) ; }
function ( ) { $ ( 'span' , this ) . toggleClass ( 'ui-icon-triangle-1-s ui-icon-triangle-1-n' ) ; $ ( this ) . parent ( ) . next ( ) . toggle ( ) ; }
f if ( strict && '{' != buf [ 0 ] && '[' != buf [ 0 ] ) return next ( utils . error ( 400 ) ) ; try { req . body = JSON . parse ( buf , options . reviver ) ; next ( ) ; } catch ( err ) { err . body = buf ; err . status = 400 ; next ( err ) ; } } ) ;
function ( done ) { var mong = new Mongoose ( ) , uri = 'mongodb://localhost/mongoose_test' mong . connect ( process . env . MONGOOSE_TEST_URI || uri ) ; mong . connection . on ( 'open' , function ( ) { mong . disconnect ( function ( ) { done ( ) ; } ) ; } ) ; }
function ( err , res ) { db . close ( ) ; assert . ifError ( err ) ; if ( ! ( res && res . documents && res . documents [ 0 ] && res . documents [ 0 ] . ok ) ) { throw new Error ( 'could not shard test collection ' + collection ) ; } done ( ) ; }
function ( err ) { db . close ( ) ; assert . ok ( err ) ; done ( ) ; }
function ( fn ) { var count = this . connections . length ; this . connections . forEach ( function ( conn ) { conn . close ( function ( err ) { if ( err ) return fn ( err ) ; if ( fn ) -- count || fn ( ) ; } ) ; } ) ; return this ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . innerHTML = '<v:shape adj="1"/>' ; var shape = div . firstChild ; shape . style . behavior = 'url(#default#VML)' ; return shape && ( typeof shape . adj === 'object' ) ; }
function ( ) { if ( path . existsSync ( this . options . conf ) ) { return this . logger . info ( "" + this . options . conf + " already exists" ) ; } else { fs . writeFileSync ( this . options . conf , sample_conf ) ; return this . logger . info ( "Wrote " + this . options . conf ) ; } }
function ( ) { var countHorizontal = ( this . width / this . frameW ) . toFixed ( ) ; var countVertical = ( this . height / this . frameH ) . toFixed ( ) ; for ( var height = 0 ; height < countVertical ; height ++ ) { for ( var slice = 0 ; slice < countHorizontal ; slice ++ ) { this . map . push ( { x : this . frameW * slice , y : this . frameH * height } ) ; } } }
function ( ) { if ( this . path_points . length === 0 ) { this . kill ( ) ; return ; } var next_step = this . path_points . shift ( ) ; this . x = next_step [ 0 ] ; this . y = next_step [ 1 ] ; }
function ( name ) { if ( this . records [ name ] === undefined ) { this . records [ name ] = { id : name } } this . records [ name ] . start = Date . now ( ) ; }
function ( ) { this . results = [ ] ; for ( var num in this . records ) { var time = cp . math . convert ( this . records [ num ] . total , 1000 , 2 ) ; var tag = this . records [ num ] . id ; this . results . push ( { name : tag , val : time } ) ; this . records [ num ] . total = 0 ; } this . display ( ) ; }
function ( ) { this . progress = this . count + ' / ' + this . total ; this . progressPercent = ( this . count / this . total ) . toFixed ( 2 ) ; if ( this . count == this . total ) { this . active = false ; this . callback ( ) ; } }
function ( val , base , round , multiply ) { if ( multiply ) { var total = val * base ; } else { var total = val / base ; } return total . toFixed ( round ) ; }
function ( ) { this . detect ( ) ; }
function ( ) { this . el . pause ( ) ; }
function ( ) { if ( this . animCur . id != - 1 ) { this . animSet . crop ( this ) ; } }
function ( ) { this . x = this . x + this . speed * Math . cos ( this . angle ) ; this . y = this . y + this . speed * Math . sin ( this . angle ) ; }
function init ( ) { if ( ! getLocation ( ) ) { location . hash = getConfig ( 'DEFAULT_INDEX' ) ; } function changeListener ( ) { var loc = getLocation ( ) ; if ( loc != currentLocation ) { locator_ . redirect ( loc ) ; } } if ( baidu . ie ) { ieIframeRecorderInit ( ) ; ieInputRecorderInit ( ) ; } setInterval ( changeListener , 100 ) ; }
function ( ) { if ( ifupdate_url && urlParams [ 'voice' ] === 'true' ) { initNote ( ) ; } var temp_url = localStorage [ "temp_note" ] ; if ( location . href === temp_url ) { console . log ( "I am in temp~" ) ; location . href = "http://www.douban.com/update/" ; } }
function ( model ) { this . remove ( model ) ; this . localSave ( this . models ) ; }
function ( ) { if ( this . path_points . length === 0 ) { this . kill ( ) ; return ; } var next_step = this . path_points . shift ( ) ; this . x = next_step [ 0 ] ; this . y = next_step [ 1 ] ; if ( cp . math . random ( 50 , 1 ) == 5 ) { cp . game . spawn ( 'Bullet' , this . x , this . y , 350 , 350 ) ; } }
function ( e ) { var reply = JSON . parse ( e . data ) ; if ( reply . status === 'OK' ) { self . dispatched_callback ( reply . host , reply . port ) ; } else if ( reply . status === 'FULL' ) { alert ( "BrowserQuest is currently at maximum player population. Please retry later." ) ; } else { alert ( "Unknown error while connecting to BrowserQuest." ) ; } }
function ( e ) { if ( e . data === "go" ) { if ( self . connected_callback ) { self . connected_callback ( ) ; } return ; } if ( e . data === 'timeout' ) { self . isTimeout = true ; return ; } self . receiveMessage ( e . data ) ; }
function ( json ) { var data ; if ( this . connection . readyState === 1 ) { if ( this . useBison ) { data = BISON . encode ( json ) ; } else { data = JSON . stringify ( json ) ; } this . connection . send ( data ) ; } }
function ( ) { for ( var key in this . interactions . previousInteractionsTextContainers ) { if ( this . interactions . previousInteractionsTextContainers . hasOwnProperty ( key ) ) { this . interactions . previousInteractionsTextContainers [ key ] . unhighlightAll ( ) ; } } this . defn . unhighlightAll ( ) ; }
function ( ) { var r ; sb . apply ( this , arguments ) ; try { r = sf . apply ( this , arguments ) ; } catch ( e ) { r = e ; } sa . call ( this , arguments , r ) ; if ( r instanceof Error ) { throw r ; } }
function ( event ) { event . preventDefault ( ) ; var url = $ ( this ) . attr ( 'href' ) ; var userData = $ ( this ) . find ( 'input[name=user-details]' ) . serialize ( ) ; $ . mobile . changePage ( url , { type : "post" , data : userData } ) ; }
function ( event ) { event . preventDefault ( ) ; var url = $ ( this ) . attr ( 'href' ) ; var eventData = $ ( this ) . find ( 'input[name=event-details]' ) . serialize ( ) ; $ . mobile . changePage ( url , { type : "post" , data : eventData } ) ; }
function smsInform ( ) { var houseId = getQueryString ( "houseId" ) ; $ . ajax ( { type : 'POST' , url : 'sms_inform?houseId=' + houseId , success : function ( data ) { if ( data . result == 'success' ) { } else { } } } ) ; }
function ( data ) { alert ( "项目删除成功" ) ; window . parent . location . href = 'cf_item_list.jsp' ; }
function ( data ) { alert ( "电费项目删除成功" ) ; window . parent . location . href = 'ef_item_list.jsp' ; }
function ( target , source ) { var i = 1 , n = arguments . length , method ; while ( ++ i < n ) target [ method = arguments [ i ] ] = d3_rebind ( target , source , source [ method ] ) ; return target ; }
function ( ) { var fs = require ( "fs" ) , path = require ( "path" ) , parserSrc = "javascript:" + fs . readFileSync ( path . join ( __dirname , "rhino_modules" , "jsdoc" , "src" , "parser.js" ) ) , parse = function ( ) { parser . parse ( parserSrc ) ; } ; expect ( parse ) . not . toThrow ( ) ; }
function ( name ) { if ( this . forms [ name ] ) return false ; return ! ! name . match ( /^[a-z0-9_\-]+$/gi ) ; }
function ( response ) { if ( $ ( '#quickpost' ) . raw ( ) . value !== '' ) { $ ( '#quickpost' ) . raw ( ) . value = $ ( '#quickpost' ) . raw ( ) . value + "\n\n" ; } $ ( '#quickpost' ) . raw ( ) . value = $ ( '#quickpost' ) . raw ( ) . value + "[quote=" + username + "]" + html_entity_decode ( response ) + "[/quote]" ; resize ( 'quickpost' ) ; }
function ( ) { ok ( true , '親コントローラのinitPromiseのfailハンドラが呼ばれる。' ) ; }
function ( a ) { ok ( false , 'テスト失敗。initPromiseがresolve()されました。' ) ; }
function ( k , v ) { return _this . addError ( $ ( _this . el ) . find ( "[name*=" + k + "]" ) , v [ 0 ] ) ; }
function ( k , v ) { return _this . addError ( $ ( _this . el ) . find ( "[name*=" + k + "]" ) , v [ 0 ] ) ; }
function ( ) { console . log ( '[COPY] %s' , PATH . basename ( targetPath ) ) ; try { if ( FILE . lstatSync ( sourcePath ) . isDirectory ( ) && FILE . lstatSync ( targetPath ) . isDirectory ( ) ) targetPath = PATH . dirname ( targetPath ) ; } catch ( e ) { } jake . cpR ( sourcePath , targetPath ) ; }
function ( fName ) { var srcDir = PATH . join ( 'Frameworks' , fName ) , dstDir = PATH . join ( finalBuildDir , 'Frameworks' , fName ) ; dependencies . push ( dstDir ) ; tasks . copy ( dstDir , srcDir ) ; }
function ( dom , base64File ) { var src = " src='" + base64File + "' " ; var audio_tag = "<audio autoplay controls " + src + ">" ; dom . html ( audio_tag ) ; }
function ( dom , base64File ) { var src = " src='" + base64File + "' " ; var audio_tag = "<audio autoplay controls " + src + ">" ; dom . html ( audio_tag ) ; }
function ( tx , r ) { console . log ( "out of range?????===========" ) console . log ( r ) ; if ( r . rowsAffected ) { var result = r . rows . item ( 0 ) ; deferred . resolve ( true ) ; } else { deferred . reject ( "no sid" ) ; } }
function ( ) { var height = ( ( browserWindow . height ( ) ) - headHeight ) . toString ( ) ; console . log ( height ) ; scroll . css ( "height" , height + "px" ) ; }
function ( v0 , v1 , axis , angle ) { var rotation = Quaternion . fromAxisAngle ( axis , angle ) . toRotationMatrix ( ) ; var u0 = rotation . multiplyByVector ( v0 ) ; var u1 = rotation . multiplyByVector ( v1 ) ; return [ u0 , u1 ] ; }
function ( theta ) { var c = Math . cos ( theta ) ; var s = Math . sin ( theta ) ; return new Matrix3 ( c , 0.0 , s , 0.0 , 1.0 , 0.0 , - s , 0.0 , c ) ; }
function ( fileName , contents ) { $ . ajax ( { type : 'POST' , url : "/webeditor/spring/json/" , data : "lala" , dataType : "text" } ) ; return this . storageImpl . setItem ( prefix + fileName , JSON . stringify ( contents ) ) ; }
function ( focus ) { if ( this . _opened ) { if ( focus ) { this . focus ( ) ; } popup . close ( this . dropDown ) ; this . _opened = false ; } }
function ( time ) { time += 'ms' ; this . scroller . style [ vendor + 'TransitionDuration' ] = time ; if ( this . hScrollbar ) this . hScrollbarIndicator . style [ vendor + 'TransitionDuration' ] = time ; if ( this . vScrollbar ) this . vScrollbarIndicator . style [ vendor + 'TransitionDuration' ] = time ; }
function ( event ) { var args = $ . makeArray ( arguments ) ; console . log ( 'riurik.trigger' , event , 'with args:' , args . slice ( 1 ) ) ; $ ( riurik ) . trigger . call ( $ ( riurik ) , args ) ; }
function ( ) { this . userStore = new phpr . Default . System . Store . User ( ) ; this . _initData . push ( { 'store' : this . userStore } ) ; this . _tagUrl = phpr . webpath + 'index.php/Default/Tag/jsonGetTagsByModule/moduleName/' + phpr . module + '/id/' + this . id ; this . _initData . push ( { 'url' : this . _tagUrl } ) ; }
function ( ) { this . userStore . fetch ( dojo . hitch ( this , function ( ) { if ( this . getActiveUser ( ) === null ) { this . setActiveUser ( this . _getCurrentUser ( ) ) ; } this . loadAppropriateList ( ) ; } ) ) ; }
function ( ) { this . _usersSelectionMode = true ; var newstate = dojo . clone ( this . state ) ; newstate . action = "dayListSelect" ; phpr . pageManager . changeState ( newstate , { noAction : true } ) ; this . userStore = new phpr . Default . System . Store . User ( ) ; this . userStore . fetch ( dojo . hitch ( this , "selectorRender" ) ) ; }
function ( activeModuleName ) { for ( var i in this . globalModuleNavigationButtons ) { var button = this . globalModuleNavigationButtons [ i ] ; if ( dijit . byId ( button ) && button . containerNode ) { dojo . removeClass ( button . containerNode , 'selected' ) ; } } var activeModuleButton = this . globalModuleNavigationButtons [ activeModuleName ] ; if ( activeModuleButton ) { dojo . addClass ( activeModuleButton . containerNode , 'selected' ) ; } }
function ( c ) { this . _limpiar ( c ) ; this . depurador . comienza_dibujado ( ) ; this . fisica . actualizar ( ) ; for ( var i = 0 ; i < this . lista_actores . length ; i ++ ) { var actor = this . lista_actores [ i ] ; actor . actualizar ( ) ; actor . dibujar ( c ) ; this . depurador . dibuja_al_actor ( actor ) ; } this . depurador . termina_dibujado ( ) ; }
function ( count ) { while ( count > my . size ) { var index = Math . floor ( count * Math . random ( ) ) ; var evct ; for ( var s in my . cache ) { if ( my . cache . hasOwnProperty ( s ) ) { if ( count == index ) evct = s ; } } count -- ; invalidate ( evct ) ; } }
function KmlViewerUi ( ) { var $url_base = $ ( '#url-base' ) ; this . api_url = $url_base . attr ( 'data-api-url' ) ; this . jarkusmean_chart_url = $url_base . attr ( 'data-jarkusmean-chart-url' ) ; this . treeStore = null ; this . treePanel = null ; this . jarkusPanel = null ; this . accordion = null ; this . isMultiSelectEnabled = false ; this . selectedItems = [ ] ; }
function ( url ) { var $preview = $ ( '#kml-preview' ) ; $preview . load ( function ( ) { if ( $ ( this ) . attr ( 'src' ) == url ) { $ ( '#kml-preview-container' ) . show ( ) ; } } ) ; $preview . attr ( 'src' , url ) ; }
function ( ) { var html = "<div class='player-citation-bubble clearfix hide'>" + "<div class='player-citation-content'>" + "<h3><%= attr.title %></h3>" + "<div class='content'><span class='citation-subhead'>DESCRIPTION:</span> <%= attr.description %></div>" + "<div class='creator'><span class='citation-subhead'>CREATED BY:</span> <%= attr.media_creator_realname %></div>" + "<div class='date-created'><span class='citation-subhead'>CREATED ON:</span> <%= attr.date_created %></div>" ; if ( ! _ . isNull ( this . model . get ( 'attr' ) . media_geo_longitude ) ) { html += "<div class='location-created'><span class='citation-subhead'>LOCATION:</span> <%= attr.media_geo_longitude %>, <%= attr.media_geo_latitude %></div>" ; } html += "<div class='trackback'><span class='citation-subhead'>click below to view original</span></div>" + "</div>" + "<div class='player-citation-thumb'><img src='<%= attr.thumbnail_url %>' height='100px' width='100px'/></div>" + "</div>" + "<a href='<%= attr.attribution_uri %>' class='citation-icon' target='blank'><i class='zitem-<%= attr.archive.toLowerCase() %> zitem-30'></i></a>" ; return html ; }
function ( ) { var self = this ; self . $topicInput = self . $el . find ( '> input' ) ; self . $topics = self . $el . find ( '.curation-topics' ) ; if ( self . options . model ) { self . render ( ) ; } }
function ( ) { var self = this ; if ( _ . isString ( self . template ) ) { var html = $ ( self . template ) . html ( ) ; try { self . __proto__ . template = _ . template ( html ) ; } catch ( e ) { console . log ( "Template error:" , e . message , ", html[" , html , "]" ) ; } } if ( self . options . model ) { self . render ( ) ; } }
function ( ) { var self = this ; if ( _ . isString ( self . template ) ) { var html = $ ( self . template ) . html ( ) ; try { self . __proto__ . template = _ . template ( html ) ; } catch ( e ) { console . log ( "Template error:" , e . message , ", html[" , html , "]" ) ; } } if ( self . options . model ) { self . render ( ) ; } }
function ( ) { var $curation = $ ( '#collaborative-curation' ) ; mainView = new TopicsView ( { el : $curation } ) ; $curation . data ( 'view' , mainView ) ; $curation . on ( 'load' , function ( e , msg ) { mainView . setModel ( msg . topics ) ; } ) ; }
function ( e ) { var self = this , $tgt = $ ( e . target ) ; if ( ( ! $tgt . attr ( 'droppable' ) ) || ( $tgt . hasClass ( 'dragging' ) ) || ( $tgt . hasClass ( 'drag-over' ) ) ) { return ; } console . log ( "drag over: tgt[" , $tgt . attr ( 'class' ) , "]" ) ; e . dataTransfer . dropEffect = 'move' ; e . preventDefault ( ) ; e . stopPropagation ( ) ; return false ; }
function ( e ) { var self = this , $tgt = $ ( e . target ) ; if ( ( ! $tgt . attr ( 'droppable' ) ) || ( $tgt . hasClass ( 'dragging' ) ) || ( $tgt . hasClass ( 'drag-over' ) ) ) { return ; } console . log ( "drag enter: tgt[" , $tgt . attr ( 'class' ) , "]" ) ; $tgt . addClass ( 'drag-over' ) ; e . preventDefault ( ) ; e . stopPropagation ( ) ; return false ; }
function ( e ) { var self = this , $tgt = $ ( e . target ) ; if ( ( ! $tgt . attr ( 'droppable' ) ) || ( $tgt . hasClass ( 'dragging' ) ) || ( $tgt . hasClass ( 'drag-over' ) ) ) { return ; } console . log ( "drag leave: tgt[" , $tgt . attr ( 'class' ) , "]" ) ; $tgt . removeClass ( 'drag-over' ) ; e . preventDefault ( ) ; e . stopPropagation ( ) ; return false ; }
function ( err , topicDetails ) { if ( err ) { console . log ( 'Failed to load topic. Clearing view.' ) ; that . view . clear ( ) ; return true ; } var modelTopic = that . model . getTopic ( ) ; if ( modelTopic !== null && topicDetails !== undefined && topicDetails . id == modelTopic . id ) { that . setSelectedTopic ( topicDetails ) ; if ( callback ) { callback ( ) ; } } }
function ( app ) { if ( app ) { app . listen ( port ) ; console . log ( "Calipso version: " . green + app . about . version ) ; console . log ( "Calipso configured for: " . green + ( global . process . env . NODE_ENV || 'development' ) + " environment." . green ) ; console . log ( "Calipso server listening on port: " . green + app . address ( ) . port ) ; } else { console . log ( "\r\nCalipso terminated ...\r\n" . grey ) ; process . exit ( ) ; } }
function ( roomId ) { var html = '<div id="emailBody"><ul style="list-style:none;margin:0px;padding:0px;width:650px;">' ; var messages = Messages . find ( { roomId : roomId } ) ; for ( message in messages ) { html += '<li class="' + message . role + '" style="border-bottom:1px solid #CCC;padding:4px;">' ; if ( message . role == 'host' ) { html += '<span style="color: #29642a;">' ; } html += '<strong>' + message . user + '</strong> <em>(' + message . timestamp + ')</em></span>: ' + message . content + '</li>' ; } html += '</ul></div>' ; return html ; }
function uninstallExtensionFromUUID ( uuid ) { let extension = ExtensionUtils . extensions [ uuid ] ; if ( ! extension ) return false ; if ( extension . type != ExtensionUtils . ExtensionType . PER_USER ) return false ; if ( ! ExtensionSystem . unloadExtension ( uuid ) ) return false ; FileUtils . recursivelyDeleteDir ( extension . dir ) ; return true ; }
function ( ) { $ ( '#map_canvas' ) . css ( { 'z-index' : '9900' , 'display' : 'block' , 'opacity' : '0' } ) ; $ ( '#map_canvas' ) . animate ( { opacity : 1.0 } , 1200 , 'easeInQuint' ) ; $ ( '.table-fade' ) . css ( { 'display' : 'block' , 'z-index' : '9890' } ) ; $ ( '.table-fade' ) . animate ( { opacity : 0.8 } , 1200 , 'easeInQuint' ) ; }
function ( role , partner ) { $ ( '#' + role ) . append ( "<a href='" + partner [ "link" ] + "'><img height='40' src='" + partner [ "picture" ] [ "data" ] [ "url" ] + "'/>" + partner [ "first_name" ] + "</a> " ) ; console . log ( partner ) ; }
function ( ) { let currentWorkspace = global . screen . get_active_workspace ( ) ; for ( let i = 0 ; i < this . _windows . length ; i ++ ) { let clone = this . _windows [ i ] ; let overlay = this . _windowOverlays [ i ] ; this . _showWindowOverlay ( clone , overlay , this . metaWorkspace == null || this . metaWorkspace == currentWorkspace ) ; } }
function ( ) { return 42 ; }
function ( arg ) { if ( arg ) { USER . name = Ext . getCmp ( 'username' ) . getValue ( ) ; var pass = Ext . getCmp ( 'password' ) . getValue ( ) ; if ( USER . name == '' || pass == '' ) { Ext . Msg . alert ( "Error" , "Please fill in all fields" ) } else { helper . loginContinue ( ) ; } } else { this . doExit ( ) ; } }
function ( arg ) { if ( arg === 'list' ) { helper . doDownload ( ) ; Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . PATIENT_LIST ) } else if ( arg === 'add' ) { Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . ADD ) } }
function ( response ) { CONNECTED = true ; var authenticated = Ext . decode ( response . responseText ) . authenticated ; if ( authenticated ) { localStorage . setItem ( "basicAuthHeader" , "Basic " + window . btoa ( username + ":" + password ) ) ; helper . loginContinue ( ) ; } else { localStorage . removeItem ( "basicAuthHeader" ) ; Ext . Msg . alert ( "Error" , "Please try again" ) } }
function ( response ) { CONNECTED = false ; var hashPass = 'Basic ' + window . btoa ( username + ":" + password ) ; var hashStored = localStorage . getItem ( 'basicAuthHeader' ) ; if ( hashPass === hashStored ) { helper . loginContinue ( ) ; } else { Ext . Msg . alert ( "Error" , "Please try again" ) } }
function ( data ) { if ( data . articles . length > 0 ) { $ . each ( data . articles , function ( i , art ) { new_article ( art ) . appendTo ( "#content" ) ; } ) ; } else dontload = true ; }
function ( kid , initially ) { if ( $ ( window ) . scrollTop ( ) >= $ ( document ) . height ( ) - $ ( window ) . height ( ) ) { load_and_inc_offset ( kid , 1 ) ; } if ( ! initially ) setTimeout ( "fill_up(" + kid + ", false)" , 500 ) ; }
function ( ) { setup ( ) ; kid = $ ( "#keyword" ) . attr ( 'title' ) ; fill_up ( kid , true ) ; fill_up ( kid , true ) ; fill_up ( kid , true ) ; $ ( window ) . scroll ( function ( ) { fill_up ( kid , false ) ; } ) ; }
function ( err , resp , body ) { var email = false ; if ( err ) { return callback ( err ) ; } try { var jsonResp = JSON . parse ( body ) ; if ( jsonResp . status === 'okay' ) { email = jsonResp . email ; } else { return callback ( jsonResp ) ; } } catch ( err ) { return callback ( err ) ; } return callback ( null , email ) ; }
function ( entries ) { console . log ( entries . length + ' files in local store' ) ; for ( var i = 0 ; i < entries . length ; ++ i ) { var f = GFS . Elements . createFile ( entries [ i ] . fullPath , entries [ i ] ) ; f . displayAsLink ( $ ( Constants . Selectors . DOWNLOADING_LIST ) [ 0 ] ) ; } }
function ( ) { if ( red >= 255 || red < 0 ) { neg = neg * ( - 1 ) ; } backgroundAlarm ( red = red + frameskip * neg ) ; }
function backgroundAlarm ( red ) { var red ; var frameskip = 40 ; document . body . style . backgroundColor = 'rgb(' + red + ', 0, 0)' ; setTimeout ( function ( ) { if ( red >= 255 || red < 0 ) { neg = neg * ( - 1 ) ; } backgroundAlarm ( red = red + frameskip * neg ) ; } , 100 ) ; }
function ( event ) { for ( var i = 0 ; i < players . length ; i ++ ) { if ( players [ i ] != undefined ) { if ( STATUS ) { players [ i ] . trigger ( "keydownself" , event ) ; } } } ; }
function ( event ) { for ( var i = 0 ; i < players . length ; i ++ ) { if ( players [ i ] != undefined ) { if ( STATUS ) { players [ i ] . trigger ( "keyupself" , event ) ; } } } ; }
function ( ) { if ( this . timeFuze ) { this . detonateTriggeredBomb ( ) ; } Crafty . e ( "DeathAnimation" , "2D" , "DOM" , "SpriteAnimation" , "animate" ) . attr ( { x : this . xDeath , y : this . yDeath - 12 , z : 10 } ) . setDeathAnimation ( this ) ; this . destroy ( ) ; }
function ( code ) { var er = null if ( code ) er = new Error ( "`" + cmd + ( args . length ? " " + args . map ( JSON . stringify ) . join ( " " ) : "" ) + "` failed with " + code ) cb ( er , code , stdout , stderr ) }
function validateMime ( name ) { var type = mime . lookup ( name ) ; var validTypes = [ 'image/jpeg' , 'image/png' , 'image/gif' , 'image/jpg' ] ; if ( validTypes . indexOf ( type ) == - 1 ) return false ; else return true ; }
function ( selectVal ) { if ( selectVal ) this . setColor ( RED ) ; else this . hover ( this . get ( 'hovered' ) ) ; this . set ( 'selected' , selectVal ) ; this . set ( 'origPos' , this . get ( 'mesh' ) . position ) ; }
function ( movement ) { var origPos = this . get ( 'origPos' ) , pos = new THREE . Vector3 ( origPos . x + movement . x , origPos . y + movement . y , origPos . z + movement . z ) ; this . get ( 'mesh' ) . position = pos ; this . get ( 'shading' ) . position = pos ; this . get ( 'object' ) . position = pos ; }
function ( e ) { console . log ( 'Creating or upgrading media database' ) ; var db = openRequest . result ; var existingStoreNames = db . objectStoreNames ; for ( var i = 0 ; i < existingStoreNames . length ; i ++ ) { db . deleteObjectStore ( existingStoreNames ) ; } var filestore = db . createObjectStore ( 'files' , { keyPath : 'name' } ) ; mediadb . indexes . forEach ( function ( indexName ) { filestore . createIndex ( indexName , indexName ) ; } ) ; }
function addThumbnail ( imagenum ) { var li = document . createElement ( 'li' ) ; li . dataset . index = imagenum ; li . classList . add ( 'thumbnail' ) ; thumbnails . appendChild ( li ) ; var imagedata = images [ imagenum ] ; var url = URL . createObjectURL ( imagedata . metadata . thumbnail ) ; li . style . backgroundImage = 'url("' + url + '")' ; }
function ( response ) { if ( response . error ) { $ ( '#pay-error' ) . show ( ) . find ( 'div' ) . text ( response . error ) ; installError ( product ) ; return ; } if ( response . receipt ) { data [ 'data' ] = { 'receipts' : [ response . receipt ] } ; } $ . when ( apps . install ( product , data ) ) . done ( installSuccess ) . fail ( installError ) ; }
function ( params , page , success , error ) { var headers = { } ; if ( 'eTag' in params ) headers = { "If-Match" : params . eTag } ; if ( 'id' in params ) { $ . ajax ( { url : '/system/weblounge/pages/' + params . id , async : false , type : 'put' , success : success , headers : headers , dataType : 'xml' , data : { content : Page . parseJSON ( page ) } } ) ; } }
function ( page ) { var path = page . getPath ( ) ; page . saveMetadata ( pageData , this . options . language , $ . proxy ( function ( ) { page . lock ( this . options . runtime . getUserLogin ( ) , function ( ) { location . href = path + window . currentLanguage + "?edit&_=" + new Date ( ) . getTime ( ) ; } ) ; } , this ) ) ; }
function ( ) { $ ( '#userListLink' ) . addClass ( 'linkGrey' ) ; $ ( this ) . removeClass ( 'linkGrey' ) ; $ ( "#userList" ) . fadeOut ( ) ; $ ( "#addUserForm" ) . delay ( 200 ) . fadeIn ( ) ; $ ( '#userButtonDiv' ) . html ( '<button class="btn btn-primary" id="addUserButton">Add User</button>' ) ; clearUserForm ( ) ; }
function ( ) { $ ( "#userList" ) . fadeOut ( ) ; $ ( "#addUserForm" ) . delay ( 200 ) . fadeIn ( ) ; $ ( '#userButtonDiv' ) . html ( '<button class="btn btn-primary" id="updateUser">Update User Information</button>' ) ; var courseID = $ ( this ) . attr ( "id" ) ; editUser ( courseID ) ; $ ( 'html, body' ) . animate ( { scrollTop : 0 } ) ; }
function ( ) { updateUser ( ) ; viewUsers ( ) ; $ ( "#addUserForm" ) . fadeOut ( ) ; $ ( "#userList" ) . delay ( 200 ) . fadeIn ( ) ; $ ( 'html, body' ) . animate ( { scrollTop : 0 } ) ; }
function ( ) { dscourse . AddPost ( ) ; var discussionID = $ ( '#dIDhidden' ) . val ( ) ; $ ( '#commentWrap' ) . fadeOut ( 'fast' ) ; $ ( '#overlay' ) . hide ( ) ; clearPostForm ( ) ; dscourse . SingleDiscussion ( discussionID ) ; }
function s_removeBoundChan ( win , origin , scope ) { var arr = s_boundChans [ origin ] [ scope ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . win === win ) { arr . splice ( i , 1 ) ; } } if ( s_boundChans [ origin ] [ scope ] . length === 0 ) { delete s_boundChans [ origin ] [ scope ] } }
function s_removeBoundChan ( win , origin , scope ) { var arr = s_boundChans [ origin ] [ scope ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . win === win ) { arr . splice ( i , 1 ) ; } } if ( s_boundChans [ origin ] [ scope ] . length === 0 ) { delete s_boundChans [ origin ] [ scope ] } }
function s_removeBoundChan ( win , origin , scope ) { var arr = s_boundChans [ origin ] [ scope ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . win === win ) { arr . splice ( i , 1 ) ; } } if ( s_boundChans [ origin ] [ scope ] . length === 0 ) { delete s_boundChans [ origin ] [ scope ] } }
function serverResponseError ( ) { var btns = { } ; btns [ PMA_messages [ 'strReloadPage' ] ] = function ( ) { window . location . reload ( ) ; } ; $ ( '#emptyDialog' ) . dialog ( 'option' , 'title' , PMA_messages [ 'strRefreshFailed' ] ) ; $ ( '#emptyDialog' ) . html ( PMA_getImage ( 's_attention.png' ) + PMA_messages [ 'strInvalidResponseExplanation' ] ) ; $ ( '#emptyDialog' ) . dialog ( { buttons : btns } ) ; }
function ( req , res , next ) { console . log ( "middleware.authenticated session =>\n" , req . session ) ; if ( req . session . userId === true ) { return next ( ) ; } else { throw new Error ( 'unauthorized' ) ; } }
function ( err , resp ) { try { if ( err ) throw err ; if ( resp . code !== 200 ) throw "non-200 status: " + resp . code + + " - " + resp . body ; if ( typeof resp . body !== 'string' ) throw cb ( "no response body" ) ; userdb . addCertToUserCtx ( ctx , email , resp . body ) ; cb ( ) ; } catch ( e ) { cb ( "can't certify key" + ( e ? ( ": " + e . toString ( ) ) : "" ) ) ; } }
function ( err , r ) { try { if ( err ) throw err ; if ( r . code !== 200 ) throw "non-200 status: " + r . code ; if ( ! JSON . parse ( r . body ) . status === 'okay' ) throw "verification failed with: " + r . reason ; cb ( undefined ) ; } catch ( e ) { return cb ( "can't verify: " + e . toString ( ) ) ; } }
function ( err , assertion ) { if ( err ) cb ( err ) ; else { cb ( null , { audience : obj . audience , assertion : assertion , expirationDate : expirationDate } ) ; } }
function ( local_path ) { var fd ; if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) === - 1 ) throw errnoException ( errno , 'socket' ) ; var s = new Socket ( fd ) ; if ( local_path ) { if ( bind ( fd , local_path ) == - 1 ) { s . emit ( 'error' , errnoException ( errno , 'bind' ) ) ; } s . local_path = local_path ; } return s ; }
function ( x , y , width , height , refid , nodeid ) { this . refid = refid ; this . nodeid = nodeid ; this . selected = false ; this . rectangle = new Rectangle ( x , y , width , height ) ; }
function browser_setUrlBar ( data ) { if ( this . currentTab . url == this . START_PAGE_URL || this . currentTab . url == this . ABOUT_PAGE_URL ) { this . urlInput . value = '' ; } else { this . urlInput . value = data ; } }
function browser_showAwesomeScreen ( ) { this . urlInput . focus ( ) ; this . setUrlButtonMode ( this . GO ) ; this . tabsBadge . innerHTML = '' ; this . switchScreen ( this . AWESOME_SCREEN ) ; this . tabCover . style . display = 'none' ; this . showTopSitesTab ( ) ; }
function tabSwipe_pan ( e ) { if ( ! this . deleteable ) { return ; } var movement = Math . min ( this . containerWidth , Math . abs ( e . detail . absolute . dx ) ) ; if ( movement > 0 ) { this . tab . style . opacity = 1 - ( movement / this . containerWidth ) ; } this . tab . style . left = e . detail . absolute . dx + 'px' ; }
function ( ) { account . user = 'james' ; account . password = 'baz' ; account . fullUrl = 'google.com/path' ; subject . updateForm ( ) ; var fields = subject . fields ; assert . equal ( fieldValue ( 'user' ) , 'james' ) ; assert . equal ( fieldValue ( 'password' ) , '' ) ; assert . equal ( fieldValue ( 'fullUrl' ) , 'google.com/path' ) ; }
function ( ) { var fields = subject . fields ; fields . user . value = 'user' ; fields . password . value = 'pass' ; fields . fullUrl . value = 'google.com/foo' ; subject . updateModel ( ) ; assert . equal ( account . user , 'user' ) ; assert . equal ( account . password , 'pass' ) ; assert . equal ( account . fullUrl , 'google.com/foo' ) ; }
function ( ) { var tags = ID3 . getAllTags ( file . name ) ; metadata . album = tags . album ; metadata . artist = tags . artist ; metadata . title = tags . title ; callback ( metadata ) ; }
function slv_init ( ) { this . dataSource = [ ] ; this . index = 0 ; this . view . addEventListener ( 'click' , this ) ; }
function pv_next ( ) { var songElements = SubListView . view . children ; if ( this . currentIndex >= this . dataSource . length - 1 ) return ; this . currentIndex ++ ; this . play ( songElements [ this . currentIndex ] . firstElementChild ) ; }
function updateState ( ) { switching = false ; var currentNetwork = gWifiManager . connection . network ; if ( currentNetwork ) { infoBlock . textContent = _ ( 'fullStatus-connected' , currentNetwork ) ; checkbox . checked = true ; } else if ( gWifiManager . enabled ) { infoBlock . textContent = _ ( 'fullStatus-disconnected' ) ; checkbox . checked = true ; } else { infoBlock . textContent = _ ( 'disabled' ) ; checkbox . checked = false ; } }
function toggleWifi ( ) { if ( switching ) return ; switching = true ; var req ; if ( gWifiManager . enabled ) { gNetworkList . clear ( ) ; infoBlock . textContent = '' ; req = gWifiManager . setEnabled ( false ) ; } else { req = gWifiManager . setEnabled ( true ) ; req . onerror = function ( ) { gNetworkList . autoscan = false ; } ; } }
function act_handleEvent ( evt ) { if ( evt . type !== 'mozChromeEvent' ) return ; var detail = evt . detail ; if ( detail . type !== 'activity-choice' ) return ; this . _id = detail . id ; var choices = detail . list . choices ; if ( choices . length === 1 ) { this . choose ( '0' ) ; } else { ListMenu . request ( this . _listItems ( choices ) , this . choose . bind ( this ) ) ; } }
function ( ) { var provider = this . provider ; var type = this . providerType ; if ( ! provider ) { this . provider = provider = new Calendar . Provider [ type ] ( ) ; } if ( provider . useUrl ) { provider . url = this . url ; provider . domain = this . domain ; } if ( provider . useCredentials ) { provider . user = this . user ; provider . passsword = this . passsword ; } }
function ( window ) { var Presets = { 'local' : { singleUse : true , providerType : 'Local' , group : 'local' , options : { providerType : 'Local' } } } ; Calendar . Presets = Presets ; }
function ( ) { provider . useCredentials = true ; subject . user = 'foo' ; subject . passsword = 'bar' ; subject . url = 'missing' ; update ( ) ; assert . ok ( ! provider . url ) ; assert . equal ( provider . user , subject . user ) ; assert . equal ( provider . passsword , subject . passsword ) ; }
function ( context ) { params = [ this . nameLookup ( 'partials' , context , 'partial' ) , "'" + context + "'" , this . popStack ( ) , "helpers" , "partials" ] ; if ( this . options . data ) { params . push ( "data" ) ; } this . pushStack ( "self.invokePartial(" + params . join ( ", " ) + ");" ) ; }
function ti_end ( ) { try { navigator . mozVibrate ( [ 200 , 200 , 200 , 200 , 200 ] ) ; } catch ( e ) { } this . cancel ( ) ; this . chronoView . parentNode . classList . add ( 'ended' ) ; }
function ( ) { if ( this . vibrate ) { try { if ( this . vibrate ) navigator . mozVibrate ( 50 ) ; } catch ( e ) { } } if ( this . clicksound ) { this . _audio . cloneNode ( false ) . play ( ) ; } }
function ( ) { r = checkCondition ( oSettings , aData , iDataIndex , $ ( this ) ) ; if ( ! r && andVor ) { show = false ; return ; } else if ( r && ! andVor ) { show = true ; return ; } }
function ( ) { var self = this ; this . remove ( ) ; this . unbind ( ) ; _ ( this . _models ) . each ( function ( m ) { m . unbind ( null , null , self ) ; } ) ; View . viewCount -- ; delete View . views [ this . cid ] ; }
function ( e ) { var updateOptions = { } ; updateOptions [ propertyName ] = element . value ; trackEvent . update ( updateOptions ) ; var target = _this . butter . getTargetByType ( "elementID" , trackEvent . popcornOptions . target ) ; if ( target ) { target . view . blink ( ) ; } }
function ( popcornOptions ) { var element ; for ( var option in popcornOptions ) { if ( popcornOptions . hasOwnProperty ( option ) ) { element = _rootElement . querySelector ( "[data-manifest-key='" + option + "']" ) ; element . value = popcornOptions [ option ] ; } } }
function ( e ) { var trackEvent = e . data ; var trackEventDoubleClicked = function ( e ) { openEditor ( trackEvent ) ; } ; e . data . view . element . addEventListener ( "click" , trackEventDoubleClicked , false ) ; butter . listen ( "trackeventremoved" , function ( e ) { if ( e . data === trackEvent ) { e . data . view . element . removeEventListener ( "click" , trackEventDoubleClicked , false ) ; } } ) ; }
function ( result , j ) { return { intertype : 'mathop' , op : value . op , type : 'i' + otherElements [ j ] . bits , params : [ result , { intertype : 'value' , ident : otherElements [ j ] . ident , type : 'i' + otherElements [ j ] . bits } ] } ; }
function ( ) { this . $TestSuite . constructor . call ( this ) ; Aria . classDefinition ( { $classpath : "snippets.core.classes.Plant" } ) ; Aria . classDefinition ( { $classpath : "snippets.core.classes.Gardener" } ) ; Aria . classDefinition ( { $classpath : "org.thirdparty.parsers.JavaScript" } ) ; Aria . classDefinition ( { $classpath : "org.thirdparty.parsers.PerlScript" } ) ; this . addTests ( "tests.snippets.core.Asynchronous" , "tests.snippets.core.Beans" , "tests.snippets.core.Classes" , "tests.snippets.core.Filters" , "tests.snippets.core.Helpers" , "tests.snippets.core.Interceptors" ) ; }
function ( name ) { var $elems = this , e , layers , l ; for ( e = 0 ; e < $elems . length ; e += 1 ) { layers = $ ( $elems [ e ] ) . getLayers ( ) ; for ( l = 0 ; l < layers . length ; l += 1 ) { if ( layers [ l ] . group === name ) { layers . splice ( l , 1 ) ; } } } return $elems ; }
function ( config ) { var self = this ; config = $ . extend ( { "liveUpdatesTimeout" : 5 , "onData" : function ( ) { } , "skipInitialRequest" : false , "onError" : function ( ) { } , "submissionProxyURL" : "apps.echoenabled.com/v2/esp/activity" } , config ) ; config = this . _wrapTransportEventHandlers ( config ) ; this . requestType = "initial" ; Echo . StreamServer . API . Request . parent . constructor . call ( this , config ) ; }
function ( data , callback ) { Echo . StreamServer . API . request ( { "endpoint" : "submit" , "submissionProxyURL" : this . component . config . get ( "submissionProxyURL" ) , "appkey" : this . component . config . get ( "appkey" ) , "onData" : callback , "data" : data , "target-query" : this . component . config . get ( "query" , "" ) , "sessionID" : this . component . user . get ( "sessionID" , "" ) } ) . send ( ) ; }
function ( topic , data ) { if ( data . target !== element . get ( 0 ) ) return ; plugin . events . publish ( { "topic" : "onUnlike" , "prefix" : "internal" , "data" : { "actor" : data . actor , "item" : item } } ) ; }
function ( inx , doc ) { if ( vidCount > totalVideoCount ) { return ; } vidCount ++ ; _this . $target . append ( $ ( '<video />' ) . attr ( { 'poster' : doc . thumb , 'src' : doc . video , 'preload' : 'none' } ) . css ( { 'width' : '160px' } ) . data ( 'meta' , doc ) ) ; }
function ( instance ) { return ( - 1 === responseNames . indexOf ( instance . response [ questionName ] ) ) ; }
function ( arr ) { return new L . LatLng ( arr [ 0 ] , arr [ 1 ] ) ; }
function ( evt ) { var pending = this . getPendingCommand ( evt ) ; if ( pending ) { pending . callback ( evt ) ; this . removePendingCommand ( pending ) ; } var denorm = this . getDenormalizer ( evt . name ) ; _ ( denorm ) . each ( function ( d ) { d . handle ( evt ) ; } ) ; }
function nativeRequire ( request ) { var code , module , filename = 'phantomjs://modules/' + request + '.js' ; if ( cache . hasOwnProperty ( filename ) ) { return cache [ filename ] . exports ; } code = phantom . readNativeModule ( request ) ; module = new Module ( filename ) ; cache [ filename ] = module ; module . exports = nativeExports [ request ] || { } ; module . _compile ( code ) ; return module . exports ; }
function ( ) { var cwd , mainFilename , mainModule = new Module ( ) ; window . require = mainModule . _getRequire ( ) ; fs = nativeRequire ( 'fs' ) ; cwd = fs . absolute ( phantom . libraryPath ) ; mainFilename = joinPath ( cwd , basename ( nativeRequire ( 'system' ) . args [ 0 ] ) || 'repl' ) ; mainModule . _setFilename ( mainFilename ) ; }
function Load_Cookie ( ) { var panel = jQuery ( '#search_box' ) ; var button = jQuery ( '#search_button' ) ; if ( jQuery . cookie ( 'searchPanelState' ) == undefined ) { jQuery . cookie ( 'searchPanelState' , 'expanded' ) ; } var state = jQuery . cookie ( 'searchPanelState' ) ; if ( state == 'collapsed' ) { panel . hide ( ) ; button . text ( 'Open Search Center' ) ; } else { button . text ( 'Close Search Center' ) ; } }
function outer_mousemove ( evt ) { evt = evt || event ; var target = fdjtUI . T ( evt ) ; if ( ! ( hasParent ( target , ".fdjtaphold" ) ) ) { if ( pressed ) released ( pressed ) ; pressed = th_target = false ; return ; } }
function ( ) { if ( freeIndex > 0 ) { if ( verbose ) console . log ( 'Flushing' ) ; tuples ( function ( time , token ) { self . emit ( 'device' , time , token . toString ( 'hex' ) ) ; } ) ; freeIndex = 0 ; } self . emit ( 'end' ) ; clearConnection ( ) ; }
function ( event , widget ) { var newIndex = event && event . page && event . page . getZoneIndex ( ) , oldIndex = event && event . oldPage && event . oldPage . getZoneIndex ( ) ; widget = widget || this ; widget . element . find ( '.ui-selected' ) . removeClass ( 'ui-selected' ) ; widget . element . find ( '#pages' ) . children ( ) . eq ( newIndex ) . addClass ( 'ui-selected' ) ; widget . _scrollPage ( newIndex ) ; }
function ( data , status ) { var fileURL = $ ( data ) . find ( 'file_url' ) . text ( ) ; var error = $ ( data ) . find ( 'error' ) . text ( ) ; if ( error != '' ) { alert ( error ) ; if ( startUploadHandler ) { $ ( '#file-upload' ) . change ( startUploadHandler ) ; } } else { imageUrl . attr ( 'value' , fileURL ) ; } }
function ( cfg ) { this . xconfig = { font : cfg . font || false , drag_source : cfg . drag_source || false , drag_dest : cfg . drag_dest || false } ; for ( var i in this . xconfig ) { if ( typeof ( cfg [ i ] ) != 'undefined' ) { delete cfg [ i ] ; } } XObject . call ( this , cfg ) ; }
function ( e ) { e . preventDefault ( ) ; var action = $ ( '#ws_form' ) . find ( 'form' ) . attr ( 'action' ) ; action = action . replace ( '_instanceId' , node . data . key ) ; var id = $ ( 'ws_form' ) . find ( 'form' ) . attr ( 'id' ) ; ClaroUtils . sendForm ( action , document . getElementById ( id ) , submissionHandler ) ; }
function ( webProgress , request , stateFlags , status ) { if ( webProgress != docShell ) { return ; } if ( stateFlags & Ci . nsIWebProgressListener . STATE_START ) { this . _seenLoadStart = true ; sendAsyncMsg ( 'loadstart' ) ; } if ( stateFlags & Ci . nsIWebProgressListener . STATE_STOP ) { sendAsyncMsg ( 'loadend' ) ; } }
function ( obj ) { obj . find ( 'span[lang]' ) . each ( function ( ) { jQuery ( this ) . removeClass ( WAI_LANG_CLASS ) ; } ) ; }
function ( result ) { builder . selenium2 . playback . execute ( 'clickElement' , { id : result . value . ELEMENT } ) ; builder . selenium2 . playback . execute ( 'clearElement' , { id : result . value . ELEMENT } ) ; builder . selenium2 . playback . execute ( 'sendKeysToElement' , { id : result . value . ELEMENT , value : builder . selenium2 . playback . param ( "text" ) . split ( "" ) } ) ; }
function ( result ) { var target = result . value . ELEMENT ; builder . selenium2 . playback . execute ( 'isElementSelected' , { id : target } , function ( result ) { if ( ! result . value ) { builder . selenium2 . playback . execute ( 'clickElement' , { id : target } ) ; } else { builder . selenium2 . playback . recordResult ( { success : true } ) ; } } ) ; }
function ( ) { var reqId = Math . random ( ) ; m = [ ] ; var x = 0 , y = ids . length ; for ( ; x < y ; x ++ ) { m [ x ] = process ( ids [ x ] , reqId ) ; } callback . apply ( context , m ) ; }
function paneVisibility ( ) { var img = document . getElementById ( paneVisibility . img_id ) ; var pane = document . getElementById ( paneVisibility . pane_id ) ; if ( paneVisibility . visible == true ) { pane . style . display = 'block' ; img . src = '/images/icons/bullet_toggle_minus.png' ; img . title = 'Hide type list' ; } else { pane . style . display = 'none' ; img . src = '/images/icons/bullet_toggle_plus.png' ; img . title = 'Show type list' ; } dijit . byId ( 'bc' ) . resize ( ) ; }
function ( e , ui ) { insert_idx = $ ( this ) . attr ( 'id' ) ; $ ( this ) . text ( ui . draggable . text ( ) ) ; $ ( this ) . removeClass ( "space" , "hover" ) ; $ ( this ) . addClass ( "word" , "highlight" ) ; ui . draggable . hide ( ) ; $ ( ".space" ) . hide ( ) ; }
function getOptions ( ) { var opts = '<ul id="nav"> <li><a>Choose Error Type</a> <ul>' ; if ( current_step == "change" ) { opts = errorChoices [ "all" ] ; } else if ( current_step == "delete" ) { opts = errorChoices [ "delete" ] ; } else if ( current_step == "reorder" ) { opts = errorChoices [ "move" ] ; } else if ( highlighting_mode == "insert" ) { opts = errorChoices [ "insert" ] ; } return opts ; }
f if ( strict && '{' != buf [ 0 ] && '[' != buf [ 0 ] ) return next ( utils . error ( 400 ) ) ; try { req . body = JSON . parse ( buf , options . reviver ) ; next ( ) ; } catch ( err ) { err . body = buf ; err . status = 400 ; next ( err ) ; } } ) ;
function ( ) { var self = this ; $ ( '#' + self . id + ' BUTTON#action' ) . unbind ( 'click' ) ; $ ( '#' + self . id + ' BUTTON#cancel' ) . unbind ( 'click' ) ; $ ( '#' + self . id ) . unbind ( "orientationchange" ) . remove ( ) ; queue . splice ( 0 , 1 ) ; if ( queue . length > 0 ) queue [ 0 ] . show ( ) ; }
function ( text ) { $ ( document . body ) . popup ( text . toString ( ) ) ; }
function ( info ) { var ret = $ ( '<table>' ) ret . addClass ( 'help_optTable' ) if ( info . o ) ret . append ( HelpUtils . OptionUtils . buildOptionsHeadersHTML ( info ) ) _ . each ( info . o , function ( optDesc , optName ) { ret . append ( HelpUtils . OptionUtils . buildOptionHtml ( optDesc , optName ) ) } ) return ret }
function ( $input , $label ) { if ( ! ( this . present ( $label ) && $label . is ( 'label' ) ) ) { $label = this . find_label_for ( $input ) ; } if ( this . present ( $label ) ) { return $label ; } throw new Error ( 'Label not found.' ) ; }
function ( ) { var $input , $label , _ref ; _ref = set_fixtures_for_not_linking_input_and_label ( ) , $input = _ref [ 0 ] , $label = _ref [ 1 ] ; return expect ( $ . InField . find_and_validate_label ( $input , $ ( '<table></table>' ) ) ) . not . toBeTruthy ( ) ; }
function ( ) { var $input , $label , $result , _ref ; _ref = set_fixtures_for_linking_input_and_parent_label ( ) , $input = _ref [ 0 ] , $label = _ref [ 1 ] ; $result = $ . InField . find_and_validate_label ( $input , $ ( '<table></table>' ) ) ; expect ( $result [ 0 ] ) . toEqual ( $label [ 0 ] ) ; expect ( $result instanceof jQuery ) . toBeTruthy ( ) ; return expect ( $result ) . toBe ( 'label' ) ; }
function ( ) { var $input , $label , $result , _ref ; _ref = set_fixtures_for_linking_input_and_non_parent_label ( ) , $input = _ref [ 0 ] , $label = _ref [ 1 ] ; $result = $ . InField . find_and_validate_label ( $input , $ ( '<table></table>' ) ) ; expect ( $result [ 0 ] ) . toEqual ( $label [ 0 ] ) ; expect ( $result instanceof jQuery ) . toBeTruthy ( ) ; return expect ( $result ) . toBe ( 'label' ) ; }
function ( ) { var $input , $label , $result , _ref ; _ref = set_fixtures_for_linking_input_and_parent_label ( ) , $input = _ref [ 0 ] , $label = _ref [ 1 ] ; $result = $ . InField . find_label_for ( $input ) ; expect ( $result [ 0 ] ) . toEqual ( $label [ 0 ] ) ; expect ( $result instanceof jQuery ) . toBeTruthy ( ) ; return expect ( $result ) . toBe ( 'label' ) ; }
function ( ) { var $input , $label , $result , _ref ; _ref = set_fixtures_for_linking_input_and_non_parent_label ( ) , $input = _ref [ 0 ] , $label = _ref [ 1 ] ; $result = $ . InField . find_label_for ( $input ) ; expect ( $result [ 0 ] ) . toEqual ( $label [ 0 ] ) ; expect ( $result instanceof jQuery ) . toBeTruthy ( ) ; return expect ( $result ) . toBe ( 'label' ) ; }
function ( ) { var $input , e ; e = { keyCode : 31 , target : '<input type="text" />' } ; $input = $ ( '<input type="text" />' ) ; expect ( $ . InField . has_value ( e ) ) . not . toBeTruthy ( ) ; e = { target : '<input type="text" />' } ; return expect ( $ . InField . has_value ( e ) ) . not . toBeTruthy ( ) ; }
function ( wholeMatch , m1 , m2 , m3 , m4 , m5 ) { var c = '\0\0\0\0' + m4 + '\0\0\0\0' c = c . replace ( /\0\0\0\0([ \t]*)/ , "" ) c = c . replace ( /[ \t]*\0\0\0\0/ , "" ) c = _EncodeCode ( c , m2 ) return m1 + "<pre><code>" + c + "</code></pre>" }
function ( ) { that . instance . deselectCell ( ) ; var $th = $ ( this ) ; $th . addClass ( 'active' ) ; that . lastActive = this ; var index = $th . index ( ) ; var offset = instance . blockedCols ? instance . blockedCols . count ( ) : 0 ; that . instance . selectCell ( 0 , index - offset , that . instance . rowCount - 1 , index - offset , false ) ; }
function ( key , buffer ) { var data = JSON . parse ( buffer ) ; console . log ( 'data:' , data ) ; console . log ( 'ksjdf' , data . value ) ; return new CacheObject ( key , data . value , data . meta ) ; }
function ( ) { if ( ! store [ self . namespace ( ) ] ) { store [ self . namespace ( ) ] = { } ; } store [ self . namespace ( ) ] [ key ] = buffer ; console . log ( '+++ STORE +++' ) ; console . log ( store ) ; console . log ( '--- STORE ---' ) ; callback ( null ) ; }
function buildActivityHtml ( template , activity ) { var icon = activity . icon ; if ( icon != null && icon . length > 0 ) { if ( icon [ 0 ] == '/' ) { icon = icon . substring ( 1 ) ; } } else { icon = constants . noActivityTypeIcon ; } if ( activity . icon . indexOf ( NXGadgetContext . clientSideBaseUrl ) < 0 ) { activity . icon = NXGadgetContext . clientSideBaseUrl + icon ; } return Mustache . render ( template , activity ) ; }
function buildActivityHtml ( template , activity ) { if ( activity . icon . indexOf ( NXGadgetContext . clientSideBaseUrl ) < 0 ) { var icon = activity . icon ; if ( icon != null && icon . length > 0 ) { if ( icon [ 0 ] == '/' ) { icon = icon . substring ( 1 ) ; } } else { icon = constants . noActivityTypeIcon ; } activity . icon = NXGadgetContext . clientSideBaseUrl + icon ; } return Mustache . render ( template , activity ) ; }
function ( list ) { if ( retVal . tag != "" ) { me . core . setTags ( list , retVal . tag , function ( ) { ew_InstancesTreeView . refresh ( ) } ) ; } else { ew_InstancesTreeView . refresh ( ) ; } me . core . selectTab ( 'ew.tabs.instance' + ( this . core . isVpcMode ( ) ? ".vpc" : "" ) ) ; }
function ( ) { console . log ( "logout success" ) ; localStorage . removeItem ( 'access_token' ) ; localStorage . removeItem ( 'expires_in' ) ; localStorage . removeItem ( 'last_login_time' ) ; localStorage . removeItem ( 'uid' ) ; alert ( "登出成功" ) ; }
function ( item , object ) { if ( item == null ) return false ; var constructor = item . $constructor || item . constructor ; while ( constructor ) { if ( constructor === object ) return true ; constructor = constructor . parent ; } return item instanceof object ; }
function ( fn , bind ) { var results = [ ] ; for ( var i = 0 , l = this . length >>> 0 ; i < l ; i ++ ) { if ( ( i in this ) && fn . call ( bind , this [ i ] , i , this ) ) results . push ( this [ i ] ) ; } return results ; }
function ( el , nocash ) { Slick . uidOf ( el ) ; if ( ! nocash && ! el . $family && ! ( /^(?:object|embed)$/i ) . test ( el . tagName ) ) { el . _fireEvent = el . fireEvent ; Object . append ( el , Element . Prototype ) ; } return el ; }
function ( item ) { var uid = item . uid ; if ( item . removeEvents ) item . removeEvents ( ) ; if ( item . clearAttributes ) item . clearAttributes ( ) ; if ( uid != null ) { delete collected [ uid ] ; delete storage [ uid ] ; } return item ; }
function ( d , h ) { var m = d , t = false ; if ( typeof m === "string" ) t = h || false ; else if ( m && ! m [ 0 ] && ! m . length ) m = [ m ] ; return $p . core ( m , t ) }
function ( req , model ) { securePairs [ model . _clientId ] = req . sessionID ; var session = model . session = req . session , userId = session . userId || session . auth && session . auth . userId ; if ( ! userId ) userId = session . userId = store . uuid ( ) ; model . set ( '_userId' , userId ) ; }
function ( context ) { var fragment = context . createFragment ( ) ; this . children = this . children || [ ] ; this . children . forEach ( function ( c ) { fragment . appendChild ( c . _render ( context ) ) ; } ) ; return fragment ; }
function ( ) { var arg , context = { context : { value : 'context' } } ; ist . registerHelper ( 'testBlock' , function ( subcontext , subtemplate ) { arg = subtemplate . document ; return document . createDocumentFragment ( ) ; } ) ; ist ( textBlockhelper ) . render ( context ) ; expect ( arg ) . toBe ( document ) ; }
function ( ) { expect ( textNodes [ 0 ] . nodeType ) . toBe ( document . TEXT_NODE ) ; expect ( textNodes [ 0 ] . textContent ) . toBe ( "text node" ) ; }
function ( values ) { if ( typeof values === 'undefined' ) { values = [ 0 , 0 , 0 , 0 ] ; } else if ( ! Array . isArray ( values ) ) { throw new DeveloperError ( 'values must be an array' ) ; } this [ 0 ] = values [ 0 ] ; this [ 1 ] = values [ 1 ] ; this [ 2 ] = values [ 2 ] ; this [ 3 ] = values [ 3 ] ; }
function ( ) { var matrix = new Matrix2 ( ) ; expect ( matrix [ 0 ] ) . toEqual ( 0.0 ) ; expect ( matrix [ 1 ] ) . toEqual ( 0.0 ) ; expect ( matrix [ 2 ] ) . toEqual ( 0.0 ) ; expect ( matrix [ 3 ] ) . toEqual ( 0.0 ) ; }
function ( ) { var expected = [ 1.0 , 2.0 , 3.0 , 4.0 ] ; var matrix = new Matrix2 ( expected ) ; expect ( matrix [ 0 ] ) . toEqual ( 1.0 ) ; expect ( matrix [ 1 ] ) . toEqual ( 2.0 ) ; expect ( matrix [ 2 ] ) . toEqual ( 3.0 ) ; expect ( matrix [ 3 ] ) . toEqual ( 4.0 ) ; }
function ( ) { var expected = new Matrix2 ( [ 1.0 , 2.0 , 3.0 , 4.0 ] ) ; var returnedResult = expected . clone ( ) ; expect ( returnedResult ) . toNotBe ( expected ) ; expect ( returnedResult ) . toEqual ( expected ) ; }
function ( ) { var expected = new Matrix2 ( [ 1.0 , 2.0 , 3.0 , 4.0 ] ) ; var result = new Matrix2 ( ) ; var returnedResult = expected . clone ( result ) ; expect ( returnedResult ) . toBe ( result ) ; expect ( returnedResult ) . toNotBe ( expected ) ; expect ( returnedResult ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1.0 , 2.0 , 3.0 , 4.0 ) ; var expectedRow0 = new Cartesian2 ( 1.0 , 2.0 ) ; var expectedRow1 = new Cartesian2 ( 3.0 , 4.0 ) ; var resultRow0 = matrix . getRow ( 0 ) ; var resultRow1 = matrix . getRow ( 1 ) ; expect ( resultRow0 ) . toEqual ( expectedRow0 ) ; expect ( resultRow1 ) . toEqual ( expectedRow1 ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = Matrix2 . fromComponents ( 5 , 6 , 7 , 8 ) ; var expected = Matrix2 . fromComponents ( 19 , 22 , 43 , 50 ) ; var result = left . multiply ( right ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = Matrix2 . fromComponents ( 5 , 6 , 7 , 8 ) ; var expected = Matrix2 . fromComponents ( 19 , 22 , 43 , 50 ) ; var result = new Matrix2 ( ) ; var returnedResult = left . multiply ( right , result ) ; expect ( returnedResult ) . toBe ( result ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = Matrix2 . fromComponents ( 5 , 6 , 7 , 8 ) ; var expected = Matrix2 . fromComponents ( 19 , 22 , 43 , 50 ) ; var returnedResult = left . multiply ( right , left ) ; expect ( returnedResult ) . toBe ( left ) ; expect ( left ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = new Cartesian2 ( 5 , 6 ) ; var expected = new Cartesian2 ( 17 , 39 ) ; var result = left . multiplyByVector ( right ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = new Cartesian2 ( 5 , 6 ) ; var expected = new Cartesian2 ( 17 , 39 ) ; var result = new Cartesian2 ( ) ; var returnedResult = left . multiplyByVector ( right , result ) ; expect ( returnedResult ) . toBe ( result ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = 2 ; var expected = Matrix2 . fromComponents ( 2 , 4 , 6 , 8 ) ; var result = left . multiplyByScalar ( right ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = 2 ; var expected = Matrix2 . fromComponents ( 2 , 4 , 6 , 8 ) ; var result = new Matrix2 ( ) ; var returnedResult = left . multiplyByScalar ( right , result ) ; expect ( returnedResult ) . toBe ( result ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( - 1 , - 2 , - 3 , - 4 ) ; var result = matrix . negate ( ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( - 1 , - 2 , - 3 , - 4 ) ; var result = new Matrix2 ( ) ; var returnedResult = matrix . negate ( result ) ; expect ( result ) . toBe ( returnedResult ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( - 1 , - 2 , - 3 , - 4 ) ; var returnedResult = matrix . negate ( matrix ) ; expect ( matrix ) . toBe ( returnedResult ) ; expect ( matrix ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( 1 , 3 , 2 , 4 ) ; var result = matrix . transpose ( ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( 1 , 3 , 2 , 4 ) ; var result = new Matrix2 ( ) ; var returnedResult = matrix . transpose ( result ) ; expect ( result ) . toBe ( returnedResult ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( 1 , 3 , 2 , 4 ) ; var returnedResult = matrix . transpose ( matrix ) ; expect ( matrix ) . toBe ( returnedResult ) ; expect ( matrix ) . toEqual ( expected ) ; }
function ( ) { expect ( wigData . length ) . toBeGreaterThan ( 19 ) ; expect ( wigData . length ) . toBeLessThan ( 100 ) ; dojo . forEach ( wigData , function ( feature ) { expect ( feature . get ( 'start' ) ) . toBeGreaterThan ( 80000 ) ; expect ( feature . get ( 'end' ) ) . toBeLessThan ( 2050000 ) ; } ) ; }
function ( args ) { args = args || { } ; this . statusEl = args . statusBar || $ ( ".c4status" ) ; this . boardEl = args . board || $ ( "#c4board" ) ; }
function ( msg ) { var welcome = msg . match ( /^WELCOME (.+)$/ ) ; if ( welcome ) { C4 . playerId = welcome [ 1 ] ; C4 . remove_handler ( C4 . cb_welcome ) ; C4 . add_handler ( C4 . cb_seek_notifications ) ; $ . mobile . changePage ( $ ( "#main" ) ) ; return true ; } else return false ; }
function ( gType ) { var boardSize = $ ( "input[type='radio'][name='board-size']:checked" ) . val ( ) ; var gVar = $ ( "input[type='radio'][name='game-variation']:checked" ) . val ( ) ; var cmd = "SEEK " + gType + " C4 " + gVar + " " + boardSize ; C4 . status ( cmd ) ; C4 . sock . send ( cmd ) ; C4 . add_handler ( C4 . cb_seek_reply ) ; C4 . add_handler ( C4 . cb_new_game ) ; $ . mobile . changePage ( $ ( "#main" ) ) ; }
function ( msg ) { var m ; var found = false ; if ( m = msg . match ( /^SEEK_CANCELED (\d+)$/ ) ) { C4 . status ( msg ) ; var seekId = + m [ 1 ] ; C4 . remove_my_seek ( seekId ) ; found = true ; } else if ( msg . match ( /^NO_SEEK_FOUND (\d+)$/ ) ) { C4 . status ( msg ) ; found = true ; } ; if ( found ) C4 . remove_handler ( C4 . cb_cancel_seek ) ; return found ; }
function set ( x , y , z , width , height , depth ) { this . x = x || 0 ; this . y = y || 0 ; this . z = z || 0 ; this . width = x || 0 ; this . height = y || 0 ; this . depth = z || 0 ; return this ; }
function set ( x , y , z , width , height , depth ) { this . x = x || 0 ; this . y = y || 0 ; this . z = z || 0 ; this . width = x || 0 ; this . height = y || 0 ; this . depth = z || 0 ; return this ; }
function ( ) { $ ( this ) . css ( { "background-image" : "url('/images/logo_lettering.png')" , "width" : "190px" } ) . animate ( { "opacity" : "1" } , { queue : false , duration : 500 } ) . animate ( { "padding-bottom" : "13px" , "height" : "33px" } , { duration : 500 } ) ; $ ( this ) . css ( { "background-position-y" : "12px" } ) ; }
function ( ) { $ ( this ) . css ( { "background-image" : "url('/logo.png')" , "background-position-y" : "0" , "padding-bottom" : "0" , "width" : "130px" } ) . animate ( { "height" : "92px" } , { duration : 300 } ) . animate ( { "opacity" : "1" } , { duration : 300 } ) ; }
function ( context ) { var border = this . border ( ) ; if ( border ) { var size = this . size ( ) ; context . strokeStyle = border ; context . rect ( 0 , 0 , size . w - 1 , size . h - 1 ) ; context . stroke ( ) ; } }
function ( e ) { log . warning ( 'Got connection lost notification' ) ; if ( e . errCode == CDO . ErrorCodes . Communication . COMM_REMOTE_END_DIED ) { log . warn ( 'Connection terminated due to internet connection issues. ' + 'Trying to reconnect in 5 seconds' ) ; CDOT . disconnectHandler ( ) ; CDOT . tryReconnect ( ) ; } }
function ( ) { log . debug ( "Trying to reestablish the connection to the Cloudeo Streaming " + "Server" ) ; var succHandler = function ( ) { log . debug ( "Connection successfully reestablished!" ) ; CDOT . postConnectHandler ( CDOT . currentConnDescriptor ) ; } ; var errHandler = function ( ) { log . warn ( "Failed to reconnect. Will try again in 5 secs" ) ; CDOT . tryReconnect ( ) ; } ; CDO . getService ( ) . connect ( CDO . createResponder ( succHandler , errHandler ) , CDOT . currentConnDescriptor ) ; }
function ( token , compiledContents , compiler , callback ) { if ( token . parent . tagType . tagName !== 'block' ) { return callback ( new Error ( 'Compilation error: `parent` tag should be immediate child of a `block` tag.' ) ) ; } token . parent . hasParentTag = true ; callback ( null , '__acc.push("{{parent}}");' ) ; }
function ( contents ) { editor . session . doc . setValue ( contents ) ; editor . navigateFileStart ( ) ; }
function ( ev ) { obj . right_deck . set_iframe ( urls . XUL_TRIGGER_EVENTS , { } , { 'patron_id' : obj . patron . id ( ) } ) ; }
function checkIfPlaying ( ) { var tag = document . getElementsByClassName ( "still_listening" ) [ 0 ] ; if ( tag != undefined ) { document . getElementsByClassName ( "still_listening" ) [ 0 ] . click ( ) ; console . log ( "clicked the link" ) ; } if ( document . getElementsByClassName ( "playButton" ) [ 0 ] . style [ 'cssText' ] == 'display: block; ' ) { document . getElementsByClassName ( "playButton" ) [ 0 ] . click ( ) ; console . log ( "pressed play" ) ; } }
function ( email , cb ) { sync ( ) ; var m = jsel . match ( ".emails ." + ESC ( email ) , db . users ) ; process . nextTick ( function ( ) { cb ( null , m . length ? m [ 0 ] . type : undefined ) ; } ) ; }
function ( email , cb ) { client . query ( "SELECT COUNT(*) as N FROM staged WHERE email = ?" , [ email ] , function ( err , rows ) { cb ( err , rows && rows . length > 0 && rows [ 0 ] . N > 0 ) ; } ) ; }
function ( e , data ) { var firstTarget = data . invalidlist [ 0 ] ; if ( firstTarget && ( badWebkit || ( $ . nodeName ( firstTarget , 'select' ) ) ) && document . activeElement && firstTarget !== document . activeElement && firstInvalidEvent && ! firstInvalidEvent . isInvalidUIPrevented ( ) ) { webshims . validityAlert . showFor ( firstTarget ) ; } firstInvalidEvent = false ; invalids = [ ] ; if ( ! form ) { return ; } $ ( form ) . unbind ( 'submit.preventInvalidSubmit' ) ; }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( d ) { if ( ! d || ! ( 17 == d . keyCode || 16 == d . keyCode ) ) b . value = a . prop ( b , "value" ) , c . box . removeClass ( "placeholder-visible" ) , clearTimeout ( j ) , a ( b ) . unbind ( ".placeholderremove" ) }
function ( a ) { n [ 0 ] . value = a ; a = n [ 0 ] . value ; h . text ( a ) ; b . contentAttr ( h [ 0 ] , "value" , a ) } ; h [ 0 ] . defaultValue = f ; b . contentAttr ( h [ 0 ] , "value" , f ) ; h . attr ( { "aria-live" : "polite" }
function ( d ) { var c = a ( "li:not(.hidden-item)" , e . shadowList ) , f = "mousedown" == d . type || "click" == d . type ; e . markItem ( c . index ( d . currentTarget ) , f , c ) ; "click" == d . type && ( e . hideList ( ) , a ( b . input ) . trigger ( "datalistselect" ) ) ; return "mousedown" != d . type }
function ( a ) { return ! b . test ( a ) } } ( ) } ) ; d . addInputType ( "url" , { mismatch : function ( ) { var b = w . urlReg || / ^ ( [ a - z ] ( [ a - z ] |
function ( c ) { if ( ! c || ! ( 17 == c . keyCode || 16 == c . keyCode ) ) b . value = a . prop ( b , "value" ) , d . box . removeClass ( "placeholder-visible" ) , clearTimeout ( o ) , a ( b ) . unbind ( ".placeholderremove" ) }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( e , data ) { var firstTarget = data . invalidlist [ 0 ] ; if ( firstTarget && ( badWebkit || ( $ . nodeName ( firstTarget , 'select' ) ) ) && document . activeElement && firstTarget !== document . activeElement && firstInvalidEvent && ! firstInvalidEvent . isInvalidUIPrevented ( ) ) { webshims . validityAlert . showFor ( firstTarget ) ; } firstInvalidEvent = false ; invalids = [ ] ; if ( ! form ) { return ; } $ ( form ) . unbind ( 'submit.preventInvalidSubmit' ) ; }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( element , maxLength ) { if ( element === document . activeElement ) { if ( maxLength == null ) { maxLength = $ . prop ( element , 'maxlength' ) ; } constrainMaxLength ( e . target , maxLength ) ; } }
function ( ) { var time = new Date ( ) - startTime ; var progress = Math . min ( transition ( time / duration ) , 1 ) ; for ( prop in properties ) style [ prop ] = ( diff [ prop ] * progress + start [ prop ] ) + units [ prop ] ; if ( progress === 1 ) { window . clearInterval ( timer ) ; cb && cb ( ) ; } }
function ( t ) { var afd = new AccrualFailureDetector ( ) ; var time = 0 ; for ( var i = 0 ; i < 2000 ; i ++ ) { time += 1000 ; afd . add ( time ) ; } t . equal ( 1000 , afd . intervals . length ) ; t . end ( ) ; }
function SyncWithCacheThread ( aFunc ) { do_check_eq ( sync_with_cache_IO_thread_cb . listener , null ) ; sync_with_cache_IO_thread_cb . listener = aFunc ; var cache = get_cache_service ( ) ; var session = cache . createSession ( "HTTP" , Ci . nsICache . STORE_ANYWHERE , Ci . nsICache . STREAM_BASED ) ; var cacheEntry = session . asyncOpenCacheEntry ( "nonexistententry" , Ci . nsICache . ACCESS_READ , sync_with_cache_IO_thread_cb ) ; }
function ( ) { var cache = get_cache_service ( ) ; var session = cache . createSession ( "HTTP" , this . _asFile ? Ci . nsICache . STORE_ON_DISK_AS_FILE : Ci . nsICache . STORE_ON_DISK , Ci . nsICache . STREAM_BASED ) ; var cacheEntry = session . asyncOpenCacheEntry ( this . _key , this . _append ? Ci . nsICache . ACCESS_READ_WRITE : Ci . nsICache . ACCESS_WRITE , this ) ; }
function ( ) { raises ( function ( ) { FileStream ( ) ; } ) ; }
function ( containerView , itemViewContainer ) { var container ; if ( "$itemViewContainer" in containerView ) { container = containerView . $itemViewContainer ; } else { if ( containerView . itemViewContainer ) { container = containerView . $ ( itemViewContainer ) ; } else { container = containerView . $el ; } containerView . $itemViewContainer = container ; } return container ; }
function createBoard ( ) { var i ; var newRow ; var shapeCollection = shapeCollectionMock ; for ( i = 0 ; i < BOARD_SIZE ; ++ i ) { newRow = document . createElement ( "div" ) ; onButtonPressFactory = makeOnButtonPress ( i , shapeCollection ) ; createRow ( newRow , onButtonPressFactory ) ; document . body . appendChild ( newRow ) ; } }
function isStrictCompletion ( inputValue , completion ) { inputValue = inputValue . replace ( /^\s*/ , '' ) ; return completion . indexOf ( inputValue ) === 0 ; }
function drop ( e ) { e . preventDefault ( ) ; var realtarget = $ ( e . target ) . closest ( ".tracker-div" ) ; var data = e . dataTransfer . getData ( "Text" ) ; $ . ajax ( { url : "/ajax?request=move_tracker&keys=" + Array ( "url" , "target_alias" ) + "&values=" + encodeURIComponent ( Array ( data , realtarget . attr ( "id" ) ) ) , success : function ( data ) { console . log ( data ) ; } } ) ; }
function ( result ) { var adDisplayConf = { } ; if ( result [ 'http_code' ] == 'ERROR' || result [ 'http_code' ] == 0 ) { mw . log ( "Error: loadAdXml error with http response" ) ; callback ( false ) ; return ; } try { var resultXML = $ . parseXML ( result [ 'contents' ] ) ; } catch ( e ) { mw . log ( "Error: AdLoader could not parse:" + resultXML ) ; callback ( { } ) ; return ; } _this . handleResult ( resultXML , callback ) ; }
function ( options ) { if ( ! $ . isFunction ( options . error ) ) { options . error = function ( ) { } ; } this . options = options ; this . ajax ( ) ; }
function ( logmsg ) { log ( "==============================================" ) ; log ( "To App: " + logmsg ) ; log ( "==============================================" ) ; if ( ! logSubscription || ! logmsg ) { return ; } var f = logSubscription . get ( ) ; f . result = { msg : logmsg } ; }
function ( key ) { var match = key . match ( /^(([\$\_a-z]|ng\:)[\w\_\-]{2,})/ ) ; if ( match ) { key = match [ 1 ] ; if ( ! keywords [ key ] ) { keywords [ key ] = true ; words . push ( key ) ; } } }
function ( page_model , parent_element ) { dm4c . render . field_label ( page_model , parent_element ) parent_element . append ( js . render_text ( page_model . value ) ) }
function ( ) { $ . ajax ( { url : "//pages/pages.json" , type : "GET" , success : this . proxy ( function ( data ) { this . element . html ( this . view ( "pageslist" , data ) ) ; } ) , error : function ( e ) { alert ( "error" ) ; } } ) ; }
function ( ) { var current = { "order_by" : this . _order_mod + this . _order , "milestone" : this . _milestone_id , "tags" : this . options . tag_filter } if ( this . _status . length > 0 ) { current [ 'status' ] = this . _status ; } return current ; }
function ( task ) { var self = this ; $ . post ( task . get ( 'delete_url' ) , { } , function ( data ) { if ( data . valid ) { var selector = "#task_" + task . get ( 'id' ) ; self . $ ( selector ) . remove ( ) ; } } , 'json' ) ; }
function ( ) { led = new five . Led ( { pin : 9 } ) ; board . repl . inject ( { led : led } ) ; led . fadeIn ( ) ; this . wait ( 5000 , function ( ) { led . fadeOut ( ) ; } ) ; }
function ( ) { scalingRange = [ 0 , 170 ] ; slider = new five . Sensor ( { pin : "A0" , freq : 50 } ) ; slider . on ( "slide" , function ( err , value ) { if ( err ) { console . log ( "error: " , err ) ; } else { console . log ( Math . floor ( this . value ) ) ; } } ) ; }
function ( ) { if ( this . mode !== this . firmata . MODES . OUTPUT ) { this . mode = this . firmata . MODES . OUTPUT ; this . firmata . pinMode ( this . pin , this . mode ) ; } this . firmata . digitalWrite ( this . pin , this . firmata . LOW ) ; priv . set ( this , { isOn : false , isRunning : false , value : 0 } ) ; return this ; }
function ( ) { if ( this . mode !== this . firmata . MODES . OUTPUT ) { this . mode = this . firmata . MODES . OUTPUT ; this . firmata . pinMode ( this . pin , this . mode ) ; } var ref = priv . get ( this ) ; if ( ref . isOn || ref . isRunning ) { this . off ( ) ; } else { this . on ( ) ; } return this ; }
function ( val ) { if ( this . mode !== this . firmata . MODES . PWM ) { this . mode = this . firmata . MODES . PWM ; this . firmata . pinMode ( this . pin , this . mode ) ; } this . firmata . analogWrite ( this . pin , val ) ; priv . set ( this , { isOn : val ? true : false , isRunning : val ? true : false , value : val } ) ; return this ; }
function ( ) { var valueAt = priv . get ( this ) . value ; if ( ( direction > 0 && valueAt === 255 ) || ( direction < 0 && valueAt === 0 ) || valueAt === val ) { clearInterval ( this . interval ) ; } else { this . brightness ( valueAt + direction ) ; } }
function ( ) { var ref = priv . get ( this ) ; clearInterval ( this . interval ) ; priv . set ( this , { isOn : ref . isOn , isRunning : false , value : ref . value } ) ; return this ; }
function ( xhr ) { if ( xhr . statusText == 'abort' ) { console . log ( '-> poll in error' ) ; _this . poll ( ) ; } else { _this . errorSleepTime += 1000 ; console . log ( "Unexpected poll error; sleeping for" , _this . errorSleepTime , "ms" ) ; ( function ( ) { window . setTimeout ( _this . poll , _this . errorSleepTime ) ; } ) . call ( _this ) ; } }
function ( err ) { emitter . emit ( "twitterListChange" , id ) ; if ( ! err ) { req . flash ( "success" , "Successfully added your twitter account" ) ; } else { req . flash ( "error" , "Failed to add your twitter account: " + err ) ; } next ( ) ; }
function ( err , resp , source ) { if ( err ) { cb ( err , null ) ; } else if ( 304 == resp . statusCode ) { handle304 ( memcached , key , resp , cb ) ; } else if ( 200 == resp . statusCode ) { handle200 ( memcached , key , timeout , resp , source , cb ) ; } else { cb ( "status " + resp . statusCode , null , null ) ; } }
function ( err , source ) { if ( ! source || err ) { return cb ( err , null ) ; } $this . cache_store ( name , source , function ( err ) { return $this . compile ( source , cb ) ; } ) ; }
function ( source , cb ) { var $this = this ; try { var tmpl_cls = $this . options . template_class ; cb ( null , new tmpl_cls ( { source : source } ) ) ; } catch ( e ) { cb ( e , null ) ; } }
function ( macro_errors ) { var result = _ . map ( tokens , function ( tok ) { if ( 'TEXT' == tok . type ) { return tok . out ; } else if ( 'MACRO' == tok . type ) { return macros [ tok . hash ] . out ; } } ) . join ( '' ) ; var errors = [ ] . concat ( tmpl_errors , macro_errors ) ; $this . emit ( 'end' ) ; process_done ( errors . length ? errors : null , result ) ; }
function ( err , tmpl ) { if ( ! err ) { templates [ name ] = tmpl ; $this . emit ( 'templateLoadEnd' , { name : name , template : tmpl } ) ; } else { var ex = new TemplateLoadingError ( { name : name , error : err , src : src } ) ; errors . push ( ex ) ; $this . emit ( 'error' , ex ) ; } q_next ( ) ; }
function ( err , result ) { if ( timed_out ) return ; clearTimeout ( tmout_timer ) ; if ( err ) { var ex = new TemplateExecutionError ( { token : tok , error : err , src : src } ) ; errors . push ( ex ) ; $this . emit ( 'error' , ex ) ; return next ( '{{ ' + tok . name + ' }}' ) ; } $this . emit ( 'macroEnd' , tok ) ; return next ( result ) ; }
function ( target ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { var obj = arguments [ i ] ; if ( obj === null || typeof obj === 'undefined' ) continue ; for ( key in obj ) { target [ key ] = obj [ key ] ; } } return target ; }
function ( msg , info ) { self . hostname = info . hostname ; self . siteName = info . siteName || info . hostname ; self . siteTOSPP = ! ! ( info . privacyPolicy && info . termsOfService ) ; requiredEmail = info . requiredEmail ; startAction ( false , "doRPInfo" , info ) ; if ( info . email && info . type === "primary" ) { primaryVerificationInfo = info ; redirectToState ( "primary_user" , info ) ; } else { startAction ( "doCheckAuth" ) ; } }
function ( msg , info ) { self . newUserEmail = info . email ; mediator . publish ( "kpi_data" , { new_account : true } ) ; _ . extend ( info , { cancelable : ! requiredEmail , personaTOSPP : ! ! requiredEmail , siteTOSPP : ! ! requiredEmail && self . siteTOSPP } ) ; startAction ( false , "doSetPassword" , info ) ; }
function ( info ) { self . close ( "authenticate" , info ) ; }
function ( options ) { if ( this != navigator . id ) throw new Error ( "all navigator.id calls must be made on the navigator.id object" ) ; options = options || { } ; checkCompat ( false ) ; return internalRequest ( options ) ; }
function onSuccess ( info ) { if ( info . success ) { pageHelpers . emailSent ( oncomplete ) ; } else { var tooltipEl = info . reason === "throttle" ? "#could_not_add" : "#not_registered" ; tooltip . showTooltip ( tooltipEl ) ; complete ( oncomplete ) ; } }
function cancelAccount ( oncomplete ) { if ( confirmAction ( gettext ( "Are you sure you want to cancel your BrowserID account?" ) ) ) { user . cancelUser ( function ( ) { doc . location = "/" ; oncomplete && oncomplete ( ) ; } , pageHelpers . getFailure ( errors . cancelUser , oncomplete ) ) ; } }
function emailSent ( onComplete ) { origStoredEmail = getStoredEmail ( ) ; dom . setInner ( '#sentToEmail' , origStoredEmail ) ; clearStoredEmail ( ) ; replaceInputsWithNotice ( ".emailsent" ) ; user . waitForUserValidation ( origStoredEmail , function ( status ) { userValidationComplete ( status ) ; } ) ; onComplete && onComplete ( ) ; }
function openPrimaryAuth ( winchan , email , baseURL , callback ) { if ( ! ( email && baseURL ) ) { throw "cannot verify with primary without an email address and URL" } winchan . open ( { url : "https://login.persona.org/authenticate_with_primary" , relay_url : "https://login.persona.org/relay" , window_features : "width=700,height=375" , params : helpers . toURL ( baseURL , { email : email } ) } , function ( error , result ) { if ( ! error ) { user . resetCaches ( ) ; } callback && callback ( error , result ) ; } ) ; }
function ( info ) { if ( info ) { redirectTo = info . returnTo ; email = info . email ; showRegistrationInfo ( info ) ; mustAuth = info . must_auth ; if ( mustAuth ) { dom . addClass ( "body" , "enter_password" ) ; complete ( oncomplete , true ) ; } else { submit ( oncomplete ) ; } } else { self . renderError ( "error" , errors . cannotConfirm ) ; complete ( oncomplete , false ) ; } }
function ( ) { storage . setReturnTo ( testOrigin ) ; xhr . useResult ( "complete" ) ; lib . waitForUserValidation ( "registered@testuser.com" , function ( status ) { equal ( status , "complete" , "complete response expected" ) ; ok ( ! storage . getReturnTo ( ) , "staged on behalf of is cleared when validation completes" ) ; start ( ) ; } , testHelpers . unexpectedXHRFailure ) ; }
function ( ) { storage . setReturnTo ( testOrigin ) ; xhr . useResult ( "complete" ) ; lib . waitForEmailValidation ( "registered@testuser.com" , function ( status ) { ok ( ! storage . getReturnTo ( ) , "staged on behalf of is cleared when validation completes" ) ; equal ( status , "complete" , "complete response expected" ) ; start ( ) ; } , testHelpers . unexpectedXHRFailure ) ; }
function ( status ) { ok ( ! storage . getReturnTo ( ) , "staged on behalf of is cleared when validation completes" ) ; equal ( status , "mustAuth" , "mustAuth response expected" ) ; start ( ) ; }
function ( ) { var tooLong = "" ; for ( var i = 0 ; i < 81 ; i ++ ) { tooLong += ( i % 10 ) ; } var valid = validation . passwordAndValidationPassword ( tooLong , tooLong ) ; equal ( valid , false , "too short password is invalid" ) ; equal ( tooltipShown , true , "too short password shows tooltip" ) ; }
function createController ( verifier , message , required ) { controller = bid . Modules . CheckRegistration . create ( ) ; controller . start ( { email : "registered@testuser.com" , verifier : verifier , verificationMessage : message , required : required , siteName : "Unit Test Site" } ) ; }
function testVerifiedUserEvent ( event_name , message ) { createController ( "waitForUserValidation" , event_name ) ; register ( event_name , function ( ) { ok ( true , message ) ; start ( ) ; } ) ; controller . startCheck ( ) ; }
function ( ) { xhr . useResult ( "mustAuth" ) ; createController ( "waitForUserValidation" ) ; register ( "authenticate" , function ( msg , info ) { equal ( info . email , "registered@testuser.com" , "correct email" ) ; ok ( info . type , "type sent with info" ) ; ok ( info . known , "email is known" ) ; start ( ) ; } ) ; controller . startCheck ( ) ; }
function ( ) { xhr . useResult ( "ajaxError" ) ; createController ( "waitForUserValidation" , "user_verified" ) ; controller . startCheck ( function ( ) { register ( "user_verified" , function ( ) { ok ( false , "on XHR error, should not complete" ) ; } ) ; ok ( testHelpers . errorVisible ( ) , "Error message is visible" ) ; start ( ) ; } ) ; }
function ( ) { $ ( "#old_password" ) . val ( "" ) ; $ ( "#new_password" ) . val ( "newpassword" ) ; bid . manageAccount . changePassword ( function ( status ) { equal ( status , false , "on missing old password, status is false" ) ; testHelpers . testTooltipVisible ( ) ; start ( ) ; } ) ; }
function ( ) { $ ( "#old_password" ) . val ( "oldpassword" ) ; $ ( "#new_password" ) . val ( "" ) ; bid . manageAccount . changePassword ( function ( status ) { equal ( status , false , "on missing new password, status is false" ) ; testHelpers . testTooltipVisible ( ) ; start ( ) ; } ) ; }
function ( status ) { equal ( status , true , "on proper completion, status is true" ) ; equal ( tooltip . shown , false , "on proper completion, tooltip is not shown" ) ; equal ( $ ( "#old_password" ) . val ( ) , "" , "old_password field is cleared" ) ; equal ( $ ( "#new_password" ) . val ( ) , "" , "new_password field is cleared" ) ; start ( ) ; }
function ( ) { $ ( "#old_password" ) . val ( "oldpassword" ) ; $ ( "#new_password" ) . val ( "newpassword" ) ; xhr . useResult ( "incorrectPassword" ) ; bid . manageAccount . changePassword ( function ( status ) { equal ( status , false , "bad password, status is false" ) ; testHelpers . testTooltipVisible ( ) ; start ( ) ; } ) ; }
function ( req , res , next ) { metrics . userEntry ( req ) ; renderCachableView ( req , res , 'dialog.ejs' , { title : _ ( 'A Better Way to Sign In' ) , layout : 'dialog_layout.ejs' , useJavascript : true , production : config . get ( 'use_minified_resources' ) } ) ; }
function ( valid ) { var result = invalidInfo ; if ( valid ) { result = _ . extend ( { valid : valid } , info ) ; var email = info . email , idInfo = storage . getEmail ( email ) ; if ( idInfo ) { idInfo . verified = true ; storage . addEmail ( email , idInfo ) ; } storage . setReturnTo ( "" ) ; } complete ( onComplete , result ) ; }
function ( ) { var text = $ ( "textarea" ) . val ( ) . trim ( ) . split ( " " ) . length $ ( "#processing-result" ) . html ( text ) }
function startRegCheckService ( options , verifier , message , password ) { var controller = startService ( "check_registration" , { verifier : verifier , verificationMessage : message , password : password , siteName : options . siteName } ) ; controller . startCheck ( ) ; }
function createController ( verifier , message , required ) { controller = bid . Modules . CheckRegistration . create ( ) ; controller . start ( { email : "registered@testuser.com" , verifier : verifier , verificationMessage : message , required : required } ) ; }
function ( ) { configPath = path . resolve ( "test/config-bare-minimum.xml" ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . content ) . toEqual ( "local:///startPage.html" ) ; expect ( configObj . version ) . toEqual ( "1.0.0" ) ; } ) ; }
function ( ) { configPath = path . resolve ( "test/config-license.xml" ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . license ) . toEqual ( "" ) ; expect ( configObj . licenseURL ) . toEqual ( "http://www.apache.org/licenses/LICENSE-2.0" ) ; } ) ; }
function _onError ( error ) { console . error ( error . message ) ; }
function ( ) { this . _getBuilder_ ( ) . addChildrenTo ( "main" , [ "col1" , "col2" ] ) . addChildrenTo ( "col1" , [ "name" , "code" ] ) . addChildrenTo ( "col2" , [ "iso2" , "iso3" , "active" ] ) . addAuditFilter ( ) }
function ( ) { this . _getBuilder_ ( ) . addTextColumn ( { name : "name" , dataIndex : "name" , width : 120 } ) . addTextColumn ( { name : "description" , dataIndex : "description" , width : 300 } ) . addBooleanColumn ( { name : "active" , dataIndex : "active" } ) . addDefaults ( ) ; }
function ( ) { this . _getBuilder_ ( ) . addTextColumn ( { name : "name" , dataIndex : "name" , width : 120 } ) . addTextColumn ( { name : "description" , dataIndex : "description" , width : 300 } ) . addBooleanColumn ( { name : "active" , dataIndex : "active" } ) . addDefaults ( ) ; }
function isInternetExplorer ( ) { var rv = - 1 ; if ( navigator . appName == 'Microsoft Internet Explorer' ) { var ua = navigator . userAgent ; var re = new RegExp ( "MSIE ([0-9]{1,}[\.0-9]{0,})" ) ; if ( re . exec ( ua ) != null ) rv = parseFloat ( RegExp . $1 ) ; } return rv >= 8 ; }
function isFennec ( ) { try { return ( navigator . userAgent . indexOf ( 'Fennec/' ) != - 1 ) ; } catch ( e ) { } ; return false ; }
function onMessage ( e ) { removeListener ( window , 'message' , onMessage ) ; var d ; o = e . origin ; try { d = JSON . parse ( e . data ) ; } catch ( e ) { } if ( cb ) { setTimeout ( function ( ) { cb ( o , d . d , function ( r ) { cb = undefined ; doPost ( { a : 'response' , d : r } ) ; } ) ; } , 0 ) ; } }
function ( ) { removeListener ( isIE ? msgTarget : window , 'message' , onDie ) ; if ( cb ) doPost ( { a : 'error' , d : 'client closed window' } ) ; cb = undefined ; try { window . close ( ) ; } catch ( e ) { } ; }
function convert_ean8_to_upca ( upc ) { if ( upc . length == 7 ) { upc = upc + validate_ean8 ( upc , true ) ; } if ( upc . length > 8 || upc . length < 8 ) { return false ; } if ( validate_ean8 ( upc ) === false ) { return false ; } upca = "0000" + upc ; return upca ; }
function convert_isbn10_to_isbn13 ( upc ) { upc = upc . replace ( /-/g , "" ) ; upc = upc . replace ( /\s/g , "" ) ; if ( validate_isbn10 ( upc ) === false ) { return false ; } if ( upc . length > 9 ) { fix_matches = upc . match ( /^(\d{9})/ ) ; upc = fix_matches [ 1 ] ; } isbn13 = "978" + upc + validate_ean13 ( "978" + upc , true ) ; return isbn13 ; }
function convert_isbn13_to_isbn10 ( upc ) { upc = upc . replace ( /-/g , "" ) ; upc = upc . replace ( /\s/g , "" ) ; if ( validate_ean13 ( upc ) === false ) { return false ; } if ( ! upc . match ( /^978(\d{9})/ ) ) { return false ; } if ( upc . match ( /^978(\d{9})/ ) ) { upc_matches = upc . match ( /^978(\d{9})/ ) ; isbn10 = upc_matches [ 1 ] + validate_isbn10 ( upc_matches [ 1 ] , true ) ; } return isbn10 ; }
function convert_ismn10_to_ismn13 ( upc ) { upc = upc . replace ( /M/g , "" ) ; upc = upc . replace ( /-/g , "" ) ; upc = upc . replace ( /\s/g , "" ) ; if ( validate_ismn10 ( upc ) === false ) { return false ; } if ( upc . length > 8 ) { fix_matches = upc . match ( /^(\d{8})/ ) ; upc = fix_matches [ 1 ] ; } ismn13 = "9790" + upc + validate_ean13 ( "9790" + upc , true ) ; return ismn13 ; }
function ( ) { $ . ajax ( { type : 'POST' , dataType : "json" , async : true , url : '/senddata' , data : { directcmd : $ ( "#directcmd_value" ) . val ( ) } , success : function ( stuff ) { console . log ( stuff ) ; } } ) ; }
function ( ) { var i , names = [ ] , node = storage . get ( id ) ; while ( node !== null || node !== undefined ) { for ( i in node . pointers ) { commonUtil . insertIntoArray ( names , i ) ; } node = storage . get ( node . relations . baseId ) ; } return names ; }
function ( ) { var i , names = [ ] , node = storage . get ( id ) ; while ( node !== null || node !== undefined ) { for ( i in node . attributes ) { commonUtil . insertIntoArray ( names , i ) ; } node = storage . get ( node . relations . baseId ) ; } return names ; }
function ( e ) { var cdata = { author : $this . options . me , body : newComment } jQuery ( "li.comment" , jQuery ( context ) ) . before ( ich . chatterComment ( cdata ) ) ; jQuery ( ".noposts" , jQuery ( context ) ) . hide ( ) ; jQuery ( box ) . val ( "" ) ; $this . setupBlocks ( $this ) }
function destroy ( ) { if ( confirm ( 'Are you sure?' ) ) { $ ( "<form style='display:none' method='POST'></form>" ) . appendTo ( $ ( this ) . parent ( ) ) . attr ( 'action' , this . href ) . submit ( ) ; } ; return false ; }
function ( ) { delete window [ baidu . guid ] . _instances [ this . guid ] ; for ( var property in this ) { if ( ! baidu . lang . isFunction ( this [ property ] ) ) { delete this [ property ] ; } } this . disposed = true ; }
function ( ) { if ( superClass != baidu . lang . Class ) { superClass . apply ( this , arguments ) ; } else { superClass . call ( this ) ; } constructor . apply ( this , arguments ) ; }
function ( colorAliases ) { surface . filterColorAliases = colorAliases ; this . _refreshSurface ( surface ) ; }
function differentStateScene ( Shape , Surface ) { if ( ! Shape || ! Surface ) { return false ; } if ( Shape . state && Surface . filterState && Shape . state != Surface . filterState ) { return true ; } if ( Shape . scene && Surface . filterScene && Shape . scene != Surface . filterScene ) { return true ; } return false ; }
function ( ) { try { var doc = this . getDocument ( ) , surface = ( doc && doc . annotationSurface ) ; if ( surface ) { surface . destroy ( ) ; } } catch ( err ) { } dojo . forEach ( this . _cxtConns , connect . disconnect ) ; dojo . forEach ( this . _cxtSubs , connect . unsubscribe ) ; if ( doc ) { delete doc . annotationSureface ; } }
function ( editor , textarea , composer ) { this . editor = editor ; this . textarea = textarea ; this . composer = composer ; this . _observe ( ) ; }
function ( html , parse ) { if ( parse ) { html = this . parent . parse ( html ) ; } if ( this . element . value !== html ) { this . parent . fire ( 'change:textarea' ) ; this . element . value = html ; } }
function ( editor , textarea , composer ) { this . editor = editor ; this . textarea = textarea ; this . composer = composer ; this . _observe ( ) ; }
function ( html , parse ) { if ( parse ) { html = this . parent . parse ( html ) ; } if ( this . element . value !== html ) { this . element . value = html ; this . parent . fire ( 'change:textarea' ) ; } }
function fixRequirePaths ( config ) { var resourcesDir = compileConfig . dir . resources , files = wrench . readdirSyncRecursive ( resourcesDir ) ; _ . each ( files , function ( file ) { var ext = file . substring ( file . length - 3 ) ; if ( ext == '.js' ) { var f = path . join ( resourcesDir , file ) ; var newSrc = requires . makeRequiresRelative ( f , resourcesDir , config ) ; fs . writeFileSync ( f , newSrc , 'utf-8' ) ; } } ) ; }
function ( message , icon , reaskPassword ) { let strings = message . split ( '\n' ) ; this . parent ( strings [ 0 ] ) ; this . _notification = new ShellMountPasswordNotification ( this , strings , icon , reaskPassword ) ; this . _setSummaryIcon ( icon ) ; Main . messageTray . add ( this ) ; this . notify ( this . _notification ) ; }
function ( opts ) { this . _nParticles = opts . nParticles !== undefined ? opts . nParticles : 100 ; this . _particles = [ ] ; this . _spawner = null ; this . _effects = [ ] ; this . _started = false ; this . _onUpdated = null ; this . _effectsStackBuilder = new Fireworks . EffectsStackBuilder ( this ) }
function ( error , list ) { if ( error ) return next ( error ) ; self . cache . dependencies [ '/' + file . path ] = list ; self . cache . stats [ '/' + file . path ] = file . mtime ; next ( content ) ; }
function ( error , list ) { if ( error ) return callback ( error , null ) ; self . cache . dirMap = list . map ( function ( value ) { return value . slice ( modulePath . length ) ; } ) ; self . compiler . compile ( function ( error ) { if ( error ) return callback ( error ) ; build ( ) ; callback ( ) ; } ) ; }
function handleMap ( self , filepath , callback ) { filepath = path . resolve ( self . piccolo . get ( 'modules' ) , './' + filepath ) ; fs . readFile ( filepath , 'utf8' , function ( error , content ) { if ( error ) return callback ( error , null ) ; if ( content . charCodeAt ( 0 ) === 0xFEFF ) { content = content . slice ( 1 ) ; } callback ( null , content ) ; } ) ; }
function ( error , filepath ) { if ( error ) return callback ( error , null ) ; var dependencies = dependenciesList ( self , filepath , cache ) ; async . map ( dependencies , handleMap . bind ( null , self ) , callback ) ; }
function async_load ( ) { var s = document . createElement ( 'script' ) ; s . type = 'text/javascript' ; s . async = true ; s . src = '/js/' + language + '/search.js?2012-06-29T21:25:24+01:00' ; var x = document . getElementsByTagName ( 'script' ) [ 0 ] ; x . parentNode . insertBefore ( s , x ) ; }
function async_load ( ) { var s = document . createElement ( 'script' ) ; s . type = 'text/javascript' ; s . async = true ; s . src = '/js/' + language + '/search.js?2012-06-29T21:25:24+01:00' ; var x = document . getElementsByTagName ( 'script' ) [ 0 ] ; x . parentNode . insertBefore ( s , x ) ; }
function ( ) { var data = { scrollable : this . id , acceptPropagatedEvent : settings . acceptPropagatedEvent , preventDefault : settings . preventDefault , prevScrolls : [ ] } ; $ ( settings . dragSelector ) . live ( 'mousedown' , data , dragscroll . mouseDownHandler ) ; }
function ( ) { var track = rover . tracks . getByCid ( this . get ( 'trackId' ) ) ; track . trigger ( 'fetching' ) ; return track . get ( 'url' ) + '?' + $ . param ( { segment : track . get ( 'chromosome' ) } ) ; }
function ( ) { var chart = this . createScribl ( ) ; this . set ( { scribl : chart } ) ; this . set ( { chromosome : rover . getChromosome ( ) } ) ; this . center = { } ; this . center . chart = undefined ; this . right = { } ; this . right . chart = undefined ; this . left = { } ; this . left . chart = undefined ; }
function ( ) { var scribl = this . model . get ( 'scribl' ) ; var renderedContent = this . template ( $ . extend ( this . model . toJSON ( ) , { thousandGSources : rover . thousandGSources } ) ) ; $ ( this . el ) . html ( renderedContent ) ; scribl . setCanvas ( this . $ ( 'canvas' ) [ 0 ] ) ; scribl . canvas . width = rover . getWidth ( ) ; return this ; }
function ( track ) { var collection = this . collection ; var view = new BTrackView ( { model : track , collection : collection , rover : rover } ) ; this . $ ( '#rover-canvas-list' ) . append ( view . render ( ) . el ) ; }
function ( track ) { track . center . chart . set ( { features : track . left . chart . get ( 'features' ) } ) ; }
function ( track ) { track . center . chart . set ( { features : track . right . chart . get ( 'features' ) } ) ; }
function ( track ) { track . center . chart . fetch ( { data : $ . param ( { min : newMin , max : newMax } ) , error : function ( ) { alert ( 'error fetching' ) ; } } ) ; }
function ( ) { var track = rover . tracks . getByCid ( this . get ( 'trackId' ) ) ; track . trigger ( 'fetching' ) ; return track . get ( 'url' ) + '?' + $ . param ( { segment : track . get ( 'chromosome' ) } ) ; }
function ( data ) { }
function ( ) { var sel = rangy . saveSelection ( ) ; this . divChecker . innerHTML = "" ; this . divChecker . innerHTML = this . _textarea . innerHTML ; this . _textarea . innerHTML = this . divChecker . innerHTML ; if ( sel ) rangy . restoreSelection ( sel ) ; }
function ( ) { var ret = true ; if ( this . parent && this . parent . children . indexOf ( this ) < 0 ) { console . error ( "sanity 1 failed" ) ; return false ; } array . forEach ( this . children , function ( at , i ) { if ( false === ( ret = ret && at . sanityCheck ( ) ) ) return ; } ) ; return ret ; }
function ( ) { if ( this . options . fade ) { this . tip ( ) . stop ( ) . fadeOut ( function ( ) { $ ( this ) . remove ( ) ; } ) ; } else { this . tip ( ) . remove ( ) ; } }
function ( ) { if ( pvc . debug >= 3 ) { pvc . log ( "Prerendering in bulletChart" ) ; } this . bulletChartPanel = new pvc . BulletChartPanel ( this , this . basePanel , { showValues : this . options . showValues , showTooltips : this . options . showTooltips , orientation : this . options . orientation } ) ; }
function layoutChildI ( child ) { var a = child . anchor ; if ( a && a !== 'fill' ) { def . hasOwn ( aoMap , a ) || def . fail . operationInvalid ( "Unknown anchor value '{0}'" , [ a ] ) ; child . layout ( new pvc . Size ( remSize ) , childReferenceSize , childKeyArgs ) ; positionChildI ( a , child ) ; updateSide ( a , child ) ; } }
function ( legendItem ) { var scene = new pvc . visual . Scene ( rootScene , { group : legendItem . group } ) ; if ( dataPartAct ) { scene . acts . dataPart = dataPartAct ; } var labelTextLen = pvc . text . getTextLength ( legendItem . label , this . font ) ; if ( labelTextLen > maxLabelTextLen ) { maxLabelTextLen = labelTextLen ; } legendItem . labelTextLength = labelTextLen ; scene . acts . legendItem = legendItem ; }
function createSeriesScene ( seriesData1 ) { var seriesScene = new pvc . visual . Scene ( rootScene , { group : seriesData1 || data } ) ; seriesScene . acts . series = { value : seriesData1 ? seriesData1 . value : null , label : seriesData1 ? seriesData1 . label : "" } ; }
function ( keyArgs ) { this . base ( keyArgs ) ; var dotSizeGrouping = this . _dotSizeRole . grouping ; if ( dotSizeGrouping ) { this . _dotSizeDim = this . data . dimensions ( dotSizeGrouping . firstDimension . name ) ; } if ( ! this . parent ) { var colorGrouping = this . _colorRole . grouping ; if ( colorGrouping && colorGrouping . isDiscrete ( ) ) { this . legendSource = 'color' ; } else { this . options . legend = false ; } } }
function ( type ) { var color = this . delegate ( ) ; if ( color === undefined ) { var colorValue = this . scene . acts . color . value ; color = colorValue == null ? options . nullColor : colorScale ( colorValue ) ; } return color ; }
function ( type ) { var color = this . delegate ( ) ; if ( color === undefined ) { var colorValue = this . scene . acts . color . value ; color = colorValue == null ? options . nullColor : colorScale ( colorValue ) ; if ( type === 'stroke' ) { color = color . darker ( ) ; } if ( ! myself . showLines ) { color . opacity = 0.8 ; } } return color ; }
function updateTipsy ( ev ) { if ( $fakeTipTarget ) { if ( prevMouseX != null && prevMouseX === ev . clientX && prevMouseY === ev . clientY ) { return ; } prevMouseX = ev . clientX ; prevMouseY = ev . clientY ; setFakeTipTargetBounds ( getMouseBounds ( ev ) ) ; $fakeTipTarget . tipsy ( "update" ) ; } }
function showTipsy ( mark ) { if ( ! $canvas ) { initBehavior ( mark ) ; } setTarget ( pv . event . target ) ; $fakeTipTarget . attr ( 'title' , getTooltipText ( mark ) ) ; setFakeTipTargetBounds ( opts . followMouse ? getMouseBounds ( ) : getInstanceBounds ( mark ) ) ; $fakeTipTarget . tipsy ( "enter" ) ; }
function ( ) { if ( this . options . showAllTimeseries ) { this . allTimeseriesPanel = new pvc . AllTimeseriesPanel ( this , this . basePanel , { anchor : this . options . allTimeseriesPosition , allTimeseriesSize : this . options . allTimeseriesSize } ) ; } }
function ( type ) { var color = this . base ( type ) ; if ( type === 'fill' ) { if ( this . scene . acts . category . group . _isFlattenGroup ) { return pv . color ( color ) . alpha ( 0.75 ) ; } } return color ; }
function createCategScene ( ruleInfo ) { var categData1 = ruleInfo . group , categScene = new pvc . visual . Scene ( rootScene , { group : categData1 } ) ; categScene . acts . category = { value : categData1 . value , label : categData1 . label , group : categData1 } ; var value = ruleInfo . offset ; categScene . acts . value = { value : value , label : this . chart . _valueDim . format ( value ) } ; }
function ( m ) { if ( typeof console != "undefined" ) { console . log ( "[pvChart ERROR]: " + m ) ; } else { throw new Error ( "[pvChart ERROR]: " + m ) ; } }
function ( instance ) { return new Rect ( instance . left , instance . top , 10 , 10 ) ; }
function ( instance ) { var midAngle = instance . startAngle + ( instance . angle / 2 ) ; var midRadius = ( instance . outerRadius + instance . innerRadius ) / 2 ; var dotLeft = instance . left + midRadius * Math . cos ( midAngle ) ; var dotTop = instance . top + midRadius * Math . sin ( midAngle ) ; return new Point ( dotLeft , dotTop ) ; }
function ( rect ) { if ( ! rect ) { return false ; } var sides = rect . getSides ( ) ; for ( var i = 0 ; i < 4 ; i ++ ) { if ( this . intersectsLine ( sides [ i ] ) ) { return true ; } } return false ; }
function getTextLength ( text , font ) { switch ( pv . renderer ( ) ) { case 'vml' : return getTextLenVML ( text , font ) ; case 'batik' : font = splitFontCGG ( font ) ; return getTextLenCGG ( text , font . fontFamily , font . fontSize , font . fontStyle , font . fontWeight ) ; } return getTextLenSVG ( text , font ) ; }
function getFontSize ( font ) { if ( pv . renderer ( ) == 'batik' ) { var sty = document . createElementNS ( 'http://www.w3.org/2000/svg' , 'text' ) . style ; sty . setProperty ( 'font' , font ) ; return parseInt ( sty . getProperty ( 'font-size' ) , 10 ) ; } var holder = getTextSizePlaceholder ( ) ; holder . css ( 'font' , font ) ; return parseInt ( holder . css ( 'font-size' ) , 10 ) ; }
function getTextLenVML ( text , font ) { return pv . Vml . text_dims ( text , font ) . width ; }
function ( childData ) { var childScene = new pvc . visual . Scene ( rootScene , { group : childData } ) ; childScene . acts . value = { value : childData . value , label : childData . label , absLabel : childData . absLabel } ; }
function ( scene ) { var value = scene . acts . value . value ; if ( value == null ) { return false ; } var targetInstance = this . scene . target [ this . index ] ; var orthoMaxPos = targetInstance [ orthoProp ] + ( value > 0 ? targetInstance [ lengthProp ] : 0 ) ; return isMin ? ( orthoMaxPos < rOrthoBound ) : ( orthoMaxPos > rOrthoBound ) ; }
function layoutChildII ( child ) { child . layout ( new pvc . Size ( remSize ) , childReferenceSize , childKeyArgs ) ; checkChildLayout ( child ) ; positionChild . call ( this , 'fill' , child ) ; }
function calcPercent ( atom , dimName ) { var pct ; if ( group ) { pct = group . dimensions ( dimName ) . percentOverParent ( visibleKeyArgs ) ; } else { pct = data . dimensions ( dimName ) . percent ( atom . value ) ; } return chart . options . valueFormat . call ( null , Math . round ( pct * 1000 ) / 10 ) + "%" ; }
function ( val , img ) { var labels = this . labels ; var box = val . box ; if ( box . hasWidth ) { labels . close . push ( img ) ; } else { labels . line . push ( img ) ; } }
function ( e ) { if ( e . keyCode != 13 ) return ; if ( ! this . input . val ( ) . trim ( ) ) return ; window . app . Todos . create ( this . newAttributes ( ) ) ; this . input . val ( '' ) ; }
function ( index , value ) { postData . Events . push ( { PersonId : $ . tmplItem ( value ) . data . PersonId , IsVisitor : false , Events : [ { Name : 'Did not attend Group' , Date : $ ( "#text_eventDate" ) . val ( ) , GroupId : selectedGroupId } ] } ) ; }
function ( event , ui ) { $ ( "#hidden_personId" ) . val ( ui . item ? ui . item . id : "0" ) ; $ ( "#addPerson_securityRole" ) . val ( "Member" ) ; $ ( "#addPerson_securityRole" ) . prop ( 'disabled' , true ) ; }
function ( data ) { $ ( '#jqgGroupAttendance' ) . jqGrid ( { url : '/Ajax/FetchGroupAttendance' , datatype : 'json' , mtype : 'POST' , colNames : data . colNames , colModel : data . colModel , pager : $ ( '#jqgpGroupAttendance' ) , rowNum : 15 , sortname : 'Name' , sortorder : 'asc' , viewrecords : true , width : 'auto' , height : 'auto' } ) . navGrid ( '#jqgpVisitors' , { edit : false , add : false , del : false , search : false } ) ; }
function ( ) { window . location . replace ( "/Report/ContactList?RoleId=" + $ ( "#SelectedRole" ) . val ( ) ) ; }
function ( touch , event ) { var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; var start = touch . locationInView ( touch . view ( ) ) ; var diff = cc . ccpSub ( cc . ccp ( s . width / 2 , s . height / 2 ) , start ) ; diff = cc . ccpNormalize ( diff ) ; var gradient = this . getChildByTag ( 1 ) ; gradient . setVector ( diff ) ; }
function ( touch , event ) { var location = touch . locationInView ( touch . view ( ) ) ; var pos = cc . PointZero ( ) ; if ( this . _background ) { pos = this . _background . convertToWorldSpace ( cc . PointZero ( ) ) ; } this . _emitter . setPosition ( cc . ccpSub ( location , pos ) ) ; }
function ( touches , event ) { for ( var it = 0 ; it < touches . length ; it ++ ) { var touch = touches [ it ] ; if ( ! touch ) break ; var location = touch . locationInView ( touch . view ( ) ) ; this . addNewSpriteWithCoords ( location ) ; } }
function ( touches , event ) { for ( var it = 0 ; it < touches . length ; it ++ ) { var touch = touches [ it ] ; if ( ! touch ) break ; var location = touch . locationInView ( touch . view ( ) ) ; this . addNewSpriteWithCoords ( location ) ; } }
function ( touch , event ) { cc . Log ( "++++++++++++++++++++++++++++++++++++++++++++" ) ; this . _beginPos = touch . locationInView ( touch . view ( ) ) ; this . _beginPos = cc . Director . sharedDirector ( ) . convertToGL ( this . _beginPos ) ; return true ; }
function ( touch ) { var getPoint = touch . locationInView ( touch . view ( ) ) ; var myRect = this . rect ( ) ; myRect . origin . x += this . getPosition ( ) . x ; myRect . origin . y += this . getPosition ( ) . y ; return cc . Rect . CCRectContainsPoint ( myRect , getPoint ) ; }
function ( touch , event ) { cc . Assert ( this . _state == PADDLE_STATE_GRABBED , "Paddle - Unexpected state!" ) ; var touchPoint = touch . locationInView ( touch . view ( ) ) ; this . setPosition ( cc . PointMake ( touchPoint . x , this . getPosition ( ) . y ) ) ; }
function ( touches , event ) { if ( this . isMouseDown ) { if ( touches ) { this . circle . setPosition ( new cc . Point ( touches [ 0 ] . locationInView ( 0 ) . x , touches [ 0 ] . locationInView ( 0 ) . y ) ) ; } } }
function ( ) { this . _dispatchEvents = true ; this . _targetedHandlers = new Array ( ) ; this . _standardHandlers = new Array ( ) ; this . _handlersToAdd = new Array ( ) ; this . _handlersToRemove = new Array ( ) ; this . _toRemove = false ; this . _toAdd = false ; this . _toQuit = false ; this . _locked = false ; return true ; }
function ( priority , delegate ) { cc . Assert ( delegate != null , "TouchDispatcher.setPriority():Arguments is null" ) ; var handler = this . findHandler ( delegate ) ; cc . Assert ( handler != null , "TouchDispatcher.setPriority():Cant find TouchHandler" ) ; handler . setPriority ( priority ) ; this . rearrangeHandlers ( this . _targetedHandlers ) ; this . rearrangeHandlers ( this . _standardHandlers ) ; }
function ( touches , event ) { for ( var it = 0 ; it < touches . length ; it ++ ) { var touch = touches [ it ] ; if ( ! touch ) break ; var location = touch . locationInView ( touch . view ( ) ) ; this . addNewSpriteWithCoords ( location ) ; } }
function ( ) { var html = '' ; var i = 0 while ( i < 12 ) { html += '<span class="month">' + dates [ this . language ] . monthsShort [ i ++ ] + '</span>' ; } this . picker . find ( '.datepicker-months td' ) . html ( html ) ; }
function ( ) { var $this = $ ( this ) , data = $this . data ( 'datepicker' ) , options = typeof option == 'object' && option ; if ( ! data ) { $this . data ( 'datepicker' , ( data = new Datepicker ( this , $ . extend ( { } , $ . fn . datepicker . defaults , options ) ) ) ) ; } if ( typeof option == 'string' ) data [ option ] . apply ( data , args ) ; }
function ( e ) { e . preventDefault ( ) ; $ ( this ) . datepicker ( 'show' ) ; }
function hide ( ) { this . container . innerHTML = '' ; this . _removeFloater ( ) ; this . showing = false ; this . _visibleDate = null ; this . selector = null ; return this . emit ( 'hide' , this ) ; }
function ( ) { this . _restoreTileFront ( ) ; L . Util . falseFn ( this . _tileBg . offsetWidth ) ; this . _resetView ( this . _animateToCenter , this . _animateToZoom , true , true ) ; this . _mapPane . className = this . _mapPane . className . replace ( ' leaflet-zoom-anim' , '' ) ; this . _animatingZoom = false ; }
function ( ) { var filter = Ext . decode ( this . getValue ( ) ) ; if ( filter ) { filter = JSON . stringify ( filter , undefined , 8 ) ; this . edit_area . setValue ( filter ) ; this . switch_elements_visibility ( false , true , false ) this . switch_button_state ( true , false , true ) } }
function ( expected ) { var i ; for ( i = 0 ; i < this . actual . length ; ++ i ) { if ( this . actual [ i ] . isDirectory && this . actual [ i ] . name === expected ) { return true ; } } return false ; }
function ( expected ) { var i ; for ( i = 0 ; i < this . actual . length ; ++ i ) { if ( this . actual [ i ] . isFile && this . actual [ i ] . name === expected ) { return true ; } } return false ; }
function requestNativeFileSystemSuccessCB ( nfs ) { var reader = nfs . createReader ( ) ; var successCallback = function ( e ) { entries = e ; readComplete = true ; } ; var errorCallback = function ( ) { readComplete = true ; gotError = true ; } ; reader . readEntries ( successCallback , errorCallback ) ; }
function ( err ) { errorCalled = true ; error = err ; }
function ( expr ) { if ( expr instanceof PropertyExpression ) { return getCacheKey ( expr . getExpr ( ) ) + "." + expr . getIdentifierToken ( ) . getValue ( ) ; } else if ( expr instanceof LocalExpression ) { return expr . getLocal ( ) . getName ( ) . getValue ( ) ; } else if ( expr instanceof ThisExpression ) { return "this" ; } return null ; }
function ( tag , context ) { var results = context . getElementsByTagName ( tag ) ; if ( tag === "*" ) { var elem , tmp = [ ] , i = 0 ; for ( ; ( elem = results [ i ] ) ; i ++ ) { if ( elem . nodeType === 1 ) { tmp . push ( elem ) ; } } results = tmp ; } return results ; }
function ( pseudo , possibleQuote , argument , context , xml ) { var fn = Expr . pseudos [ pseudo ] || Expr . pseudos [ pseudo . toLowerCase ( ) ] ; if ( ! fn ) { Sizzle . error ( "unsupported pseudo: " + pseudo ) ; } if ( ! fn . sizzleFilter ) { return fn ; } return fn ( argument , context , xml ) ; }
function ( elem ) { var attr = elem . getAttribute ( "type" ) , type = elem . type ; return elem . nodeName . toLowerCase ( ) === "input" && "text" === type && ( attr === null || attr . toLowerCase ( ) === type ) ; }
function ( data ) { $error . show ( ) . html ( ( data && data . message ) || "There was a problem fetching the feed from this URL." ) ; $loading . removeClass ( 'NB-active' ) ; $submit . removeClass ( 'NB-disabled' ) . attr ( 'value' , 'Parse this RSS/XML Feed' ) ; }
function ( data ) { $error . show ( ) . html ( ( data && data . message ) || "There was a problem fetching the feed from this URL." ) ; $loading . removeClass ( 'NB-active' ) ; $submit . removeClass ( 'NB-disabled' ) . attr ( 'value' , 'Fetch Feed from Website' ) ; }
function update_subject_category ( current_select , option ) { current_select . val ( option ) ; var tr = current_select . parent ( "td" ) . parent ( "tr" ) ; if ( option == 1 | option == 2 ) { tr . attr ( "class" , "accepted" ) ; } else if ( option == 0 ) { tr . attr ( "class" , "" ) ; } else { tr . attr ( "class" , "denied" ) ; } }
function ( clazz , construct , superClass , name , basename ) { var superproto = superClass . prototype ; var helper = new Function ; helper . prototype = superproto ; var proto = new helper ; clazz . prototype = proto ; proto . name = proto . classname = name ; proto . basename = basename ; construct . base = clazz . superclass = superClass ; construct . self = clazz . constructor = proto . constructor = clazz ; }
function ( id ) { return 'http://a.tiles.mapbox.com/v3/' + id + '.jsonp' ; }
function ( ) { $ ( '.modal.share' ) . stop ( ) . fadeIn ( 100 ) ; }
function ( data ) { obj . data . shift ( ) ; obj . data . push ( obj . updateNextValue ( data ) ) ; obj . redraw ( ) ; }
function initChild ( self , c , elBefore ) { self . create ( ) ; var contentEl = self . getContentElement ( ) ; c = Component . create ( c , self ) ; c . __set ( "parent" , self ) ; c . set ( "render" , contentEl ) ; c . set ( "elBefore" , elBefore ) ; if ( self . get ( "rendered" ) ) { c . render ( ) ; } else { c . create ( undefined ) ; } return c ; }
function ( ) { var self = this , i , children , child ; self . get ( "view" ) . render ( ) ; children = self . get ( "children" ) ; for ( i = 0 ; i < children . length ; i ++ ) { child = children [ i ] ; child = initChild ( self , child ) ; children [ i ] = child ; child . render ( ) ; } }
function ( c , destroy ) { var children = this . get ( "children" ) , index = S . indexOf ( c , children ) ; if ( index != - 1 ) { children . splice ( index , 1 ) ; } if ( destroy && c . destroy ) { c . destroy ( ) ; } return c ; }
function ( element ) { var self = this ; self . set ( "el" , element ) ; var ui = self . get ( "decorateChildCls" ) , child = element . one ( "." + ui ) ; if ( child ) { var UI = self . findUIConstructorByNode ( child ) ; if ( UI ) { self . decorateChildrenInternal ( UI , child ) ; } else { self . decorateChildren ( child ) ; } } }
function ( childNode ) { var self = this , cls = childNode . attr ( "class" ) || "" , prefixCls = self . get ( "prefixCls" ) ; cls = cls . replace ( new RegExp ( "\\b" + prefixCls , "ig" ) , "" ) ; var UI = Manager . getConstructorByXClass ( cls ) ; if ( ! UI ) { S . log ( childNode ) ; S . log ( "can not find ui " + cls + " from this markup" ) ; } return UI ; }
function ( a , b ) { var dayDifference = ( a . _julianDayNumber - b . _julianDayNumber ) | 0 ; if ( dayDifference > 1 || dayDifference < - 1 ) { return dayDifference ; } dayDifference = ( a . _julianDayNumber - b . _julianDayNumber ) ; if ( dayDifference !== 0 ) { return dayDifference ; } return a . _secondsOfDay - b . _secondsOfDay ; }
function ( ) { var taiDate = new Date ( 'September 1, 2011 12:00:00' ) ; var taiJulianDate = JulianDate . fromDate ( taiDate , TimeStandard . TAI ) ; var utcDate = new Date ( 'September 1, 2011 11:59:26' ) ; var utcJulianDate = JulianDate . fromDate ( utcDate , TimeStandard . UTC ) ; expect ( taiJulianDate . equalsEpsilon ( utcJulianDate , CesiumMath . EPSILON20 ) ) . toEqual ( true ) ; }
function ( ) { var start = JulianDate . fromDate ( new Date ( 'July 4, 2011 12:00:00 UTC' ) ) ; var end = JulianDate . fromDate ( new Date ( 'July 5, 2011 12:01:00 UTC' ) ) ; expect ( start . getSecondsDifference ( end ) ) . toEqualEpsilon ( TimeConstants . SECONDS_PER_DAY + TimeConstants . SECONDS_PER_MINUTE , CesiumMath . EPSILON5 ) ; }
function ( ) { var original = new JulianDate ( ) ; var clone = JulianDate . fromDate ( original . toDate ( ) ) ; clone = clone . addSeconds ( 0.01 ) ; expect ( original . equalsEpsilon ( clone , CesiumMath . EPSILON1 ) ) . toEqual ( true ) ; }
function ( ) { var leapSeconds = LeapSecond . leapSeconds ; var toFind = new LeapSecond ( JulianDate . fromDate ( new Date ( 'January 1, 1973 00:00:00 UTC' ) ) , 12.0 ) ; var index = binarySearch ( leapSeconds , toFind , LeapSecond . compareLeapSecondDate ) ; expect ( LeapSecond . leapSeconds [ index ] . offset ) . toEqual ( 12.0 ) ; }
function ( ) { var leapSeconds = LeapSecond . leapSeconds ; var toFind = new LeapSecond ( JulianDate . fromDate ( new Date ( 'July 1, 1972 00:00:00 UTC' ) ) , 0.0 ) ; var index = binarySearch ( leapSeconds , toFind , LeapSecond . compareLeapSecondDate ) ; expect ( leapSeconds [ index ] . julianDate ) . toEqual ( toFind . julianDate ) ; }
function ( ) { var countHorizontal = ( this . width / this . frameW ) . toFixed ( ) ; var countVertical = ( this . height / this . frameH ) . toFixed ( ) ; for ( var height = 0 ; height < countVertical ; height ++ ) { for ( var slice = 0 ; slice < countHorizontal ; slice ++ ) { this . map . push ( { x : this . frameW * slice , y : this . frameH * height } ) ; } } }
function ( name ) { if ( this . records [ name ] === undefined ) { this . records [ name ] = { id : name } } this . records [ name ] . start = Date . now ( ) ; }
function ( ) { this . results = [ ] ; for ( var num in this . records ) { var time = cp . math . convert ( this . records [ num ] . total , 1000 , 2 ) ; var tag = this . records [ num ] . id ; this . results . push ( { name : tag , val : time } ) ; this . records [ num ] . total = 0 ; } this . display ( ) ; }
function ( ) { this . progress = this . count + ' / ' + this . total ; this . progressPercent = ( this . count / this . total ) . toFixed ( 2 ) ; if ( this . count == this . total ) { this . active = false ; this . callback ( ) ; } }
function ( val , base , round , multiply ) { if ( multiply ) { var total = val * base ; } else { var total = val / base ; } return total . toFixed ( round ) ; }
function ( ) { this . detect ( ) ; }
function ( ) { this . el . pause ( ) ; }
function ( ) { if ( this . animCur . id != - 1 ) { this . animSet . crop ( this ) ; } }
function ( channel ) { var args = [ ] . slice . call ( arguments , 1 ) , el = args [ 0 ] , file = obj . util . decamelize ( channel ) ; obj . unload ( "widgets/" + file ) ; $ ( el ) . html ( '' ) ; }
function ok ( res ) { var loc = window . location ; console . log ( 'got res: ' + JSON . stringify ( res ) ) res = JSON . parse ( res ) u . makeCookie ( res . token , res . userId ) ; jQuery ( "#result" ) . append ( "Login Successful" ) ; window . location = 'http://' + window . location . host + after ; }
function _handle_select_click ( item ) { if ( _option_box ( item ) . is ( ':visible' ) ) { item . downpour ( 'blur' ) ; } else { item . downpour ( 'focus' ) ; } }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var tmp = this . _winSizeInPoints ; if ( this . _deviceOrientation == cc . DEVICE_ORIENTATION_LANDSCAPE_LEFT || this . _deviceOrientation == cc . DEVICE_ORIENTATION_LANDSCAPE_RIGHT ) { var size = new cc . SizeZero ( ) ; size . width = tmp . height ; size . height = tmp . width ; return size ; } return tmp ; }
function ( target , selector , seconds ) { try { this . _target = target ; this . _selector = selector ; this . _elapsed = - 1 ; this . _interval = seconds || 0 ; return true ; } catch ( e ) { return false ; } }
function ( target , selector , seconds ) { if ( arguments < 2 ) throw new Error ( "timerWithTarget'argument can't is null" ) ; var timer = new cc . Timer ( ) ; if ( arguments . length == 2 ) { timer . initWithTarget ( target , selector , 0 ) ; } else { timer . initWithTarget ( target , selector , seconds ) ; } return timer ; }
function ( time1 ) { var sign = 1 ; var r = this . _rate ; if ( r % 2 == 0 ) { sign = - 1 ; } time1 *= 2 ; if ( time1 < 1 ) { this . _other . update ( 0.5 * Math . pow ( time1 , this . _rate ) ) ; } else { this . _other . update ( sign * 0.5 * ( Math . pow ( time1 - 2 , this . _rate ) + sign * 2 ) ) ; } }
function ( time ) { if ( this . _target && ! this . isDone ( ) ) { var slice = 1.0 / this . _times ; var m = time % slice ; this . _target . setIsVisible ( m > slice / 2 ? true : false ) ; } }
function ( ) { if ( cc . NODE_TRANSFORM_USING_AFFINE_MATRIX ) { this . _isTransformGLDirty = true ; this . _transformGL = 0.0 ; } this . _anchorPoint = new cc . Point ( 0 , 0 ) ; this . _anchorPointInPixels = new cc . Point ( 0 , 0 ) ; this . _contentSize = new cc . Size ( 0 , 0 ) ; this . _contentSizeInPixels = new cc . Size ( 0 , 0 ) ; }
function ( newPosition ) { this . _position = newPosition ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { this . _positionInPixels = this . _position ; } else { this . _positionInPixels = cc . ccpMult ( newPosition , cc . CONTENT_SCALE_FACTOR ( ) ) ; } this . setNodeDirty ( ) ; }
function ( point ) { if ( ! cc . Point . CCPointEqualToPoint ( point , this . _anchorPoint ) ) { this . _anchorPoint = point ; this . _anchorPointInPixels = new cc . Point ( this . _contentSizeInPixels . width * this . _anchorPoint . x , this . _contentSizeInPixels . height * this . _anchorPoint . y ) ; this . setNodeDirty ( ) ; } }
function ( cleanup ) { if ( this . _children != null ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var node = this . _children [ i ] ; if ( node ) { if ( this . _isRunning ) { node . onExit ( ) ; } if ( cleanup ) { node . cleanup ( ) ; } node . setParent ( null ) ; } } this . _children = [ ] ; } }
function ( child , doCleanup ) { if ( this . _isRunning ) { child . onExit ( ) ; } if ( doCleanup ) { child . cleanup ( ) ; } child . setParent ( null ) ; cc . ArrayRemoveObject ( this . _children , child ) ; }
function ( selector , interval ) { if ( ! interval ) interval = 0 ; cc . Assert ( selector , "Argument must be non-nil" ) ; cc . Assert ( interval >= 0 , "Argument must be positive" ) ; cc . Scheduler . sharedScheduler ( ) . scheduleSelector ( selector , this , interval , ! this . _isRunning ) ; }
function ( worldPoint ) { var ret = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { ret = cc . PointApplyAffineTransform ( worldPoint , this . worldToNodeTransform ( ) ) ; } else { ret = cc . ccpMult ( worldPoint , cc . CONTENT_SCALE_FACTOR ( ) ) ; ret = cc . PointApplyAffineTransform ( ret , this . worldToNodeTransform ( ) ) ; ret = cc . ccpMult ( ret , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } return ret ; }
function ( nodePoint ) { var ret = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { ret = cc . PointApplyAffineTransform ( nodePoint , this . nodeToWorldTransform ( ) ) ; } else { ret = cc . ccpMult ( nodePoint , cc . CONTENT_SCALE_FACTOR ( ) ) ; ret = cc . PointApplyAffineTransform ( ret , this . nodeToWorldTransform ( ) ) ; ret = cc . ccpMult ( ret , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } return ret ; }
function ( worldPoint ) { var nodePoint = this . convertToNodeSpace ( worldPoint ) ; var anchorInPoints = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { anchorInPoints = this . _anchorPointInPixels ; } else { anchorInPoints = cc . ccpMult ( this . _anchorPointInPixels , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } return cc . ccpSub ( nodePoint , anchorInPoints ) ; }
function ( nodePoint ) { var anchorInPoints = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { anchorInPoints = this . _anchorPointInPixels ; } else { anchorInPoints = cc . ccpMult ( this . _anchorPointInPixels , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } var pt = new cc . Point ( ) ; pt = cc . ccpAdd ( nodePoint , anchorInPoints ) ; return this . convertToWorldSpace ( pt ) ; }
function ( ) { this . _super ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . _isRelativeAnchorPoint = false ; var director = cc . Director . sharedDirector ( ) ; if ( ! director ) { return false ; } this . setContentSize ( director . getWinSize ( ) ) ; this . _isTouchEnabled = false ; this . _isAccelerometerEnabled = false ; }
function ( ) { this . _isRelativeAnchorPoint = false ; var director = cc . Director . sharedDirector ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . setContentSize ( director . getWinSize ( ) ) ; }
function ( dt ) { this . unschedule ( this . _setNewScene ) ; var director = cc . Director . sharedDirector ( ) ; this . _isSendCleanupToScene = director . isSendCleanupToScene ( ) ; director . replaceScene ( this . _inScene ) ; cc . TouchDispatcher . sharedDispatcher ( ) . setDispatchEvents ( true ) ; this . _outScene . setIsVisible ( true ) ; }
function ( NormalImage ) { if ( NormalImage ) { this . addChild ( NormalImage , 0 , cc . NORMAL_TAG ) ; NormalImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; NormalImage . setIsVisible ( true ) ; } if ( this . _normalImage ) { this . removeChild ( this . _normalImage , true ) ; } this . _normalImage = NormalImage ; }
function ( SelectedImage ) { if ( SelectedImage ) { this . addChild ( SelectedImage , 0 , cc . SELECTED_TAG ) ; SelectedImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; SelectedImage . setIsVisible ( false ) ; } if ( this . _selectedImage ) { this . removeChild ( this . _selectedImage , true ) ; } this . _selectedImage = SelectedImage ; }
function ( DisabledImage ) { if ( DisabledImage ) { this . addChild ( DisabledImage , 0 , cc . DISABLE_TAG ) ; DisabledImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; DisabledImage . setIsVisible ( false ) ; } if ( this . _disabledImage ) { this . removeChild ( this . _disabledImage , true ) ; } this . _disabledImage = DisabledImage ; }
function ( ) { this . _super ( ) ; if ( this . _disabledImage ) { this . _disabledImage . setIsVisible ( false ) ; } if ( this . _selectedImage ) { this . _normalImage . setIsVisible ( false ) ; this . _selectedImage . setIsVisible ( true ) ; } else { this . _normalImage . setIsVisible ( true ) ; } }
function ( ) { this . _super ( ) ; this . _normalImage . setIsVisible ( true ) ; if ( this . _selectedImage ) { this . _selectedImage . setIsVisible ( false ) ; } if ( this . _disabledImage ) { this . _disabledImage . setIsVisible ( false ) ; } }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( args ) { this . dom . id = "DomMenu" + Date . now ( ) ; this . dom . className += " domMenu" ; this . _isRelativeAnchorPoint = false ; this . setContentSize ( cc . Director . sharedDirector ( ) . getWinSize ( ) ) ; for ( var i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] ) { this . addChild ( args [ i ] ) ; } } }
function ( cleanup ) { if ( this . _usesBatchNode ) { if ( this . _children != null ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { if ( this . _children [ i ] instanceof cc . Sprite ) { this . _batchNode . removeSpriteFromAtlas ( this . _children [ i ] ) ; } } } } this . _super ( cleanup ) ; this . _hasChildren = false ; }
function ( value ) { this . _dirty = this . _recursiveDirty = value ; if ( this . _children != null ) { for ( var i in this . _children ) { if ( this . _children [ i ] instanceof cc . Sprite ) { this . _children [ i ] . setDirtyRecursively ( true ) ; } } } }
function ( newFrame ) { this . setNodeDirty ( ) ; this . _unflippedOffsetPositionFromCenter = newFrame . getOffsetInPixels ( ) ; var pNewTexture = newFrame . getTexture ( ) ; if ( pNewTexture != this . _texture ) { this . setTexture ( pNewTexture ) ; } this . _rectRotated = newFrame . isRotated ( ) ; if ( this . _rectRotated ) this . setRotation ( - 90 ) ; this . setTextureRectInPixels ( newFrame . getRectInPixels ( ) , newFrame . isRotated ( ) , newFrame . getOriginalSizeInPixels ( ) ) ; }
function ( animationName , frameIndex ) { cc . Assert ( animationName , "" ) ; var a = cc . AnimationCache . sharedAnimationCache ( ) . animationByName ( animationName ) ; cc . Assert ( a , "" ) ; var frame = a . getFrames ( ) [ frameIndex ] ; cc . Assert ( frame , "" ) ; this . setDisplayFrame ( frame ) ; }
function ( ) { if ( cc . renderContextType == cc . CANVAS ) { return cc . SpriteFrame . _frameWithTextureForCanvas ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSizeInPixels ) ; } else { return cc . SpriteFrame . create ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSizeInPixels ) ; } }
function ( spriteFrame ) { var sprite = new cc . Sprite ( ) ; if ( sprite && sprite . initWithSpriteFrame ( spriteFrame ) ) { return sprite ; } return null ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = new TestController ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( dt ) { var children = this . _batchNode . getChildren ( ) ; if ( cc . ENABLE_PROFILERS ) { cc . ProfilingBeginTimingBlock ( this . _profilingTimer ) ; } for ( var i = 0 ; i < children . length ; i ++ ) { var sprite = children [ i ] ; sprite . setIsVisible ( false ) ; } if ( cc . ENABLE_PROFILERS ) { cc . ProfilingEndTimingBlock ( this . _profilingTimer ) ; } }
function ( dt ) { var children = this . _batchNode . getChildren ( ) ; if ( cc . ENABLE_PROFILERS ) { cc . ProfilingBeginTimingBlock ( this . _profilingTimer ) ; } for ( var i = 0 ; i < children . length ; i ++ ) { var sprite = children [ i ] ; sprite . setIsVisible ( false ) ; } if ( cc . ENABLE_PROFILERS ) { cc . ProfilingEndTimingBlock ( this . _profilingTimer ) ; } }
function ( ) { this . setIsTouchEnabled ( true ) ; var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; this . addNewSpriteWithCoords ( cc . ccp ( s . width / 2 , s . height / 2 ) ) ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { document . getElementById ( 'czbox-loading' ) . style . display = 'none' ; this . parentNode . style . opacity = 1 ; }
function ( e ) { CzBox . open ( this ) ; CzBox . framework . cancelEvent ( e ) ; return false ; }
function ( e ) { if ( window . event ) { event . returnValue = false ; } else { e . preventDefault ( ) ; } }
function ( o ) { if ( ( typeof o === "number" || typeof o === "string" ) && typeof this . _hash [ o ] === "undefined" ) { this . _hash [ o ] = true ; this . _count ++ ; return true ; } return false ; }
function ( ) { expect ( 2 ) ; var member = 'a' ; var nonmember = 'b' ; var obj = new Exhibit . Set ( [ member ] ) ; ok ( obj . contains ( member ) , "Exhibit.Set(['a']).contains('a')" ) ; ok ( ! obj . contains ( nonmember ) , "Exhibit.Set(['a']).contains('b')" ) ; }
function toggleAnonymous ( e ) { if ( e ) { $ ( '#comment-username' ) . text ( "Anónimo" ) ; $ ( '#comment-programName' ) . text ( "..." ) ; $ ( '.comment-photo>img' ) . attr ( 'src' , anonymousImagePath ) ; } else { $ ( '#comment-username' ) . text ( userName ) ; $ ( '#comment-programName' ) . text ( userProgram ) ; $ ( '.comment-photo>img' ) . attr ( 'src' , userImagePath ) ; } }
function ( e ) { if ( ! self . drawReady ) return ; var v = self . _touchCapture ( e ) . xy2val ( self . dx , self . dy ) ; if ( v == this . newValue ) return ; if ( self . changeHook && ( self . changeHook ( v ) === false ) ) return ; self . change ( v ) ; self . drawReady = false ; }
function ( e ) { if ( ! self . drawReady ) return ; var v = self . xy2val ( e . pageX , e . pageY ) ; if ( v == self . newValue ) return ; if ( self . changeHook && ( self . changeHook ( v ) === false ) ) return ; self . change ( v ) ; self . drawReady = false ; }
function ( ) { var regex = new RegExp ( chrome . extension . getURL ( this . application . ninja . currentDocument . model . views . design . iframe . src . split ( chrome . extension . getURL ( '/' ) ) [ 1 ] ) . replace ( /\//gi , '\\\/' ) , 'gi' ) ; return regex ; }
function ( ) { if ( this . children . is_empty ( ) ) return ; var effects = this . options . effects ; if ( effects . initial ) { effects = Ergo . override ( { } , effects , effects . initial ) ; delete this . options . effects . initial ; } return $ . when ( this . el [ effects . show ] ( effects . delay ) ) ; }
function ( fill ) { svgCanvas . createLayer ( "background" ) cur_shape = svgCanvas . addSvgElementFromJson ( { "element" : "rect" , "attr" : { "x" : 0 , "y" : 0 , "width" : res . w , "height" : res . h , "stroke" : "none" , "id" : "canvas_background" , "opacity" : 1 , "fill" : fill || $ . pref ( 'bkgd_color' ) , "style" : "pointer-events:none" } } ) ; svgCanvas . setCurrentLayer ( "Layer 1" ) svgCanvas . setCurrentLayerPosition ( "1" ) }
function ( fill ) { svgCanvas . createLayer ( "background" ) cur_shape = svgCanvas . addSvgElementFromJson ( { "element" : "rect" , "attr" : { "x" : 0 , "y" : 0 , "width" : res . w , "height" : res . h , "stroke" : "none" , "id" : "canvas_background" , "opacity" : 1 , "fill" : fill || $ . pref ( 'bkgd_color' ) , "style" : "pointer-events:none" } } ) ; svgCanvas . setCurrentLayer ( "Layer 1" ) svgCanvas . setCurrentLayerPosition ( "1" ) }
function ( err , msg ) { if ( err ) { nodeca . logger . error ( 'Failed apiTree call' , err ) ; return ; } History . pushState ( null , msg . data . head . title , href ) ; nodeca . render ( match . meta , msg . data ) ; }
function ( ) { try { return ns . nanoTime ( ) / 1e6 ; } catch ( e ) { ns = new applet . Packages . nano ; return ns . nanoTime ( ) / 1e6 ; } }
function ( ) { var uuids = MobDeals . Account . _getUuids ( ) ; data = { platform : MobDeals . Habitat . platform , adcolony_udid : window . loot_native . getAdColonyDeviceId ( ) , android_id : uuids [ 'android_id' ] , android_serial_number : uuids [ 'android_id' ] , android_telephony_id : uuids [ 'android_telephony_id' ] , mac_address : uuids [ 'mac_address' ] } ; MobDeals . Account . _registerDevice ( data ) ; }
function ( options ) { options = options || { } ; this . directory = options . directory || '.' ; this . functions = { 'print' : console . log . bind ( console ) } ; }
function ( block ) { var scanner = this . scanner ; this . parsePrefix ( block ) ; while ( scanner . next === 'asterisk' || scanner . next === 'slash' || scanner . next === 'percent' ) { var operation = ( scanner . next === 'asterisk' ) ? 'multiply' : ( ( scanner . next === 'slash' ) ? 'divide' : 'remainder' ) ; scanner . advance ( ) ; this . writeOperation ( block , operation , 2 ) ; } }
function ( block , blockKind ) { var scanner = this . scanner ; var childBlock = newBlock ( this . blocks , block . level + 1 , blockKind ) ; block . children = block . children || [ ] ; block . children . unshift ( childBlock ) ; childBlock . parent = block ; this . parseBlock ( childBlock , null , false ) ; }
function ( block , code ) { var start = this . variables . pop ( ) ; var end = this . variables . pop ( ) ; return this . loopStatement ( block , start - 1 , end , true , '--' , '>=' ) ; }
function ( block , start , end , unshift , increment , compare ) { increment = increment || '++' ; var id = '__i' ; var childBlock = block . children . shift ( ) ; compare = compare || '<' ; if ( unshift ) { childBlock . codes . unshift ( { type : 'pushVariable' , variable : id } ) ; } return 'for (var ' + id + ' = ' + start + '; ' + id + compare + end + '; ' + id + increment + ')' + this . addJSBlock ( childBlock ) ; }
function ( ) { that . add ( new Bullet ( { x : x , y : y , speed : speed , angle : angle + 180 , image : image , owner : that . enemy , life : 10000 } ) ) ; }
function tabTrigger ( ) { var imgs = $ ( ".slide-main .yui3-tabs-panel" ) ; var selected = $ ( ".slide-main .yui3-tabs-panel-selected" ) ; var index = imgs . index ( selected ) ; if ( ++ index >= imgs . length - 1 ) { index = 0 ; } triggerImg ( index ) ; }
function triggerImg ( index ) { var tabs = $ ( ".slide-side .yui3-tabs-trigger" ) ; tabs . removeClass ( ".slide-side yui3-tabs-trigger-selected" ) ; var tab = tabs . eq ( index ) ; tab . addClass ( "yui3-tabs-trigger-selected" ) ; $ ( ".slide-main .yui3-tabs-panel-selected" ) . fadeOut ( ) ; var imgs = $ ( ".slide-main .yui3-tabs-panel" ) ; imgs . removeClass ( "yui3-tabs-panel-selected" ) ; var img = imgs . eq ( index ) ; img . addClass ( "yui3-tabs-panel-selected" ) ; $ ( ".slide-main .yui3-tabs-panel-selected" ) . fadeIn ( ) ; }
function ( ) { if ( this . _stack ) { return this . _stack ; } else if ( this . sourceId ) { return this . toString ( ) + '\nat ' + getErrorMessage ( this ) ; } return this . toString ( ) + '\nat unknown' ; }
function ( data ) { this . instance . data = $ . extend ( this . config . get ( "data" ) , data || { } ) ; this . jxhrInstance = $ . ajax ( this . instance ) ; }
function ( num ) { $j ( '.previous' ) . removeClass ( 'previous' ) ; $j ( '.current' ) . addClass ( 'previous' ) ; $j ( '.current' ) . removeClass ( 'current' ) ; $j ( '.thumb[data-index="' + num + '"]' ) . addClass ( 'current' ) ; $j ( '#scroll .image-container[data-index="' + num + '"]' ) . addClass ( 'current' ) ; }
function ( pos , time ) { $j ( '#scroll .image-container.previous' ) . animate ( { opacity : 0.25 } , 200 , function ( ) { } ) ; $j ( '#scroll' ) . animate ( { left : pos } , time , function ( ) { $j ( '#scroll .image-container.current' ) . animate ( { opacity : 1 } , 200 , function ( ) { } ) ; } ) ; }
function ( dv ) { var agentId = dv . model . get ( "id" ) ; var matchingAgents = self . collection . where ( { id : agentId } ) ; if ( matchingAgents . length == 1 ) { dv . model = matchingAgents [ 0 ] ; } dv . render ( $ ( 'ul' , self . el ) ) ; dv . delegateEvents ( ) ; }
function ( value ) { var panelPane = FirebugChrome . $ ( "fbPanelPane" ) ; var newOrient = value ? "vertical" : "horizontal" ; if ( panelPane . orient == newOrient ) return ; panelSplitter . orient = panelPane . orient = newOrient ; }
function ( context , event ) { if ( event . target . id != "cmd_toggleBreakOn" ) return ; if ( ! context ) { if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext with no context??" ) ; return ; } var panel = panelBar1 . selectedPanel ; if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext for panel " + ( panel ? panel . name : "NO panel" ) , panel ) ; if ( panel && panel . breakable ) Firebug . Breakpoint . toggleBreakOnNext ( panel ) ; }
function getBrowserDocument ( ) { return Firebug . chrome . inDetachedScope ? Firebug . chrome . originalBrowser . ownerDocument : top . document ; }
function ( context , cancelReport ) { var totalTime = FBS . stopProfiling ( ) ; if ( totalTime == - 1 ) return ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleProfiling" , "checked" , "false" ) ; if ( cancelReport ) delete context . profileRow ; else this . logProfileReport ( context , cancelReport ) ; Firebug . Console . removeListener ( this ) ; }
function ( context , fullName , url ) { try { Services . scriptloader . loadSubScript ( url , context ) ; } catch ( err ) { Cu . reportError ( fullName + " -> " + url ) ; Cu . reportError ( err ) ; } }
function ( target , panel , value , textSize ) { this . target = target ; this . panel = panel ; this . panel . panelNode . appendChild ( this . box ) ; this . input . value = value ; this . input . focus ( ) ; var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , true ) ; }
function ( ) { var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , false ) ; if ( this . box . parentNode == this . panel . panelNode ) this . panel . panelNode . removeChild ( this . box ) ; delete this . target ; delete this . panel ; delete this . styleSheet ; }
function ( ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; var menuitem = Firebug . chrome . $ ( "menu_" + this . getEditorOptionKey ( ) + mode ) ; var command = Firebug . chrome . $ ( "cmd_toggle" + this . getEditorOptionKey ( ) ) ; command . setAttribute ( "label" , menuitem . label ) ; command . setAttribute ( "tooltiptext" , menuitem . tooltipText ) ; }
function ( popup ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; for ( var child = popup . firstChild ; child ; child = child . nextSibling ) { if ( child . localName == "menuitem" ) { if ( child . id == "menu_" + this . getEditorOptionKey ( ) + mode ) child . setAttribute ( "checked" , true ) ; else child . removeAttribute ( "checked" ) ; } } }
function ( ) { var command = Firebug . chrome . $ ( "cmd_toggleHTMLEditing" ) ; command . setAttribute ( "checked" , false ) ; this . panel . panelNode . removeChild ( this . box ) ; delete this . editingParent ; delete this . editingRange ; delete this . originalLocalName ; delete this . target ; delete this . panel ; }
function ( panel ) { var breakable = Firebug . chrome . getGlobalAttribute ( "cmd_toggleBreakOn" , "breakable" ) ; var armed = ( breakable == "false" ) ; var tooltip = panel . getBreakOnNextTooltip ( armed ) ; if ( ! tooltip ) tooltip = "" ; if ( breakable == "disabled" ) tooltip += " " + Locale . $STR ( "firebug.bon.scriptPanelNeeded" ) ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleBreakOn" , "tooltiptext" , tooltip ) ; }
function ( script , context , frame ) { if ( frame ) { var name = frame . name ; var args = StackFrame . getFunctionArgValues ( frame ) ; } else { var name = script . functionName ; var args = [ ] ; } if ( name == "anonymous" ) { name = StackFrame . guessFunctionName ( this . sourceFile . href , this . getBaseLineNumberByScript ( script ) , context ) ; } return { name : name , args : args } ; }
function ( expression ) { if ( FBTrace . DBG_WATCH ) FBTrace . sysout ( "Firebug.WatchPanel.addWatch; expression: " + expression ) ; if ( ! this . watches ) this . watches = [ ] ; for ( var i = 0 ; i < this . watches . length ; i ++ ) { if ( expression == this . watches [ i ] ) return ; } this . watches . splice ( 0 , 0 , expression ) ; this . rebuild ( true ) ; }
function ( file ) { var text = "" ; if ( file . responseStatus ) text += file . responseStatus + " " ; if ( file . responseStatusText ) text += file . responseStatusText ; return text ? Str . cropString ( text ) : " " ; }
function ( row ) { var chrome = FW . Firebug . chrome ; var doc = chrome . window . document ; FBTest . clickToolbarButton ( chrome , "fbConsoleClear" ) ; var button = doc . getElementById ( "cmd_toggleProfiling" ) ; FBTest . ok ( ! button . checked , "'Profile' button must not be pressed when 'Clear' button was pressed" ) ; callback ( ) ; }
function ( row ) { FBTest . executeCommand ( "console.clear()" ) ; var doc = FW . Firebug . chrome . window . document ; var button = doc . getElementById ( "cmd_toggleProfiling" ) ; FBTest . ok ( ! button . checked , "'Profile' button must not be pressed when 'console.clear()' was executed" ) ; callback ( ) ; }
function ( row ) { var chrome = FW . Firebug . chrome ; var doc = chrome . window . document ; FBTest . clickToolbarButton ( chrome , "fbConsoleClear" ) ; var button = doc . getElementById ( "cmd_toggleMemoryProfiling" ) ; FBTest . ok ( ! button . checked , "'Memory Profile' button must not be pressed when 'Clear' button was pressed" ) ; callback ( ) ; }
function ( row ) { FBTest . executeCommand ( "console.clear()" ) ; var doc = FW . Firebug . chrome . window . document ; var button = doc . getElementById ( "cmd_toggleMemoryProfiling" ) ; FBTest . ok ( ! button . checked , "'Memory Profile' button must not be pressed when 'console.clear()' was executed" ) ; callback ( ) ; }
function ( browser ) { var annotation = "firebugged.showFirebug" ; this . setPageAnnotation ( browser . currentURI . spec , annotation ) ; }
function ( object , panelName , sidePanelName , forceUpdate ) { if ( FBTrace . DBG_PANELS ) FBTrace . sysout ( "chrome.select object:" + object + " panelName:" + panelName + " sidePanelName:" + sidePanelName + " forceUpdate:" + forceUpdate + "\n" ) ; var bestPanelName = getBestPanelName ( object , Firebug . currentContext , panelName ) ; var panel = this . selectPanel ( bestPanelName , sidePanelName , true ) ; if ( panel ) panel . select ( object , forceUpdate ) ; this . syncLocationList ( ) ; }
function ( value ) { var panelPane = FirebugChrome . $ ( "fbPanelPane" ) ; var newOrient = value ? "vertical" : "horizontal" ; if ( panelPane . orient == newOrient ) return ; panelSplitter . orient = panelPane . orient = newOrient ; }
function ( context , event ) { if ( event . target . id != "cmd_toggleBreakOn" ) return ; if ( ! context ) { if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext with no context??" ) ; return ; } var panel = panelBar1 . selectedPanel ; if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext for panel " + ( panel ? panel . name : "NO panel" ) , panel ) ; if ( panel && panel . breakable ) Firebug . Breakpoint . toggleBreakOnNext ( panel ) ; }
function getBrowserDocument ( ) { return Firebug . chrome . inDetachedScope ? Firebug . chrome . originalBrowser . ownerDocument : top . document ; }
function ( panelType , enable ) { if ( ! enable ) { var self = this ; Firebug . connection . eachContext ( function ( context ) { context . destroyPanel ( panelType , context . persistedState ) ; } ) ; } panelType . prototype . onActivationChanged ( enable ) ; Firebug . chrome . syncPanel ( ) ; }
function ( context ) { var panel = Firebug . chrome . getSelectedPanel ( ) ; if ( panel && panel . name == "console" ) return ; if ( FBTrace . DBG_COMMANDLINE ) FBTrace . sysout ( "commandLine.Popup.toggle;" ) ; var newState = ! this . isVisible ( ) ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleCommandPopup" , "checked" , newState ) ; Firebug . Options . set ( "alwaysShowCommandLine" , newState ) ; this . updateVisibility ( newState ) ; this . reattach ( context ) ; this . showPopupPanel ( context ) ; }
function ( ) { var fbStatus = Firefox . getElementById ( 'firebugStatus' ) ; if ( fbStatus ) { if ( Firebug . Errors . watchForErrors ) fbStatus . setAttribute ( "console" , "on" ) ; else fbStatus . removeAttribute ( "console" ) ; } else { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "console.setStatus ERROR no firebugStatus element" ) ; } }
function ( state ) { if ( FBTrace . DBG_CONSOLE ) FBTrace . sysout ( "Console.panel show; wasScrolledToBottom: " + ( state ? state . wasScrolledToBottom : "no prev state" ) + " " + this . context . getName ( ) , state ) ; this . showCommandLine ( true ) ; this . showToolbarButtons ( "fbConsoleButtons" , true ) ; this . setFilter ( Firebug . consoleFilterTypes ) ; Firebug . chrome . setGlobalAttribute ( "cmd_togglePersistConsole" , "checked" , this . persistContent ) ; this . showPanel ( state ) ; }
function getExceptionContext ( context , object ) { var errorWin = getErrorWindow ( object ) if ( errorWin ) { var errorContext = Firebug . connection . getContextByWindow ( errorWin ) ; if ( FBTrace . DBG_ERRORLOG ) { FBTrace . sysout ( "errors.observe exception context: " + ( errorContext ? errorContext . getName ( ) : "none" ) + " errorWin: " + Win . safeGetWindowLocation ( errorWin ) ) ; } if ( errorContext ) return errorContext ; } return context ; }
function ( context ) { var panel = Firebug . chrome . getSelectedPanel ( ) ; if ( panel && panel . name == "console" ) return ; if ( FBTrace . DBG_COMMANDLINE ) FBTrace . sysout ( "commandLine.Popup.toggle;" ) ; var newState = ! this . isVisible ( ) ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleCommandPopup" , "checked" , newState ) ; Firebug . Options . set ( "alwaysShowCommandLine" , newState ) ; this . updateVisibility ( newState ) ; this . reattach ( context ) ; this . showPopupPanel ( context ) ; }
function ( context , cancelReport ) { var totalTime = FBS . stopProfiling ( ) ; if ( totalTime == - 1 ) return ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleProfiling" , "checked" , "false" ) ; if ( cancelReport ) delete context . profileRow ; else this . logProfileReport ( context , cancelReport ) ; Firebug . Console . removeListener ( this ) ; }
function ( result , context ) { if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onEvaluateSucceeds; " + result , result ) ; if ( ! result ) return ; context . breakingCause = { title : Locale . $STR ( "firecookie.Break On Cookie" ) , message : Str . cropString ( unescape ( this . name + "; " + this . condition + "; " ) , 200 ) } ; }
function ( result , context ) { if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onEvaluateFails; " + result , result ) ; context . breakingCause = { title : Locale . $STR ( "firecookie.Break On Cookie" ) , message : Locale . $STR ( "firecookie.Breakpoint condition evaluation fails" ) , prevValue : this . condition , newValue : result } ; }
function ( context ) { if ( Firebug . CookieModule . isAlwaysEnabled ( ) ) TabWatcher . iterateContexts ( Firebug . CookieModule . registerObservers ) ; top . document . getElementById ( "firebugStatus" ) . setAttribute ( panelName , "on" ) ; if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onResumeFirebug" ) ; }
function ( context ) { var params = { blockVisible : true , sessionVisible : true , allowVisible : true , prefilledHost : "" , permissionType : "cookie" , windowTitle : Locale . $STR ( "firecookie.ExceptionsTitle" ) , introText : Locale . $STR ( "firecookie.Intro" ) } ; parent . openDialog ( "chrome://browser/content/preferences/permissions.xul" , "_blank" , "chrome,resizable=yes" , params ) ; }
function ( infoBox , file ) { var sentCookiesHeader = this . findHeader ( file . requestHeaders , "Cookie" ) ; var receivedCookiesHeader = this . findHeader ( file . responseHeaders , "Set-Cookie" ) ; if ( sentCookiesHeader || receivedCookiesHeader ) Firebug . NetMonitor . NetInfoBody . appendTab ( infoBox , "Cookies" , Locale . $STR ( "firecookie.Panel" ) ) ; }
function ( aSubject , aTopic , aData ) { if ( aTopic != "perm-changed" ) return ; if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.observe: " + aTopic + ", " + aData ) ; var fn = CookiePermissions . updatePermButton ; TabWatcher . iterateContexts ( fn ) ; }
function ( context ) { return [ MenuUtils . optionAllowGlobally ( context , "firecookie.AllowGlobally" , networkPrefDomain , cookieBehaviorPref ) , MenuUtils . optionMenu ( context , "cookies.LogEvents" , Firebug . prefDomain , logEventsPref ) , MenuUtils . optionMenu ( context , "firecookie.Confirm cookie removal" , Firebug . prefDomain , removeConfirmation ) ] ; }
function ( cookie ) { var limit = 200 ; var value = cookie . cookie . value ; if ( value . length > limit ) return Str . escapeNewLines ( value . substr ( 0 , limit ) + "..." ) ; else return Str . escapeNewLines ( value ) ; }
function ( cookie ) { if ( cookie . cookie . expires == undefined ) return "" ; if ( cookie . cookie . expires == 0 ) return " " + Locale . $STR ( "firecookie.Session" ) ; try { var date = new Date ( cookie . cookie . expires * 1000 ) ; return date . toLocaleString ( ) ; } catch ( err ) { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "cookies.CookieRow.getExpires; EXCEPTION " + err , err ) ; } return "" ; }
function ( clickedCookie ) { var text = "" ; var tbody = Dom . getAncestorByClass ( clickedCookie . row , "cookieTable" ) . firstChild ; for ( var row = tbody . firstChild ; row ; row = row . nextSibling ) { if ( Css . hasClass ( row , "cookieRow" ) && row . repObject ) text += row . repObject . toString ( ) + "\n" ; } copyToClipboard ( text ) ; }
function ( cookie ) { if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onClearValue;" , cookie ) ; var newCookie = new Firebug . CookieModule . Cookie ( cookie . cookie ) ; newCookie . cookie . rawValue = "" ; Firebug . CookieModule . createCookie ( newCookie ) ; }
function ( cookieEvent ) { switch ( cookieEvent . action ) { case "deleted" : return Locale . $STR ( "firecookie.console.deleted" ) ; case "added" : return Locale . $STR ( "firecookie.console.added" ) ; case "changed" : return Locale . $STR ( "firecookie.console.changed" ) ; case "cleared" : return Locale . $STR ( "firecookie.console.cleared" ) ; } return "" ; }
function ( event ) { if ( ! Events . isLeftClick ( event ) ) return ; var target = event . target ; if ( ! Css . hasClass ( target , "cookieHeaderCellBox" ) ) return ; var header = Dom . getAncestorByClass ( target , "cookieHeaderRow" ) ; if ( ! header ) return ; this . onStartResizing ( event ) ; Events . cancelEvent ( event ) ; }
function ( context , label , domain , option ) { var value = Options . get ( option ) == 0 ; return { label : Locale . $STR ( label ) , nol10n : true , type : "checkbox" , checked : value , command : Obj . bindFixed ( this . onAllowCookie , this , domain , option ) } }
function ( state ) { if ( this . context . loaded ) { var state ; Persist . restoreObjects ( this , state ) ; if ( state ) { if ( state . scrollTop ) this . panelNode . scrollTop = state . scrollTop ; if ( state . groupOpened ) this . groupOpened = state . groupOpened ; if ( state . styleOpened ) this . styleOpened = state . styleOpened ; } } if ( this . selection ) this . refresh ( ) ; }
function ( name , value ) { var options = [ "showUserAgentCSS" , "computedStylesDisplay" , "colorDisplay" , "showMozillaSpecificStyles" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . refresh ( ) ; }
function ( context , win ) { var doc = win . document ; this . cleanupSheetListener = Obj . bind ( this . cleanupSheetHandler , this , context ) ; context . addEventListener ( doc , "DOMAttrModified" , this . cleanupSheetListener , false ) ; context . addEventListener ( doc , "DOMNodeInserted" , this . cleanupSheetListener , false ) ; }
function ( context , win ) { var doc = win . document ; if ( this . cleanupSheetListener ) { context . removeEventListener ( doc , "DOMAttrModified" , this . cleanupSheetListener , false ) ; context . removeEventListener ( doc , "DOMNodeInserted" , this . cleanupSheetListener , false ) ; } }
function ( ) { this . onMouseDown = Obj . bind ( this . onMouseDown , this ) ; this . onClick = Obj . bind ( this . onClick , this ) ; Firebug . Panel . initialize . apply ( this , arguments ) ; }
function ( state ) { state . scrollTop = this . panelNode . scrollTop ? this . panelNode . scrollTop : this . lastScrollTop ; Persist . persistObjects ( this , state ) ; this . stopEditing ( ) ; Firebug . Panel . destroy . apply ( this , arguments ) ; }
function ( oldPanelNode ) { Events . addEventListener ( this . panelNode , "mousedown" , this . onMouseDown , false ) ; Events . addEventListener ( this . panelNode , "click" , this . onClick , false ) ; Firebug . Panel . initializeNode . apply ( this , arguments ) ; }
function ( ) { Events . removeEventListener ( this . panelNode , "mousedown" , this . onMouseDown , false ) ; Events . removeEventListener ( this . panelNode , "click" , this . onClick , false ) ; Firebug . Panel . destroyNode . apply ( this , arguments ) ; }
function ( target , panel , value , textSize ) { this . target = target ; this . panel = panel ; this . panel . panelNode . appendChild ( this . box ) ; this . input . value = value ; this . input . focus ( ) ; var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , true ) ; }
function ( ) { var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , false ) ; if ( this . box . parentNode == this . panel . panelNode ) this . panel . panelNode . removeChild ( this . box ) ; delete this . target ; delete this . panel ; delete this . styleSheet ; }
function ( element , sections , usedProps ) { var parent = element . parentNode ; if ( parent && parent . nodeType == 1 ) { this . getInheritedRules ( parent , sections , usedProps ) ; var rules = [ ] ; this . getElementRules ( parent , rules , usedProps , true ) ; if ( rules . length ) sections . splice ( 0 , 0 , { element : parent , rules : rules } ) ; } }
function ( ) { this . onMouseDown = Obj . bind ( this . onMouseDown , this ) ; this . onClick = Obj . bind ( this . onClick , this ) ; this . onStateChange = Obj . bindFixed ( this . contentStateCheck , this ) ; this . onHoverChange = Obj . bindFixed ( this . contentStateCheck , this , STATE_HOVER ) ; this . onActiveChange = Obj . bindFixed ( this . contentStateCheck , this , STATE_ACTIVE ) ; Firebug . Panel . initialize . apply ( this , arguments ) ; }
function ( context , win ) { if ( Dom . domUtils ) { var doc = win . document ; context . addEventListener ( doc , "mouseover" , this . onHoverChange , false ) ; context . addEventListener ( doc , "mousedown" , this . onActiveChange , false ) ; } }
function ( context , win ) { var doc = win . document ; context . removeEventListener ( doc , "mouseover" , this . onHoverChange , false ) ; context . removeEventListener ( doc , "mousedown" , this . onActiveChange , false ) ; if ( Dom . isAncestor ( this . stateChangeEl , doc ) ) { this . removeStateChangeHandlers ( ) ; } }
function ( element ) { if ( ! ( element instanceof window . Element ) ) return ; var sothinkInstalled = ! ! Firefox . getElementById ( "swfcatcherKey_sidebar" ) ; if ( sothinkInstalled ) { var div = FirebugReps . Warning . tag . replace ( { object : "SothinkWarning" } , this . panelNode ) ; div . innerHTML = Locale . $STR ( "SothinkWarning" ) ; return ; } if ( ! element ) return ; this . updateView ( element ) ; }
function ( state ) { if ( FBTrace . DBG_CONSOLE ) FBTrace . sysout ( "Console.panel show; wasScrolledToBottom: " + ( state ? state . wasScrolledToBottom : "no prev state" ) + " " + this . context . getName ( ) , state ) ; this . showCommandLine ( true ) ; this . showToolbarButtons ( "fbConsoleButtons" , true ) ; this . setFilter ( Firebug . consoleFilterTypes ) ; Firebug . chrome . setGlobalAttribute ( "cmd_togglePersistConsole" , "checked" , this . persistContent ) ; this . showPanel ( state ) ; }
function ( name , value ) { var options = [ "showUserProps" , "showUserFuncs" , "showDOMProps" , "showDOMFuncs" , "showDOMConstants" , "showInlineEventHandlers" , "showOwnProperties" , "showEnumerableProperties" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . rebuild ( true ) ; }
function ( ) { if ( ! this . autoCompleter ) { this . autoCompleter = new Firebug . AutoCompleter ( false , Obj . bind ( this . getAutoCompleteRange , this ) , Obj . bind ( this . getAutoCompleteList , this ) , Obj . bind ( this . getAutoCompletePropSeparator , this ) ) ; } return this . autoCompleter ; }
function ( context , textBox , cycle ) { if ( ! textBox . value && ! cycle ) { return false ; } var offset = textBox . selectionStart ; var found = this . pickCandidates ( textBox , context , cycle ) ; if ( ! found ) this . reset ( ) ; return found ; }
function ( ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; var menuitem = Firebug . chrome . $ ( "menu_" + this . getEditorOptionKey ( ) + mode ) ; var command = Firebug . chrome . $ ( "cmd_toggle" + this . getEditorOptionKey ( ) ) ; command . setAttribute ( "label" , menuitem . label ) ; command . setAttribute ( "tooltiptext" , menuitem . tooltipText ) ; }
function ( popup ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; for ( var child = popup . firstChild ; child ; child = child . nextSibling ) { if ( child . localName == "menuitem" ) { if ( child . id == "menu_" + this . getEditorOptionKey ( ) + mode ) child . setAttribute ( "checked" , true ) ; else child . removeAttribute ( "checked" ) ; } } }
function addListeners ( win ) { var doc = win . document ; if ( doc . location == "about:blank" ) return ; Events . addEventListener ( doc , "DOMAttrModified" , self . onMutateAttr , false ) ; Events . addEventListener ( doc , "DOMCharacterDataModified" , self . onMutateText , false ) ; Events . addEventListener ( doc , "DOMNodeInserted" , self . onMutateNode , false ) ; Events . addEventListener ( doc , "DOMNodeRemoved" , self . onMutateNode , false ) ; }
function ( event ) { Events . cancelEvent ( event ) ; var bpPanel = Firebug . getElementPanel ( event . target ) ; var context = bpPanel . context ; if ( Css . hasClass ( event . target , "closeButton" ) ) { var row = Dom . getAncestorByClass ( event . target , "breakpointRow" ) ; context . mutationBreakpoints . removeBreakpoint ( row . repObject ) ; bpPanel . refresh ( ) ; } }
function ( panel , armed ) { var breakable = armed ? "false" : "true" ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleBreakOn" , "breakable" , breakable ) ; }
function ( sourceBox , viewRange ) { try { this . updateViewportCache ( sourceBox , viewRange ) ; } catch ( exc ) { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "buildViewAround updateViewportCache FAILS " + exc , exc ) ; } Dom . collapse ( sourceBox , false ) ; this . setViewportPadding ( sourceBox , viewRange ) ; sourceBox . centralLine = Math . floor ( ( viewRange . lastLine + viewRange . firstLine ) / 2 ) ; this . applyDecorator ( sourceBox ) ; return ; }
function ( script , context , frame ) { if ( frame ) { var name = frame . name ; var args = StackFrame . getFunctionArgValues ( frame ) ; } else { var name = script . functionName ; var args = [ ] ; } if ( name == "anonymous" ) { name = StackFrame . guessFunctionName ( this . sourceFile . href , this . getBaseLineNumberByScript ( script ) , context ) ; } return { name : name , args : args } ; }
function ( url , line , context ) { var sourceFile = context . sourceFileMap [ url ] ; if ( sourceFile ) { var scripts = sourceFile . getScriptsAtLineNumber ( line ) ; if ( scripts ) { var script = scripts [ 0 ] ; var analyzer = sourceFile . getScriptAnalyzer ( script ) ; line = analyzer . getBaseLineNumberByScript ( script ) ; } } return StackFrame . guessFunctionName ( url , line - 1 , context ) ; }
function ( expression ) { if ( FBTrace . DBG_WATCH ) FBTrace . sysout ( "Firebug.WatchPanel.addWatch; expression: " + expression ) ; if ( ! this . watches ) this . watches = [ ] ; for ( var i = 0 ; i < this . watches . length ; i ++ ) { if ( expression == this . watches [ i ] ) return ; } this . watches . splice ( 0 , 0 , expression ) ; this . rebuild ( true ) ; }
function ( element , html ) { var doc = element . ownerDocument ; var range = doc . createRange ( ) ; range . selectNode ( element || doc . documentElement ) ; try { var fragment = range . createContextualFragment ( html ) ; var first = fragment . firstChild ; var last = fragment . lastChild ; element . parentNode . replaceChild ( fragment , element ) ; return [ first , last ] ; } catch ( e ) { return [ element , element ] } }
function ( expression , context ) { var valueType = Container . getTypeName ( expression . value ) ; context . value = this . provider . fieldConverter . toDb [ Container . resolveName ( Container . resolveType ( valueType ) ) ] ( expression . value ) ; }
function flip ( player ) { if ( "ownGravity" in player ) { delete player . ownGravity ; } else { player . ownGravity = - WebSplat . conf . gravity ; } WebSplat . conf . jumpSpeed = - WebSplat . conf . jumpSpeed ; }
function reifySymbol ( sexpr ) { var value ; if ( value = sexpr . value . match ( INTEGER ) ) { return Data . Number ( Number ( value [ 0 ] ) ) ; } if ( value = sexpr . value . match ( FLOAT ) ) { return Data . Number ( Number ( value [ 0 ] ) ) ; } if ( sexpr . value . length > 0 ) { return Data . Symbol ( sexpr . value ) ; } throw new Error ( "can't extract primitive:  symbol has empty value" ) ; }
function ( field ) { if ( field === null ) { field = '' ; } else if ( typeof field === "string" ) { field = delimiter + field + delimiter ; } else if ( typeof field === "number" ) { field = field . toString ( 10 ) ; } return field ; }
function ( ) { var csv = [ [ 'Jones, Jay' , 10 ] , [ 'Xyz "ABC" O\'Brien' , '11:35' ] , [ 'Other, AN' , '12:35' ] ] ; var array = recline . Backend . CSV . serializeCSV ( csv ) ; var exp = '"Jones, Jay",10\n' + '"Xyz ""ABC"" O\'Brien",11:35\n' + '"Other, AN",12:35\n' ; deepEqual ( array , exp ) ; }
function ( args ) { this . ticks = null ; if ( args ) { if ( args . ticks !== undefined ) { this . ticks = args . ticks ; } } }
function ( output ) { output . writeStructBegin ( 'BombahService_waitForStart_args' ) ; output . writeFieldStop ( ) ; output . writeStructEnd ( ) ; return ; }
function ( output ) { output . writeStructBegin ( 'BombahService_getMapState_args' ) ; output . writeFieldStop ( ) ; output . writeStructEnd ( ) ; return ; }
function ( ticks , callback ) { if ( callback === undefined ) { this . send_waitTicks ( ticks ) ; return this . recv_waitTicks ( ) ; } else { var postData = this . send_waitTicks ( ticks , true ) ; return this . output . getTransport ( ) . jqRequest ( this , postData , arguments , this . recv_waitTicks ) ; } }
function ( ticks , callback ) { this . output . writeMessageBegin ( 'waitTicks' , Thrift . MessageType . CALL , this . seqid ) ; var args = new BombahService_waitTicks_args ( ) ; args . ticks = ticks ; args . write ( this . output ) ; this . output . writeMessageEnd ( ) ; return this . output . getTransport ( ) . flush ( callback ) ; }
function ( callback ) { if ( callback === undefined ) { this . send_waitForStart ( ) ; this . recv_waitForStart ( ) ; } else { var postData = this . send_waitForStart ( true ) ; return this . output . getTransport ( ) . jqRequest ( this , postData , arguments , this . recv_waitForStart ) ; } }
function ( callback ) { if ( callback === undefined ) { this . send_getMapState ( ) ; return this . recv_getMapState ( ) ; } else { var postData = this . send_getMapState ( true ) ; return this . output . getTransport ( ) . jqRequest ( this , postData , arguments , this . recv_getMapState ) ; } }
function ( callback ) { this . output . writeMessageBegin ( 'getMapState' , Thrift . MessageType . CALL , this . seqid ) ; var args = new BombahService_getMapState_args ( ) ; args . write ( this . output ) ; this . output . writeMessageEnd ( ) ; return this . output . getTransport ( ) . flush ( callback ) ; }
function ( args ) { this . ticks = null ; if ( args ) { if ( args . ticks !== undefined ) { this . ticks = args . ticks ; } } }
function ( output ) { output . writeStructBegin ( 'BombahService_waitForStart_args' ) ; output . writeFieldStop ( ) ; output . writeStructEnd ( ) ; return ; }
function ( output ) { output . writeStructBegin ( 'BombahService_getMapState_args' ) ; output . writeFieldStop ( ) ; output . writeStructEnd ( ) ; return ; }
function ( ticks ) { var output = new this . pClass ( this . output ) ; output . writeMessageBegin ( 'waitTicks' , Thrift . MessageType . CALL , this . seqid ) ; var args = new BombahService_waitTicks_args ( ) ; args . ticks = ticks ; args . write ( output ) ; output . writeMessageEnd ( ) ; return this . output . flush ( ) ; }
function ( ) { var output = new this . pClass ( this . output ) ; output . writeMessageBegin ( 'getMapState' , Thrift . MessageType . CALL , this . seqid ) ; var args = new BombahService_getMapState_args ( ) ; args . write ( output ) ; output . writeMessageEnd ( ) ; return this . output . flush ( ) ; }
function ( seqid , input , output ) { var args = new BombahService_waitForStart_args ( ) ; args . read ( input ) ; input . readMessageEnd ( ) ; var result = new BombahService_waitForStart_result ( ) ; this . _handler . waitForStart ( function ( success ) { result . success = success ; output . writeMessageBegin ( "waitForStart" , Thrift . MessageType . REPLY , seqid ) ; result . write ( output ) ; output . writeMessageEnd ( ) ; output . flush ( ) ; } ) }
function updateGraph ( report , newSeries ) { newSeries . active = report . graph . series . active ; report . graph . series = newSeries ; try { report . graph . update ( ) ; } catch ( e ) { drawGraph ( report , newSeries ) ; } }
function processAsyncMethodCallback ( value , error ) { if ( ! error ) { this . options . nonErrorCallCount ++ ; this . options . lastGet = new Date ( ) ; this . options . isRefreshing = false ; this . options . cachedValue = value ; } else { console . log ( 'error %s' , error ) ; } }
function ( error , response , body ) { if ( ! error && response . statusCode == 200 ) { var markdown = body . toString ( ) ; post . content_md = markdown ; post . content_html = md ( markdown ) ; callback ( ) ; } else { log ( 'populateBlogPostContent: error for %s, error = %s' , post . id , error ) ; callback ( error ) ; } }
function ( error , response , body ) { if ( ! error && response . statusCode === 200 ) { callback ( body ) ; } else { log ( "error getting JSON from %s: error: %s, statusCode: %s" , url , error , response . statusCode ) ; callback ( null , response . statusCode ) ; } }
function ( posts , error ) { if ( error ) { callback ( null , error ) ; } else { var viewModel = { posts : posts , shared : getSharedViewModel ( 'home' ) , title : 'Rarely updated' } ; callback ( viewModel ) ; } }
function getPostViewModel ( postId , callback ) { getIndexViewModel ( function ( indexViewModel ) { var post = _ . chain ( indexViewModel . posts ) . filter ( function ( post ) { return post . id == postId } ) . first ( ) . value ( ) ; var postViewModel = { title : post . title , post : post , shared : getSharedViewModel ( 'post' ) } ; callback ( postViewModel ) ; } ) ; }
function Reading ( ) { function Constructor ( ) { } function index ( req , res ) { s . getReadingListViewModel ( function ( model ) { res . render ( 'reading' , model ) ; } ) ; } ; Constructor . prototype = { index : index , } ; return Constructor ; }
function ( opts , elems ) { var elems = elems || "body" ; $ . extend ( this . options , opts ) ; if ( this . options . class_prefix == "" ) { this . options . class_prefix = "set_in_" ; } var stack = $ ( elems ) . css ( 'font-family' ) ; if ( typeof stack == "string" ) { stack = stack . match ( /[^'",;\s][^'",;]*/g ) || [ ] ; } this . analyzeStack ( stack , elems ) ; }
function getDefaultComponent ( req ) { return { type : req . body . type , layout : req . body . layout , action : req . body . action } ; }
function getDefaultElement ( req ) { return { type : req . body . type , head : req . body . head , nextId : req . body . nextId , name : req . body . name , required : req . body . required || false , src : req . body . src , text : req . body . text , level : req . body . level } ; }
function validateProject ( req , beingCreated ) { var title = req . body . title ; if ( ! title || title . length === 0 ) { return 'Project must have a title.' ; } else if ( title . length > 25 ) { return 'Project must have a title less than 25 characters long.' ; } return true ; }
function validateScreen ( req , beingCreated ) { var title = req . body . title ; if ( ! title || title . length === 0 ) { return 'Screen must have a title.' ; } else if ( title . length > 25 ) { return 'Screen must have a title less than 25 characters long.' ; } return true ; }
function ( ) { var title = this . $input . val ( ) . trim ( ) ; var that = this ; this . model . save ( { title : title } , { error : tooltipErrorHandler ( this . $input ) , success : function ( model ) { that . $el . removeClass ( 'editing' ) ; } } ) ; }
function ( event ) { event . preventDefault ( ) ; var $target = $ ( event . target ) ; if ( $target . is ( 'a' ) ) { this . $el . siblings ( ) . removeClass ( 'active' ) ; this . $el . addClass ( 'active' ) ; this . options . screens . setActiveProject ( this . model . id ) ; $addScreen . show ( ) ; } }
function ( project ) { var view = new ProjectView ( { model : project , screens : screens } ) ; this . $projectList . append ( view . render ( ) . $el ) ; }
function ( $component , type ) { $component . removeClass ( type + '-container' ) ; $component . removeClass ( 'active' ) ; $component . addClass ( 'empty' ) ; $component . empty ( ) ; }
function ( event ) { if ( $ ( 'input[type="text"]:focus, textarea:focus' ) . length === 0 ) { if ( event . which === 8 && this . layoutView . $activeElement ) { this . layoutView . trigger ( 'removeElement' ) ; event . preventDefault ( ) ; } if ( event . which === 27 ) { this . layoutView . resetActiveElement ( ) ; } } }
function ( ) { $ ( this ) . jqmRemoveData ( "collapsible-last" ) . find ( $ . mobile . collapsible . prototype . options . heading ) . find ( "a" ) . first ( ) . removeClass ( "ui-corner-top ui-corner-bottom" ) . find ( ".ui-btn-inner" ) . removeClass ( "ui-corner-top ui-corner-bottom" ) ; }
function ( ) { var el = document . createElement ( 'bootstrap' ) , transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'oTransitionEnd otransitionend' , 'msTransition' : 'MSTransitionEnd' , 'transition' : 'transitionend' } , name for ( name in transEndEventNames ) { if ( el . style [ name ] !== undefined ) { return transEndEventNames [ name ] } } }
function ( ) { console . log ( 'asd' ) ; var data = { text : $ ( this ) . siblings ( '.feedback-input' ) . text ( ) , image : getUserImage ( ) } $ ( this ) . siblings ( '#comments' ) . append ( $ ( Mustache . render ( commentTemplate , data ) ) ) ; }
function func ( ) { var data = musu . appContext . feed . query ( "type='truth_dare_state'" , "_id desc limit 1" ) [ 0 ] ; var start_obj_DbObj = new SocialKit . DbObj ( data ) ; start_obj_DbObj . post ( user_obj ) ; }
function define ( env , name , sexpr ) { if ( name . type !== "symbol" ) { throw new Error ( "define needs a symbol as its first argument (got " + name . type + ")" ) ; } var value = evaluate ( sexpr , env ) ; env . addBinding ( name . value , value ) ; return Data . Nil ( ) ; }
function closure ( ) { var ln = names . length , la = arguments . length , newEnv = Environment . Environment ( env , { } ) ; if ( ln !== la ) { throw new Error ( "length of parameter list of lambda does not match arguments list: " + ln + " vs " + la ) ; } for ( var j = 0 ; j < names . length ; j ++ ) { newEnv . addBinding ( names [ j ] . value , arguments [ j ] ) ; } return evaluate ( body , newEnv ) ; }
function car ( list ) { if ( list . type !== 'list' ) { throw new Error ( "argument to 'car' must be list (got " + list . type + ")" ) ; } if ( arguments . length != 1 ) { throw new Error ( "wrong number of arguments: needed 1, got " + arguments . length ) ; } if ( list . value . length > 0 ) { return list . value [ 0 ] ; } return Data . Nil ( ) ; }
function cdr ( list ) { if ( list . type !== 'list' ) { throw new Error ( "argument to 'cdr' must be list (got " + list . type + ")" ) ; } if ( arguments . length != 1 ) { throw new Error ( "wrong number of arguments: needed 1, got " + arguments . length ) ; } if ( list . value . length > 0 ) { return Data . List ( list . value . slice ( 1 ) ) ; } return Data . Nil ( ) ; }
function plus ( left , right ) { if ( arguments . length != 2 ) { throw new Error ( "wrong number of arguments: needed 2, got " + arguments . length ) ; } if ( left . type !== 'number' || right . type !== 'number' ) { throw new Error ( "primitive + requires two numbers (got " + left . type + ", " + right . type + ")" ) ; } return Data . Number ( left . value + right . value ) ; }
function neg ( num ) { if ( arguments . length != 1 ) { throw new Error ( "wrong number of arguments: needed 1, got " + arguments . length ) ; } if ( num . type !== 'number' ) { throw new Error ( "primitive 'neg' requires a number (got " + num . type + ")" ) ; } return Data . Number ( - num . value ) ; }
function ( ) { deepEqual ( data . List ( [ 14 ] ) , funcs . cons ( 14 , data . List ( [ ] ) ) ) ; deepEqual ( data . List ( [ 1 , 2 , 3 ] ) , funcs . cons ( 1 , data . List ( [ 2 , 3 ] ) ) ) ; }
function ( ) { var car = funcs . car ; deepEqual ( 3 , car ( data . List ( [ 3 , 4 ] ) ) ) ; deepEqual ( data . Nil ( ) , car ( data . List ( [ ] ) ) ) ; }
function ( ) { var cdr = funcs . cdr ; deepEqual ( data . List ( [ 4 , 10 , 'hello' ] ) , cdr ( data . List ( [ 3 , 4 , 10 , 'hello' ] ) ) ) ; deepEqual ( data . Nil ( ) , cdr ( data . List ( [ ] ) ) ) ; }
function ( ) { deepEqual ( data . Number ( 3 ) , funcs . neg ( data . Number ( - 3 ) ) , "simple negation" ) ; deepEqual ( data . Number ( - 14 ) , funcs . neg ( funcs . neg ( data . Number ( - 14 ) ) ) , "a number is its own double negative" ) ; }
function _lintCPP ( prev , baton ) { var options = [ "--R" , "--filter=-whitespace/line_length,-whitespace/comments,-whitespace/labels,-readability/streams" ] , files = [ "ext" ] ; _exec ( 'python ' + __dirname + "/../dependencies/cpplint/cpplint.py " + options . concat ( files ) . join ( ' ' ) , prev , baton ) ; }
function ( ) { if ( Ext . isIE6 || Ext . isIE7 || Ext . isIE8 || ( Ext . isIE && this . document . documentMode < 9 ) ) { Ext . each ( this . config . customTags , function ( tag ) { this . document . createElement ( tag ) ; } , this ) ; } }
function ( err ) { if ( err ) { return cb ( err ) ; } stream . write ( jqtpl . tmpl ( 'headerTemplate' , { modulename : details . name , dependencies : dependencies , modulepath : '/' + details . name + '/' + getMainModulePath ( details ) } ) ) ; stream . end ( ) ; }
function ( err , location ) { obj = { city : location . city , latitude : location . latitude , longitude : location . longitude , ip : ip , timestamp : time } console . log ( obj ) ; self . bayeux . getClient ( ) . publish ( '/stat' , obj ) ; }
function ( ) { var width = $ ( '.yui3-u-3-5' ) . width ( ) , windowHeight = $ ( window ) . height ( ) , mapCanvasHeight = width * ( 369.0 / 567.0 ) ; self . map . setSize ( width , mapCanvasHeight ) ; console . log ( window . location . hostname ) ; }
function ( ) { var client = new varnish . VarnishClient ( '127.0.0.1' , server . address ( ) . port ) ; client . on ( 'ready' , function ( ) { client . run_cmd ( 'purge obj.http.X == test' , function ( ) { } ) ; } ) ; }
function ( ) { var client = new varnish . VarnishClient ( '127.0.0.1' , server . address ( ) . port ) ; client . on ( 'ready' , function ( ) { client . on ( 'close' , function ( ) { ok = true ; } ) ; server . close_connections ( ) ; server . close ( ) ; } ) ; }
function ( ) { var client = new varnish . VarnishClient ( '127.0.0.1' , server . address ( ) . port ) ; client . on ( 'ready' , function ( ) { client . run_cmd ( 'purge obj.http.X == test' , function ( ) { } ) ; client . on ( 'response' , function ( code , body ) { ok = true ; assert . equal ( 200 , code ) ; } ) ; } ) ; }
function ( ) { client . run_cmd ( 'purge obj.http.X == test' , function ( ) { } ) ; client . on ( 'error' , function ( e ) { ok = true ; assert . equal ( 'RESPONSE_PENDING' , e . code ) ; } ) ; client . run_cmd ( 'purge obj.http.X == test' , function ( ) { } ) ; }
function ( ) { var client = new varnish . VarnishClient ( '127.0.0.1' , server . address ( ) . port ) ; client . on ( 'ready' , function ( ) { client . run_cmd ( 'purge obj.http.X == test' , function ( ) { } ) ; client . on ( 'error' , function ( e ) { ok = true ; assert . equal ( 'RESPONSE_PENDING' , e . code ) ; } ) ; client . run_cmd ( 'purge obj.http.X == test' , function ( ) { } ) ; } ) ; }
function ( ) { var queue = new varnish . VarnishQueue ( '127.0.0.1' , 1234 ) for ( var i = 0 ; i < 10 ; ++ i ) { queue . run_cmd ( 'purge simon_is == the_best' ) ; } var server = VarnishEmu ( null , 1234 ) setTimeout ( function ( ) { assert . equal ( 10 , server . commands ) ; } , 2000 ) ; }
function ( module4 ) { console . log ( 'Executing module2.js' ) ; document . getElementById ( 'console' ) . innerHTML += 'Executing module2.js\n' ; console . log ( 'Trying to use module4...' ) ; document . getElementById ( 'console' ) . innerHTML += 'Trying to use module4...\n' ; if ( module4 . speak ( 'Hello, World!' ) === 'ok' ) { console . log ( 'module4 used successfully' ) ; document . getElementById ( 'console' ) . innerHTML += 'module4 used successfully\n' ; } else { console . error ( 'Failed using module4' ) ; document . getElementById ( 'console' ) . innerHTML += 'Failed using module4\n' ; } return { } ; }
function ( module1 ) { console . log ( 'Executing module4.js' ) ; document . getElementById ( 'console' ) . innerHTML += 'Executing module4.js\n' ; return { speak : function ( message ) { console . log ( 'module4.js: ' + message ) ; document . getElementById ( 'console' ) . innerHTML += 'module4.js: ' + message + '\n' ; return 'ok' ; } } ; }
function ( ) { if ( window . console ) console . log ( "Initializing StreetView support." ) ; this . streetViewPanel = $ ( "<div>" ) . addClass ( "map-panel" ) ; this . googleMap . controls [ google . maps . ControlPosition . BOTTOM_CENTER ] . push ( this . streetViewPanel . get ( 0 ) ) ; this . streetViewPanel . hide ( ) ; }
function ( model , el ) { var presenterClass , type ; type = model . get ( 'type' ) ; if ( ( type != null ) && type . match ( /^\w+$/ ) ) { presenterClass = eval ( "" + ( type . capitalize ( ) ) + "Presenter" ) ; return new presenterClass ( model , el ) ; } else { return null ; } }
function ( ) { return ( new Date ( ) ) . getTime ( ) ; }
function ( v , min , max ) { if ( v != null ) { if ( ( min != null ) && v < min ) { return min ; } else if ( ( max != null ) && v > max ) { return max ; } else { return v ; } } else { return 0 ; } }
function ( el , ndx ) { var src = el . dataset . source ; var id = el . id || 'bang_' + ndx ; el . id = id ; var context = initElementWithSrcImage ( el , src ) ; }
function ( method ) { method . analysis = new Analysis ( method , opts ) ; method . analysis . analyzeControlFlow ( ) ; method . analysis . restructureControlFlow ( ) ; if ( method . analysis ) { method . analysis . traceCFG ( writer , method , "G" + graph + "_" ) ; graph += 1 ; } }
function ( target , easing ) { this . $super ( target , easing ) ; var ctor = target . constructor ; switch ( true ) { case ctor === undefined : case ( /HTML[a-zA-Z]+Element/ . test ( ctor ) ) : this . units = { } ; break ; case ctor === Class : case ctor === Date : case ctor === Number : case ctor === String : case ctor === Function : case ctor === Object : default : break ; } }
function ( ) { console . log ( 'touchdown' ) ; window . clearInterval ( this . controlTimer ) ; console . log ( this . controlTimer ) ; this . loadBoard ( ) ; this . playPiece = this . waitingPiece ; this . waitingPiece = this . createPiece ( ) ; if ( this . collisionTest ( 'init' ) === true ) { this . gameOver ( ) ; } this . render ( ) ; this . renderWaiting ( ) ; }
function paneVisibility ( ) { var img = document . getElementById ( paneVisibility . img_id ) ; var pane = document . getElementById ( paneVisibility . pane_id ) ; if ( paneVisibility . visible == true ) { pane . style . display = 'block' ; img . src = virtroot + '/images/icons/bullet_toggle_minus.png' ; img . title = 'Hide type list' ; } else { pane . style . display = 'none' ; img . src = virtroot + '/images/icons/bullet_toggle_plus.png' ; img . title = 'Show type list' ; } dijit . byId ( 'bc' ) . resize ( ) ; }
function ( err , data ) { if ( err ) cb ( err ) ; else if ( data == '' ) cb ( new Error ( 'JSON Syntax Error' ) ) ; else try { cb ( null , JSON . parse ( data ) ) ; } catch ( e ) { console . error ( 'While loading metadata:' , e . stack ) ; } }
function ( ) { if ( LEVELS [ level ] >= allowedLevel ) { var args = Array . prototype . slice . call ( arguments ) ; args . splice ( 0 , 0 , level ) ; log . apply ( this , args ) ; } }
function runTest ( ) { browserElementTestHelpers . setEnabledPref ( true ) ; browserElementTestHelpers . addToWhitelist ( ) ; iframe = document . createElement ( 'iframe' ) ; iframe . mozbrowser = true ; addOneShotIframeEventListener ( 'mozbrowserloadend' , function ( ) { SimpleTest . executeSoon ( test2 ) ; } ) ; iframe . src = browserElementTestHelpers . emptyPage1 ; document . body . appendChild ( iframe ) ; }
function ( e , el ) { e && e . stop && e . stop ( ) ; var id = el . getParent ( 'div.task' ) . get ( 'data-id' ) , model = this . collection . getModelById ( id ) ; this . collection . removeModel ( model ) ; this . render ( ) ; }
function log ( params , severity ) { if ( typeof severity === 'number' ) { params . severity = severity ; } var message = this . formatter . format ( params ) ; if ( severity >= 3 ) { var syslogSeverity = severity - 3 ; this . syslog . send ( message , syslogSeverity ) ; } return message ; }
function ( msg ) { self . connectInterval = 0 if ( msg [ 'delete' ] ) { self . emit ( 'delete' , msg ) ; } else if ( msg [ 'limit' ] ) { self . emit ( 'limit' , msg ) ; } else if ( msg [ 'scrub_geo' ] ) { self . emit ( 'scrub_geo' , msg ) ; } else { self . emit ( 'tweet' , msg ) ; } }
function down ( ev ) { if ( ! itson ) { return ; } doit . className = 'measuring' ; if ( time === 0 ) { time = ev . timeStamp ; log . classList . add ( 'animate' ) ; } }
function up ( ev ) { doit . className = '' ; if ( ! itson ) { return ; } if ( time !== 0 ) { displayresult ( ev . timeStamp - time ) ; time = 0 ; log . classList . remove ( 'animate' ) ; } }
function _setupTraceTree ( trace ) { if ( trace . type === "function.end" ) { _lastParent = _lastParent . parent ; return ; } if ( _lastParent ) { _lastParent . children . push ( trace ) ; trace . parent = _lastParent ; } if ( trace . type === "event" || ! _lastParent ) { _rootTraces . push ( trace ) ; } _lastParent = trace ; }
function ( ) { if ( sandboxRoot . _error ) return ; try { callback . apply ( sandboxRoot . _this , arguments ) ; events . emit ( 'finishCallback' ) ; } catch ( err ) { sandbox . _error = err ; done ( err ) ; } }
function showErrorMsg ( message ) { var $msgDiv = $ ( '#messageDiv' ) ; $msgDiv . html ( message ) ; $msgDiv . fadeIn ( "fast" ) ; setTimeout ( function ( ) { $msgDiv . fadeOut ( 'fast' ) ; $msgDiv . html ( "" ) ; } , 3000 ) ; }
function ( ) { var $elem = $ ( "#footDiv" ) ; var i = $elem [ 0 ] ; if ( i ) { var ll = i . offsetTop ; while ( i == i . offsetParent ) { ll += i . offsetTop ; i = i . offsetParent ; } if ( ll < 800 ) { $elem . addClass ( "footDiv" ) ; } } }
function ( target_id , page , callback ) { console . log ( "API - getCommentsByTargetId" ) ; $ . ajax ( { url : '/api/question/' + target_id + '/comments/' + page , type : 'GET' , success : function ( data ) { callback ( data ) ; } } ) ; }
function ( row , index ) { var record = that . options . list [ that . options . offset + index ] ; that . locate ( "column" , rows . eq ( index ) ) . wrapInner ( $ ( "<a/>" ) . attr ( "href" , fluid . stringTemplate ( that . options . url , { recordType : record [ that . options . typePath ] . toLowerCase ( ) , csid : record . csid } ) ) ) ; }
function _addFileToIndexes ( entry ) { if ( brackets . platform === "mac" && entry . name . charAt ( 0 ) === "." ) { return ; } var fileInfo = new FileInfo ( entry ) ; $ . each ( _indexList , function ( indexName , index ) { if ( index . filterFunction ( entry ) ) { index . fileInfos . push ( fileInfo ) ; } } ) ; }
function ( request , response ) { var parsed = parseQuotas ( response . GROUP ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . VM ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . DATASTORE ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . IMAGE ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . NETWORK ) ; }
function updateGroupsView ( request , group_list ) { group_list_json = group_list ; var group_list_array = [ ] ; $ . each ( group_list , function ( ) { group_list_array . push ( groupElementArray ( this ) ) ; } ) ; updateView ( group_list_array , dataTable_groups ) ; updateGroupSelect ( group_list ) ; SunstoneMonitoring . monitor ( 'GROUP' , group_list ) updateSystemDashboard ( "groups" , group_list ) ; }
function ( ) { var uname = getValue ( $ ( this ) . val ( ) , 4 , 2 , dataTable_images ) ; $ ( 'input#IMAGE_UNAME' , section_disks ) . val ( uname ) ; var target = getValue ( $ ( this ) . val ( ) , 4 , 12 , dataTable_images ) ; if ( target && target != "--" ) $ ( 'input#TARGET' , section_disks ) . val ( target ) ; else $ ( 'input#TARGET' , section_disks ) . val ( '' ) ; }
function ( request , response ) { var parsed = parseQuotas ( response . USER ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . VM ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . DATASTORE ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . IMAGE ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . NETWORK ) ; }
function ( monitoring ) { $ ( '#totalUsers' , $dashboard ) . text ( monitoring [ 'totalUsers' ] ) var container = $ ( 'div#usersPerGroup' , $dashboard ) ; SunstoneMonitoring . plot ( 'USER' , 'usersPerGroup' , container , monitoring [ 'usersPerGroup' ] ) ; }
function updateUsersView ( request , users_list ) { var user_list_array = [ ] ; $ . each ( users_list , function ( ) { user_list_array . push ( userElementArray ( this ) ) ; } ) ; updateView ( user_list_array , dataTable_users ) ; SunstoneMonitoring . monitor ( 'USER' , users_list ) updateSystemDashboard ( "users" , users_list ) ; updateUserSelect ( ) ; }
function Testling ( harness , name , conf ) { Test . apply ( this , arguments ) ; for ( var key in Test . prototype ) { this [ key ] = Test . prototype [ key ] . bind ( this ) ; } for ( var key in Testling . prototype ) { this [ key ] = Testling . prototype [ key ] . bind ( this ) ; } }
function wsp_test_func ( func , data , expect ) { let result_str = JSON . stringify ( func ( data ) ) ; let expect_str = JSON . stringify ( expect ) ; if ( result_str !== expect_str ) { do_throw ( "expect decoded value: '" + expect_str + "', got '" + result_str + "'" ) ; } }
function ( e ) { e . preventDefault ( ) ; var query = $ ( "#query" ) . val ( ) . replace ( /\"/g , "" ) ; searchControl . startSearch ( query ) ; history . pushState ( { "query" : query } , "Searching for - " + query , "/search?q=" + encodeURIComponent ( query ) ) ; }
function ( aSubject , aTopic , aData ) { switch ( aTopic ) { case "profile-after-change" : updateFilter ( ) ; checkIECompatMode ( ) ; break ; } ; }
function ( ) { grid = core . grids . contractGrid ; selectedIndex = grid . focus . rowIndex ; selectedItem = grid . getItem ( selectedIndex ) ; id = grid . store . getValue ( selectedItem , 'contract_idContract' ) ; tabTitle = grid . store . getValue ( selectedItem , 'client_name' ) ; this . showContractTab ( id , tabTitle ) ; }
function ( ) { grid = core . grids . meterGrid ; selectedIndex = grid . focus . rowIndex ; selectedItem = grid . getItem ( selectedIndex ) ; id = grid . store . getValue ( selectedItem , 'meter_idMeter' ) ; tabTitle = grid . store . getValue ( selectedItem , 'meter_numberMain' ) ; this . showMeterTab ( id , tabTitle ) ; }
function ( ) { grid = core . grids . siteGrid ; selectedIndex = grid . focus . rowIndex ; selectedItem = grid . getItem ( selectedIndex ) ; id = grid . store . getValue ( selectedItem , 'site_idSite' ) ; tabTitle = grid . store . getValue ( selectedItem , 'clientAd_addressName' ) ; this . showSiteTab ( id , tabTitle ) ; }
function ( viz , options ) { this . viz = viz ; this . config = $ . merge ( { idSuffix : '-bkcanvas' , levelDistance : 100 , numberOfCircles : 6 , CanvasStyles : { } , offset : 0 } , options ) ; }
function ( ) { this . remove ( ) ; this . model . destroy ( ) ; var items = manager . folders . items , pos = items . indexOf ( this ) ; if ( pos >= 0 ) items . splice ( pos , 1 ) ; manager . folders . resize ( ) ; }
function ( solution , index ) { var paths = matchMaker . computeLeavesFromSolution ( solution ) ; var skeleton = matchMaker . pathsToSkeleton ( paths ) ; return { solution : solution , skeleton : skeleton , index : index } }
function ( t ) { t . plan ( 1 ) ; var src = browserify . bundle ( { require : __dirname + '/subdep/index.js' } ) ; var c = { } ; vm . runInNewContext ( src , c ) ; t . deepEqual ( Object . keys ( c . require . modules ) . sort ( ) , [ '/package.json' , '/index.js' , '/node_modules/qq/package.json' , '/node_modules/qq/b.js' , '/node_modules/qq/node_modules/a/package.json' , '/node_modules/qq/node_modules/a/index.js' , '/node_modules/qq/node_modules/z/index.js' , 'path' ] . sort ( ) ) ; t . end ( ) ; }
function ( callback ) { var stream ; if ( seperator ) { output . write ( ',' ) ; } output . write ( '"' + filepath + '":' ) ; stream = self . compiler . read ( filepath ) ; stream . pipe ( output . write ) ; stream . once ( 'end' , callback ) ; stream . resume ( ) ; }
function getScoreAndCellIndex ( ) { completeAlignment ( ) ; score = $ ( '#score' ) . html ( ) ; for ( i = 8 ; i < totalCells ; ++ i ) { if ( $ ( '#matrix' ) . find ( $ ( 'td:eq(' + ( i ) + ')' ) ) . html ( ) === score ) { scoreCellIndex = i ; } } }
f } , 0 ) ; } ) ; } , check_field : function ( c ) { $field = b ( this ) ; if ( a . timer ) { clearTimeout ( a . timer ) ; } if ( $field . val ( ) === "http://" || $field . val ( ) === "" ) { a . set_status ( $field , "empty" ) ;
function ( bundleURI ) { categoryManager . addCategoryEntry ( "strings_firebug" , bundleURI , "" , false , true ) ; this . stringBundle = null ; }
function ( ) { if ( ! this . defaultStringBundle ) { var chromeRegistry = Cc [ "@mozilla.org/chrome/chrome-registry;1" ] . getService ( Ci . nsIChromeRegistry ) ; var uri = Services . io . newURI ( "chrome://firebug/locale/firebug.properties" , "UTF-8" , null ) ; var fileURI = chromeRegistry . convertChromeURL ( uri ) . spec ; var parts = fileURI . split ( "/" ) ; parts [ parts . length - 2 ] = DEFAULT_LOCALE ; this . defaultStringBundle = stringBundleService . createBundle ( parts . join ( "/" ) ) ; } return this . defaultStringBundle ; }
function ( ) { width = $ ( window ) . width ( ) ; height = $ ( window ) . height ( ) ; headerHeight = $ ( "header" , $ . mobile . activePage ) . height ( ) ; footerHeight = $ ( "footer" , $ . mobile . activePage ) . height ( ) ; contentHeight = height - headerHeight - footerHeight ; }
function correctWord ( ) { if ( err_type_chosen == false ) { displayWarning ( ) ; } else { trackChanges ( num_corr , span_start ) ; if ( moving_phrase ) { commitMove ( ) ; } else if ( highlighting_mode == "insert" ) { commitInsert ( ) ; } else { commitChange ( ) ; } cleanUpUI ( ) ; } return false ; }
function ( template ) { var template = Mustache . render ( template , data ) ; $ ( "#goals-list" ) . append ( template ) ; $ ( "#goal-name" ) . val ( "" ) ; $ ( "#goal-name" ) . focus ( ) ; addGoalButton . removeClass ( "disabled" ) ; addGoalButton . val ( "add goal" ) ; }
function closetag ( tag ) { var currentTag = tagNameStack . pop ( ) if ( currentTag === tag ) { self . emit ( 'closetag' , tag ) atok . offset -- atokTracker . xx -- } else { console . log ( atok . buffer ) setError ( new Error ( 'Invalid closetag: ' + tag + ' !== ' + currentTag ) ) ( tag ) } }
function ( ) { } , endPath : function ( ) { } , getContour : function ( ) { } , updatePath : function ( ) { } , applyAsPath : function ( ) { } , transform : function ( ) { } , drawHandle : function ( a , b , c ) { var d = CAAT . Curve . prototype . HANDLE_SIZE / 2 ; a . fillRect ( b - d , c - d , d * 2 , d * 2 ) }
function ReadStream ( bin , offset , length ) { assert ( bin instanceof ArrayBuffer ) ; this . position = 0 ; this . source = bin ; this . length = bin . byteLength ; this . view = offset && length ? DataView ( bin , offset , length ) : DataView ( bin ) ; }
function ( v ) { assert ( typeof v . index === 'number' ) ; assert ( typeof v . name === 'string' ) ; assert ( ! this . index . hasOwnProperty ( v . index . toString ( ) ) ) ; assert ( ! this . name . hasOwnProperty ( v . name ) ) ; this . index [ v . index . toString ( ) ] = v ; this . name [ v . name ] = v ; }
function ( idx ) { switch ( typeof idx ) { case 'string' : assert ( this . name . hasOwnProperty ( idx ) ) ; return this . name [ idx ] ; case 'number' : assert ( this . index . hasOwnProperty ( idx . toString ( ) ) ) ; return this . index [ idx . toString ( ) ] ; default : assert ( false ) ; } }
function ( ) { var pairs = { } ; for ( var i = 0 , key = localStorage . key ( 0 ) ; key !== null ; key = localStorage . key ( ++ i ) ) { if ( key . split ( '.' ) [ 0 ] === 'Settings' ) { pairs [ key ] = localStorage . getItem ( key ) ; } } return pairs ; }
function ( ) { if ( $ ( this ) . prop ( "checked" ) ) { window . webkitNotifications . requestPermission ( ) ; } }
function ( ) { if ( this . family === PConstants . GROUP ) { this . drawGroup ( ) ; } else if ( this . family === PConstants . PRIMITIVE ) { this . drawPrimitive ( ) ; } else if ( this . family === PConstants . GEOMETRY ) { this . drawGeometry ( ) ; } else if ( this . family === PConstants . PATH ) { this . drawPath ( ) ; } }
function ( ) { if ( this . matrix ) { p . popMatrix ( ) ; } if ( this . style ) { p . popStyle ( ) ; } }
function playlistQueues_renderTableRow ( playlistQueueId , playlist ) { $ ( "#playlist_queues tbody tr.empty_row" ) . remove ( ) ; var rowCount = $ ( "#playlist_queues tbody tr" ) . length ; $ ( "#playlist_queues tbody" ) . append ( "<tr id=\"" + playlistQueueId + "\"><td class=\"row_number\">" + ( rowCount + 1 ) + "</td><td class=\"playlist_name\">" + playlist . name + "</td><td class=\"playlist_length\">" + playlist . songs . length + "</td><td>" + playlistQueues_renderActions ( playlistQueueId ) + "</td></tr>" ) ; }
function thrown ( error , steps , index , context , callbacks , callback ) { if ( steps . length && steps . length && ~ steps [ 0 ] . parameters . indexOf ( "error" ) ) { context . error = error ; } abended = true ; if ( timer ) clearTimeout ( timer ) ; callback ( error ) ; }
function toggleFunctionsView ( input ) { var current_tab_index = $ ( "#toc_tabs" ) . tabs ( 'option' , 'selected' ) ; var new_tab_index = ( input . val ( ) === 'by_name' ) ? functionPanelIndex : categoriesPanelIndex ; $ ( "#toc_tabs" ) . tabs ( 'select' , new_tab_index ) ; console . log ( "Toggling function view..." ) ; }
function ( ) { var total = $ ( window ) . height ( ) , $section = $ ( 'section' ) . css ( 'height' , 'auto' ) ; if ( $section . outerHeight ( true ) < total ) { var margin = $section . outerHeight ( true ) - $section . height ( ) ; $section . height ( total - margin - 20 ) ; } else { $section . css ( 'height' , 'auto' ) ; } }
function ( data ) { rescaleGraph ( data ) console . log ( "the data to store:" , data ) ; graph_substrate . nodes ( data . nodes ) graph_substrate . links ( data . links ) graph_substrate . edgeBinding ( ) var g = graphDrawing ( graph_substrate , svg_substrate ) g . draw ( ) return }
function ( data ) { console . log ( "received data after synchronization: " ) console . log ( data ) ; rescaleGraph ( data ) cGraph . nodes ( data . nodes ) cGraph . links ( data . links ) cGraph . edgeBinding ( ) g = graphDrawing ( cGraph , svg ) g . show ( cGraph ) if ( 'data' in data ) { cohesion_homogeneity = data [ 'data' ] [ 'cohesion homogeneity' ] ; cohesion_intensity = data [ 'data' ] [ 'cohesion intensity' ] ; cohesionCaught ( ) ; } }
function ( data ) { console . log ( "received data after analysis:" ) console . log ( data ) ; rescaleGraph ( data ) graph_catalyst . nodes ( data . nodes ) graph_catalyst . links ( data . links ) graph_catalyst . edgeBinding ( ) g = graphDrawing ( graph_catalyst , svg_catalyst ) g . clear ( ) g . draw ( ) cohesion_homogeneity = data [ 'data' ] [ 'cohesion homogeneity' ] cohesion_intensity = data [ 'data' ] [ 'cohesion intensity' ] cohesionCaught ( ) ; }
function ( data ) { console . log ( 'creating in tulip, and recieved data: ' , data ) rescaleGraph ( data ) graph_substrate . nodes ( data . nodes ) graph_substrate . links ( data . links ) graph_substrate . edgeBinding ( ) g = graphDrawing ( graph_substrate , svg_substrate ) g . move ( graph_substrate , 0 ) }
function ( d ) { d . x = ( d . x - minX ) * scale + buttonWidth + frame ; d . y = ( d . y - minY ) * scale + frame ; }
function removeHandler ( e ) { var newTargetIsHandle = e . toElement == handle ; var newTargetIsNode = e . toElement == node . rscratch ( "svg" ) ; if ( newTargetIsHandle || newTargetIsNode || mdownOnHandle ) { return ; } node . unbind ( "mouseout" , removeHandler ) ; resetToDefaultState ( ) ; }
function ( ) { cy . nodes ( ) . die ( "mouseover" , startHandler ) . die ( "mouseover" , hoverHandler ) . die ( "mouseout" , leaveHandler ) . die ( "grab" , grabNodeHandler ) . die ( "free" , freeNodeHandler ) ; cy . unbind ( "zoom pan" , transformHandler ) ; }
function ( ) { var newProjectName = dojo . attr ( this . _projectName , "value" ) ; var isEclipse = dojo . attr ( this . _eclipseSupport , 'checked' ) ; Resource . createProject ( newProjectName , true , isEclipse ) ; if ( isEclipse ) { var prefValue = { webContentFolder : "./WebContent" , themeFolder : "./WebContent/themes" , widgetFolder : "./WebContent/widgets" } ; Preferences . savePreferences ( 'davinci.ui.ProjectPrefs' , newProjectName , prefValue ) ; } if ( Workbench . singleProjectMode ( ) ) Workbench . loadProject ( newProjectName ) ; this . onClose ( ) ; }
function ( node , i ) { scrollHeight = node . get ( 'scrollHeight' ) ; paginator . cards [ i ] = { maxScrollY : scrollHeight - widgetHeight , node : node , scrollX : 0 , scrollY : 0 } ; }
function ( x , y , duration , easing ) { var sv = this , duration = duration || ScrollView . SNAP_DURATION , easing = easing || ScrollView . SNAP_EASING ; sv . set ( SCROLL_X , x , { src : 'ui' } ) ; sv . set ( SCROLL_Y , y , { src : 'ui' } ) ; sv . scrollTo ( x , y , duration , easing ) ; }
function ( mins , callback ) { log ( "start timer for " + mins + " mins" ) ; var duration = Math . round ( mins * 60 ) ; var timer = duration ; stateStart ( timer ) ; ( function tick ( ) { stateCounting ( timer , duration ) ; if ( timer <= 0 ) { callback ( ) ; soundManager . setVolume ( settings . timerEndSoundId , volume ) . play ( ) ; } else { timer -- ; timerInterval = setTimeout ( tick , 1000 ) ; } } ) ( ) ; }
function updateVolumeIcon ( ) { var level = Math . floor ( TT . getVolume ( ) / 25 ) ; level = Math . min ( level , 3 ) ; level = Math . max ( level , 0 ) ; $ ( "#volume_icon" ) . removeClass ( ) . addClass ( "mute_toggle left level_" + level ) ; }
function ( results ) { for ( metricName in results ) { resultMetricData = results [ metricName ] ; graphMetricData = graph . data [ metricName ] ; for ( j = 0 ; j < resultMetricData . length ; j ++ ) { graphMetricData [ j ] = resultMetricData [ j ] ; } graph . data [ metricName ] = graphMetricData ; } if ( graph . name == 'multiple-metrics' ) console . log ( graph . data ) ; graph . object . update ( ) ; metricData = null ; }
function ( i , graph ) { graph . object . update ( ) ; }
function ( e ) { var layout_pane = jQuery ( '.ui-layout-' + e ) , tabs_height = layout_pane . find ( '.ui-tabs-nav' ) . height ( ) , pane_height = layout_pane . height ( ) - tabs_height , pane_width = layout_pane . width ( ) ; jQuery ( layout_pane . find ( '.ui-tabs-panel' ) . each ( function ( ) { var panel = jQuery ( this ) ; panel . height ( pane_height ) ; panel . width ( pane_width ) ; } ) ) ; }
function ( errorValue ) { if ( errorValue . type && errorValue . type === 'exn:fail:read' ) { return new Error ( errorValue . message ) ; } else if ( errorValue . type && errorValue . type === 'moby-failure' ) { var domMessage = this . _convertDomSexpr ( errorValue [ 'dom-message' ] ) ; return new ErrorWithDomMessage ( domMessage ) ; } return new Error ( errorValue + '' ) ; }
function ( ) { req = { params : { service : "default" , action : "exec" , ext : "blackberry.app" , method : "author" , args : null , origin : null } , headers : { host : "" } , url : "" , body : "" , origin : "" } ; res = { send : jasmine . createSpy ( ) } ; GLOBAL . frameworkModules = [ 'ext/app/index.js' , 'lib/plugins/extensions.js' , 'lib/plugins/default.js' ] ; }
function include ( parent , featureIdList ) { var featureId , featureProperties , localUrl , i ; for ( i = 0 ; i < featureIdList . length ; i ++ ) { featureId = featureIdList [ i ] ; localUrl = "local://ext/" + featureId + "/client.js" ; featureProperties = requireLocal ( localUrl ) ; buildNamespace ( parent , featureId . split ( "." ) , featureProperties ) ; } }
function ( success , fail , service , action , args , sync ) { var uri = service + "/" + action , request = new RemoteFunctionCall ( uri ) , name ; for ( name in args ) { if ( Object . hasOwnProperty . call ( args , name ) ) { request . addParam ( name , args [ name ] ) ; } } request [ sync ? "makeSyncCall" : "makeAsyncCall" ] ( success , fail ) ; }
function ( service , action , args ) { var result ; execFunc ( function ( data , response ) { result = data ; } , function ( data , response ) { throw data ; } , service , action , args , true ) ; return result ; }
function ( service , action , args ) { var result ; execFunc ( function ( data , response ) { result = data ; } , function ( data , response ) { throw data ; } , service , action , args , false ) ; return result ; }
function ( ) { req = { origin : "http://www.origin.com" , params : { } } ; res = { send : jasmine . createSpy ( ) } ; succ = jasmine . createSpy ( ) ; fail = jasmine . createSpy ( ) ; args = { } ; GLOBAL . frameworkModules = [ "ext/app/index.js" ] ; }
function ( ) { req . params . ext = "blackberry.app" ; req . params . method = "NotAMethod" ; bridge . exec ( req , succ , fail , args ) ; expect ( fail ) . toHaveBeenCalledWith ( - 1 , jasmine . any ( String ) , 404 ) ; }
function ( ) { GLOBAL . window = GLOBAL ; GLOBAL . window . webworks = mockedWebworks ; }
function WriteStream ( path , file ) { stream . Stream . call ( this ) ; this . writeable = true ; client . putStream ( this , file , function ( err , res ) { console . log ( res . statusCode ) ; } ) ; }
function ( err , fields , files ) { res . writeHead ( 200 , { 'content-type' : 'text/plain' } ) ; res . write ( 'received upload:\n\n' ) ; res . end ( util . inspect ( { fields : fields , files : files } ) ) ; }
function ( dir ) { var parent ; if ( path . existsSync ( path . join ( dir , 'Cakefile' ) ) ) return dir ; parent = path . normalize ( path . join ( dir , '..' ) ) ; if ( parent !== dir ) return cakefileDirectory ( parent ) ; throw new Error ( "Cakefile not found in " + ( process . cwd ( ) ) ) ; }
function ( ) { view = new cdb . admin . HeaderView ( { column : [ 'name' , 'type' ] , template : "<label><a><%= col_name %></a></label><p><a><%= col_type %></a></p>" } ) ; }
function ( ) { should . exist ( require ( 'assert' ) . AssertionError ) ; should . exist ( require ( 'events' ) . EventEmitter ) ; should . exist ( require ( 'http' ) . STATUS_CODES ) ; should . exist ( require ( 'path' ) . dirname ) ; should . exist ( require ( 'tty' ) . isatty ) ; should . exist ( require ( 'util' ) . inspect ) ; }
function ( xhr ) { var response = JSON . decode ( xhr . responseText ) if ( response && response . errors ) { this . alert ( response . errors , 'error' ) } this . fireEvent ( 'failure' , arguments ) }
function ( ev , target ) { var popover , options popover = target . retrieve ( 'popover' ) if ( ! popover ) { options = target . get ( 'dataset' ) options . anchor = target popover = Brickrouge . Popover . from ( options ) document . body . appendChild ( popover . element ) target . store ( 'popover' , popover ) } popover . show ( ) }
function ( data ) { $ ( "#queue" ) . empty ( ) ; var items = [ ] ; $ . each ( data , function ( i , item ) { items . push ( '<li>' + item . artist_name + ' - ' + item . name + '  <a href=\'#\' onclick="return removeItemFromQueue(\'' + item . queue_id + '\')">Remove</a>' + '</li>' ) ; } ) ; $ ( '#queue' ) . append ( items . join ( '' ) ) ; }
function ( dt , dn ) { var d = locals [ dt ] [ dn ] ; if ( ! d . __islocal ) d . __oldparent = d . parent ; d . parent = 'old_parent:' + d . parent ; d . docstatus = 2 ; d . __deleted = 1 ; }
function display_recorder ( type ) { var form = document . getElementById ( 'mform1' ) , params = 'type' + type + '&browserplugins' + JSON . stringify ( BrowserPlugins ) + '&browserdetect' + JSON . stringify ( BrowserDetect ) ; form . action = form . action + '?' + params ; form . submit ( ) ; }
function ( col ) { var elem = $ ( '.chart.' + scope + '.' + col . name ) . get ( 0 ) ; console . log ( scope , col , elem ) ; new google . visualization . LineChart ( elem ) . draw ( tablify ( data [ scope ] , col . name ) , { 'title' : scope + ' usage stats: ' + col . label , 'width' : 1000 , 'height' : 420 } ) ; }
function onRequest ( request , response ) { var pathname = url . parse ( request . url ) . pathname ; console . log ( "Request for " + pathname + " received." ) ; route ( handle , pathname ) ; response . writeHead ( 200 , { "Content-Type" : "text/plain" } ) ; response . write ( "Mikail bixa!" ) ; response . end ( ) ; }
function ( dirResult , dirStatus ) { if ( dirStatus != google . maps . DirectionsStatus . OK ) { alert ( 'Directions failed: ' + dirStatus ) ; return ; } WPmap . dirRenderer . setMap ( WPmap . map ) ; WPmap . dirRenderer . setPanel ( WPmap . dirContainer ) ; WPmap . dirRenderer . setDirections ( dirResult ) ; }
function ( result , textstatus , xhr ) { var params = $ ( result ) ; placeholder . replaceWith ( params ) ; params . find ( 'a[rel="popover"]' ) . popover ( ) ; }
function ( ) { if ( Ember . empty ( this . getPath ( 'content.title' ) ) ) { this . getPath ( 'controller.content' ) . removeObject ( this . get ( 'content' ) ) ; } }
function ( data ) { if ( data && data . barcode ) { var label = Titanium . UI . createLabel ( { text : data . barcode , } ) ; sellingDetailsWin . isbnNo = data . barcode ; sellingDetailsWin . image = imageTaken ; sellingDetailsWin . open ( ) ; } else { alert ( JSON . stringify ( data ) ) ; } }
function ( event ) { localImage = event . media ; if ( event . mediaType == Ti . Media . MEDIA_TYPE_PHOTO ) { photoLogo . image = localImage ; winProfile . add ( photoLogo ) ; } }
function ( e ) { if ( e . success ) { var post = e . posts [ 0 ] ; activityIndicator . hide ( ) ; var homeWin = Ti . UI . createWindow ( { url : "home.js" , } ) ; homeWin . open ( ) ; } else { alert ( 'Error in post creating:\\n' + ( ( e . error && e . message ) || JSON . stringify ( e ) ) ) ; } }
function ( e ) { if ( typeBarcodeTextField . value . length == 13 ) { Ti . UI . Android . hideSoftKeyboard ( ) ; sellingDetailsWin . isbnNo = typeBarcodeTextField . value ; sellingDetailsWin . image = imgView ; sellingDetailsWin . open ( ) ; } else { alert ( 'Invalid isbn number. Check that the isbn number is 13 digit long. And remove all \'-\'' ) } }
function ( d ) { if ( ! d || ! ( 17 == d . keyCode || 16 == d . keyCode ) ) b . value = a . prop ( b , "value" ) , c . box . removeClass ( "placeholder-visible" ) , clearTimeout ( k ) , a ( b ) . unbind ( ".placeholderremove" ) }
function ( a ) { return ! b . test ( a ) } } ( ) } ) ; d . addInputType ( "url" , { mismatch : function ( ) { var a = w . urlReg || / ^ ( [ a - z ] ( [ a - z ] |
function ( ) { params = { "verb" : "sms" , "demo" : "true" } ; Twilio . Device . connect ( params ) }
function ( ) { $ ( "#playlist_form #playlistitem_set-group .module.table.dynamic-form" ) . sortable ( { items : "div.tbody.dynamic-form" , placeholder : "ui-state-highlight" , stop : playlistitem_set_sorting } ) ; $ ( "#playlistitem_set-group .module.table.dynamic-form" ) . disableSelection ( ) ; $ ( "#playlist_form #playlistitem_set-group [name$='video']" ) . live ( "change" , playlistitem_set_sorting ) ; $ ( "#playlist_form #playlistitem_set-group .remove-handler" ) . live ( "click" , playlistitem_set_sorting ) ; }
function ( trackEvent ) { var targetList = createTargetsList ( trackEvent ) ; if ( ! trackEvent . manifest ) { throw "Unable to create properties from null manifest. Perhaps trackevent is not initialized properly yet." ; } var manifestOptions = trackEvent . manifest . options ; for ( var item in manifestOptions ) { if ( manifestOptions . hasOwnProperty ( item ) ) { _rootElement . appendChild ( createManifestItem ( item , manifestOptions [ item ] , trackEvent . popcornOptions [ item ] , trackEvent ) ) ; } } _rootElement . appendChild ( targetList ) ; _this . updatePropertiesFromManifest ( trackEvent . popcornOptions ) ; }
function ( popcornOptions ) { var element ; for ( var option in popcornOptions ) { if ( popcornOptions . hasOwnProperty ( option ) ) { element = _rootElement . querySelector ( "[data-manifest-key='" + option + "']" ) ; if ( element . type === "checkbox" ) { element . checked = popcornOptions [ option ] ; } else { element . value = popcornOptions [ option ] ; } } } }
function openEditor ( trackEvent ) { if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( "default" , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; return _currentEditor ; }
function ( data ) { button . hide ( ) ; button . after ( '<div></div>' ) ; button . next ( ) . html ( data ) ; s3_gis_locationselector_activate ( ) ; var url2 = S3 . Ap . concat ( '/pr/contact/create?person=' + personId ) ; $ ( '#popup' ) . find ( 'form' ) . attr ( 'action' , url2 ) ; $ ( '#contact-add_throbber' ) . hide ( ) ; }
function ( ) { var el = doc . createElement ( 'div' ) el . style . display = 'none' doc . body . appendChild ( el ) this . el = el this . removeEvent = ENV . bind ( this . remove , this ) this . transEvent = ENV . bind ( this . _afterAnimation , this ) ENV . domLoaded = true }
function ( item ) { var newNode = new LinkedList . Node ( item , null ) ; if ( this . first === null ) { this . first = newNode ; this . last = newNode ; } else { this . last . next = newNode ; this . last = newNode ; } assert ( this . last === newNode , 'error adding new node to linked list' ) ; }
function ( item , itr ) { if ( itr . prev === null ) this . addFirst ( item ) ; else itr . prev . next = new LinkedList . Node ( item , itr . current ) ; }
function ( item , itr ) { if ( itr . current === null ) this . addLast ( item ) ; else itr . current . next = new LinkedList . Node ( item , itr . current . next ) ; }
function ( ) { assert ( this . first !== null , 'cannot remove first, list empty' ) ; var item = this . first . item ; this . first = this . first . next ; if ( this . first === null ) this . last = null ; return item ; }
function ( itr ) { assert ( itr . valid ( ) , 'cannot remove item at iterator, iterator not valid' ) ; if ( itr . prev ) { itr . prev . next = itr . current . next ; } else { this . remFirst ( ) ; } }
function ( cfg ) { var preloads ; preloads = cfg && cfg [ 'preloads' ] ; if ( preloads && preloads . length > 0 ) { when ( preload , function ( ) { preload = core . getDeps ( core . createContext ( cfg , undef , preloads , true ) ) ; } ) ; } }
function ( ) { sort . destroy ( ) ; Assert . isTrue ( sort . get ( 'destroyed' ) , 'Failed to destroy the sortable instance' ) ; }
function ( ) { let expandedY = this . actor . height - this . _notificationBin . height ; if ( this . _notificationBin . y < expandedY ) this . _notificationBin . y = expandedY ; else if ( this . _notification . y != expandedY ) this . _tween ( this . _notificationBin , '_notificationState' , State . SHOWN , { y : expandedY , time : ANIMATION_TIME , transition : 'easeOutQuad' } ) ; }
function ( ev , name ) { var name ; name == null && ( name = file ) ; name = ( function ( ) { return this . join ( this . dirname ( file ) , this . basename ( name ) ) ; } . call ( path ) ) ; return cb ( __this . load . sync ( __this , name ) ) ; }
function ( ) { var cb , __i , __ref , __len , __run , __results = [ ] ; for ( __i = 0 , __len = ( __ref = $callbacks ) . length ; __i < __len ; ++ __i ) { cb = __ref [ __i ] ; __run = true ; __results . push ( cb . apply ( this , arguments ) ) ; } if ( ! __run ) { return $queue . push ( arguments ) ; } return __results ; }
function ( path , extra ) { var extra , sub ; extra == null && ( extra = { } ) ; sub = __this . system . resolve ( path ) ; return sub . run ( __import ( __this . args , extra ) ) ; }
function __bind ( obj , key ) { return function ( ) { return obj [ key ] . apply ( obj , arguments ) } ; }
function updateFullImage ( id ) { $ ( "body" ) . css ( "cursor" , "wait" ) ; img = "Image__" + id ; imgTag = $ ( '#largeImg' ) . prop ( "src" , img ) . css ( "max-width" , $ ( "body" ) . width ( ) ) . css ( "max-height" , $ ( "body" ) . height ( ) ) . load ( function ( ) { $ ( "body" ) . css ( "cursor" , "auto" ) } ) }
function init_visio ( ) { $ ( ".visio_img" ) . click ( function ( ) { current = $ ( this ) updateFullImage ( $ ( this ) . prop ( "rel" ) ) return false } ) $ ( "#visio_preview" ) . hide ( ) document . body . style . overflow = 'hidden' ; nextprev ( ) jwerty . key ( 's/n/→/↓' , function ( ) { nextprev ( ) } ) ; jwerty . key ( 'p/←/↑' , function ( ) { nextprev ( true ) } ) ; }
function ( selectionModel , record ) { if ( this . getSelectionModel ( ) . getCount ( ) == 1 && record . get ( "footprintId" ) ) { this . deleteButton . enable ( ) ; } else { this . deleteButton . disable ( ) ; } }
function ( ) { if ( this . instance . curScrollTop === 0 ) { this . ths . css ( 'borderBottomWidth' , 0 ) ; } else if ( this . instance . lastScrollTop === 0 ) { this . ths . css ( 'borderBottomWidth' , '1px' ) ; } }
function ( ) { if ( this . instance . curScrollLeft === 0 ) { this . ths . css ( 'borderRightWidth' , 0 ) ; } else if ( this . instance . lastScrollLeft === 0 ) { this . ths . css ( 'borderRightWidth' , '1px' ) ; } }
function ( userid ) { if ( config . enableQueue ) { if ( djQueue [ userid ] !== undefined ) { delete djQueue [ userid ] ; djQueue . length -- ; bot . speak ( "You have been removed from the queue @" + usersList [ userid ] . name ) ; if ( config . database . usedb ) { client . query ( "UPDATE " + config . database . dbname + "." + config . database . tablenames . cache + " SET `value` = ? WHERE `key` = 'djQueue'" , [ JSON . stringify ( djQueue ) ] ) ; } } } }
function ( key ) { var self = this ; var context = Context . current ; if ( context && ! self . _keyDeps [ key ] [ context . id ] ) { self . _keyDeps [ key ] [ context . id ] = context ; context . on_invalidate ( function ( ) { if ( self . _keyDeps [ key ] ) delete self . _keyDeps [ key ] [ context . id ] ; } ) ; } return self . _rawData [ key ] ; }
function ( jqXHR , textStatus , errorThrown ) { var statusCode = jqXHR . statusCode ( ) . status ; alert ( 'Houston, we have a problem trying to log out: ' + statusCode + ' ' + errorThrown ) ; }
function ( ) { localStorage . removeItem ( "player" ) ; if ( localStorage [ "fb_token" ] ) { window . location . href = facebookApiLogoutUrl + localStorage [ "fb_token" ] ; } else { Navigation . GoTo . Login ( ) ; } return false ; }
function ( ) { this . setPosition ( this . locationModel . get ( 'lat' ) , this . locationModel . get ( 'lng' ) ) ; var feedbackList = this . locationModel . get ( 'feedback' ) ; if ( ! feedbackList || feedbackList . length === 0 ) { this . setPov ( 0 , 0 , 1 ) ; } else { this . setPov ( feedbackList [ 0 ] . heading , feedbackList [ 0 ] . pitch , feedbackList [ 0 ] . zoom ) ; } }
function ch_end ( ) { if ( this . recentsEntry && ( this . recentsEntry . type . indexOf ( '-connected' ) == - 1 ) ) { this . recentsEntry . type += '-refused' ; } if ( this . currentCall ) this . currentCall . hangUp ( ) ; OnCallHandler . disconnected ( ) ; }
function ( ) { var view = App . getPrimaryActiveView ( ) ; if ( view ) { var value = view . getValues ( ) ; this . currentValue = this . validationValue = value ; this . setValue ( this . currentValue , false ) ; } }
function ( err , element ) { element . type . should . equal ( req . body . type ) ; element . head . should . equal ( req . body . head ) ; element . nextId . should . equal ( req . body . nextId ) ; element . required . should . equal ( req . body . required ) ; element . src . should . equal ( req . body . src ) ; done ( ) ; }
function ( err , element ) { element . type . should . equal ( req . body . type ) ; should . not . exist ( element . head ) ; should . not . exist ( element . nextId ) ; element . required . should . equal ( req . body . required ) ; element . src . should . equal ( req . body . src ) ; done ( ) ; }
function ( err , element ) { element . type . should . equal ( req . body . type ) ; element . head . should . equal ( req . body . head ) ; element . nextId . should . equal ( req . body . nextId ) ; element . required . should . equal ( req . body . required ) ; element . src . should . equal ( req . body . src ) ; done ( ) ; }
function ( err , screen ) { screen . title . should . equal ( req . body . title ) ; screen . is_start . should . equal ( req . body . is_start ) ; screen . layout . should . equal ( req . body . layout ) ; done ( ) ; }
function ( err , screen ) { screen . title . should . equal ( req . body . title ) ; screen . is_start . should . equal ( req . body . is_start ) ; screen . layout . should . equal ( req . body . layout ) ; done ( ) ; }
function ( result ) { var finished = parse_realm_status ( result , div_id ) ; if ( finished == '' ) finished = '<center>No Realms Installed</center>' ; $ ( div_id ) . html ( finished ) . show ( ) ; $ ( loading_id ) . hide ( ) ; }
function ( ) { myEditor . setCursorPos ( len - 1 , 0 ) ; CommandManager . execute ( Commands . EDIT_DUPLICATE , myEditor ) ; var lines = defaultContent . split ( "\n" ) , len = lines . length ; lines . push ( "}" ) ; var expectedText = lines . join ( "\n" ) ; expect ( myDocument . getText ( ) ) . toEqual ( expectedText ) ; expectCursorAt ( { line : len , ch : 0 } } ) ;
function ( ) { $page . removeClass ( "" + options . transition + " in reverse" ) ; if ( page === '#match' ) { $ ( '#lobby' ) . find ( '#matches' ) . css ( 'height' , '0' ) ; } if ( page === '#lobby' ) { return $ ( '#match' ) . find ( '#hand-container' ) . css ( 'height' , '0' ) ; } }
function ( ) { if ( ! mapLoaded ) { if ( navigator . geolocation ) { navigator . geolocation . getCurrentPosition ( loadMap , function ( ) { alert ( 'Could not detect position.' ) ; } ) ; } } else { map . setCenter ( lonlat ) ; showMapDirectPopup ( ) ; } }
function ( data ) { markerFeatures = new Array ( ) ; $ . each ( data . building , function ( key , val ) { addMarker ( buildingLayer , val . longitude , val . latitude , val . buildingID , val . categoryID ) ; latDestination = val . latitude ; lonDestination = val . longitude ; } ) ; showMapDirectPopup ( ) ; }
function ( aEvt ) { if ( req . readyState == 4 ) { if ( req . status == 200 ) { var child = osgDB . parseSceneGraph ( JSON . parse ( req . responseText ) ) ; if ( cbfunc ) { cbfunc ( child ) ; } node . addChild ( child ) ; removeLoading ( node , child ) ; osg . log ( "success " + url ) ; } else { removeLoading ( node , child ) ; osg . log ( "error " + url ) ; } } }
function ( input , st ) { var jsonObj = input . getJSON ( ) ; var check = function ( o ) { if ( o . Name ) { return true ; } return false ; } ; if ( ! check ( jsonObj ) ) { return false ; } if ( ! osgDB . ObjectWrapper . serializers . osg . Object ( input , st ) ) { return false ; } if ( jsonObj . Translate ) { st . setTranslate ( jsonObj . Translate ) ; } return true ; }
function ( input , st ) { var jsonObj = input . getJSON ( ) ; var check = function ( o ) { if ( o . Name ) { return true ; } return false ; } ; if ( ! check ( jsonObj ) ) { return false ; } if ( ! osgDB . ObjectWrapper . serializers . osg . Object ( input , st ) ) { return false ; } if ( jsonObj . Quaternion ) { st . setQuaternion ( jsonObj . Quaternion ) ; } return true ; }
function ( ) { same ( osg . Vec2 . normalize ( [ 2 , 4 ] , [ ] ) , [ 0.4472135954999579 , 0.8944271909999159 ] , "test normalize" ) ; same ( osg . Vec2 . normalize ( [ 0 , 0 ] , [ ] ) , [ 0.0 , 0.0 ] , "test normalize" ) ; }
function ( ) { var state = new osg . State ( ) ; state . setGraphicContext ( createFakeRenderer ( ) ) ; var stateSet0 = new osg . StateSet ( ) ; stateSet0 . setAttributeAndMode ( new osg . Material ( ) ) ; var stateSet1 = new osg . StateSet ( ) ; stateSet1 . setTextureAttributeAndMode ( 0 , new osg . Texture ( undefined ) ) ; state . pushStateSet ( stateSet0 ) ; state . pushStateSet ( stateSet1 ) ; state . apply ( ) ; }
function ( ) { var ba = { "Array" : { "Uint16Array" : { "Elements" : [ 0.01727 , - 0.00262 , 3.0 ] , "Size" : 3 } } , "ItemSize" : 3 , "Type" : "ARRAY_BUFFER" , "UniqueID" : 10 } ; var input = new osgDB . Input ( ba ) ; var o = input . readBufferArray ( ) ; var o2 = input . setJSON ( { "UniqueID" : 10 } ) . readBufferArray ( ) ; ok ( o2 . getElements ( ) [ 2 ] === 3.0 , "readBufferArray with new array typed inlined" ) ; }
function ( ) { if ( window . setTimeout ) { window . setTimeout ( function ( ) { if ( config . timeout ) { clearTimeout ( config . timeout ) ; } config . blocking = false ; process ( ) ; } , 13 ) ; } else { config . blocking = false ; process ( ) ; } }
function ( ) { var li = document . getElementsByTagName ( "li" ) ; for ( var i = 0 ; i < li . length ; i ++ ) { if ( li [ i ] . className . indexOf ( "pass" ) > - 1 ) { li [ i ] . style . display = filter . checked ? "none" : "" ; } } }
function fail ( message , exception , callback ) { if ( typeof console !== "undefined" && console . error && console . warn ) { console . error ( message ) ; console . error ( exception ) ; console . warn ( callback . toString ( ) ) ; } else if ( window . opera && opera . postError ) { opera . postError ( message , exception , callback . toString ) ; } }
function extend ( a , b ) { for ( var prop in b ) { a [ prop ] = b [ prop ] ; } return a ; }
function quote ( str ) { return '"' + str . toString ( ) . replace ( /"/g , '\\"' ) + '"' ; }
function ( extra ) { if ( ! this . multiline ) return '' ; var chr = this . indentChar ; if ( this . HTML ) chr = chr . replace ( /\t/g , '   ' ) . replace ( / /g , '&nbsp;' ) ; return Array ( this . _depth_ + ( extra || 0 ) ) . join ( chr ) ; }
function ( a ) { this . _depth_ += a || 1 ; }
function ( ) { equals ( makeurl ( ) , 'http://google.com/?q=hamstersoup' , 'url from module, q from test' ) ; }
function ( mode , indices ) { this . mode = osg . PrimitiveSet . POINTS ; if ( mode !== undefined ) { this . mode = mode ; } this . count = 0 ; this . offset = 0 ; this . indices = indices ; if ( indices !== undefined ) { this . count = indices . getElements ( ) . length ; } }
function ( imageSource , format ) { return osg . Texture . createFromImg ( osgDB . readImage ( imageSource ) , format ) ; }
function ( url ) { var img = new Image ( ) ; img . onerror = function ( ) { osg . warn ( "warning use white texture as fallback instead of " + url ) ; img . src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQIW2P8DwQACgAD/il4QJ8AAAAASUVORK5CYII=" ; } ; img . src = url ; return img ; }
function ( oEvent ) { var arrayBuffer = oReq . response ; if ( arrayBuffer ) { if ( callback !== undefined ) { callback ( arrayBuffer ) ; } } }
function ( input , attr ) { var jsonObj = input . getJSON ( ) ; var check = function ( o ) { if ( o . Mode !== undefined ) { return true ; } return false ; } ; if ( ! check ( jsonObj ) ) { return ; } osgDB . ObjectWrapper . serializers . osg . Object ( input , attr ) ; attr . setMode ( jsonObj . Mode ) ; }
function ( input , attr ) { var jsonObj = input . getJSON ( ) ; var check = function ( o ) { if ( o . ConstantColor !== undefined ) { return true ; } return false ; } ; if ( ! check ( jsonObj ) ) { return ; } osgDB . ObjectWrapper . serializers . osg . Object ( input , attr ) ; attr . setConstantColor ( jsonObj . ConstantColor ) ; }
function ( input , node ) { var jsonObj = input . getJSON ( ) ; var check = function ( o ) { if ( o . Matrix !== undefined ) { return true ; } return false ; } ; if ( ! check ( jsonObj ) ) { return ; } osgDB . ObjectWrapper . serializers . osg . Node ( input , node ) ; if ( jsonObj . Matrix !== undefined ) { node . setMatrix ( jsonObj . Matrix ) ; } }
function ( input , node ) { var jsonObj = input . getJSON ( ) ; var check = function ( o ) { if ( o . Matrix ) { return true ; } return false ; } ; if ( ! check ( jsonObj ) ) { return ; } osgDB . ObjectWrapper . serializers . osg . Node ( input , node ) ; if ( jsonObj . Matrix !== undefined ) { node . setMatrix ( jsonObj . Matrix ) ; } }
function ( attr ) { var type = this . getType ( ) ; if ( _ ( attr ) . isString ( ) ) { attr = type . fields [ attr ] ; } var data = _ . extend ( { } , this , { descriptors : this . descriptors . concat ( [ attr ] ) } ) ; return new PathInfo ( data ) ; }
function ( comp_src , comp_dest , alpha_src , alpha_dest ) { return ( 255 - ( Math . round ( ( 255 - comp_src ) * ( 255 - comp_dest ) ) >> 8 ) ) * alpha_src + comp_dest * alpha_dest * ( 1 - alpha_src ) ; }
function ( comp_src , comp_dest , alpha_src , alpha_dest ) { return ( ( comp_src > 128 ) ? ( 2 * comp_dest * comp_src / 255 ) : ( 255 - 2 * ( 255 - comp_dest ) * ( 255 - comp_src ) / 255 ) ) * alpha_src + comp_dest * alpha_dest * ( 1 - alpha_src ) ; }
function ( comp_src , comp_dest , alpha_src , alpha_dest ) { return ( ( comp_dest < 128 ) ? ( 2 * ( ( Math . round ( comp_src ) >> 1 ) + 64 ) ) * ( comp_dest / 255 ) : ( 255 - ( 2 * ( 255 - ( ( Math . round ( comp_src ) >> 1 ) + 64 ) ) * ( 255 - comp_dest ) / 255 ) ) ) * alpha_src + comp_dest * alpha_dest * ( 1 - alpha_src ) ; }
function ( comp_src , comp_dest , alpha_src , alpha_dest ) { return ( ( comp_src < 128 ) ? ( 2 * comp_dest * comp_src / 255 ) : ( 255 - 2 * ( 255 - comp_dest ) * ( 255 - comp_src ) / 255 ) ) * alpha_src + comp_dest * alpha_dest * ( 1 - alpha_src ) ; }
function ( tilejson ) { tilejson . attribution += mapBoxAdditAttribution ; var mapboxstreet = new wax . leaf . connector ( tilejson ) ; layersControl . addBaseLayer ( mapboxstreet , mapData . label ) ; if ( idx === 0 && ! custAdded ) { map . addLayer ( mapboxstreet ) ; } else if ( idx === mapboxMaps . length && custAdded ) { map . addLayer ( mapboxstreet ) ; $ ( "input[name=leaflet-base-layers]" ) . attr ( 'checked' , true ) ; } }
function generate_checkin_listing ( checkin ) { var listing = '<div id="check-in-id{0}" class="newsfeed-item">' + '<div id="json" class="hidden">' + '{6}' + '</div>' + '<span class="item-title">{1} is at {2}</span>' + '<br>' + '<br>' + '<span class="item-text item-time" id="time-staying-id{3}"></span>' + '<button class="btn btn-primary order-button" data-toggle="modal" onClick="javascript:order_up({5})">OrderUp</button>' + '<span class="item-text item-price">${4}</span>' + '</div>' return listing . format ( checkin . id , checkin . user , checkin . name , checkin . id , checkin . fee , checkin . id , JSON . stringify ( checkin ) ) ; }
function ( ) { var winObj = Ext . create ( 'Ext.window.Window' , { width : 868 , height : 225 , maximizable : false , modal : true , items : [ { xtype : 'addPatient' } ] } ) . show ( ) ; }
function ( personUuid , identifierType , location ) { var patient = Ext . create ( 'RaxaEmr.Pharmacy.model.patient' , { person : personUuid , identifiers : [ { identifier : Util . getPatientIdentifier ( ) . toString ( ) , identifierType : identifierType , location : location , preferred : true } ] } ) ; var PatientStore = Ext . create ( 'RaxaEmr.Pharmacy.store.Patients' ) PatientStore . add ( patient ) ; PatientStore . sync ( ) ; return PatientStore }
function ( ) { var l = Ext . getCmp ( 'mainarea' ) . getLayout ( ) ; l . setActiveItem ( 0 ) ; }
function ( ) { if ( form_num > 0 ) { Ext . getCmp ( 'form' + form_num ) . remove ( { autoDestroy : true } ) ; Ext . getCmp ( 'form' + form_num ) . hide ( ) ; form_num -- ; } store . getData ( ) . getAt ( 0 ) . getData ( ) . uuid }
function ( ) { if ( ! this . patientView ) { this . patientView = Ext . create ( 'Screener.view.PatientView' ) ; } this . getDoctorList ( ) . deselectAll ( ) ; this . getView ( ) . push ( this . patientView ) ; patientUpdate . updatePatientsWaitingTitle ( ) ; }
function ( request ) { var response = { responseText : "{\"uuid\":\"04e12695-4e25-406c-9044-342d5337280a\",\"display\":\"REGISTRATION 28/06/2012\",\"encounterDatetime\":\"2012-06-28T11:54:52.000+0400\",\"patient\":{\"uuid\":\"0f86b6a5-6dbe-46bc-ba30-4b0b234c460e\",\"display\":\"sdf xcv\",\"links\":[{\"uri\":\"http://raxajss.jelastic.servint.net/ws/rest/v1/person/0f86b6a5-6dbe-46bc-ba30-4b0b234c460e\",\"rel\":\"self\"}]},\"location\":null,\"form\":null,\"encounterType\":{\"uuid\":\"677c2593-a2ea-4029-a5ba-e261482c2077\",\"display\":\"REGISTRATION - New registration\",\"links\":[{\"uri\":\"http://raxajss.jelastic.servint.net/ws/rest/v1/encountertype/677c2593-a2ea-4029-a5ba-e261482c2077\",\"rel\":\"self\"}]},\"provider\":{\"uuid\":\"13f2c8b2-c6a4-497f-af28-6a3f88e5cae3\",\"display\":\"User Who Is Admin\",\"links\":[{\"uri\":\"http://raxajss.jelastic.servint.net/ws/rest/v1/person/13f2c8b2-c6a4-497f-af28-6a3f88e5cae3\",\"rel\":\"self\"}]},\"obs\":[],\"orders\":[],\"voided\":false,\"links\":[{\"uri\":\"http://raxajss.jelastic.servint.net/ws/rest/v1/encounter/04e12695-4e25-406c-9044-342d5337280a\",\"rel\":\"self\"},{\"uri\":\"http://raxajss.jelastic.servint.net/ws/rest/v1/encounter/04e12695-4e25-406c-9044-342d5337280a?v=full\",\"rel\":\"full\"}],\"resourceVersion\":\"1.8\"}" , status : 201 } request . success = 'true' ; request . callback ( null , true , response ) ; expect ( request . jsonData . patient ) . toEqual ( "0f86b6a5-6dbe-46bc-ba30-4b0b234c460e" ) ; }
function ( blockKey ) { var block = self . blocks [ blockKey ] ; if ( block . model == undefined ) { block . model = { } ; } _ . extend ( block . model , block . page . model ) ; block . render ( ) ; console . log ( self . name + ": EL: " , block . el ) ; $ ( self . el ) . append ( block . el ) ; }
function ( blockKey ) { var block = self . blocks [ blockKey ] ; if ( block . model == undefined ) { block . model = { } ; } _ . extend ( block . model , block . page . model ) ; block . render ( ) ; console . log ( self . name + ": EL: " , block . el ) ; $ ( self . el ) . append ( block . el ) ; }
function ( ) { var ieRange , endRange , startRange , range , sel ; range = rangy . createRange ( ) ; range . setStart ( this . startContainer , this . startOffset ) ; range . setEnd ( this . endContainer , this . endOffset ) ; sel = rangy . getSelection ( ) ; sel . setSingleRange ( range ) ; }
function footer_onclick ( event ) { if ( mode === 'normal' ) { var dataset = event . target . dataset ; if ( dataset && typeof dataset . origin !== 'undefined' ) { Applications . getByOrigin ( dataset . origin ) . launch ( ) ; } } }
function ls_switchPanel ( panel ) { var overlay = this . overlay ; this . unloadPanel ( overlay . dataset . panel ) ; if ( panel ) { overlay . dataset . panel = panel ; this . loadPanel ( panel ) ; } else { delete overlay . dataset . panel ; } }
function findByID ( contactID , callback ) { var options = { filterBy : [ 'id' ] , filterOp : 'equals' , filterValue : contactID } ; this . _findOne ( options , callback ) ; }
function ( a ) { dw_linkwiz . $entry . val ( a . title ) ; if ( a . title == '' || a . title . substr ( - 1 ) == ':' ) { dw_linkwiz . autocomplete_exec ( ) ; } else { if ( jQuery ( a . nextSibling ) . is ( 'span' ) ) { dw_linkwiz . insertLink ( a . nextSibling . innerHTML ) ; } else { dw_linkwiz . insertLink ( '' ) ; } } }
function browser_handleTabsBadgeClicked ( ) { if ( this . currentScreen === this . TABS_SCREEN ) { var tabId = this . createTab ( ) ; this . selectTab ( tabId ) ; this . showAwesomeScreen ( ) ; return ; } if ( this . currentScreen === this . AWESOME_SCREEN && this . previousScreen === this . PAGE_SCREEN ) { this . showPageScreen ( ) ; return ; } if ( this . currentScreen === this . AWESOME_SCREEN ) { this . deleteTab ( this . currentTab . id ) ; } this . showTabScreen ( ) ; }
function ( local ) { var remote = net . connect ( remotePort , remoteHost , function ( err ) { if ( err ) { local . end ( ) ; } else { local . pipe ( remote ) ; remote . pipe ( local ) ; } } ) ; remote . on ( 'close' , function ( ) { local . end ( ) ; } ) ; local . on ( 'end' , function ( ) { remote . end ( ) ; } ) ; }
function ( elem ) { _elem = JQuery ( elem ) ; JQuery . ajax ( { cache : false , url : 'assets/templates/comments.html?nocache=' + ( new Date ( ) ) . getTime ( ) , dataType : 'html' , success : function ( html ) { template = Handlebars . compile ( html ) ; } } ) }
function startMandelbulb ( ) { var mandelbulbCanvas = document . getElementById ( 'mandelbulb' ) ; cHeight = mandelbulbCanvas . height ; cWidth = mandelbulbCanvas . width ; context = mandelbulbCanvas . getContext ( "2d" ) ; context . fillRect ( 0 , 0 , cWidth , cHeight ) ; pixel = DEPTH_OF_FIELD / ( ( cHeight + cWidth ) / 2 ) ; halfPixel = pixel / 2 ; image = context . getImageData ( 0 , 0 , cWidth , cHeight ) ; imageData = image . data ; animate ( ) ; }
function ( ) { process . kill ( child . pid ) ; assert . throws ( process . kill ( child . pid ) , Error ) ; }
function ( _id ) { if ( typeof _id === "undefined" ) { this . clearMods ( ) ; } else if ( typeof _id === "number" ) { this . mods . splice ( _id , 1 ) ; } else { for ( var i = 0 ; i < this . mods . length ; i ++ ) { var mod = this . mods [ i ] ; if ( mod . name == _id ) { this . mods . splice ( i , 1 ) ; } } } return this ; }
function ( name , modulator , type ) { var type = type || "+" ; var m = { type : type , operands : [ this [ name ] , modulator ] , name : name , NO_MEMO : true } ; this [ name ] = m ; modulator . modding . push ( { ugen : this , mod : m } ) ; this . mods . push ( m ) ; Gibberish . dirty ( this ) ; return modulator ; }
function ( ) { var n = $ ( "#navtopr" ) ; var a = $ ( "<a>SS" ) . bind ( "click" , $SS . options . show ) ; n . get ( ) . removeChild ( n . get ( ) . childNodes [ 2 ] ) ; return $ ( "#navtopr>a:last-child" ) . before ( $ ( "<span>] [" ) . append ( a ) . append ( document . createTextNode ( "] [" ) ) ) ; }
function ( animal ) { var environment = { 'canvas' : that . canvas , 'force' : that . force , 'catContainer' : that . catContainer , 'markerContainer' : that . markerContainer } ; for ( var envName in environment ) { animal [ envName ] = environment [ envName ] ; } ; }
function ( ) { if ( d3 . event . target == that . canvas . node ( ) ) { if ( d3 . event . ctrlKey ) { var newMouse = new Mouse ( that ) ; that . mice . push ( newMouse ) ; } else { var newCat = new Cat ( that ) ; that . cats . push ( newCat ) ; catNames . push ( 'shreda' ) ; redraw ( ) ; } that . force . start ( ) ; } }
function ( manager ) { that . manager = manager ; manager . loadEnvironment ( that ) ; that . selector = that . canvas . select ( '#' + selectorGroupId ) ; that . buttons . rotate = that . selector . select ( '#buttonRotate' ) ; that . buttons . rotate . on ( 'mousedown' , that . buttonRotatePress ) ; }
function Attribute ( validator , name , schema , instance ) { this . validator = validator ; this . name = name ; this . schema = schema ; this . value = schema [ name ] ; this . instance = instance ; return this ; }
function ( ) { var valid = true ; if ( helpers . isNumber ( this . instance ) ) { if ( this . schema . exclusiveMinimum && this . schema . exclusiveMinimum === true ) { valid = this . instance > this . value ; } else { valid = this . instance >= this . value ; } } if ( ! valid ) { return "minumum" ; } }
function ( ) { var valid = true ; if ( helpers . isNumber ( this . instance ) ) { if ( this . schema . exclusiveMaximum && this . schema . exclusiveMaximum === true ) { valid = this . instance < this . value ; } else { valid = this . instance <= this . value ; } } if ( ! valid ) { return "maximum" ; } }
function ( ) { var valid = true ; if ( this . value && this . validator . schemas [ this . value ] ) { this . validator . validateSchema ( this . instance , this . validator . schemas [ this . value ] ) ; } else { return "no such schema: " + this . value ; } }
function ( ) { var valid = true ; if ( helpers . isString ( this . instance ) ) { valid = ( this . instance . match ( this . value ) !== null ) ; } if ( ! valid ) { return "pattern" ; } }
function ( ) { var valid = true ; valid = ( helpers . isString ( this . instance ) && helpers . isFormat ( this . instance , this . value ) ) ; if ( ! valid ) { return "format" ; } }
function ( obj , type ) { if ( type === 'Any' ) return true ; if ( obj == null ) return false ; return typeof type === 'function' ? obj instanceof type : _toString . call ( obj ) === '[object ' + type + ']' ; }
function ( arr , type , index ) { if ( type === 'Any' ) return true ; index >>>= 0 ; var len = arr . length ; for ( ; index < len ; index ++ ) if ( ! this . isType ( arr [ index ] , type ) ) return false ; return true ; }
function ( e ) { console . log ( 'Creating or upgrading media database' ) ; var db = openRequest . result ; var existingStoreNames = db . objectStoreNames ; for ( var i = 0 ; i < existingStoreNames . length ; i ++ ) { db . deleteObjectStore ( existingStoreNames ) ; } var filestore = db . createObjectStore ( 'files' , { keyPath : 'name' } ) ; mediadb . indexes . forEach ( function ( indexName ) { filestore . createIndex ( indexName , indexName ) ; } ) ; }
function addThumbnail ( imagenum ) { var li = document . createElement ( 'li' ) ; li . dataset . index = imagenum ; li . classList . add ( 'thumbnail' ) ; thumbnails . appendChild ( li ) ; var imagedata = images [ imagenum ] ; var url = URL . createObjectURL ( imagedata . metadata . thumbnail ) ; li . style . backgroundImage = 'url("' + url + '")' ; }
function ( passageId ) { this . version ( passageId , this . version ( passageId ) , false ) ; this . _storedReference ( passageId , this . _storedReference ( passageId ) , false ) ; this . _restoreMenuOptions ( passageId , this . options ( passageId ) ) ; this . _restoreInterlinearVersions ( passageId , this . interlinearVersions ( passageId ) ) ; this . _restorePassageSync ( ) ; this . _fireStateChanged ( passageId ) ; }
function ( passageId , options ) { var menuOptions = $ . isArray ( options ) ? options : options . split ( "," ) ; $ . shout ( "initialise-passage-display-options" , { passageId : passageId , menuOptions : menuOptions } ) ; }
function ( passageId ) { $ . shout ( "passage-state-has-changed-" + passageId , { passageId : passageId } ) ; }
function ( event ) { if ( this . application . ninja . timeline . selectedStyle === "top" || this . application . ninja . timeline . selectedStyle === "master" ) { if ( ! event . wasSetByCode ) { if ( ! this . savedPosition ) this . savedPosition = this . topPosition ; this . application . ninja . elementMediator . setProperty ( [ this . layerData . stageElement ] , "top" , [ this . topControl . value + "px" ] , "Changing" , "timeline" ) ; } } }
function ( event ) { if ( this . application . ninja . timeline . selectedStyle === "width" || this . application . ninja . timeline . selectedStyle === "master" ) { if ( ! event . wasSetByCode ) { if ( ! this . savedPosition ) this . savedPosition = this . dtextScaleX ; this . application . ninja . elementMediator . setProperty ( [ this . layerData . stageElement ] , "width" , [ this . dtextScaleX + "px" ] , "Changing" , "timeline" ) ; } } }
function ( ) { this . trial_idx = this . trial_idx + 1 ; var curr_trial = trial_list [ this . trial_idx ] ; if ( typeof curr_trial == "undefined" ) { return this . done ( ) ; } do_trial ( this , curr_trial ) ; }
function ( err , result ) { do_check_eq ( err , null ) ; do_check_neq ( result , null ) ; result . verify ( { assertion : saved_state . assertion } , function ( err , result ) { do_check_eq ( err , null ) ; do_check_neq ( result , null ) ; do_check_eq ( result . identity , "ben@adida.net" ) ; do_check_eq ( result . message , "testmessage" ) ; run_next_test ( ) ; } ) ; }
function ( ) { var user_agent = window . navigator . userAgent || "" ; wot . env . is_mailru = user_agent . indexOf ( "MRCHROME" ) >= 0 ; if ( wot . env . is_mailru ) { wot . partner = "mail.ru" ; } }
function ( b ) { var panel = this . getTrans_peminjaman ( ) ; if ( panel . win == undefined ) { panel . win = Ext . create ( 'Earsip.view.PeminjamanWin' , { } ) ; } panel . win . show ( ) ; panel . win . action = 'update' ; }
function ( texture ) { this . _sprite = cc . Sprite . spriteWithTexture ( texture ) ; this . _percentage = 0.0 ; this . _vertexData = null ; this . _vertexDataCount = 0 ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . setContentSize ( this . _sprite . getContentSize ( ) ) ; this . _type = cc . CCPROGRESS_TIMER_RADIAL_CCW ; return true ; }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = nextTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( ) { var store = this . app . store ( 'Account' ) ; var items = store . cached ; var list = this . accountList ; var key ; var result = '' ; for ( key in items ) { if ( items . hasOwnProperty ( key ) ) { result += template . account . render ( this . _formatModel ( items [ key ] ) ) ; } } list . innerHTML = result ; }
function updateModel ( err , model ) { self . model = model ; self . render ( ) ; }
function ( ) { var $backButton = ( ! ! Ui . currentPage ) ? Util . getElementFromCache ( '#' + Ui . currentPage [ 0 ] . id + ' button.back' ) : z ( 'section.active_page' ) . find ( 'button.back' ) ; if ( $backButton . length ) { $backButton . trigger ( TAP ) ; } }
function SpeechAction ( model , controller , item , speechArray ) { this . setSpeechArray ( speechArray ) ; this . currentIndex = 0 ; SpeechAction . baseConstructor . call ( this , model , controller ) ; this . type = "Speech" ; this . speechItem = new ACItemHandler ( this . model , item , this . type ) ; this . speechItem . addActionListener ( this ) ; }
function ( src , evt ) { ViewItemContainer . superClass . doAction . call ( this , src , evt ) ; if ( evt . type == "appendedItem" ) { this . appendViewItemAndChildren ( evt . item ) ; } else if ( evt . type == "removeItem" ) { var viewItem = this . containedItems . childNodes [ evt . itemIndex ] ; viewItem . modelItem . removeActionListener ( viewItem ) ; this . containedItems . removeChildByIndex ( evt . itemIndex ) ; this . auxGroup . removeChildByIndex ( evt . itemIndex ) ; } }
function ( src , evt ) { if ( evt . type == "itemUpdated" ) { this . tellActionListeners ( this , { type : "actionUpdated" } ) ; } }
function ( ) { var result = SpeechAction . superClass . toXML . call ( this ) ; result . setAttribute ( "speech" , htmlspecialchars ( this . speechArray . join ( "|" ) ) ) ; this . speechItem . addToXML ( result ) ; return result ; }
function ( areConditionsMet ) { if ( areConditionsMet ) { if ( this . targetItem . item != null ) { if ( this . destItem . item != null ) { this . targetItem . item . moveItem ( this . destItem . item ) ; } else { } } } return true ; }
function ( ) { if ( this . owner == null ) { this . params . elev = 0 ; } else if ( this . owner . params != null ) { if ( this . owner . params . elev != null ) this . params . elev = this . owner . params . elev ; if ( this . owner . params . ht != null ) this . params . elev += this . owner . params . ht ; } }
function ( src , evt ) { GridViewItem . superClass . doAction . call ( this , src , evt ) ; if ( evt . type == "paramChanged" ) { if ( evt . name == 'speech' ) { this . doSpeech ( evt . value ) ; } } }
function ( target ) { if ( this . owner ) { this . owner . removeItem ( this ) ; } target . appendItem ( this ) ; }
function ShadowElement ( base , showInvisible ) { ShadowElement . baseConstructor . call ( this , "g" ) ; this . setBaseElement ( base ) ; this . showInvisible = showInvisible ; if ( ! this . showInvisible ) this . hide ( ) ; this . shadowID = gShadowElementIdIndex ++ ; this . isVisible = true ; }
function ( err ) { var prefix = '[server.fontomas.font.download] (' + http . req . url + ')' ; if ( err && err . code ) { callback ( prefix + 'File not found' ) ; return ; } if ( err ) { callback ( prefix + 'Unexpected error: ' + ( err . stack || err ) ) ; return ; } callback ( prefix + 'Generic error' ) ; }
function ( err ) { var prefix = '[server.static] (' + http . req . url + ')' ; if ( err && err . code ) { callback ( prefix + 'File not found' ) ; return ; } if ( err ) { callback ( prefix + 'Unexpected error: ' + ( err . stack || err ) ) ; return ; } callback ( prefix + 'Generic error' ) ; }
function getSpecialClick ( key ) { if ( key === 'backspace' ) { return deleteJamo ; } if ( key === 'BACKSPACE' ) { return deleteSyllable ; } if ( key === 'shift' ) { return showUpperTab ; } if ( key === 'SHIFT' ) { return showLowerTab ; } if ( key === 'spacebar' || key === 'SPACEBAR' ) { return insertSpace ; } }
function deleteItem ( id ) { if ( confirm ( "Wollen sie diesen Beitrag wirklich löschen?" ) ) { $ . ajax ( { type : "POST" , url : rating_url2 , data : "delete=0&id=" + id , success : function ( html ) { if ( html != "" ) { $ ( "#" + html ) . remove ( ) ; } } } ) ; } }
function ( e ) { if ( e . keyCode == 27 ) { this . undoEdition ( ) ; this . applyMode ( "view" ) ; } else { this . update ( ) ; if ( ! e . altKey && ! e . shiftKey && e . keyCode == 13 ) { this . applyMode ( "view" ) ; } } }
function ( ) { var me = this ; me . $el . on ( "click" , ".view-editable,.view-editable-empty" , null , function ( ) { me . onEditableClick ( ) ; } ) ; me . $el . on ( "keyup" , ".editor-editable textarea" , null , function ( e ) { me . onKeyUp ( e ) ; } ) ; }
function ( e ) { if ( e . keyCode == 27 ) { this . undoEdition ( ) ; this . applyMode ( "view" ) ; } else { this . update ( ) ; if ( e . ctrlKey && e . keyCode == 13 ) { this . applyMode ( "view" ) ; } } }
function ( ) { if ( this . $editor . css ( "display" ) != "none" ) { this . $editor . focus ( ) . select ( ) ; } }
function ( ) { var me = this ; me . $el . on ( "click" , ".view-editable .icon-edit,.view-editable-empty icon-edit" , null , function ( ) { me . onEditableClick ( ) ; } ) ; me . $el . on ( "keyup" , ".editor-editable" , null , function ( e ) { me . onKeyUp ( e ) ; } ) ; me . $el . on ( "keypress" , ".editor-editable" , null , function ( e ) { me . onKeyPress ( e ) ; } ) ; }
function ( ind ) { story = d [ 'stories' ] [ ind ] ; }
function ( ) { function _Parser ( handler ) { atok . wait ( '_' , handler ) } var Parser = atokParser . createParser ( _Parser ) it ( 'should call the handler' , function ( done ) { function handler ( token , idx , type ) { done ( ) } var p = new Parser ( handler ) p . write ( '_' ) } ) }
function ( ) { function _Parser ( handler ) { atok . wait ( '_' , '_' , handler ) } var Parser = atokParser . createParser ( _Parser ) it ( 'should call the handler' , function ( done ) { function handler ( token , idx , type ) { done ( ) } var p = new Parser ( handler ) p . write ( '_a_' ) } ) }
function ( ) { function _Parser ( handler ) { atok . wait ( '_' , '_' , handler ) } var Parser = atokParser . createParser ( _Parser ) it ( 'should not call the handler' , function ( done ) { function handler ( token , idx , type ) { done ( ) } var p = new Parser ( handler ) p . write ( '~a~' ) done ( ) } ) }
function ( query ) { if ( ! query ) return '' ; query = querystring . parse ( query ) ; for ( var name in query ) { query [ name ] = query [ name ] . replace ( HOST_PATTERN , function ( full , scheme , domain , _ , suffix ) { return scheme + decodeHost ( domain ) + ( suffix || '' ) ; } ) ; } return querystring . stringify ( query ) ; }
function ( ) { return _this . confirmation . className = '' ; }
function ( ) { return _this . confirmation . className = '' ; }
function resultsLoaded ( ) { if ( options . dev ) console . log ( document . getElementById ( "center_col" ) , document . getElementById ( "center_col" ) . style . visibility ) ; if ( document . getElementById ( "center_col" ) !== null ) { if ( document . getElementById ( "center_col" ) . style . visibility === "visible" ) { return true ; } } return false ; }
function ( json ) { table . fnClearTable ( this ) ; for ( var i = 0 ; i < json . aaData . length ; i ++ ) { var ins = ( ( json . aaData . length ) - 1 ) - i ; table . oApi . _fnAddData ( oSettings , json . aaData [ ins ] ) ; } oSettings . aiDisplay = oSettings . aiDisplayMaster . slice ( ) ; table . fnDraw ( ) ; }
function ( e , category ) { if ( ! ! category && ! ! category . save ) { category . latestGame = null ; category . save ( function ( e , savedCategory ) { eventEmitter . emit ( 'latestGameWasClearedForCategory' , savedCategory . _id ) ; if ( ! ! callback ) { callback ( savedCategory ) ; } } ) ; } else { if ( ! ! callback ) { callback ( category ) ; } } }
function ( connection ) { var schema = require ( '../db/schemas' ) [ "schemas" ] . categorySchema ; Category = connection . model ( 'category' , schema ) ; }
function ( connection ) { schema = require ( '../db/schemas' ) [ "schemas" ] . gameSchema ; Game = connection . model ( 'game' , schema ) ; }
function ( games ) { var mostRecentGame = _ . max ( games , function ( current ) { return current . played ; } ) , categoryId = savedGame . category ; eventEmitter . emit ( 'updateLatestGameForCategory' , { categoryId : categoryId , game : mostRecentGame , callback : function ( ) { callback ( savedGame ) ; } } ) ; }
function ( done ) { var teamModel = team . getModel ( ) , categoryModel = category . getModel ( ) ; testCategory = { } ; categoryModel . remove ( { } , function ( ) { teamModel . remove ( { } , function ( ) { done ( ) ; } ) ; } ) ; }
function ( returnedCategory ) { returnedCategory . latestGame . should . be . null ; done ( ) ; }
function ( ) { done ( ) ; }
function ( done ) { game . addGame ( { homeScore : 2 , awayScore : 1 , overtimeWin : false , shootoutWin : true , played : new Date ( '2012-01-01' ) , season : '2012' , arena : 'Buddy Arena' } , function ( newGame ) { game . getAllGames ( function ( games ) { games . length . should . be . above ( 1 ) ; done ( ) ; } ) ; } ) ; }
function ( db ) { $ ( '#topbar' ) . html ( '<a href="#/">Overview</a><strong id="current-db">' + db + ' <button class="down">&#160;</button></strong>' + '<ul class="tabs"><li class="all-docs"><a href="#/' + encodeURIComponent ( db ) + '/_all_docs">All Documents</a></li>' + '<li class="design-docs"><a href="#/' + encodeURIComponent ( db ) + '/_all_docs?startkey=%22_design/%22&endkey=%22_design0%22">Design Docs</a></li>' + '<li class="changes"><a href="#/' + encodeURIComponent ( db ) + '/_changes">Changes</a></li></ul>' ) ; }
function getAllFlightsBounds ( ) { var bounds = new OpenLayers . Bounds ( ) ; for ( fid in flights ) { bounds . extend ( flights [ fid ] . geo . bounds ) ; } return bounds ; }
function Game ( seed , graphics ) { this . seed = seed ; this . tanks = [ ] ; this . bullets = [ ] ; this . lt = 0 ; this . a = 0 ; if ( graphics ) { this . renderer = new Renderer ( graphics ) ; } }
function ( monitor ) { if ( stats . counters [ monitor . name ] !== undefined ) { monitor . check ( stats . counters [ k ] ) ; } else if ( stats . gauges [ k ] !== undefined ) { monitor . check ( stats . gauges [ k ] ) ; } }
function startOAuth ( ) { clearStorage ( ) ; var queryParams = [ 'client_id=' + appID , 'redirect_uri=' + encodeURIComponent ( getLocation ( ) + "?state=redirect" ) , 'response_type=token' , 'scope=' + encodeURIComponent ( 'friends_about_me,\                                           friends_birthday,email,friends_education_history,\                                           friends_work_history,friends_status' ) ] ; var query = queryParams . join ( '&' ) ; var url = oauthDialogUri + query ; window . console . log ( 'URL: ' , url ) ; document . location = url ; }
function ( ) { var friendsService = 'https://graph.facebook.com/fql?' ; var params = [ ACC_T + '=' + accessToken , 'q' + '=' + FRIENDS_QUERY , 'callback=owdFbInt.friendsReady' ] ; var q = params . join ( '&' ) ; var jsonp = document . createElement ( 'script' ) ; jsonp . src = friendsService + q ; document . body . appendChild ( jsonp ) ; document . body . dataset . state = 'waiting' ; }
function importSlice ( ) { var cgroup = contacts . slice ( pointer , pointer + chunkSize ) ; persistContactGroup ( cgroup , function ( ) { pointer += chunkSize ; this . pending -= chunkSize ; this . onsuccess ( ) ; } . bind ( this ) ) ; }
function ( ) { if ( this . pending > 0 ) { if ( this . pending < chunkSize ) { var cgroup = contacts . slice ( pointer , pointer + this . pending ) ; persistContactGroup ( cgroup , function ( ) { this . pending = 0 ; this . onsuccess ( ) ; } . bind ( this ) ) ; } else { ( importSlice . bind ( this ) ) ( ) ; } } }
function ( ) { try { if ( geo_object . type === 'google' ) { editor . goTo ( geo_object . geo ) ; } else { editor . loadGeoJSON ( geo_object . geo , true ) ; } return clearInterval ( intvl ) ; } catch ( _e ) { } }
function ( ) { var value = $ ( this ) . val ( ) ; if ( value . length > 0 && ! value . match ( new RegExp ( AddContact . selectedContactType . validationPattern ) ) ) { $ ( '#contact-error-status' ) . text ( $labelValidationUsercontactNotMatch ) ; ErrorUtils . addErrorStyles ( '#contact' ) ; AddContact . isValueValid = false ; } else { $ ( '#contact-error-status' ) . text ( '' ) ; ErrorUtils . removeErrorStyles ( '#contact' ) ; AddContact . isValueValid = true ; } }
function ( args ) { this . push ( [ name ] . concat ( __slice . call ( args ) ) ) ; return this ; }
function onLocationDetected ( ok , e ) { if ( e ) { console . log ( 'onLocationDetected :: ' + e ) ; } else { return ; drawISPList ( ) ; map . setLocation ( { isp : isp , status : status , lat : loc . lat , lng : loc . lng } ) ; if ( ! initialized ) { map . getMarkers ( ) ; mdl . setLocation ( loc . city , loc . state , isps ) ; initialized = true ; } } }
function ( done ) { pg . connect ( ':memory:' , onConnect ) ; function onConnect ( err , dbDriver ) { driver = dbDriver ; driver . client . run ( 'CREATE TABLE person (id INTEGER PRIMARY KEY NOT NULL, name VARCHAR(255) NOT NULL, email VARCHAR(100), age INTEGER DEFAULT 30);' , createIndex ) ; } function createIndex ( err ) { driver . client . run ( 'CREATE INDEX person_name_idx ON person (name, age)' , done ) ; } }
function ( hideFunction ) { $ ( document ) . unbind ( "click" ) ; $ ( document ) . bind ( "click" , function ( event ) { for ( var target = event . target ; target != null ; target = target . parentElement ) { if ( $ ( target ) . attr ( "notthide" ) != null ) return ; } hideFunction ( ) ; } ) ; }
function ( event ) { var $this = $ ( this ) ; var events = $this . data ( 'eventStack' ) . events ; var pos = $ . inArray ( event , events ) ; events . splice ( pos , 1 ) ; }
function ( req , res ) { var start = new Date ( ) ; statsd . increment ( 'routes.provision_js.get' ) ; res . render ( 'error' , { browserid_server : config . get ( 'browserid_server' ) , claimed : session . getClaimedEmail ( req ) , layout : false } ) ; statsd . timing ( 'routes.error' , new Date ( ) - start ) ; }
function ( event ) { $ ( this . dom ) . parent ( ) . toggleClass ( 'hidden' ) ; }
function ( key ) { if ( ! key || typeof key !== "string" ) { throw new Error ( "Resource key must be a valid string" ) ; } return WinJS . Resources . getString ( key ) . value ; }
function ( data ) { data = data . paging ; var root = this . rootNode ; root . innerHTML = util . parseTpl ( this . pageTpl , this . prepareTplConfig ( data ) ) ; this . registerEvents ( ) ; util . removeClass ( root , this . hideClass ) ; }
function ( lat , lng ) { console . log ( 'setLocation ' + uMarker ) ; if ( uMarker == null ) { map . setCenter ( new google . maps . LatLng ( lat , lng ) ) ; } else { uMarker . setPosition ( new google . maps . LatLng ( lat , lng ) ) ; win . setPosition ( aMarker . getPosition ( ) ) ; } searchCircle . setCenter ( new google . maps . LatLng ( lat , lng ) ) ; }
function ( res ) { fn ( null , res ) ; }
function ( res ) { fn ( null , res ) ; }
function ( res ) { fn ( null , res ) ; }
function ( res ) { fn ( null , res ) ; }
function ( context , token , lhsType , rhsType ) { if ( ! lhsType . isAssignable ( ) ) { context . errors . push ( new CompileError ( "left-hand-side expression is not assignable" ) ) ; return false ; } if ( ! rhsType . isConvertibleTo ( lhsType ) ) { context . errors . push ( new CompileError ( token , "cannot assign a value of type '" + rhsType . toString ( ) + "' to '" + lhsType . toString ( ) + "'" ) ) ; return false ; } return true ; }
function ( arr ) { if ( jStat . utils . isArray ( arr [ 0 ] ) ) { return arr ; } var len = arr . length , sums = new Array ( len ) , i = 1 ; sums [ 0 ] = arr [ 0 ] ; for ( ; i < len ; i ++ ) { sums [ i ] = sums [ i - 1 ] + arr [ i ] ; } return sums ; }
function ( value ) { var cases = Array . prototype . slice . call ( arguments , 1 ) ; for ( var i = 0 ; i < cases . length ; i += 1 ) { if ( cases [ i ] . matches ( value ) ) { return cases [ i ] . apply ( value ) ; } } }
function ( ) { if ( t [ 0 ] === "binop" ) tx = "(" + tx + ")" ; if ( op === "typeof" || op === "void" || op === "delete" ) { return op + " " + tx ; } else { return op + tx ; } }
function ( ) { var res = x + " " + op + " " + y ; if ( this . noComma && op === "," ) res = "(" + res + ")" ; return res ; }
function ( element , settings , message ) { if ( element . data ( 'valid' ) !== false ) { var wrapper = element . closest ( 'li' ) ; wrapper . addClass ( 'error' ) ; var errorElement = $ ( '<p class="' + settings . inline_error_class + '">' + message + '</p>' ) ; wrapper . append ( errorElement ) ; } else { element . parent ( ) . find ( 'p.' + settings . inline_error_class ) . text ( message ) ; } }
function ( err , data ) { if ( ! err && data ) { res . end ( data ) ; } else res . end ( ) ; }
function dieInFile ( res , filePath ) { res . writeHead ( 201 ) ; fs = require ( 'fs' ) ; fs . readFile ( "./application" + filePath , function ( err , data ) { if ( ! err && data ) { res . end ( data ) ; } else res . end ( ) ; } ) ; var Metrics = require ( './TDMetrics.js' ) ( "Status 201" , "201" , "Info" , filePath , function ( resp , ok ) { } ) ; }
function ( resp , ok ) { }
function resSuccess ( res , hashcode ) { res . writeHead ( 200 , { 'Content-Type' : 'text/plain' } ) ; res . end ( TDShortener . formatToURL ( hashcode ) ) ; var Metrics = require ( './TDMetrics.js' ) ( "Status 200" , "200" , "Info" , "/create/" , function ( resp , ok ) { } ) ; }
function redirect ( res , toURL ) { if ( ! toURL . match ( "http://" ) && ! toURL . match ( "https://" ) ) { toURL = "http://" + toURL ; } res . writeHead ( 302 , { 'location' : toURL } ) ; res . end ( ) ; var Metrics = require ( './TDMetrics.js' ) ( "Status 302" , "302" , "Info" , "/XXXXXXXX" , function ( resp , ok ) { } ) ; }
function ( ) { _ . bindAll ( this ) ; updateBreadcrumb ( "calculator" ) ; this . template = _ . template ( $ ( '#simulation-template' ) . html ( ) ) ; this . result_row_template = _ . template ( $ ( '#result-row-template' ) . html ( ) ) ; this . options . settings . on ( 'change display_as' , this . modelToView ) ; }
function ( resulttype ) { var title = 'EHP ' + ( resulttype == 'base' ? '' : resulttype ) ; $ ( this . result_row_template ( { 'key' : resulttype , 'title' : title } ) ) . appendTo ( $ ( 'table.results tbody' , this . el ) ) ; }
function __trap ( err ) { if ( err ) { if ( __g . context && __g . context . errorHandler ) __g . context . errorHandler ( err ) ; else throw err ; } }
function ( ) { container . find ( '.active' ) . toggleClass ( 'previous active' ) ; newSlide . toggleClass ( 'active next' ) ; if ( $ ( '.loader' ) . size ( ) > 0 ) { setTimeout ( function ( ) { $ ( '.loader' ) . remove ( ) ; } , 5000 ) ; } }
function ( ) { ProjectCheck . init ( ) ; expect ( ajaxRequests . length ) . toEqual ( 1 ) ; expect ( ajaxRequests [ 0 ] . url ) . toBe ( '/' ) ; expect ( ajaxRequests [ 0 ] . requestHeaders . Accept ) . toContain ( 'application/json' ) ; }
function ( ) { ProjectCheck . checkProjects ( ) ; expect ( ajaxRequests . length ) . toEqual ( 1 ) ; expect ( ajaxRequests [ 0 ] . url ) . toBe ( '/' ) ; expect ( ajaxRequests [ 0 ] . requestHeaders . Accept ) . toContain ( 'application/json' ) ; }
function ( data ) { switch ( data . message ) { case "login" : this . startApp ( ) ; break ; case "noUser" : this . authUser ( ) ; break ; case 'accessToken' : this . setAccessToken ( ) ; break ; } }
function showLoadingIcon ( tagControl ) { var src = "themes/photon/images/loading_blue.gif" ; var theme = localStorage [ "color" ] ; if ( theme == undefined || theme == "themes/photon/css/red.css" ) { src = "themes/photon/images/loading_red.gif" ; } tagControl . empty ( ) ; tagControl . html ( "<img class='loadingIcon' src='" + src + "' style='display: block'>" ) ; }
function getCurrentCSS ( ) { var theme = localStorage [ "color" ] ; if ( theme == undefined || theme == "themes/photon/css/red.css" ) { $ ( '.loadingIcon, .popupLoadingIcon' ) . attr ( "src" , "themes/photon/images/loading_red.gif" ) ; } else { $ ( '.loadingIcon, .popupLoadingIcon' ) . attr ( "src" , "themes/photon/images/loading_blue.gif" ) ; } }
function ( ) { var slide = getState ( this ) ; interval = this . getAttribute ( 'data-interval' ) || 2000 ; if ( slide [ 0 ] >= slide [ 1 ] && ! loop ) { return ; } ; this . xtag . slideNext . call ( this ) ; currentTimeout = setTimeout ( this . next . bind ( this ) , interval ) ; }
function ( ) { play . call ( this , this . getAttribute ( 'loop' ) != undefined ) ; }
function ( ) { spyOn ( console , 'error' ) ; spyOn ( console , 'log' ) ; var cwd = process . cwd ( ) ; this . after ( function ( ) { process . chdir ( cwd ) ; } ) ; cordova . create ( tempDir ) ; process . chdir ( tempDir ) ; cordova . platform ( ) ; expect ( console . log ) . toHaveBeenCalled ( ) ; expect ( console . error ) . not . toHaveBeenCalled ( ) ; }
function ( ) { spyOn ( console , 'error' ) ; spyOn ( console , 'log' ) ; var cwd = process . cwd ( ) ; this . after ( function ( ) { process . chdir ( cwd ) ; } ) ; process . chdir ( tempDir ) ; cordova . platform ( ) ; expect ( console . log ) . not . toHaveBeenCalled ( ) ; expect ( console . error ) . toHaveBeenCalled ( ) ; }
function ( ) { spyOn ( console , 'error' ) ; spyOn ( console , 'log' ) ; process . chdir ( tempDir ) ; cordova . platform ( 'ls' ) ; expect ( console . error ) . not . toHaveBeenCalled ( ) ; expect ( console . log ) . toHaveBeenCalledWith ( 'No platforms added. Use `cordova platforms add <platform>`.' ) ; }
function ( ) { spyOn ( console , 'error' ) ; spyOn ( console , 'log' ) ; process . chdir ( tempDir ) ; cordova . platform ( 'add' , 'android' ) ; cordova . platform ( 'ls' ) ; expect ( console . error ) . not . toHaveBeenCalled ( ) ; expect ( console . log ) . toHaveBeenCalledWith ( 'android' ) ; }
function ( ) { spyOn ( console , 'error' ) ; spyOn ( console , 'log' ) ; process . chdir ( tempDir ) ; cordova . platform ( 'add' , 'android' ) ; cordova . platform ( 'ls' ) ; expect ( console . error ) . not . toHaveBeenCalled ( ) ; expect ( console . log ) . toHaveBeenCalledWith ( 'android' ) ; }
function ( ) { spyOn ( console , 'error' ) ; spyOn ( console , 'log' ) ; process . chdir ( tempDir ) ; cordova . platform ( 'add' , 'android' ) ; cordova . platform ( 'remove' , 'android' ) ; cordova . platform ( 'ls' ) ; expect ( console . error ) . not . toHaveBeenCalled ( ) ; expect ( console . log ) . toHaveBeenCalledWith ( 'No platforms added. Use `cordova platforms add <platform>`.' ) ; }
function ( err , stderr , stdout ) { if ( err ) { console . error ( 'An error occured during git-clone of ' + repos [ target ] + ', ' , err ) ; cfg . remove_platform ( target ) ; return ; } create ( target , output , cfg ) ; }
function ( ) { var self = this ; var done = self . async ( ) ; var templateDir = this . file . src ; var handlebarsCmd = __dirname + '/../node_modules/.bin/handlebars -m ' + templateDir + '/*.handlebars -f ' + this . file . dest ; exec ( handlebarsCmd , done ) ; }
function next ( ) { var key = keyArr . shift ( ) ; if ( key ) { if ( /\.css$/ . test ( key ) ) { fs . readFile ( '../style/jx.' + key , cssCallback ) ; } else { fs . readFile ( '../src/jx.' + key + '.js' , jsCallback ) ; } } else { res . end ( ) ; } }
function ( name ) { var value = this . context [ name ] ; if ( ! er . _util . hasValue ( value ) && this . parent ) { return this . parent . get ( name ) ; } return value || null ; }
function orExpr ( iterator ) { var expr = andExpr ( iterator ) ; var oper ; if ( ( oper = iterator . next ( ) ) && oper . text == '||' ) { expr = { type : EXPR_T . or , expr1 : expr , expr2 : opExpr ( iterator ) } ; } return expr ; }
function andExpr ( iterator ) { var expr = relationExpr ( iterator ) ; var oper ; if ( ( oper = iterator . next ( ) ) && oper . text == '&&' ) { expr = { type : EXPR_T . and , expr1 : expr , expr2 : andExpr ( iterator ) } ; } return expr ; }
function relationExpr ( iterator ) { var expr = unaryExpr ( iterator ) ; var oper ; if ( ( oper = iterator . next ( ) ) && /^[><=]+$/ . test ( oper . text ) ) { iterator . next ( ) ; expr = { type : EXPR_T . relation , expr1 : expr , expr2 : unaryExpr ( iterator ) , oper : oper . text } ; } return expr ; }
function unaryExpr ( iterator ) { if ( iterator . current ( ) . text == '!' ) { iterator . next ( ) ; return { type : EXPR_T . unary , oper : '!' , expr : primaryExpr ( iterator ) } } return primaryExpr ( iterator ) ; }
function ( ) { if ( this . _m_bPurgeDirecotorInNextLoop ) { this . purgeDirector ( ) ; this . _m_bPurgeDirecotorInNextLoop = false ; } else if ( ! this . m_bInvalid ) { this . drawScene ( ) ; cc . KeypadDispatcher . sharedDispatcher ( ) . clearKeyUp ( ) ; } }
function ( dt ) { timeElapsed += dt ; this . refresh ( this . easing ( timeElapsed / duration ) ) ; if ( timeElapsed > duration ) { if ( typeof this . callback === "function" ) { this . callback ( ) ; } return false ; } else { return true ; } }
function Event ( smallimap , callback ) { this . smallimap = smallimap ; this . callback = callback ; this . refresh = __bind ( this . refresh , this ) ; this . init = __bind ( this . init , this ) ; this . queue = [ ] ; }
function ( msgid ) { if ( window . json_locale_data && json_locale_data [ "client" ] ) { var dict = json_locale_data [ "client" ] ; if ( dict [ msgid ] && dict [ msgid ] . length >= 2 && dict [ msgid ] [ 1 ] . trim ( ) != "" ) { return dict [ msgid ] [ 1 ] ; } } return msgid ; }
function ( err , collection ) { if ( err ) { return callback ( err ) ; } collection . save ( document , options , callback ) ; }
function ( session ) { var session_name = TissueStack . Admin . prototype . getCookie ( "session" ) ; if ( session_name != null && session_name != "" ) { TissueStack . Admin . prototype . session = session_name ; } else { session_name = session ; if ( session_name != null && session_name != "" ) { TissueStack . Admin . prototype . setCookie ( "session" , session_name . id , 1 ) ; } } }
function ( key ) { var keys = key . split ( '.' ) , pt = this . __attributes ; _ . each ( keys , function ( key ) { if ( pt === undefined ) { return null ; } pt = pt [ key ] ; } ) ; return pt ; }
function ( data ) { this . setSubmitInProgress ( false ) ; if ( data ) { new phpr . handleResponse ( 'serverFeedback' , data ) ; if ( ! this . id ) { this . id = data [ 'id' ] ; } if ( data . type == 'success' ) { this . publish ( "updateCacheData" ) ; this . publish ( "setUrlHash" , [ phpr . module ] ) ; } } }
function ( ) { this . map = this . model ; _ . defaults ( this . options , this . default_options ) ; this . template = _ . template ( this . options . template || cdb . templates . getTemplate ( 'geo/zoom' ) || '' ) ; }
function ( where , content ) { if ( this . isChunked ) throw new Error ( 'can not insert content after .append or .done' ) ; var elem = this . elem ; if ( insertAdjacentMethods . hasOwnProperty ( where ) === false ) { throw new Error ( 'did not understand first argument' ) ; } insertAdjacent ( this . elem , where , content ) ; return this ; }
function ( content ) { if ( this . isDone ) throw new Error ( 'can not append after .done' ) ; var elem = this . elem ; if ( elem . singleton ) throw new Error ( 'can not append to singleton element' ) ; this . isChunked = true ; insertAdjacent ( this . elem , 'beforeend' , content ) ; return this ; }
function ( ) { var elem = this . elem ; if ( elem . singleton ) throw new Error ( 'can not get content from singleton element' ) ; var pos = elem . pos ; return this . document . content . slice ( pos . afterbegin , pos . beforeend ) ; }
function insertAdjacent ( elem , where , content ) { var move = content . length ; if ( move === 0 ) return ; insertAdjacentMethods [ where ] ( elem , content , move ) ; moveParentSiblings ( elem , move ) ; }
function ( elem , content , move ) { var before = after = elem . pos . beforebegin + elem . pos . afterbegin ; replaceContent ( this , before , after , content ) ; elem . pos . beforebegin += move ; elem . pos . beforeend += move ; moveChildPointers ( elem , move ) ; }
function ( elem , content , move ) { if ( elem . singleton ) throw new Error ( 'can not insert content intro singleton element' ) ; var before = after = elem . pos . beforebegin + elem . pos . afterbegin ; replaceContent ( this , before , after , content ) ; elem . pos . beforeend += move ; moveChildPointers ( elem , move ) ; }
function ( elem , content , move ) { if ( elem . singleton ) throw new Error ( 'can not insert content intro singleton element' ) ; var before = after = elem . pos . beforeend ; replaceContent ( this , before , after , content ) ; elem . pos . beforeend += move ; }
function ( event , ui ) { ui . item . option . selected = true ; self . _trigger ( "selected" , event , { item : ui . item . option } ) ; $ ( self . element ) . trigger ( "autocompleteselected" , event , { item : ui . item . option } ) ; }
function ( event ) { event . preventDefault ( ) ; var districtId = $ ( "#district-autocomplete" ) . val ( ) ; var providerId = $ ( "#providerId-autocomplete" ) . val ( ) ? $ ( "#providerId-autocomplete" ) . val ( ) : "" ; var data = { "selectedDistrict" : districtId , "selectedProvider" : providerId } ; $ . post ( '/whp/patients/search' , data , function ( response ) { $ ( '#patients' ) . html ( response ) ; } ) }
function ( json ) { if ( json ) { this . store ( json ) ; } this . displayBanner ( ) ; this . displayFollow ( ) ; this . displayTabs ( ) ; pl ( '.preloadercompanybanner' ) . hide ( ) ; pl ( '.companybannerwrapper' ) . show ( ) ; }
function ( ) { if ( ! mapLoaded ) { if ( navigator . geolocation ) { navigator . geolocation . getCurrentPosition ( loadMap , function ( ) { alert ( 'Could not detect position.' ) ; } ) ; } } else { map . setCenter ( lonlat ) ; myRouteVector . destroyFeatures ( ) ; } }
function ( ) { var action_button = this . uiDialog . parent ( ) . find ( ':button:contains("Action")' ) ; action_button . attr ( 'id' , 'action-button' ) ; action_button . find ( '.ui-button-text' ) . text ( gettext ( 'Select' ) ) ; action_button . attr ( 'disabled' , 'disabled' ) ; action_button . addClass ( 'ui-button-disabled ui-state-disabled' ) ; this . uiDialog . dialog ( 'option' , 'title' , gettext ( 'Select an image' ) ) ; this . init_dialog_success ( ) ; }
function ( ) { var actionButton = this . uiDialog . parent ( ) . find ( ':button:contains("Action")' ) ; actionButton . attr ( 'id' , 'action-button' ) ; actionButton . find ( '.ui-button-text' ) . text ( gettext ( 'Select' ) ) ; actionButton . attr ( 'disabled' , 'disabled' ) ; actionButton . addClass ( 'ui-button-disabled ui-state-disabled' ) ; this . uiDialog . dialog ( 'option' , 'title' , gettext ( 'Select a file' ) ) ; this . init_dialog_success ( ) ; }
function ( ) { var action_button = this . uiDialog . parent ( ) . find ( ':button:contains("Action")' ) ; action_button . attr ( 'id' , 'action-button' ) ; action_button . find ( '.ui-button-text' ) . text ( gettext ( 'Select' ) ) ; action_button . attr ( 'disabled' , 'disabled' ) ; action_button . addClass ( 'ui-button-disabled ui-state-disabled' ) ; this . uiDialog . dialog ( 'option' , 'title' , gettext ( 'Select page' ) ) ; this . init_dialog_success ( ) ; }
function ( textarea ) { CKEDITOR . replace ( textarea , { extraPlugins : 'fpagelink,ffilelink,fimagelink,fcustomlink,funlink,fimage,ftable,tabletools' , removePlugins : 'scayt,menubutton,forms,image,link' , toolbar : [ [ 'Format' ] , [ 'Bold' , 'Italic' ] , [ 'NumberedList' , 'BulletedList' , 'Outdent' , 'Indent' ] , [ 'fPageLink' , 'fFileLink' , 'fImageLink' , 'fCustomLink' , 'fUnlink' ] , [ 'fImage' , 'fTable' ] , [ 'PasteText' , 'PasteFromWord' , 'RemoveFormat' ] , [ 'Maximize' ] , [ 'Source' ] ] , format_tags : 'p;h2;h3;h4' , toolbarCanCollapse : false , resize_maxWidth : 610 } ) ; }
function ( target , obj ) { var extendedObj = { } ; for ( var key in target ) { if ( target . hasOwnProperty ( key ) ) { extendedObj [ key ] = target [ key ] ; } } for ( var key in obj ) { if ( obj . hasOwnProperty ( key ) ) { extendedObj [ key ] = obj [ key ] ; } } return extendedObj ; }
function ( e , xhr , settings , error ) { switch ( xhr . status ) { case 401 : return app . vent . trigger ( 'error' , 'Authentication error, try logging in again.' ) ; case 404 : return app . vent . trigger ( 'error' , 'The server didn\'t understand that action.' ) ; case 500 : return app . vent . trigger ( 'error' , 'There was a server error, try again.' ) ; } }
function ( delta ) { var choices = this . results . find ( ".select2-result-selectable" ) , index = this . highlight ( ) ; while ( index > - 1 && index < choices . length ) { index += delta ; if ( $ ( choices [ index ] ) . hasClass ( "select2-result-selectable" ) ) { this . highlight ( index ) ; break ; } } }
function ( url ) { var match = /(?:^|;\s*)(JSESSIONID|PHPSESSID)=([^;]*)/ . exec ( document . cookie ) ; switch ( match && match [ 1 ] ) { case "JSESSIONID" : return url . replace ( /;jsessionid=[^\?]*|(\?)|$/ , ";jsessionid=" + match [ 2 ] + "$1" ) ; case "PHPSESSID" : return url . replace ( /\?PHPSESSID=[^&]*&?|\?|$/ , "?PHPSESSID=" + match [ 2 ] + "&" ) . replace ( /&$/ , "" ) ; } }
function _push ( message ) { if ( _activeRequest != null || _sse != null ) { _pushAjaxMessage ( message ) ; } else if ( _ieStream != null ) { _pushIE ( message ) ; } else if ( _jqxhr != null ) { _pushJsonp ( message ) ; } else if ( _websocket != null ) { _pushWebSocket ( message ) ; } }
function ( fn , interval ) { var timeoutId ; interval = interval || 0 ; ( function loop ( ) { timeoutId = setTimeout ( function ( ) { if ( fn ( ) === false ) { return ; } loop ( ) ; } , interval ) ; } ) ( ) ; return function ( ) { clearTimeout ( timeoutId ) ; } ; }
function ( media ) { this . inherited ( arguments ) ; if ( this . useHtml5Player ) { return ; } if ( mulberry . Device . environment == 'native' ) { mulberry . app . PhoneGap . video . play ( this . media . url ) ; } else { mulberry . app . PhoneGap . browser . url ( this . media . url ) ; } }
function ( mode ) { }
function ( ) { var div = $ ( 'dd[id="sp_criteria-element"]' ) . children ( 'div:visible:last' ) . next ( ) ; div . show ( ) ; div . children ( ) . removeAttr ( 'disabled' ) ; div = div . next ( ) ; if ( div . length === 0 ) { $ ( this ) . hide ( ) ; } }
function ( ) { if ( $ ( this ) . val ( ) == 'is in the range' ) { var criteria_value = $ ( this ) . next ( ) , index_name = criteria_value . attr ( 'id' ) , index_num = index_name . charAt ( index_name . length - 1 ) ; criteria_value . after ( $ ( '<input type="text" class="input_text">' ) . attr ( 'id' , 'sp_criteria_extra_' + index_num ) . attr ( 'name' , 'sp_criteria_extra_' + index_num ) ) . after ( ' to ' ) ; } }
function ( ) { var _self = this ; _self . _initHeader ( ) ; _self . _initBody ( ) ; _self . _initBars ( ) ; _self . _initLoadMask ( ) ; }
function ( column ) { if ( ! column . get ( 'hide' ) && column . get ( 'resizable' ) ) { adjustCount ++ ; } if ( ! column . get ( 'hide' ) && ! column . get ( 'resizable' ) ) { width -= column . get ( "el" ) . outerWidth ( ) ; } }
function ( column ) { if ( ! column . get ( 'hide' ) && column . get ( 'resizable' ) ) { var columnEl = column . get ( "el" ) ; var borderWidth = parseInt ( columnEl . css ( "border-left-width" ) ) || 0 + parseInt ( columnEl . css ( "border-right-width" ) ) || 0 ; column . set ( "width" , colWidth - borderWidth , { silent : 1 } ) ; columnEl . width ( colWidth - borderWidth ) ; } }
function ( ) { var _self = this , totalPageItem = _self . getItem ( ID_TOTAL_PAGE ) , totalCountItem = _self . getItem ( ID_TOTAL_COUNT ) ; if ( totalPageItem ) { totalPageItem . set ( 'html' , _self . _getTextItemTpl ( ID_TOTAL_PAGE ) ) ; } _self . _setCurrentPageValue ( _self . get ( ID_CURRENT_PAGE ) ) ; if ( totalCountItem ) { totalCountItem . set ( 'html' , _self . _getTextItemTpl ( ID_TOTAL_COUNT ) ) ; } }
function ( column ) { if ( ! column . get ( 'hide' ) && column . get ( 'resizable' ) ) { adjustCount ++ ; } if ( ! column . get ( 'hide' ) && ! column . get ( 'resizable' ) ) { width -= column . get ( "el" ) . outerWidth ( ) ; } }
function ( column ) { if ( ! column . get ( 'hide' ) && column . get ( 'resizable' ) ) { var columnEl = column . get ( "el" ) ; var borderWidth = parseInt ( columnEl . css ( "border-left-width" ) ) || 0 + parseInt ( columnEl . css ( "border-right-width" ) ) || 0 ; column . set ( "width" , colWidth - borderWidth , { silent : 1 } ) ; columnEl . width ( colWidth - borderWidth ) ; } }
function ( ) { var _self = this , totalPageItem = _self . getItem ( ID_TOTAL_PAGE ) , totalCountItem = _self . getItem ( ID_TOTAL_COUNT ) ; if ( totalPageItem ) { totalPageItem . set ( 'html' , _self . _getTextItemTpl ( ID_TOTAL_PAGE ) ) ; } _self . _setCurrentPageValue ( _self . get ( ID_CURRENT_PAGE ) ) ; if ( totalCountItem ) { totalCountItem . set ( 'html' , _self . _getTextItemTpl ( ID_TOTAL_COUNT ) ) ; } }
function ( ) { grid . showData ( data ) ; var height = 500 ; grid . set ( 'height' , height ) ; expect ( header . getColumnsWidth ( ) ) . toBe ( header . get ( 'width' ) - 17 ) ; grid . set ( 'forceFit' , false ) ; grid . set ( 'width' , 300 ) ; waits ( 100 ) ; runs ( function ( ) { grid . set ( 'width' , 800 ) ; } ) ; }
function ( ) { var owner = this . getInstanceOwner ( ) ; this . $ . headerComponents . destroyClientControls ( ) ; this . $ . headerComponents . createComponents ( this . headerComponents , { owner : owner } ) ; this . $ . headerComponents . resized ( ) ; }
function ( ) { var owner = this . getInstanceOwner ( ) ; this . $ . footerComponents . destroyClientControls ( ) ; this . $ . footerComponents . createComponents ( this . footerComponents , { owner : owner } ) ; this . $ . footerComponents . resized ( ) ; }
function ( ) { var $video = $ ( this ) , count = userCount [ $video . data ( 'meta' ) . identifier ] || 0 ; $video . data ( 'userCount' , count ) ; console . log ( count , Object . keys ( users ) . length ) ; _this . applyStyle ( count , Object . keys ( users ) . length , $video ) ; }
function _draw ( baseLayout , inputType , layoutMode , uppercase ) { baseLayout = baseLayout || _baseLayout ; inputType = inputType || _currentInputType ; layoutMode = layoutMode || _currentLayout ; uppercase = uppercase || false ; _currentLayout = _buildLayout ( baseLayout , inputType , layoutMode , uppercase ) ; if ( _severalLanguages ( ) ) IMERender . draw ( _currentLayout , baseLayout , _onScroll ) ; else IMERender . draw ( _currentLayout , undefined , _onScroll ) ; }
function ( ) { var mockFn = mockRequest . mock ( ) . get ( '/not-found' ) . respond ( { statusCode : 404 } ) . run ( ) ; var f1 = frisby . create ( 'test with httpbin for array of JSON objects' ) . get ( 'http://mock-request/not-found' , { mock : mockFn } ) . expectStatus ( 404 ) . toss ( ) ; }
function ( ) { var mockFn = mockRequest . mock ( ) . get ( '/test-object-array' ) . respond ( { statusCode : 200 , body : fixtures . arrayOfObjects } ) . run ( ) ; var f1 = frisby . create ( 'test with httpbin for array of JSON objects' ) . get ( 'http://mock-request/test-object-array' , { mock : mockFn } ) . expectJSON ( 'test_subjects.*' , { test_str_same : "I am the same..." , test_int : function ( val ) { expect ( val ) . toMatch ( /\d+/ ) ; } } ) . toss ( ) ; }
function ( ) { var mockFn = mockRequest . mock ( ) . get ( '/test-object-array' ) . respond ( { statusCode : 200 , body : fixtures . arrayOfObjects } ) . run ( ) ; var f1 = frisby . create ( 'test with httpbin for array of JSON objects' ) . get ( 'http://mock-request/test-object-array' , { mock : mockFn } ) . expectJSON ( 'test_subjects.*' , { test_str_same : String , test_optional : function ( val ) { expect ( val ) . toBeTypeOrNull ( String ) ; } } ) . toss ( ) ; }
function ( ) { var mockFn = mockRequest . mock ( ) . get ( '/test-object-array' ) . respond ( { statusCode : 200 , body : fixtures . arrayOfObjects } ) . run ( ) ; var f1 = frisby . create ( 'test with httpbin for array of JSON objects' ) . get ( 'http://mock-request/test-object-array' , { mock : mockFn } ) . expectJSON ( 'test_subjects.?' , { test_str : "I am a string two!" , test_int : 43 } ) . toss ( ) ; }
function ( clientState , ev , val ) { this . _currentPage = val ; this . element . html ( "Loading ..." ) . scrollTop ( 0 ) ; Doc . findOne ( { name : val } , this . proxy ( function ( docData ) { if ( Doc . dataDeferred . isResolved ( ) ) { this . show ( docData ) } else { Doc . dataDeferred . then ( this . proxy ( 'show' , docData ) ) } } ) ) ; }
function ( ) { quailTest . runTest ( 'documentAllColorsAreSet' , '252-1.html' ) ; equal ( true , quailTest . confirmIsTag ( 'html' ) , 'Document is set' ) ; quailTest . runTest ( 'documentAllColorsAreSet' , '252-2.html' ) ; equal ( true , quailTest . confirmIsEmpty ( ) , 'Results are empty' ) ; quailTest . runTest ( 'documentAllColorsAreSet' , '252-3.html' ) ; equal ( true , quailTest . confirmIsEmpty ( ) , 'Results are empty' ) ; }
function ( data ) { var release , releases , _i , _len ; releases = [ ] ; for ( _i = 0 , _len = data . length ; _i < _len ; _i ++ ) { release = data [ _i ] ; Release . create ( data ) ; releases . push ( this . release ) ; } return releases ; }
function ( releases , resources ) { var loadReleases ; loadReleases = new HLoadReleases ( ) ; releases = loadReleases . execute ( releases ) ; resources = Resource . createCollection ( resources ) ; this . viewModel = new PlanResourcesViewmodel ( releases , resources ) ; this . viewModel . selectRelease ( this . viewModel . allReleases ( ) [ 0 ] ) ; return ko . applyBindings ( this . viewModel ) ; }
function ( radius ) { if ( radius == 0 ) return this . disable ( ) ; this . options . radius = radius ; this . enable ( ) ; this . _grouping = true ; this . _iteratePiles ( this . _map . removeLayer , this . _map ) ; this . _leafpiles = { } ; this . _iterateMarkers ( this . _pileMarker , this ) ; }
function ( mark ) { var id = L . Util . stamp ( mark ) ; this . _markers [ id ] = mark ; if ( this . _map ) { if ( this . _grouping ) this . _pileMarker ( mark ) ; else this . _map . addLayer ( mark ) ; } return this ; }
function ( ) { if ( ! this . _grouping ) { this . _iterateMarkers ( this . _map . removeLayer , this . _map ) ; this . _iteratePiles ( this . _map . addLayer , this . _map ) ; this . _grouping = true ; } }
function isHidden ( node ) { var p ; if ( node . domNode ) { node = node . domNode ; } return ( dojo . style ( node , "display" ) == "none" ) || ( dojo . style ( node , "visibility" ) == "hidden" ) || ( p = dojo . position ( node , true ) , p . y + p . h < 0 || p . x + p . w < 0 || p . h <= 0 || p . w <= 0 ) ; }
function ( data ) { data = data . data ; if ( data . length === 0 ) { callback ( null ) ; } else if ( data . length === 1 ) { var path = data [ 0 ] , value = data [ 1 ] , ver = data [ 2 ] ; callback ( null , value ) ; } else { throw new Error ( 'Unimplemented' ) ; } }
function ( value ) { var key ; key = Ext . isFunction ( hashFn ) ? hashFn . apply ( scope , arguments ) : value ; if ( ! ( key in memo ) ) memo [ key ] = fn . apply ( scope , arguments ) ; return memo [ key ] ; }
function ( ) { var Cons = b . definitions . makeConstructor ( { x : { } } ) , eg1 , eg2 ; eg1 = new Cons ( { x : 0 } ) ; strictEqual ( eg1 . x , 0 , 'numeric zero should pass through the definition correctly.' ) ; eg2 = new Cons ( { x : undefined } ) ; strictEqual ( eg2 . x , undefined , 'undefined should pass through correctly.' ) ; notStrictEqual ( eg2 . x , eg1 . x , 'undefined should pass through correctly.' ) ; }
function ( ) { var ctor , ctors , _i , _len ; ctors = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; for ( _i = 0 , _len = ctors . length ; _i < _len ; _i ++ ) { ctor = ctors [ _i ] ; if ( this [ "instanceof" ] ( ctor ) ) { return true ; } } return false ; }
function ( inScope ) { if ( ( this . right [ "instanceof" ] ( Identifier ) ) && this . right . data === 'eval' ) { return this ; } if ( ! this . left . mayHaveSideEffects ( inScope ) ) { return this . right . r ( this . raw ) . p ( this . line , this . column ) ; } return this ; }
function ( ) { if ( ! ( ( this . expr [ "instanceof" ] ( ArrayInitialiser ) ) && this . expr . members . length === 0 ) ) { return this ; } return ( new ArrayInitialiser ( [ ] ) ) . g ( ) . r ( this . raw ) . p ( this . line , this . column ) ; }
function ( ) { if ( ! ( ( this . expr [ "instanceof" ] ( ObjectInitialiser ) ) && this . expr . isOwn && this . expr . members . length === 0 ) ) { return this ; } return ( new ArrayInitialiser ( [ ] ) ) . g ( ) . r ( this . raw ) . p ( this . line , this . column ) ; }
function ( i , elt ) { elt . alpha = 0 ; elt . textElement . fadeIn ( textFadeDuration * 1000 ) ; $ ( "body" ) . append ( elt . textElement ) ; }
function ( ) { if ( ! this . get ( "comments" ) ) { this . set ( "comments" , new Comments ( ) ) ; } }
function ( options ) { Utils . debug ( "DATALIST init: " + this . el ) ; if ( options . datumCollection ) { this . datumsView = new UpdatingCollectionView ( { collection : options . datumCollection , childViewConstructor : DatumReadView , childViewTagName : "li" , childViewFormat : "latex" } ) ; } }
function ( paper , lr , cx , cy ) { var e , x = cx - 30 , y = cy ; if ( lr === "l" ) { e = paper . path ( "M " + x + "," + y + "c 0,0 -3,-30 60,0" ) ; } else { e = paper . path ( "M " + x + "," + y + "c 0,0 63,-30 60,0" ) ; } e . attr ( { "stroke-width" : "8px" } ) ; }
function ( paper , lr , cx , cy , angle ) { var x = cx - 30 , y = cy ; paper . path ( "M " + x + "," + y + "h 60" ) . attr ( { "stroke-width" : "8px" } ) . transform ( "r" + ( lr === "l" ? angle : - angle ) ) ; }
function ( paper , lr , cx , cy , angle ) { var x = cx , y = cy + 20 ; paper . path ( "M " + x + "," + ( y - 7 ) + "a 20,15 0 1 1 0.1,0" ) . attr ( { "stroke-width" : 0 , fill : "#000" } ) . transform ( "r" + ( lr === "l" ? angle : - angle ) ) ; }
function ( paper , cx , cy , size , posY , flip ) { var e , x = cx - 30 , y = cy ; e = paper . path ( "M " + x + "," + y + "l 30,30" + "l 30,-30" ) . attr ( { "stroke-width" : "8px" } ) ; }
function ( paper , cx , cy , size , posY , flip ) { var e , x = cx , y = cy - 10 ; e = paper . path ( "M " + x + "," + y + "c 0,0 50,-30 0,30" ) . attr ( { "stroke-width" : "8px" } ) ; if ( flip ) { e . transform ( "m -1 0 0 1 " + ( x * 2 ) + " 0" ) ; } }
function openEditor ( trackEvent ) { if ( ! _firstUse ) { _firstUse = true ; _editorAreaDOMRoot . classList . remove ( "minimized" ) ; } var editorType = Editor . isRegistered ( trackEvent . type ) ? trackEvent . type : "default" ; if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( editorType , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; return _currentEditor ; }
function show_tweets ( tweets , element ) { for ( t in tweets ) { var tweet = tweets [ t ] ; var t = '<li class="post">' + fmt_text ( tweet [ "text" ] ) + "<br />" ; t += '<a href="http://twitter.com/' + tweet [ "user" ] [ "screen_name" ] + '/status/' + tweet [ "id_str" ] + '">' t += '<span class="tweet description">' + fmt_date ( tweet [ "created_at" ] ) + "</span>" ; t += "</a></li>" ; element . innerHTML += t ; } }
function now ( ) { var performance = window . performance ; if ( performance && performance . now ) return performance . now ( ) ; else { if ( performance && performance . webkitNow ) return performance . webkitNow ( ) ; else return Date ( ) . getTime ( ) ; } }
function ( sounds ) { var p = document . createElement ( 'p' ) ; p . innerHTML = requests . errors document . body . appendChild ( p ) ; sounds . forEach ( function ( sound , i ) { setTimeout ( function ( ) { playSound ( sound ) ; makeDiv ( i , sound ) ; } , 100 * i ) ; } ) ; setTimeout ( function ( ) { addKeys ( sounds ) ; } , 100 * sounds . length ) ; }
function ( ) { if ( $ ( ".field" ) . val ( ) === "Name" ) { $ ( ".query" ) . autocomplete ( { source : '/search/auto/' + $ ( ".field" ) . val ( ) , minLength : 3 } ) ; } else { $ ( ".query" ) . autocomplete ( { source : '/search/auto/' + $ ( ".field" ) . val ( ) , minLength : 1 } ) ; } }
function ( ) { var model = this . model ; this . lightboxView = new LightboxView ( { model : model } ) ; this . lightboxView . show ( ) ; }
function ( ) { var $badge = $ ( '.NB-friends-findfriends-profile' , this . $modal ) . empty ( ) ; var $profile_badge ; var profile = this . profile ; $profile_badge = new NEWSBLUR . Views . SocialProfileBadge ( { model : profile } ) ; $badge . append ( $profile_badge ) ; }
function ( data ) { $ ( '.NB-modal-loading' , this . $modal ) . removeClass ( 'NB-active' ) ; this . profile = this . model . user_profile ; this . services = data . services ; this . make_profile_section ( ) ; this . make_profile_photo_chooser ( ) ; this . choose_color ( ) ; callback && callback ( ) ; }
function ( workerScriptfile ) { var self = this ; this . worker = new Worker ( workerScriptfile ? workerScriptfile : 'BitComposerWorker.js' ) ; this . worker . addEventListener ( 'message' , function ( event ) { return self . messageFromWorker ( event ) ; } , false ) ; this . refinementCallback = { } ; this . refinementDataURLs = [ ] ; this . nextLevelToSend = 0 ; this . downloadedRefinementLevels = [ ] ; this . requestedRefinement = { pendingRequests : 0 , attributeArrayBuffers : [ ] } ; this . useDebugOutput = false ; }
function setupTOC ( root_info ) { var navhud = createNavHUD ( "div#CODEXTOC.hudpanel" , root_info ) ; var toc_button = fdjtID ( "CODEXTOCBUTTON" ) ; toc_button . style . visibility = '' ; Codex . TOC = navhud ; fdjtDOM . replace ( "CODEXTOC" , navhud ) ; var flytoc = createStaticTOC ( "div#CODEXFLYTOC" , root_info ) ; Codex . Flytoc = flytoc ; fdjtDOM ( fdjtID ( "FLYTOC" ) , flytoc ) ; }
function render ( target , repos ) { var i = 0 , fragment = '' , t = $ ( target ) [ 0 ] ; for ( i = 0 ; i < repos . length ; i ++ ) { fragment += '<li><a href="' + repos [ i ] . url + '">' + repos [ i ] . name + '</a><p>' + repos [ i ] . description + '</p></li>' ; } t . innerHTML = fragment ; }
function ( ev , ui ) { var droppedObject = jQuery ( ui . draggable ) . clone ( ) ; debug . info ( 'CodeFrame drop' , droppedObj ) ; if ( droppedObject . hasClass ( 'file' ) ) { editFile ( droppedObject . attr ( "path" ) ) ; } }
function ( ) { if ( _ . isFunction ( _this . router . before ) ) { _this . router . before . call ( _this ) ; } _this . router . trigger ( 'navigate' ) ; window . scrollTo ( 0 , 0 ) ; return __super . apply ( Backbone . history , arguments ) ; }
function ( runner ) { var specs = runner . specs ( ) || [ ] ; if ( specs . length == 0 ) { return ; } createReporterDom ( runner . env . versionString ( ) ) ; doc . body . appendChild ( dom . reporter ) ; reporterView = new jasmine . HtmlReporter . ReporterView ( dom ) ; reporterView . addSpecs ( specs , self . specFilter ) ; }
function memoizeFocusedSpec ( ) { if ( specName ) { return ; } var paramMap = [ ] ; var params = doc . location . search . substring ( 1 ) . split ( '&' ) ; for ( var i = 0 ; i < params . length ; i ++ ) { var p = params [ i ] . split ( '=' ) ; paramMap [ decodeURIComponent ( p [ 0 ] ) ] = decodeURIComponent ( p [ 1 ] ) ; } specName = paramMap . spec ; }
function ( suite , dom , views ) { this . suite = suite ; this . dom = dom ; this . views = views ; this . element = this . createDom ( 'div' , { className : 'suite' } , this . createDom ( 'a' , { className : 'description' , href : '?spec=' + encodeURIComponent ( this . suite . getFullName ( ) ) } , this . suite . description ) ) ; this . appendToSummary ( this . suite , this . element ) ; }
function ( onComplete ) { try { this . func . apply ( this . spec ) ; } catch ( e ) { this . spec . fail ( e ) ; } onComplete ( ) ; }
function ( e ) { var updateOptions = { } ; updateOptions [ propertyName ] = element . value ; trackEvent . update ( updateOptions ) ; var target = _butter . getTargetByType ( "elementID" , trackEvent . popcornOptions . target ) ; if ( target ) { target . view . blink ( ) ; } }
function ( userAction ) { mw . log ( 'EmbedPlayer::toggleMute> (old state:) ' + this . muted ) ; if ( this . muted ) { this . muted = false ; var percent = this . preMuteVolume ; } else { this . muted = true ; this . preMuteVolume = this . volume ; var percent = 0 ; } this . setVolume ( percent ) ; this . setInterfaceVolume ( percent ) ; $ ( this ) . trigger ( 'onToggleMute' ) ; }
function ( schema ) { if ( schema . constructor == String ) schema = { type : schema } ; var typeChecker = this . typeFor ( schema . type ) ; if ( typeof ( typeChecker ) == 'object' ) { return this . makeSchema ( typeChecker . schema ) ; } else { return new typeChecker ( schema , this ) ; } }
function ( line ) { var currLine = this . editor . getCursor ( false ) . line ; if ( line != currLine ) this . editor . setCursor ( line ) ; else { this . editor . setCursor ( line + 1 ) ; this . editor . setCursor ( line ) ; } }
function ( msg ) { if ( msg instanceof Error ) { msg = { type : msg . type , message : msg . message , stack : msg . stack , stackArray : msg . stack . split ( '\n' ) . slice ( 1 ) . map ( trim ) } ; } else { msg = { message : msg } ; } return { error : msg } ; }
function Logger_prepareFile ( ) { var file = this . dir . clone ( ) ; file . append ( Date . now ( ) + ".log" ) ; this . _file = file ; this . _firstLog = true ; this . _writeAsync ( '[' + '\r\n' ) ; }
function Logger_log ( aType , aData , aCallback ) { if ( this . active ) { var message = JSON . stringify ( { type : aType , data : aData } ) ; if ( this . _firstLog ) { this . _firstLog = false ; } else { message = ',' + message ; } message = message + '\r\n' ; this . _writeAsync ( message , aCallback ) ; } }
function ( ) { this . _bind ( ) ; }
function ( ) { this . _initCells ( ) ; }
function getLogMessagePrefix ( kind , moduleName ) { if ( kind . fn === util . log ) { return kind . prefix + ' (' + moduleName + '): ' ; } else { return new Date ( ) . toJSON ( ) + ' ' + kind . prefix + ' (' + moduleName + '): ' ; } }
function getAvailableData ( filters , categories ) { var available = { } ; if ( categories instanceof Array ) { $ . each ( categories , function ( i , category ) { available [ category ] = getCategoryAvailableData ( filters , category ) ; } ) ; } else { available [ categories ] = getCategoryAvailableData ( filters , categories ) ; } return available ; }
function ( key , value ) { var filtering = { } ; filtering [ category ] = value [ category ] ; $ . extend ( filtering , filters ) ; var count = getIrregularidadesCount ( filtering ) ; if ( count >= 1 ) { categoryAvailableData [ i ] = value ; i ++ ; } }
function ( i , catData ) { data [ i + 1 ] = [ ] ; data [ i + 1 ] [ 0 ] = catData [ category ] ; filters [ category ] = catData [ category ] ; data [ i + 1 ] [ 1 ] = getIrregularidadesCount ( filters ) ; }
function drawPieChart ( title , filters , output , containerId ) { var wrapper = new google . visualization . ChartWrapper ( { chartType : 'PieChart' , dataTable : getGraphData ( filters , output ) , options : { title : title , width : 473 , height : 400 , backgroundColor : 'transparent' } , containerId : containerId } ) ; wrapper . draw ( ) ; return ; }
function drawCidade ( cidade , containerId ) { var wrapper = new google . visualization . ChartWrapper ( { chartType : 'ComboChart' , dataTable : getCidadeGraphData ( cidade ) , options : { title : 'Irregularidades na cidade' , width : 473 , height : 400 , backgroundColor : 'transparent' , vAxis : { title : 'Irregularidades' } , hAxis : { title : 'Programa' } , seriesType : 'bars' , isStacked : true } , containerId : containerId } ) ; wrapper . draw ( ) ; return ; }
function ( ) { that . focus ( ) ; }
function ( item , x , y ) { var view = new xmppchat . ChatBoxView ( { model : item } ) ; this . positionNewChatBox ( view . render ( ) ) ; this . views [ item . get ( 'jid' ) ] = view . show ( ) ; }
function ( property , id ) { if ( property . type !== 'NestedModel' && property . listType !== 'NestedModel' ) { return ; } var value = entity . get ( id ) ; if ( value ) { schema [ id ] . model = value ; return ; } schema [ id ] . model = new entity . vie . Entity ( { '@type' : property . nestedModelType } ) ; }
function ( callback ) { var req = Echo . StreamServer . API . request ( { "endpoint" : "search" , "data" : this . params , "recurring" : true , "onData" : function ( data ) { QUnit . ok ( data && data . entries , "Checking if the \"onData\" callback was executed after the live update request." ) ; req . abort ( ) ; callback ( ) ; } } ) ; req . send ( ) ; }
function unselect_metadata_file ( ) { selected_metadata_file = "" ; selected_libraries = [ ] ; document . getElementById ( "sel_md_pill" ) . className = "pill_incomplete" ; document . getElementById ( "icon_step_1" ) . style . display = "none" ; update_inbox ( ) ; check_submittable ( ) ; }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer2 ( ) ; s . addChild ( layer ) ; var scene = restartTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer2 ( ) ; s . addChild ( layer ) ; var scene = nextTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer2 ( ) ; s . addChild ( layer ) ; var scene = backTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = restartTransitionAction ( TRANSITION_DURATION , s ) ; if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = nextTransitionAction ( TRANSITION_DURATION , s ) ; if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = backTransitionAction ( TRANSITION_DURATION , s ) ; if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function getOptionalSpacing ( src ) { var optionalReg = /^{\d|.+\?}$/ , tmp = '' , optional , lastWasOptional ; src . split ( ' ' ) . each ( function ( token , i ) { optional = ! ! token . match ( optionalReg ) ; if ( i > 0 ) { tmp += '[-,. ]' + ( optional || lastWasOptional ? '*' : '+' ) ; } tmp += token ; lastWasOptional = optional ; } ) ; return tmp ; }
function ( index ) { var attributeIndex = $ ( gexfContent ) . find ( 'attributes' ) . filter ( '.node' ) ; if ( attributeIndex . length > 0 ) { attributeName = attributeIndex . find ( 'id=' + $ ( this ) . attr ( 'for' ) ) . attr ( 'title' ) ; } else { attributeName = $ ( this ) . attr ( 'for' ) . toLowerCase ( ) ; } attributes [ attributeName ] = $ ( this ) . attr ( 'value' ) ; }
function ( index ) { var attributeIndex = $ ( gexfContent ) . find ( 'attributes' ) . filter ( '.edge' ) ; if ( attributeIndex . length > 0 ) { attributeName = attributeIndex . find ( 'id=' + $ ( this ) . attr ( 'for' ) ) . attr ( 'title' ) ; } else { attributeName = $ ( this ) . attr ( 'for' ) . toLowerCase ( ) ; } attributes [ attributeName ] = $ ( this ) . attr ( 'value' ) ; }
function ( event , context ) { var _this = context , context = this . context ; _this . hasStarted = true ; context . beginPath ( ) ; context . moveTo ( event . _x , event . _y ) ; }
function ( ) { this . articlesDir = path . join ( this . blogDir , this . config . articles ) ; this . log ( 'creating blog directory: ' + this . blogDir ) ; if ( path . existsSync ( this . blogDir ) ) wrench . rmdirSyncRecursive ( this . blogDir ) ; fs . mkdirSync ( this . blogDir ) ; this . createArticlesDirectory ( ) ; this . createSampleArticle ( ) ; this . createThemeDirectory ( ) ; this . createBlogConfig ( ) ; }
function ( dest , template , data ) { var html = this . renderTemplate ( template , data ) , destDir = '/' + ( dest . split ( '/' ) . slice ( 1 , - 1 ) . join ( '/' ) ) ; if ( ! path . existsSync ( destDir ) ) { wrench . mkdirSyncRecursive ( destDir ) ; } fs . writeFileSync ( dest , html ) ; flipflop . info ( 'created file:\t\t' , dest ) ; }
function ( e , data ) { var x = JSON . parse ( data . jqXHR . responseText ) [ 0 ] var template = $ ( '#template-mason-brick' ) . html ( ) ; var h = Mustache . to_html ( template , x ) ; $container = $ ( '#gallery' ) . prepend ( h ) . masonry ( 'reload' ) ; }
function ( p ) { if ( this . options . snapToZoom ) { var z = this . map . getZoom ( ) , tz = Math . round ( z ) ; this . map . zoomBy ( tz - z ) ; } this . wasPinching = false ; }
function ( map , options ) { this . map = map ; this . _doubleClick = MM . bind ( this . doubleClick , this ) ; MM . addEvent ( map . parent , 'dblclick' , this . _doubleClick ) ; this . options = { } ; }
function ( err ) { if ( err ) { createHub ( ) ; } else { error ( "Connected to " + url ) ; prepareTests ( client ) ; } }
function ( ) { if ( $ ( '#tracking_id' ) . attr ( 'value' ) == '' ) { alert ( 'Нужен номер трекинга' ) ; } else { $ . ajax ( { url : "/" , type : "POST" , data : { tid : $ ( '#tracking_id' ) . attr ( 'value' ) , } , } ) . success ( function ( data ) { $ ( '.warehouse' ) . fadeIn ( 'slow' ) . append ( data ) ; $ ( 'h2' ) . fadeOut ( 'fast' ) ; } ) ; } }
function ( ) { obj = $ ( this ) . parents ( '.box' ) ; $ . ajax ( { url : "/" , type : "DELETE" , data : { id : $ ( this ) . data ( 'id' ) } , } ) . success ( function ( ) { obj . fadeOut ( 'slow' ) ; } ) ; }
function ( ) { var data = { title : this . options . title , description : this . options . description } ; this . $el . html ( Mustache . to_html ( this . template , data ) ) ; this . $el . find ( 'ul' ) . hide ( ) ; new google . ui . FastButton ( this . $el . find ( '.back' ) . get ( 0 ) , this . back ) ; return this ; }
function addDetail ( elem , ind ) { var resetKey = this . createdCategoriesListInd . indexOf ( elem . cat ) === - 1 ; if ( resetKey ) { this . pipe . del ( 'activity:' + elem . activityId + ':details' ) ; this . createdCategoriesListInd . push ( elem . cat ) ; } this . pipe . sadd ( 'activity:' + elem . activityId + ':details' , ind ) ; this . pipe . del ( 'detail:' + ind ) ; this . pipe . hmset ( 'detail:' + ind , elem ) ; }
function getYouTube ( searchLat , searchLon , searchRadius , searchQuery ) { var endpoint = 'https://gdata.youtube.com/feeds/api/videos' ; return jQuery . ajax ( { url : endpoint , data : { 'v' : 2 , 'alt' : 'json' , 'safeSearch' : 'none' , 'orderby' : 'published' , 'location' : searchLat + ',' + searchLon , 'location-radius' : searchRadius + 'km' , 'q' : searchQuery , } , dataType : 'jsonp' } ) ; }
function ( vertices ) { ++ transformed ; if ( ( transformed % 10 ) === 0 ) { console . log ( 'transformed: ' + transformed ) ; } tile . geometry = undefined ; tile . transformedGeometry = { vertices : vertices , indices : TerrainProvider . getRegularGridIndices ( width , height ) } ; tile . state = TileState . TRANSFORMED ; }
function ( context , tile ) { ++ creating ; if ( ( creating % 10 ) === 0 ) { console . log ( 'creating: ' + creating ) ; } var buffers = tile . transformedGeometry ; tile . transformedGeometry = undefined ; TerrainProvider . createTileEllipsoidGeometryFromBuffers ( context , tile , buffers ) ; tile . state = TileState . READY ; ++ ready ; if ( ( ready % 10 ) === 0 ) { console . log ( 'ready: ' + ready ) ; } }
function ( event ) { var data = event . data ; var id = data . id ; var parameters = data . parameters ; var vertices = new Float32Array ( parameters . width * parameters . height * 5 ) ; parameters . vertices = vertices ; parameters . generateTextureCoordinates = true ; parameters . interleaveTextureCoordinates = true ; HeightmapTessellator . computeVertices ( parameters ) ; postMessage ( { id : id , result : vertices } , [ vertices . buffer ] ) ; }
function ( ) { if ( this . type === "TEXT" ) { return this . content ; } var children = this . children ; if ( children . length === 1 && children [ 0 ] . type === "TEXT" ) { return children [ 0 ] . content ; } return null ; }
function ( ) { var len = 1 ; var b = buffer . slice ( 0 , len ) ; if ( len < buffer . length ) { buffer = buffer . slice ( len , buffer . length ) ; process . nextTick ( emitData ) ; } else { process . nextTick ( function ( ) { self . emit ( 'end' ) ; } ) ; } self . emit ( 'data' , b ) ; }
function ( event , notification ) { notification . close ( ) ; restorables = [ ] ; }
function ( event , notification ) { notification . close ( ) ; restorables = [ ] ; }
function ( speed ) { this . targetSpeed = speed ; if ( this . targetSpeed === null ) { this . speedBug . hide ( ) ; } else { this . speedBug . setY ( this . _calcSpeedBugY ( ) ) ; this . speedBug . show ( ) ; } this . layer . draw ( ) ; }
function ( altitude ) { this . targetAltitude = altitude ; if ( this . targetAltitude === null ) { this . altitudeBug . hide ( ) ; } else { this . altitudeBug . setY ( this . _calcAltitudeBugY ( ) ) ; this . altitudeBug . show ( ) ; } this . layer . draw ( ) ; }
function ( pitch , roll ) { }
function ( time , index , msg ) { mmap . adi . setTargetAltitude ( mmap . altitude + msg . alt_error ) ; mmap . adi . setTargetSpeed ( mmap . airspeed + msg . aspd_error ) ; }
function ( ) { var args = Array . prototype . slice . call ( arguments ) ; var text = args . shift ( ) ; return text . replace ( /\{(\d+)\}/g , function ( match , number ) { return typeof args [ number ] != 'undefined' ? args [ number ] : match ; } ) ; }
function ( value , attr , required , model ) { var isRequired = _ . isFunction ( required ) ? required . call ( model ) : required ; if ( ! isRequired && ! hasValue ( value ) ) { return false ; } if ( isRequired && ! hasValue ( value ) ) { return format ( messages . required , attr ) ; } }
function ( value , attr , range ) { if ( ! isNumber ( value ) || value < range [ 0 ] || value > range [ 1 ] ) { return format ( messages . range , attr , range [ 0 ] , range [ 1 ] ) ; } }
function ( value , attr , range ) { if ( ! hasValue ( value ) || trim ( value ) . length < range [ 0 ] || trim ( value ) . length > range [ 1 ] ) { return format ( messages . rangeLength , attr , range [ 0 ] , range [ 1 ] ) ; } }
function ( value , attr , pattern ) { if ( ! hasValue ( value ) || ! value . toString ( ) . match ( patterns [ pattern ] || pattern ) ) { return format ( messages . pattern , attr , pattern ) ; } }
function ( msg , line , id ) { var fileName = id . split ( '/' ) ; console . log ( fileName [ fileName . length - 1 ] + ', ' + line + ': ' + msg ) ; }
function ( data ) { if ( ! data ) { $ ( '#directory_user_result' ) . html ( 'User id (' + un + ') does not exist.' ) ; $ ( '#new_user_name_skel' ) . select ( ) ; } else { $ ( '#new_permission_user' ) . attr ( 'disabled' , false ) ; } }
function ( ) { if ( this . _m_bPurgeDirecotorInNextLoop ) { this . purgeDirector ( ) ; this . _m_bPurgeDirecotorInNextLoop = false ; } else if ( ! this . m_bInvalid ) { this . drawScene ( ) ; cc . KeypadDispatcher . sharedDispatcher ( ) . clearKeyUp ( ) ; } }
function zoomShow ( src , highSrc ) { var low = '<img id="zoomlayLow" src="' + src + '">' ; zoomlayPage . html ( low ) ; zoomlay . fadeIn ( 800 ) ; if ( highSrc ) { var high = '<img id="zoomlayHigh" src="' + highSrc + '">' ; zoomlayPage . append ( high ) ; var $high = $ ( '#zoomlayHigh' ) , $low = $ ( '#zoomlayLow' ) ; $high . load ( function ( ) { $low . hide ( ) ; $high . show ( ) ; } ) ; } }
function ( element , eventName , memo , bubble ) { if ( eventName . indexOf ( ':' ) > 0 ) { oldjQueryTrigger ( eventName , memo ? [ memo ] : null , element , ! bubble ) ; } oldPrototypeFire ( element , eventName , memo , bubble ) ; }
function ( context , args ) { var points = this . getPath ( 'toolRoot.annotation' ) . get ( 'points' ) ; for ( var i = 0 ; i < points . length ; i ++ ) { if ( Math . round ( args . x ) == Math . round ( points [ i ] [ 0 ] ) && Math . round ( args . y ) == Math . round ( points [ i ] [ 1 ] , 2 ) ) { break ; } } }
function ( args ) { var controller = this . graphControllerForPane ( args . pane ) ; controller . graphingToolStartTool ( { annotationName : args . annotationName , shape : args . shape , datadefName : args . data } ) ; this . set ( 'annotationName' , args . annotationName ) ; this . set ( 'datadefName' , args . data ) ; }
function ( ) { var html = '<iframe src="javascript:false" name="hiddenIframe" style="display:none"></iframe>' ; $ ( this ) . find ( '#create_and_edit_ssh_keypair_dialog' ) . append ( html ) ; var params = { 'button' : bt_edit_ssh_keypair , 'element_id' : 1 } ; $ ( this ) . find ( '#ssh_keypair_display_name' ) . bind ( 'paste' , params , DcmgrGUI . Util . availableTextField ) ; $ ( this ) . find ( '#ssh_keypair_display_name' ) . bind ( 'keyup' , params , DcmgrGUI . Util . availableTextField ) ; }
function ( domEvt ) { this . focus ( ) ; this . _mouseOver = true ; this . _mousePressed = true ; this . _updateState ( ) ; if ( aria . core . Browser . isChrome || aria . core . Browser . isSafari ) { this . currTarget = domEvt . currentTarget ; } }
function ( domEvt ) { if ( aria . core . Browser . isChrome || aria . core . Browser . isSafari ) { if ( this . _mousePressed && domEvt . currentTarget == this . currTarget ) { this . _performAction ( domEvt ) ; } this . currTarget = null ; } if ( this . _cfg ) { this . _mousePressed = false ; this . _updateState ( ) ; } }
function ( domEvt ) { if ( domEvt . keyCode == aria . DomEvent . KC_SPACE || domEvt . keyCode == aria . DomEvent . KC_ENTER ) { this . _keyPressed = true ; this . _updateState ( ) ; domEvt . stopPropagation ( ) ; return false ; } return true ; }
function ( domEvt ) { if ( domEvt . keyCode == aria . DomEvent . KC_SPACE || domEvt . keyCode == aria . DomEvent . KC_ENTER ) { this . _keyPressed = false ; this . _updateState ( ) ; if ( ! this . _performAction ( domEvt ) ) { domEvt . stopPropagation ( ) ; return false ; } return true ; } return true ; }
function render ( target , repos ) { var i = 0 , fragment = '' , t = $ ( target ) [ 0 ] ; for ( i = 0 ; i < repos . length ; i ++ ) { fragment += '<li><a href="' + repos [ i ] . url + '">' + repos [ i ] . name + '</a><p>' + repos [ i ] . description + '</p></li>' ; } t . innerHTML = fragment ; }
function ( data ) { var keys = [ ] ; for ( var i in data . rows ) { keys . push ( [ data . rows [ i ] . value , data . rows [ i ] . key [ 0 ] , data . rows [ i ] . key [ 1 ] ] ) ; } return keys ; }
function connectPlayer ( ) { if ( gameSocket === null ) { var urlBase = window . location . href . substr ( "http://" . length ) ; urlBase = urlBase . substr ( 0 , urlBase . indexOf ( '/' ) ) ; var relativeUrl = jsRoutes . controllers . Gaming . connectPlayer ( $ ( "#userName" ) . text ( ) ) . url ; gameSocket = new WebSocket ( "ws://" + urlBase + relativeUrl ) ; gameSocket . onmessage = receiveSummary ; } }
function ( ) { __extends ( Snake , Animal ) ; function Snake ( ) { Snake . __super__ . constructor . apply ( this , arguments ) ; } Snake . prototype . move = function ( ) { alert ( "Slithering..." ) ; return Snake . __super__ . move . call ( this , 5 ) ; } ; return Snake ; }
function ( ) { __extends ( Horse , Animal ) ; function Horse ( ) { Horse . __super__ . constructor . apply ( this , arguments ) ; } Horse . prototype . move = function ( ) { alert ( "Galloping..." ) ; return Horse . __super__ . move . call ( this , 45 ) ; } ; return Horse ; }
function ( customer , cart ) { this . customer = customer ; this . cart = cart ; return $ ( '.shopping_cart' ) . bind ( 'click' , __bind ( function ( event ) { return this . customer . purchase ( this . cart ) ; } , this ) ) ; }
function ( event ) { var ua = navigator . userAgent . toLowerCase ( ) , boolIsMac = false ; if ( ua . indexOf ( "mac" ) > - 1 ) { boolIsMac = true ; } if ( event . keyCode === 16 ) { this . _isShiftPressed = true ; } if ( ( event . keyCode === 17 ) && ! boolIsMac ) { this . _isControlPressed = true ; } if ( event . metaKey === true ) { this . _isControlPressed = true ; } }
function ( ) { var result = this . _commandFn . apply ( this , arguments ) ; if ( ! result ) { return ( new $ . Deferred ( ) ) . resolve ( ) . promise ( ) ; } else { return result ; } }
function wrapComException ( comException ) { var resultCode = comException . number & 0xffff ; return WinJS . Promise . wrapError ( { message : 'SQLite Error (Result Code ' + resultCode + ')' , resultCode : resultCode } ) ; }
function ( p , v ) { var pn = toCamelCase ( p ) ; var val = this . values [ pn ] ; if ( typeof v != "undefined" ) { if ( ! val ) { val = this . values [ pn ] = new CSSValue ( p , v ) ; } else { val . value = v ; } } return val ; }
function ( feature ) { var featureFound = accessObj . features . reduce ( function ( found , currElem ) { return found || currElem . id === feature . id ; } , false ) ; if ( ! featureFound ) { accessObj . features . push ( feature ) ; } }
function ( ) { var data = testUtilities . cloneObj ( testData . xml2jsConfig ) ; data . content [ "@" ] . src = "localFile.html" ; mockParsing ( data ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . content ) . toEqual ( "local:///localFile.html" ) ; } ) ; }
function ( ) { var failedProject , buildFailedSpy = spyOnSignal ( service . buildFailed ) . matching ( function ( info ) { return info . message === 'Build failed - CruiseControl.NET' ; } ) ; initResponse ( ) ; service . update ( ) ; failedProject = service . projects [ 'CruiseControl.NET' ] ; failedProject . buildFailed . dispatch ( failedProject ) ; expect ( buildFailedSpy ) . toHaveBeenDispatched ( 1 ) ; }
function ( ) { var fixedProject , buildFixedSpy = spyOnSignal ( service . buildFixed ) . matching ( function ( info ) { return info . message === 'Build fixed - CruiseControl.NET' ; } ) ; initResponse ( ) ; service . update ( ) ; fixedProject = service . projects [ 'CruiseControl.NET' ] ; fixedProject . buildFixed . dispatch ( fixedProject ) ; expect ( buildFixedSpy ) . toHaveBeenDispatched ( 1 ) ; }
function ( ) { var failedBuildsCount = 0 ; var message = 'Build failed' ; var details = 'Build 123 failed' ; this . create = function ( ) { return { message : message , details : details , url : 'http://example.com/project/build/100' , state : { failedBuildsCount : failedBuildsCount } } ; } ; this . withFailedBuilds = function ( amount ) { if ( amount === 0 ) { message = 'Build fixed' ; details = 'Build 123 fixed' ; } else { message = 'Build failed' ; details = 'Build 123 failed' ; } failedBuildsCount = amount ; return this ; } ; }
function ( ) { notificationController . initialize ( ) ; var buildEvent = new MockBuildEventBuilder ( ) . withFailedBuilds ( 2 ) . create ( ) ; serviceController . buildFailed . dispatch ( buildEvent ) ; expect ( window . webkitNotifications . createNotification ) . toHaveBeenCalledWith ( 'img/icon-128.png' , buildEvent . message , buildEvent . details ) ; }
function ( ) { notificationController . initialize ( ) ; var buildEvent = new MockBuildEventBuilder ( ) . withFailedBuilds ( 2 ) . create ( ) ; serviceController . buildFixed . dispatch ( buildEvent ) ; expect ( window . webkitNotifications . createNotification ) . toHaveBeenCalledWith ( 'img/icon-128.png' , buildEvent . message , buildEvent . details ) ; }
function ( ) { notificationController . initialize ( ) ; var buildEvent = new MockBuildEventBuilder ( ) . withFailedBuilds ( 0 ) . create ( ) ; serviceController . buildFixed . dispatch ( buildEvent ) ; expect ( window . webkitNotifications . createNotification ) . toHaveBeenCalledWith ( 'img/icon-128.png' , 'All builds are green !' , buildEvent . details ) ; }
function projectInfo ( i , d ) { var name = $ ( d ) . attr ( 'name' ) ; return { name : name , status : $ ( d ) . attr ( 'lastBuildStatus' ) } ; }
function ( newProjectInfo ) { var oldStatus = status ; projectName = newProjectInfo . name ; status = newProjectInfo . status ; if ( ! oldStatus && newProjectInfo . status !== 'Success' ) { console . log ( 'cc build failed' , projectName ) ; buildFailed . dispatch ( this ) ; } if ( oldStatus === 'Success' && newProjectInfo . status !== 'Success' ) { buildFailed . dispatch ( this ) ; } if ( oldStatus && oldStatus !== 'Success' && newProjectInfo . status === 'Success' ) { buildFixed . dispatch ( this ) ; } return projectInstance ; }
function onBuildFailed ( buildEvent ) { var notification = { message : buildEvent . message , details : buildEvent . details , url : buildEvent . url , backgroundColor : '#0D0' , sticky : true } ; showNotification ( notification ) ; updateBadge ( buildEvent . state ) ; }
function ( ) { var transport = nodemailer . createTransport ( "sendmail" , { path : "/usr/local/bin/sendmail" , args : [ "-f online@southern.edu" ] } ) ; var mailOptions = { from : "online@southern.edu" , to : email , subject : "Online Campus Suport - Chat Transcript" , generateTextFromHTML : true , html : chatTranscript } console . log ( mailOptions ) ; console . log ( chatTranscript ) ; return 'Email response successfull!  Response was: ' + result + '\nEmail to: ' + email + '\nEmail text: \n' + chatTranscript ; }
function ( ) { var args = Array . prototype . slice . call ( arguments ) ; args . splice ( 0 , 1 ) ; $original . trigger ( 'errorful.editable' ) ; settings . validate_error . apply ( $original , args ) ; }
function ( ) { var link = 'https://www.facebook.com/dialog/oauth' + '?client_id=' + appID + '&redirect_uri=' + redirectURI + '&scope=publish_stream,share_item,offline_access,manage_pages' ; $ ( authorizeElement ) . href = link ; if ( $ ( accessTokenElement ) . value == '' ) { $ ( authorizeElement ) . set ( 'class' , 'fbconnect' ) ; $ ( authorizeElement ) . text = 'Connect to FB' ; } else { $ ( authorizeElement ) . set ( 'class' , 'fbdisconnect' ) ; $ ( authorizeElement ) . text = 'Remove FB Connection' ; } }
function ( ) { $ ( authCodeElement ) . value = '' ; $ ( fbPageIdElement ) . value = '' ; $ ( accessTokenElement ) . value = '' ; setButtonHref ( ) ; $ ( accessTokenElement ) . fireEvent ( 'change' ) ; }
function ( ) { $ ( ".title" ) . text ( this . model . get ( "title" ) ) ; $ ( ".dateCreated" ) . text ( this . model . get ( "dateCreated" ) ) ; $ ( ".description" ) . text ( this . model . get ( "description" ) ) ; }
function ( ) { while ( this . datumLatexViews . length > 0 ) { var datumLatexView = this . datumLatexViews . pop ( ) ; datumLatexView . remove ( ) ; } for ( i = 0 ; i < this . perPage ; i ++ ) { var datumId = this . model . get ( "datumIds" ) [ i ] ; if ( datumId ) { this . addOne ( datumId ) ; } } }
function ( ) { while ( this . datumLatexViews . length > 0 ) { var datumLatexView = this . datumLatexViews . pop ( ) ; datumLatexView . remove ( ) ; } for ( i = 0 ; i < this . perPage ; i ++ ) { var datumId = this . model . get ( "datumIds" ) [ i ] ; if ( datumId ) { this . addOne ( datumId ) ; } } }
function ( ) { Utils . debug ( "SESSION init: " + this . el ) ; this . sessionFieldsView = new UpdatingCollectionView ( { collection : this . model . get ( "sessionFields" ) , childViewConstructor : DatumFieldEditView , childViewTagName : "li" , format : "datum" } ) ; this . model . bind ( 'change' , this . render , this ) ; }
function ( ) { Utils . debug ( "SESSION init: " + this . el ) ; this . sessionFieldsView = new UpdatingCollectionView ( { collection : this . model . get ( "sessionFields" ) , childViewConstructor : DatumFieldEditView , childViewTagName : "li" , childViewFormat : "datum" } ) ; this . model . bind ( 'change' , this . render , this ) ; }
function ( ) { if ( this . $el . find ( ".username" ) . val ( ) != "YourNewUserNameGoesHere" ) { this . model . set ( "username" , $ ( ".username" ) . val ( ) ) ; $ ( ".confirm-password" ) . show ( ) ; } }
function ( what , func ) { ASSERT ( core ) ; console . log ( "Printing " + what + ":" ) ; for ( var name in nodes ) { console . log ( name + ":" , func ( nodes [ name ] ) ) ; } console . log ( ) ; }
function ( first , second ) { ASSERT ( typeof first === "string" || typeof first === "number" ) ; ASSERT ( typeof second === "string" || typeof second === "number" ) ; return second === EMPTY_STRING ? first : ( first === EMPTY_STRING ? second : first + "/" + second ) ; }
function ( node ) { ASSERT ( isValid ( node ) ) ; return Object . keys ( node . data ) ; }
function ( node , base ) { ASSERT ( isValid ( node ) ) ; ASSERT ( base === undefined || isValid ( base ) ) ; var path = EMPTY_STRING ; while ( node . parent && node !== base ) { if ( path === EMPTY_STRING ) { path = node . relid ; } else { path = node . relid + "/" + path ; } node = node . parent ; } return path ; }
function close_comment_form ( div ) { if ( div . find ( '.add_comment' ) . is ( ':visible' ) ) { div . find ( '.add_comment' ) . slideUp ( 400 , function ( ) { $ ( this ) . empty ( ) ; } ) ; } else { div . find ( '.message' ) . css ( 'height' , '100' ) . html ( div . data ( 'message' ) ) ; div . find ( '.message_toggle' ) . show ( ) ; } }
function ( ) { var ties = { } , key ; var i = options . tie . length ; while ( i -- ) { ties [ options . tie [ i ] . pkg ] = options . tie [ i ] . obj ; } return JSON . stringify ( ties ) ; }
function ( ) { if ( ! this . debug ) return ; var args = Array . prototype . slice . call ( arguments ) ; args . unshift ( "[" + this . identifier + "]" ) ; window . console . log . apply ( console , args ) ; }
function ( ) { if ( ! this . debug ) return ; var args = Array . prototype . slice . call ( arguments ) ; args . unshift ( "[" + this . identifier + "]" ) ; window . console . log ( args . join ( ) . replace ( "," , "" ) ) ; }
function handleKeyEvent ( editor , event ) { if ( editor . getModeForSelection ( ) !== "html" ) { return ; } if ( event . type === "keydown" && event . keyCode === 32 && event . ctrlKey ) { _showHint ( editor ) ; event . preventDefault ( ) ; } else if ( event . type === "keyup" && event . keyCode === 188 ) { _showHint ( editor ) ; } if ( hintList && hintList . isOpen ( ) ) { hintList . handleKeyEvent ( editor , event ) ; } }
function ( lastClass ) { html = '\ <span class="span-4 ' + ( lastClass ? lastClass : '' ) + '">\ <div class="tile">\ ' + this . openanchor + '\ <div class="tileimg fourthtileimage hoverlink" style="' + this . imgStyle + '"></div>\ ' + this . closeanchor + '\ <!--\ <div class="tiledays"></div>\ <div class="tiledaystext">' + this . daystext + '</div>\ <div class="tiletype"></div>\ <div class="tiletypetext">' + this . categoryUC + '</div>\ <div class="tilepoints"></div>\ -->\ <div class="tilepointstext">\     <div class="tileposted">' + this . suggested_text + '</div>\ </div>\ <p class="tiledesc">\ ' + this . openanchor + '\     <span class="tilecompany hoverlink">' + this . name + '</span><br/>\ ' + this . closeanchor + '\     <span class="tileloc">' + this . brief_address_inp + '</span><br/>\     <span class="tiledetails">' + this . mantra + '</span>\ </p>\ </div>\ </span>\ ' ; return html ; }
function ( event ) { var size = sizes ( 480 , 320 , 0 , 1 ) , w = size . width , h = size . height ; $ ( "#mapiframe" ) . prop ( "width" , w ) . prop ( "height" , h ) ; }
function ( event ) { $ ( "#mapiframe" ) . prop ( "width" , 0 ) . prop ( "height" , 0 ) ; }
function ( ) { this . err = this . err || f . apply ( this , arguments ) ; return this ; }
function ( response ) { var err = "Server Error" ; if ( response . value && response . value . message ) { err += ": " + response . value . message ; } builder . selenium2 . rcPlayback . recordError ( err ) ; }
function ( xhr , textStatus , errorThrown ) { var response = builder . selenium2 . rcPlayback . parseServerResponse ( xhr . responseText ) ; if ( errorCallback ) { errorCallback ( response ) ; } else { builder . selenium2 . rcPlayback . handleError ( response ) ; } }
function ( ) { value && baidu . paramCheck ( '^(?:number|string)$' , 'baidu.dom.scrollTop' ) ; var ret = baidu . dom . _smartScroll ( 'scrollTop' ) ; return function ( value ) { return value === undefined ? ret . get ( this [ 0 ] ) : ret . set ( this [ 0 ] , value ) || this ; } }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function ( ) { $ ( '.close' ) . click ( function ( e ) { $ ( this ) . parent ( ) . fadeOut ( 1000 ) ; } ) ; update_time_staying_counters ( ) ; setInterval ( update_time_staying_counters , 1000 ) ; dispatch_checkins_request ( ) ; setInterval ( dispatch_checkins_request , 2000 ) ; MapApplet . init ( ) MapApplet . placeAllMarkers ( data ) ; }
function ( i , v ) { var id = $ ( v ) . attr ( 'id' ) ; if ( $ ( '#' + id ) . length > 0 ) return ; var repeat = $ ( v ) ; repeat . attr ( 'id' , id + '-' + i ) ; repeat . addClass ( _this . prefix + '-' + id ) ; $ ( 'body' ) . append ( repeat ) ; }
function ( x , y , ref ) { x = ( x < 0 ) ? 0 : x ; y = ( y < 0 ) ? 0 : y ; screen . drawImage ( assets [ ref . id ] . image , x , y , screen . getWidth ( ) , screen . getHeight ( ) , 0 , 0 , screen . getWidth ( ) , screen . getHeight ( ) ) ; }
function ( data ) { var lonLat = $ . parseJSON ( data ) ; var bk = this . getSelectedBuildingKey ( ) ; this . coordsCache [ bk ] = lonLat ; this . centerMapData ( this . coordsCache [ bk ] ) ; }
function ( obj ) { var sources = Array . prototype . slice . call ( arguments , 1 ) ; for ( var i = 0 ; i < sources . length ; i ++ ) { var source = sources [ i ] ; for ( var prop in source ) { obj [ prop ] = source [ prop ] ; } } return obj ; }
function ( ) { var sources = Array . prototype . slice . call ( arguments , 0 ) ; var parent = this ; var child = function ( ) { parent . apply ( this , arguments ) ; } ; child . prototype = new parent ( ) ; Pd . extend . apply ( this , [ child . prototype , parent . prototype ] . concat ( sources ) ) ; child . extend = this . extend ; return child ; }
function ( cbsArray , event , callback , context ) { if ( ! callback || ! event ) return this ; var eventCbs = cbsArray [ event ] || ( cbsArray [ event ] = [ ] ) ; eventCbs . push ( { callback : callback , context : context } ) ; return this ; }
function ( event ) { var allCbs = ( this . _cbs [ event ] || [ ] ) . concat ( this . _cbsOne [ event ] || [ ] ) ; var cbObj ; for ( var i = 0 ; i < allCbs . length ; i ++ ) { cbObj = allCbs [ i ] ; cbObj . callback . apply ( cbObj . context ) ; } delete this . _cbsOne [ event ] ; return this ; }
function ( ) { var inputval = $ ( this ) . parent ( ) . next ( ) . val ( ) ; var name = $ ( this ) . closest ( ".remote_setting" ) . attr ( "id" ) . split ( "remote_settings_" ) [ 1 ] ; if ( inputval ) { socket . send ( "request=add_filter&name=" + name + "&restring=" + inputval ) ; } }
function onOpen ( evt ) { console . log ( "autoSocket opened" , evt , socket ) ; runInit ( ) ; }
function ( r ) { me . savingflag = false ; if ( user == 'Guest' && ! r . exc ) { $dh ( me . page_layout . wrapper ) ; $ds ( me . saved_wrapper ) ; me . saved_wrapper . innerHTML = '<div style="padding: 150px 16px; text-align: center; font-size: 14px;">' + ( cur_frm . message_after_save ? cur_frm . message_after_save : 'Your information has been sent. Thank you!' ) + '</div>' ; return ; } if ( ! me . meta . istable ) { me . refresh ( r . docname ) ; } if ( call_back ) { call_back ( r ) ; } }
function ( success , error , args ) { error = error || noop ; success = success || noop ; if ( ! args . length ) { error ( "Media Object id was not sent in arguments" ) ; } var id = args [ 0 ] , audio = audioObjects [ id ] ; if ( ! audio ) { error ( "Audio Object has not been initialized" ) ; } audio . pause ( ) ; success ( ) ; }
function ( success , error , args ) { error = error || noop ; success = success || noop ; if ( ! args . length ) { error ( "Media Object id was not sent in arguments" ) ; } var id = args [ 0 ] , audio = audioObjects [ id ] ; if ( ! audio ) { error ( "Audio Object has not been initialized" ) ; } success ( audio . currentTime ) ; }
function ( success , error , args ) { error = error || noop ; success = success || noop ; if ( ! args . length ) { error ( "Media Object id was not sent in arguments" ) ; } var id = args [ 0 ] , audio = audioObjects [ id ] ; if ( ! audio ) { error ( "Audio Object has not been initialized" ) ; } success ( audio . duration ) ; }
function ( success , error , args ) { error = error || noop ; success = success || noop ; if ( ! args . length ) { error ( "Media Object id was not sent in arguments" ) ; } var id = args [ 0 ] , audio = audioObjects [ id ] ; if ( audio ) { audioObjects [ id ] = undefined ; audio . src = undefined ; } success ( ) ; }
function ( longitude , latitude , height , result ) { longitude = typeof longitude === 'undefined' ? 0.0 : CesiumMath . toRadians ( longitude ) ; latitude = typeof latitude === 'undefined' ? 0.0 : CesiumMath . toRadians ( latitude ) ; height = typeof height === 'undefined' ? 0.0 : height ; if ( typeof result === 'undefined' ) { return new Cartographic ( longitude , latitude , height ) ; } result . longitude = longitude ; result . latitude = latitude ; result . height = height ; return result ; }
function ( red , green , blue , alpha ) { this . red = typeof red === 'undefined' ? 1.0 : red ; this . green = typeof green === 'undefined' ? 1.0 : green ; this . blue = typeof blue === 'undefined' ? 1.0 : blue ; this . alpha = typeof alpha === 'undefined' ? 1.0 : alpha ; }
function ( red , green , blue , alpha ) { red = typeof red === 'undefined' ? 255.0 : red ; green = typeof green === 'undefined' ? 255.0 : green ; blue = typeof blue === 'undefined' ? 255.0 : blue ; alpha = typeof alpha === 'undefined' ? 255.0 : alpha ; return new Color ( red / 255.0 , green / 255.0 , blue / 255.0 , alpha / 255.0 ) ; }
function ( extent , ellipsoid ) { ellipsoid = ellipsoid || Ellipsoid . WGS84 ; var positions = Extent . _computePositions ( extent , ellipsoid ) ; var bs = new BoundingSphere ( positions ) ; var ellipsoidCenter = Cartesian3 . ZERO ; if ( ! ellipsoidCenter . equals ( bs . center ) ) { return Occluder . getOccludeePoint ( new BoundingSphere ( ellipsoidCenter , ellipsoid . getMinimumRadius ( ) ) , bs . center , positions ) ; } return { valid : false } ; }
function combine ( ) { var composite = { } ; var length = arguments . length ; for ( var i = 0 ; i < length ; ++ i ) { var object = arguments [ i ] ; for ( var key in object ) { if ( object . hasOwnProperty ( key ) ) { if ( composite [ key ] ) { throw new DeveloperError ( 'Duplicate member: ' + key ) ; } composite [ key ] = object [ key ] ; } } } return composite ; }
function ( word , i ) { if ( word . charAt ( 0 ) == '/' && word . charAt ( word . length - 1 ) == '/' ) { return word . substr ( 1 , word . length - 2 ) } return word . replace ( /[\-\[\]{}()*+?.,\\\^$|#\s]/g , "\\$&" ) ; }
function ( ) { var $select = $ ( this ) ; var $input = _inputAfter ( $select ) ; _disableTabstop ( $select ) ; _watchChanges ( $select , $input ) ; _initKeypressCounter ( $input ) ; _autocompleteInput ( $select , $input , _options . notfoundCss ) ; if ( _options . expandOnFocus ) { _expandOnFocus ( $select , $input , _options . expandSize ) ; } _selectallOnClick ( $input ) ; }
function _inputAfter ( $select ) { var $input = $ ( '<input/>' ) ; $input . css ( { position : 'absolute' } ) ; $input . addClass ( 'jqcombo' ) ; _positionInput ( $select , $input ) ; $input . val ( $select . find ( 'option:selected' ) . text ( ) ) ; $select . after ( $input ) ; return $input ; }
function _positionInput ( $select , $input ) { var offset = _positionCorrection ( ) ; $input . css ( { top : $select . position ( ) . top + offset . top , left : $select . position ( ) . left + offset . left , width : $select . width ( ) + offset . width , height : $select . height ( ) + offset . height } ) ; }
function ( opt_data , opt_sb ) { var output = opt_sb || new soy . StringBuilder ( ) ; output . append ( '\t\t\t<div><h3 id="folderName">' , soy . $$escapeHtml ( opt_data . folder ) , '</h3></div><div align="right" class="breadcrumb">' , ( opt_data . owner == true ) ? '<div style="float:left; margin-top:20px; margin-left:20px">Check <a id="check-all" href="javascript:void(0)">All</a> <a id="check-none" href="javascript:void(0)">None</a>&nbsp;&nbsp;&nbsp;<button class="btn btn-error btn-small disabled" id="remove-btn">Remove checked</button>&nbsp;&nbsp;&nbsp;<button class="btn btn-info btn-small disabled" id="move-btn">Move checked</button>&nbsp;&nbsp;&nbsp;<span id="optButCont"></span></div>' : '' , '<div style="width:200px;float:right;">Page <span id="start-page"></span> of <span id="last-page"></span></div><div class="pagination" style="width:205px"><ul><li class="prev disabled"><a href="javascript:void(0)" id="previousPage-btn">← Previous</a></li><li class="next disabled"><a href="javascript:void(0)" id="nextPage-btn">Next page →</a></li></ul></div></div><div><ul class="thumbnails" id="photo-list"></ul></div>' ) ; return opt_sb ? '' : output . toString ( ) ; }
function ( opt_data , opt_sb ) { var output = opt_sb || new soy . StringBuilder ( ) ; var elementList1120 = opt_data . list ; var elementListLen1120 = elementList1120 . length ; for ( var elementIndex1120 = 0 ; elementIndex1120 < elementListLen1120 ; elementIndex1120 ++ ) { var elementData1120 = elementList1120 [ elementIndex1120 ] ; output . append ( '<div class="well"><h3>' , soy . $$escapeHtml ( elementData1120 . title ) , '</h3></div><p>' , soy . $$escapeHtml ( elementData1120 . body ) , '</p>' ) ; } return opt_sb ? '' : output . toString ( ) ; }
function ( data , styleClass ) { var ids = data . split ( "," ) ; for ( var i = 0 ; i < ids . length ; i ++ ) { jQuery ( this . escapeId ( ids [ i ] ) ) . addClass ( styleClass ) ; } }
function ( name , method , message ) { $ . validator . methods [ name ] = method ; $ . validator . messages [ name ] = message !== undefined ? message : $ . validator . messages [ name ] ; if ( method . length < 3 ) { $ . validator . addClassRules ( name , $ . validator . normalizeRule ( name ) ) ; } }
function ( roundDto , answers ) { var self = this ; self . questionText = ko . observable ( ) ; self . score = ko . observable ( ) ; ko . mapping . fromJS ( roundDto , { } , self ) ; self . answers = ko . observableArray ( answers ) ; }
function ( answer , e ) { if ( self . isAudience ( ) ) return ; var dtoAnswer = ko . mapping . toJS ( answer ) ; self . hub . sendShowAnswer ( dtoAnswer ) . done ( function ( ) { console . log ( 'Sent Answer!' ) ; } ) . fail ( function ( e ) { console . warn ( e ) ; } ) ; ; }
function ( ) { for ( var nOps = undoOps . length ; nOps > 0 ; nOps -- ) { testAccount . eImapAccount . expect_runOp_begin ( 'local_undo' , 'modtags' ) ; testAccount . eImapAccount . expect_runOp_end ( 'local_undo' , 'modtags' ) ; } undoOps . forEach ( function ( x ) { x . undo ( ) ; } ) ; testAccount . expect_headerChanges ( folderView , undoHeaderExps , 'roundtrip' ) ; }
function ( ) { applyManips ( ) ; for ( var nOps = undoOps . length ; nOps > 0 ; nOps -- ) { testAccount . eImapAccount . expect_runOp_begin ( 'local_do' , 'modtags' ) ; testAccount . eImapAccount . expect_runOp_end ( 'local_do' , 'modtags' ) ; } testAccount . expect_headerChanges ( folderView , doHeaderExps , 'roundtrip' ) ; }
function ( ) { for ( var nOps = undoOps . length ; nOps > 0 ; nOps -- ) { testAccount . eImapAccount . expect_runOp_begin ( 'local_undo' , 'modtags' ) ; testAccount . eImapAccount . expect_runOp_end ( 'local_undo' , 'modtags' ) ; } undoOps . forEach ( function ( x ) { x . undo ( ) ; } ) ; testAccount . expect_headerChanges ( folderView , undoHeaderExps , 'roundtrip' ) ; }
function ( ) { applyManips ( ) ; for ( var nOps = undoOps . length ; nOps > 0 ; nOps -- ) { testAccount . eImapAccount . expect_runOp_begin ( 'local_do' , 'modtags' ) ; testAccount . eImapAccount . expect_runOp_end ( 'local_do' , 'modtags' ) ; } testAccount . expect_headerChanges ( folderView , doHeaderExps , 'roundtrip' ) ; }
function ( ) { for ( var nOps = undoOps . length ; nOps > 0 ; nOps -- ) { testAccount2 . eImapAccount . expect_runOp_begin ( 'local_undo' , 'modtags' ) ; testAccount2 . eImapAccount . expect_runOp_end ( 'local_undo' , 'modtags' ) ; } undoOps . forEach ( function ( x ) { MailUniverse . undoMutation ( x . _longtermIds ) ; } ) ; testAccount2 . expect_headerChanges ( folderView2 , undoHeaderExps , 'roundtrip' ) ; }
function ( ) { var menuitem = document . querySelector ( "span.new-wrapper i.nav-me" ) || null , avi = document . querySelector ( 'img.avatar.size32' ) || null , src = avi ? avi . src : "" ; if ( menuitem && src ) { menuitem . style . cssText = "background-image: url('" + src + "');background-position: 0 0;border-radius: 4px;height: 32px;margin: -10px 0 0;width: 32px;" ; } }
function ( ) { var method ; method = actions [ methodName ] ; if ( method == null ) { throw new Error ( "Unable to find '" + req . method + "' method in exports.actions" ) ; } if ( typeof method !== 'function' ) { throw new Error ( "The '" + req . method + "' method in exports.actions must be a function" ) ; } return method . apply ( method , req . params ) ; }
function ( ) { self . editableValue . queryApi = function ( deferred , apiAction ) { deferred . reject ( 'error' , self . errors [ 0 ] ) . promise ( ) ; } ; }
function ( e ) { if ( e . success ) { Ti . App . Properties . setString ( "token" , '' ) , Ti . App . Properties . setString ( "email" , '' ) , Ti . App . Properties . setString ( "name" , '' ) , alert ( 'Success: Logged out' ) , loginWin . open ( ) ; } else { alert ( 'Error:\\n' + ( ( e . error && e . message ) || JSON . stringify ( e ) ) ) ; } }
function any ( promisesOrValues , callback , errback , progressHandler ) { function unwrapSingleResult ( val ) { return callback ? callback ( val [ 0 ] ) : val [ 0 ] ; } return some ( promisesOrValues , 1 , unwrapSingleResult , errback , progressHandler ) ; }
function ( val ) { if ( useResolveValue ) val = resolveValue ; resolver . resolve ( val ) ; return val ; }
function ( i , e ) { if ( this ) { index = u . indexOfProp ( map_areas , "key" , this . key ) ; if ( index >= 0 ) { $ . extend ( map_areas [ index ] , this ) ; } else { map_areas . push ( this ) ; } ar = map_data . getDataForKey ( this . key ) ; if ( ar ) { $ . extend ( ar . options , this ) ; } } }
function ( i , e ) { var areaData = map_data . getDataForKey ( e . toString ( ) ) ; addShapeGroupImpl ( me , areaData , areaData . effectiveRenderOptions ( mode ) ) ; }
function ( ) { var canvas_temp , map_data = this . map_data ; canvas_temp = map_data . base_canvas ; map_data . base_canvas = this . createVisibleCanvas ( map_data ) ; $ ( map_data . base_canvas ) . hide ( ) ; $ ( canvas_temp ) . before ( map_data . base_canvas ) ; map_data . redrawSelections ( ) ; $ ( map_data . base_canvas ) . show ( ) ; $ ( canvas_temp ) . remove ( ) ; }
function ( c ) { var d = a . mapster . utils ; return { width : d . imgWidth ( c , true ) , height : d . imgHeight ( c , true ) , complete : function ( ) { return ! ! this . height && ! ! this . width ; } } ; } , setOpacity : function ( c , d ) { c . style . opacity = d ; }
function ( p , o ) { if ( this ) { l = i . indexOfProp ( m , "key" , this . key ) ; if ( l >= 0 ) { a . extend ( m [ l ] , this ) ; } else { m . push ( this ) ; } j = n . getDataForKey ( this . key ) ; if ( j ) { a . extend ( j . options , this ) ; } } }
function ( ) { return this . getSelected ( ) ; } , function ( ) { return this . isSelected ( ) ; } , { name : "get" , args : arguments , key : j , first : true , allowAsync : true , defaultReturn : "" }
function ( ) { var j ; for ( j = d . map_cache . length - 1 ; j >= 0 ; j -- ) { if ( d . map_cache [ j ] ) { e . unbind . call ( a ( d . map_cache [ j ] . image ) ) ; } } e . graphics = null ; }
function ( g , h ) { var f = h . isMask ? this . masks : this . shapes ; f . push ( { mapArea : g , options : h } ) ; }
function ( f , g ) { a ( f ) . each ( function ( j , h ) { if ( typeof h . opacity !== "undefined" ) { h . opacity = g ; } else { a ( h ) . css ( "opacity" , g ) ; } } ) ; }
function ( h , g ) { g . reset ( ) ; }
function ( e ) { if ( ! this . isSelected ( ) ) { this . addSelection ( e ) ; } else { this . removeSelection ( ) ; } return this . isSelected ( ) ; }
function ( ) { var result = '' ; $ . each ( this . data , function ( i , e ) { if ( e . isSelected ( ) ) { result += ( result ? ',' : '' ) + this . key ; } } ) ; return result ; }
function ( v ) { if ( v instanceof Error ) { v = new Error ( 'Malformed array. Error in value parsing. ' + 'Collected array data: ' + JSON . stringify ( arr ) ) ; acc = oldAcc ; acc ( v ) ; return ; } arr . push ( v ) ; if ( arr . length >= nvals ) { acc = oldAcc ; acc ( arr ) ; } }
function ( v , isEnd ) { if ( ! isEnd ) { if ( v instanceof Error ) { v = new Error ( 'Malformed array. Error in value parsing. ' + 'Collected array data: ' + JSON . stringify ( arr ) ) ; acc = oldAcc ; acc ( v ) ; return ; } arr . push ( v ) ; } else { acc = oldAcc ; acc ( arr ) ; } }
function ( ) { Ext . getBody ( ) . mask ( 'Rendering table of all results. May take some time for many students.' , 'page-load-mask' ) ; this . _minimalDatasetLoaded = true ; this . _createStore ( ) ; this . store . suspendEvents ( ) ; this . _mergeMinimalDatasetIntoStore ( ) ; this . store . resumeEvents ( ) ; Ext . getBody ( ) . unmask ( ) ; this . store . fireEvent ( 'datachanged' ) ; this . fireEvent ( 'minimalDatasetLoaded' , this ) ; }
function ( callback , scope , args ) { if ( this . _completeDatasetLoaded ) { Ext . bind ( callback , scope , args ) ( ) ; } else { this . addListener ( 'completeDatasetLoaded' , function ( ) { Ext . bind ( callback , scope , args ) ( ) ; } , this , { single : true } ) ; Ext . getBody ( ) . mask ( 'Loading all results for all students' , 'page-load-mask' ) ; this . _loadAllGroupsInPeriod ( ) ; } }
function ( ) { Ext . getBody ( ) . unmask ( ) ; if ( this . _minimalDatasetLoaded ) { this . _mergeCompleteDatasetIntoStore ( ) ; } else { this . addListener ( 'minimalDatasetLoaded' , this . _mergeCompleteDatasetIntoStore , this , { single : true } ) ; } }
function ( ) { if ( this . _completeDatasetLoaded ) { return ; } this . _completeDatasetLoaded = true ; Ext . getBody ( ) . mask ( 'Calculating table of all results. May take some time for many students.' , 'page-load-mask' ) ; this . store . suspendEvents ( ) ; this . _addAssignmentsToStore ( ) ; this . _addGroupsToStore ( ) ; this . updateScaledPoints ( ) ; this . store . resumeEvents ( ) ; this . store . fireEvent ( 'datachanged' ) ; this . fireEvent ( 'completeDatasetLoaded' , this ) ; Ext . getBody ( ) . unmask ( ) ; }
function ( ) { Ext . getBody ( ) . mask ( "Loading page" , 'page-load-mask' ) ; Ext . create ( 'devilry.statistics.Loader' , this . periodid , { listeners : { scope : this , minimalDatasetLoaded : this . _onMinimalDatasetLoaded } } ) ; }
function ( record , op ) { Ext . getBody ( ) . unmask ( ) ; if ( ! op . success ) { this . _handleComError ( 'Save settings' , op ) ; return ; } this . settings = settingData ; this . _saveReadyForExportRecord ( callback , scope ) ; }
function ( response ) { if ( response && response . html ) { $ ( '#content' ) . html ( response . html ) ; } if ( response && response . action ) { switch ( response . action ) { case 'reload' : window . location = window . location ; break ; } } }
function ( e ) { return jQuery ( '.wortspiel-area' , element ) . wordmatch ( { rootPrefix : 'lib/wordmatch/img/' , result : function ( res ) { Capkom . profile . set ( { wordmatch : res } ) ; Capkom . clickNext ( ) ; return jQuery ( '.wortspiel-area' , element ) . wordmatch ( 'destroy' ) ; } , questions : Capkom . wordmatchQuestions } ) ; }
function ( res ) { Capkom . profile . set ( { wordmatch : res } ) ; done ( ) ; Capkom . clickNext ( ) ; return jQuery ( '.wortspiel-area' , element ) . wordmatch ( 'destroy' ) ; }
function ( element , done ) { return jQuery ( '.wortspiel-area' , element ) . wordmatch ( { rootPrefix : 'lib/wordmatch/img/' , result : function ( res ) { Capkom . profile . set ( { wordmatch : res } ) ; done ( ) ; Capkom . clickNext ( ) ; return jQuery ( '.wortspiel-area' , element ) . wordmatch ( 'destroy' ) ; } , questions : Capkom . wordmatchQuestions } ) ; }
function ( stage ) { var _ref9 ; return "<div id=\"" + stage . name + "\">\n    <table class=\"ui-widget-content\"><tr><td style=\"vertical-align: top;padding: 1em;\">\n        <div>\n            <img width=\"200\" class=\"stage-image " + ( ( _ref9 = stage . image ) != null ? _ref9 : { '' : 'hidden' } ) + "\" alt=\"Wizard Bild\" src=\"" + stage . image + "\" />\n        </div>\n    </td><td>\n        <div style=\"padding: 5px 15px;\">\n            <span class=\"stage-content tts\" lang=\"de\">" + stage . html + "</span>\n        </div>\n        <div class=\"buttons\">\n            <button class=\"prevButton\" alt=\"Zurück\">\n                <i class=\"icon-arrow-left\"></i>\n                Zurück\n            </button>\n            <button class=\"nextButton\" alt=\"Weiter\">\n                Weiter\n                <i class=\"icon-arrow-right\"/>\n            </button>\n        </div>\n    </td></tr></table>\n</div>" ; }
function ( data ) { data = data [ 0 ] ; newResource . set ( { url : urlVal , resource_type : 'file' , format : data . format , size : data . size , mimetype : data . mimetype , last_modified : data . last_modified , webstore_url : 'enabled' , url_error : ( data . url_errors || [ "" ] ) [ 0 ] } ) ; self . collection . add ( newResource ) ; self . resetForm ( ) ; }
function ( schema ) { var key = _ . keys ( schema ) [ 0 ] ; var fieldData = _ . map ( schema [ key ] . properties , function ( dict , fieldName ) { dict . id = fieldName ; return dict ; } ) ; model . fields . reset ( fieldData ) ; dfd . resolve ( model , jqxhr ) ; }
function ( feature ) { if ( this . tooltipDiv != null ) { document . body . removeChild ( this . tooltipDiv ) ; this . tooltipDiv = null ; } }
function ( feature ) { if ( this . tooltipDiv != null ) { document . body . removeChild ( this . tooltipDiv ) ; this . tooltipDiv = null ; } this . clickFeature ( feature ) ; }
function ( _data , textStatus ) { callback ( true , data ) ; }
function ( ) { this . parent ( ) ; for ( let i = 0 ; i < this . _networks . length ; i ++ ) this . _networks [ i ] . item = null ; this . _overflowItem = null ; }
function ( ) { let title ; if ( this . _activeConnection && this . _activeConnection . _connection ) title = this . _activeConnection . _connection . get_id ( ) ; else title = _ ( "Connected (private)" ) ; if ( this . _activeNetwork ) this . _activeConnectionItem = new NMNetworkMenuItem ( this . _activeNetwork . accessPoints , undefined , { reactive : false } ) ; else this . _activeConnectionItem = new PopupMenu . PopupImageMenuItem ( title , 'network-wireless-connected' , { reactive : false } ) ; this . _activeConnectionItem . setShowDot ( true ) ; }
function ( r , g , b ) { var col = color$4 ( r , g , b , 0 ) ; var normalizedCol = [ ( ( col & PConstants . RED_MASK ) >>> 16 ) / 255 , ( ( col & PConstants . GREEN_MASK ) >>> 8 ) / 255 , ( col & PConstants . BLUE_MASK ) / 255 ] ; curContext . useProgram ( programObject3D ) ; uniformf ( "specular3d" , programObject3D , "specular" , normalizedCol ) ; }
function ( v1 , v2 , v3 ) { curContext . useProgram ( programObject3D ) ; uniformi ( "usingMat3d" , programObject3D , "usingMat" , true ) ; var col = p . color ( v1 , v2 , v3 ) ; uniformf ( "mat_ambient3d" , programObject3D , "mat_ambient" , p . color . toGLArray ( col ) . slice ( 0 , 3 ) ) ; }
function ( v1 , v2 , v3 ) { curContext . useProgram ( programObject3D ) ; uniformi ( "usingMat3d" , programObject3D , "usingMat" , true ) ; var col = p . color ( v1 , v2 , v3 ) ; uniformf ( "mat_emissive3d" , programObject3D , "mat_emissive" , p . color . toGLArray ( col ) . slice ( 0 , 3 ) ) ; }
function ( v1 , v2 , v3 ) { curContext . useProgram ( programObject3D ) ; uniformi ( "usingMat3d" , programObject3D , "usingMat" , true ) ; var col = p . color ( v1 , v2 , v3 ) ; uniformf ( "mat_specular3d" , programObject3D , "mat_specular" , p . color . toGLArray ( col ) . slice ( 0 , 3 ) ) ; }
function ( w ) { DrawingShared . prototype . strokeWeight . apply ( this , arguments ) ; curContext . useProgram ( programObject2D ) ; uniformf ( "pointSize2d" , programObject2D , "pointSize" , w ) ; curContext . useProgram ( programObjectUnlitShape ) ; uniformf ( "pointSizeUnlitShape" , programObjectUnlitShape , "pointSize" , w ) ; curContext . lineWidth ( w ) ; }
function ( size ) { if ( size !== curTextSize ) { curTextFont = PFont . get ( curFontName , size ) ; curTextSize = size ; curTextAscent = curTextFont . ascent ; curTextDescent = curTextFont . descent ; curTextLeading = curTextFont . leading ; var curContext = drawing . $ensureContext ( ) ; curContext . font = curTextFont . css ; } }
function arcString ( end , radius , largeAngle , sweep ) { var radii = KhanUtil . currentGraph . scaleVector ( radius ) ; var retstring = "A" + radii . join ( " " ) + " 0 " + ( largeAngle ? 1 : 0 ) + " " + ( sweep ? 1 : 0 ) + " " + scaleAndJoin ( end ) ; return retstring ; }
function ( j , p2 ) { ps . push ( points [ ( i + j ) % points . length ] [ sweeps [ ( j + 1 ) % sweeps . length ] == inner ? 0 : 1 ] ) ; cs . push ( circles [ ( i + j + 1 ) % circles . length ] ) ; }
function ( i , p ) { drawIntersection ( points , circles , labels [ ( i + 2 ) % points . length ] , i , [ true , false , true ] , true , true ) ; drawIntersection ( points , circles , labels [ 3 + i ] , i , [ true , false , true ] , false ) ; }
function ( access , refresh , profile , done ) { for ( id in profile . emails ) { var email = profile . emails [ id ] . value ; if ( validateEmail ( email ) ) { return done ( null , profile ) ; } } return done ( false , null ) ; }
function ( ) { if ( $ . trim ( this . options . initialPath ) != "" ) { this . navigateTo ( this . options . initialPath ) ; } else { this . navigateTo ( "/?default_to_home" ) ; } }
function ( item ) { var Node = org . mikeneck . list . DoubleLinkedListNode ; if ( item instanceof Node === false ) { return this . value > item . value ; } else if ( typeof item === "number" ) { return this . value > item ; } else { return false ; } }
function ( item ) { var Node = org . mikeneck . list . DoubleLinkedListNode ; if ( item instanceof Node === false ) { return this . value < item . value ; } else if ( typeof item === "number" ) { return this . value < item ; } else { return false ; } }
function ( ) { this . footer = this . $ ( 'footer' ) ; this . main = $ ( '#main' ) ; this . login_btn = $ ( '#login-btn' ) Images . bind ( 'all' , this . render , this ) ; Images . bind ( 'reset' , this . addAll , this ) ; var access_token = this . _getHasVars ( 'access_token' ) ; if ( access_token ) { this . login_btn . hide ( ) Backbone . InstagramSync . access_token = access_token ; Images . fetch ( ) ; } }
function ( ) { var animation_name ; if ( ! selected_animation ) { animation_name = prompt ( "Enter animation name:" ) ; if ( animation_name === null || animation_name . trim ( ) === "" ) { return ; } selected_animation = animation_name ; } else if ( ! confirm ( "Are you sure you want to save over \"" + selected_animation + "\"?\n\n(If not, select \"(new)\" in the animation drop down box.)" ) ) { return ; } save_animation ( selected_animation , cur_animation ) ; }
function ( ) { var icon = this . type . split ( '/' ) . pop ( ) files . push ( { id : App . fileCounter , name : this . name , size : this . size , icon : icon } ) App . fileCounter ++ }
function getDate ( date ) { var dateString = "" + date . getDate ( ) ; if ( date . getDate ( ) % 10 > 3 || date . getDate ( ) % 10 === 0 ) dateString += "th" ; else if ( date . getDate ( ) === 3 ) dateString += "rd" ; else if ( date . getDate ( ) === 2 ) dateString += "nd" ; else if ( date . getDate ( ) === 1 ) dateString += "st" ; return dateString ; }
function ( adjust ) { if ( ! this . editor || ! this . editor . _view ) return ; if ( typeof ( SourceEditor ) != "undefined" ) { var doc = this . editor . _view . _frame . contentDocument ; } else { this . editor . textBox . style . fontSizeAdjust = adjust ; } }
function ( callback ) { if ( staleAuthentication ) { window . appView . authView . showQuickAuthenticateView ( function ( ) { this . staleAuthentication = false ; if ( typeof callback == "function" ) { callback ( ) ; } } ) ; } else { if ( typeof callback == "function" ) { callback ( ) ; } } }
function ( callback ) { if ( this . model . get ( "privateUser" ) . username == "sapir" ) { this . authenticate ( "sapir" , "phoneme" , callback ) ; } else { alert ( "Authenticating quickly, with just password, (if the user is not sapir, if its sapir, just authenticating him with his password)... At the moment I will use the pasword 'test' " ) ; this . authenticate ( this . model . get ( "privateUser" ) . username , "test" , callback ) ; } }
function ( a , callback ) { if ( a == null ) { a = new App ( ) ; a . createAppBackboneObjects ( ) ; } window . app = a ; window . appView = new AppView ( { model : a } ) ; window . appView . render ( ) ; app . router = new AppRouter ( ) ; Backbone . history . start ( ) ; if ( typeof callback == "function" ) { callback ( ) ; } }
function ( ) { window . appView . loadSample ( ) ; }
function ( doc ) { if ( doc . resource === 'Post' ) { emit ( doc . _id , { _id : doc . _id } ) ; } }
function ( err ) { if ( err && err . validate && err . validate . errors ) { err = err . validate . errors ; var ret = { } ; err . forEach ( function ( e ) { ret [ e . property ] = e . message ; } ) ; return ret ; } else return { } ; }
function ( key , inp ) { var ret = '' ; ret += '<div class="control-group' + ( err ? ' error' : '' ) + '">' ; ret += '<label class="control-label" for=' + id ( key ) + '>' ; ret += utile . inflect . titleize ( key ) + '</label><div class="controls">' ; ret += inp + ( errs [ key ] ? '<span class="help-inline">' + errs [ key ] + '</span>' : '' ) ; ret += '</div></div>' ; return ret ; }
function ( ) { var headtg = document . getElementsByTagName ( 'head' ) [ 0 ] ; if ( ! headtg ) { return ; } var linktg = document . createElement ( 'link' ) ; linktg . type = 'text/css' ; linktg . rel = 'stylesheet' ; linktg . href = './app/app_transparent.css' ; headtg . appendChild ( linktg ) ; }
function ( ) { try { var headtg = document . getElementsByTagName ( 'head' ) [ 0 ] ; if ( ! headtg ) { return ; } var linktg = document . createElement ( 'link' ) ; linktg . type = 'text/css' ; linktg . rel = 'stylesheet' ; linktg . href = './app/app_opaque.css' ; headtg . appendChild ( linktg ) ; } catch ( e ) { Utils . debug ( "Problem loading the opaque" ) ; } }
function ( service ) { new cls . ResourceManagerAllView ( "resource_all" , ui_strings . M_VIEW_LABEL_ALL_RESOURCES , "scroll resource-manager" , "" , "" ) ; new cls . NetworkLogView ( "network_logger" , ui_strings . M_VIEW_LABEL_NETWORK_LOG , "scroll network_logger" , null , "network-logger" ) ; new cls . RequestCraftingView ( "request_crafter" , ui_strings . M_VIEW_LABEL_REQUEST_CRAFTER , "scroll" , "" , "" ) ; new cls . NetworkOptionsView ( "network_options" , ui_strings . M_VIEW_LABEL_NETWORK_OPTIONS , "scroll network-options-container" , "" , "" ) ; cls . NetworkLog . create_ui_widgets ( ) ; return true ; }
function ( mime ) { var type = cls . ResourceUtil . mime_to_type ( mime ) ; switch ( type ) { case "image" : case "pdf" : case "flash" : case "font" : return "datauri" ; case "markup" : case "css" : case "xml" : case "script" : return "text" ; } return "text" ; }
function ( msg ) { var data = new cls . DocumentManager [ "1.0" ] . AboutToLoadDocument ( msg ) ; if ( data . parentDocumentID ) { return ; } this . _current_context = new cls . ResourceContext ( ) ; }
function ( msg ) { if ( ! this . _current_context ) { return ; } var data = new cls . ResourceManager [ "1.2" ] . UrlLoad ( msg ) ; this . _current_context . update ( "urlload" , data ) ; }
function ( msg ) { if ( ! this . _current_context ) { return ; } var data = new cls . ResourceManager [ "1.0" ] . UrlFinished ( msg ) ; this . _current_context . update ( "urlfinished" , data ) ; }
function ( url ) { if ( this . _current_context ) { var filterfun = function ( res ) { return res . url == url } ; return this . _current_context . resources . filter ( filterfun ) . pop ( ) ; } return null ; }
function ( n ) { var i = Notice . findOne ( { } , { skip : n } ) ; if ( i ) { console . log ( '[remove]' , i . content ) ; Notice . remove ( i . _id ) ; } else { console . log ( '[err] cant find this notice' ) ; } }
function ( ) { var lineEl = this . getLine ( ) ; if ( this . isLastLine ) { lineEl = lineEl . add ( $ ( '<span>' ) . addClass ( 'divide' ) . append ( $ ( '<span>' ) . addClass ( 'divide-text' ) . text ( '分界线' ) ) ) ; } lineEl . appendTo ( this . hallEl ) ; this . itemMatrix . push ( lineEl ) ; }
function ( ) { console . log ( 'time kick' ) ; Slide . scroll ( ) ; ( ( notiShowCnt ++ ) % 3 ) || Notification . changeNotice ( ) ; if ( Meteor . status ( ) . connected ) { Notification . alertOff ( ) ; } else { Notification . alertOn ( '服务器断开' ) ; } }
function ( ) { if ( Speaks . find ( ) . count ( ) === 0 ) { Speaks . remove ( { } ) ; Speaks . insert ( { name : 'Houks' , content : '各位好，我是新的DianTv君，你们可以通过http://192.168.7.2:8888/来访问我，DianTv君不喜欢说话，你们来说好了，不过不要有诽谤、脏话、侵犯隐私等危险言论嗯，可以有技术含量的TX...' , time : 'From 192.168.7.1' , elapsedTime : Date . now ( ) , style : 'brick-huge' } ) ; } }
function drawColumnChart ( title , filters , categories , containerId ) { var wrapper = new google . visualization . ChartWrapper ( { chartType : 'ColumnChart' , dataTable : getColumnGraphData ( filters , categories ) , options : { title : title , width : 450 , height : 500 , backgroundColor : 'transparent' } , containerId : containerId } ) ; wrapper . draw ( ) ; return ; }
function ( node ) { if ( params . mode == 'picker' ) { params . resourcePickedHandler ( node . data . key ) ; } else { node . expand ( ) ; node . activate ( ) ; } }
function ( node , sourceNode , hitMode , ui , draggable ) { if ( node . isDescendantOf ( sourceNode ) ) { return false ; } else { dropNode ( node , sourceNode , hitMode ) ; } }
function ( err , data ) { var lines = data . toString ( ) . trim ( ) . split ( '\n' ) , r = 0 ; ; for ( r = 0 ; r < lines . length ; r ++ ) { lines [ r ] = lines [ r ] . split ( delimiter ) ; } cb ( err , lines ) ; }
function ( error , result ) { if ( error ) { console . log ( error ) ; req . flash ( 'error' , req . flash ( 'info' , 'Changes applied successfully!' ) ) ; } else { req . flash ( 'info' , 'Changes applied successfully!' ) ; tagProvider . rebuildCount ( function ( error , result ) { console . log ( error ) ; } ) ; tagProvider . current = false ; } res . redirect ( '/post/' + id ) ; }
function ( error , resp ) { if ( error ) { console . log ( error ) ; req . flash ( 'error' , error ) ; res . redirect ( '/login' ) ; } else { req . flash ( 'info' , "You've been sent a confirmation email, check it for instructions." ) ; res . redirect ( '/login' ) ; } }
function ( error , result ) { if ( error ) { console . log ( error ) ; res . json ( error ) ; } else { result = result [ 0 ] ; res . json ( result ) ; if ( ! result . error ) { tagProvider . rebuildCount ( function ( error , result ) { console . log ( error ) ; } ) ; tagProvider . current = false ; } } }
function ( json ) { for ( i = 0 ; i < json . length ; i ++ ) { panel = '#correlation-panel' + json [ i ] . rank ; $ ( '.' + type + 's' , panel ) . html ( json [ i ] . correlation ) ; } callbackFn ( ) ; }
function ( attrs ) { var result = { } ; console . log ( 'attrs' , attrs ) ; if ( attrs ) { attrs . split ( reAttrSplit ) . forEach ( function ( pair ) { console . log ( 'pair' , pair ) ; pair = pair . split ( '=' ) ; var name = pair . shift ( ) ; var value = pair . join ( '=' ) ; result [ name ] = value . replace ( /^"|"$/g , '' ) ; } ) ; } return result ; }
function ( m ) { if ( m . resolve ) { var pairs = [ ] ; for ( var name in m . resolve ) { var value = eval ( m . resolve [ name ] ) ; pairs . push ( { 'name' : m . resolve [ name ] , 'value' : value . toString ( ) } ) ; } worker . send ( { 'vars' : pairs } ) ; } else if ( m . callback ) { callback ( m . value ) ; } }
function repeat ( ) { var value = loopFunc ( ) ; if ( value ) process . message ( { 'callback' : value } ) ; if ( loopDelay ) setTimeout ( repeat , loopDelay ) ; else process . nextTick ( repeat ) ; }
function ( newValue ) { if ( newValue ) { lastScope = scope . $new ( ) ; linker ( lastScope , function ( clone ) { lastElement = clone ; iterStartElement . after ( clone ) ; } ) ; } else { if ( lastElement ) { lastElement . remove ( ) ; lastElement = null ; } lastScope && lastScope . $destroy ( ) ; } iterStartElement . parent ( ) . trigger ( "$childrenChanged" ) ; }
function ( newValue ) { if ( newValue ) { lastScope = scope . $new ( ) ; linker ( lastScope , function ( clone ) { lastElement = clone ; iterStartElement . after ( clone ) ; } ) ; } else { if ( lastElement ) { lastElement . remove ( ) ; lastElement = null ; } lastScope && lastScope . $destroy ( ) ; } iterStartElement . parent ( ) . trigger ( "$childrenChanged" ) ; }
function ( ) { var EmptyView = this . options . emptyView || this . emptyView ; if ( EmptyView ) { this . showingEmptyView = true ; var model = new Backbone . Model ( ) ; this . addItemView ( model , EmptyView , 0 ) ; } }
function ( view ) { var that = this ; this . ensureEl ( ) ; this . close ( ) ; view . render ( ) ; this . open ( view ) ; if ( view . onShow ) { view . onShow ( ) ; } view . trigger ( "show" ) ; if ( this . onShow ) { this . onShow ( view ) ; } this . trigger ( "view:show" , view ) ; this . currentView = view ; }
function ( promises ) { var promise ; var EmptyView = this . options . emptyView || this . emptyView ; if ( EmptyView ) { this . showingEmptyView = true ; var model = new Backbone . Model ( ) ; promise = this . addItemView ( model , EmptyView , 0 ) ; } return promise ; }
function ( ) { var EmptyView = this . options . emptyView || this . emptyView ; if ( EmptyView ) { this . showingEmptyView = true ; var model = new Backbone . Model ( ) ; this . addItemView ( model , EmptyView , 0 ) ; } }
function ( view ) { var that = this ; this . ensureEl ( ) ; this . close ( ) ; view . render ( ) ; this . open ( view ) ; if ( view . onShow ) { view . onShow ( ) ; } view . trigger ( "show" ) ; if ( this . onShow ) { this . onShow ( view ) ; } this . trigger ( "view:show" , view ) ; this . currentView = view ; }
function ( ) { this . frames_ = frames || [ ] ; this . frameSpeed_ = 4 ; this . name_ = name ; this . isAttack_ = isAttack == undefined ? true : isAttack ; this . allowAirBlock_ = allowAirBlock ; this . lastFrameOffset = 0 ; }
function ( ) { var collection = this . getParent ( ) ; if ( collection ) { var lines = collection . export ( ) ; var $storage = $ ( '.field-yamaps-lines' ) ; $storage . val ( JSON . stringify ( lines ) ) ; } }
function ( event ) { var coords = { center : event . get ( 'newCenter' ) , zoom : event . get ( 'newZoom' ) } ; var $storage = $ ( '.field-yamaps-coords' ) ; $storage . val ( JSON . stringify ( coords ) ) ; }
function ( ) { var collection = this . getParent ( ) ; if ( collection ) { var placemarks = collection . export ( ) ; var $storage = $ ( '.field-yamaps-placemarks' ) ; $storage . val ( JSON . stringify ( placemarks ) ) ; } }
function ( ) { var collection = this . getParent ( ) ; if ( collection ) { var polygons = collection . export ( ) ; var $storage = $ ( '.field-yamaps-polygons' ) ; $storage . val ( JSON . stringify ( polygons ) ) ; } }
function ( start , end ) { var $storage = $ ( '.field-yamaps-routes' ) ; if ( ! start || ! end ) { $storage . val ( '' ) ; } else { $storage . val ( JSON . stringify ( [ start , end ] ) ) ; } }
function ( button ) { var grid = button . up ( '#peminjaman_rinci' ) ; var editor = grid . getPlugin ( 'roweditor' ) ; editor . cancelEdit ( ) ; var r = Ext . create ( 'Earsip.model.PeminjamanRinci' , { } ) ; grid . getStore ( ) . insert ( 0 , r ) ; editor . action = 'add' ; editor . startEdit ( 0 , 0 ) ; Ext . data . StoreManager . lookup ( 'BerkasPinjam' ) . filter ( 'arsip_status_id' , 0 ) ; }
function ( r , op , success ) { if ( success ) { form . loadRecord ( record ) ; grid . getStore ( ) . load ( { params : { peminjaman_id : form . getRecord ( ) . get ( 'id' ) } } ) ; } }
function ( err , adresses ) { if ( err ) { this . emit ( "error" , err ) ; return ; } url_data . urloptions . headers [ 'host' ] = url_data . urloptions . hostname + url_data . urloptions . port ; url_data . urloptions . hostname = adresses [ 0 ] ; url_data . urloptions . host = url_data . urloptions . hostname + ( url_data . urloptions . port ? ':' + url_data . urloptions . port : '' ) ; this . _runStream ( url_data , url ) ; }
function ( fileImage ) { this . _super ( ) ; if ( fileImage ) { this . initWithFile ( fileImage , cc . DEFAULT_CAPACITY ) ; } this . setContentSize ( new cc . Size ( cc . canvas . width , cc . canvas . height ) ) ; this . _renderTexture = cc . RenderTexture . create ( cc . canvas . width , cc . canvas . height ) ; }
function ( child , zOrder ) { cc . Assert ( child != null , "SpriteBatchNode.addChild():the child should not be null" ) ; cc . Assert ( this . _children . indexOf ( child ) > - 1 , "SpriteBatchNode.addChild():sprite batch node should contain the child" ) ; if ( zOrder == child . getZOrder ( ) ) { return ; } this . removeChild ( child , false ) ; this . addChild ( child , zOrder ) ; this . setNodeDirty ( ) ; }
function ( cleanup ) { if ( this . _children && this . _children . length > 0 ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var obj = this . _children [ i ] ; if ( obj ) { this . removeSpriteFromAtlas ( obj ) ; } } } this . _super ( cleanup ) ; this . _descendants = [ ] ; this . _textureAtlas . removeAllQuads ( ) ; }
function ( jsonData ) { var dict = jsonData ; var texturePath = "" ; var metadataDict = dict [ "metadata" ] ; if ( metadataDict ) { texturePath = this . _valueForKey ( "textureFileName" , metadataDict ) ; texturePath = texturePath . toString ( ) ; } var texture = cc . TextureCache . sharedTextureCache ( ) . addImage ( texturePath ) ; if ( texture ) { this . addSpriteFramesWithDictionary ( dict , texture ) ; } else { cc . Log ( "cocos2d: cc.SpriteFrameCache: Couldn't load texture" ) ; } }
function ( name ) { if ( ! name ) { return ; } if ( this . _spriteFramesAliases . hasOwnProperty ( name ) ) { delete ( this . _spriteFramesAliases [ name ] ) ; } if ( this . _spriteFrames . hasOwnProperty ( name ) ) { delete ( this . _spriteFrames [ name ] ) ; } }
function ( plist ) { var path = cc . FileUtils . fullPathFromRelativePath ( plist ) ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( path ) ; this . removeSpriteFramesFromDictionary ( dict ) ; }
function ( texture ) { var frameDict = null ; for ( var key in this . _spriteFrames ) { var frame = this . _spriteFrames [ key ] ; if ( frame && ( frame . getTexture ( ) == texture ) ) { delete ( this . _spriteFrames [ key ] ) ; } } }
function ( splitWord ) { var words = [ ] ; words = this . _dbSearch . search ( splitWord [ 'middle' ] ) ; return words ; }
function ( ) { var step , tour ; tour = new Tour ( ) ; step = { element : $ ( "<div></div>" ) . appendTo ( "#qunit-fixture" ) , path : "test" , placement : "left" , title : "Test" , content : "Just a test" , next : 2 , end : false , animation : false } ; tour . addStep ( step ) ; deepEqual ( tour . getStep ( 0 ) , step , "tour gets a step" ) ; return clearTour ( tour ) ; }
function ( x , y ) { this . parent ( 'alien.png' , vec2 ( x , y ) ) ; this . update_event = events . connect ( 'onUpdate' , this . update . bind ( this ) ) ; events . connect ( 'alien::oob' , this . outOfBounds . bind ( this ) ) ; this . left_border = 50 ; this . right_border = phoenix . resolution . x - 50 ; this . step_down = 25 ; }
function ( event , ui ) { if ( isTip1 ) { $tip1 . hide ( ) ; } if ( isTip2 ) { $tip2 . show ( ) ; } if ( isTip1 || isTip2 ) { $block . expose ( { zIndex : 998 , color : '#000' } ) ; } }
function ( event , data ) { if ( isTip1 ) { $tip1 . show ( ) ; } if ( isTip2 ) { $tip2 . hide ( ) ; } }
function ( store , type , id ) { var fixtures = this . fixturesForType ( type ) ; if ( fixtures ) { fixtures = fixtures . findProperty ( 'id' , id ) ; } Ember . assert ( "Unable to find fixtures for model type " + type . toString ( ) , ! ! fixtures ) ; this . simulateRemoteCall ( function ( ) { store . load ( type , fixtures ) ; } , store , type ) ; }
function ( store , type , query , array ) { var fixtures = this . fixturesForType ( type ) ; fixtures = this . queryFixtures ( fixtures , query ) ; Ember . assert ( "Unable to find fixtures for model type " + type . toString ( ) , ! ! fixtures ) ; this . simulateRemoteCall ( function ( ) { array . load ( fixtures ) ; } , store , type ) ; }
function ( ) { if ( this . $el . find ( ".username" ) . val ( ) != "YourNewUserNameGoesHere" ) { this . model . set ( "username" , $ ( ".username" ) . val ( ) ) ; $ ( ".confirm-password" ) . show ( ) ; } ; }
function ( ) { var view = new DatumReadView ( { model : d , tagName : "li" } ) ; view . format = "latex" ; $ ( '#data_list_content' ) . append ( view . render ( ) . el ) ; self . datumLatexViews . push ( view ) ; self . renderUpdatedPagination ( ) ; }
function ( ) { var view = new DatumReadView ( { model : d , tagName : "li" } ) ; view . format = "latex" ; $ ( '#data_list_content' ) . append ( view . render ( ) . el ) ; self . datumLatexViews . push ( view ) ; self . renderUpdatedPagination ( ) ; }
function ( err , db ) { db . query ( "get_datum_ids/by_date" , { reduce : false } , function ( err , response ) { if ( ( ! err ) && ( typeof callback == "function" ) ) { console . log ( "Callback with: " , response . rows ) ; callback ( response . rows ) ; } } ) ; }
function task_display_filter ( text ) { var linked_text = text . replace ( /((https?|ftp)(:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%#]+))/g , function ( ) { var matched_link = arguments [ 1 ] ; if ( matched_link . match ( /(\.jpg|\.gif|\.png|\.bmp)$/ ) ) { return '<img src="' + matched_link + '"/>' ; } else { return '<a href="' + matched_link + '" target="_blank" >[URL]</a>' ; } } ) ; return linked_text ; }
function cb ( err , s ) { if ( ! -- pending ) { db . close ( ) ; done ( ) ; } if ( Array . isArray ( s ) ) s = s [ 0 ] ; assert . strictEqual ( null , err ) ; assert . equal ( false , s . isSelected ( 'name' ) ) ; assert . strictEqual ( undefined , s . name ) ; }
function cb ( err , s ) { if ( ! -- pending ) { db . close ( ) ; done ( ) ; } if ( Array . isArray ( s ) ) s = s [ 0 ] ; assert . strictEqual ( null , err ) ; assert . strictEqual ( true , s . isSelected ( 'name' ) ) ; assert . equal ( s . name , 'the included' ) ; }
function ( ) { var category = $ ( "#category" ) . val ( ) ; var view = $ ( "#view" ) . val ( ) ; var url = "/frontpages/all/" + category + "/" + view + "/" ; window . location . href = url ; return false ; }
function ( ) { category = $ ( "#category" ) . val ( ) ; url = "/frontpages/all/" + category + "/words/" ; window . location . href = url ; return false ; }
function ( event ) { if ( $ ( event . target ) . val ( ) == 'mitigation' ) $ ( '#mitigationType' ) . removeClass ( 'hidden' ) ; else $ ( '#mitigationType' ) . addClass ( 'hidden' ) ; }
function ( ) { if ( ! this . opened ( ) ) return ; this . clearDropdownAlignmentPreference ( ) ; this . dropdown . hide ( ) ; this . container . removeClass ( "select2-dropdown-open" ) ; this . results . empty ( ) ; this . clearSearch ( ) ; }
function ( aWebProgress , aRequest , aLocation ) { if ( sbrowser . service . origin != aLocation . prePath && aLocation . prePath . indexOf ( "resource:" ) != 0 ) { aRequest . cancel ( Cr . NS_BINDING_ABORTED ) ; Cu . reportError ( "unable to load new location, " + sbrowser . service . origin + " != " + aLocation . prePath ) ; return ; } }
function ( e ) { var _this = this ; e . preventDefault ( ) ; this . $ ( '.delete-confirm' ) . button ( 'loading' ) ; return this . model . destroy ( { success : function ( ) { _this . $ ( ".deleteModal" ) . modal ( 'hide' ) ; return app . router . navigate ( '' , { trigger : true } ) ; } } ) ; }
function ( ) { return _this . vent . trigger ( 'scroll:window' ) ; }
function ( task ) { this . router . navigate ( "task/" + task . id ) ; if ( ! _ . isObject ( task ) ) { task = this . tasks . get ( task ) ; } return this . body . show ( this . taskView = new TaskView ( { model : task } ) ) ; }
function ( date_string ) { var year = date_string . substr ( 0 , 4 ) ; var month = date_string . substr ( 5 , 2 ) ; var day = date_string . substr ( 8 , 2 ) ; var hour = date_string . substr ( 11 , 2 ) ; var min = date_string . substr ( 14 , 2 ) ; var sec = date_string . substr ( 17 , 2 ) ; return new Date ( year , month , day , hour , min , sec ) ; }
function setfreq_onsuccess ( ) { console . log ( 'Set freq successfully!' + freq ) ; }
function seekup_onsuccess ( ) { $ ( 'current_freq' ) . innerHTML = mozFMRadio . frequency ; console . log ( 'Seek up complete, and got new program.' ) ; }
function seekdown_onsuccess ( ) { $ ( 'current_freq' ) . innerHTML = mozFMRadio . frequency ; console . log ( 'Seek down complete, and got new program.' ) ; }
function ( element , eventName , handler ) { if ( element . addEventListener ) { element . addEventListener ( eventName , handler , false ) ; } else if ( element . attachEvent ) { element . attachEvent ( 'on' + eventName , handler ) ; } else { element [ 'on' + eventName ] = handler ; } }
function ( key , data , notifyEverbody ) { if ( notifyEverbody == undefined ) notifyEverbody = false ; var emitter = ( this . client == undefined || notifyEverbody ) ? Cassidie . netConnection : this . client . socket . broadcast ; data . id = this . id ; emitter . to ( this . level . name ) . emit ( key , data ) ; }
function ( ) { fluid . log ( "Logout connection to server ended" ) ; jqUnit . assertNotEquals ( "Successful logout message returned" , data . indexOf ( "successfully logged out." ) , - 1 ) ; setTimeout ( function ( ) { checkSettings ( json . initialState ) ; jqUnit . start ( ) ; } , 5000 ) ; }
function ( _ , slash , format , key , capture , optional , star ) { keys . push ( { name : key , optional : ! ! optional } ) ; slash = slash || '' ; return '' + ( optional ? '' : slash ) + '(?:' + ( optional ? slash : '' ) + ( format || '' ) + ( capture || ( format && '([^/.]+?)' || '([^/]+?)' ) ) + ')' + ( optional || '' ) + ( star ? '(/*)' : '' ) ; }
function ( done ) { var app = express ( ) ; app . get ( '/file/*' , function ( req , res ) { res . end ( req . params [ 0 ] ) ; } ) ; request ( app ) . get ( '/file/javascripts/jquery.js' ) . expect ( 'javascripts/jquery.js' , done ) ; }
function ( ) { var str = '[ *** copy *** ] [time:' + _myTime . get ( originFile ) + 'ms ]' + originFile ; _myLog ( str . green ) ; callback && callback ( ) ; }
function ( e ) { var layout_pane = jQuery ( '.ui-layout-' + e ) ; jQuery ( layout_pane . find ( '.ui-tabs-panel' ) . each ( function ( ) { var panel = jQuery ( this ) ; panel . width ( layout_pane . width ( ) ) ; panel . height ( layout_pane . height ( ) - panel . position ( ) . top ) ; } ) ) ; }
function ( ) { self . level ++ ; self . setCookie ( 'level' , self . level . toString ( ) ) ; self . addLevelToSelect ( ) ; }
function ( evt ) { evt && evt . preventDefault ( ) var remixUrl = "https://makr.io/posts/" + this . model . id + "/remix" , caption = "made on <a href='https://www.makr.io'>makr.io</a> | <a href='" + remixUrl + "'>remix this</a>" , source = this . model . get ( "screenshot_url" ) , url = "http://www.tumblr.com/share/photo?" + "source=" + encodeURIComponent ( source ) + "&caption=" + encodeURIComponent ( caption ) + "&clickthru=" + encodeURIComponent ( source ) this . launchWindow ( url ) }
function ( ) { var $el = $ ( this ) , href = $el . data ( 'target' ) || $el . attr ( 'href' ) , $href = /^#\w/ . test ( href ) && $ ( href ) return ( $href && href . length && [ [ $href . position ( ) . top , href ] ] ) || null }
function ( ) { var $el = $ ( this ) , href = $el . data ( 'target' ) || $el . attr ( 'href' ) , $href = /^#\w/ . test ( href ) && $ ( href ) return ( $href && href . length && [ [ $href . position ( ) . top , href ] ] ) || null }
function ( ) { WebInspector . SettingsTab . call ( this ) ; var p = this . _appendSection ( ) ; p . appendChild ( this . _createUserAgentControl ( ) ) ; if ( Capabilities . canOverrideDeviceMetrics ) p . appendChild ( this . _createDeviceMetricsControl ( ) ) ; p . appendChild ( this . _createGeolocationOverrideControl ( ) ) ; p . appendChild ( this . _createCheckboxSetting ( WebInspector . UIString ( "Emulate touch events" ) , WebInspector . settings . emulateTouchEvents ) ) ; }
function ( ) { if ( WebInspector . settings . deviceMetrics . get ( ) ) this . _deviceMetricsChanged ( ) ; WebInspector . settings . deviceMetrics . addChangeListener ( this . _deviceMetricsChanged , this ) ; WebInspector . settings . deviceFitWindow . addChangeListener ( this . _deviceMetricsChanged , this ) ; WebInspector . settings . geolocationOverride . addChangeListener ( this . _geolocationPositionChanged , this ) ; WebInspector . settings . geolocationError . addChangeListener ( this . _onGeolocationErrorChanged , this ) ; }
function ( latitude , longitude ) { this . _latitude = latitude ; this . _longitude = longitude ; }
function ( ) { try { document . cookie = "test=true; max-age=1" ; var enabled = document . cookie . indexOf ( "test" ) > - 1 ; } catch ( e ) { enabled = false ; } complete ( onComplete , enabled ) ; }
function ( ) { try { network . cookiesEnabled ( function ( status ) { equal ( status , true , "cookies are enabled, correct status" ) ; start ( ) ; throw "callback exception" ; } , testHelpers . unexpectedXHRFailure ) ; } catch ( e ) { equal ( e . toString ( ) , "callback exception" , "correct exception caught" ) ; } }
function ( ) { xhr . setContextInfo ( "auth_level" , "primary" ) ; lib . checkAuthentication ( function ( authenticated ) { equal ( authenticated , "primary" , "We are authenticated!" ) ; start ( ) ; } ) ; }
function ( authenticated ) { equal ( authenticated , undefined , "We are not authenticated!" ) ; start ( ) ; }
function ( data ) { console . log ( "redmine connect : " ) ; socket . emit ( 'redmineExtract' , function ( data ) { console . log ( "data : " , data ) ; } ) ; socket . on ( 'log' , function ( data ) { console . log ( "data : " , data ) ; } ) ; }
function ( path , params ) { if ( path . slice ( 0 , 1 ) != '/' ) { path = '/' + path ; } return path + '?' + querystring . stringify ( params ) ; }
function ( ) { expect ( 4 ) ; assert . strictEqual ( azusaar . util . splitKeyword ( null ) , "" ) ; assert . strictEqual ( azusaar . util . splitKeyword ( "" ) , "" ) ; assert . deepEqual ( azusaar . util . splitKeyword ( "Google App Engine" ) , [ "Google" , "App" , "Engine" ] ) ; assert . deepEqual ( azusaar . util . splitKeyword ( "Google　App　Engine" ) , [ "Google" , "App" , "Engine" ] ) ; }
function ( dir ) { watch ( dir , cb ) ; }
function ( field , event ) { if ( me . delayValidation && ( ! event . isSpecialKey ( ) || ( event . getKey ( ) === event . BACKSPACE ) || ( event . getKey ( ) === event . DELETE ) ) ) { var spinningWheel = me . down ( '#spinningWheel' ) ; var validationLabel = me . down ( '#validationLabel' ) ; spinningWheel . show ( ) ; validationLabel . hide ( ) ; spinningWheelTask . delay ( me . delayValidationTime ) ; } }
function ( response ) { var respObj = Ext . decode ( response . responseText , true ) ; if ( respObj . userkey !== null ) { me . validValue = false ; validationStatus . update ( { type : 'error' , text : 'Not available' } ) ; } else { me . validValue = true ; validationStatus . update ( { type : 'info' , text : 'Available' } ) ; } me . validate ( ) ; }
function ( response ) { var respObj = Ext . decode ( response . responseText , true ) ; if ( respObj . emailInUse ) { validationStatus . update ( { type : 'error' , text : 'Not available' } ) ; me . validValue = ( respObj . userkey === parentField . validationData . userKey ) ; } else { validationStatus . update ( { type : 'info' , text : 'Available' } ) ; me . validValue = true ; } me . validate ( ) ; }
function ( cssStyle ) { if ( ! cssStyle ) { return cssStyle ; } var regex = /\/\*.+?\*\//g ; cssStyle = cssStyle . replace ( regex , '' ) ; regex = /expression\(/g ; if ( cssStyle . search ( regex ) !== - 1 ) { cssStyle = '' ; } return cssStyle }
function ( ) { styler = [ { elementType : "labels" , stylers : [ { visibility : "off" } ] } ] ; options = { center : new google . maps . LatLng ( startLat , startLong ) , zoom : 8 , mapTypeId : google . maps . MapTypeId . SATELLITE , styles : styler } ; map = new google . maps . Map ( document . getElementById ( "mapCanvas" ) , options ) ; }
function ( response ) { 'use strict' ; var pageData = '' ; response . on ( 'data' , function ( data ) { pageData += data ; } ) ; response . on ( 'end' , function ( ) { fs . writeFile ( 'jslint/jslint.js' , pageData . toString ( ) , function ( err ) { if ( err ) { throw err ; } callback ( ) ; } ) ; } ) ; }
function ( cb ) { 'use strict' ; fs . mkdir ( "jslint" ) ; callback = cb ; http . get ( options , processData ) ; }
function ConstantPool ( cpItems ) { this . cpItems = cpItems ; for ( i = 1 ; i < this . getLength ( ) ; i ++ ) { if ( i in this . cpItems ) { this . cpItems [ i ] . resolveReferences ( this ) ; } } }
function ( Util , Enum ) { function ConstantUTF8Info ( length , string ) { this . length = length ; this . string = string ; } ConstantUTF8Info . prototype . toString = function ( ) { return "UTF8 " + this . string ; } ; ConstantUTF8Info . prototype . getTag = function ( ) { return Enum . constantPoolTag . UTF8 ; } ; ConstantUTF8Info . prototype . resolveReferences = function ( ) { } ; return ConstantUTF8Info ; }
function ( index , value ) { this . locals [ index ] = value ; if ( value !== null && value !== undefined && ( value . dataType === Data . type . DOUBLE || value . dataType === Data . type . LONG ) ) { this . locals [ index + 1 ] = value ; } }
function JavaArray ( elementType , elementClass , dimensions , length ) { this . elementType = elementType ; this . elementClass = elementClass ; this . dataType = Data . type . ARRAY ; this . dimensions = dimensions ; this . length = length ; this . array = new Array ( length ) ; }
function ( classDescriptor ) { if ( classDescriptor === "java/lang/Object" ) { return true ; } for ( var i = 0 ; i < this . dimensions ; i ++ ) { if ( classDescriptor . charAt ( i ) != '[' ) return false ; } var descElementClassName = classDescriptor . slice ( this . dimensions ) ; if ( this . elementType != Data . type . OBJECT ) { return descElementClassName === this . elementType ; } return this . elementClass . isA ( descElementClassName ) ; }
function ( ) { var type = this . elementType ; if ( this . elementType === Data . type . OBJECT ) type = this . elementClass . thisClassName ; var arrayPart = "" ; for ( var i = 0 ; i < this . dimensions ; i ++ ) { arrayPart = "[" + arrayPart + "]" ; } return "[" + type + arrayPart + "]" ; }
function ( string ) { var charArray = new JavaArray ( Data . type . CHAR , null , 1 , string . length ) ; for ( var i = 0 ; i < string . length ; i ++ ) { charArray . set ( i , Primitives . getChar ( string . charCodeAt ( i ) ) ) ; } return MethodRun . constructObject ( "java/lang/String" , "([C)V" , charArray ) ; }
function printCharArrayToConsole ( arrayToPrint ) { JVM . println ( "[" ) ; for ( var i = 0 ; i < arrayToPrint . length ; i ++ ) { if ( arrayToPrint [ i ] === undefined ) { JVM . print ( ' ' ) ; } else { JVM . print ( String . fromCharCode ( arrayToPrint [ i ] . value ) ) ; } if ( i != arrayToPrint . length - 1 ) { JVM . print ( ',' ) ; } } JVM . print ( ']' ) ; }
function ( ) { var theArguments = NativeFunctions . getArguments ( "(I)Ljava/lang/Class;" ) ; var numberOfFrames = theArguments [ 0 ] . value ; var frameOfInterest = JVM . getExecutingThread ( ) . getStack ( ) . stack [ JVM . getExecutingThread ( ) . getStack ( ) . length - 1 - numberOfFrames ] ; MethodRun . createReturn ( frameOfInterest . methodInfo . classInfo ) ; }
function ( fieldLength ) { return this . getField ( 'utf8' , fieldLength ) ; }
function ( ) { StructDataTypes = { 'u1' : 1 , 'u2' : 2 , 'u4' : 4 , 'u8' : 8 , 'i1' : 1 , 'i2' : 2 , 'i4' : 4 , 'i8' : 8 , 'utf8' : 0 , 'float' : 4 , 'double' : 8 } ; return StructDataTypes ; }
function ( ) { var arrayIndex = ByteCode . pop ( ) . value ; var array = ByteCode . pop ( ) ; if ( array === null ) { ByteCode . throwException ( "NullPointerException" ) ; return ; } if ( arrayIndex < 0 && array >= array . length ) { ByteCode . throwException ( "ArrayIndexOutOfBoundsException" ) ; return ; } ByteCode . push ( array . get ( arrayIndex ) ) ; }
function ( ) { var value = ByteCode . pop ( ) ; var arrayIndex = ByteCode . pop ( ) . value ; var array = ByteCode . pop ( ) ; if ( array === null ) { ByteCode . throwException ( "NullPointerException" ) ; return ; } if ( arrayIndex < 0 && arrayIndex >= array . length ) { ByteCode . throwException ( "ArrayIndexOutOfBoundsException" ) ; return ; } array . set ( arrayIndex , value ) ; }
function ( initialValue ) { var number2 = ByteCode . pop ( ) ; var number1 = ByteCode . pop ( ) ; var result = initialValue ; if ( isNaN ( number1 . value ) || isNaN ( number2 . value ) ) { } else { if ( number1 > number2 ) { result = 1 ; } else if ( number1 === number2 ) { result = 0 ; } else { result = - 1 ; } } ByteCode . push ( Primitives . getInteger ( result ) ) ; }
function ( className ) { var arrayLength = ByteCode . pop ( ) . value ; if ( arrayLength < 0 ) { ByteCode . throwException ( "NegativeArraySizeException" ) ; return ; } var class_ = JVM . getClass ( className ) ; ByteCode . push ( new JavaArray ( Data . type . OBJECT , class_ , 1 , arrayLength ) ) ; }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value === value2 . value ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value != value2 . value ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value === value2 . value ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value != value2 . value ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value < value2 . value ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value <= value2 . value ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value > value2 . value ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value >= value2 . value ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( constant ) { if ( constant . getTag ( ) === Enum . constantPoolTag . LONG ) { ByteCode . push ( constant . value ) ; return ; } if ( constant . getTag ( ) === Enum . constantPoolTag . DOUBLE ) { ByteCode . push ( constant . value ) ; return ; } }
function ( atype ) { var count = ByteCode . pop ( ) . value ; if ( count < 0 ) { ByteCode . throwException ( "NegativeArraySizeException" ) ; return ; } ByteCode . push ( new JavaArray ( Data . type . PRIMITIVE , ArrayType . type [ atype ] , 1 , count ) ) ; }
function ( length , default_ , low , high , offsets ) { var index = ByteCode . pop ( ) . value ; var offset = default_ ; if ( index >= low || index <= high ) { offset = offsets [ index - low ] ; } JVM . getExecutingThread ( ) . incrementPC ( offset - length ) ; }
function ( Util , Enum ) { function ConstantClassInfo ( nameIndex ) { this . nameIndex = nameIndex ; } ConstantClassInfo . prototype . getTag = function ( ) { return Enum . constantPoolTag . CLASS ; } ; ConstantClassInfo . prototype . resolveReferences = function ( constantPool ) { this . name = constantPool . getUTF8Info ( this . nameIndex ) ; } ; ConstantClassInfo . prototype . toString = function ( ) { return "class " + this . name ; } ; return ConstantClassInfo ; }
function ( ) { var output = "" ; switch ( this . tag ) { case Enum . constantPoolTag . INTEGER : output += "int " ; break ; case Enum . constantPoolTag . FLOAT : output += "float " ; break ; default : output += "unknownnumber " ; break ; } return output + this . value ; }
function bt_EnabledSuccess ( ) { var bluetooth = window . navigator . mozBluetooth ; if ( ! bluetooth ) return ; var enabled = req . result [ 'bluetooth.enabled' ] ; bluetooth . setEnabled ( enabled ) ; document . querySelector ( '#bluetooth-status input' ) . checked = enabled ; }
function ( value ) { self . data . dataset . enabled = value ; }
function qs_updateStatus ( ) { var wifiManager = navigator . mozWifiManager ; this . wifi . dataset . enabled = ! ! ( wifiManager && wifiManager . enabled ) ; var bluetooth = navigator . mozBluetooth ; this . bluetooth . dataset . enabled = ! ! ( bluetooth && bluetooth . enabled ) ; }
function ( color ) { var i , c , colors = this . _colors , len = colors . length ; color = new Color ( color ) ; for ( i = 0 ; i < len ; ++ i ) { c = colors [ i ] ; if ( c . equals ( color , 0.01 ) ) { return i ; } } return - 1 ; }
function ( ) { var alpha , self = this , alphaRange = self . _alphaRange , alphaValue = self . _alphaValue ; alpha = + alphaRange . val ( ) ; self . _color . alpha ( alpha ) ; alphaValue . html ( alpha . toPrecision ( 1 ) ) ; self . _dispatchColorChange ( ) ; }
function ( attrs ) { console . log ( 'VALIDATE LAYER ARRAY' , attrs . layers + '' ) ; if ( attrs . layers . length > 1 && _ . include ( attrs . layers , false ) ) { alert ( 'There was an error with your project :(/nplease email bugs@zeega.org and describe what you were doing that led to this error.\nPlease refresh your browser. Your last edit may not have saved. We apologize for the inconvenience.' ) ; return 'layer array update error!' ; } }
function ( ) { var s = this . _stats ; if ( ! ( 'mean' in s ) ) s . mean = s . sumData / s . basesCovered ; if ( ! ( 'stdDev' in s ) ) s . stdDev = this . _calcStdFromSums ( s . sumData , s . sumSquares , s . basesCovered ) ; s . global_min = s . minVal ; s . global_max = s . maxVal ; return s ; }
function ( data ) { var ul = $ ( ".thread[data-id=" + editor . find ( 'input#rootID' ) . val ( ) + "]>ul" ) ; if ( ul . length == 1 ) { ul . append ( $ ( "<li>" , { text : data } ) ) ; } else { console . log ( data ) ; comments . append ( data ) ; } }
function ( index , slide ) { $ ( slide ) . attr ( 'id' , idSlideBox + '-' + ( index + 1 ) ) ; if ( op . translucentElement ) { $ ( slide ) . append ( fn . tmpl ( '#slice-slide-translucent' ) , { } ) ; } }
function ( slidesBox ) { var allSlides = slidesBox . find ( op . slidesBoxSlide ) ; initialSlides = allSlides . filter ( ':lt(' + op . numberSimultaneousSlides + ')' ) , notInitialSlides = allSlides . filter ( ':gt(' + ( op . numberSimultaneousSlides - 1 ) + ')' ) ; initialSlides . addClass ( op . classesActive ) ; notInitialSlides . hide ( ) ; }
function ( slidesBox , slides , idSlideBox ) { slidesBox . append ( fn . tmpl ( '#slice-slide-controls' , { id : idSlideBox , slides : slides } ) ) ; fn . startSlide ( slidesBox ) ; }
function ( event ) { event . preventDefault ( ) ; if ( slideControls . pauseResume . find ( '[data-slice-slide-playing]' ) . length > 0 ) { fn . pauseSlide ( interval , slideControls ) ; } else { slideControls . pauseResume . html ( fn . tmpl ( '#slice-slide-controls-playing' ) ) ; fn . resumeSlide ( slidesBox , slideControls ) ; } }
function ( ) { if ( op . numberSimultaneousSlides > 1 ) { var nextDestination = $ ( destination ) . next ( ) ; var i = 1 ; while ( i < op . numberSimultaneousSlides ) { nextDestination . addClass ( op . classesActive ) ; var nextDestination = nextDestination . next ( ) ; i ++ ; } } $ ( destination ) . addClass ( op . classesActive ) . add ( $ ( destination ) . siblings ( op . slidesBoxSlideActive ) ) . fadeIn ( op . effectTime ) ; }
function ContentSecurityPolicy ( ) { CSPdebug ( "CSP CREATED" ) ; this . _isInitialized = false ; this . _reportOnlyMode = false ; this . _policy = CSPRep . fromString ( "default-src *" ) ; this . _policy . _allowInlineScripts = true ; this . _policy . _allowEval = true ; this . _request = "" ; this . _docRequest = null ; CSPdebug ( "CSP POLICY INITED TO 'default-src *'" ) ; }
function ( aViolationType , aSourceFile , aScriptSample , aLineNum ) { switch ( aViolationType ) { case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_INLINE_SCRIPT : if ( ! this . _policy . allowsInlineScripts ) this . _asyncReportViolation ( 'self' , 'inline script base restriction' , 'violated base restriction: Inline Scripts will not execute' , aSourceFile , aScriptSample , aLineNum ) ; break ; case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_EVAL : if ( ! this . _policy . allowsEvalInScripts ) this . _asyncReportViolation ( 'self' , 'eval script base restriction' , 'violated base restriction: Code will not be created from strings' , aSourceFile , aScriptSample , aLineNum ) ; break ; } }
function ( callback , key ) { this . collection . off ( key , callback , this ) ; this . collection . on ( key , callback , this ) ; }
function ( collection ) { this . collection = collection ; var events = { 'add remove reset' : this . updateList , 'change' : this . updateRow } ; _ . each ( events , function ( callback , key ) { this . collection . off ( key , callback , this ) ; this . collection . on ( key , callback , this ) ; } , this ) ; this . trigger ( 'collectionChanged' , collection ) ; }
function ( e ) { var el = $ ( e . currentTarget ) ; var column = el . attr ( 'data-column' ) ; var direction = el . hasClass ( 'asc' ) ? 'DESC' : 'ASC' ; this . grid . $thead . find ( '.asc,.desc' ) . removeClass ( 'asc' ) . removeClass ( 'desc' ) this . sortOn ( direction , column ) ; this . updateColumnClass ( el , direction ) ; }
function ( ) { $test . context = new $test . Context ( { name : 'storm' } ) ; $test . context . onReady ( function ( db ) { callback ( db ) ; } ) ; }
function ( index , item ) { if ( arguments . length === 1 ) return this . replace ( items ) ; var oldValue = this . value [ index ] ; this . value [ index ] = item ; this . emit ( 'change' , this . get ( ) , new Ivy . ChangeSet ( ) . remove ( index , [ oldValue ] ) . add ( index , [ value ] ) ) ; return this ; }
function ( array ) { var oldValues = this . value ; this . value = array ; this . emit ( 'change' , this . get ( ) , new Ivy . ChangeSet ( ) . remove ( 0 , oldValues ) . add ( 0 , array ) ) ; return items ; }
function ( ) { it ( 'should serialize its internal value' , function ( ) { var objectWithAttr = { x : Ivy . attr ( 5 ) } ; var object = { x : 5 } ; assert . equal ( JSON . stringify ( object ) , JSON . stringify ( objectWithAttr ) ) ; } ) ; it ( 'should allow coercion' , function ( ) { var value = Ivy . attr ( 5 ) + 1 ; assert . equal ( value , 6 ) ; } ) ; }
function ( self , type , fun ) { return $ ( self ) [ type ] ( function ( ev ) { ev = getTouchEvent ( ev ) ; fingerDown = ev . identifier ; return fun . call ( this , ev ) ; } ) ; }
function ( fun ) { return oneTouch ( this , 'touchMove' , fun ) ; }
function ( element ) { var object = Parallax . scrollObjects [ element ] ; if ( typeof object == "undefined" ) { object = new Parallax . ScrollObject ( element ) ; Parallax . scrollObjects [ element ] = object ; } return object ; }
function ( item ) { var searchTerm = item . data . place ; for ( i = 0 ; i < filters . length ; i ++ ) { return searchTerm === filters [ i ] } }
function ( event ) { var pos = this . getEventPosition ( event ) ; this . lastMousePos . pageX = pos . absX ; this . lastMousePos . pageY = pos . absY ; E . fire ( this . el , 'flotr:mousemove' , [ event , pos , this ] ) ; }
function ( e ) { e . preventDefault ( ) ; movement = true ; var pageX = e . touches [ 0 ] . pageX , pageY = e . touches [ 0 ] . pageY , pos = this . getEventPosition ( e . touches [ 0 ] ) ; this . lastMousePos . pageX = pageX ; this . lastMousePos . pageY = pageY ; if ( ! touchend ) { E . fire ( el , 'flotr:mousemove' , [ event , pos , this ] ) ; } }
function ( el ) { if ( ! el ) throw 'The target container doesn\'t exist' ; if ( ! el . clientWidth ) throw 'The target container must be visible' ; this . el = el ; if ( this . el . graph ) this . el . graph . destroy ( ) ; this . el . graph = this ; }
function ( ) { if ( this . lastMousePos . relX ) this . octx . clearRect ( this . lastMousePos . relX - 0.5 , this . plotOffset . top , 1 , this . plotHeight + 1 ) ; if ( this . lastMousePos . relY ) this . octx . clearRect ( this . plotOffset . left , this . lastMousePos . relY - 0.5 , this . plotWidth + 1 , 1 ) ; }
function ( o , k ) { try { if ( s = o . insertUploadedFile ( r ) ) { if ( ed . dom . replace ( s , n ) ) { ed . nodeChanged ( ) ; return true ; } ed . dom . remove ( n ) ; } } catch ( e ) { return showError ( e ) ; } }
function ( me ) { window . myself = me ; router ( ) ; }
function ( ) { var hash = location . hash . replace ( "#" , "" ) ; if ( hash !== "" ) { getBoard ( hash ) ; } else { listBoards ( ) ; } }
function ( ) { var elem = $ ( this ) , jspApi = elem . data ( 'jsp' ) ; if ( jspApi ) { jspApi . reinitialise ( settings ) ; } else { $ ( "script" , elem ) . filter ( '[type=text/javascript],not([type])' ) . remove ( ) ; jspApi = new JScrollPane ( elem , settings ) ; elem . data ( 'jsp' , jspApi ) ; } }
function ( ) { if ( cc . NODE_TRANSFORM_USING_AFFINE_MATRIX ) { this . _isTransformGLDirty = true ; this . _transformGL = 0.0 ; } this . _anchorPoint = new cc . Point ( 0 , 0 ) ; this . _anchorPointInPoints = new cc . Point ( 0 , 0 ) ; this . _contentSize = new cc . Size ( 0 , 0 ) ; var director = cc . Director . sharedDirector ( ) ; this . _actionManager = director . getActionManager ( ) ; this . _scheduler = director . getScheduler ( ) ; }
function ( child , zOrder ) { cc . Assert ( child != null , "Child must be non-nil" ) ; this . _reorderChildDirty = true ; cc . ArrayRemoveObject ( this . _children , child ) ; this . _insertChild ( child , zOrder ) ; this . setNodeDirty ( ) ; }
function ( selectedUsers ) { var confirmMessage = gettext ( 'Do you really want to remove the {numselected} selected users from the list?' ) ; Ext . MessageBox . show ( { title : gettext ( 'Confirm remove' ) , msg : Ext . create ( 'Ext.XTemplate' , confirmMessage ) . apply ( { numselected : selectedUsers . length } ) , buttons : Ext . MessageBox . YESNO , icon : Ext . MessageBox . QUESTION , fn : function ( buttonId ) { if ( buttonId == 'yes' ) { this . removeUsers ( selectedUsers ) ; } } , scope : this } ) ; }
function ( target_uuid , args , callback ) { MediaFile . updateMediaFile ( target_uuid , args , function ( error , updatedMediaFile ) { if ( ! error ) { callback ( null , updatedMediaFile ) ; } else { callback ( error , null ) ; } } ) }
function ( media , callback ) { media . target_uuid = UUID . generate ( ) ; var newMediaFile = MediaFile . build ( media ) ; newMediaFile . save ( ) . error ( function ( error ) { callback ( error , null ) ; } ) . success ( function ( ) { callback ( null , newMediaFile ) ; } ) }
function ( target_uuid , args , callback ) { MediaFile . find ( { where : target_uuid } ) . success ( function ( mediaFile ) { mediaFile . updateAttributes ( args ) . success ( function ( updatedMedia ) { console . log ( "updated succesfully" ) ; callback ( null , updatedMedia ) ; } ) ; } ) . error ( function ( error ) { callback ( error , null ) ; console . log ( "Couldn't find mediaFile " + error ) ; } ) ; }
function gotPath ( fileSystem ) { console . log ( fileSystem . name ) ; console . log ( fileSystem . root . name ) ; dataDir = fileSystem . root . getDirectory ( "data/OBS" , { create : true } , onSuccessTest , onFailTest ) ; }
function ( models , options ) { options || ( options = { } ) ; if ( options . model ) this . model = options . model ; if ( typeof options . comparator !== 'undefined' ) this . comparator = options . comparator ; this . _reset ( ) ; this . initialize . apply ( this , arguments ) ; if ( models ) this . reset ( models , { silent : true , parse : options . parse } ) ; }
function mm_deleteMessage ( id , callback ) { console . log ( "SMS: Eliminando mensaje " + id ) ; var req = navigator . mozSms . delete ( id ) ; req . onsuccess = function onsuccess ( ) { callback ( req . result ) ; } ; req . onerror = function onerror ( ) { var msg = 'Deleting in the database. Error: ' + req . errorCode ; console . log ( msg ) ; callback ( null ) ; } ; }
function thui_deleteMessages ( ) { var inputs = this . view . querySelectorAll ( 'input[type="checkbox"]:checked' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . parentNode . parentNode . classList . add ( 'undo-candidate' ) ; if ( inputs [ i ] . id ) { this . delNumList . push ( inputs [ i ] . id ) ; } else { } } }
function ( err , doc ) { doc . mostRecentIds = 'jason borne' ; doc . save ( ) ; if ( typeof callback == "function" ) { callback ( user ) ; } }
function ( ) { this . $style = $ ( "<style type='text/css' rel='stylesheet' />" ) . appendTo ( $ ( "head" ) ) ; var rules = [ ".slick-row { height:" + this . rowHeight + "px; }" ] ; if ( this . $style [ 0 ] . styleSheet ) { this . $style [ 0 ] . styleSheet . cssText = rules . join ( " " ) ; } else { this . $style [ 0 ] . appendChild ( document . createTextNode ( rules . join ( " " ) ) ) ; } }
function ( withOutBuffer ) { if ( ! this . initialized ) { return ; } var renderedRange = this . getRenderedRange ( ) ; this . deRenderRows ( withOutBuffer ? null : renderedRange ) ; this . renderRows ( renderedRange ) ; this . lastRenderedScrollTop = this . scrollTop ; }
function ( rangeToKeep ) { if ( rangeToKeep ) console . log ( 'deRender top:' + rangeToKeep . top + " bottom:" + rangeToKeep . bottom ) ; for ( var i in this . content ) { if ( Em . none ( rangeToKeep ) || i < rangeToKeep . top || i > rangeToKeep . bottom ) { this . deRenderRow ( i ) ; } } }
function ( rowIdx ) { var rowView = this . renderedRows [ rowIdx ] ; if ( ! rowView ) { return ; } this . rowsCache . push ( rowView ) ; delete this . renderedRows [ rowIdx ] ; if ( this . deRenderedHook ) { Em . run . later ( rowView , this . deRenderedHook , 50 ) ; } }
function ( ) { this . _super ( ) ; this . cleanCache ( ) ; $ ( window ) . off ( "scroll" , this . handleScroll ) ; this . $style . remove ( ) ; this . stylesheet = null ; this . $style = null ; }
function ( row , idx ) { row . destroy ( ) ; childViews . removeObject ( row ) ; delete self . rowsCache [ idx ] ; }
function ( event ) { self . readyState = this . readyState ; if ( self . readyState == 4 ) { self . responseText = this . responseText ; self . responseXML = this . responseXML ; self . status = this . status ; self . statusText = this . statusText ; } if ( self . onreadystatechange ) self . onreadystatechangeCallback ( event ) ; }
function ( error , result ) { if ( error ) { return 'Error sending email!  Error was: ' + error ; } else { return 'Email response successfull!  Response was: ' + result + '\nEmail to: ' + email + '\nEmail text: \n' + chatTranscript ; } }
function ( node ) { var i , prop , optionItem ; prop = node . getProperty ( "options" ) ; prop . children = [ ] ; for ( i = 0 ; i < 3 ; i ++ ) { optionItem = { } ; optionItem . text = "Option" + ( i + 1 ) ; optionItem . value = "Value" ; prop . children . push ( optionItem ) ; } }
function finishExperiment ( ) { var all_data = [ ] ; for ( var i = 0 ; i < exp_blocks . length ; i ++ ) { all_data [ i ] = exp_blocks [ i ] . data ; } opts [ "finish" ] . apply ( ( new Object ( ) ) , [ all_data ] ) ; }
function ( value ) { var dateValue = this . convertToDate ( value ) , output = dateValue . getUTCFullYear ( ) + '-' + pad ( dateValue . getUTCMonth ( ) + 1 ) + '-' + pad ( dateValue . getUTCDate ( ) ) + 'T' + pad ( dateValue . getUTCHours ( ) ) + ':' + pad ( dateValue . getUTCMinutes ( ) ) + ':' + pad ( dateValue . getUTCSeconds ( ) ) + 'Z' ; return output ; }
function ( value ) { var dateValue = this . convertToDate ( value ) , output = dateValue . getUTCFullYear ( ) + '-' + pad ( dateValue . getUTCMonth ( ) + 1 ) + '-' + pad ( dateValue . getUTCDate ( ) ) + 'T' + pad ( dateValue . getUTCHours ( ) ) + ':' + pad ( dateValue . getUTCMinutes ( ) ) + ':' + pad ( dateValue . getUTCSeconds ( ) ) + this . getReadableTimezone ( dateValue , true ) ; return output ; }
function ( value ) { var dateValue = this . convertToDate ( value ) , output = this . getDayShort ( dateValue ) + ', ' + dateValue . getDate ( ) + ' ' + this . getMonthShort ( dateValue ) + ' ' + dateValue . getUTCFullYear ( ) + ' ' + pad ( dateValue . getUTCHours ( ) ) + ':' + pad ( dateValue . getUTCMinutes ( ) ) + ':' + pad ( dateValue . getUTCSeconds ( ) ) + ' ' + this . getReadableTimezone ( dateValue ) ; return output ; }
function ( dateObj , addDelimiter ) { dateObj = dateObj || new Date ( ) ; addDelimiter = addDelimiter || false ; var offset = - dateObj . getTimezoneOffset ( ) , hours = Math . floor ( offset / 60 ) , minutes = ( offset - ( hours * 60 ) ) , output = ( ( hours > 0 ) ? '+' : '-' ) + pad ( hours ) + ( addDelimiter ? ':' : '' ) + pad ( minutes ) ; return output ; }
function ( event ) { if ( ! wc . local . map . map ) { wc . local . mapqueue = function ( ) { wc . local . map . showPlace ( event . data ) ; } ; $ ( '#FindLatLonByMapButton' ) . click ( ) ; } else { wc . local . map . showPlace ( event . data ) ; } $ . smoothScroll ( { scrollElement : $ ( '#bg2' ) , scrollTarget : $ ( '#gMapGridBox' ) , offset : - 85 } ) ; return false ; }
function ( regionName ) { var regionEl = rootElement . querySelector ( "div[data-winning-region='" + regionName + "']" ) ; return Q . when ( regionMap [ regionName ] . render ( ) ) . then ( function ( renderedElement ) { regionEl . parentNode . replaceChild ( renderedElement , regionEl ) ; } ) ; }
function showQuestionDetails ( question ) { question . find ( '.answers' ) . each ( check ) ; question . find ( '.comments' ) . show ( ) ; question . find ( '.materials' ) . show ( 'fast' ) ; }
function showStatistics ( ) { var s = $ ( '#statistics' ) ; var time_passed = getTimePassed ( ) ; s . empty ( ) ; s . append ( $ ( '<dt>Insgesamt</dt><dd>' + questions_total + '</dd>' ) ) ; s . append ( $ ( '<dt>Korrekt</dt><dd>' + questions_correct + '</dd>' ) ) ; s . append ( $ ( '<dt>Anteil</dt><dd>' + ( ( questions_correct / questions_total ) * 100 ) + '%</dd>' ) ) ; s . append ( $ ( '<dt>Zeit</dt><dd>' + time_passed + '</dd>' ) ) ; s . show ( ) ; }
function allValidQuestionsAnswered ( ) { for ( question in exam . Question ) { if ( question . valid && ! question . answered ) return false ; } return true ; }
function ( eventObject ) { if ( shortcuts_enabled ) { switch ( eventObject . which ) { case 37 : case 38 : showPreviousQuestion ( ) ; return false ; case 39 : case 40 : showNextQuestion ( ) ; return false ; case 13 : showQuestionDetails ( $ ( ".question.current" ) ) ; return false ; break ; } } }
function DTA_grip ( ) { dbg_assert ( ! this . exited , 'grip() should not be called on exited browser actor.' ) ; dbg_assert ( this . actorID , 'tab should have an actorID.' ) ; return { 'actor' : this . actorID , 'title' : this . browser . contentTitle , 'url' : this . browser . document . documentURI } }
function DTA_pushContext ( ) { dbg_assert ( ! this . _contextPool , "Can't push multiple contexts" ) ; this . _contextPool = new ActorPool ( this . conn ) ; this . conn . addActorPool ( this . _contextPool ) ; this . threadActor = new ThreadActor ( this ) ; this . _addDebuggees ( this . browser . content . wrappedJSObject ) ; this . _contextPool . addActor ( this . threadActor ) ; }
function ( html ) { on_a_link = true ; $ ( "div.popup" ) . show ( speed ) ; $ ( "div.popup" ) . animate ( { top : event . pageY - 100 , left : 0 , } , speed ) ; $ ( "div.popup" ) . html ( html ) ; }
function ( event ) { $ . ajax ( event . currentTarget . children [ 1 ] . href , { success : function ( html ) { on_a_link = true ; $ ( "div.popup" ) . show ( speed ) ; $ ( "div.popup" ) . animate ( { top : event . pageY - 100 , left : 0 , } , speed ) ; $ ( "div.popup" ) . html ( html ) ; } , } ) ; }
function bind_node_event ( e , data ) { $ ( "#testplan-tree" ) . unblock ( ) ; $ ( this ) . find ( "li[rel=test_case]" ) . click ( function ( e ) { var $node = $ ( this ) ; $ ( "#executions-view" ) . block ( impasse_loading_options ( ) ) ; show_test_case ( $ ( this ) . attr ( "id" ) . replace ( "exec_" , "" ) ) ; } ) ; }
function ( elem , div_id ) { var code = "if (document.getElementById('" + div_id + "') != null){" + "document.body.removeChild(document.getElementById('" + div_id + "'))}" ; if ( elem . getAttribute ( "onclick" ) == undefined ) { elem . setAttribute ( "onclick" , code ) ; } }
function ( e ) { var id = $ ( e ) . data ( "id" ) ; var ship = gamedata . getShip ( id ) ; if ( shipSelectList . haveToShowList ( ship ) ) { shipSelectList . showList ( ship ) ; } else { shipManager . doShipContextMenu ( ship ) ; } }
function ( e ) { e . stopPropagation ( ) ; var id = $ ( this ) . data ( "id" ) ; var ship = gamedata . getShip ( id ) ; if ( shipSelectList . haveToShowList ( ship ) ) { shipSelectList . showList ( ship ) ; } else { shipManager . doShipClick ( ship ) ; } }
function ( shooter , target , weapon ) { var sPos = shipManager . getShipPositionInWindowCo ( shooter ) ; var tPos = shipManager . getShipPositionInWindowCo ( target ) ; var dis = mathlib . getDistance ( sPos , tPos ) ; var disInHex = dis / hexgrid . hexWidth ( ) ; var rangePenalty = ( weapon . rangePenalty / hexgrid . hexWidth ( ) * dis ) ; return rangePenalty ; }
function ( ship , system ) { for ( var i in ship . fireOrders ) { var fire = ship . fireOrders [ i ] ; if ( fire . weaponid == system . id && fire . turn == gamedata . turn && ! fire . rolled ) { if ( ( gamedata . gamephase == 1 && system . ballistic ) || ( gamedata . gamephase == 3 && ! system . ballistic ) ) { return true ; } } } return false ; }
function ( ship ) { for ( var i in ship . fireOrders ) { var fire = ship . fireOrders [ i ] ; var weapon = shipManager . systems . getSystem ( ship , fire . weaponid ) if ( fire . turn == gamedata . turn && ! fire . rolled && ! weapon . ballistic ) { return false ; } } return true ; }
function ( ship , system ) { for ( var i in ship . fireOrders ) { var fire = ship . fireOrders [ i ] ; if ( fire . weaponid == system . id && fire . turn == gamedata . turn && ! fire . rolled ) return fire ; } return false ; }
function ( ship , system , mod ) { for ( var i in ship . fireOrders ) { var fire = ship . fireOrders [ i ] ; if ( fire . weaponid == system . id && fire . turn == gamedata . turn && ! fire . rolled ) { if ( ( gamedata . gamephase == 1 && system . ballistic ) || ( gamedata . gamephase == 3 && ! system . ballistic ) ) fire . shots += mod ; } } shipWindowManager . setDataForSystem ( ship , system ) ; }
function ( ) { if ( ajaxInterface . submiting ) return ; ajaxInterface . submiting = true ; var gd = ajaxInterface . construcGamedata ( ) ; $ . ajax ( { type : 'POST' , url : 'gamedata.php' , dataType : 'json' , data : gd , success : ajaxInterface . successSubmit , error : ajaxInterface . errorSubmit } ) ; gamedata . goToWaiting ( ) ; }
function ( ship ) { for ( var i in ship . EW ) { var EWentry = ship . EW [ i ] ; if ( EWentry . turn != gamedata . turn ) continue ; if ( EWentry . type == "CCEW" ) { return EWentry . amount ; } } return 0 ; }
function ( error_frame ) { var msg = "ERROR: " + ( error_frame . body ) ? error_frame . body : error_frame . toString ; log ( msg , { facility : whatami , level : LOG_ERROR } ) ; }
function ( ) { var offsetParent = this . offsetParent || document . body ; while ( offsetParent && ( ! rroot . test ( offsetParent . nodeName ) && jQuery . css ( offsetParent , "position" ) === "static" ) ) { offsetParent = offsetParent . offsetParent ; } return offsetParent ; }
function ( e , scope ) { var parser = scope ; parser . emit ( 'error' , e ) ; parser . errors . push ( e ) ; }
function ( fx ) { var elem = $ ( fx . elem ) , data = elem . data ( "accordionHeight" ) ; elem . height ( data . total - elem . outerHeight ( ) - data . toHide . outerHeight ( ) + elem . height ( ) ) ; }
function ( ) { "use strict" ; var title = "Magic Land HD" ; var message = "Do you like Magic Land HD? \nRate it now and get 4000 gold! \n \n \ue32f\ue32f\ue32f\ue32f\ue32f\n " ; var yesHandler = function ( ) { wooga . castle . game . increase ( 'gold' , 4000 ) ; window . location . href = rateAppUrl ; } ; var noHandler = function ( ) { } ; wooga . yesno ( message , yesHandler , noHandler , title ) ; }
function ( isp , status ) { console . log ( 'marker = ' , uMarker , 'markers.length = ' , markers . length ) ; if ( uMarker ) { uMarker . isp = ispName = isp ; uMarker . status = status ; uMarker . time = Date . now ( ) ; drawMap ( ) ; } }
function ( a ) { console . log ( 'adding markers' ) for ( var i = a . length - 1 ; i >= 0 ; i -- ) { if ( a [ i ] . user == false ) { addMarker ( a [ i ] ) ; } else { uMarker = drawGeoMarker ( a [ i ] ) ; } } drawMap ( ) ; }
function ( ) { console . log ( 'drawMap' ) console . log ( '**searchCircle = ' + searchCircle ) ; console . log ( '**markers.length = ' + markers . length ) ; console . log ( '**ispName = ' + ispName ) ; for ( var i = markers . length - 1 ; i >= 0 ; i -- ) { markers [ i ] . inCircle = searchCircle . contains ( markers [ i ] . getPosition ( ) ) ; } }
function load ( url , content , type , line ) { if ( panel_window ) { panel_window . purple . showContent ( url , content , type ) ; panel_window . purple . setCursorOn ( url , line || 1 , 1 ) ; } else { buffer = Array . prototype . slice . apply ( arguments ) ; console . log ( 'buffering load' , buffer ) ; } }
function checkSibling ( property , collapse ) { while ( ! node [ property ] ) { node = node . parentNode ; } node = node [ property ] ; if ( node && ! /br|h\d|p/i . test ( node . nodeName ) ) { selectNodes ( [ node ] , collapse ) ; return false ; } }
function ( hook ) { var hookInSourceControl = path . resolve ( __dirname , hook ) ; if ( path . existsSync ( hookInSourceControl ) ) { var hookInHiddenDirectory = path . resolve ( __dirname , ".." , ".git" , "hooks" , hook ) ; if ( path . existsSync ( hookInHiddenDirectory ) ) { fs . unlinkSync ( hookInHiddenDirectory ) ; } fs . linkSync ( hookInSourceControl , hookInHiddenDirectory ) ; } }
function ( ) { for ( var e in _listeners ) { if ( e !== "close" ) { _internal . unlisten ( e , _listeners [ e ] ) ; } } _modal . destroy ( ) ; _modal = null ; document . removeEventListener ( "keydown" , onKeyDown , false ) ; _internal . dispatch ( "close" ) ; _external . dispatch ( "close" ) ; }
function ( name , spawnOptions ) { if ( __dialogs [ name ] ) { if ( __openDialogs [ name ] ) { __openDialogs [ name ] . focus ( ) ; } else { __openDialogs [ name ] = __dialogs [ name ] ( spawnOptions ) ; __openDialogs [ name ] . listen ( "close" , function ( ) { __openDialogs [ name ] = null ; } ) ; } return __openDialogs [ name ] ; } else { throw "Dialog '" + name + "' does not exist." ; } }
function ( ) { var dialogs = [ "error-message" , "track-data" , "delete-track" , "export" , "quit-confirmation" , "save-as" , "load" , "share" ] ; var include = [ ] ; var i = dialogs . length ; while ( i -- ) { include . push ( "dialog/dialogs/" + dialogs [ i ] ) ; } define ( include , function ( ) { } ) ; }
function ( e ) { var dialog = Dialog . spawn ( "delete-track" , { data : trackName , events : { submit : function ( e ) { if ( e . data === true ) { media . removeTrack ( track ) ; } dialog . close ( ) ; } , cancel : function ( e ) { dialog . close ( ) ; } } } ) ; }
function showErrorDialog ( message , callback ) { var dialog = Dialog . spawn ( "error-message" , { data : message , events : { cancel : function ( e ) { dialog . close ( ) ; if ( callback ) { callback ( ) ; } } } } ) ; }
function ( e ) { if ( e . error !== "okay" ) { showErrorDialog ( "There was a problem saving your project. Please try again." ) ; return ; } else { var url = e . url ; Dialog . spawn ( "share" , { data : url } ) ; } }
function ( ) { settings . popupOn = true ; pubsub . publish ( 'state.persist' ) ; util . cookie ( 'glimpseKeepPopup' , '1' ) ; var url = data . currentMetadata ( ) . paths . popup ; window . open ( url , 'GlimpsePopup' , 'width=1100,height=600,status=no,toolbar=no,menubar=no,location=no,resizable=yes,scrollbars=yes' ) ; }
function ( ) { settings . popupOn = true ; pubsub . publish ( 'state.persist' ) ; util . cookie ( 'glimpseKeepPopup' , '1' ) ; var url = data . currentMetadata ( ) . paths . popup ; window . open ( url , 'GlimpsePopup' , 'width=1100,height=600,status=no,toolbar=no,menubar=no,location=no,resizable=yes,scrollbars=yes' ) ; }
function generateCommonJSModule ( opt ) { opt = typal . mix . call ( { } , this . options , opt ) ; var moduleName = opt . moduleName || "parser" ; var out = this . generateModule ( opt ) + "\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {" + "\nexports.parser = " + moduleName + ";" + "\nexports.parse = function () { return " + moduleName + ".parse.apply(" + moduleName + ", arguments); }" + "\nexports.main = " + String ( opt . moduleMain || commonjsMain ) + "\nif (typeof module !== 'undefined' && require.main === module) {\n" + "  exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require(\"system\").args);\n}" + "\n}" return out ; }
f { return { x : parseInt ( c . x * xscale , 10 ) , y : parseInt ( c . y * yscale , 10 ) , x2 : parseInt ( c . x2 * xscale , 10 ) , y2 : parseInt ( c . y2 * yscale , 10 ) , w : parseInt ( c . w * xscale , 10 ) , h : parseInt ( c . h * yscale , 10 ) } ; }
f { var xa = x1 , xb = x2 , ya = y1 , yb = y2 ; if ( x2 < x1 ) { xa = x2 ; xb = x1 ; } if ( y2 < y1 ) { ya = y2 ; yb = y1 ; } return [ Math . round ( xa ) , Math . round ( ya ) , Math . round ( xb ) , Math . round ( yb ) ] ; }
f { setSelectRaw ( [ parseInt ( rect [ 0 ] , 10 ) / xscale , parseInt ( rect [ 1 ] , 10 ) / yscale , parseInt ( rect [ 2 ] , 10 ) / xscale , parseInt ( rect [ 3 ] , 10 ) / yscale ] ) ; options . onSelect . call ( api , unscale ( Coords . getFixed ( ) ) ) ; Selection . enableHandles ( ) ; }
function ( ) { self . editableValue . queryApi = function ( deferred , apiAction ) { deferred . reject ( 'error' , self . errors [ 0 ] ) . promise ( ) ; } ; }
function ( values ) { if ( typeof values === 'undefined' ) { values = [ 0 , 0 , 0 , 0 ] ; } else if ( ! Array . isArray ( values ) ) { throw new DeveloperError ( 'values must be an array' ) ; } this [ 0 ] = values [ 0 ] ; this [ 1 ] = values [ 1 ] ; this [ 2 ] = values [ 2 ] ; this [ 3 ] = values [ 3 ] ; }
function ( ) { var matrix = new Matrix2 ( ) ; expect ( matrix [ 0 ] ) . toEqual ( 0.0 ) ; expect ( matrix [ 1 ] ) . toEqual ( 0.0 ) ; expect ( matrix [ 2 ] ) . toEqual ( 0.0 ) ; expect ( matrix [ 3 ] ) . toEqual ( 0.0 ) ; }
function ( ) { var expected = [ 1.0 , 2.0 , 3.0 , 4.0 ] ; var matrix = new Matrix2 ( expected ) ; expect ( matrix [ 0 ] ) . toEqual ( 1.0 ) ; expect ( matrix [ 1 ] ) . toEqual ( 2.0 ) ; expect ( matrix [ 2 ] ) . toEqual ( 3.0 ) ; expect ( matrix [ 3 ] ) . toEqual ( 4.0 ) ; }
function ( ) { var expected = new Matrix2 ( [ 1.0 , 2.0 , 3.0 , 4.0 ] ) ; var returnedResult = expected . clone ( ) ; expect ( returnedResult ) . toNotBe ( expected ) ; expect ( returnedResult ) . toEqual ( expected ) ; }
function ( ) { var expected = new Matrix2 ( [ 1.0 , 2.0 , 3.0 , 4.0 ] ) ; var result = new Matrix2 ( ) ; var returnedResult = expected . clone ( result ) ; expect ( returnedResult ) . toBe ( result ) ; expect ( returnedResult ) . toNotBe ( expected ) ; expect ( returnedResult ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1.0 , 2.0 , 3.0 , 4.0 ) ; var expectedRow0 = new Cartesian2 ( 1.0 , 2.0 ) ; var expectedRow1 = new Cartesian2 ( 3.0 , 4.0 ) ; var resultRow0 = matrix . getRow ( 0 ) ; var resultRow1 = matrix . getRow ( 1 ) ; expect ( resultRow0 ) . toEqual ( expectedRow0 ) ; expect ( resultRow1 ) . toEqual ( expectedRow1 ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = Matrix2 . fromComponents ( 5 , 6 , 7 , 8 ) ; var expected = Matrix2 . fromComponents ( 19 , 22 , 43 , 50 ) ; var result = left . multiply ( right ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = Matrix2 . fromComponents ( 5 , 6 , 7 , 8 ) ; var expected = Matrix2 . fromComponents ( 19 , 22 , 43 , 50 ) ; var result = new Matrix2 ( ) ; var returnedResult = left . multiply ( right , result ) ; expect ( returnedResult ) . toBe ( result ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = Matrix2 . fromComponents ( 5 , 6 , 7 , 8 ) ; var expected = Matrix2 . fromComponents ( 19 , 22 , 43 , 50 ) ; var returnedResult = left . multiply ( right , left ) ; expect ( returnedResult ) . toBe ( left ) ; expect ( left ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = new Cartesian2 ( 5 , 6 ) ; var expected = new Cartesian2 ( 17 , 39 ) ; var result = left . multiplyByVector ( right ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = new Cartesian2 ( 5 , 6 ) ; var expected = new Cartesian2 ( 17 , 39 ) ; var result = new Cartesian2 ( ) ; var returnedResult = left . multiplyByVector ( right , result ) ; expect ( returnedResult ) . toBe ( result ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = 2 ; var expected = Matrix2 . fromComponents ( 2 , 4 , 6 , 8 ) ; var result = left . multiplyByScalar ( right ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var left = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var right = 2 ; var expected = Matrix2 . fromComponents ( 2 , 4 , 6 , 8 ) ; var result = new Matrix2 ( ) ; var returnedResult = left . multiplyByScalar ( right , result ) ; expect ( returnedResult ) . toBe ( result ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( - 1 , - 2 , - 3 , - 4 ) ; var result = matrix . negate ( ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( - 1 , - 2 , - 3 , - 4 ) ; var result = new Matrix2 ( ) ; var returnedResult = matrix . negate ( result ) ; expect ( result ) . toBe ( returnedResult ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( - 1 , - 2 , - 3 , - 4 ) ; var returnedResult = matrix . negate ( matrix ) ; expect ( matrix ) . toBe ( returnedResult ) ; expect ( matrix ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( 1 , 3 , 2 , 4 ) ; var result = matrix . transpose ( ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( 1 , 3 , 2 , 4 ) ; var result = new Matrix2 ( ) ; var returnedResult = matrix . transpose ( result ) ; expect ( result ) . toBe ( returnedResult ) ; expect ( result ) . toEqual ( expected ) ; }
function ( ) { var matrix = Matrix2 . fromComponents ( 1 , 2 , 3 , 4 ) ; var expected = Matrix2 . fromComponents ( 1 , 3 , 2 , 4 ) ; var returnedResult = matrix . transpose ( matrix ) ; expect ( matrix ) . toBe ( returnedResult ) ; expect ( matrix ) . toEqual ( expected ) ; }
function ( data ) { if ( feed . readyState === 4 ) { var tweets = new Array ( ) ; for ( i in data ) { if ( tweets . length < count ) { if ( replies || data [ i ] . in_reply_to_user_id == null ) { tweets . push ( data [ i ] ) ; } } } showTwitterFeed ( tweets , user ) ; } }
function ( callback ) { if ( user ) { if ( ! curRoom || this . get ( "id" ) != curRoom . get ( "id" ) ) { curRoom = new Model . CurrentRoom ( { id : this . get ( "id" ) , callback : callback } ) ; } } else { callback ( { status : false , message : "You haven't logged in yet" } ) ; } }
function ( ) { this . _isCacheDirty = true ; this . _isNeedUpdate = true ; }
function ( fileName ) { return this . initWithTexture ( cc . TextureCache . sharedTextureCache ( ) . addImage ( fileName ) ) ; }
function ( index ) { switch ( index ) { case 0 : return new SpriteProgressToRadial ( ) ; case 1 : return new SpriteProgressToHorizontal ( ) ; case 2 : return new SpriteProgressToVertical ( ) ; } return null ; }
function ( subject , encoding ) { var length = 0 ; for ( var i = 0 , l = subject . length ; i < l ; ++ i ) { length += utf8toHex ( subject . charAt ( i ) ) . length ; } return length ; }
function string2ArrayBuffer ( string , callback ) { var bb = new WebKitBlobBuilder ( ) ; bb . append ( string ) ; var f = new FileReader ( ) ; f . onload = function ( e ) { callback ( e . target . result ) ; } f . readAsArrayBuffer ( bb . getBlob ( ) ) ; }
function arrayBuffer2String ( buf , callback ) { var bb = new WebKitBlobBuilder ( ) ; bb . append ( buf ) ; var f = new FileReader ( ) ; f . onload = function ( e ) { callback ( e . target . result ) } f . readAsText ( bb . getBlob ( ) ) ; }
function send ( address , port , message ) { var buf ; message . v = this . version ; util . debug ( 'Sending (to %s:%s): %j' , address , port , message ) ; try { buf = bencode . bencode ( message ) ; this . socket4 . send ( buf , 0 , buf . length , port , address ) ; } catch ( e ) { console . log ( "Couldn't send: %s" , e . stack ) ; } }
function sha1 ( data , encoding ) { var hash = crypto . createHash ( 'sha1' ) ; hash . update ( data ) ; if ( ! encoding || encoding === 'binary' ) { return new Buffer ( hash . digest ( 'base64' ) , 'base64' ) ; } else { return hash . digest ( encoding ) ; } }
function ( DHT , dgram ) { console . log ( "dgram" , dgram ) var dht = new DHT . DHT ( 51414 ) ; console . log ( "dht" , dht ) ; chrome . experimental . dns . resolve ( 'router.bittorrent.com' , function ( ) { console . log ( arguments ) } ) }
function ( c ) { console . error ( 'exit ' + c ) if ( c && ! ready ) { console . error ( 'squid must be installed to run this test.' ) c = null hadError = null process . exit ( 0 ) return } if ( c ) { hadError = hadError || new Error ( 'Squid exited with ' + c ) } if ( hadError ) throw hadError }
function onCourseAssignment ( el , response ) { if ( response . evalJSON ( true ) && response . evalJSON ( true ) . status ) { new Effect . Fade ( el . up ( ) . up ( ) ) ; } else { alert ( translations [ '_SOMEPROBLEMOCCURED' ] ) ; } }
function addGroupKey ( el ) { parameters = { group_key : $ ( 'group_key' ) . value , method : 'get' } ; var url = window . location . toString ( ) ; ajaxRequest ( el , url , parameters , onAddGroupKey ) ; }
function ( msg ) { console . log ( msg ) ; eval ( "msg =" + msg . d ) ; switch ( msg . type ) { case "question" : window . location = "answer.aspx?q=" + msg . data ; break ; case "comparison" : window . location = "compare.aspx?q=" + msg . data . join ( "+" ) ; break ; case "relate" : window . location = "relate.aspx?q=" + msg . data . join ( "+" ) ; break ; } }
function ( messages ) { var errors = this . getCompileMessages ( JSON . parse ( messages ) ) ; window . aceEditor . getSession ( ) . clearAnnotations ( ) ; window . aceEditor . getSession ( ) . setAnnotations ( errors ) ; }
function LEMpi ( ) { return Math . PI ; }
function ( years , department , data ) { moduleContext . getController ( ) . goTo ( "salesinfo/" + department + "/" + years ) ; self . tableEnabled ( true ) ; self . selectedYear ( years ) ; self . selectedDept ( department ) ; self . selectedData ( data . values ) ; }
function authentication_init_complete ( response ) { Bum . instance_id = response . instance_id ; Bum . csrf_token = response . csrf_token ; Bum . init = true ; if ( Reauth_El ) { el = Reauth_El ; Reauth_El = null ; bum_it ( el ) ; } else { Bum . find_links ( ) ; } }
function adjustPageMargins ( ) { if ( String ( window . location ) . match ( files_url_regex ) ) { $ ( '.hentry' ) . css ( 'margin' , '0px 0px 0px auto' ) ; } else { $ ( '.hentry' ) . css ( 'margin' , '0px auto' ) ; } }
function onGPSSuccess ( pos ) { var myLat = pos . coords . latitude ; var myLon = pos . coords . longitude ; var distance = haversine ( myLon , myLat , venueObj . lon , venueObj . lat ) ; console . log ( distance ) ; if ( distance <= 100 ) { console . log ( 'button enabled' ) ; $ ( '#btnCheckin' ) . removeClass ( 'ui-disabled' ) ; } }
function ( data ) { if ( data . length < 1 ) { $ . post ( endpoint + '/users' , { facebook_id : facebook_id , firstname : firstname , surname : surname , birthdate : birthdate , gender : gender , picture_url : picture_url , email : email } ) ; } window . localStorage . setItem ( "pm_facebook_id" , facebook_id ) ; $ ( location ) . attr ( 'href' , 'profile.html' ) ; }
function ( s ) { var tokens = s . split ( /\s+/ ) ; var words = [ ] ; for ( var i = 0 ; i < tokens . length ; i ++ ) { var token = tokens [ i ] ; if ( token == '' ) continue ; if ( /^-?\d+/ . test ( token ) ) words . push ( parseInt ( token ) ) ; else words . push ( token . toLowerCase ( ) ) ; } return words ; }
function ( a , b ) { if ( a . timestamp && b . timestamp ) { var ts_a = parseInt ( a . timestamp ) ; var ts_b = parseInt ( b . timestamp ) ; return ts_a < ts_b ; } else { return a . filename . localeCompare ( b . filename ) ; } }
function createMovieObj ( filepath , avail ) { var filename = path . basename ( filepath ) ; var m = { } ; m [ 'hash' ] = getHash ( filename ) ; m [ 'fullpath' ] = filepath ; m [ 'filename' ] = filename ; m [ 'available' ] = avail ; m [ 'timestamp' ] = ( new Date ( ) ) . getTime ( ) ; return m ; }
function onSaved ( ) { module = cachedModules [ uri ] if ( module . status >= STATUS . SAVED ) { var deps = getPureDependencies ( module ) if ( deps . length ) { Module . prototype . _load ( deps , function ( ) { cb ( module ) } ) } else { cb ( module ) } } else { cb ( ) } }
function require ( id ) { var uri = resolve ( id , module . uri ) var child = cachedModules [ uri ] if ( ! child || child . status < STATUS . LOADED ) { return null } if ( isCircular ( child ) ) { return child . exports } child . parent = module return child . _compile ( ) }
function onSaved ( ) { module = cachedModules [ uri ] if ( module . status >= STATUS . SAVED ) { var deps = getPureDependencies ( module ) if ( deps . length ) { Module . prototype . _load ( deps , function ( ) { cb ( module ) } ) } else { cb ( module ) } } else { cb ( ) } }
function require ( id ) { var uri = resolve ( id , module . uri ) var child = cachedModules [ uri ] if ( ! child || child . status < STATUS . LOADED ) { return null } if ( isCircular ( child ) ) { return child . exports } child . parent = module return child . _compile ( ) }
function ( ) { var i , l , p , r = [ ] for ( i = 0 , l = this . length ; i < l ; i ++ ) { p = this [ i ] while ( p = p . previousSibling ) p . nodeType == 1 && r . push ( p ) p = this [ i ] while ( p = p . nextSibling ) p . nodeType == 1 && r . push ( p ) } return $ ( r ) }
function ( colname ) { var ret = { } , $t = this [ 0 ] ; if ( ! $t . grid ) { return ; } var cM = $t . p . colModel ; for ( var i = 0 ; i < cM . length ; i ++ ) { if ( cM [ i ] . name == colname ) { ret = cM [ i ] ; break ; } } return ret ; }
function ( ) { var a = D . P ( arguments ) ; F ( a ) } ; K && b && ( l . define = K ) ; c . amd = { plugins : h , jQuery : h , $ : "0.6.5" } ; b && ( D . b = D . F ) ; return D . F ( a ) } , F : function ( a , b ) {
function ( ) { var a = F . S ( arguments ) ; I ( a ) } ; M && b && ( m . define = M ) ; d . amd = { plugins : h , jQuery : h , da : "0.6.5" } ; b && ( F . b = F . I ) ; return F . I ( a ) } , I : function ( a , b ) {
function ( ) { var a = F . X ( arguments ) ; fa ( a ) } ; K && b && ( s . define = K ) ; c . amd = { plugins : m , jQuery : m , na : "0.6.5" } ; b && ( F . c = F . N ) ; return F . N ( a ) } , N : function ( a , b ) {
function ( ) { var a = G . S ( arguments ) ; I ( a ) } ; M && b && ( m . define = M ) ; c . amd = { plugins : h , jQuery : h , da : "0.6.5" } ; b && ( G . b = G . I ) ; return G . I ( a ) } , I : function ( a , b ) {
function ( ) { var a = F . P ( arguments ) ; I ( a ) } ; M && b && ( l . define = M ) ; c . amd = { plugins : h , jQuery : h , $ : "0.6.5" } ; b && ( F . b = F . F ) ; return F . F ( a ) } , F : function ( a , b ) {
function ( ) { if ( self . _ended ) return ; self . proto = self . _createProto ( ) ; self . proto . start ( ) ; }
function ( user ) { var userIds = Object . keys ( this . users ) ; this . users [ user . id ] = user ; user . sendCommand ( 'joinSuccess' , { channelName : this . name , id : user . id , userIds : userIds } ) ; this . sendCommandToAllUsersExcept ( 'userJoined' , user . id , user ) ; this . gameController . createPlayerForUser ( user ) }
function GameController ( ) { Parent . call ( this , new PhysicsEngine ( ) ) ; this . inputControllers = { } ; this . update ( ) ; this . updateWorld ( ) ; }
function ( topic , args ) { if ( ! this . topics [ topic ] ) { throw "No such topic " + topic + ". Could not trigger." ; } var subscribers = this . topics [ topic ] ; var len = subscribers ? subscribers . length : 0 ; while ( len -- ) { subscribers [ len ] . func ( topic , args ) ; } }
function ( topic , func ) { if ( ! this . topics [ topic ] ) { this . topics [ topic ] = [ ] ; } var token = ( ++ this . subUid ) . toString ( ) ; this . topics [ topic ] . push ( { token : token , func : func } ) ; return token ; }
function ( channel ) { if ( NotificationCenter ) { NotificationCenter . off ( "updateClientsWorld" ) ; } this . channel = channel ; NotificationCenter = this . channel . notificationCenter ; this . factory = this . channel . factory ; var self = this ; NotificationCenter . on ( "sendCommandToAllUsers" , function ( topic , args ) { self . sendCommand . apply ( self , args ) ; } ) ; }
function ( command , options ) { switch ( command ) { case 'join' : this . coordinator . assignUserToChannel ( this , options ) ; break ; case 'leave' : this . coordinator . assignUserToLobby ( this ) ; break ; case 'gameCommand' : for ( var gameCommand in options ) { NotificationCenter . trigger ( "processGameCommandFromUser" , [ gameCommand , options [ gameCommand ] , this ] ) ; } break ; default : break ; } }
function ( pokemon , target , move ) { if ( move . isTwoTurnMove && pokemon . useItem ( ) ) { this . debug ( 'power herb - remove charge turn for ' + move . id ) ; this . add ( '-prepare' , pokemon , move , target ) ; pokemon . addVolatile ( move . id ) ; } }
function ( ) { $ ( '#id_producto_no_maderable' ) . change ( function ( ) { if ( ( $ ( "#id_producto_no_maderable" ) . val ( ) ) == 1 ) { $ ( '.field-tipo_producto' ) . show ( "100" ) ; } else { $ ( '.field-tipo_producto' ) . hide ( "100" ) ; } } ) ; }
function ( ) { M . EventDispatcher . registerEvent ( 'orientationchange' , $ ( window ) , { target : M . EventDispatcher , action : 'dispatchOrientationChangeEvent' } , [ 'orientationchange' ] , null , NO , YES ) ; $ . mobile . initializePage ( ) ; $ ( "[data-role=header]" ) . fixedtoolbar ( { hideDuringFocus : "" } ) ; }
function ( ) { db . close ( ) ; }
function ( canvas ) { this . canvas = canvas ; this . speed = 1 ; this . pieceSize = 20 ; this . gapTiles = 20 ; this . tiles = this . calculateTiles ( ) ; this . map = this . generateBlankMap ( ) ; this . shiftMapRow ( true ) ; this . grid = this . generateGrid ( canvas ) ; }
function foreground ( ) { var uiElements = uiElements ( ) ; var listen = function ( ) { chrome . extension . onConnect . addListener ( function ( port ) { port . onMessage . addListener ( function ( message ) { if ( message . errorMessage ) alert ( message . errorMessage ) ; uiElements . updateWithMessage ( message ) ; } ) ; } ) ; } ( ) ; }
function playlistsTab ( ) { var contentHeader = contentHeader ( '#PlaylistDisplay' , 'Add Playlist' , 'Enter a playlist name' ) var playlistList = playlistList ( contentHeader ) ; return { setContentHeaderTitle : function ( title ) { contentHeader . setTitle ( title ) ; } , reloadList : function ( ) { playlistList . reload ( ) ; } } ; }
function ( doc , xpath ) { var nodes = [ ] ; try { var result = doc . evaluate ( xpath , doc , null , XPathResult . ANY_TYPE , null ) ; for ( var item = result . iterateNext ( ) ; item ; item = result . iterateNext ( ) ) nodes . push ( item ) ; } catch ( exc ) { } return nodes ; }
function ( value ) { for ( var i = 0 ; i < this . _size ; i ++ ) { var item = this . _items [ i ] ; if ( JSIL . ObjectEquals ( item , value ) ) return i ; } return - 1 ; }
function ( ) { if ( this . readyState === 4 ) { try { var response = JSON . parse ( this . response ) ; } catch ( err ) { callback ( { error : "an unknown error occured" } ) ; return ; } callback ( response ) ; } }
function ( ) { if ( this . readyState === 4 ) { try { var response = JSON . parse ( this . response ) ; } catch ( err ) { callback ( { error : "an unknown error occured" } ) ; return ; } callback ( response ) ; } }
function showErrorDialog ( message , callback ) { var dialog = Dialog . spawn ( "error-message" , { data : message , events : { cancel : function ( e ) { dialog . close ( ) ; if ( callback ) { callback ( ) ; } } } } ) ; }
function ( e ) { if ( e . error !== "okay" ) { showErrorDialog ( "There was a problem saving your project. Please try again." ) ; return ; } else { var url = e . url ; var dialog = Dialog . spawn ( "share" , { data : url } ) ; } }
function ( ) { this . _super ( ) ; this . _emitter = cc . ParticleExplosion . create ( ) ; this . _background . addChild ( this . _emitter , 10 ) ; this . _emitter . setTexture ( cc . TextureCache . sharedTextureCache ( ) . addImage ( s_stars1 ) ) ; this . _emitter . setShapeType ( cc . PARTICLE_STAR_SHAPE ) ; this . _emitter . setIsAutoRemoveOnFinish ( true ) ; this . setEmitterPosition ( ) ; }
function ( ) { if ( cc . NODE_TRANSFORM_USING_AFFINE_MATRIX ) { this . _isTransformGLDirty = true ; } this . _anchorPoint = new cc . Point ( 0 , 0 ) ; this . _anchorPointInPoints = new cc . Point ( 0 , 0 ) ; this . _contentSize = new cc . Size ( 0 , 0 ) ; var director = cc . Director . sharedDirector ( ) ; this . _actionManager = director . getActionManager ( ) ; this . _scheduler = director . getScheduler ( ) ; this . _children = [ ] ; }
function ( texture ) { this . _texture = texture ; if ( ( texture instanceof HTMLImageElement ) || ( texture instanceof HTMLCanvasElement ) ) { } else { if ( this . _texture && ! this . _texture . getHasPremultipliedAlpha ( ) && ( this . _blendFunc . src == cc . BLEND_SRC && this . _blendFunc . dst == cc . BLEND_DST ) ) { this . _blendFunc . src = GL_SRC_ALPHA ; this . _blendFunc . dst = GL_ONE_MINUS_SRC_ALPHA ; } } }
function ( isBlendAdditive ) { this . _isBlendAdditive = isBlendAdditive ; return ; if ( isBlendAdditive ) { } else { if ( this . _texture && ! this . _texture . getHasPremultipliedAlpha ( ) ) { } else { this . _blendFunc . src = cc . BLEND_SRC ; this . _blendFunc . dst = cc . BLEND_DST ; } } }
function ( ) { if ( cc . renderContextType == cc . CANVAS ) { } else { if ( cc . USES_VBO ) { glBindBuffer ( GL_ARRAY_BUFFER , quadsID ) ; glBufferSubData ( GL_ARRAY_BUFFER , 0 , sizeof ( quads [ 0 ] ) * particleCount , quads ) ; glBindBuffer ( GL_ARRAY_BUFFER , 0 ) ; } } }
function ( pars , divPrecarga , divCarga , callback ) { "use strict" ; new Ajax . Request ( url , { method : 'post' , parameters : pars , onCreate : $ ( divPrecarga ) . innerHTML = imgCarga , onComplete : function gen ( respuesta ) { $ ( divCarga ) . innerHTML = respuesta . responseText ; if ( callback ) { callback ( ) ; } } } ) ; }
function ( ) { "use strict" ; var fields , buttons , i ; fields = [ 'fecha_inicio_a' , 'fecha_fin_a' , 'fecha_inicio_b' , 'fecha_fin_b' ] ; buttons = [ 'boton_fecnicio_a' , 'boton_fecha_fin_a' , 'boton_fecha_inicio_b' , 'boton_fecha_fin_b' ] ; for ( i = 0 ; i < fields . length ; i ++ ) { Calendar . setup ( { inputField : fields [ i ] , ifFormat : '%d-%m-%Y' , showsTime : true , buttons : buttons [ i ] , singleClick : false , step : 1 } ) ; } }
function ( code , lang ) { if ( ! highlight ) { return code ; } if ( lang && hl . LANGUAGES [ lang ] ) { return hl . highlight ( lang , code ) . value ; } else { return hl . highlightAuto ( code ) . value ; } }
function ( ) { var active_editable_obj = this . getBaseElement ( ) ; if ( ! active_editable_obj ) { return ; } $ ( Aloha . activeEditable . obj ) . attr ( 'aloha-numerated-headers' , 'false' ) ; var headingselector = this . getCurrentConfig ( ) . headingselector ; var headers = active_editable_obj . find ( headingselector ) ; headers . each ( function ( ) { $ ( this ) . find ( 'span[role=annotation]' ) . each ( function ( ) { $ ( this ) . remove ( ) ; } ) ; } ) ; }
function ( ) { if ( typeof this . baseobjectSelector !== 'undefined' ) { return ( $ ( this . baseobjectSelector ) . length > 0 ) ? $ ( this . baseobjectSelector ) : null ; } return Aloha . activeEditable ? Aloha . activeEditable . obj : null ; }
function ( declare , domAttr , domClass , _Chart , ChartManager , Areas ) { var chart = declare ( 'Sage.Platform.Mobile.Charts.AreaChart' , [ _Chart ] , { xAxis : { fixLower : 'major' , fixUpper : 'major' , minorTicks : false } , yAxis : { vertical : true , fixLower : 'major' , fixUpper : 'major' , minorTicks : false } , plotType : Areas , plotOptions : { markers : false , tension : 'X' } } ) ; ChartManager . register ( 'area' , chart ) ; return chart ; }
function ( declare , domGeom , _Chart , ChartManager , Columns ) { var chart = declare ( 'Sage.Platform.Mobile.Charts.ColumnChart' , [ _Chart ] , { plotType : Columns , plotOptions : { markers : true , gap : 5 } , xAxis : { natural : true , trailingSymbol : '...' } , yAxis : { vertical : true , fixLower : 'major' , fixUpper : 'major' , minorTicks : false } } ) ; ChartManager . register ( 'column' , chart ) ; return chart ; }
function ( ) { var box = win . getBox ( ) , width = box . w , height = ( box . h > this . maxHeight ) ? this . maxHeight : box . h ; return Math . floor ( ( width > height ? height : width ) / 5 ) ; }
function ( ) { if ( ! this . sampleView ) { this . sampleView = new SampleView ( ) ; this . showView ( this . sampleView , '.container' ) ; } }
function ( path ) { if ( path . substring ( 0 , 3 ) === "../" ) return true ; if ( path . substring ( 0 , 1 ) === "/" ) return true ; path = path . split ( "/" ) ; var cwd = fs . readdirSync ( process . cwd ( ) ) ; return ! ! ( cwd . indexOf ( path [ 0 ] ) === - 1 ) ; }
function ( ) { order = $ ( this ) . val ( ) ; based = character [ order ] ; reset ( ) ; totalAttribute ( based , 'based' ) ; diff ( ) ; totalAttribute ( replacement , 'replacement' ) ; calculate ( based , 'based' ) ; calculate ( replacement , 'replacement' ) ; saveProfile ( ) ; }
function ContentSecurityPolicy ( ) { CSPdebug ( "CSP CREATED" ) ; this . _isInitialized = false ; this . _reportOnlyMode = false ; this . _policy = CSPRep . fromString ( "default-src *" ) ; this . _policy . _allowInlineScripts = true ; this . _policy . _allowEval = true ; this . _request = "" ; this . _referrer = "" ; this . _docRequest = null ; CSPdebug ( "CSP POLICY INITED TO 'default-src *'" ) ; }
function ( aViolationType , aSourceFile , aScriptSample , aLineNum ) { switch ( aViolationType ) { case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_INLINE_SCRIPT : if ( ! this . _policy . allowsInlineScripts ) this . _asyncReportViolation ( 'self' , null , 'inline script base restriction' , 'violated base restriction: Inline Scripts will not execute' , aSourceFile , aScriptSample , aLineNum ) ; break ; case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_EVAL : if ( ! this . _policy . allowsEvalInScripts ) this . _asyncReportViolation ( 'self' , null , 'eval script base restriction' , 'violated base restriction: Code will not be created from strings' , aSourceFile , aScriptSample , aLineNum ) ; break ; } }
function ( ) { var __ref ; return ( ( __ref = ( __ref = this . tokens ) [ __ref . length - 2 ] ) != null ? __ref [ 0 ] : void 8 ) === 'FOR' && ( this . seenFor = false , this . seenFrom = true , this ) ; }
function ( e ) { var code = e . keyCode || e . which ; if ( ( code == 13 ) && ( this . $el . find ( ".username" ) . val ( ) != "YourNewUserNameGoesHere" ) ) { this . model . set ( "username" , $ ( ".username" ) . val ( ) ) ; $ ( ".confirm-password" ) . show ( ) ; $ ( ".password" ) . focus ( ) } }
function ( ) { var node = nb . createProxy ( 5 ) ; util . assert ( node . id == 5 , "Expected id {0}, got {1}" , 5 , node . id ) ; util . assert ( node . version == undefined , "Expected undefined version, got {0}" , node . version ) ; util . assert ( node . isIncomplete ( ) , "Expected node is incomplete, got {0}" , node . isIncomplete ( ) ) ; }
function getDigit ( start , stop ) { return '[\\d' + ( set [ 'digits' ] || '' ) + ']' + ( start ? '{' + start + ',' + stop + '}' : '+' ) ; }
function getNum ( ) { var arr = [ getDigit ( ) ] . concat ( set [ 'articles' ] ) ; console . info ( 'hrmmmmmmmmmm' , set [ 'numbers' ] ) ; if ( set [ 'numbers' ] ) arr = arr . concat ( set [ 'numbers' ] ) ; return arr . compact ( ) . join ( '|' ) ; }
function collectDateArguments ( args ) { var obj , arr ; if ( object . isObject ( args [ 0 ] ) ) { return args ; } else if ( args . length == 1 && object . isNumber ( args [ 0 ] ) ) { return [ args [ 0 ] ] ; } obj = { } ; DateArgumentUnits . each ( function ( u , i ) { obj [ u . unit ] = args [ i ] ; } ) ; return [ obj ] ; }
function ( finishMove ) { var hiddenItems = $ ( '.lazy' , currentSlide ) ; if ( hiddenItems . length > 0 ) { this . moveTo ( currentIndex , finishMove ) ; } else { var prev = currentSlide . attr ( 'data-prev' ) ; if ( prev ) { this . moveTo ( parseInt ( prev , 10 ) , finishMove ) ; } else if ( currentIndex > 0 ) { this . moveTo ( currentIndex - 1 , finishMove ) ; } } }
function ( ) { browser . visit ( "http://localhost:3000/slider/" + newSlider . name + "/editor" , function ( ) { expect ( browser . success ) ; browser . fill ( "passcode" , newSlider . passcode ) . pressButton ( "OK" , function ( ) { done ( ) ; } ) ; } ) ; }
function ( done ) { var browser = new Browser ( ) ; browser . visit ( "http://localhost:3000/slider" , function ( ) { browser . fill ( "name" , newSlider . name ) . fill ( "passcode" , newSlider . passcode ) . fill ( "title" , newSlider . title ) . fill ( "description" , newSlider . description ) . pressButton ( "Create!" , done ) ; } ) ; }
function ( event ) { var rotation = event . rotation ; var deg = rotation < 0 ? 180 + ( rotation * - 1 ) : rotation ; console . log ( 'pinch ' + deg ) ; $ ( selectedPhoto ) . css ( '-webkit-transform' , 'rotate(' + deg + 'deg)' ) ; }
function ( arr ) { var len = arr . length , sums = new Array ( len ) , i = 1 ; sums [ 0 ] = arr [ 0 ] ; for ( ; i < len ; i ++ ) { sums [ i ] = sums [ i - 1 ] + arr [ i ] ; } return sums ; }
function ( sfs ) { _ . defaults ( options , { model : m , summaryFields : sfs } ) ; var q ; try { q = new Query ( options , service ) ; } catch ( e ) { promise . reject ( e ) ; } if ( cb ) { try { cb ( q ) ; } catch ( e ) { promise . reject ( e ) ; } } promise . resolve ( q ) ; }
function ( ) { var c$ = this . container . getPanels ( ) ; var port = this . containerBounds [ this . axisSize ] ; var box = port - this . margin - this . margin ; for ( var i = 0 , b , c ; c = c$ [ i ] ; i ++ ) { b = { } ; b [ this . axisSize ] = box ; b [ this . offAxisSize ] = "100%" ; c . setBounds ( b ) ; } }
function ( ) { var c$ = this . container . getPanels ( ) ; var b = this . containerBounds ; var w = this . controlWidth = b . width / 3 ; var h = this . controlHeight = b . height / 3 ; for ( var i = 0 , c ; c = c$ [ i ] ; i ++ ) { c . setBounds ( { width : w , height : h } ) ; } }
function ( ) { this . inherited ( arguments ) ; var c$ = this . getOrderedControls ( this . container . toIndex ) ; for ( var i = 0 , c ; c = c$ [ i ] ; i ++ ) { c . applyStyle ( "z-index" , c$ . length - i ) ; } }
function ( ) { var c$ = this . container . getPanels ( ) ; var w = this . colWidth , h = this . colHeight ; for ( var i = 0 , c ; c = c$ [ i ] ; i ++ ) { c . setBounds ( { width : w , height : h } ) ; } }
function ( ) { this . destroyMap ( ) ; try { this . createMap ( ) ; } catch ( e ) { this . doLoadFailure ( e ) ; return ; } this . mapTypeChanged ( ) ; this . updateCenter ( ) ; this . zoomChanged ( ) ; this . showPinChanged ( ) ; this . doLoaded ( ) ; }
function ( inExcludes ) { this . map . entities . clear ( ) ; if ( this . showPin && this . pin ) { this . map . entities . push ( this . pin ) ; } if ( inExcludes ) { for ( var i = 0 , ex ; ex = inExcludes [ i ] ; i ++ ) { if ( ex ) { this . map . entities . push ( ex ) ; } } } }
function ( inCallback ) { if ( window [ "Microsoft" ] && window [ "Microsoft" ] [ "Maps" ] ) { inCallback && inCallback ( ) ; } else { this . scriptLoadedCbs . push ( inCallback ) ; if ( ! this . alreadyCalled ) { this . alreadyCalled = true ; this . addScript ( ) ; } } }
function ( ) { this . inherited ( arguments ) ; for ( var i = 0 , b ; b = mock_bookmarks [ i ] ; i ++ ) { var c = this . createComponent ( { kind : "BookmarkItem" , ontap : "itemTap" , } , b ) ; c . setTitle ( b . Title ) ; c . setDetails ( b . Address ) ; } }
function ( inSender ) { if ( this . activated ) { this . activated . applyStyle ( "background" , null ) ; } this . activated = inSender ; this . activated . applyStyle ( "background" , "lightblue" ) ; this . doItemSelect ( inSender ) ; }
function ( img ) { var canvas = document . getElementById ( 'share' ) ; var ctx = canvas . getContext ( '2d' ) ; for ( var i = 0 ; i < img . length ; i ++ ) { draw ( img [ i ] , ctx ) ; } go ( socket , canvas , ctx ) ; }
function ( device ) { this . mobile = true ; this . found . device = device ; this . found . browser_version = $ . browser . version ; this . found . supported_browser_version = this . s [ device ] ; if ( this . s . test_mobile_os || ! this . test_device ) return ; if ( ! this . s [ device ] || ( $ . browser . version < this . s [ device ] ) ) this . devive_not_supported ( device ) ; }
function ( e ) { var reverse ; if ( $ ( this ) . attr ( 'href' ) ) { e . preventDefault ( ) ; reverse = false ; if ( $ ( this ) . attr ( 'data-transition' ) === 'reverse' ) { reverse = true ; } return changePage ( $ ( this ) . attr ( 'href' ) , { transition : 'slide' , reverse : reverse } ) ; } }
function ( filepath ) { grunt . log . ok ( 'File "' + filepath + '" ' + changedFiles [ filepath ] + '.' ) ; grunt . file . clearRequireCache ( filepath ) ; }
function ( $compile ) { var element ; element = $compile ( "<ui-template ng-model='mymodel'></ui-template>" ) ( scope ) ; scope . $apply ( function ( ) { scope . mymodel = 'MODELVAL' ; } ) ; expect ( element . text ( ) ) . toEqual ( 'MODELVAL' ) ; }
function ( request , response ) { if ( request . cookies . auth == true ) { response . writeHead ( 200 , { 'Content-Type' : 'text/html' } ) ; response . write ( '<h1>Login Success</h1>' ) ; response . end ( ) ; } else { fs . readFile ( '/node.chapter.7-7.login.html' , function ( error , data ) { response . writeHead ( 200 , { 'Content-Type' : 'text/html' } ) ; response . write ( data ) ; response . end ( ) ; } ) ; } }
function is ( it , type ) { var t = it === void 0 ? "" : ( { } ) . toString . call ( it ) , m = t . match ( /^\[object (.+)\]$/ ) , v = m ? m [ 1 ] : "Undefined" ; return type ? type === v : v ; }
function ( e ) { e = e || global . event ; var node = e . target || e . srcElement ; if ( e . type === "load" || /complete|loaded/ . test ( node . readyState ) ) { disconnect ( ) ; onLoad ( ) ; } }
function ( ) { deps [ j ] = m . def ; if ( -- count === 0 ) { callback . apply ( null , deps ) ; count = - 1 ; } }
function ( ) { if ( loaded ) { console . warn ( "app.js already loaded!" ) ; } else { var n = Math . round ( Math . random ( ) * 1e12 ) ; waiting . push ( n ) ; return function ( ) { var p = waiting . indexOf ( n ) ; ~ p && waiting . splice ( p , 1 ) ; loaded = 1 ; waiting . length || require ( cfg . main || [ "app.js" ] ) ; } ; } }
function detectReady ( evt ) { if ( isReady || ( evt && evt . type == "readystatechange" && ! readyStates [ doc . readyState ] ) ) { return ; } while ( readyQ . length ) { ( readyQ . shift ( ) ) ( ) ; } isReady = 1 ; }
function ( e ) { switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : if ( ! this . shown ) return this . hide ( ) break default : this . lookup ( ) } e . stopPropagation ( ) e . preventDefault ( ) }
function ( err , docs ) { if ( ! err ) { res . render ( 'admin/board_modify_view' , { title : 'board_modify' , docs : docs } ) ; } else { console . log ( 'in admin.js, modify_view : error(01)' ) ; } }
function ( err ) { if ( ! err ) { console . log ( 'in admin.js, board_update : success' ) ; var alert_script = alert . AlertRedirect ( "수정되었습니다." , '/admin/main' ) ; res . render ( 'alert/alert' , { title : "Success" , alert : alert_script } ) ; } else { console . log ( 'in admin.js, board_update : err(01)' ) ; } }
function ( comments , length ) { res . render ( 'board/show' , { title : 'Show Contents' , board : docs , board_id : board_id , comment : comments , length : length , sessionId : req . session . user . Id , session : req . session . user } ) ; }
function ( obj , secondary , key , lambda , error_lambda ) { var params = null console . log ( key ) ; _staticApi . call ( ( 'get/' + obj + "by" + secondary + "/" + key ) , params , function ( data ) { Log ( 'debug' , 'response data:' , data ) ; lambda ( data ) ; } , error_lambda ) }
function ( ) { var comment = $ ( "div id='comments'><div class='comment'><div class='user-icon'></div><div class='body'>Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non!<div class='time'>about 20 minutes ago</div></div></div>" ) ; var comment2 = $ ( "div id='comments'><div class='comment'><div class='user-icon'></div><div class='body'>Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non!<div class='time'>about 20 minutes ago</div></div></div>" ) ; $ ( '#comments' ) . append ( comment ) ; $ ( '#comments' ) . append ( comment2 ) ; }
function ( userdata ) { Log ( 'info' , 'Showing user modal for ' + username ) ; userdata . username = username ; var u = new User ( userdata ) ; u . streams = userdata ; console . log ( u ) Frontend . userModal . show ( html , u ) ; }
function ( html , data ) { console . log ( this . page ) if ( typeof ( data ) === 'object' ) { var template = Handlebars . compile ( html ) ; html = template ( data ) ; $ ( '#hidden-data' ) . html ( $ ( html ) ) ; $ ( '#hidden-div' ) . attr ( 'href' , '#hidden-data' ) . fancybox ( ) . click ( ) ; } }
function ( ) { if ( r . constant . MY_BROWSER === 'msie' ) { var output = document . selection . createRange ( ) . text ; } else { var output = window . getSelection ( ) . toString ( ) ; } return output ; }
function ( event ) { if ( event . which === 13 ) { var output = '<br />' ; if ( r . constant . MY_BROWSER === 'firefox' ) { output += '<div></div>' ; } if ( r . constant . MY_BROWSER === 'msie' ) { houtputtml += '<span></span>' ; } if ( r . constant . MY_ENGINE === 'webkit' ) { output += '<br />' ; } editor . insertHTML ( output ) ; event . preventDefault ( ) ; } }
function ( message ) { if ( message . data === "</stream:stream>" ) { this . disconnect ( ) ; return ; } var string = message . data . replace ( /^<stream:([a-z]*)>/ , "<stream:$1 xmlns:stream='http://etherx.jabber.org/streams'>" ) ; parser = new DOMParser ( ) ; var elem = parser . parseFromString ( string , "text/xml" ) . documentElement ; var elem = this . _c . _bodyWrap ( elem ) . tree ( ) ; this . _c . _dataRecv ( elem ) ; }
function ( req , res , next ) { if ( req . user ) { if ( req . user . confirmed || noConfirm ) { view ( req , res , next ) ; } else { res . redirect ( '/confirm' , 307 ) ; } } else { res . redirect ( '/login' , 307 ) ; } }
function ( ) { var slide = $ ( "<div/>" , { 'class' : 'item item1' , 'id' : 'item1' } ) ; $ ( '.add-remove-slide-slider' ) . iosSlider ( 'addSlide' , slide , 2 ) ; }
function ( world ) { var newMat = new RaidersMaterial ( ) ; var propNames = [ ] , propValues = [ ] , propTypes = [ ] , propLabels = [ ] ; this . getAllProperties ( propNames , propValues , propTypes , propLabels ) ; var n = propNames . length ; for ( var i = 0 ; i < n ; i ++ ) newMat . setProperty ( propNames [ i ] , propValues [ i ] ) ; return newMat ; }
function ( ) { this . ninjaVersion = window . ninjaVersion . ninja . version ; this . undoManager = document . application . undoManager = UndoManager . create ( ) ; document . application . njUtils = NjUtils ; }
function ( ) { var transitionStopRule ; if ( this . appModel . livePreview ) { transitionStopRule = "nj-css-garbage-selector" ; this . stage . bindingView . hide = true ; } else { transitionStopRule = "*" this . stage . bindingView . hide = false ; } this . application . ninja . stylesController . _stageStylesheet . rules [ 0 ] . selectorText = transitionStopRule ; this . _toggleWebGlAnimation ( this . appModel . livePreview ) ; }
function ( event ) { this . _showMaterialPopup ( event . detail ) ; }
function ( event ) { if ( this . application . ninja . timeline . selectedStyle === "top" || this . application . ninja . timeline . selectedStyle === "master" ) { if ( ! event . wasSetByCode ) { if ( ! this . savedPosition ) this . savedPosition = this . topPosition ; this . application . ninja . elementMediator . setProperty ( [ this . layerData . stageElement ] , "top" , [ this . topControl . value + "px" ] , "Changing" , "timeline" ) ; } } }
function ( event ) { if ( this . application . ninja . timeline . selectedStyle === "width" || this . application . ninja . timeline . selectedStyle === "master" ) { if ( ! event . wasSetByCode ) { if ( ! this . savedPosition ) this . savedPosition = this . dtextScaleX ; this . application . ninja . elementMediator . setProperty ( [ this . layerData . stageElement ] , "width" , [ this . dtextScaleX + "px" ] , "Changing" , "timeline" ) ; } } }
function ( event ) { var elements = event . detail ; if ( Array . isArray ( elements ) ) { elements . forEach ( function ( element ) { this . addElement ( element ) ; } , this ) ; } else { this . addElement ( elements ) ; } this . drawWorkingPlane ( ) ; }
function safariMessageHandler ( event ) { if ( event . name == "refreshSettings" ) { safari . self . tab . dispatchMessage ( "getSettings" ) ; return ; } var savedSettings = event . message . data ; settings = parseSettings ( savedSettings ) ; applySettings ( ) ; WaitForPosts ( ) ; }
function ( ) { if ( _this . sound ) _this . sound . destruct ( ) _this . tracks = [ ] ; delete _this . tracks ; delete _this . track ; delete _this ; delete this ; }
function connectTarget ( host , port , callback ) { try { var vncSocket = net . createConnection ( port , host ) ; Logging . Info ( 'Client connected to VNC server on ' + host + ':' + port ) ; Logging . Info ( 'Start proxying from ' + serverOptions . host + ':' + serverOptions . port + ' to ' + host + ':' + port + "\n" ) ; callback ( vncSocket ) ; } catch ( e ) { Logging . Error ( 'Could not create connection to VNC: ' + e . message ) ; } }
function ( html ) { if ( ! module . FormDialog . checkOpenError ( html ) ) { jQuery ( "body" ) . append ( html ) ; var form = new _class ( jQuery ( "#" + _ID ) ) ; form . fragment = fragment ; form . modal = modal ; form . onRegistered = onRegistered ; form . open ( ) ; } }
function ( element ) { module . FormDialog . call ( this , element ) ; window . fileForm = this ; this . id = _ID ; this . modal = false ; this . indicator = this . element . find ( "span.indicator" ) ; this . fragment = null ; this . onRegistered = null ; }
function ( html ) { if ( outer . checkErrors ( html ) ) { piggydb . widget . imageViewer . close ( ) ; outer . unblock ( ) ; } else { piggydb . widget . Fragment . onAjaxSaved ( html , outer . fragment ) ; outer . close ( ) ; if ( jQuery . isFunction ( outer . onRegistered ) ) outer . onRegistered ( html ) ; } }
function fetch ( url , callback ) { if ( templates [ url ] ) callback ( null , templates [ url ] ) ; else resolver ( url , "text/xml" , check ( callback , function ( doc ) { callback ( null , templates [ url ] = { url : url , doc : doc , funcs : { } } ) ; } ) ) ; }
function resolver ( url , mimeType , callback ) { var resolved = path . resolve ( base , url ) switch ( mimeType ) { case "text/javascript" : try { callback ( null , require ( resolved ) ) ; } catch ( error ) { callback ( error ) ; } break ; case "text/xml" : callback ( null , new ( xmldom . DOMParser ) ( ) . parseFromString ( fs . readFileSync ( resolved , "utf8" ) ) ) ; break ; } }
function create ( base ) { return function resolver ( url , mimeType , callback ) { var resolved = path . resolve ( base , url ) switch ( mimeType ) { case "text/javascript" : try { callback ( null , require ( resolved ) ) ; } catch ( error ) { callback ( error ) ; } break ; case "text/xml" : callback ( null , new ( xmldom . DOMParser ) ( ) . parseFromString ( fs . readFileSync ( resolved , "utf8" ) ) ) ; break ; } } }
function ( ) { var context = { stencil : require ( "../../index" ) , resolver : require ( "../../resolver" ) , compare : require ( "../compare" ) , fixture : function ( file , callback ) { fs . readFile ( path . resolve ( __dirname , file ) , "utf8" , callback ) } } ; return context ; }
function ( ) { var num = Math . floor ( Math . random ( ) * 11 ) - 1 ; $ ( '.main-image-div' ) . css ( "background" , "url(" + flickrImages [ num ] . image_b + ")" ) ; $ ( '.float' ) . html ( "<h4>" + flickrImages [ num ] . title + "</h4>" ) ; $ ( '.main-image-div' ) . click ( function ( ) { window . location = flickrImages [ num ] . link ; } ) ; }
function ( ) { function scrollIntoViewCallback ( object ) { function scrollIntoView ( ) { this . scrollIntoViewIfNeeded ( true ) ; } if ( object ) object . callFunction ( scrollIntoView ) ; } WebInspector . RemoteObject . resolveNode ( this . representedObject , "" , scrollIntoViewCallback ) ; }
function ( ) { var slug = $ ( this ) . data ( 'slug' ) ; if ( ! ( slug in reports ) ) { var advr = new advreport ( $ ( this ) ) ; reports [ slug ] = advr ; } }
function ( v ) { return lang . isArray ( v ) ? "array" : lang . isFunction ( ( v || { } ) . getTime ) ? "date" : v != null && { } . toString . call ( v ) == "[object Object]" ? "object" : "value" ; }
function ( dst , src , options ) { var options = options || equals , types = [ options . getType ( dst ) , options . getType ( src ) ] ; return types [ 0 ] != types [ 1 ] ? false : options [ "equals" + types [ 0 ] . replace ( /^[a-z]/ , function ( c ) { return c . toUpperCase ( ) ; } ) ] ( dst , src ) ; }
function Vertical ( images , spriteDef , layout ) { this . images = images ; this . spriteDef = spriteDef ; this . layout = layout ; this . width = 0 ; this . height = 0 ; this . labels = { fix : [ ] , line : [ ] , close : [ ] } ; this . blocks = [ ] ; this . init ( ) ; }
function ( evt ) { $ [ '_each' ] ( findHdls ( el , evt , fn , sel ) , function ( hdl ) { delete handlers [ id ] [ hdl . i ] ; unbind ( el , hdl . e , hdl . del || hdl . fn ) ; } ) ; }
function remEvt ( el , evts , fn , sel ) { var id = jquid ( el ) ; $ [ '_each' ] ( ( evts || '' ) . split ( /\s/ ) , function ( evt ) { $ [ '_each' ] ( findHdls ( el , evt , fn , sel ) , function ( hdl ) { delete handlers [ id ] [ hdl . i ] ; unbind ( el , hdl . e , hdl . del || hdl . fn ) ; } ) ; } ) ; }
function ( ) { if ( $ ( this ) . val ( ) == 'Subtitle' ) { $ ( this ) . val ( '' ) ; $ ( this ) . focus ( ) ; $ ( this ) . bind ( 'blur' , function ( ) { if ( $ ( this ) . val ( ) == '' ) { $ ( this ) . val ( 'Subtitle' ) ; } } ) } }
function ( response ) { if ( response . success ) { $ . formReset ( $form ) ; $modal . modal ( 'hide' ) ; $successModal . find ( '.modal-body h3' ) . html ( response . message ) ; $successModal . modal ( 'show' ) . delay ( 3000 , function ( e ) { } ) ; } else { elm . error ( response . message , $content , 'prepend' ) ; } }
function ( response ) { if ( response . success ) { $ . formReset ( $form ) ; $modal . modal ( 'hide' ) ; $successModal . find ( '.modal-body h3' ) . html ( response . message ) ; $successModal . modal ( 'show' ) . delay ( 3000 , function ( e ) { } ) ; } else { elm . error ( response . message , $content , 'prepend' ) ; } }
function _initRecurse ( ) { if ( typeof ( elm . myPosition ) == 'undefined' ) { initLocation ( ) ; locationTimeout = window . setTimeout ( function ( ) { _initRecurse ( ) } , 300 ) ; } else { initialLocation = new google . maps . LatLng ( elm . myPosition . lat , elm . myPosition . long ) ; _initMap ( ) ; } }
function ( attributesLong , id , rowData ) { s = '<select ' + attributesLong + ' multiple>' ; for ( x in rowData . options ) { s += '<option value="' + x + '"' + ( rowData . value != null && $ . inArray ( x , rowData . value . split ( ',' ) ) != - 1 ? ' selected' : '' ) + '>' + rowData . options [ x ] + '</option>' ; } ; s += '</select>' ; return s ; }
function ( ) { var pos = $ . extend ( { } , this . $element . offset ( ) , { height : this . $element [ 0 ] . offsetHeight } ) this . $menu . css ( { top : pos . top + pos . height , left : pos . left } ) this . $menu . show ( ) this . shown = true return this }
function ( $1 , match ) { return '<strong>' + match + '</strong>' }
function ( e ) { e . stopPropagation ( ) e . preventDefault ( ) switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : this . hide ( ) break default : this . lookup ( ) } }
function ( doc ) { onDocValueUpdate ( doc . getValue ( ) ) ; }
function showDocumentState ( show ) { showPrevNextCont ( ! show ) ; allDocsCont [ show ? 'hide' : 'show' ] ( ) ; currenDocCont [ show ? 'show' : 'hide' ] ( ) ; showCodeEditor ( ! show ) ; }
function tryShowJson ( obj ) { var isError = obj instanceof Error ; editingNotice . text ( isError && obj ? buildErrorMessage ( obj ) : '' ) ; jsonDocId . text ( isError ? '' : obj . _id ) ; self . jsonCodeEditor . setValue ( isError ? '' : JSON . stringify ( obj , null , "  " ) ) ; enableDeleteBtn ( ! isError ) ; enableSaveBtns ( ! isError ) ; showCodeEditor ( ! isError ) ; }
function buildErrorMessage ( error ) { return error . name + ': ' + error . message + ' ' + error . explanatoryMessage ; }
function ( e ) { var docsLookupVal = $ . trim ( $ ( this ) . val ( ) ) ; if ( latestSearch === docsLookupVal ) { return true ; } self . searchedDocumentCell . setValue ( docsLookupVal ) ; self . documentsPageNumberCell . setValue ( 0 ) ; }
function ( v ) { var selected = v ( self . rawViewsBucketCell ) ; if ( selected ) { return selected ; } var buckets = v . need ( DAL . cells . bucketsListCell ) . byType . membase ; var bucketInfo = _ . detect ( buckets , function ( info ) { return info . name === "default" } ) || buckets [ 0 ] ; return bucketInfo ; }
function ( builder , intPage , subset ) { var html = "" ; if ( builder ) { var url = builder ( intPage , subset ) ; var text = url . substring ( url . indexOf ( '?' ) ) ; html = "<a href='" + escapeHTML ( url ) + "'>" + escapeHTML ( decodeURIComponent ( text ) ) + '</a>' ; } $ ( '.view_query_string' ) . html ( html ) ; }
function ( ) { goog . ui . ControlRenderer . call ( this ) ; }
function ( ) { goog . ui . ControlRenderer . call ( this ) ; }
function ( ) { todomvc . view . ToDoItemControl . superClass_ . enterDocument . call ( this ) ; this . getHandler ( ) . listen ( this . getElement ( ) , goog . events . EventType . CLICK , function ( e ) { e . preventDefault ( ) ; } ) ; }
function ( ) { goog . ui . ControlRenderer . call ( this ) ; }
function ( err , sites ) { if ( err ) { util . error ( err . message ) res . writeHead ( 500 ) res . end ( ) } res . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) res . end ( sites ) }
f var len = data . trim ( ) . length , js = data . split ( '{' ) . length , html = data . split ( /<\s*\w+/ ) . length if ( len === 0 ) return 'zero-lenth source' if ( js < html ) return 'source looks like HTML' }
function ( ) { var template ; if ( this . options && this . options . template ) { template = this . options . template ; } else { template = this . template ; } if ( _ . isObject ( template ) && template . type === 'handlebars' ) { return template ; } return _ . bind ( oldGetTemplateSelector , this ) ( ) ; }
function ( ) { var template ; if ( this . options && this . options . template ) { template = this . options . template ; } else { template = this . template ; } if ( _ . isObject ( template ) && template . type === 'handlebars' ) { return template ; } return _ . bind ( oldGetTemplateSelector , this ) ( ) ; }
function Module ( filename , stubs ) { this . id = this . filename = filename ; this . dirname = dirname ( filename ) ; this . exports = { } ; this . stubs = { } ; for ( var name in stubs ) { this . stubs [ name ] = stubs [ name ] ; } }
function ( ) { var billboards = new Cesium . BillboardCollection ( undefined ) ; var textureAtlas = scene . getContext ( ) . createTextureAtlas ( { image : image } ) ; billboards . setTextureAtlas ( textureAtlas ) ; billboards . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , imageIndex : 0 } ) ; primitives . add ( billboards ) ; }
function ( positions ) { if ( positions ) { var cartesians = [ ] ; var length = positions . length ; for ( var i = 0 ; i < length ; ++ i ) { cartesians . push ( this . toCartesian ( positions [ i ] ) ) ; } return cartesians ; } }
function ( positions ) { if ( positions ) { var cartographics = [ ] ; var length = positions . length ; for ( var i = 0 ; i < length ; ++ i ) { cartographics . push ( this . toCartographic3 ( positions [ i ] ) ) ; } return cartographics ; } }
function getPosition ( lla , ellipsoid , time , projection ) { if ( typeof time === 'undefined' || time === 0.0 || typeof projection === 'undefined' ) { return ellipsoid . toCartesian ( lla ) ; } var twod = projection . project ( lla ) ; twod = new Cartesian3 ( 0.0 , twod . x , twod . y ) ; return twod . lerp ( ellipsoid . toCartesian ( lla ) , time ) ; }
function ( cartesian ) { var lon = cartesian . x / this . _halfEquatorCircumference ; var lat = Math . exp ( cartesian . y / this . _quarterPolarCircumference ) ; lat = 2.0 * Math . atan ( ( lat - 1.0 ) / ( lat + 1.0 ) ) ; return new Cartographic3 ( lon * Math . PI , lat * CesiumMath . PI_OVER_TWO , cartesian . z ) ; }
function ( ) { var polyline = new Cesium . Polyline ( undefined ) ; polyline . setPositions ( Cesium . Shapes . computeCircleBoundary ( ellipsoid , ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , 300000.0 ) ) ; primitives . add ( polyline ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( Cesium . Shapes . computeCircleBoundary ( ellipsoid , ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , 300000.0 ) ) ; primitives . add ( polygon ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( Cesium . Shapes . computeCircleBoundary ( ellipsoid , ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , 300000.0 ) ) ; polygon . material = new Cesium . TieDyeMaterial ( undefined ) ; primitives . add ( polygon ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( Cesium . Shapes . computeEllipseBoundary ( ellipsoid , ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , 500000.0 , 300000.0 , Cesium . Math . toRadians ( 60 ) ) ) ; primitives . add ( polygon ) ; }
function ( projection ) { if ( typeof projection === 'undefined' ) { throw new DeveloperError ( 'projection is required.' ) ; } this . _projection = projection ; this . _maxCoord = projection . project ( new Cartographic3 ( Math . PI , CesiumMath . toRadians ( 85.05112878 ) ) ) ; }
function ( ) { var labels = new Cesium . LabelCollection ( undefined ) ; labels . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.10 , 39.57 ) ) , text : 'Philadelphia' } ) ; primitives . add ( labels ) ; }
function ( ) { var labels = new Cesium . LabelCollection ( undefined ) ; var l = labels . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.10 , 39.57 ) ) , text : 'Philadelphia' } ) ; l . setPosition ( ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic3 ( - 75.10 , 39.57 , 300000.0 ) ) ) ; l . setScale ( 2.0 ) ; primitives . add ( labels ) ; }
function ( ) { expect ( Cartesian3 . UNIT_X . equalsEpsilon ( Ellipsoid . UNIT_SPHERE . geodeticSurfaceNormalc ( Cartographic3 . ZERO ) , CesiumMath . EPSILON10 ) ) . toEqual ( true ) ; expect ( Cartesian3 . UNIT_Z . equalsEpsilon ( Ellipsoid . UNIT_SPHERE . geodeticSurfaceNormalc ( new Cartographic3 ( 0 , CesiumMath . PI_OVER_TWO , 0 ) ) , CesiumMath . EPSILON10 ) ) . toEqual ( true ) ; }
function ( ) { var height = 10.0 ; var cartographic = new Cartographic3 ( 0.0 , 0.0 , height ) ; var projection = new EquidistantCylindricalProjection ( ) ; expect ( projection . project ( cartographic ) . equals ( new Cartesian3 ( 0.0 , 0.0 , height ) ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var cartographic = new Cartographic3 ( Math . PI , CesiumMath . PI_OVER_TWO , 0.0 ) ; var expected = new Cartesian3 ( Math . PI * ellipsoid . getRadii ( ) . x , CesiumMath . PI_OVER_TWO * ellipsoid . getRadii ( ) . z , 0.0 ) ; var projection = new EquidistantCylindricalProjection ( ellipsoid ) ; expect ( projection . project ( cartographic ) . equals ( expected ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . UNIT_SPHERE ; var cartographic = new Cartographic3 ( - Math . PI , CesiumMath . PI_OVER_TWO , 0.0 ) ; var expected = new Cartesian3 ( - Math . PI , CesiumMath . PI_OVER_TWO , 0.0 ) ; var projection = new EquidistantCylindricalProjection ( ellipsoid ) ; expect ( projection . project ( cartographic ) . equals ( expected ) ) . toEqual ( true ) ; }
function ( ) { var cartographic = new Cartographic3 ( CesiumMath . PI_OVER_TWO , CesiumMath . PI_OVER_FOUR , 12.0 ) ; var projection = new EquidistantCylindricalProjection ( ) ; var projected = projection . project ( cartographic ) ; expect ( projection . unproject ( projected ) . equals ( cartographic ) ) . toEqual ( true ) ; }
function ( ) { var c = CesiumMath . cartographic3ToRadians ( new Cartographic3 ( 360.0 , 180.0 , 1.0 ) ) ; expect ( c . longitude ) . toEqual ( 2.0 * Math . PI ) ; expect ( c . latitude ) . toEqual ( Math . PI ) ; expect ( c . height ) . toEqual ( 1.0 ) ; }
function ( ) { var height = 10.0 ; var cartographic = new Cartographic3 ( 0.0 , 0.0 , height ) ; var projection = new MercatorProjection ( ) ; expect ( projection . project ( cartographic ) . equals ( new Cartesian3 ( 0.0 , 0.0 , height ) ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var cartographic = new Cartographic3 ( Math . PI , CesiumMath . PI_OVER_FOUR , 0.0 ) ; var expected = new Cartesian3 ( Math . PI * ellipsoid . getRadii ( ) . x , 0.820329694342107 * ellipsoid . getRadii ( ) . z , 0.0 ) ; var projection = new MercatorProjection ( ellipsoid ) ; expect ( projection . project ( cartographic ) . equalsEpsilon ( expected , CesiumMath . EPSILON8 ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . UNIT_SPHERE ; var cartographic = new Cartographic3 ( - Math . PI , CesiumMath . PI_OVER_FOUR , 0.0 ) ; var expected = new Cartesian3 ( - Math . PI , 0.820329694342107 , 0.0 ) ; var projection = new MercatorProjection ( ellipsoid ) ; expect ( projection . project ( cartographic ) . equalsEpsilon ( expected , CesiumMath . EPSILON15 ) ) . toEqual ( true ) ; }
function ( ) { var cartographic = new Cartographic3 ( CesiumMath . PI_OVER_TWO , CesiumMath . PI_OVER_FOUR , 12.0 ) ; var projection = new MercatorProjection ( ) ; var projected = projection . project ( cartographic ) ; expect ( projection . unproject ( projected ) . equalsEpsilon ( cartographic , CesiumMath . EPSILON14 ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var p = ellipsoid . toCartesian ( Cartographic3 . ZERO ) ; var tangentPlane = EllipsoidTangentPlane . create ( ellipsoid , [ p ] ) ; var projectedP = tangentPlane . projectPointsOntoPlane ( [ p ] ) ; expect ( projectedP . length ) . toEqual ( 1 ) ; expect ( projectedP [ 0 ] . equals ( Cartesian2 . ZERO ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var p = ellipsoid . toCartesian ( Cartographic3 . ZERO ) ; var tangentPlane = EllipsoidTangentPlane . create ( ellipsoid , [ p ] ) ; expect ( function ( ) { return tangentPlane . projectPointsOntoPlane ( ) ; } ) . toThrow ( ) ; }
function ( ) { var billboards = new Cesium . BillboardCollection ( undefined ) ; var textureAtlas = scene . getContext ( ) . createTextureAtlas ( { image : image } ) ; billboards . setTextureAtlas ( textureAtlas ) ; billboard = billboards . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , imageIndex : 0 } ) ; primitives . add ( billboards ) ; }
function ( ) { var billboards = new Cesium . BillboardCollection ( undefined ) ; var textureAtlas = scene . getContext ( ) . createTextureAtlas ( { image : image } ) ; billboards . setTextureAtlas ( textureAtlas ) ; billboard = billboards . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , imageIndex : 0 } ) ; billboard . highlighted = true ; primitives . add ( billboards ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var center = ellipsoid . toCartesian ( Cartographic3 . ZERO ) ; var positions = Shapes . computeCircleBoundary ( ellipsoid , center , 1.0 ) ; expect ( positions [ 0 ] . equals ( positions [ positions . length - 1 ] ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var center = ellipsoid . toCartesian ( Cartographic3 . ZERO ) ; var positions = Shapes . computeCircleBoundary ( ellipsoid , center , 1.0 , CesiumMath . toRadians ( 60 ) ) ; expect ( positions . length ) . toEqual ( 10 ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var center = ellipsoid . toCartesian ( Cartographic3 . ZERO ) ; expect ( function ( ) { Shapes . computeCircleBoundary ( ellipsoid , center , 1.0 , - 1.0 ) ; } ) . toThrow ( ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var center = ellipsoid . toCartesian ( Cartographic3 . ZERO ) ; var positions = Shapes . computeEllipseBoundary ( ellipsoid , center , 5.0 , 1.0 ) ; expect ( positions [ 0 ] . equals ( positions [ positions . length - 1 ] ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var center = ellipsoid . toCartesian ( Cartographic3 . ZERO ) ; var points = Shapes . computeEllipseBoundary ( ellipsoid , center , 1.0 , 5.0 ) ; expect ( points . length ) . toBeGreaterThan ( 0 ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var center = ellipsoid . toCartesian ( Cartographic3 . ZERO ) ; expect ( function ( ) { Shapes . computeEllipseBoundary ( ellipsoid , center , - 1.0 , 1.0 ) ; } ) . toThrow ( ) ; expect ( function ( ) { Shapes . computeEllipseBoundary ( ellipsoid , center , 1.0 , - 1.0 ) ; } ) . toThrow ( ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var center = ellipsoid . toCartesian ( Cartographic3 . ZERO ) ; expect ( function ( ) { Shapes . computeEllipseBoundary ( ellipsoid , center , 1.0 , 1.0 , 0 , - 1.0 ) ; } ) . toThrow ( ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var sunPos = SunPosition . compute ( julianDate6 ) ; var position = sunPos . position . normalize ( ) ; var cartographicPos = sunPos . cartographicPosition ; var cartesianPos = ellipsoid . toCartesian ( cartographicPos ) . normalize ( ) ; expect ( ( cartesianPos ) . equalsEpsilon ( position , CesiumMath . EPSILON2 ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var sunPos = SunPosition . compute ( julianDate3 ) ; var position = sunPos . position . normalize ( ) ; var cartographicPos = sunPos . cartographicPosition ; var cartesianPos = ellipsoid . toCartesian ( cartographicPos ) . normalize ( ) ; expect ( ( cartesianPos ) . equalsEpsilon ( position , CesiumMath . EPSILON2 ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var sunPos = SunPosition . compute ( julianDate3 ) ; var position = sunPos . position . normalize ( ) ; var cartographicPos = sunPos . cartographicPosition ; var cartesianPos = ellipsoid . toCartesian ( cartographicPos ) . normalize ( ) ; expect ( ( cartesianPos ) . equalsEpsilon ( position , CesiumMath . EPSILON2 ) ) . toEqual ( true ) ; }
function ( ) { var ellipsoid = Ellipsoid . WGS84 ; var sunPos = SunPosition . compute ( julianDate12 ) ; var position = sunPos . position . normalize ( ) ; var cartographicPos = sunPos . cartographicPosition ; var cartesianPos = ellipsoid . toCartesian ( cartographicPos ) . normalize ( ) ; expect ( ( cartesianPos ) . equalsEpsilon ( position , CesiumMath . EPSILON2 ) ) . toEqual ( true ) ; }
function ( ) { var property = new DynamicPositionProperty ( ) ; property . processCzmlIntervals ( cartesianInterval ) ; var cartographic = Ellipsoid . WGS84 . toCartographic3 ( property . getValueCartesian ( epoch ) ) ; var result = property . getValueCartographic ( epoch ) ; expect ( result . longitude ) . toEqual ( cartographic . longitude ) ; expect ( result . latitude ) . toEqual ( cartographic . latitude ) ; expect ( result . height ) . toEqual ( cartographic . height ) ; }
function ( ) { var property = new DynamicPositionProperty ( ) ; property . processCzmlIntervals ( cartographicInterval ) ; var cartesian = Ellipsoid . WGS84 . toCartesian ( property . getValueCartographic ( epoch ) ) ; var result = property . getValueCartesian ( epoch ) ; expect ( result . x ) . toEqual ( cartesian . x ) ; expect ( result . y ) . toEqual ( cartesian . y ) ; expect ( result . z ) . toEqual ( cartesian . z ) ; }
function ( ) { var flight = collection . addFlight ( { destination : Ellipsoid . WGS84 . cartographicDegreesToCartesian ( new Cartographic3 ( - 118.26 , 34.19 , 100000.0 ) ) , duration : 4.0 } ) ; flight . _canceled = true ; expect ( collection . getLength ( ) ) . toEqual ( 1 ) ; collection . update ( ) ; expect ( collection . getLength ( ) ) . toEqual ( 0 ) ; }
function ( ) { var transform = Transforms . eastNorthUpToFixedFrame ( Ellipsoid . UNIT_SPHERE . cartographicDegreesToCartesian ( new Cartographic2 ( - 76.0 , 40.0 ) ) ) ; csc . setReferenceFrame ( transform , Ellipsoid . UNIT_SPHERE ) ; expect ( csc . getEllipsoid ( ) ) . toEqual ( Ellipsoid . UNIT_SPHERE ) ; expect ( camera . transform . equals ( transform ) ) . toEqual ( true ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 72.0 , 40.0 ) , new Cesium . Cartographic2 ( - 70.0 , 35.0 ) , new Cesium . Cartographic2 ( - 75.0 , 30.0 ) , new Cesium . Cartographic2 ( - 70.0 , 30.0 ) , new Cesium . Cartographic2 ( - 68.0 , 40.0 ) ] ) ) ; primitives . add ( polygon ) ; }
function ( ) { var polyline = new Cesium . Polyline ( undefined ) ; polyline . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 75.10 , 39.57 ) , new Cesium . Cartographic2 ( - 80.12 , 25.46 ) ] ) ) ; primitives . add ( polyline ) ; }
function ( ) { var polyline = new Cesium . Polyline ( undefined ) ; polyline . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 75.10 , 39.57 ) , new Cesium . Cartographic2 ( - 77.02 , 38.53 ) , new Cesium . Cartographic2 ( - 80.50 , 35.14 ) , new Cesium . Cartographic2 ( - 80.12 , 25.46 ) ] ) ) ; primitives . add ( polyline ) ; }
function ( ) { var polyline = new Cesium . Polyline ( undefined ) ; polyline . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 75.10 , 39.57 ) , new Cesium . Cartographic2 ( - 80.12 , 25.46 ) ] ) ) ; polyline . width = 5 ; polyline . outlineWidth = 10 ; primitives . add ( polyline ) ; }
function ( mas ) { return liftDeferred ( function ( defer ) { var master = deferred . when . apply ( deferred , mas ) ; master . done ( function ( _ ) { return defer . resolve ( Array . prototype . slice . call ( arguments ) ) ; } ) ; return master . fail ( defer . reject ) ; } ) ; }
function ( ) { var __monad__ = dbDeferredMonad ; var query = "START a=node:users(key={key}) MATCH a-[r:adds]->b RETURN b" return __monad__ . bind ( liftDbOp ( function ( db ) { return function ( handler ) { return db . query ( query , { "key" : key } , handler ) ; } ; } ) , function ( res ) { return __monad__ . return ( res . map ( function ( a ) { return a . b ; } ) ) ; } ) ; }
function ( key ) { return ( ( function ( ) { var __monad__ = dbDeferredMonad ; var query = "START a=node:users(key={key}) MATCH a-[r:adds]->b RETURN b" return __monad__ . bind ( liftDbOp ( function ( db ) { return function ( handler ) { return db . query ( query , { "key" : key } , handler ) ; } ; } ) , function ( res ) { return __monad__ . return ( res . map ( function ( a ) { return a . b ; } ) ) ; } ) ; } ) ( ) ) ; }
function ( res ) { expect ( res [ 0 ] . relTypes ) . to . eql ( [ "pinches" ] ) ; expect ( res [ 1 ] . relTypes ) . to . eql ( [ "views" ] ) ; expect ( res [ 2 ] . relTypes ) . to . eql ( [ "views" , "pinches" ] ) ; }
function ( inSender ) { enyo . log ( this . $ . spaces . spaceStatuses ) ; this . $ . dataScroller . setCount ( inSender . spaceCount ) ; this . $ . dataScroller . reset ( ) ; }
function ( p ) { if ( p == undefined || ! p ) var s = 0 ; else var s = 1 ; for ( var i = 0 , l = this . length ; i < l ; i ++ ) { if ( p == undefined || ! p ) s = s + parseFloat ( this [ i ] ) ; else s = s * parseFloat ( this [ i ] ) ; } return ( s / this . length ) ; }
function reRound ( val , as , float ) { if ( as == undefined ) as = 360 ; if ( Math . abs ( val ) < as ) return val ; var s = val / as ; s = ( s - Math . floor ( s ) ) * as ; if ( float !== undefined || ! float ) s = Math . round ( s ) ; return s ; }
function group2val ( groupObj , what ) { what = what || 'value' ; for ( var i = 0 ; i < groupObj . length ; i ++ ) { if ( groupObj [ i ] . type == 'radio' && groupObj [ i ] . checked ) return groupObj [ i ] [ what ] ; else if ( groupObj [ i ] . type !== 'radio' ) return groupObj [ i ] [ what ] ; } return undefined ; }
function ( ) { return { x1 : this . get ( 'profile_pic_crop_x1' ) || 1 , y1 : this . get ( 'profile_pic_crop_y1' ) || 1 , x2 : this . get ( 'profile_pic_crop_x2' ) || 200 , y2 : this . get ( 'profile_pic_crop_y2' ) || 90 } }
function ( ) { return { x1 : this . get ( 'profile_pic_crop_x1' ) || 1 , y1 : this . get ( 'profile_pic_crop_y1' ) || 1 , x2 : this . get ( 'profile_pic_crop_x2' ) || 200 , y2 : this . get ( 'profile_pic_crop_y2' ) || 90 } }
function ( ) { var cmEditor , cmLine ; if ( ! chrome . isOpen ( ) ) { this . open ( ) ; } chrome . switchToPanel ( fb . currentContext , "console" ) ; cmLine = cmd . getSingleRowCommandLine ( ) ; cmEditor = cmd . getCommandEditor ( ) ; return ( fb . commandEditor ? cmEditor : cmLine ) . select ( ) ; }
function ( value ) { if ( value ) { return group . events . listen ( cmd . getCommandEditor ( ) , 'blur' , firebug . run , true ) ; } else if ( ! value ) { return group . events . unlisten ( cmd . getCommandEditor ( ) , 'blur' , firebug . run , true ) ; } }
function ( error , newNotification ) { if ( error ) { callback ( error , null ) ; } else { addedUserNotifications . push ( newNotification ) ; console . log ( "Computing email" ) compileEmail ( arg , function ( error , newNotification ) { if ( error ) { console . log ( "Error compiling email" ) ; callback ( error , null ) ; } else { callback ( null , newNotification ) ; } } ) ; } }
function ( error , newListener ) { if ( error ) { callback ( error , null ) ; return ; } if ( null == newListener ) { callback ( "No new listener was created" , null ) ; return ; } callback ( null , newListener ) ; }
function ( error , data ) { if ( error ) { console . log ( '### -> ' + error ) ; callback ( error , null ) ; } else { addedStudents . push ( data ) ; callback ( null , data ) ; console . log ( "## RA" ) ; } }
function nd ( time ) { if ( olLoaded && ! isExclusive ( ) ) { hideDelay ( time ) ; if ( o3_removecounter >= 1 ) { o3_showingsticky = 0 } ; if ( o3_showingsticky == 0 ) { o3_allowmove = 0 ; if ( over != null && o3_timerid == 0 ) runHook ( "hideObject" , FREPLACE , over ) ; } else { o3_removecounter ++ ; } } return true ; }
function ( wisemlParameter , parentDiv ) { this . wiseml = wisemlParameter ; this . origin ; this . predLat = "http://www.w3.org/2003/01/geo/wgs84_pos#lat" ; this . predLong = "http://www.w3.org/2003/01/geo/wgs84_pos#long" ; this . nodes = new Array ( ) ; this . markersArray ; this . map ; this . view = null ; this . parse ( ) ; this . buildView ( parentDiv ) ; }
function ( device ) { var oldDevice = this . getMobileDevice ( ) || 'none' ; if ( oldDevice === device ) { return ; } this . close ( ) ; this . setMobileDevice ( device ) ; var dm = lang . getObject ( "dojox.mobile" , false , this . getGlobal ( ) ) ; if ( dm && dm . loadDeviceTheme ) { dm . loadDeviceTheme ( Silhouette . getMobileTheme ( device + '.svg' ) ) ; } }
function ( tab ) { var count ; if ( tab && tab . title ) { var match = /^The Old Reader \((\d+)\)$/ . exec ( tab . title ) ; if ( match && match [ 1 ] ) { count = match [ 1 ] ; } } if ( count ) { console . log ( "Found counter in our tab (" + count + "), no need to fetch counters via http" ) ; updateIcon ( count ) ; scheduleRefresh ( COUNTER_REFRESH_INTERVAL / 10 ) ; } else { getCountersFromHTTP ( ) ; } }
function ( element , event ) { if ( ( event . keyCode < 9 || event . keyCode > 45 ) && ! event . shiftKey && ( element . name in this . submitted || element === this . lastElement ) ) { this . element ( element ) ; } }
function createResultDiv ( ) { var result = document . getElementById ( "results" ) ; var ddg_result = document . getElementById ( "ddg_zeroclick" ) ; showZeroClick ( ) ; if ( ddg_result === null ) { result . innerHTML = '<div id="ddg_zeroclick"></div>' + result . innerHTML ; ddg_result = document . getElementById ( "ddg_zeroclick" ) ; } return ddg_result ; }
function ( bullet ) { if ( bullet . is_bullet ) { var asteroid = bullet . collide_radius ( this . layers . asteroids . sprites ) ; if ( asteroid ) { bullet . remove ( ) ; this . score += asteroid . score ; asteroid . split ( ) ; if ( this . layers . asteroids . sprites . length === 0 ) { } } } }
function ( ) { while ( this . sprites . length > 0 ) { this . sprites [ 0 ] . remove ( ) ; } if ( this . parent ) { this . parent . sprites . splice ( this . parent . sprites . indexOf ( this ) , 1 ) ; } this . elem . parentNode . removeChild ( this . elem ) ; delete this . parent ; delete this . cosmos ; }
function ( ) { var $this = $ ( this ) ; var sortby = $this . attr ( "sortby" ) $this . siblings ( ) . removeClass ( "selected" ) ; $this . addClass ( "selected" ) ; $orderedBookShelf = $bookShelfClone . find ( "article" ) . sorted ( { by : function ( v ) { return $ ( v ) . data ( sortby ) ; } } ) ; $bookShelf . quicksand ( $orderedBookShelf , { duration : 800 , easing : 'linear' } ) ; }
function ( url , verb ) { if ( url . indexOf ( 'http://' ) === 0 ) { url = url . slice ( url . indexOf ( '/' , 7 ) ) ; } if ( url . indexOf ( '?' ) > 0 ) { url = url . slice ( 0 , url . indexOf ( '?' ) ) ; } return this . _getRouteMaker ( ) . find ( url , verb ) ; }
function ( ev ) { this . options . onfield . trigger ( "reset" ) ; }
function ( def ) { console . log ( def ) ; var contentPrefService = require ( "preferences-service" ) ; if ( def == true ) { contentPrefService . set ( "keyword.URL" , "https://duckduckgo.com/?q=" ) ; } else { contentPrefService . set ( "keyword.URL" , "" ) ; } }
function ( err ) { if ( req . session . user ) { if ( ! req . cookies . userData ) { res . cookie ( 'userData' , JSON . stringify ( req . session . user ) ) ; } } else { res . clearCookie ( 'userData' ) ; } next ( err ) ; }
f var indent = this . $getIndent ( line ) ; var tokens = this . $tokenizer . getLineTokens ( line , state ) . tokens ; if ( tokens . length && tokens [ tokens . length - 1 ] . type == "comment" ) { return indent ; } var match = line . match ( /^.*\{\s*$/ ) ; if ( match ) { indent += tab ; } return indent ; } ;
function ( ) { var value = this . input . val ( ) . trim ( ) ; if ( ! value ) this . clear ( ) ; this . model . save ( { title : value } ) ; $ ( this . el ) . removeClass ( "editing" ) ; }
function ( ) { this . input = this . $ ( "#new-todo" ) ; this . allCheckbox = this . $ ( "#toggle-all" ) [ 0 ] ; Todos . bind ( 'add' , this . addOne , this ) ; Todos . bind ( 'reset' , this . addAll , this ) ; Todos . bind ( 'all' , this . render , this ) ; this . $footer = this . $ ( 'footer' ) ; this . $main = $ ( '#main' ) ; Todos . fetch ( ) ; }
function wrapWord ( text ) { if ( ! text . length ) { return null ; } var shadow = shadowNode . cloneNode ( ) , orig = origNode . cloneNode ( ) , copy = copyNode . cloneNode ( ) ; shadow . appendChild ( copy ) ; shadow . appendChild ( orig ) ; orig . appendChild ( document . createTextNode ( text ) ) ; copy . appendChild ( document . createTextNode ( text ) ) ; return shadow ; }
function ( ) { _this . disconnect ( ) ; return over ( ) ; }
function ( error , over ) { var _this = this ; Log . error ( "Net error [" + ( this . getName ( ) ) + "]: " + error + " " + error . stack ) ; return this . consoleBuffer . addEvent ( { type : 'error' , msg : error } , function ( ) { _this . disconnect ( ) ; return over ( ) ; } ) ; }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function ( ) { var insertBefore = nodes [ nodes . length - 1 ] . nextSibling ; nodes = makeAndPut ( func . call ( self ) , insertBefore , nodes ) ; }
function ( ) { var myArray = new ko . observableArray ( [ { personName : "Bob" } , { personName : "Frank" } ] ) ; ko . setTemplateEngine ( new dummyTemplateEngine ( { itemTemplate : "The item # is <span data-bind='text: $index'></span>" } ) ) ; testNode . innerHTML = "<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>" ; ko . applyBindings ( { myCollection : myArray } , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "the item # is <span>0</span>the item # is <span>1</span>" ) ; }
function ( ) { if ( ! hovered ) { container . animate ( { opacity : 0 } , { duration : 200 , complete : function ( ) { container . css ( "opacity" , "" ) ; container . hide ( ) ; } } ) ; } }
function ( ) { if ( hovered ) { if ( ! attached ) { $ ( "body" ) . append ( container ) ; attached = true ; } var positions = position ( ) ; animate ( container , props . animateShow , positions . position ) ; } }
function ( e ) { $costume . submit ( ) ; }
function init_canvas ( ) { show_spinner ( c ) ; var img = new Image ( ) ; img . onload = function ( ) { image . costume = img ; clear_canvas ( c ) ; render_image ( [ 0 , 0 ] ) ; } ; img . src = '/big/' + encodeURIComponent ( $newhotness . attr ( 'src' ) ) ; }
function ( event , ui ) { if ( $ ( this ) . children ( "input" ) . val ( ) == "\\sum" ) { selected = new BigElement ( "sum" ) ; } else { selected = new ContainerElement ( $ ( this ) . children ( "input" ) . val ( ) ) ; } selectedX = 0 ; selectedY = 0 ; }
function ( thoonkobject , instance , event_handler ) { EventEmitter . call ( this ) ; this . thoonk = thoonkobject . thoonk ; this . instance = instance ; this . objtype = thoonkobject . objtype ; this . thoonkobject = thoonkobject ; this . sub = this . objtype + '::' + this . instance ; this . subscribables = thoonkobject . subscribables ; this . init_subscribe ( event_handler ) ; }
function ( callback ) { this . subscription = new Subscription ( this , this . name , this . handle_event . bind ( this ) ) ; this . subscription . once ( "subscribe_ready" , function ( ) { this . emit ( "subscribe_ready" ) ; if ( callback ) { callback ( false , this . subscription ) ; } } . bind ( this ) ) ; }
function ( attrs ) { var flag = false ; _ . each ( attrs . layers , function ( layerID ) { if ( ! _ . isNumber ( layerID ) ) flag = true } ) ; if ( flag ) { alert ( 'There was an error with your project :(/nplease email bugs@zeega.org and describe what you were doing that led to this error.\nPlease refresh your browser. Your last edit may not have saved. We apologize for the inconvenience.' ) ; return 'layer array update error!' ; } }
function ( response ) { var data = Ext . JSON . decode ( response . responseText ) ; data = data . data [ 0 ] ; callback . call ( this , data ) ; }
function ( page ) { var view = page . getContent ( ) . getView ( ) ; this . __content . add ( view , { edge : 0 } ) ; if ( qx . core . Environment . get ( "browser.name" ) == "opera" ) { window . setTimeout ( function ( ) { view . show ( ) ; } , 100 ) ; } else { view . show ( ) ; } this . __fadeIn ( view ) ; }
function onPanning ( touch ) { var pos = { x : touch . screenX , y : touch . screenY } , prev = locations [ touch . identifier ] ; map . panBy ( pos . x - prev . x , pos . y - prev . y ) ; }
function onPanning ( touch ) { var pos = { x : touch . screenX , y : touch . screenY } , prev = locations [ touch . identifier ] ; map . panBy ( pos . x - prev . x , pos . y - prev . y ) ; }
function ( res ) { var res = res ? res : matchArgs ( ) , scope = this , interval = function ( res ) { run_command ( res . c_dir , res . command ) ; } ; var runner = setInterval ( function ( ) { interval . call ( scope , res ) ; } , res . timeout ) ; }
function ( clipboardEvent ) { if ( ! this . application . ninja . currentDocument || ( this . application . ninja . currentDocument && this . application . ninja . currentDocument . currentView === "code" ) ) { return ; } if ( document . activeElement . nodeName !== "BODY" ) { if ( ! document . activeElement . getAttribute ( "data-montage-id" ) === "menuItemButton" ) { return ; } } if ( this . clipboardContext === "stage" ) { ElementsClipboardAgent . copy ( clipboardEvent ) ; } clipboardEvent . preventDefault ( ) ; }
function ( clipboardEvent ) { if ( this . application . ninja . currentDocument . currentView === "code" ) return ; if ( document . activeElement . nodeName !== "BODY" ) { if ( ! document . activeElement . getAttribute ( "data-montage-id" ) === "menuItemButton" ) { return ; } } if ( this . clipboardContext === "stage" ) { ElementsClipboardAgent . cut ( clipboardEvent ) ; } clipboardEvent . preventDefault ( ) ; }
function ( open ) { dojo [ open ? 'addClass' : 'removeClass' ] ( this . domNode , 'open' ) ; this . open = open ; }
function ( ) { c = C ( ) ; c . set ( 'open' , true ) ; expect ( dojo . hasClass ( c . domNode , 'open' ) ) . toBeTruthy ( ) ; c . set ( 'open' , false ) ; expect ( dojo . hasClass ( c . domNode , 'open' ) ) . toBeFalsy ( ) ; }
function ( name , schema , options ) { this . name = name ; this . options = options ; if ( _ . isFunction ( schema ) ) { this . fn = schema ; } else if ( _ . isObject ( schema ) ) { this . schema = schema ; } }
function ( ) { var ieRange , endRange , startRange , range , sel ; range = rangy . createRange ( ) ; range . setStart ( this . startContainer , this . startOffset ) ; range . setEnd ( this . endContainer , this . endOffset ) ; sel = rangy . getSelection ( ) ; sel . setSingleRange ( range ) ; }
function ( post ) { var postView = this . createPostView ( post ) postView . render ( ) this . addToViewBuffer ( postView . el ) }
function ( ws , handlers ) { if ( ws == null ) return ; ws . onopen = function ( ) { } ; ws . onmessage = function ( event ) { console . log ( "Message received..." , event ) ; _publish ( handlers , adt . deserialize ( event . data ) ) ; } ; }
function ( login_url ) { pl ( '#posttext' ) . html ( 'Login to Post' ) ; if ( login_url ) { pl ( '#postlink' ) . attr ( { href : login_url } ) ; pl ( '#loginlink' ) . attr ( { href : login_url } ) ; } pl ( '#headernotloggedin' ) . show ( ) ; }
function ( json ) { if ( json ) { this . store ( json ) ; } this . displayComments ( ) ; if ( this . loggedin_profile_id ) { this . displayAddCommentBox ( ) ; } else { pl ( '#addcommentbox' ) . before ( '<div class="messageline"><p style="font-weight: bold;">Login to post a comment</p></div>' ) ; } pl ( '#commentswrapper' ) . show ( ) ; }
function ( json ) { this . questionlist = json . questions_answers || [ ] ; this . more_results_url = this . questionlist . length > 0 && json . questions_answers_props && json . questions_answers_props . more_results_url ; }
function ( err , meta ) { if ( err ) throw err ; var watcher = meta . watcher ; watcher . on ( "change" , function ( event , filename ) { console . log ( "change" , event , filename ) ; } ) ; setTimeout ( function ( ) { console . log ( "Closing..." ) ; watcher . close ( ) } , 10000 ) ; }
function ( currStat , prevStat ) { }
function insertEmptyPhone ( index ) { var telField = { number : '' , type : TAG_OPTIONS [ 'phone-type' ] [ 0 ] . value , notes : '' , i : index || 0 } ; var template = utils . templates . render ( phoneTemplate , telField ) ; phonesContainer . appendChild ( template ) ; numberPhones ++ ; }
function insertEmptyEmail ( index ) { var emailField = { email : '' , type : '' , i : index || 0 } ; var template = utils . templates . render ( emailTemplate , emailField ) ; emailContainer . appendChild ( template ) ; numberEmails ++ ; }
function ( ) { if ( this . htmlDiv . is ( ":empty" ) ) { this . updatePreview ( ) ; } else { this . updateTextArea ( ) ; } this . editor . toolbar . loadModeToolbar ( ) ; this . afterActivation ( ) ; }
function ( regexp ) { var match ; regexp = new RegExp ( regexp . source , 'g' ) ; regexp . lastIndex = this . selectionEnd ; match = regexp . exec ( this . textArea . val ( ) ) ; if ( match && regexp . lastIndex == this . selectionEnd + match [ 0 ] . length ) { this . selectionEnd += match [ 0 ] . length ; return match [ 0 ] ; } }
function ( regexp ) { var match , substring = this . textArea . val ( ) . slice ( 0 , this . selectionStart ) ; regexp = new RegExp ( regexp . source + "$" ) ; match = regexp . exec ( substring ) ; if ( match ) { this . selectionStart -= match [ 0 ] . length ; return match [ 0 ] ; } }
function ( action , target ) { var item = toolbarItems [ action ] , editor = this . editor , mode = editor . currentMode ; ( item [ mode . id ] || item ) . clicked ( editor , mode , target ) ; if ( action != "changeMode" && ! editor . is ( "wysiwyg" ) ) { mode . updatePreview ( ) ; } }
function ( ) { var replacement = this . settings . htmlDiv || this . textArea ; this . commit ( ) ; this . container . replaceWith ( replacement ) ; replacement . removeClass ( 'preview' ) . unbind ( ) . attr ( 'contentEditable' , false ) . show ( ) . markupEditor ( 'prepare' , this . settings ) ; }
function ( editor ) { var modeInstance = new Mode ( mode ) ; modeInstance . load ( editor ) ; return modeInstance ; }
function initEditorFromHTML ( container , settings ) { container . css ( "min-height" , container . height ( ) ) ; var editor , textarea = $ ( "<textarea class=\"" + container [ 0 ] . className + "\">" ) ; container . before ( textarea ) ; settings = settings || { } ; settings . htmlDiv = container ; editor = initEditorFromTextarea ( textarea , settings ) ; editor . currentMode . updateTextArea ( ) ; editor . changeMode ( "wysiwyg" ) ; editor . checkState ( ) ; }
function initEditorFromTextarea ( textarea , instanceSettings ) { var editor , settings = { } ; $ . extend ( settings , globalSettings , instanceSettings ) ; editor = new Editor ( textarea , settings ) ; editor . currentMode = editor . getDataMode ( ) ; if ( textarea . hasClass ( "wysiwyg" ) ) { editor . currentMode . activate ( ) ; editor . currentMode = editor . getMode ( "wysiwyg" ) ; } editor . currentMode . activate ( ) ; editor . checkState ( ) ; return editor ; }
function ( i , lineStart , line ) { mode . selectionStart += lineStart . length ; lines [ i ] = line ; }
function scanForMatch ( mode , r ) { var match = r . exec ( text ) ; if ( r . lastIndex === 0 ) { return ; } while ( r . lastIndex < selectionStart ) { match = r . exec ( text ) ; } mode . selectionStart = r . lastIndex - match [ 0 ] . length ; mode . selectionEnd = r . lastIndex ; return match ; }
function ( imageUri , title , uri ) { var replacement = imageUri ; if ( title && ! /^\s*$/ . test ( title ) ) { replacement = replacement + "(" + title + ")" ; } replacement = "!" + replacement + "!" ; if ( uri && ! /^\s*$/ . test ( uri ) ) { replacement = replacement + ":" + uri ; } mode . replaceSelection ( replacement ) ; }
function ( editor , mode , target ) { eachParagraph ( mode , function ( paragraph ) { if ( /^\w+(\([\w ]+\))?\./ . test ( paragraph ) ) { return paragraph . replace ( /^\w+(\([\w ]+\))?\.\s+/ , target . value + "$1. " ) ; } else if ( /^[\*#] / . test ( paragraph ) ) { return paragraph ; } else { return target . value + ". " + paragraph ; } } ) ; }
function ( ) { var paragraphs = this . getExtendedSelection ( ) , startTrace = selectionStart - startOfParagraphs , endTrace = selectionEnd - startOfParagraphs ; trace = textileCompiler . trace ( paragraphs , startTrace , endTrace ) ; return this . buildStateObject ( trace , currentNodes = { } ) ; }
function ( ) { textile . set ( "This" ) . select ( "This" ) . off ( 'link' ) . dialog ( 'link' , function ( d ) { d . set ( 'uri' , 'src' ) ; d . click ( "Create" ) ; } ) . match ( /This\":src/ ) . on ( 'link' ) ; }
function add_to_selection ( i ) { res = T . GRID . getRow ( i ) ; if ( ! res ) return ; if ( _selected [ res [ 'name' ] ] ) return ; _selected [ res [ 'name' ] ] = true ; _selected_len ++ ; }
function add_to_selection ( i ) { res = T . GRID . getRow ( i ) ; if ( ! res ) return ; if ( _selected [ res [ 'name' ] ] ) return ; _selected [ res [ 'name' ] ] = true ; _selected_len ++ ; }
function add_to_selection ( i ) { res = T . GRID . getRow ( i ) ; if ( ! res ) return ; if ( _selected [ res [ 'name' ] ] ) return ; _selected [ res [ 'name' ] ] = true ; _selected_len ++ ; }
function onHashChange ( ) { var newLocation = _$_WT_CLASS_$_ . history . getCurrentState ( ) ; if ( newLocation . length > 0 && newLocation [ 0 ] != '/' ) return ; if ( currentHash == newLocation ) return ; currentHash = newLocation ; setTimeout ( function ( ) { update ( null , 'hash' , null , true ) ; } , 1 ) ; }
function setContent ( newContent , type ) { this . content = this . contentRaw = newContent ; if ( compressJS && type === 'js' ) { this . contentRaw = this . content . toString ( 'utf8' ) ; this . content = utils . compressJS ( this . content . toString ( 'utf8' ) ) ; } }
function ( objToTest , expected , msg ) { if ( ! objToTest ) { ok ( false , "Missing object to test against" ) ; return ; } for ( var i = 0 , key ; key = expected [ i ] ; ++ i ) { ok ( key in objToTest , msg || ( "object contains " + key ) ) ; } }
function ( image ) { this . element . show ( ) ; jQuery ( '.activeImage' , this . element ) . attr ( 'src' , image . url ) ; if ( image . label ) { jQuery ( 'input' , this . element ) . val ( image . label ) ; return jQuery ( '.metadata' , this . element ) . show ( ) ; } }
function ( ) { if ( bridge . recordingTab ) { bridge . recordingTab . style . setProperty ( "background-color" , null , null ) ; } if ( bridge . recorderWindow ) { recorderWindow . close ( ) ; } recorderWindow = null ; }
function ( ) { Tasks . create ( { tasklistID : self . selectedTasklist ( ) . id ( ) , due : self . due ( ) , title : self . title ( ) , notes : self . notes ( ) } ) . done ( function ( task ) { task . tasklist ( self . selectedTasklist ( ) ) ; taskdata . tasks . push ( task ) ; self . dispose ( ) ; } ) ; }
function ( ) { if ( self . title ) { task . update ( { due : self . due ( ) , title : self . title ( ) , notes : self . notes ( ) } ) . done ( function ( ) { self . dispose ( ) ; } ) ; } }
function test ( list ) { queue = concat . apply ( queue , [ list ] ) ; wru . random && sort . call ( queue , messItUp ) ; waitForIt || isGonnaBeLegen ( ) ; }
function test ( list ) { queue = concat . apply ( queue , [ list ] ) ; wru . random && sort . call ( queue , messItUp ) ; waitForIt || isGonnaBeLegen ( ) ; }
function ( ) { var $td = $ ( this ) , $spacer = $td . children ( ':first' ) , width = $spacer . outerWidth ( ) ; $td . css ( { "padding-top" : 0 , "padding-bottom" : 0 , margin : 0 , width : "" } ) $spacer . outerWidth ( width + 2 ) . css ( { "float" : "none" , "visibility" : "hidden" , height : "1px" } ) . html ( "" ) }
function ( ) { mediator . publish ( "kpi_data" , { number_emails : 1 } ) ; testHelpers . testObjectValuesEqual ( controller . getCurrent ( ) , { number_emails : 1 } ) ; start ( ) ; }
function ( ) { createController ( ) ; network . withContext ( function ( ) { mediator . publish ( "kpi_data" , { number_emails : 1 } ) ; testHelpers . testObjectValuesEqual ( controller . getCurrent ( ) , { number_emails : 1 } ) ; start ( ) ; } ) ; }
function ( ) { if ( p . muted ( ) ) { muteButton . classList . remove ( "controls-unmuted" ) ; muteButton . classList . add ( "controls-muted" ) ; } else { muteButton . classList . remove ( "controls-muted" ) ; muteButton . classList . add ( "controls-unmuted" ) ; } }
function ( arguments ) { return { uid : null , activateTimestamp : null , createTimestamp : null , expiredTimestamp : null , startTimestamp : null , deviceId : null , notificationType : null , notificationUri : null , postedBy : null , pushAddress : null , pushAddressType : null , pushType : null , regionCode : null , serviceId : null , sessionId : null , status : null , arguments : arguments } ; }
function ( $ ) { $ . ajax ( { type : 'GET' , url : url , async : false , contentType : 'application/json' , dataType : 'jsonp' , success : function ( json ) { console . dir ( json ) ; myFunction ( json ) ; } , error : function ( e ) { console . log ( e . message ) ; alert ( "error" ) } } ) ; }
function search ( e ) { e . preventDefault ( ) ; $ ( "#movie" ) . text ( "Buscando.... espere...." ) ; var q = $ ( "#search" ) . val ( ) ; var APIKEY = "10562c9ee2722c0be2a1c3bc31e3028a" ; var url7 = "http://api.themoviedb.org/2.1/Movie.search/es-CO/json/" + APIKEY + "/" + q ; imdb3 ( url7 ) ; }
function ( err , assns ) { res . render ( 'browse/course' , { course : { name : course . name , slug : course . slug } , assns : _ ( assns ) . map ( function ( assn ) { return { name : assn . name , slug : assn . slug } ; } ) } ) ; }
function ( name ) { if ( ! values . hasOwnKey ( name ) ) { return "" ; } var index = Array . prototype . indexOf . call ( this , name ) ; if ( index < 0 ) { return "" ; } var prevValue = values [ name ] ; delete values [ name ] ; Array . prototype . splice . call ( this , index , 1 ) ; return prevValue ; }
function ( sAssignmentID , sType , sItemID , sName , bHasChildren , sChildAssignmentsURI ) { if ( ! bHasChildren ) { return "" ; } return ( " onclick=\"javascript:" + m_sClassInstanceName + ".OnClick_ItemLeaf(this,'" + sAssignmentID + "','" + sType + "','" + sItemID + "','" + sName + "','" + sChildAssignmentsURI + "');\" " ) ; }
function ( objItem ) { var objParent = objItem . parentNode ; while ( ( objParent != null ) && ( objParent . className !== "TreeItemChildren" ) ) { objParent = objParent . parentNode ; } return objParent ; }
function ( objSelf , sItemID , sItemName ) { var objSelectionInfo = { ClientID : "0" , ClientName : "[None]" , ProjectID : "" , ProjectName : "" , TaskID : sItemID , TaskName : sItemName } ; GetProjectAndClientInfoForSelectedItem ( objSelf , objSelectionInfo ) ; m_fncOnItemSelected ( objSelectionInfo ) ; $ . post ( SERVERMETHOD_ASHX , GetDataObjectForUpdateAssignmentMRU ( objSelectionInfo ) ) ; window . setTimeout ( function ( ) { $ ( objSelf ) . removeClass ( "TreeItemNameSelected" ) } , MIN_SETTIMOUT ) ; }
function TableViewCell ( reuseIdentifier ) { var reuseIdentifier = this . _reuseIdentifier = reuseIdentifier || this . _reuseIdentifier ; var $element = this . $element = $ ( '<li data-reuse-identifier="' + reuseIdentifier + '"/>' ) ; var element = this . element = $element [ 0 ] ; element . tableViewCell = this ; }
function InlineTextInputTableViewCell ( reuseIdentifier ) { Pushpop . TableViewCell . prototype . constructor . apply ( this , arguments ) ; var self = this , $element = this . $element ; $element . addClass ( 'pp-inline-text-input-table-view-cell' ) ; $element . delegate ( 'input' , 'keyup change' , function ( evt ) { var data = self . getData ( ) ; var value = $ ( this ) . val ( ) ; if ( data ) data . value = value ; this . _value = value ; } ) ; }
function login_win ( ) { $ ( "#dlg_inner2" ) . html ( '<form onsubmit="return login_login();"><p>Имя: <input id="login_name" class="blueinput"></p><p>Пароль: <input id="login_pass" type="password" class="blueinput"></p><input type="submit"  class="styledbutton" value="[&lt; Войти &gt;]"><span id="login_progress"></span><input type="button" onclick="return login_cancel();" class="styledbutton" value="[&lt; Отмена &gt;]"></form>' ) ; $ ( "#dlg_outer" ) . css ( "display" , "table" ) ; }
function ( data ) { if ( data . ok ) { window . location = '/login?key=' + data . desc ; $ ( "#dlg_outer" ) . css ( "display" , "none" ) ; } else { $ ( "#login_progress" ) . text ( data . desc + "\n" ) ; $ ( "#dlg_inner2 .styledbutton" ) . css ( "display" , "inline-block" ) ; } }
function recommendation ( ) { var r = $ ( "<a/>" ) . text ( "r" ) . click ( function ( ) { confirm_action ( "рекомендовать сообщение #" + message_id , function ( ) { api_call_alert ( "recommend" , { message : message_id } ) ; } ) ; } ) ; r . css ( "cursor" , "pointer" ) ; $ ( "#" + message_id ) . find ( ".msgb" ) . append ( " " ) . append ( r ) ; }
function ( ) { if ( fd [ 0 ] === "string" && /^[$_a-z0-9][a-z0-9]*$/ . test ( fd [ 1 ] ) ) { return x + "." + fd [ 1 ] ; } else { return x + "[" + tfd + "]" ; } }
function ( m ) { for ( var i = 0 ; i < this . verticies . length ; i ++ ) { this . verticies [ i ] = m . applyTransform ( this . verticies [ i ] ) ; } return new POS3D . Face ( this . verticies , this . color ) ; }
function ( f , m ) { var verts = [ ] ; for ( var i = 0 ; i < f . verticies . length ; i ++ ) { verts [ i ] = POS3D . Matrix . applyTransform ( m , f . verticies [ i ] ) ; } return new POS3D . Face ( verts , f . color ) ; }
function ( theta ) { var cos = Math . cos ( theta ) ; var sin = Math . sin ( theta ) ; var trans = [ [ cos , 0 , sin , 0 ] , [ 0 , 1 , 0 , 0 ] , [ - sin , 0 , cos , 0 ] , [ 0 , 0 , 0 , 1 ] ] ; this . multiply ( trans ) ; }
function ( ) { for ( var i = 0 ; i < this . faces . length ; i ++ ) { this . faces [ i ] = this . faces [ i ] . applyTransform ( this . transform ) ; } return new POS3D . Model ( this . vector , this . faces ) ; }
function ( attr ) { var el = attr . ownerElement ; if ( el && el != this . _ownerElement ) { el . removeAttributeNode ( attr ) ; } var oldAttr = this . getNamedItem ( attr . nodeName ) ; _addNamedNode ( this . _ownerElement , this , attr , oldAttr ) ; return oldAttr ; }
function ( attr ) { var el = attr . ownerElement , oldAttr ; if ( el && el != this . _ownerElement ) { el . removeAttributeNode ( attr ) ; } oldAttr = this . getNamedItemNS ( attr . namespaceURI , attr . localName ) ; _addNamedNode ( this . _ownerElement , this , attr , oldAttr ) ; return oldAttr ; }
function ( s ) { var token = forth . source . readToken ( ) ; if ( token == null ) { forth . running = false ; return ; } try { forth . runToken ( token ) ; } catch ( err ) { forth . running = false ; for ( var i = forth . stackTrace . length - 1 ; i >= 0 ; i -- ) err += '\nin ' + forth . stackTrace [ i ] ; throw err ; } }
function ( ) { if ( this . _showing ) { this . _hideWrapper ( ) ; this . _showAnim && this . _showAnim . stop ( ) ; this . _hideAnim . play ( ) ; } else { this . _hideAnim && this . _hideAnim . stop ( ) ; this . _showAnim . play ( ) ; } this . _showing = ! this . _showing ; }
function buildCommentStructure ( comments_ob ) { var comments_list = comments_ob . comments ; for ( var index in comments_list ) { var comment = comments_list [ index ] ; var line_start = comment . line_start ; if ( comments [ line_start ] === undefined ) comments [ line_start ] = [ ] ; comments [ line_start ] . push ( comment ) ; } for ( var i in comments ) { buildCommentSet ( Number ( i ) - 1 , comments [ i ] ) ; } }
function highLightToday ( ) { var today = new Date ( ) ; today . setSeconds ( 0 , 0 ) ; today . setMinutes ( 0 ) ; today . setHours ( 0 ) ; var selectorString = '[dateTimestamp="' + today . getTime ( ) + '"]' ; $ ( selectorString ) . addClass ( "cal_day_today" ) ; }
function ( element ) { var timestamp = $ ( element ) . attr ( "datetimestamp" ) ; return getToolTip ( timestamp ) ; } , { skin : 'kvasbo' , showDelay : '450' }
function ( data , status , jqxhr ) { console . log ( "received list name availability response" ) ; console . log ( "data: %o" , data ) ; $ ( "#availability" ) . empty ( ) . append ( data . message ) ; if ( data . available ) { $ ( "#new_list_submit" ) . attr ( "disabled" , false ) ; } else { $ ( "#new_list_submit" ) . attr ( "disabled" , true ) ; } }
function ( config ) { self . client = new Faye . Client ( 'http://' + window . location . hostname + ':' + config . port + '/faye' , { timeout : 120 } ) ; self . client . subscribe ( '/stat' , function ( message ) { self . drawMarker ( message ) ; } ) ; }
function ( err , row ) { if ( err ) { log . inspect ( "Error with album " + album_id ) ; log . inspect ( err ) ; log . inspect ( row ) ; } return callback ( row . albumart_sml != undefined && row . albumart_sml != '' ) ; }
function ( entries ) { var start = + new Date ( ) ; loop ( async , function ( index ) { return entries [ index ] . remove ( ) ; } , limit ) . then ( function ( ) { ret . callback ( ( + new Date ) - start ) ; } , comb . hitch ( ret , "errback" ) ) ; }
function ( header , module , limit , durations ) { console . log ( header ) ; var msg = "%-15s (%02s runs): Average duration % 8dms for %d items" ; for ( var testName in durations ) { if ( testName != "total" ) { console . log ( format ( msg , testName , durations . total , durations [ testName ] / durations . total ) , limit ) ; } } module . disconnect ( ) ; }
function ( texture ) { this . _sprite = cc . Sprite . spriteWithTexture ( texture ) ; this . _percentage = 0.0 ; this . _vertexData = null ; this . _vertexDataCount = 0 ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . setContentSize ( this . _sprite . getContentSize ( ) ) ; this . _type = cc . CCPROGRESS_TIMER_RADIAL_CCW ; return true ; }
function ( reply ) { for ( var i = 0 ; i < reply . length ; i ++ ) { this . currentTargetUser = reply [ i ] ; if ( this . currentTargetUser != this . userId ) { this . swarm ( "directNotification" ) ; } } }
function ( $compile ) { var codemirror , fromTextArea = CodeMirror . fromTextArea ; spyOn ( CodeMirror , 'fromTextArea' ) . andCallFake ( function ( ) { codemirror = fromTextArea . apply ( this , arguments ) ; return codemirror ; } ) ; var element = $compile ( '<textarea ui-codemirror ng-model="foo"></textarea>' ) ( scope ) ; scope . $apply ( ) ; expect ( scope . foo ) . toBe ( undefined ) ; expect ( element . siblings ( ) . text ( ) . trim ( ) ) . toBe ( '' ) ; }
function ( aData ) { if ( gData . current . memory ) gData . previous . memory = gData . current . memory ; gData . current . memory = aData ; widget . port . emit ( 'update_memory' , aData ) ; logger . log ( config . application . topic_memory_statistics , aData ) ; }
function dragEnd ( e ) { $ ( this ) . unbind ( "mousemove" , draging ) . unbind ( "mouseup" , dragEnd ) ; if ( isMove ) { handler . unbind ( "mouseover" , dragDisable ) . unbind ( "mouseout" , dragDisable ) . unbind ( "click" , dragDisable ) ; whenDragEnd ( start ) ; } else { whenClick ( e ) ; isMove = true ; } }
function ( ) { $ ( this . target ) . unbind ( this . event , this . _handler ) ; this . keyHandlers = { } ; this . rules = [ ] ; this . history = [ ] ; delete this . _handler ; this . lock = false ; }
function ( target ) { var objs = arguments , l = objs . length , o , copy ; if ( l == 1 ) { objs [ 1 ] = target ; l = 2 ; target = this ; } for ( var i = 1 ; i < l ; i ++ ) { o = objs [ i ] ; for ( var n in o ) { copy = o [ n ] ; target [ n ] = copy ; } } return target ; }
function ( Backbone , DefaultState ) { Backbone . sync = function ( method , model , options ) { if ( options . keyTrail != null ) { return options . success ( DefaultState . get ( options . keyTrail ) ) ; } } ; window . slideConfig = { size : { width : 1024 , height : 768 } } ; return continuation ( ) ; }
function ( model , value ) { var key , persp , _ref , _results ; _ref = this . perspectives ; _results = [ ] ; for ( key in _ref ) { persp = _ref [ key ] ; _results . push ( persp . backgroundChanged ( value ) ) ; } return _results ; }
function find ( file ) { var jsfile ; if ( fs . existsSync ( file ) ) return file ; else { jsfile = file + '.js' ; if ( fs . existsSync ( jsfile ) ) return jsfile ; } throw new ProxyquireError ( util . format ( 'Cannot find file you required.\nTried [%s] and [%s]' , file , jsfile ) + '\nIf you are running tests from different files asynchronously, pass in scripts __dirname instead of using ' + 'proxyquire.setup().' ) ; }
function ( arg ) { if ( this . param . isDataRequired && ! this . conversion . isDataProvided ( ) ) { return Status . ERROR ; } if ( ! this . param . isDataRequired && this . arg . type === 'BlankArgument' ) { return Status . VALID ; } return this . conversion . getStatus ( arg ) ; }
function UnassignedAssignment ( arg , isIncompleteName ) { this . param = new canon . Parameter ( { name : '__unassigned' , type : 'string' } ) ; this . paramIndex = - 1 ; this . isIncompleteName = isIncompleteName ; this . onAssignmentChange = util . createEvent ( 'UnassignedAssignment.onAssignmentChange' ) ; this . conversion = new Conversion ( undefined , arg , Status . INCOMPLETE , '' ) ; this . conversion . assign ( this ) ; }
function ( ) { if ( this . _args ) { return this . _args . slice ( - 1 ) [ 0 ] . suffix . slice ( - 1 ) === ' ' ; } return this . toCanonicalString ( ) . slice ( - 1 ) === ' ' ; }
function startTests ( ) { emit ( "browser-login" , "Node" ) stream . write ( "login again" ) if ( consumer ) { consumer . removeListener ( "data" , onData ) consumer . removeListener ( "end" , onEnd ) } consumer = new Consumer ( ) consumer . on ( "data" , onData ) consumer . on ( "end" , onEnd ) var child = spawn ( testemOptions . command , testemOptions . args ) child . stdout . pipe ( consumer ) child . stderr . pipe ( stream ) }
function ( iName ) { keys . push ( iName ) ; var iTo = aTo [ iName ] = { } ; var iFrom = aFrom [ iName ] ; var i = attrLength , name ; while ( i -- ) { name = attrKeys [ i ] ; if ( iFrom [ name ] !== undefined ) iTo [ name ] = iFrom [ name ] ; } }
function ( err , data ) { var o_id = m . ObjectID . createFromHexString ( id ) ; data . findOne ( { _id : o_id } , function ( err , result ) { console . log ( err ) ; console . log ( result ) ; callback ( result ) ; } ) ; }
function ( ) { var lang = $ ( "#langdata" ) . val ( ) ; if ( lang != "" ) { $ ( '#tabs' ) . append ( "<div id='" + lang + "'><center>" + attname + "<input type='text' name='" + lang + "' id='" + lang + "' /></center><br></div>" ) ; $ ( "#tabs" ) . tabs ( "add" , "#" + lang , $ ( "#langdata option:selected" ) . text ( ) ) ; $ ( "select#langdata option[value='" + $ ( "#langdata" ) . val ( ) + "']" ) . remove ( ) ; } }
function ( ) { html = "<tr>" + "<td><input type='text' name='attribute_value_name_" + id + "' id='attribute_value_name_" + id + "' size='8' style='50%;'></td></tr>" ; $ ( '.dd' ) . fadeIn ( 'slow' ) ; $ ( '#ddtable tr:last' ) . after ( html ) ; id ++ ; }
function ( ) { var embedPlayer = this . embedPlayer ; mw . log ( "PlayerControlBuilder::syncPlayerSize: window:" + $ ( window ) . width ( ) + ' player: ' + $ ( embedPlayer ) . width ( ) ) ; if ( embedPlayer . playlist && ! this . inFullScreen ) { embedPlayer . playlist . syncPlayerSize ( ) ; } else { embedPlayer . resizePlayer ( this . getWindowSize ( ) ) ; } }
function ( responseText ) { var response = JSON . parse ( responseText + "" ) ; alert ( JSON . stringify ( response ) ) ; builder . selenium2 . rcPlayback . result . success = true ; }
function ( path ) { var d = new Deferred ( ) ; path = array . map ( path , function ( item ) { return lang . isString ( item ) ? item : tree . model . getIdentity ( item ) ; } ) ; if ( path . length ) { selectPath ( path , [ tree . rootNode ] , d ) ; } else { d . reject ( "Empty path" ) ; } return d ; }
function ( ) { if ( doneBuildingChannelList ) { return ; } doneBuildingChannelList = true ; var html = '' , $channelList = Util . getElementFromCache ( '#channel_list' ) ; for ( var p in _CHANNELS ) { html += '<li><a href="#date_list_page" data-send=\'{"channel":"' + _CHANNELS [ p ] + '","name":"' + p + '"}\' class="page_link channel_link">' + p + '</a></li>' ; } if ( $channelList . length ) { $channelList . html ( html ) ; } Util . getElementFromCache ( '#channel_list_page' ) . removeClass ( 'hide' ) ; }
function ( ) { var backButtonChannel = cordova . addDocumentEventHandler ( 'backbutton' , { onSubscribe : function ( ) { if ( this . numHandlers === 1 ) { exec ( null , null , "CoreEvents" , "overridebackbutton" , [ true ] ) ; } } , onUnsubscribe : function ( ) { if ( this . numHandlers === 0 ) { exec ( null , null , "CoreEvents" , "overridebackbutton" , [ false ] ) ; } } } ) ; }
function ( ) { $ ( '#pools-information' ) . fadeIn ( 'fast' ) ; that . plateElement . find ( '.aliquot' ) . removeClass ( that . plate . state ) ; that . colourPools ( ) ; that . control . find ( 'input:radio[name=radio-choice-1]:eq(1)' ) . attr ( 'checked' , true ) ; that . control . find ( 'input:radio' ) . checkboxradio ( "refresh" ) ; }
function ( ) { $ ( "input, textarea" ) . placeholder ( ) ; $ ( this . avatars . selector ) . error ( this . avatars . fallback ) ; $ . facebox . settings . closeImage = '/assets/facebox/closelabel.png' ; $ . facebox . settings . loadingImage = '/assets/facebox/loading.gif' ; $ . facebox . settings . opacity = 0.75 ; $ ( 'a[rel*=facebox]' ) . facebox ( ) ; }
function ( b ) { var a = this ; return a . contains ? ( a != b && a . contains ( b ) && 16 ) + ( a != b && b . contains ( a ) && 8 ) + ( a . sourceIndex >= 0 && b . sourceIndex >= 0 ? ( a . sourceIndex < b . sourceIndex && 4 ) + ( a . sourceIndex > b . sourceIndex && 2 ) : 1 ) + 0 : 0 ; }
function html5_document ( doc ) { var a = - 1 ; if ( doc . createElement ) { while ( ++ a < html5_elements_array . length ) { doc . createElement ( html5_elements_array [ a ] ) ; } if ( doc . createElement !== shivedCreateElement ) { doc [ "__orig__createElement__" ] = doc . createElement ; doc . createElement = shivedCreateElement ; } } return doc ; }
function ( b ) { var a = this ; return a . contains ? ( a != b && a . contains ( b ) && 16 ) + ( a != b && b . contains ( a ) && 8 ) + ( a . sourceIndex >= 0 && b . sourceIndex >= 0 ? ( a . sourceIndex < b . sourceIndex && 4 ) + ( a . sourceIndex > b . sourceIndex && 2 ) : 1 ) + 0 : 0 ; }
function html5_document ( doc ) { var a = - 1 , _doc ; if ( doc . createElement ) { while ( ++ a < html5_elements_array . length ) { doc . createElement ( html5_elements_array [ a ] ) ; } if ( doc . createElement !== shivedCreateElement && ! ( "ielt9" in doc . createElement ) ) { doc [ "__orig__createElement__" ] = doc . createElement ; doc . createElement = shivedCreateElement ; } } return doc ; }
function queryOneManySelector ( selector ) { return queryManySelector . call ( this , selector , true ) [ 0 ] || null ; }
function ( ) { return ActiveXObject ( "Microsoft.XMLHTTP" ) ; }
function ( position , html ) { var ref = this , container = ref . ownerDocument . createElement ( "_" ) , nodes , translate = { "beforebegin" : "before" , "afterbegin" : "preppend" , "beforeend" : "append" , "afterend" : "after" } , func ; container . innerHTML = html ; nodes = container . childNodes ; if ( nodes && nodes . length && ( func = ref [ translate [ position ] ] ) ) { func ( nodes ) } nodes = container = void 0 ; }
function extendNodeListPrototype ( nodeListProto ) { if ( nodeListProto && nodeListProto !== Array . prototype ) { nodeList_methods_fromArray . forEach ( function ( key ) { if ( ! nodeListProto [ key ] ) nodeListProto [ key ] = Array . prototype [ key ] ; } ) } }
function ( parent ) { var formatter = this . _getFormatter ( ) ; var data = this . getData ( parent . dataContext ) ; var formattedData = formatter ( data ) ; var node = formattedData ; if ( ! this . engine . adoptable ( formattedData ) ) { node = getDocument ( ) . newTextNode ( formattedData ) ; } return node ; }
function ( ) { return function ( x , y ) { return this . formatter ? this . formatter ( x , y ) : x ; } . bind ( this ) ; }
function ( ) { var inputElementId = "myText" ; var $text = createInputElement ( inputElementId , "@Min(value=5)" , "text" ) ; $text . val ( "" ) ; regula . configure ( { validateEmptyFields : false } ) ; regula . bind ( ) ; var constraintViolation = regula . validate ( ) [ 0 ] ; equals ( regula . validate ( ) . length , 0 , "@Min must not fail against empty field when validateEmptyFields is set to false" ) ; deleteElements ( ) ; }
function ( ) { var inputElementId = "myText" ; var $text = createInputElement ( inputElementId , "@Min(value=5, ignoreEmpty=true)" , "text" ) ; $text . val ( "" ) ; regula . configure ( { validateEmptyFields : true } ) ; regula . bind ( ) ; var constraintViolation = regula . validate ( ) [ 0 ] ; equals ( regula . validate ( ) . length , 0 , "@Min must not fail against empty field when validateEmptyFields is set to true and ignoreEmpty is set to true" ) ; deleteElements ( ) ; }
function ( simbolo ) { Utilitarios . assegureQue ( Utilitarios . instanciaDe ( simbolo , String ) ) ; this . simbolo = simbolo ; this . producoes = [ ] ; this . firsts = null ; this . follows = null ; this . recursivoAEsquerda = false ; this . receptoresDosFirsts = { } ; }
function ( ) { var recursivoAEsquerda = false ; this . producoes . paraCada ( function ( producao , indiceDaProducao ) { var indiceDoSimboloDaProducao = 0 ; var antecessoresDerivamEpsilon = true ; while ( indiceDoSimboloDaProducao < producao . length && antecessoresDerivamEpsilon && ! recursivoAEsquerda ) { var simboloDaProducao = producao [ indiceDoSimboloDaProducao ++ ] ; if ( simboloDaProducao !== this ) { antecessoresDerivamEpsilon = simboloDaProducao . derivaEpsilonEmZeroOuMaisPassos ( ) ; } else { recursivoAEsquerda = true ; return ; } } } , this ) ; this . recursivoAEsquerda = recursivoAEsquerda ; return this . recursivoAEsquerda ; }
function ( ev ) { ev . preventDefault ( ) ; this . model . add ( new Datea . Image ( { order : ( this . model . length - 1 ) } ) , { silent : true } ) ; this . render ( ) ; console . log ( this . model ) ; }
function ( image ) { if ( image && image . width && image . height ) { var c = new Canvas ; c . canvas = document . createElement ( 'canvas' ) ; c . width = c . canvas . width = image . width ; c . height = c . canvas . height = image . height ; c . ctx = c . canvas . getContext ( '2d' ) ; c . drawImage ( image , 0 , 0 ) ; return c ; } return null ; }
function ( ) { var p = new R . Pulse ( e . latlng , 6 , { 'stroke' : '#2478ad' , 'fill' : '#30a3ec' } , { 'stroke' : '#30a3ec' , 'stroke-width' : 3 } ) ; map . addLayer ( p ) ; setTimeout ( function ( ) { map . removeLayer ( b ) . removeLayer ( p ) ; } , 3000 ) ; }
function ( options ) { if ( this != navigator . id ) throw new Error ( "all navigator.id calls must be made on the navigator.id object" ) ; options = options || { } ; checkCompat ( false ) ; return internalRequest ( options ) ; }
function saveModified ( callback ) { $ . post ( "/save_transcription/" , $ ( '.modified' ) . serialize ( ) , function ( ) { console . log ( 'saved' ) ; $ ( '.modified' ) . removeClass ( 'modified' ) ; callback ( ) ; } ) ; }
function updateGrid ( ) { $ ( '.thumbnails' ) . trigger ( 'resize' ) ; }
function ( evt ) { if ( evt . keyCode === 32 ) { evt . preventDefault ( ) ; } }
function ( evt ) { if ( evt . keyCode === 32 ) { if ( popcorn . paused ( ) ) { popcorn . play ( ) ; } else { popcorn . pause ( ) ; } } }
function ( ) { _this . server . responses = [ ] _this . server . respondWith ( 'GET' , _this . url , TestResponses . chat . error ) ; _this . server . respond ( ) ; expect ( _this . view . el . find ( 'div.crashed' ) . length ) . toBeTruthy ; }
function ( ) { var elem = $ ( 'li[data-href="' + window . History . getState ( ) . title + '"]' ) ; if ( elem . next ( ".sub-header" ) . length ) { self . show ( elem . next ( ".sub-header" ) ) ; } }
function ( image , key ) { key = key . split ( '\\' ) . getLast ( ) ; var f = document . getElements ( 'input[name*=' + key + ']' ) ; f = f [ 1 ] ; f . value = JSON . encode ( image ) ; }
function ( jqXHR , textStatus , errorThrown ) { var st = jqXHR . status ; if ( st == 401 || st == 403 ) { var msg = ( st == 401 ) ? "Invalid username or password" : "Access denied: please log in" ; say_status ( msg ) ; show_login_form ( ) ; } else { say_status ( "Error: " + st + " " + textStatus ) ; } }
function escapeHTML ( str , escapeQuotes ) { var span = document . createElement ( 'span' ) ; span . textContent = str ; if ( escapeQuotes ) return span . innerHTML . replace ( /"/g , '&quot;' ) . replace ( /'/g , '&#x27;' ) ; return span . innerHTML ; }
function ( data ) { rescaleGraph ( data ) console . log ( "the data to store:" , data ) ; graph_substrate . nodes ( data . nodes ) graph_substrate . links ( data . links ) graph_substrate . edgeBinding ( ) var g = graphDrawing ( graph_substrate , svg_substrate ) g . draw ( ) return }
function ( data ) { console . log ( "received data after synchronization: " ) console . log ( data ) ; rescaleGraph ( data ) cGraph . nodes ( data . nodes ) cGraph . links ( data . links ) cGraph . edgeBinding ( ) g = graphDrawing ( cGraph , svg ) g . show ( cGraph ) if ( 'data' in data ) { cohesion_homogeneity = data [ 'data' ] [ 'cohesion homogeneity' ] ; cohesion_intensity = data [ 'data' ] [ 'cohesion intensity' ] ; cohesionCaught ( ) ; } }
function ( data ) { console . log ( "received data after analysis:" ) console . log ( data ) ; rescaleGraph ( data ) graph_catalyst . nodes ( data . nodes ) graph_catalyst . links ( data . links ) graph_catalyst . edgeBinding ( ) g = graphDrawing ( graph_catalyst , svg_catalyst ) g . clear ( ) g . draw ( ) cohesion_homogeneity = data [ 'data' ] [ 'cohesion homogeneity' ] cohesion_intensity = data [ 'data' ] [ 'cohesion intensity' ] cohesionCaught ( ) ; }
function ( data ) { console . log ( 'creating in tulip, and recieved data: ' , data ) rescaleGraph ( data ) graph_substrate . nodes ( data . nodes ) graph_substrate . links ( data . links ) graph_substrate . edgeBinding ( ) g = graphDrawing ( graph_substrate , svg_substrate ) g . move ( graph_substrate , 0 ) }
function ( d ) { d . x = ( d . x - minX ) * scale + buttonWidth + frame ; d . y = ( d . y - minY ) * scale + frame ; }
function ( event ) { var hashId = event . target . hash , section = hashId && $ ( hashId ) , offset = window . scrollY , targetId = hashId ? hashId . substring ( 1 , hashId . length ) : null ; if ( targetId === subnavId ) { event . preventDefault ( ) ; toggleSubnav ( ) ; } else if ( section ) { animateScrollToLink ( section ) ; } }
function updateResizeRect ( ) { var controlElm = dom . getParent ( selection . getNode ( ) , 'table,img' ) ; if ( controlElm ) { showResizeRect ( controlElm ) ; } else if ( selectedElm ) { dom . removeClass ( dom . select ( 'img.mceResizeSelected' ) , 'mceResizeSelected' ) ; hideResizeRect ( ) ; } }
function ( result ) { if ( result . success == false ) { if ( typeof result . php_error != "undefined" && result . php_error == true && Plexis . debugging == true ) { show_php_error ( result . php_error_data ) ; } } else { var finished = parse_realm_status ( result , div_id ) ; if ( finished == '' ) finished = '<center>No Realms Installed</center>' ; $ ( div_id ) . html ( finished ) . show ( ) ; $ ( loading_id ) . hide ( ) ; } }
function ( template , vars ) { renderer . render ( target + " .contents" , template , vars ) ; dom . addClass ( BODY , className ) ; dom . fireEvent ( window , "resize" ) ; this . visible = true ; }
function animateClose ( callback ) { var body = $ ( "body" ) , bodyWidth = body . innerWidth ( ) , doAnimation = $ ( "#signIn" ) . length && bodyWidth > 640 ; if ( doAnimation ) { var endWidth = bodyWidth - 10 ; body . addClass ( "completing" ) ; $ ( "#signIn" ) . css ( "width" , endWidth + "px" ) ; setTimeout ( complete . curry ( callback ) , 1750 ) ; } else { complete ( callback ) ; } }
function ( fmt , obj , named ) { if ( ! fmt ) return "" ; if ( named ) { return fmt . replace ( /%\(\w+\)s/g , function ( match ) { return String ( obj [ match . slice ( 2 , - 2 ) ] ) } ) ; } else { return fmt . replace ( /%s/g , function ( match ) { return String ( obj . shift ( ) ) } ) ; } }
function describeOperation ( name , op ) { var str = "  " + name + " (" ; str += op . method . toUpperCase ( ) + " - " ; str += ( op . authed ? "" : "not " ) + "authed" ; if ( op . args ) { str += " - " + op . args . join ( ", " ) ; } str += ")" ; logger . debug ( str ) ; }
function ( msgid ) { if ( json_locale_data && json_locale_data [ "client" ] ) { var dict = json_locale_data [ "client" ] ; if ( dict [ msgid ] && dict [ msgid ] . length >= 2 && dict [ msgid ] [ 1 ] . trim ( ) != "" ) { return dict [ msgid ] [ 1 ] ; } } return msgid ; }
function ( slimeVersion ) { cont ( { pid : self . pid === null ? process . pid : self . pid , encoding : { codingSystem : "utf-8" , externalFormat : "UTF-8" } , packageSpec : { name : prompt , prompt : prompt } , implementation : { type : "JS" , name : "JS" , version : "1.5" } , version : slimeVersion || DEFAULT_SLIME_VERSION } ) ; }
function ( err , req , res , next ) { winston . error ( err ) ; if ( req . accepts ( 'html' ) || req . is ( 'html' ) ) { res . status ( err . status || 500 ) ; res . render ( '500' , { error : err } ) ; return ; } res . send ( err . status || 500 , { error : err . message } ) ; }
function ( req , res ) { winston . error ( 'Failed to locate:' + req . url ) ; if ( req . accepts ( 'html' ) || req . is ( 'html' ) ) { res . status ( 404 ) ; res . render ( '404' , { url : req . url } ) ; return ; } res . send ( 404 , { error : "can't find the resource" } ) ; }
function ( resp ) { console . log ( "\n===> thumbnailSaveAs result: " , resp ) ; if ( resp . code != 200 ) { return ; } imgrs . publish ( DEMO_DOMAIN , function ( resp ) { console . log ( "\n===> Publish result: " , resp ) ; if ( resp . code != 200 ) { return ; } } ) ; }
function ( h ) { if ( h [ 'attachmentPoint' ] . length > 0 ) { h . swport = _ . reduce ( h [ 'attachmentPoint' ] , function ( memo , ap ) { return memo + ap . dpid + "-" + ap . port + " " } , "" ) console . log ( h . swport ) ; self . add ( h , { silent : true } ) ; } }
function ( ) { this . overlay . setAttribute ( 'style' , 'opacity:1.0;background-color:' + bb . options . bb10HighlightColor + ';' ) ; itemNode . fingerDown = true ; itemNode . contextShown = false ; if ( itemNode . contextMenu ) { window . setTimeout ( this . touchTimer , 667 ) ; } }
function ( ) { this . overlay . setAttribute ( 'style' , '' ) ; itemNode . fingerDown = false ; if ( itemNode . contextShown ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; } }
function ( ) { if ( outerElement . isActivated === true ) { outerElement . isActivated = false ; outerElement . currentXPos = outerElement . transientXPos ; outerElement . value = parseInt ( outerElement . range . value ) ; outerElement . halo . style [ '-webkit-transform' ] = 'scale(0)' ; outerElement . halo . style [ '-webkit-animation-name' ] = 'implode' ; outerElement . indicator . setAttribute ( 'class' , 'indicator' ) ; outerElement . indicator . style . background = '' ; } }
function ( ) { this . overlay . setAttribute ( 'style' , 'opacity:1.0;background-color:' + bb . options . bb10HighlightColor + ';' ) ; itemNode . fingerDown = true ; itemNode . contextShown = false ; if ( itemNode . contextMenu ) { window . setTimeout ( this . touchTimer , 667 ) ; } }
function ( ) { this . overlay . setAttribute ( 'style' , '' ) ; itemNode . fingerDown = false ; if ( itemNode . contextShown ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; } }
function ( ) { if ( outerElement . isActivated === true ) { outerElement . isActivated = false ; outerElement . currentXPos = outerElement . transientXPos ; outerElement . value = parseInt ( outerElement . range . value ) ; outerElement . halo . style [ '-webkit-transform' ] = 'scale(0)' ; outerElement . halo . style [ '-webkit-animation-name' ] = 'implode' ; outerElement . indicator . setAttribute ( 'class' , 'indicator' ) ; outerElement . indicator . style . background = '' ; } }
function ( ) { this . overlay . setAttribute ( 'style' , 'opacity:1.0;background-color:' + bb . options . bb10HighlightColor + ';' ) ; itemNode . fingerDown = true ; itemNode . contextShown = false ; if ( itemNode . contextMenu ) { window . setTimeout ( this . touchTimer , 667 ) ; } }
function ( ) { this . overlay . setAttribute ( 'style' , '' ) ; itemNode . fingerDown = false ; if ( itemNode . contextShown ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; } }
function ( checkSet , part , isXML ) { var nodeCheck , doneName = done ++ , checkFn = dirCheck ; if ( typeof part === "string" && ! /\W/ . test ( part ) ) { part = part . toLowerCase ( ) ; nodeCheck = part ; checkFn = dirNodeCheck ; } checkFn ( "parentNode" , part , doneName , checkSet , nodeCheck , isXML ) ; }
function ( checkSet , part , isXML ) { var nodeCheck , doneName = done ++ , checkFn = dirCheck ; if ( typeof part === "string" && ! /\W/ . test ( part ) ) { part = part . toLowerCase ( ) ; nodeCheck = part ; checkFn = dirNodeCheck ; } checkFn ( "previousSibling" , part , doneName , checkSet , nodeCheck , isXML ) ; }
function loadEsprima ( ) { if ( typeof esprima === 'undefined' ) { console . log ( "Loading esprima.js" ) ; $script = $ ( "<script>" ) . attr ( "src" , require . toUrl ( "lib/esprima.js" ) ) . appendTo ( window . document . head ) ; } else { console . log ( "Esprima already loaded" ) ; } }
function ( top ) { const overviewHeight = 90 ; const sectionMinHeight = 100 ; top = Number . constrain ( top , overviewHeight + sectionMinHeight , this . element . offsetHeight - sectionMinHeight ) ; this . splitView . element . style . height = ( top - overviewHeight ) + "px" ; this . _timelineMemorySplitter . style . top = ( top - 2 ) + "px" ; this . _memoryStatistics . setTopPosition ( top ) ; this . _containerElementHeight = this . _containerElement . clientHeight ; }
function ( ) { var piyo = { hoge : function ( ) { return 'hoge' ; } , huga : function ( ) { return 'huga' ; } } ; return expect ( ensure ( piyo , HogeInterface , HugaInterface ) ) . to_eq ( undefined ) ; }
function ( err , db ) { db . query ( "get_datum_ids/by_date" , { reduce : false } , function ( err , response ) { if ( ( ! err ) && ( typeof callback == "function" ) ) { console . log ( "Callback with: " , response . rows ) ; callback ( response . rows ) } } ) ; }
function ( event ) { if ( ! this . menu . peeking ) return ; var touch = event . touches [ 0 ] ; if ( this . startPos && ( this . startPos - touch . pageX > this . threshold ) ) { this . menu . show ( this . menu . selected ) ; this . closeMenu = false ; } }
function ( event ) { if ( ! this . menu . peeking ) return ; var touch = event . touches [ 0 ] ; if ( this . startPos && ( this . startPos - touch . pageX > this . threshold ) ) { this . menu . show ( this . menu . selected ) ; this . closeMenu = false ; } }
function ensureObjectStore ( osName , callback ) { gazel . version ++ ; openDatabase ( function ( ) { callback ( ) ; } , null , function ( db ) { if ( ! db . objectStoreNames . contains ( osName ) ) { db . createObjectStore ( osName ) ; } } ) ; }
function ensureObjectStore ( osName , callback ) { gazel . version ++ ; openDatabase ( function ( ) { callback ( ) ; } , null , function ( db ) { if ( ! db . objectStoreNames . contains ( osName ) ) { db . createObjectStore ( osName ) ; } } ) ; }
function ( snake ) { var tiles = document . getElementById ( "arena" ) . children ; function changeClass ( index , className ) { tiles [ index ] . className = className ; } changeClass ( snake . head , "head" ) ; snake . tail . forEach ( function ( tailIndex ) { changeClass ( tailIndex , "tail" ) ; } ) ; snake . trail . forEach ( function ( trailIndex ) { changeClass ( trailIndex , "trail" ) ; } ) ; }
function ( response ) { assert ( response . raw ) ; assert . same ( request , response . request ) ; assert . equals ( response . entity , 'hello world' ) ; assert . equals ( response . status . code , 200 ) ; assert . equals ( 'text/plain' , response . headers [ 'Content-Type' ] ) ; assert . equals ( response . entity . length , parseInt ( response . headers [ 'Content-Length' ] , 10 ) ) ; done ( ) ; }
function ( response ) { assert ( response . raw ) ; assert . same ( request , response . request ) ; assert . equals ( response . entity , 'echo' ) ; assert . equals ( response . status . code , 200 ) ; assert . equals ( 'text/plain' , response . headers [ 'Content-Type' ] ) ; assert . equals ( response . entity . length , parseInt ( response . headers [ 'Content-Length' ] , 10 ) ) ; done ( ) ; }
function ( done ) { var client ; client = oAuth ( function ( request ) { return { request : request , status : { code : 200 } } ; } , { token : 'bearer abcxyz' } ) ; client ( { } ) . then ( function ( response ) { assert . equals ( 'bearer abcxyz' , response . request . headers . Authorization ) ; done ( ) ; } ) ; }
function ( done ) { var client = pathPrefix ( function ( request ) { return { request : request } ; } , { prefix : '/foo' } ) ; client ( { path : '/bar' } ) . then ( function ( response ) { assert . equals ( '/foo/bar' , response . request . path ) ; done ( ) ; } ) ; }
function ( done ) { var client = pathPrefix ( function ( request ) { return { request : request } ; } , { prefix : '/foo' } ) ; client ( { path : 'bar' } ) . then ( function ( response ) { assert . equals ( '/foo/bar' , response . request . path ) ; done ( ) ; } ) ; }
function ( spec ) { when ( spec . client ( { path : 'to/somewhere' } ) , function ( response ) { assert . equals ( 'path/to/somewhere' , response . request . path ) ; assert . equals ( 'text/plain' , response . request . headers . Accept ) ; assert . equals ( 'bar' , response . entity . foo ) ; done ( ) ; } , never ( done ) ) ; }
function ( spec ) { when ( spec . client ( { method : 'post' , entity : { bleep : 'bloop' } } ) , function ( response ) { assert . equals ( '{"bleep":"bloop"}' , response . request . entity ) ; assert . equals ( 0 , response . request . headers . Accept . indexOf ( 'application/json' ) ) ; assert . equals ( 'application/json' , response . request . headers [ 'Content-Type' ] ) ; done ( ) ; } , never ( done ( ) ) ) ; }
function ( response ) { assert . equals ( 'what is the meaning of life?' , response . request . params . q ) ; done ( ) ; }
function ( response ) { assert . equals ( '42' , response . request . path ) ; refute ( response . request . method ) ; done ( ) ; }
function ( response ) { assert . equals ( '42' , response . request . path ) ; assert . equals ( 'delete' , response . request . method ) ; done ( ) ; }
function ( done ) { var store = new RestStore ( { client : client } ) ; when ( store . put ( { foo : 'bar' , id : 42 } , { overwrite : false } ) , function ( response ) { assert . equals ( '42' , response . request . path ) ; assert . equals ( 'put' , response . request . method ) ; assert . equals ( '*' , response . request . headers [ 'If-None-Match' ] ) ; done ( ) ; } ) ; }
function ( done ) { var store = new RestStore ( { client : client } ) ; when ( store . put ( { foo : 'bar' , id : 42 } ) , function ( response ) { assert . equals ( '42' , response . request . path ) ; assert . equals ( 'put' , response . request . method ) ; refute ( response . request . headers [ 'If-None-Match' ] ) ; refute ( response . request . headers [ 'If-Match' ] ) ; done ( ) ; } ) ; }
function ( spec ) { spec . resource . then ( function ( resource ) { assert . equals ( 'bar' , resource . entity . foo ) ; assert . equals ( 'test/dojo/hello.json' , resource . request . path ) ; done ( ) ; } , never ( done ) ) ; }
function ( done ) { var client = basicAuth ( function ( request ) { return { request : request } ; } , { username : 'user' , password : 'pass' } ) ; client ( { } ) . then ( function ( response ) { assert . equals ( 'dXNlcjpwYXNz' , response . request . headers . Authorization ) ; done ( ) ; } ) ; }
function ( done ) { var client = basicAuth ( function ( request ) { return { request : request } ; } ) ; client ( { username : 'user' , password : 'pass' } ) . then ( function ( response ) { assert . equals ( 'dXNlcjpwYXNz' , response . request . headers . Authorization ) ; done ( ) ; } ) ; }
function ( done ) { var client , body ; body = { } ; client = entity ( function ( ) { return { entity : body } ; } ) ; client ( ) . then ( function ( response ) { assert . same ( body , response ) ; done ( ) ; } ) ; }
function ( done ) { var client , response ; response = { } ; client = entity ( function ( ) { return response ; } ) ; client ( ) . then ( function ( r ) { assert . same ( response , r ) ; done ( ) ; } ) ; }
function ( response ) { assert . equals ( 400 , response . status . code ) ; done ( ) ; }
function ( done ) { var client = errorCode ( function ( ) { return { status : { code : 400 } } ; } ) ; client ( { } ) . then ( function ( response ) { assert . fail ( 'success handler should not be involved' ) ; done ( ) ; } , function ( response ) { assert . equals ( 400 , response . status . code ) ; done ( ) ; } ) ; }
function ( done ) { var client = errorCode ( function ( ) { return { status : { code : 300 } } ; } , { code : 300 } ) ; client ( { } ) . then ( function ( response ) { assert . fail ( 'success handler should not be involved' ) ; done ( ) ; } , function ( response ) { assert . equals ( 300 , response . status . code ) ; done ( ) ; } ) ; }
function ( ) { var client = jsonp ( function ( request ) { return { request : request } ; } , { callback : { param : 'callback' , prefix : 'jsonp' } } ) ; when ( client ( { } ) ) . then ( function ( response ) { assert . equals ( 'callback' , response . request . callback . param ) ; assert . equals ( 'jsonp' , response . request . callback . prefix ) ; } ) ; }
function ( done ) { var client ; client = mime ( function ( ) { return { entity : '{}' , headers : { 'Content-Type' : 'application/json' } } ; } ) ; client ( { } ) . then ( function ( response ) { assert . equals ( { } , response . entity ) ; done ( ) ; } ) ; }
function ( done ) { var client ; client = mime ( function ( request ) { return { request : request , headers : { } } ; } , { mime : 'application/json' } ) ; client ( { entity : { } } ) . then ( function ( response ) { assert . equals ( '{}' , response . request . entity ) ; done ( ) ; } ) ; }
function ( imagen , x , y , centro_x , centro_y , escala_x , escala_y , rotacion ) { imagen = imagen || "sin_imagen.png" this . imagen = this . cargar_imagen ( imagen ) this . inicializar ( x , y , centro_x , centro_y , escala_x , escala_y , rotacion ) this . centro_x = 16 this . centro_y = 16 singleton . get ( ) . agregar_actor ( this ) }
function ( x , y , centro_x , centro_y , escala_x , escala_y , rotacion ) { this . x = x || 0 this . y = y || 0 this . centro_x = centro_x || 0 this . centro_y = centro_y || 0 this . escala_x = escala_x || 1 this . escala_y = escala_y || 1 this . _rotacion = rotacion || 0 }
function ( dx , dy ) { if ( dx === "centro" ) dx = this . imagen . image . width / 2 if ( dy === "centro" ) dy = this . imagen . image . height / 2 this . centro_x = Math . round ( dx ) this . centro_y = Math . round ( dy ) }
function ( require , mootools ) { var Utils = new Class ( { convertir_a_radianes : function ( grados ) { return grados * ( Math . PI / 180 ) ; } , convertir_a_grados : function ( radianes ) { return radianes * ( 180 / Math . PI ) ; } , } ) ; function sumar ( a , b ) { return a + b } return { sumar : sumar , Utils : Utils } }
function ( g , x , y ) { this . g . setStrokeStyle ( 1 ) ; this . g . beginStroke ( Graphics . getRGB ( 255 , 0 , 0 ) ) ; g . moveTo ( x - 3 , y - 3 ) g . lineTo ( x + 3 , y + 3 ) g . moveTo ( x + 3 , y - 3 ) g . lineTo ( x - 3 , y + 3 ) }
function ( ) { var eventos = this this . canvas . onclick = function ( e ) { eventos . click_de_mouse . emitir ( { x : e . clientX , y : e . clientY } ) } this . canvas . onmousemove = function ( e ) { eventos . mueve_mouse . emitir ( { x : e . clientX , y : e . clientY } ) } }
function ( mootools ) { var Imagenes = new Class ( { initialize : function ( prefijo ) { this . prefijo = prefijo || "data/" } , cargar : function ( ruta ) { var imagen = new Bitmap ( this . prefijo + ruta ) return imagen } , } ) return { Imagenes : Imagenes , } } ) ;
function ( ) { test . done ( ) }
function ( callback ) { if ( process . _exiting ) return ; var tock = { callback : callback } ; if ( process . domain ) tock . domain = process . domain ; nextTickQueue . push ( tock ) ; process . _needTickCallback ( ) ; }
function mouseup ( e ) { if ( ! scene ) { return ; } pv . Mark . dispatch ( "selectend" , scene , index , e ) ; scene . mark . selectionRect = null ; scene = null ; }
function ( e ) { if ( e . keyCode == Event . KEY_RETURN ) { chat . message ( '/join ' + $ ( 'entered_channel' ) . getValue ( ) ) ; $ ( 'entered_channel' ) . clear ( ) ; chat . listWindow . hide ( ) ; return true ; } }
function ( ) { while ( $ ( this . content ) . firstChild ) { $ ( this . content ) . removeChild ( $ ( this . content ) . firstChild ) ; } $ ( this . content ) . update ( '' ) ; }
function ( instance , schema ) { if ( typeof schema . type === 'object' && ( schema . type instanceof Array ) ) { this . validateUnionType ( instance , schema ) ; } else { this . validateSchema ( instance , schema ) ; } return this . errors . length === 0 ; }
function ( instance , schema ) { var a ; if ( typeof instance !== 'object' ) { this . addError ( "not an object" ) ; } else { for ( var property in schema . properties ) { if ( schema . properties . hasOwnProperty ( property ) ) { this . validate ( instance [ property ] , schema . properties [ property ] ) ; } } } }
function ( instance , schema ) { var a , i ; if ( ! ( instance instanceof Array ) ) { this . addError ( "not an array" ) ; } else { for ( i = 0 ; i < instance . length ; i ++ ) { this . validate ( instance [ i ] , schema . items ) ; } } }
function ( ) { var toRemove = this . collection . filter ( function ( model ) { return model . get ( 'completed' ) == 'completed' ; } ) ; Array . each ( toRemove , this . collection . removeModel . bind ( this . collection ) ) }
function ( ) { var remaining = 0 , completed = this . collection . filter ( function ( el ) { var status = el . get ( 'completed' ) == 'completed' ; if ( ! status ) remaining ++ ; return status ; } ) . length ; this . footer . set ( 'html' , this . template ( { completed : completed , remaining : remaining } ) ) ; this . toggleAll . set ( 'checked' , ! remaining ) ; }
function ( ) { this . about = { name : "Hangman" , description : "A game of hangman" , author : "Alan Foster (http://www.alanfoster.me)" } ; this . triggers = [ [ /^!start/ , this . tryCreateGame ] , [ /^!guess (.*)/ , this . tryGuess ] ] ; this . help = [ [ "!start" , "Creates a new game for this channelnel if one isn't already started" ] , [ "!guess <letter(s)>" , "Guess n letters on the current game being played." ] ] ; this . currentGames = { } ; return this ; }
function ( channel , user , word ) { this . channel = channel ; this . user = user ; this . rawWord = word ; this . modifiedWord = word . replace ( /./g , "_" ) ; this . guessedLetters = new Array ( 26 ) ; this . totalWrong = 0 ; this . maxGuesses = 6 ; return this ; }
function ( ) { return this . modifiedWord . indexOf ( "_" ) === - 1 ; }
function logStartup ( data ) { if ( ss . storage . h . length >= MAX_LOG_ENTRIES ) ss . storage . h . shift ( ) ; ss . storage . h . push ( { 'time' : _time , 'startupTime' : _startupTime , 'data' : data } ) ; if ( lastWorker ) lastWorker . postMessage ( ss . storage . h ) ; ready = true ; }
function ( json ) { var velo = json . Velo ; if ( velo . length <= 0 ) { return undefined ; } for ( var i in velo ) { velo [ i ] . distance = Math . round ( parseInt ( velo [ i ] . distance ) / 10 ) * 10 ; } return velo ; }
function ( json ) { var villo = json . Villo ; if ( villo . length <= 0 ) { return undefined ; } for ( var i in villo ) { villo [ i ] . distance = Math . round ( parseInt ( villo [ i ] . distance ) / 10 ) * 10 ; villo [ i ] . name = jQuery . trim ( villo [ i ] . name ) ; } return villo ; }
function ( users , maxUsers , el ) { var percentage = users / maxUsers ; el . css ( { "-webkit-transform" : "scale( " + percentage + "," + percentage + ")" , opacity : percentage } ) ; }
function ( inx , video ) { var v = $ ( video ) ; if ( v . data ( 'meta' ) . identifier == user . videoOver ) { v . data ( 'userCount' , ( v . data ( 'userCount' ) || 0 ) + 1 ) ; _this . applyStyle ( v . data ( 'userCount' ) , users . length , v ) ; } }
function cI_cGR_getInterfaces ( aCount ) { var ifaces = [ Components . interfaces . nsISupports , Components . interfaces . calIGoogleRequest , Components . interfaces . calIOperation , Components . interfaces . nsIStreamLoaderObserver , Components . interfaces . nsIInterfaceRequestor , Components . interfaces . nsIChannelEventSink , Components . interfaces . nsIClassInfo ] ; aCount . value = ifaces . length ; return ifaces ; }
function ( doc ) { ArticleManager . initialDocument . meta = doc . meta ; ArticleManager . initialDocument . children = doc . children ; ArticleManager . initialDocument . requirements = doc . requirements ; initialDocumentMeta . forEach ( function ( meta ) { var name = meta . getAttribute ( 'name' ) , content = meta . getAttribute ( 'content' ) ; if ( name && content ) { doc . meta [ name ] = content ; } } ) ; doc . parent . replaceChild ( ArticleManager . initialDocument , doc ) ; }
function ( xhr , textStatus ) { if ( options . ajaxCache && ! caches [ tipAttribute ] ) { caches [ tipAttribute ] = { status : 'error' , textStatus : textStatus , xhr : xhr } ; } if ( isActive ) { if ( optionError ) { optionError . call ( link , xhr , textStatus , $cluetip , $cluetipInner ) ; } else { $cluetipInner . html ( '<i>sorry, the contents could not be loaded</i>' ) ; } } }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'update_history' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 58 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 783 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 806 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 847 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 878 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 979 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'edit-issue.iced' , funcname : 'onhashchange' } ) ; $ . getJSON ( "/api/" + hash , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return data = arguments [ 0 ] ; } ; } ) ( ) , lineno : 23 } ) ) ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'edit-list.iced' } ) ; $ . getJSON ( "/api" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return data = arguments [ 0 ] ; } ; } ) ( ) , lineno : 1 } ) ) ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'update_history' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 58 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 783 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 806 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 847 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 878 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 979 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'update_history' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 58 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 783 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 806 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 847 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 878 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 979 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'update-issue.iced' , funcname : 'onhashchange' } ) ; $ . getJSON ( "/api/" + hash , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return data = arguments [ 0 ] ; } ; } ) ( ) , lineno : 25 } ) ) ) ; __iced_deferrals . _fulfill ( ) ; }
function ( options ) { var html = "" ; selector . empty ( ) ; KT . utils . each ( options , function ( option ) { html += '<option value="' + option [ 'id' ] + '">' + option [ 'name' ] + '</option>' ; } ) ; selector . append ( html ) ; }
function ( data ) { comparison_grid . set_columns ( subgrid . cols ) ; comparison_grid . set_mode ( "details" ) ; comparison_grid . show_columns ( subgrid . cols ) ; if ( search_params . subgrid . type !== 'compare' ) { comparison_grid . set_content_select ( utils . values ( subgrids ) ) ; } comparison_grid . set_title ( data . name ) ; draw_grid ( data . rows ) ; }
function ( data ) { comparison_grid . set_columns ( env_select . get_paths ( ) ) ; select_envs ( get_initial_environments ( ) ) ; draw_grid ( data ) ; cache . save_state ( comparison_grid , search_params ) ; }
function updateVerticalScroll ( scrollTop ) { var showScrollbar = scroller . scrollHeight > scroller . offsetHeight ; scrollbar . style . display = showScrollbar ? "block" : "none" ; if ( showScrollbar ) { scrollbarInner . style . height = scroller . scrollHeight + "px" ; scrollbar . style . height = scroller . offsetHeight + "px" ; if ( scrollTop != null ) scrollbar . scrollTop = scrollTop ; } mover . style . top = ( displayOffset * textHeight ( ) - scrollbar . scrollTop ) + "px" ; }
function ( ) { if ( ( this . _iExpectation >= this . _expectations . length ) && ( this . _expectDeath ? ( this . _logger && this . _logger . _died ) : true ) ) { this . _resolved = true ; return this . _expectationsMetSoFar ; } if ( ! this . _deferred ) this . _deferred = $Q . defer ( ) ; return this . _deferred . promise ; }
function ( ) { if ( this . __stepCleanup ) this . __stepCleanup ( ) ; var expectationsWereMet = this . _expectationsMetSoFar ; this . _expectationsMetSoFar = true ; this . _iExpectation = 0 ; this . _expectations . splice ( 0 , this . _expectations . length ) ; this . _expectDeath = false ; this . _unorderedSetMode = false ; this . _deferred = null ; this . _resolved = false ; this . _activeForTestStep = false ; return expectationsWereMet ; }
function testActorConstructor ( name , _parentUniqueName ) { this . __name = name ; this . _uniqueName = gUniqueActorName ++ ; this . _parentUniqueName = _parentUniqueName ; this . _logger = undefined ; this . _expectations = [ ] ; this . _expectationsMetSoFar = true ; this . _expectDeath = false ; this . _unorderedSetMode = false ; this . _activeForTestStep = false ; this . _iEntry = this . _iExpectation = 0 ; this . _lifecycleListener = null ; }
function ( newCount , knownCount ) { self . _LOG . syncDateRange_end ( newCount , knownCount , numDeleted , startTS , endTS ) ; self . _storage . markSyncRange ( startTS , endTS , modseq , Date . now ( ) ) ; doneCallback ( newCount + knownCount ) ; }
function ( ) { partsReceived . push ( finishBodyParsing ( ) ) ; if ( partsReceived . length === chewRep . bodyParts . length ) { if ( $imapchew . chewBodyParts ( chewRep , partsReceived , storage . folderId ) ) { storage . addMessageHeader ( chewRep . header ) ; storage . addMessageBody ( chewRep . header , chewRep . bodyInfo ) ; } if ( -- pendingFetches === 0 ) callbacks . newMsgs ( ) ; } }
function ( date , uid ) { if ( ! this . _headerBlockInfos . length ) return ( date === null && uid === null ) ; var blockInfo = this . _headerBlockInfos [ 0 ] ; return ( date === blockInfo . endTS && uid === blockInfo . endUID ) ; }
function ma_viewFolderMessages ( folder ) { var handle = this . _nextHandle ++ , slice = new HeadersViewSlice ( this , handle ) ; this . _slices [ handle ] = slice ; this . __bridgeSend ( { type : 'viewFolderMessages' , folderId : folder . id , handle : handle , } ) ; return slice ; }
function mb__cmd_tryToCreateAccount ( msg ) { var self = this ; this . universe . tryToCreateAccount ( msg . details , function ( good , account ) { self . __sendMessage ( { type : 'tryToCreateAccountResults' , handle : msg . handle , error : good ? null : 'generic-badness' , } ) ; } ) ; }
function onUniverse ( ) { localMailAPI = createBridgePair ( universe ) . api ; console . log ( "Mail universe/bridge created, notifying." ) ; for ( var i = 0 ; i < _universeCallbacks . length ; i ++ ) { _universeCallbacks [ i ] ( universe ) ; } _universeCallbacks = null ; var evtObject = document . createEvent ( 'Event' ) ; evtObject . initEvent ( 'mailapi' , false , false ) ; evtObject . mailAPI = localMailAPI ; window . dispatchEvent ( evtObject ) ; }
function ( event ) { if ( event . origin !== ORIGIN ) return ; if ( event . data . id !== channelId ) return ; clearInterval ( spamIntervalId ) ; event . source . postMessage ( { type : "backlog" , id : channelId , schema : $log . provideSchemaForAllKnownFabs ( ) , backlog : LOG_BACKLOG , } , event . origin ) ; }
function ( e ) { if ( ! this . isLoaded ) return ; if ( e . data == 1 ) { Storage . goOnline ( ) ; if ( this . config . location ) Location . get ( ) ; this . onOnline . call ( this ) ; } else { Storage . goOffline ( ) ; this . onOffline . call ( this ) ; } }
function ( ) { $ ( this ) . attr ( 'style' , 'display:block;' ) ; var data = $ . collapsibleTabs . getSettings ( $ ( this ) ) ; if ( ! data ) { return ; } var expContainerSettings = $ . collapsibleTabs . getSettings ( $ ( data . expandedContainer ) ) ; if ( ! expContainerSettings ) { return ; } expContainerSettings . shifting = false ; $ . collapsibleTabs . handleResize ( ) ; }
function ( ) { if ( $ ( '#p-cactions' ) . css ( 'display' ) == 'none' ) { $ ( '#p-cactions' ) . addClass ( 'filledPortlet' ) . removeClass ( 'emptyPortlet' ) . find ( 'h5' ) . css ( 'width' , '1px' ) . animate ( { 'width' : '26px' } , 390 ) ; } }
function ( eleWidth ) { if ( rtl ) { return ( $ ( '#right-navigation' ) . position ( ) . left + $ ( '#right-navigation' ) . width ( ) + 1 ) < ( $ ( '#left-navigation' ) . position ( ) . left - eleWidth ) ; } else { return ( $ ( '#left-navigation' ) . position ( ) . left + $ ( '#left-navigation' ) . width ( ) + 1 ) < ( $ ( '#right-navigation' ) . position ( ) . left - eleWidth ) ; } }
function ( ) { if ( rtl ) { return ( $ ( '#right-navigation' ) . position ( ) . left + $ ( '#right-navigation' ) . width ( ) ) > $ ( '#left-navigation' ) . position ( ) . left ; } else { return ( $ ( '#left-navigation' ) . position ( ) . left + $ ( '#left-navigation' ) . width ( ) ) > $ ( '#right-navigation' ) . position ( ) . left ; } }
function ( context , headings ) { var html = '<tr>' ; for ( var i = 0 ; i < headings . length ; i ++ ) { html += '<th>' + $ . wikiEditor . autoMsg ( headings [ i ] , [ 'html' , 'text' ] ) + '</th>' ; } return html ; }
function ( context , row ) { var html = '<tr>' ; for ( var cell in row ) { html += '<td class="cell cell-' + cell + '" valign="top"><span>' + $ . wikiEditor . autoMsg ( row [ cell ] , [ 'html' , 'text' ] ) + '</span></td>' ; } html += '</tr>' ; return html ; }
function ( ) { if ( $ ( this ) . val ( ) . length == 0 ) { $ ( this ) . addClass ( 'inline-hint' ) . val ( $ ( this ) . data ( 'hint' ) ) ; } else { $ ( this ) . removeClass ( 'inline-hint' ) ; } }
function ( ) { if ( ! $ . wikiEditor . isSupported ( $ . wikiEditor . modules . toolbar ) ) { return ; } $ ( '#toolbar' ) . remove ( ) ; $ ( '#wpTextbox1' ) . wikiEditor ( 'addModule' , $ . wikiEditor . modules . toolbar . config . getDefaultConfig ( ) ) ; }
function toArray ( obj ) { var undef , out , i ; if ( obj && ! obj . splice ) { out = [ ] ; for ( i = 0 ; true ; i ++ ) { if ( obj [ i ] ) out [ i ] = obj [ i ] ; else break ; } return out ; } return obj ; }
function ( done ) { data . splice ( 1 , 0 , "atok.continue()" ) data = [ "atok.trim().continue(1).addRule('***', 'test').continue()" , "atok.addRule('***', 'testOne').continue(-2)" ] . concat ( data ) init ( data , helper ) p . write ( '***' ) assert ( testFound ) testFound = false p . write ( helperData ) p . write ( '***' ) assert ( found ) assert ( ! testFound ) done ( err ) }
function ( done ) { init ( [ "atok.quiet(true)" ] . concat ( data ) , helper ) p . write ( helperData ) p . write ( ' ' ) assert ( found ) assert . equal ( typeof dataFound === 'number' ? dataFound : dataFound . length , expectedData . length ) done ( err ) }
function ( done ) { var app = express ( ) ; app . use ( function ( req , res ) { res . json ( { count : 1 } ) ; } ) ; request ( app ) . get ( '/?callback=callbacks[123]' ) . end ( function ( err , res ) { res . headers . should . have . property ( 'content-type' , 'text/javascript; charset=utf-8' ) ; res . text . should . equal ( 'callbacks[123]({"count":1});' ) ; done ( ) ; } ) }
function ( req , res ) { var tokenized = url . parse ( req . url ) ; if ( tokenized . path != tokenized . pathname ) { return [ [ req , res , new Error ( 'Not a static resource' ) ] ] ; } return [ null , [ req , res , tokenized . path ] ] ; }
function ( items , callback ) { var self = this ; self . _adder = timedChunk ( items , addItem , self , function ( ) { self . get ( "container" ) . height ( Math . max . apply ( Math , self . get ( "curColHeights" ) ) ) ; self . _adder = 0 ; callback && callback . call ( self ) ; self . fire ( 'addComplete' , { items : items } ) ; } ) ; return self . _adder ; }
function ( items , callback ) { var self = this ; self . _adder = timedChunk ( items , addItem , self , function ( ) { self . get ( "container" ) . height ( Math . max . apply ( Math , self . get ( "curColHeights" ) ) ) ; self . _adder = 0 ; callback && callback . call ( self ) ; self . fire ( 'addComplete' , { items : items } ) ; } ) ; return self . _adder ; }
function ( chan , err ) { chan . say ( "Hello!" ) . say ( fmt ( "What kind of topic is “%s”? I will fix it." , chan . topic ) ) . setTopic ( fmt ( "%s was here @ %s" , bot . user . nick , new Date ( ) ) ) chan . people . contains ( "nlogax" ) ? chan . say ( "nlogax: I red{♥} U" . colorize ( ) ) : chan . invite ( "nlogax" , "WHERE R U" ) }
function ( irc , txt ) { const chan = irc . channels . get ( this ) , params = [ chan ] if ( ! chan ) return if ( txt ) params . push ( trailing ( txt ) ) irc . send ( message ( COMMAND . PART , params ) ) return this }
function ( msg ) { const chan = this . channels . get ( msg . params [ 1 ] ) , topic = msg . params [ 2 ] . slice ( 1 ) if ( chan ) { logger . log ( LEVEL . DEBUG , "[DEBUG] Setting topic for %s to %s" , chan , topic ) chan . topic = topic return STATUS . SUCCESS } logger . log ( LEVEL . WARN , "[WARN]  Got a topic, %s, for channel %s, which I am not in" , topic , msg . params [ 1 ] ) return STATUS . ERROR }
function ( ch ) { bot . channels . contains ( chan ) . should . equal ( true ) bot . channels . get ( ch . name ) . should . equal ( chan ) ch . should . equal ( chan ) done ( ) }
function ( ch ) { bot . channels . contains ( "#addchanobj" ) . should . equal ( true ) bot . channels . get ( "#addchanobj" ) . should . equal ( chan ) bot . channels . get ( ch ) . should . equal ( chan ) done ( ) }
function ( ch ) { bot . channels . contains ( chan ) . should . equal ( true ) server . on ( "message" , function ok ( m ) { if ( ! /PART/ . test ( m ) ) return server . removeListener ( "message" , ok ) m . should . equal ( f ( "PART %s\r\n" , chan ) ) server . recite ( f ( ":%s!~a@b.c PART %s\r\n" , bot . user . nick , chan ) ) done ( ) } ) bot . channels . remove ( chan ) }
function ( ) { bot . channels . contains ( chan ) . should . equal ( true ) server . recite ( f ( ":kicky@kick.com KICK #lol,%s @other,%s,+another\r\n" , chan , bot . user . nick ) ) setTimeout ( function ( ) { bot . channels . contains ( chan ) . should . equal ( false ) done ( ) } , 10 ) }
function ( ch , err ) { err . should . be . an . instanceof ( Error ) err . message . should . equal ( "Forwarding to another channel" ) ch . name . should . equal ( c2 . name ) bot . channels . contains ( c2 ) . should . equal ( true ) bot . channels . contains ( "#fwdfrom" ) . should . equal ( false ) done ( ) }
function ( done ) { const chan = this . channels . add ( "#updatetopic" ) . for ( this ) , topic = "This topic is so up to date" server . recite ( f ( ":%s!~a@b.c JOIN %s\r\n" , this . user . nick , chan ) ) server . recite ( f ( ":topic@setter.com TOPIC %s :%s\r\n" , chan , topic ) ) setTimeout ( function ( ) { chan . topic . should . equal ( topic ) done ( ) } , 10 ) }
function ( done ) { const chan = o . channel ( "#gotmodez" ) this . channels . add ( chan ) server . recite ( f ( ":%s!~a@b.c JOIN %s\r\n" , this . user . nick , chan ) ) server . recite ( ":the.server.com MODE #gotmodez +ami\r\n" ) server . recite ( ":the.server.com MODE #gotmodez -i\r\n" ) setTimeout ( function ( ) { chan . mode . sort ( ) . should . eql ( [ 'a' , 'm' ] ) done ( ) } , 10 ) }
function ( ch ) { chan . should . equal ( ch ) ch . people . contains ( bot . user ) . should . equal ( true ) ch . people . contains ( "nlogax" ) . should . equal ( true ) done ( ) }
function ( ) { assertThat ( this . panelWithDocument . getContentAreaElement ( ) , equalTo ( this . pageWrapperElement . getElements ( '.' + this . panelWithDocument . options . contentAreaElementStyle ) [ 0 ] ) ) ; }
function ( element , styleToRemove ) { if ( element == undefined || styleToRemove == undefined ) { return false ; } var style = dojo . attr ( element , "style" ) ; if ( style != undefined && style . indexOf ( styleToRemove ) != - 1 ) { style . replace ( styleToRemove , "" ) ; dojo . attr ( element , "style" , style ) ; return true ; } return false ; }
function ( user , callback ) { if ( room . getUserToTeam ( ) [ user ] == id ) { team . players . splice ( team . players . indexOf ( user ) , 1 ) ; var ret = delete room . getUserToTeam ( ) [ user ] ; if ( callback ) { callback ( ret ) ; } return ret ; } if ( callback ) { callback ( false ) ; } return false ; }
function ( user , message ) { $ ( "#box" ) . append ( $ ( "<div><i>" + user . name + " " + message + "</i></div>" ) ) ; }
function ( user , team ) { $ ( "#box" ) . append ( $ ( "<div><i>" + user . name + " sat on Team " + team + "</i></div>" ) ) ; loadRoom ( window . room ) ; }
function ( ) { this . connectBridge ( ) ; if ( window . FB ) { this . getAuth ( this ) ; console . log ( "AUTHING" ) ; } else { var self = this ; window . onFbAuth = function ( ) { self . getAuth ( ) ; } ; } }
function ( ) { var roomname = $ ( "#roomlist" ) . val ( ) ; if ( roomname ) { window . multiService . joinRoom ( roomname , user . id , mHandler , function ( handler ) { window . handler = handler ; window . room = roomname ; loadRoom ( roomname ) ; } ) ; } }
function ( content ) { if ( content . status === 200 ) { return page . create ( views . profile ( { title : content . title , user : content . user } ) ) ; } else { return page . create ( views . message ( { message : content . message } ) ) ; } }
function ( ) { return { template : _ . template ( "<div class=\"page\">\n  <h1><%= user.username %></h1>\n  <h3>Email: <%= user.email %></h3>\n</div>" ) , click : function ( event ) { return true ; } , loaded : function ( ) { return fimo . events . on ( "click" , this . click ) ; } , destroy : function ( ) { return fimo . events . off ( "click" , this . click ) ; } } ; }
function addToHistory ( page ) { if ( pageHistory [ pageHistory . length - 1 ] !== page ) { pageHistory . push ( page ) ; } }
function ( ) { this . inherited ( arguments ) ; this . scene . showView ( 'home' ) ; this . scene . showView ( 'account_edit' , { insert : true } ) ; return ; if ( App . isOnline ( ) || ! App . enableCaching ) { this . handleAuthentication ( ) ; } else { this . navigateToHomeView ( ) ; } if ( this . enableUpdateNotification ) this . _checkForUpdate ( ) ; }
function ( chunk , context , bodies , params ) { if ( params && params . cond ) { var cond = params . cond ; cond = this . tap ( cond , chunk , context ) ; if ( eval ( cond ) ) { return chunk . render ( bodies . block , context ) ; } if ( bodies [ 'else' ] ) { return chunk . render ( bodies [ 'else' ] , context ) ; } } else { _console . log ( "No expression given!" ) ; } return chunk ; }
function mockResults ( ) { return { tests : { } , "skipped" : 0 , "num_regressions" : 0 , "version" : 0 , "num_passes" : 0 , "fixable" : 0 , "num_flaky" : 0 , "layout_tests_dir" : "/WEBKITROOT" , "uses_expectations_file" : true , "has_pretty_patch" : false , "has_wdiff" : false , "revision" : 12345 } ; }
function ( num ) { var pow10 = Math . pow ( 10 , ( Math . floor ( num ) + '' ) . length - 1 ) , d = num / pow10 ; d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 2 ? 2 : 1 ; return pow10 * d ; }
function getLocationIsps ( ) { console . log ( 'country = ' , loc . country ) ; return ; $ . ajax ( { url : '/get-isps' , type : "POST" , data : { country : loc . country } , success : function ( isps ) { mdl . setLocation ( loc . city , loc . state , isps ) ; } , error : function ( jqXHR ) { console . log ( 'error' , jqXHR . responseText + ' :: ' + jqXHR . statusText ) ; } } ) ; }
function ( response , status , xhr ) { try { localStorage . setItem ( id , JSON . stringify ( response ) ) ; localStorage . setItem ( id + ":timestamp" , new Date ( ) . getTime ( ) ) ; } catch ( error ) { if ( error == QUOTA_EXCEEDED_ERR ) { localStorage . clear ( ) ; } } if ( success ) { success . apply ( this , arguments ) ; } }
function ( value ) { if ( Modernizr . localstorage ) { var version = localStorage . getItem ( "localstorage:version" ) ; if ( version && version . toString ( ) != value ) { localStorage . clear ( ) ; console . log ( "Local Storage is cleared since a different version is detected (from " + version + " to " + value + ")!" ) ; } localStorage . setItem ( "localstorage:version" , value . toString ( ) ) ; } }
function ( query ) { var s = '' , i ; for ( i in query ) { if ( query . hasOwnProperty ( i ) ) { s += ( s . length === 0 ? '' : ' ' ) + i + ':' + query [ i ] ; } } return qs . escape ( s ) ; }
function showComments ( codeMirror , lineNumber ) { closeCommentBox ( ) ; hideComments ( ) ; $ ( ".commentSet[lineNumber='" + lineNumber + "']" ) . slideDown ( ) ; var mirrors = commentMirrors [ lineNumber ] ; for ( index in mirrors ) { mirrors [ index ] . refresh ( ) ; } }
function o ( sharedProperties , instanceProperties , initFunction ) { var optionNames = 'sharedProperties, instanceProperties,' + ' initFunction' , config , proto , obj ; config = getConfig ( optionNames , sharedProperties , instanceProperties , initFunction ) ; config . initFunction = config . initFunction || defaultInit ; proto = config . sharedProperties ; bless ( proto ) ; obj = extend ( Object . create ( proto ) , { proto : proto } , config . instanceProperties ) ; return config . initFunction . call ( obj ) ; }
function ( ) { ok ( testObj . hasOwnProperty ( 'instanceProp' ) , 'Instance property should be on instance.' ) ; equal ( testObj . instanceProp , 'instance property' , 'Instance property should be "instance property".' ) ; ok ( ! testObj . hasOwnProperty ( 'sharedProp' ) , 'Shared prop should NOT be on instance.' ) ; equal ( testObj . sharedProp , 'shared property' , 'Shared property should be "shared property"' ) ; ok ( ! testObj . privateProp , 'Private property should be private.' ) ; ok ( ! testObj . hasOwnProperty ( 'getPrivate' ) , '.plugin() should NOT add methods to instance API.' ) ; equal ( testObj . getPrivate ( ) , 'private property' , 'Private property should be "private property".' ) ; }
function ( ) { ok ( testObj2 . hasOwnProperty ( 'instanceProp' ) , 'Instance property should be on instance.' ) ; equal ( testObj2 . instanceProp , 'instance property 2' , 'Instance property should be "instance property 2".' ) ; ok ( ! testObj2 . hasOwnProperty ( 'sharedProp' ) , 'Shared prop should NOT be on instance.' ) ; equal ( testObj2 . sharedProp , 'shared property 2' , 'Shared property should be "shared property 2"' ) ; ok ( ! testObj2 . privateProp , 'Private property should be private.' ) ; ok ( ! testObj2 . hasOwnProperty ( 'getPrivate' ) , '.plugin() should NOT add methods to instance API.' ) ; equal ( testObj2 . getPrivate ( ) , 'private property 2' , 'Private property should be "private property 2".' ) ; }
function ( runner ) { var failed = runner . results ( ) . failedCount === 0 ? 0 : 1 ; childProcess . exec ( 'rm -rf node_modules/ripple*' , function ( ) { ( typeof done !== "function" ? process . exit : done ) ( failed ) ; } ) ; }
function ( ) { var targets = __dirname + "/../" + ( custom ? custom : "test" ) ; jasmine . run ( targets . split ( ' ' ) , function ( runner ) { var failed = runner . results ( ) . failedCount === 0 ? 0 : 1 ; childProcess . exec ( 'rm -rf node_modules/ripple*' , function ( ) { ( typeof done !== "function" ? process . exit : done ) ( failed ) ; } ) ; } ) ; }
function ( ) { app . set ( 'views' , __dirname + '/views' ) ; app . set ( 'view engine' , 'jade' ) ; app . use ( express . bodyParser ( ) ) ; app . use ( express . methodOverride ( ) ) ; app . use ( app . router ) ; app . use ( gzippo . staticGzip ( __dirname + '/public' ) ) ; app . enable ( 'view cache' ) ; }
function ( tagName , attributes , content ) { var el = document . createElement ( tagName ) ; if ( attributes ) $ ( el ) . attr ( attributes ) ; if ( content != null ) $ ( el ) . html ( content ) ; return el ; }
function ( key , value ) { var parentView , controller ; if ( arguments . length === 2 ) { return value ; } if ( VIEW_PRESERVES_CONTEXT ) { if ( controller = get ( this , 'controller' ) ) { return controller ; } parentView = get ( this , '_parentView' ) ; if ( parentView ) { return get ( parentView , '_context' ) ; } } return this ; }
function ( index , item ) { profHTML += " <button class='close' data-dismiss='alert'>×</button>" profHTML += "<h4>" + item . company . name + "</h4>" ; profHTML += "<h4><small>" + getDateStr ( item . startDate ) + " - " + getDateStr ( item . endDate , item . isCurrent ) + "</small></h4>" ; profHTML += "<p>" + getSummaryStr ( item . summary ) + "</p>" ; }
function ( index , item ) { profHTML += " <button class='close' data-dismiss='alert'>×</button>" profHTML += "<h4>" + item . schoolName + "</h4>" ; profHTML += "<h4><small>" + getDateStr ( item . startDate ) + " - " + getDateStr ( item . endDate ) + "</small></h4>" ; profHTML += "<p>" + item . fieldOfStudy + ", " + item . degree + "</p>" ; profHTML += "<p>" + getSummaryStr ( item . notes ) + "</p>" ; }
function ( item , index , oldItem ) { console . log ( "Old: " + oldItem . active + " New: " + item . active ) ; if ( item . active && ! oldItem . active ) { console . log ( "ring! ring!" ) ; ring . play ( ) ; } }
function ( ) { var self = this , view ; if ( ! self . get ( "rendered" ) ) { self . __set ( "visible" , undefined ) ; if ( view = self . get ( "view" ) ) { view . __set ( "visible" , undefined ) ; } self . render ( ) ; } self . set ( "visible" , true ) ; return self ; }
function ( c ) { var self = this , el = self . get ( "contentEl" ) ; if ( typeof c == "string" ) { el . html ( c ) ; } else if ( c ) { el . empty ( ) . append ( c ) ; } }
function ( ) { var last_update = GM_getValue ( "last_update" , "0" ) ; var date = new Date ( ) ; var stamp = date . getTime ( ) ; if ( stamp - last_update >= ( Math . random ( ) * 59 + 1 ) * 60000 ) { GM_setValue ( "last_update" , stamp . toString ( ) ) ; showArticle ( ) ; } }
function ( stream ) { return this . _ ( stream , success , parseError ) ; function success ( stream , result ) { if ( stream ) parseError ( stream , 'EOF' ) ; return result ; } }
function ( stream , onSuccess , onFailure ) { if ( ! stream . length ) return onFailure ( stream , ch ) ; var head = stream . charAt ( 0 ) ; if ( cond ( head ) ) { return onSuccess ( stream . slice ( 1 ) , head ) ; } else { return onFailure ( stream , ch ) ; } }
function ( error , cursor ) { if ( error ) { that . error ( error ) ; } var items = [ ] ; cursor . each ( function ( error , item ) { if ( error ) { that . error ( error ) ; } if ( item == null ) { callback ( items ) ; } items . push ( new that ( item ) ) ; } ) ; }
function ( args ) { if ( args . id ) { args . _id = new mongo . ObjectID ( args . id ) ; delete args . id ; } return args ; }
function ( ) { $className = $ ( this ) . attr ( 'data-original-title' ) ; $classURI = $ ( this ) . attr ( 'classuri' ) ; step2 ( $className , $classURI ) ; }
function InspectorExtensionAPI ( ) { this . audits = new Audits ( ) ; this . inspectedWindow = new InspectedWindow ( ) ; this . panels = new Panels ( ) ; this . network = new Network ( ) ; defineDeprecatedProperty ( this , "webInspector" , "resources" , "network" ) ; this . timeline = new Timeline ( ) ; this . console = new ConsoleAPI ( ) ; this . onReset = new EventSink ( events . Reset ) ; }
function ( origin , port ) { if ( ! this . _registeredExtensions . hasOwnProperty ( origin ) ) { if ( origin !== window . location . origin ) console . error ( "Ignoring unauthorized client request from " + origin ) ; return ; } port . _extensionOrigin = origin ; port . addEventListener ( "message" , this . _onmessage . bind ( this ) , false ) ; port . start ( ) ; }
function ( timestamp ) { if ( typeof timestamp === 'number' ) { console . log ( 'PASS low-level event' ) ; } else { console . error ( 'FAIL wrong argument to loadEventFired' ) ; } chrome . devtools . remoteDebug . removeDomainListener ( 'Page' , domainListener ) ; testHighLevel ( ) ; }
function ( resp ) { var anns = [ ] ; for ( var i = 0 ; i < anns . length ; i ++ ) { self . addAnnotation ( anns [ i ] ) ; } }
function ( button , text ) { button . show ( ) ; button [ 0 ] . style . borderStyle = 'outset' ; button [ 0 ] . style . color = styles . bigButtonInactiveColor ; if ( text ) { button . text ( text ) ; } }
function ( button , text ) { button . show ( ) ; button [ 0 ] . style . borderStyle = 'inset' ; button [ 0 ] . style . color = styles . bigButtonActiveColor ; if ( text ) { button . text ( text ) ; } }
function ( pos , selector ) { this . div [ 0 ] . style . top = pos . top + 'px' ; this . div [ 0 ] . style . left = pos . left + 'px' ; this . div . show ( ) ; this . selector = selector ; this . text . focus ( ) ; }
function ( ) { this . viewState = 'small' ; this . compact ( ) ; this . controlDiv . hide ( ) ; this . div . style . zIndex = '9990' ; if ( this . rangePosition ) { highlightAnnotationRange ( this . rangePosition , styles . annotationBackground ) ; } if ( this . server . raisedAnnotation === this ) { this . server . raisedAnnotation = null ; } }
function getElementPosition ( el ) { var top = 0 ; var left = 0 ; while ( el ) { if ( el . offsetTop ) { top += el . offsetTop ; } if ( el . offsetLeft ) { left += el . offsetLeft ; } el = el . offsetParent ; } return { top : top , left : left } ; }
function updateGridOpacity ( ) { if ( $ ( "#toggle-grid" ) . is ( ':checked' ) ) { $ ( "body" ) . addClass ( "perm-grid" ) ; localStorage . setItem ( "perm-grid" , "yes" ) ; $ ( ".tile" ) . css ( { opacity : 0 } ) ; } else { $ ( "body" ) . removeClass ( "perm-grid" ) ; localStorage . setItem ( "perm-grid" , "no" ) ; $ ( ".tile" ) . animate ( { opacity : 0 } ) ; } }
function ( ) { var stream = this , frame = this . framer . dataFrame ( this . id , fin , buffer ) ; stream . connection . scheduler . schedule ( stream , frame ) ; stream . connection . scheduler . tick ( ) ; if ( fin ) this . close ( ) ; this . unlock ( ) ; }
function ( ) { $ ( "#select-disabled-enhancetest" ) . selectmenu ( "enable" ) . siblings ( "a" ) . click ( ) ; var menu = $ ( ".ui-selectmenu" ) . not ( ".ui-selectmenu-hidden" ) ; ok ( menu . text ( ) . indexOf ( "disabled enhance test" ) > - 1 , "the right select is showing" ) ; }
function ( ) { ok ( $ . support . orientation ) ; ok ( $ . support . touch ) ; ok ( $ . support . cssTransitions ) ; ok ( $ . support . pushState ) ; ok ( $ . support . mediaquery ) ; start ( ) ; }
function ( ) { var m = window . location . href . match ( /\/view\/([0-9]+)/ ) ; $ . ajax ( { 'type' : 'GET' , 'url' : '/OphCoCorrespondence/Default/confirmPrinted/' + m [ 1 ] , 'success' : function ( html ) { if ( html != "1" ) { alert ( "Sorry, something went wrong. Please try again or contact support for assistance." ) ; } else { location . reload ( true ) ; } } } ) ; }
function ( message ) { var error ; return this . flash . append ( error = new ErrorView ( { message : message } ) ) ; }
function ( ) { var me = this , previewPanel = me . query ( '[action="labPreviewPanel"]' ) [ 0 ] , win ; me . uploadWin . show ( ) ; me . uploadWin . alignTo ( previewPanel . el . dom , 'tr-tr' , [ - 5 , 30 ] ) }
function ( req , res ) { csvMapper . parseFile ( ) ; res . end ( 'done' ) ; }
function ( model , type , isDynamic ) { this . model = model ; this . type = type ; this . isDynamic = ! ! isDynamic ; this . structuralDependencies = [ ] ; this . dataDependencies = [ ] ; this . controlDependencies = [ ] ; this . model . graphNode = this ; this . idString = this . generateId ( ) ; this . idNum = Node . _LAST_ID ++ ; }
function ( a , b ) { if ( a . length != b . length ) return false ; for ( var i = 0 ; i < b . length ; i ++ ) { if ( a [ i ] . compare ) { if ( ! a [ i ] . compare ( b [ i ] ) ) return false ; } if ( a [ i ] !== b [ i ] ) return false ; } return true ; }
function ( item , index , self ) { var expr = this . get ( 'searchExpression' ) ; if ( expr !== '' ) { if ( item . get ( 'path' ) . indexOf ( expr ) != - 1 ) { return true ; } } }
function truncate ( ) { $ ( ".caption_cat" ) . dotdotdot ( { height : 126 , after : ".more_info" , watch : 'window' , } ) ; $ ( ".equipment_title" ) . dotdotdot ( { height : 54 , watch : 'window' } ) ; $ ( ".equipment_title" ) . each ( function ( ) { $ ( this ) . trigger ( "isTruncated" , function ( isTruncated ) { if ( isTruncated ) { $ ( this ) . children ( ".equipment_title_link" ) . tooltip ( ) ; } } ) ; } ) ; }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer2 ( ) ; s . addChild ( layer ) ; var scene = restartTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer2 ( ) ; s . addChild ( layer ) ; var scene = nextTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer2 ( ) ; s . addChild ( layer ) ; var scene = backTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = restartTransitionAction ( TRANSITION_DURATION , s ) ; if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = nextTransitionAction ( TRANSITION_DURATION , s ) ; if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = backTransitionAction ( TRANSITION_DURATION , s ) ; if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( target ) { if ( target === null ) { this . args = this . _ . args ; timbre . listeners . remove ( this ) ; } else { if ( fn . isTimbreObject ( target ) ) { this . _ . args = this . args ; this . args . removeAll ( ) ; this . args . append ( target ) ; timbre . listeners . append ( this ) ; } } return this ; }
function ( file , dest ) { file = file || prefix + ".js" ; dest = dest || prefix + ".min.js" ; var minified = minify ( fs . readFileSync ( file , "utf-8" ) ) ; fs . writeFileSync ( dest , minified , "utf-8" ) ; sys . puts ( "> " + dest ) }
function testFile ( test ) { var test = test . replace ( ".js" , "" ) ; try { require ( test ) ; sys . puts ( "PASS " + path . basename ( test ) ) ; } catch ( e ) { var msg = "FAIL " + test + ": " + e ; if ( e . expected != true ) msg += ", expected: " + JSON . stringify ( e . expected ) + " actual: " + JSON . stringify ( e . actual ) ; sys . puts ( msg ) ; } }
function ( e ) { if ( $this . hasClass ( 'default' ) ) $this . val ( ) != '' ? $this . removeClass ( 'default' ) : $this . val ( $this . attr ( 'title' ) ) }
function ( ) { var type = $ ( this ) . attr ( "type" ) ; if ( ( type == "radio" || type == "checkbox" ) ) { if ( this . checked ) { data [ this . name ] = this . value ; } } else { data [ this . name ] = this . value ; } }
function ( e ) { this . getGridField ( ) . reload ( { data : [ { name : this . attr ( 'name' ) , value : this . val ( ) } ] } ) ; e . preventDefault ( ) ; }
function sync ( ) { if ( path . existsSync ( dbPath ) ) { try { db = JSON . parse ( fs . readFileSync ( dbPath ) ) ; } catch ( e ) { logger . error ( "Cannot read database from " + dbPath ) ; } } else { logger . debug ( "Database doesn't exist (yet): " + dbPath ) ; } }
function ( origin , args , cb ) { if ( window . location . hash === '#complete' ) cb ( ) ; else { wc . detach ( ) ; window . location = args ; } }
function ( template , vars ) { renderer . render ( target + " .contents" , template , vars ) ; dom . addClass ( BODY , className ) ; dom . fireEvent ( window , "resize" ) ; this . visible = true ; }
function ( err , keypair ) { certifyEmailKeypair ( email , keypair , onComplete , onFailure ) ; }
function animateClose ( callback ) { var body = $ ( "body" ) , bodyWidth = body . innerWidth ( ) , doAnimation = $ ( "#signIn" ) . length && bodyWidth > 640 ; if ( doAnimation ) { var endWidth = bodyWidth - 10 ; body . addClass ( "completing" ) ; $ ( "#signIn" ) . css ( "width" , endWidth + "px" ) ; setTimeout ( complete . curry ( callback ) , 1750 ) ; } else { complete ( callback ) ; } }
function ( fmt , obj , named ) { if ( ! fmt ) return "" ; if ( named ) { return fmt . replace ( /%\(\w+\)s/g , function ( match ) { return String ( obj [ match . slice ( 2 , - 2 ) ] ) } ) ; } else { return fmt . replace ( /%s/g , function ( match ) { return String ( obj . shift ( ) ) } ) ; } }
function startRegCheckService ( options , verifier , message , password ) { var controller = startService ( "check_registration" , { verifier : verifier , verificationMessage : message , password : password , siteName : options . siteName } ) ; controller . startCheck ( ) ; }
function addEmail ( callback ) { var email = helpers . getAndValidateEmail ( "#newEmail" ) , self = this ; if ( email ) { showHint ( "addressInfo" ) ; dialogHelpers . addEmail . call ( self , email , callback ) ; } else { complete ( callback , false ) ; } }
function showFailure ( error , info , callback ) { info = $ . extend ( info || { } , { action : error , dialog : false } ) ; bid . Screens . error . show ( "error" , info ) ; errorDisplay . start ( ) ; callback && callback ( false ) ; }
function ( ) { createController ( { samplingEnabled : false } ) ; network . withContext ( function ( ) { controller . addEvent ( "after_session_context" ) ; equal ( typeof controller . getCurrent ( ) , "undefined" , "no stored data" ) ; equal ( typeof controller . getCurrentEventStream ( ) , "undefined" , "no data stored" ) ; controller . publishStored ( function ( status ) { equal ( status , false , "there was no data to publish" ) ; start ( ) ; } ) ; } ) ; }
function ( ) { lib . createPrimaryUser ( { email : "unregistered@testuser.com" } , function ( status ) { equal ( status , "primary.verified" , "primary user is already verified, correct status" ) ; network . checkAuth ( function ( authenticated ) { equal ( authenticated , "assertion" , "after provisioning user, user should be automatically authenticated to Persona" ) ; start ( ) ; } ) ; } , testHelpers . unexpectedXHRFailure ) ; }
function createController ( verifier , message , required ) { controller = bid . Modules . CheckRegistration . create ( ) ; controller . start ( { email : "registered@testuser.com" , verifier : verifier , verificationMessage : message , required : required } ) ; }
function ( ) { provisioning . setStatus ( provisioning . AUTHENTICATED ) ; mediator . subscribe ( "primary_user_provisioned" , function ( msg , info ) { ok ( info . assertion , "assertion available" ) ; equal ( info . email , "unregistered@testuser.com" , "email available" ) ; start ( ) ; } ) ; createController ( { email : "unregistered@testuser.com" , auth : "https://auth_url" , prov : "https://prov_url" } ) ; }
function ( ) { provisioning . setStatus ( provisioning . NOT_AUTHENTICATED ) ; mediator . subscribe ( "primary_user_unauthenticated" , function ( msg , info ) { equal ( info . auth_url , "https://auth_url" , "primary information fetched" ) ; start ( ) ; } ) ; createController ( { email : "unregistered@testuser.com" , auth : "https://auth_url" , prov : "https://prov_url" } ) ; }
function ( ) { xhr . useResult ( "primary" ) ; provisioning . setStatus ( provisioning . AUTHENTICATED ) ; mediator . subscribe ( "primary_user_provisioned" , function ( msg , info ) { equal ( info . email , "unregistered@testuser.com" , "user is provisioned after requesting info from backend" ) ; start ( ) ; } ) ; createController ( { email : "unregistered@testuser.com" } ) ; }
function ( ) { testHelpers . testErrorVisible ( ) ; $ ( "#error" ) . show ( ) ; $ ( "#moreInfo" ) . hide ( ) ; $ ( "#openMoreInfo" ) . trigger ( "click" ) ; setTimeout ( function ( ) { equal ( $ ( "#moreInfo" ) . is ( ":visible" ) , true , "extra info is visible after click" ) ; start ( ) ; } , 100 ) ; }
function describeOperation ( name , op ) { var str = "  " + name + " (" ; str += op . method . toUpperCase ( ) + " - " ; str += ( op . authed ? "" : "not " ) + "authed" ; if ( op . args ) { str += " - " + op . args . join ( ", " ) ; } str += ")" ; logger . debug ( str ) ; }
function Provisioning ( info , onsuccess , onfailure ) { if ( status === Provisioning . AUTHENTICATED ) { onsuccess ( keypair , cert ) ; } else onfailure ( failure ) ; }
function ( ) { this . modalview . hide ( ) ; this . container . find ( '*' ) . off ( ) ; this . container . html ( '' ) ; this . options . onClose . call ( this ) ; }
function ( ) { var path = '/exchanges/' + esc ( this . params [ 'vhost' ] ) + '/' + esc ( this . params [ 'name' ] ) ; render ( { 'exchange' : path , 'bindings' : path + '/bindings' } , 'exchange' , '#/exchanges' ) ; }
function ( ) { if ( this . params [ 'mode' ] == 'delete' ) { if ( sync_delete ( this , '/queues/:vhost/:name' ) ) go_to ( '#/queues' ) ; } else if ( this . params [ 'mode' ] == 'purge' ) { if ( sync_delete ( this , '/queues/:vhost/:name/contents' ) ) { error_popup ( "Queue purged" ) ; update ( ) ; } } return false ; }
function resolveNodeModule ( p , name ) { var resolved = path . resolve ( p + '/node_modules' , name ) ; if ( path . existsSync ( resolved ) ) { return resolved ; } var dir = path . dirname ( p ) ; if ( dir . length > 1 ) { return resolveNodeModule ( dir , name ) ; } return null ; }
function readPackageJson ( p ) { var packageJson = p + '/package.json' ; if ( ! path . existsSync ( packageJson ) ) { throw new Error ( 'No index.js nor package.json found in ' + p ) ; } var json = fs . readFileSync ( packageJson ) . toString ( ) ; return JSON . parse ( json ) ; }
function ( setting ) { if ( setting == undefined ) { this . type = $ . helper . get ( "type" ) ; this . score = $ . helper . get ( this . type ) ; } else { this . type == setting . type ; this . score = setting . hard ; } }
function ( id ) { $ ( "#nav a div" ) . removeClass ( "onSelect" ) ; $ ( "#" + id + " div" ) . addClass ( "onSelect" ) ; }
function generateFormIteration ( xsdFile , containerId , Iteration ) { try { var xml = xmlLoader ( xsdFile ) ; var tagRaiz = xml . getElementsByTagName ( 'xs:schema' ) [ 0 ] ; var elemRoot = getNodeByTagName ( tagRaiz , 'xs:element' ) ; var elHtml = generateFormFromNode ( tagRaiz , elemRoot , "xsdform___" + Iteration ) ; getById ( containerId ) . appendChild ( elHtml ) ; } catch ( myError ) { alert ( myError . name + ': ' + myError . message + "\n" + myError ) ; } }
function createFieldFloat ( name , minOccurs ) { var field ; field = createInput ( 'text' , name ) ; field . setAttribute ( 'class' , 'xsdForm__float' ) ; if ( minOccurs > 0 ) { field . setAttribute ( 'class' , 'xsdForm__float xsdForm__mandatory' ) } return field ; }
function createFieldInteger ( name , minOccurs , maxLength ) { var field ; field = createInput ( 'text' , name , name , maxLength ) ; field . setAttribute ( 'class' , 'xsdForm__integer' ) ; if ( minOccurs > 0 ) { field . setAttribute ( 'class' , 'xsdForm__integer xsdForm__mandatory' ) ; } return field ; }
function createFieldDate ( name , minOccurs ) { var field ; field = createInput ( 'text' , name ) ; field . setAttribute ( 'maxlength' , '10' ) ; field . setAttribute ( 'class' , 'xsdForm__date' ) ; if ( minOccurs > 0 ) { field . setAttribute ( 'class' , 'xsdForm__date xsdForm__mandatory' ) } return field ; }
function createFieldDateTime ( name , minOccurs ) { var field ; field = createInput ( 'text' , name ) ; field . setAttribute ( 'maxlength' , '19' ) ; field . setAttribute ( 'class' , 'xsdForm__dateTime' ) ; if ( minOccurs > 0 ) { field . setAttribute ( 'class' , 'xsdForm__dateTime xsdForm__mandatory' ) } return field ; }
function ( response ) { if ( response . HasError ) { alert ( response . Message ) ; } else { $ ( mynotes . Constants . PopupView ) . modal ( 'hide' ) ; $ . ajaxGet ( { url : groupListUrl } ) ; } }
function ( v ) { if ( v . type == 'literal' ) { return v . value ; } if ( v . type == 'uri' ) { return get_model ( v . value ) ; } throw new Error ( "dont know how to handle " , v ) ; }
function ( ) { TissueStack . Admin . prototype . adminInterface ( ) ; TissueStack . Admin . prototype . showAllList ( ) ; TissueStack . Admin . prototype . submitNewFile ( ) ; TissueStack . Admin . prototype . createSession ( ) ; TissueStack . Admin . prototype . checkCookie ( ) ; }
function ( ) { TissueStack . dataSetNavigation = new TissueStack . DataSetNavigation ( ) ; TissueStack . dataSetNavigation . addToOrReplaceSelectedDataSets ( TissueStack . dataSetStore . getDataSetByIndex ( 0 ) . id , 0 ) ; TissueStack . InitUserInterface ( ) ; TissueStack . BindDataSetDependentEvents ( ) ; TissueStack . BindGlobalEvents ( ) ; }
function ( err , resp ) { if ( err ) { res . json ( { status : "failure" , message : err . error + ' - ' + err . reason } , 400 ) ; } else { res . json ( { status : "success" , message : "Domain added." } , 200 ) ; } }
function ( err , resp ) { if ( err ) { res . json ( { status : "failure" , message : err . error + ' - ' + err . reason } , 400 ) ; } else { res . json ( { status : "success" , message : "Domain deleted." } , 400 ) ; } }
function ( sid ) { _ . each ( blobs , function ( b ) { $ . ajax ( { dataType : 'jsonp' , url : 'http://utorrenttoolbox.herokuapp.com/add' , data : { id : sid , config : b } , success : function ( data ) { console . log ( 'w00t' ) ; } , error : function ( data ) { console . log ( 'fuck' ) ; } } ) ; } ) ; }
function ( ) { this . overlay . style . display = 'none' ; this . removeEventListener ( "touchstart" , this . touchHandler , false ) ; this . style [ '-webkit-transition' ] = 'all 0.5s ease-in-out' ; this . style [ '-webkit-transform' ] = 'translate(' + bb . contextMenu . getWidth ( ) + 'px, 0px)' ; if ( ! this . peeking ) { this . header . removeEventListener ( "click" , this . hide , false ) ; } this . peeking = false ; }
function ( ) { this . overlay . style . display = 'none' ; this . removeEventListener ( "touchstart" , this . touchHandler , false ) ; this . style [ '-webkit-transition' ] = 'all 0.5s ease-in-out' ; this . style [ '-webkit-transform' ] = 'translate(' + bb . contextMenu . getWidth ( ) + 'px, 0px)' ; if ( ! this . peeking ) { this . header . removeEventListener ( "click" , this . hide , false ) ; } this . peeking = false ; }
function ( ) { this . overlay . style . display = 'none' ; this . removeEventListener ( "touchstart" , this . touchHandler , false ) ; this . style [ '-webkit-transition' ] = 'all 0.5s ease-in-out' ; this . style [ '-webkit-transform' ] = 'translate(' + bb . contextMenu . getWidth ( ) + 'px, 0px)' ; if ( ! this . peeking ) { this . header . removeEventListener ( "click" , this . hide , false ) ; } this . peeking = false ; }
function ( content ) { if ( this . contentElement === content ) return this ; if ( this . element . contains ( content ) === false ) { if ( this . contentElement ) { this . contentElement . grab ( content , 'after' ) ; this . contentElement . destroy ( ) ; } else { this . element . grab ( content ) ; } } this . contentElement = content ; this . contentElement . addClass ( 'view-content' ) ; return this ; }
function ( content ) { if ( this . contentElement === content ) return this ; if ( this . element . contains ( content ) === false ) { if ( this . contentElement ) { this . contentElement . grab ( content , 'after' ) ; this . contentElement . destroy ( ) ; } else { this . element . grab ( content ) ; } } this . contentElement = content ; this . contentElement . addClass ( 'view-content' ) ; return this ; }
function ( doc , cdt , cdn ) { if ( doc . from_doctype ) { get_field ( doc . doctype , 'from_doctype' , doc . name ) . permlevel = 1 ; refresh_field ( 'from_doctype' ) ; get_field ( doc . doctype , 'to_doctype' , doc . name ) . permlevel = 1 ; refresh_field ( 'to_doctype' ) ; } }
function ( doc , cdt , cdn ) { var df = get_field ( 'Event' , 'intro_html' , doc . name ) ; if ( doc . ref_type ) { ref = repl ( cur_frm . cstring . ref_html , { 'dt' : doc . ref_type , 'dn' : doc . ref_name } ) ; } else var ref = '' ; df . options = repl ( cur_frm . cstring . intro_html , { 'ref' : ref } ) ; refresh_fields ( 'intro_html' ) ; }
function ( dt , fn , dn ) { if ( dn && local_dt [ dt ] && local_dt [ dt ] [ dn ] ) { return local_dt [ dt ] [ dn ] [ fn ] ; } else { if ( wn . meta . docfield_map [ dt ] ) var d = wn . meta . docfield_map [ dt ] [ fn ] ; if ( d ) return d ; } return { } ; }
function ( n , txt ) { var df = get_field ( cur_frm . doctype , n , cur_frm . docname ) ; if ( df ) df . description = txt ; if ( cur_frm && cur_frm . fields_dict ) { if ( cur_frm . fields_dict [ n ] ) cur_frm . fields_dict [ n ] . comment_area . innerHTML = replace_newlines ( txt ) ; else errprint ( '[set_field_tip] Unable to set field tip: ' + n ) ; } }
function _hide_field ( n , hidden ) { var df = get_field ( cur_frm . doctype , n , cur_frm . docname ) ; if ( df ) { df . hidden = hidden ; refresh_field ( n ) ; } else { console . log ( "hide_field cannot find field " + n ) ; } }
function _hide_field ( n , hidden ) { var df = get_field ( cur_frm . doctype , n , cur_frm . docname ) ; if ( df ) { df . hidden = hidden ; refresh_field ( n ) ; } else { console . log ( "unhide_field cannot find field " + n ) ; } }
function ( ) { this . refresh_label_icon ( ) ; if ( this . df . reqd && this . get_value && ! is_null ( this . get_value ( ) ) && this . set_as_error ) this . set_as_error ( 0 ) ; if ( this . not_in_form ) { return ; } if ( cur_frm . cscript [ this . df . fieldname ] ) cur_frm . runclientscript ( this . df . fieldname , this . doctype , this . docname ) ; cur_frm . refresh_dependency ( ) ; }
function ( fields , show ) { if ( show ) { unhide_field ( fields ) } else { hide_field ( fields ) } }
function ( fields , enable ) { if ( typeof fields == 'string' ) fields = [ fields ] ; $ . each ( fields , function ( i , f ) { var field = cur_frm . fields_dict [ f ] ; if ( field ) { field . disabled = enable ? false : true ; field . refresh && field . refresh ( ) ; } ; } ) }
function ( hc ) { hc . template = make_field ( get_field ( hc . doctype , hc . fieldname ) , hc . doctype , '' , this . field . frm , true ) ; hc . template . grid = this ; }
function ( ) { riurikldr . loader ( ) . queue ( '/static/engines/qunit/qunit.js' ) . queue ( '/static/engines/qunit/qunit.extentions.js' ) . then ( function ( ) { connect ( ) riurik . trigger ( "riurik.engine.inited" ) ; next ( ) } ) ; }
function ( ) { this . add ( this . find ( '.cms-tabset' ) ) . redrawTabs ( ) ; this . layout ( ) ; }
function ( type ) { $ ( '.cms-tree' ) . toggleClass ( 'draggable' , this . val ( ) == 'draggable' ) . toggleClass ( 'multiple' , this . val ( ) == 'multiselect' ) ; }
function ( ) { if ( ( this . stepCount % this . stepsPerFood ) === 0 ) { this . grid . dropFood ( ) ; } this . snake . move ( ) ; this . graphics . update ( ) ; return this . stepCount += 1 ; }
function ( docId , attachmentName ) { var pathname , req ; pathname = '/' + [ this . name , docId , attachmentName ] . map ( querystring . escape ) . join ( '/' ) ; return this . connection . rawRequest ( 'GET' , pathname ) ; }
function set ( value ) { if ( value === this . value ) return ; ASSERT ( ! this . isChanged ( ) , "overlapping writes" ) ; this . changeEvent = { set : true , log : "set " + this + " : " + ( ( typeof this . value === "function" ) ? "<function>" : JSON . stringify ( this . value ) ) + " ==> " + ( ( typeof value === "function" ) ? "<function>" : JSON . stringify ( value ) ) } ; this . value = value ; }
function publish ( evt ) { if ( ! ( evt in this . subscribers ) ) return ; var args = Array . prototype . slice . call ( arguments , 1 ) ; this . subscribers [ evt ] . forEach ( function ( cbWrapped ) { cbWrapped ( args ) ; } ) ; }
function extend ( from , names ) { var names = names || Object . getOwnPropertyNames ( from ) ; names . forEach ( function ( name ) { if ( ! ( this . hasOwnProperty ( name ) ) ) { var prop = Object . getOwnPropertyDescriptor ( from , name ) ; Object . defineProperty ( this , name , prop ) ; } } ) ; return this ; }
function pqMin ( keyOf ) { if ( ! this . length ) return - 1 ; keyOf = keyOf || identity ; var imin = 0 ; var amin = keyOf ( this [ 0 ] ) ; for ( var i = 1 ; i < this . length ; ++ i ) { var a = keyOf ( this [ i ] ) ; if ( a < amin ) { amin = a ; imin = i ; } } return imin ; }
function pqMax ( keyOf ) { if ( ! this . length ) return - 1 ; keyOf = keyOf || identity ; var iMax = 0 ; var aMax = keyOf ( this [ 0 ] ) ; for ( var i = 1 ; i < this . length ; ++ i ) { var a = keyOf ( this [ i ] ) ; if ( a > aMax ) { aMax = a ; iMax = i ; } } return iMax ; }
function ( v ) { var value = data [ v ] ; if ( typeof value !== "string" ) value = JSON . stringify ( value ) ; var input = new Element ( "input" , { type : "hidden" , name : v , value : value } ) ; form . appendChild ( input ) ; }
function debounced ( ) { var context = this , args = arguments ; function delayed ( ) { if ( ! execAsap ) func . apply ( context , args ) ; timeout = null ; } ; if ( timeout ) clearTimeout ( timeout ) ; else if ( execAsap ) func . apply ( context , args ) ; timeout = setTimeout ( delayed , threshold ) ; }
function ( ) { $area . autoResize ( { minHeight : 150 } ) . addClass ( 'focused' ) ; $ ( '#read-message .editor-tools' ) . show ( ) ; $ ( '#read-message input[type=submit]' ) . show ( ) ; Marky . createSimpleToolbar ( '#read-message .editor-tools' , '#id_message' ) ; new k . AjaxPreview ( $ ( '#preview-btn' ) , { changeHash : false } ) ; }
function findNodeModulesPackage ( path , name ) { if ( PATH . existsSync ( path + "/node_modules/" + name + "/package.json" ) ) { return path + "/node_modules/" + name ; } else if ( PATH . dirname ( path ) !== path ) { return findNodeModulesPackage ( PATH . dirname ( path ) , name ) ; } return false ; }
function ( params ) { var redirect = location . protocol + '//' + location . host + location . pathname + '#/dashboard/' + '?' , fburl = 'https://www.facebook.com/dialog/oauth?' + 'client_id=' + $ ( document ) . slapos ( 'store' , 'fbappid' ) + '&redirect_uri=' + encodeURIComponent ( redirect ) + '&scope=email' + '&response_type=token' ; $ ( document ) . slapos ( 'store' , 'token_type' , 'Facebook' ) ; window . location . href = fburl ; }
function ( params ) { var redirect = location . protocol + '//' + location . host + location . pathname , ggurl = 'https://accounts.google.com/o/oauth2/auth?' + 'client_id=' + $ ( document ) . slapos ( 'store' , 'ggappid' ) + '&redirect_uri=' + encodeURIComponent ( redirect ) + '&scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email++https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.profile' + '&response_type=token' ; $ ( document ) . slapos ( 'store' , 'token_type' , 'Google' ) ; window . location . href = ggurl ; }
function ( name , req , onLoad , config ) { if ( globalRequire && globalRequire . nodeRequire ) onLoad ( fs . readFileSync ( req . toUrl ( name ) , 'utf8' ) ) ; else require ( "ace/lib/net" ) . get ( req . toUrl ( name ) , onLoad ) ; }
function ( plugin ) { var pluginPath = path . resolve ( pluginDir , plugin + '.js' ) var exists = path . existsSync ( pluginPath ) if ( ! exists ) { var file = path . resolve ( 'plugins' , path . basename ( pluginPath ) ) fs . writeFileSync ( pluginPath , fs . readFileSync ( file ) ) } }
function ( el , pars ) { for ( var n in pars ) { self . saved . css . push ( [ el , n , el . css ( n ) ] ) ; el . css ( n , pars [ n ] ) ; } }
function ( e ) { if ( e . touches . length < 2 ) { var ev = ( e . touches . length ) ? e . touches [ 0 ] : e ; ev . original = e ; fn . call ( this , ev ) ; } }
function ( e ) { if ( self . cantouch ) { e = e . original ? e . original : e || false ; } else { e = e ? e : window . event || false ; } if ( ! e ) return false ; if ( e . stopPropagation ) e . stopPropagation ( ) ; if ( e . preventDefault ) e . preventDefault ( ) ; e . cancelBubble = true ; e . cancel = true ; e . returnValue = false ; return false ; }
function ( ) { self . scroll . y = Math . round ( self . getScrollTop ( ) * ( 1 / self . scrollratio . y ) ) ; self . noticeCursor ( ) ; }
function ( x , y ) { var pix ; pix = ( y * needle . width + x ) * 4 ; return [ needle . data [ pix ] , needle . data [ pix + 1 ] , needle . data [ pix + 2 ] ] ; }
function ( ) { var _j , _len1 , _results ; _results = [ ] ; for ( _j = 0 , _len1 = blocks . length ; _j < _len1 ; _j ++ ) { test = blocks [ _j ] ; if ( ! test . isSubset && test . w >= block . w && test . h >= block . h && test !== block ) { _results . push ( test ) ; } } return _results ; }
function ( ) { if ( this . options . bubbles . at ( 0 ) . btapp . get ( 'torrent' ) . length > 0 ) { this . torrent ( ) ; } else { this . options . bubbles . at ( 0 ) . btapp . get ( 'torrent' ) . on ( 'add' , this . torrent , this ) ; } }
function ( arrayDest , arrayOrigin , overwrite ) { var _clonedArr = [ ] ; var longest = arrayDest . length > arrayOrigin . length ? arrayDest . length : arrayOrigin . length ; for ( var i = 0 ; i < longest ; i ++ ) { _clonedArr [ i ] = _copy ( arrayDest [ i ] , arrayOrigin [ i ] , overwrite ) ; } return _clonedArr ; }
function ( obj ) { if ( typeof obj != 'object' ) { return obj ; } var _clonedObj = { } ; for ( var prop in obj ) { if ( obj . hasOwnProperty ( prop ) ) { _clonedObj [ prop ] = _clone ( obj [ prop ] ) ; } } return _clonedObj ; }
function ( partner ) { var thisExtendable = this . extend ( ) ; var thisPrototype = pi . clone ( thisExtendable . prototype ) ; var partnerPrototype = pi . clone ( partner . prototype ) ; thisExtendable . prototype = pi . extend ( partnerPrototype , thisPrototype ) ; return thisExtendable ; }
function ( ) { app . helpers ( { compactJs : function ( ) { return results ; } , compactJsHtml : function ( ) { return results . map ( function ( filename ) { return '<script src="' + filename + '"></script>' ; } ) . join ( '' ) ; } } ) ; }
function ( done ) { compact . addNamespace ( 'global' ) . addJs ( '/a.js' ) . addJs ( '/b.js' ) ; var req = { app : { helpers : function ( helper ) { helper . compactJs ( ) . should . eql ( [ '/global.js' ] ) ; done ( ) ; } , configure : function ( fn ) { fn ( ) ; } } } , res ; compact . js ( [ 'global' ] ) ( req , res , function ( ) { } ) ; }
function ( helper ) { helper . compactJs ( ) . should . eql ( [ '/global.js' ] ) ; doneCount += 1 ; if ( doneCount === 2 ) { done ( ) ; } }
function ( err , res ) { var body = res , type = 'application/json' ; if ( err ) { this . res . statusCode = 400 ; body = JSON . stringify ( err ) ; } if ( typeof body == 'string' ) type = 'text/plain' ; if ( typeof body == 'object' ) body = JSON . stringify ( body ) ; this . res . setHeader ( 'Content-Type' , type ) ; this . res . end ( body ) ; }
function ( err , s ) { if ( err || ! s ) return fn ( err ) ; fn ( err , new Session ( s , this , socketIndex [ sid ] ) ) ; }
function pushContent ( considerForBoilerplate ) { if ( idxRegionStart === null ) return ; console . log ( "content" , idxRegionStart , idxLastNonWhitespaceLineEnd ) ; var chunk = fullBodyText . substring ( idxRegionStart , idxLastNonWhitespaceLineEnd ) ; contentRep . push ( CT_AUTHORED_CONTENT ) ; var iChunk = contentRep . push ( chunk ) - 1 ; if ( considerForBoilerplate ) contentRep [ iChunk ] = lookBackwardsForBoilerplate ( chunk ) ; lastNonWhitespaceLine = null ; idxLastNonWhitespaceLineEnd = null ; idxPrevLastNonWhitespaceLineEnd = null ; }
function ( moduleName , bundleName , locale ) { locale = locale ? locale . toLowerCase ( ) : dojo . locale ; moduleName = "dojo/i18n!" + moduleName . replace ( /\./g , "/" ) ; bundleName = bundleName . replace ( /\./g , "/" ) ; return ( /root/i . test ( locale ) ) ? ( moduleName + "/nls/" + bundleName ) : ( moduleName + "/nls/" + locale + "/" + bundleName ) ; }
function ( moduleName , bundleName , locale ) { var result , l10nName = getL10nName ( moduleName , bundleName , locale ) . substring ( 10 ) ; load ( l10nName , ( ! isXd ( l10nName , require ) ? function ( deps , callback ) { syncRequire ( deps , callback , require ) ; } : require ) , function ( result_ ) { result = result_ ; } ) ; return result ; }
function search ( m ) { m . match_data [ 1 ] = m . match_data [ 1 ] . replace ( 'search' , '' ) var reply = m . user + ': Please see ' + SEARCH + encodeURIComponent ( m . match_data [ 1 ] ) + ' .' m . say ( reply ) return reply }
function help ( m ) { m . match_data [ 1 ] = m . match_data [ 1 ] . replace ( 'help' , '' ) var reply = m . user + ': Please see https://duckduckgo.com/?q=' + encodeURIComponent ( 'site:http://npmjs.org/doc/ ' + m . match_data [ 1 ] ) m . say ( reply ) return reply }
function getMonth ( date ) { switch ( date . getMonth ( ) ) { case 0 : return "January" ; case 1 : return "February" ; case 2 : return "March" ; case 3 : return "April" ; case 4 : return "May" ; case 5 : return "June" ; case 6 : return "July" ; case 7 : return "August" ; case 8 : return "September" ; case 9 : return "October" ; case 10 : return "November" ; default : return "December" ; } }
function getDayOfWeek ( date ) { switch ( date . getDay ( ) ) { case 0 : return "Sunday" ; case 1 : return "Monday" ; case 2 : return "Tuesday" ; case 3 : return "Wednesday" ; case 4 : return "Thursday" ; case 5 : return "Friday" ; default : return "Saturday" ; } }
function ( name , data ) { if ( ! listeners [ name ] ) return ; for ( var l in listeners [ name ] ) listeners [ name ] [ l ] ( data ) ; return exports ; }
function ( str ) { if ( ! str || str == "0000-00-00T00:00:00" ) return null ; if ( typeof str == "string" ) { var val = new Date ( str . replace ( /-/g , "/" ) . replace ( /[TZ]/g , " " ) ) ; return val && val != "undefined" ? val : null ; } return str ; }
function ( time ) { var date = exports . stringToDate ( time ) ; if ( ! date || ! date . getTime ) return "" ; var aa = "AM" , hours = date . getHours ( ) ; hours >= 12 && ( aa = "PM" , hours -= 12 ) , hours == 0 && ( hours = "12" ) ; var minutes = date . getMinutes ( ) ; return minutes < 10 && ( minutes = "0" + minutes ) , hours + ":" + minutes + " " + aa ; }
function ( event ) { var height , width , _ref ; _ref = getDimensions ( ) , width = _ref . width , height = _ref . height ; return $ ( '#output-text' ) . text ( DFHMExport [ "export" ] ( width , height , determineSize ( ) , worldState ) ) ; }
function ( ) { this . objects = this . level . objects ; for ( var i in this . objects ) { this . objects [ i ] . mesh !== undefined ? this . scene . add ( this . objects [ i ] . mesh ) : false ; this . objects [ i ] . light !== undefined ? this . scene . add ( this . objects [ i ] . light ) : false ; } }
function Lamp ( model , options ) { if ( options . light ) { this . light = new THREE . PointLight ( ( options . light . color || 0xffffff ) , options . light . intensity ) ; this . light . position = options . light . position !== undefined ? options . light . position : new THREE . Vector3 ( 0 , 0 , 0 ) ; this . light . add ( new SolidObject ( model , 0 , 0 , options ) . mesh ) ; } }
function ( ) { var sources = this . sources ; for ( var i = 0 , l = sources . length ; i < l ; ++ i ) { new Bitmap ( this . _loader , sources [ i ] , { onload : tools . hitch ( this , '_bitmapLoaded' ) } ) ; } }
function ( req , res ) { var wikipage = { title : req . body . title , text : req . body . body , created_at : Date ( ) } ; provider . createWikiPage ( wikipage , function ( err , new_wikipage ) { return res . send ( new_wikipage ) ; } ) ; }
function ( req , res ) { var updated_wikipage = { title : req . body . title , text : req . body . body , created_at : req . body . created_at } ; provider . updateWikiPage ( req . params . wikipage , updated_wikipage , function ( err , wikipage ) { return res . send ( updated_wikipage ) ; } ) ; }
function ( lat , lng ) { console . log ( 'setLocation +' uMarker ) ; if ( uMarker == null ) { map . setCenter ( new google . maps . LatLng ( lat , lng ) ) ; } else { uMarker . setPosition ( new google . maps . LatLng ( lat , lng ) ) ; win . setPosition ( aMarker . getPosition ( ) ) ; } searchCircle . setCenter ( new google . maps . LatLng ( lat , lng ) ) ; }
function ( args , callback ) { console . log ( 'Connecting to Mongo database: ' + args . name ) ; this . conn = new mongo . Db ( args . name , new mongo . Server ( args . host , args . port , args . options || { } ) ) ; this . conn . open ( function ( error , conn ) { callback ( ) ; } ) ; }
function ( error , cursor ) { var items = [ ] ; cursor . each ( function ( error , item ) { console . log ( 'each' , item ) ; if ( item == null ) { callback ( items ) ; } items . push ( new that ( item ) ) ; } ) ; }
function ( field ) { var value = rawdoc [ field . id ] ; if ( value !== null ) { value = value . toString ( ) ; } foundmatch = foundmatch || ( value . toLowerCase ( ) === term . toLowerCase ( ) ) ; }
function ( content , result ) { $ ( this ) . trigger ( 'loadSuccessful' , arguments ) ; content . empty ( ) . css ( { 'background' : 'none' , 'height' : 'auto' , 'min-height' : 'auto' } ) ; if ( result . bStateError ) { ls . msg . error ( null , result . sMsg ) ; } else { content . html ( result . sText ) ; ls . hook . run ( 'ls_block_onload_html_after' , arguments , this ) ; } }
function ( expression ) { if ( FBTrace . DBG_WATCH ) FBTrace . sysout ( "Firebug.WatchPanel.addWatch; expression: " + expression ) ; if ( ! this . watches ) this . watches = [ ] ; for ( var i = 0 ; i < this . watches . length ; i ++ ) { if ( expression == this . watches [ i ] ) return ; } this . watches . splice ( 0 , 0 , expression ) ; this . rebuild ( true ) ; }
function ( ) { var $window = $ ( window ) , distFromTop = $window . height ( ) + $window . scrollTop ( ) , distFromBottom = $ ( document ) . height ( ) - distFromTop , bufferPx = 2000 ; if ( distFromBottom < bufferPx ) { this . trigger ( "loadMore" ) } }
function ( PlaylistInstance ) { self . playlist = playlist = PlaylistInstance new PlaylistModel ( { withUI : playlist , withApi : api , onload : function ( PlaylistModelInstance ) { playlistModel = self . playlistModel = PlaylistModelInstance playlistModel . updateInfo ( ) playlistModel . updateButtons ( ) callback && callback ( ) } } ) }
function playlistItemDidMove ( ) { }
function ( options ) { this . node = util . createElement ( { tag : 'ol' , customClass : 'UIRearrangeableListWidget' , appendTo : ( options . appendTo instanceof Element ) ? options . appendTo : document . body } ) this . onmoved = options . onmoved this . onnoderemoved = options . onnoderemoved this . selectedNodes = [ ] }
function dragDrop ( item , index ) { if ( window . dropZone == 'rearrangeablelist' ) { var group , draggedNode = this . node . childNodes [ index ] if ( util . hasClass ( draggedNode , 'selected' ) ) { group = this . selectedNodes } else { group = [ draggedNode ] } this . onmoved ( index ) moveTo . call ( this , group , item , window . dropRegion ) window . dropRegion = undefined } util . removeNode ( document . getElementById ( 'dropIndicator' ) ) }
function ( f ) { if ( f . name == fileName ) { self . _stopUpload ( file , msg ) ; self . fire ( Auth . event . ERROR , { rule : 'allowRepeat' , msg : msg , value : rule [ 0 ] } ) ; return isRepeat = true ; } }
function ( ) { var op = this . _expr . getToken ( ) . getValue ( ) ; this . _emitter . _getExpressionEmitterFor ( this . _expr . getFirstExpr ( ) ) . emit ( _AssignmentExpressionEmitter . _operatorPrecedence [ op ] ) ; this . _emitter . _emit ( op , this . _expr . getToken ( ) ) ; this . _emitter . _emitRHSOfAssignment ( this . _expr . getSecondExpr ( ) , this . _expr . getFirstExpr ( ) . getType ( ) ) ; }
function ( seq ) { var out = [ ] ; for ( var i = seq . length - 1 ; i != 0 ; i -- ) { out . push ( DnaComplements [ seq [ i ] ] ) ; } return out . join ( '' ) ; }
function ( data ) { $ ( "#path-id" ) . val ( data . id ) ; window . location = "/" + data . id + "/edit" ; }
function ( data , status ) { $ ( "#goal-name-" + goalId ) . text ( newName ) ; $ ( "#goal-cancel-button-" + goalId ) . click ( ) ; }
function ( data , status ) { $ ( "#path-name" ) . text ( newName ) ; $ ( "#path-description" ) . html ( markdown . Transform ( newDescription ) ) ; $ ( "#path-cancel-button" ) . click ( ) ; }
function ( data ) { $ ( "#goals" ) . toggle ( ) ; $ ( "#path-form" ) . toggle ( ) ; $ ( "#path-name-saved" ) . html ( data . name ) ; $ ( "#path-id" ) . val ( data . id ) ; }
function ( data ) { $ ( "#add-comment-" + achievementId ) . html ( "<p>" + markdown . Transform ( comment ) + "</p>" ) ; }
function ( msg , type , pid , ref , pos , off , dur ) { var notif = ( zul && zul . wgt ) ? zul . wgt . Notification : null ; if ( notif ) notif . show ( msg , pid , { ref : ref , pos : pos , off : off , dur : dur , type : type } ) ; else { jq . alert ( msg ) ; } }
function ( id ) { var exports ; if ( id . indexOf ( '@' ) < 0 ) id += '@' ; for ( var _id in depslist ) { if ( _id . lastIndexOf ( id ) >= 0 ) { exports = depslist [ _id ] ; break ; } } ; if ( exports ) { return exports ; } else { throw new Error ( 'no dependence for ' + id ) ; } }
function ( ) { _redraw ( false ) ; }
function ( ) { jQuery ( "#slide_list" ) . sortable ( { update : function ( event , ui ) { refresh_order ( jQuery ( "#add_slide" ) . attr ( 'code_pays' ) ) } } ) ; }
function ( strategy , root , segment , index ) { if ( typeof ( strategy ) === "function" ) { return strategy ( root , segment , index ) ; } else if ( strategy && strategy . next ) { return strategy . next ( root , segment , index ) ; } }
function ( EL , uncess ) { uncess = uncess || 0 ; var newThat = fluid . model . makeTrundler ( that . root , config , that . strategies ) ; newThat . segs = fluid . model . parseEL ( EL ) ; newThat . index = 0 ; newThat . step ( newThat . segs . length - uncess ) ; return newThat ; }
function ( inputPath , value , expander ) { var togo ; if ( inputPath ) { togo = fluid . get ( expander . source , inputPath ) ; } if ( togo === undefined ) { togo = fluid . isPrimitive ( value ) ? value : expander . expand ( value ) ; } return togo ; }
function ( userOutputPath , value , expander ) { var toset = fluid . copy ( value ) ; var outputPath = fluid . model . composePaths ( expander . outputPrefix , userOutputPath ) ; if ( toset !== undefined ) { fluid . set ( expander . target , outputPath , toset ) ; } return userOutputPath ? fluid . model . transform . NONDEFAULT_OUTPUT_PATH_RETURN : toset ; }
function ( ) { var shortened = fluid . model . transform ( valueTests , transformToShortNames ) ; var expected = fluid . transform ( valueTests , function ( config ) { return { expander : { type : fluid . computeNickName ( config . expander . type ) } } ; } ) ; jqUnit . assertDeepEq ( "Transformed expander types to short names" , expected , shortened ) ; var newConfig = $ . extend ( true , [ ] , valueTests , shortened ) ; testOneStructure ( newConfig ) ; }
function _request ( method , path , data , cb ) { $ . ajax ( { type : method , url : API_URL + path , data : JSON . stringify ( data ) , dataType : 'json' , contentType : 'application/x-www-form-urlencoded' , success : function ( res ) { cb ( null , res ) ; } , error : function ( err ) { cb ( err ) ; } , headers : headers ( ) } ) ; }
function _raw_request ( method , path , data , cb ) { $ . ajax ( { type : method , url : API_URL + path , data : JSON . stringify ( data ) , contentType : 'application/x-www-form-urlencoded' , success : function ( res ) { cb ( null , res ) ; } , error : function ( err ) { cb ( err ) ; } , headers : headers ( ) } ) ; }
function ( msg , data ) { if ( hasTimedOut ) return ; var line = self . set ( 'log' , { message : msg } ) ; if ( data ) line . set ( 'data' , data ) ; line . set ( 'timestamp' , new Date ( ) . getTime ( ) ) ; line . set ( 'job' , job ) ; debug ( 'task %s log: %s' , msg ) ; task . emit ( 'log' , job , line ) ; }
function autoLog ( ) { switch ( job . get ( 'status' ) ) { case 'completed' : param . log ( 'Job completed successfully' ) ; break ; case 'failed' : param . log ( 'Job has failed: "' + job . get ( 'error.msg' ) + '"' ) ; break ; case 'timeout' : param . log ( 'Job has timed out after ' + timeout + 'ms' ) ; break ; case 'processing' : param . log ( 'Job has started processing' ) ; break ; } }
function ( error , response , body ) { if ( ! error && response . statusCode == 200 ) { console . log ( body ) ; var answer = JSON . parse ( body ) ; } }
function bglog ( msg ) { if ( chrome . extension . getBackgroundPage ( ) ) { chrome . extension . getBackgroundPage ( ) . console . log ( msg ) ; } else { window . console && window . console . log ( msg ) ; } }
function ( ) { this . fields . title = trimTo ( this . fields . title , MAX_CHARS_PER_FIELD ) ; this . fields . description = trimTo ( this . fields . description , MAX_CHARS_PER_FIELD ) ; this . fields . location = trimTo ( this . fields . location , MAX_CHARS_PER_FIELD ) ; }
function ( startTime ) { var endTime = new Date ( Date . parse ( startTime . toString ( ) ) ) ; if ( startTime . getHours ( ) == 0 && startTime . getMinutes ( ) == 0 ) { endTime . setDate ( startTime . getDate ( ) + 1 ) ; } else { endTime . setHours ( startTime . getHours ( ) + DEFAULT_DURATION_HOURS_IF_ABSENT ) ; } return endTime ; }
function ( ) { var loc = '' ; if ( ! isBlankOrUndef ( this . fields . address ) ) { loc += encodeURIComponent ( this . fields . address ) ; if ( ! isBlankOrUndef ( this . fields . location ) ) { loc += encodeURIComponent ( ' (' + this . fields . location + ')' ) ; } } else if ( ! isBlankOrUndef ( this . fields . location ) ) { loc = encodeURIComponent ( this . fields . location ) ; } return loc ; }
function getFirstFieldText ( element , selector ) { var rawField = $ ( element ) . find ( selector ) ; if ( rawField && rawField . length > 0 ) { return $ ( rawField [ 0 ] ) . text ( ) . trim ( ) ; } return '' ; }
function ( ) { this . _popModal ( ) ; if ( this . actor . visible ) { Tweener . addTween ( this . actor , { opacity : 0 , time : POPUP_FADE_OUT_TIME , transition : 'easeOutQuad' , onComplete : Lang . bind ( this , function ( ) { this . actor . destroy ( ) ; } ) } ) ; } else this . actor . destroy ( ) ; }
function ( e ) { e . preventDefault ( ) ; $ ( '.button.dropdown' ) . not ( $ ( this ) . parent ( ) ) . children ( 'ul' ) . removeClass ( 'show-dropdown' ) ; $ ( this ) . siblings ( 'ul' ) . toggleClass ( 'show-dropdown' ) ; }
function ( token ) { var thisObj = this , v = thisObj . value ; if ( thisObj . contains ( token ) ) return ; thisObj . value += ( ( v && ! v . match ( RE_DOMSettableTokenList_lastSpaces ) ? " " : "" ) + token ) ; this [ this . length ++ ] = token ; if ( thisObj . _onchange ) thisObj . _onchange . call ( thisObj . _onchange_this , thisObj . value ) ; }
function ( ) { if ( ! this . tagName ) return void 0 ; var thisObj = this , cont = thisObj [ "_" ] || ( thisObj [ "_" ] = { } ) ; if ( ! cont [ S_ELEMENT_CACHED_CLASSLIST_NAME ] ) cont [ S_ELEMENT_CACHED_CLASSLIST_NAME ] = new DOMStringCollection ( thisObj . className , DOMStringCollection_setNodeClassName , thisObj ) ; return cont [ S_ELEMENT_CACHED_CLASSLIST_NAME ] ; }
function ( ) { slices . selectAll ( "text" ) . remove ( ) ; slicePaths = slicePaths . data ( dataPie ( chart . group ( ) . top ( Infinity ) ) ) ; slicePaths . transition ( ) . duration ( 750 ) . attrTween ( "d" , tweenPie ) ; chart . drawLabels ( slices , arc ) ; return chart ; }
function ( ) { slices . selectAll ( "text" ) . remove ( ) ; slicePaths = slicePaths . data ( dataPie ( chart . group ( ) . top ( Infinity ) ) ) ; slicePaths . transition ( ) . duration ( 750 ) . attrTween ( "d" , tweenPie ) ; chart . drawLabels ( slices , arc ) ; return chart ; }
function ( ) { var d = new Date ( this . x ) ; d = d . toUTCString ( ) . split ( " " ) ; d = d [ 4 ] + " " + d [ 5 ] + getTimeZone ( ) ; return '<b>' + this . series . name + '</b><br/><em>Time: </em>' + d + '<br/><em>Usage: </em>' + this . y + 'MB' ; }
function ( ) { return '<b>' + this . point . name + ' GMT' + getTimeZone ( ) + '</b>: ' + this . percentage . toFixed ( 2 ) + ' %' + ' (' + this . point . y . toFixed ( 2 ) + ' MB)' ; }
function Reward_rewardOverview ( ) { var today = new Date ( ) ; var date = new Date ( today . getFullYear ( ) , today . getMonth ( ) , today . getDate ( ) - 1 ) ; date = $ . datepicker . formatDate ( "dd M yy" , date ) ; $ ( "#date" ) . val ( date ) ; $ ( "#date" ) . datepicker ( { minDate : - 180 , maxDate : 5 , dateFormat : "dd M yy" } ) ; Reward_rewardOverview_showUsage ( ) ; }
function ( ) { var done = ( loaded . length + errors . length ) === paths . length ; if ( done && callback ) { callback ( sounds ) ; } if ( progress ) { progress ( sounds ) ; } }
function ( span ) { if ( span <= 1000000 ) { return ~ ~ ( span / 10000 ) + 1 ; } return Math . pow ( 10 , ( ~ ~ ( Math . log ( span ) / Math . log ( 10 ) ) - 4 ) ) * 5 ; }
function unload ( ) { Inspector . off ( "connect" , _onConnect ) ; Inspector . off ( "disconnect" , _onDisconnect ) ; Inspector . off ( "Debugger.paused" , _onPaused ) ; Inspector . off ( "Debugger.resumed" , _onResumed ) ; $exports . off ( ) ; _onDisconnect ( ) ; }
function ( ) { var selected = this . datasource [ this . selectedIndex ] , word = this . staticText || ( selected ? selected . name : this . emptyLabel ) , el = this . _getCur ( ) ; el . title = word ; el . innerHTML = '<nobr>' + word + '</nobr>' ; this . _repaintLayer ( ) ; }
function ( ) { window . setTimeout ( this . bind ( function ( ) { this . close ( ) ; this . container . removeClass ( "select2-container-active" ) ; this . dropdown . removeClass ( "select2-drop-active" ) ; this . clearSearch ( ) ; this . selection . find ( ".select2-search-choice-focus" ) . removeClass ( "select2-search-choice-focus" ) ; this . search . blur ( ) ; } ) , 10 ) ; }
function openEditor ( trackEvent ) { if ( ! _firstUse ) { _firstUse = true ; _editorAreaDOMRoot . classList . remove ( "minimized" ) ; } var editorType = Editor . isRegistered ( trackEvent . type ) ? trackEvent . type : "default" ; if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( editorType , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; return _currentEditor ; }
function ( ) { M . block_ajax_marking . show_error ( M . str . block_ajax_marking . connecttimeout ) ; M . block_ajax_marking . get_current_tab ( ) . displaywidget . rebuild_parent_and_tree_count_after_new_nodes ( ) ; YAHOO . util . Dom . removeClass ( this . icon , 'loaderimage' ) ; }
function ( ) { if ( ! this . opened ( ) ) return ; this . dropdown . hide ( ) ; this . container . removeClass ( "select2-dropdown-open" ) ; this . results . empty ( ) ; this . clearSearch ( ) ; }
function ( ) { var checked = this . checked ; bugTrackerTypeEl [ 0 ] . disabled = checked ; forEachField ( BUG_TRACKER_FIELDS , true , function ( el ) { el [ 0 ] . disabled = checked ; } ) ; updateFormDisplay ( "bug_tracker_type" , BUG_TRACKER_FIELDS ) ; }
function ( ) { var hostingType = hostingTypeEl [ 0 ] . value , repoFormID = "repo-form-" + hostingType + "-" + ( repoPlanEl . val ( ) || "default" ) ; repoForms . hide ( ) ; $ ( "#" + repoFormID ) . show ( ) ; }
function ( ) { updateFormDisplay ( "bug_tracker_type" , BUG_TRACKER_FIELDS ) ; }
function ( ) { this . css ( "top" , ( $ ( window ) . height ( ) - this . height ( ) ) / 2 + $ ( window ) . scrollTop ( ) + "px" ) ; this . css ( "left" , ( $ ( window ) . width ( ) - this . width ( ) ) / 2 + $ ( window ) . scrollLeft ( ) + "px" ) ; return this ; }
function ( view , name ) { if ( _ . isArray ( view ) ) { return _ . each ( view , function ( view ) { this . setView ( name , view , true ) ; } , this ) ; } this . setView ( name , view ) ; }
function ( subView , i ) { if ( ! subView . keep && ( subView . options && ! subView . options . keep ) ) { subView . remove ( ) ; view . splice ( i , 1 ) ; } }
function playMovie ( building ) { window . plugins . videoPlayer . play ( 'http://tali.irail.be/REST/Movie/qrID/' + building . token + '.gp3' ) ; }
function ( ) { if ( builder . record . recording ) { builder . record . stop ( ) ; } if ( builder . record . verifyExploring ) { builder . record . stopVerifyExploring ( ) ; } }
function ( ) { jQuery ( '#record-panel' ) . hide ( ) ; builder . record . recorder . destroy ( ) ; builder . record . recorder = null ; builder . pageState . removeListener ( builder . record . pageLoadListener ) ; if ( builder . record . selenium1WaitsListener ) { builder . pageState . removeListener ( builder . record . selenium1WaitsListener ) ; builder . record . selenium1WaitsListener = null ; } builder . record . recording = false ; }
function ( result , exception ) { ok ( result instanceof Components . interfaces . nsIIDBDatabase , "First database creation was successful" ) ; ok ( ! exception , "No exception" ) ; is ( getPermission ( testPageURL , "indexedDB" ) , Components . interfaces . nsIPermissionManager . UNKNOWN_ACTION , "Correct permission set" ) ; gBrowser . removeCurrentTab ( ) ; executeSoon ( test2 ) ; }
function ( result , exception ) { ok ( result instanceof Components . interfaces . nsIIDBDatabase , "First database creation was successful" ) ; ok ( ! exception , "No exception" ) ; is ( getPermission ( testPageURL , "indexedDB" ) , Components . interfaces . nsIPermissionManager . UNKNOWN_ACTION , "Correct permission set" ) ; gBrowser . removeCurrentTab ( ) ; unregisterAllPopupEventHandlers ( ) ; removePermission ( testPageURL , "indexedDB" ) ; executeSoon ( finish ) ; }
function ( result ) { is ( result , "finished" , "Got 'finished' result" ) ; is ( getPermission ( testPageURL , "indexedDB-unlimited" ) , Components . interfaces . nsIPermissionManager . ALLOW_ACTION , "Correct permission set" ) ; gBrowser . removeCurrentTab ( ) ; unregisterAllPopupEventHandlers ( ) ; executeSoon ( finish ) ; }
function ( i , prop ) { var sum = ( start [ prop ] || 0 ) - ( delta [ prop ] || 0 ) ; if ( sum && sum >= 0 ) style [ prop ] = sum || null ; }
function ( d1 , d2 ) { var o1 = utils . isNumber ( d1 ) ? this . getChildAtOrder ( d1 ) : this . children [ d1 ] , o2 = utils . isNumber ( d2 ) ? this . getChildAtOrder ( d2 ) : this . children [ d2 ] , d = o1 . order ; o1 . order = o2 . order ; o2 . order = d ; setDirty ( this , 'childrenOrder' ) ; return this ; }
function ( ) { this . model . bind ( 'change' , this . render , this ) ; this . model . bind ( 'destroy' , this . remove , this ) ; this . model . bind ( 'change:online' , this . unrender , this ) ; this . toggle_unrender = false || options . toggle_unrender ; }
function ( inSender , inEvent ) { this . requestHideTooltip ( ) ; if ( inEvent . originator . active ) { this . menuActive = true ; this . activator = inEvent . originator ; this . activator . addClass ( "active" ) ; this . requestShowMenu ( ) ; } else { this . requestHideMenu ( ) ; } }
function ( ) { var savedSnippets = this . _snippetsSetting . get ( ) ; for ( var i = 0 ; i < savedSnippets . length ; ++ i ) this . _snippetAdded ( WebInspector . Snippet . fromObject ( savedSnippets [ i ] ) ) ; }
function ( data ) { if ( data && data . id ) { player . play ( { song_id : data . id , playlist_id : p . playlist_id , playlist_name : p . playlist_name , position : p . position - 1 } ) ; } else { player . stop ( ) ; } }
function ( data ) { if ( data && data . id ) { player . play ( { song_id : data . id , playlist_id : p . playlist_id , playlist_name : p . playlist_name , position : p . position + 1 } ) ; } else { player . stop ( ) ; } }
function ( data ) { data . forEach ( function ( d ) { $ ( '#regionSelect' ) . append ( new Option ( d . name , d . name , false , false ) ) ; } ) ; }
function pushAccountFolders ( acct ) { for ( var iFolder = 0 ; iFolder < acct . folders . length ; iFolder ++ ) { var folder = acct . folders [ iFolder ] ; wireReps . push ( folder ) ; markers . push ( [ acct . id , makeFolderSortString ( acct . id , folder ) ] ) ; } }
function ( event ) { console . error ( 'indexedDB error: ' + event . target . errorCode ) ; }
function ( event ) { var node = event . target ; if ( node === containerNode ) return ; while ( node && node . parentNode !== containerNode ) { node = node . parentNode ; } func ( node , event ) ; }
function ( clickedNode ) { if ( ! clickedNode ) return ; switch ( clickedNode . classList [ 0 ] ) { case 'msg-edit-menu-star' : header . setStarred ( true ) ; break ; case 'msg-edit-menu-unstar' : header . setStarred ( false ) ; break ; case 'msg-edit-menu-mark-read' : header . setRead ( true ) ; break ; case 'msg-edit-menu-mark-unread' : header . setRead ( false ) ; break ; } }
function ( header ) { var contents = msgNodes [ 'edit-menu' ] . cloneNode ( true ) ; contents . removeChild ( contents . getElementsByClassName ( header . isStarred ? 'msg-edit-menu-star' : 'msg-edit-menu-unstar' ) [ 0 ] ) ; contents . removeChild ( contents . getElementsByClassName ( header . isRead ? 'msg-edit-menu-mark-read' : 'msg-edit-menu-mark-unread' ) [ 0 ] ) ; return contents ; }
function ( pid , status ) { GLib . spawn_close_pid ( pid ) ; let enabledExtensions = global . settings . get_strv ( ExtensionSystem . ENABLED_EXTENSIONS_KEY ) ; if ( enabledExtensions . indexOf ( uuid ) == - 1 ) { enabledExtensions . push ( uuid ) ; global . settings . set_strv ( ExtensionSystem . ENABLED_EXTENSIONS_KEY , enabledExtensions ) ; } ExtensionSystem . loadExtension ( dir , ExtensionUtils . ExtensionType . PER_USER , true ) ; }
function ( key , value , callback ) { var self = this ; var osName = gazel . osName ; this . register ( 'write' , function ( uuid , cb ) { setValue ( gazel . osName , self . trans , uuid , key , value , cb , self . handleError . bind ( self ) , self ) ; } , callback ) ; return this ; }
function ( ) { var args = slice . call ( arguments ) ; if ( args . length === 0 ) return ; ( args [ 0 ] instanceof Array ? args [ 0 ] : [ args [ 0 ] ] ) . forEach ( function ( item ) { console . log ( item ) ; } ) ; }
function ( key ) { if ( ! uDb . objectStoreNames . contains ( key ) ) { uDb . createObjectStore ( key ) ; } }
function ( key ) { if ( ! uDb . objectStoreNames . contains ( key ) ) { uDb . createObjectStore ( key ) ; } }
function ( done ) { var val = 'foo:' + Date . now ( ) . toString ( ) ; client . sadd ( SET_KEY , val , function ( res ) { done ( assert . equal ( res , 1 , 'Values do not match.' ) ) ; } ) ; }
function ( done ) { var val = 'exists' ; client . sadd ( SET_KEY , val , function ( ) { client . add ( SET_KEY , val , function ( res ) { done ( assert . equal ( res , 0 , 'Values do not match.' ) ) ; } ) ; } ) ; }
function ( i ) { iWidth = $ ( this ) . outerWidth ( ) ; that . s . aiWidths . push ( iWidth ) ; if ( i < that . s . iLeftColumns ) { iLeftWidth += iWidth ; } if ( that . s . iTableColumns - that . s . iRightColumns <= i ) { iRightWidth += iWidth ; } }
function ( e ) { if ( e . keyCode === 13 ) { var msg = $ ( this ) . val ( ) ; if ( ! msg ) { return ; } connection . send ( msg ) ; $ ( this ) . val ( '' ) ; input . attr ( 'disabled' , 'disabled' ) ; } }
function ( instance , interrupt , offset , loop , volume , pan ) { if ( ! SoundChannel . add ( instance , interrupt ) ) { return false ; } var result = instance . beginPlaying ( offset , loop , volume , pan ) ; if ( result == - 1 ) { this . instances . splice ( this . instances . indexOf ( instance ) , 1 ) ; delete this . instanceHash [ instance . uniqueId ] ; return false ; } return true ; }
function ( data ) { this . conversationID = data [ 'conversationID' ] ; this . _super ( data ) ; if ( data [ 'conversationID' ] ) { this . startChat ( true ) ; } if ( data [ 'loginHTML' ] !== undefined && data [ 'loginHTML' ] ) { this . loginHTML = data [ 'loginHTML' ] ; WDN . jQuery ( "#wdn_feedback_comments" ) . replaceWith ( this . loginHTML ) ; this . initWatchers ( ) ; } this . displaySiteAvailability ( ) ; }
function ( ) { var placeholder = this . getPlaceholder ( ) ; if ( placeholder !== undefined && this . getVal ( ) . length === 0 && this . search . hasClass ( "select2-focused" ) === false ) { this . search . val ( placeholder ) . addClass ( "select2-default" ) ; this . search . width ( this . container . width ( ) ) ; } else { this . search . val ( " " ) . width ( 10 ) ; } }
function ( ) { if ( this . search . hasClass ( "select2-default" ) ) { this . search . val ( "" ) . removeClass ( "select2-default" ) ; } }
function ( ) { this . _waitDialog . dismiss ( ) ; SC . AlertPane . extend ( { layout : { top : 0 , centerX : 0 , width : 400 , height : 100 } } ) . show ( "Error posting to the journal" , "Your post doesn't seem to have reached the journal. Please check your internet connection and try again." , "" , "OK" , this ) ; Geniverse . blogPostController . restoreBlogPost ( ) ; }
function ( reason , desc ) { if ( 'closed' != this . readyState ) { debug ( 'socket close with reason: "%s"' , reason ) ; this . readyState = 'closed' ; this . emit ( 'close' , reason , desc ) ; this . onclose && this . onclose . call ( this ) ; } }
function ( url ) { if ( url ) { ad_url = url ; return this ; } else { return ad_url ; } }
function RFrameStream__destroy ( ) { if ( ! this . frap ) { if ( RFrameStream . VERBOSE ) log ( "RFrameStream__destroy: already destroyed" ) return } var self = this Object . keys ( this . frap_listeners ) . forEach ( function ( k ) { self . frap . removeListener ( k , self . frap_listeners [ k ] ) } ) this . emit ( 'end' ) delete this . frap this . emit ( 'close' ) }
function WFrameStream__destroy ( ) { if ( this . doingDestroySoon ) { log ( "WFrameStream__destroy: called while this.doingDestroySoon set" ) return } if ( this . didDestroy ) return this . didDestroy = true this . end ( ) delete this . frap this . emit ( 'close' ) }
function WFrameStream__destroySoon ( ) { if ( this . didDestroySoon ) return this . didDestroySoon = true var self = this if ( this . draining ) { if ( WFrameStream . VERBOSE ) log ( "WFrameStream__destroySoon: waiting on wstream 'drain'" ) this . doingDestroySoon = false this . once ( 'drain' , function ( ) { if ( WFrameStream . VERBOSE ) log ( "WFrameStream__destroySoon: wstream 'drain'" ) self . doingDestroySoon = false self . destroy ( ) } ) } else { self . destroy ( ) } }
function ( opts , callback ) { if ( ! callback ) { throw new Error ( 'setAttachment called without callback function.' ) ; } opts = opts || { } ; if ( ! opts [ 'name' ] ) { return callback ( "Attachment name not specified" ) ; } if ( ! opts [ 'contentType' ] ) { return callback ( "Attachment content type not specified" ) ; } if ( ! opts [ 'body' ] ) { return callback ( "Attachment name body not specified" ) ; } db . saveAttachement ( this . id , opts , callback ) ; }
function ( ) { var el = document . createElement ( 'bootstrap' ) , transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'oTransitionEnd otransitionend' , 'msTransition' : 'MSTransitionEnd' , 'transition' : 'transitionend' } , name for ( name in transEndEventNames ) { if ( el . style [ name ] !== undefined ) { return transEndEventNames [ name ] } } }
function ( ) { var el = document . createElement ( 'bootstrap' ) , transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'oTransitionEnd otransitionend' , 'msTransition' : 'MSTransitionEnd' , 'transition' : 'transitionend' } , name for ( name in transEndEventNames ) { if ( el . style [ name ] !== undefined ) { return transEndEventNames [ name ] } } }
function ( type ) { var node = this function catcher ( ) { if ( event . __pmc_dispatched ) return event . __pmc_dispatched = true var w = getEventWrapper ( event ) node . __pmc_dispatchEvent ( w ) } this . attachEvent ( 'on' + type , catcher ) return catcher }
function ( markers , seriesData ) { var i ; this . createMarkers ( markers ) ; for ( i = 0 ; i < this . series . length ; i ++ ) { this . series [ i ] . setValues ( seriesData [ i ] || { } ) ; } ; }
function ( ) { var i , markers = [ ] ; for ( i in this . markers ) { markers . push ( i ) ; } this . removeMarkers ( markers ) }
function ( ) { var i ; this . series = [ ] ; for ( i = 0 ; i < this . params . series . length ; i ++ ) { this . params . series [ i ] . type = this . params . series [ i ] . type || 'regions' ; this . series [ i ] = new jvm . DataSeries ( this . params . series [ i ] , this [ this . params . series [ i ] . type ] ) ; } }
function ( butter ) { var t = butter . tracks [ 0 ] , te = t . addTrackEvent ( defaultEvent ) ; butter . listen ( "trackeventremoved" , function ( e ) { butter . unlisten ( "trackeventremoved" ) ; equal ( e . data . id , te . id , "Removed correct track event" ) ; start ( ) ; } ) ; t . removeTrackEvent ( te ) ; }
function requireLogin ( req , res , next ) { if ( ! req . url . match ( /login/ ) && ! req . user ) { req . flash ( "info" , "please login" ) ; res . redirect ( '/login' ) ; } next ( ) ; }
function ( selectionmodel ) { if ( selectionmodel . getSelection ( ) . length == 0 ) { this . down ( '#removeButton' ) . disable ( ) ; } else { this . down ( '#removeButton' ) . enable ( ) ; } }
function htmlEscape ( s ) { return s . replace ( /&/g , '&amp;' ) . replace ( /</g , '&lt;' ) . replace ( />/g , '&gt;' ) . replace ( /'/g , '&#039;' ) . replace ( /"/g , '&quot;' ) . replace ( /\n/g , '<br />' ) ; }
function ( x , y ) { this . set ( { "x" : x , "y" : y } , { silent : true } ) ; this . glyphs . text . attr ( "x" , x ) ; this . glyphs . text . attr ( "y" , y ) ; }
function ( ) { this . closeTimeout = - 1 ; _ . defaults ( this . options , this . default_options ) ; this . template = _ . template ( this . options . template || cdb . templates . getTemplate ( [ 'common/notification' ] ) || '' ) ; this . $el . hide ( ) ; }
function ( ) { this . closeTimeout = - 1 ; _ . defaults ( this . options , this . default_options ) ; this . template_base = _ . template ( this . options . template_base || cdb . templates . getTemplate ( 'common/notification' ) || '' ) ; this . $el . hide ( ) ; }
function ( options ) { return new File ( options ) }
function ( e ) { if ( e . success ) { Ti . App . Properties . removeProperty ( 'token' ) ; Ti . App . Properties . removeProperty ( 'email' ) ; Ti . App . Properties . removeProperty ( 'name' ) ; alert ( 'Success: Logged out' ) , loginWin . open ( ) ; } else { alert ( 'Error:\\n' + ( ( e . error && e . message ) || JSON . stringify ( e ) ) ) ; } }
function ( move ) { if ( move . secondary ) { move . secondary . chance = 100 ; } if ( move . accuracy !== true && move . accuracy <= 99 ) { move . accuracy = 0 ; } move . willCrit = true ; }
function playlistQueues_playlistQueuesDestroy ( playlistQueueId ) { var playlistQueue = $ ( "#playlist_queues #" + playlistQueueId ) ; if ( playlistQueue . length > 0 ) { playlistQueue . remove ( ) ; $ ( "#playlist_queues tbody tr" ) . each ( function ( ) { $this = $ ( this ) var row = $this [ 0 ] . rowIndex ; $this . find ( "td.row_number" ) . html ( row ) ; } ) ; playlistQueues_renderTableEmptyMessage ( ) ; } }
function ( ) { for ( var i = 0 ; i < arguments . length ; i ++ ) { var scriptEl = doc . createElement ( 'script' ) ; scriptEl . src = window . Worker . baseURI + script ; scriptEl . type = 'text/javascript' ; doc . body . appendChild ( scriptEl ) ; } }
function ( data ) { resultData = eval ( data ) ; wycFun . fillColorHtmlByData ( resultData [ 0 ] , $ ( "#diskinfo01" ) [ 0 ] , 0 ) ; }
function ( ) { $ ( this ) . dialog ( "close" ) ; }
function ( data ) { var getData = eval ( data ) ; if ( getData . result . process <= 100 && getData . result . process >= 0 ) { checkLoading . css ( 'width' , getData . result . process + '%' ) ; timeNum = setTimeout ( timeSet , 1000 ) ; } else { clearTime ( timeNum ) ; } }
function ( ) { var selected = path_selector . find ( 'input:checked' ) , to_ret = { } ; KT . utils . each ( selected , function ( item ) { item = $ ( item ) ; to_ret [ item . data ( 'node_id' ) ] = { text : item . parent ( ) . text ( ) , next_id : item . data ( 'next_node_id' ) } ; } ) ; return to_ret ; }
function ( node , next ) { var html = '' , next_node = next ? ( 'data-next_node_id="' + next . id + '"' ) : '' , input = node . select ? '<span class="checkbox_holder"><input class="node_select" type="checkbox" ' + next_node + ' data-node_id="' + node . id + '"></span>' : '' ; html += '<li data-node_id="' + node . id + '">' + '<label><div>' + input + node . name + '</div></label></li>' ; return html ; }
function onFetched ( ) { module = cachedModules [ uri ] if ( module . status >= STATUS . SAVED ) { var deps = getPureDependencies ( module ) if ( deps . length ) { Module . prototype . _load ( deps , function ( ) { cb ( module ) } ) } else { cb ( module ) } } else { cb ( ) } }
function execModifiers ( module ) { var uri = module . uri var modifiers = cachedModifiers [ uri ] if ( modifiers ) { util . forEach ( modifiers , function ( modifier ) { runInModuleContext ( modifier , module ) } ) delete cachedModifiers [ uri ] } }
function onFetched ( ) { module = cachedModules [ uri ] if ( module . status >= STATUS . SAVED ) { var deps = getPureDependencies ( module ) if ( deps . length ) { Module . prototype . _load ( deps , function ( ) { cb ( module ) } ) } else { cb ( module ) } } else { cb ( ) } }
function execModifiers ( module ) { var uri = module . uri var modifiers = cachedModifiers [ uri ] if ( modifiers ) { util . forEach ( modifiers , function ( modifier ) { runInModuleContext ( modifier , module ) } ) delete cachedModifiers [ uri ] } }
function ( propertyType , property ) { switch ( propertyType ) { case "string" : if ( property . format == "wcf-date" ) { propertyType = "Date" ; } else { propertyType = "String" ; } break ; case "number" : propertyType = "Number" ; break ; case "integer" : propertyType = "Number" ; break ; case "boolean" : propertyType = "Boolean" ; break ; case "object" : propertyType = "Object" ; break ; case "null" : case "any" : default : break ; } return propertyType ; }
function ( ) { var el , len = this . objectsList . length ; for ( el = 0 ; el < len ; el ++ ) { this . objectsList [ el ] . clearTrace ( ) ; } this . numTraces = 0 ; return this ; }
function ( err , stat ) { if ( err ) { return ; } if ( options . ignoreDotFiles && path . basename ( file ) [ 0 ] === '.' ) return ; if ( options . filter && options . filter ( file , stat ) ) return ; files [ file ] = stat ; fileWatcher ( file ) ; callback ( file , stat , null ) ; }
function ( successCb , failureCb ) { if ( ! this . isPhysical ( ) ) { var computeStore = Ext . data . StoreManager . lookup ( 'ComputesStore' ) ; var parentId = this . get ( 'url' ) . split ( '/' ) [ 2 ] ; computeStore . loadById ( parentId , successCb , failureCb ) ; } }
function ( playerNumber ) { var rider = $scope . gameState . players [ playerNumber ] . rider ; var card = $scope . getMyHand ( ) ; if ( ! rider . card && card . kind !== "extra" ) { rider . card = card ; setMyHand ( null ) } else if ( rider . card && card . kind === "extra" ) { rider . extras += 1 ; setMyHand ( null ) } $scope . $apply ( ) ; }
function ( event ) { if ( $scope . getMyHand ( ) ) { $ ( '#hand' ) . offset ( { left : ( event . pageX - ( $ ( '#hand' ) . width ( ) / 2.0 ) ) , top : ( event . pageY - ( $ ( '#hand' ) . height ( ) / 2.0 ) ) } ) ; } }
function ( ) { var controllerClass , _i , _len ; for ( _i = 0 , _len = controllers . length ; _i < _len ; _i ++ ) { controllerClass = controllers [ _i ] ; try { Ext . create ( controllerClass , { view : this } ) ; } catch ( error ) { Deft . Logger . log ( "Error initializing Controllable instance: an error occurred while creating an instance of the specified controller: '" + controllerClass + "'." ) ; throw error ; } } }
function ( ) { this . list . html ( this . template ( this . taskFilter ( ) ) ) ; this . list . listview ( "refresh" ) ; $ ( "button" , this . list ) . button ( ) ; try { $ ( '[type="checkbox"]' , this . list ) . checkboxradio ( ) ; } catch ( e ) { } }
function ( child ) { var isSelected = array . some ( val , function ( v ) { return child . option && ( v === child . option . value ) ; } ) ; domClass . toggle ( child . domNode , this . baseClass + "SelectedOption" , isSelected ) ; child . domNode . setAttribute ( "aria-selected" , isSelected ? "true" : "false" ) ; }
function ( ) { console . info ( "enabled autosave timer" ) ; var widget = this ; this . timerAutoSave = new dojox . timing . Timer ( this . delay ) ; this . timerAutoSave . onTick = function ( ) { widget . _autoSave ( ) ; console . info ( "enabled autosave execute" ) ; } ; this . timerAutoSave . onStart = function ( ) { } ; this . timerAutoSave . start ( ) ; }
function codifyElement ( obj ) { var parent_node = obj . parent ( ) ; var html = obj . html ( ) . replace ( /&/g , "&amp;" ) . replace ( /</g , "&lt;" ) . replace ( />/g , "&gt;" ) ; var code = $ ( "<code></code>" ) ; code . append ( html ) ; var pre = $ ( "<pre></pre>" ) ; pre . append ( code ) ; parent_node . append ( pre ) ; return obj ; }
function codifyElement ( obj ) { var parent_node = obj . parent ( ) ; var html = obj . html ( ) . replace ( /&/g , "&amp;" ) . replace ( /</g , "&lt;" ) . replace ( />/g , "&gt;" ) ; var code = $ ( "<code></code>" ) ; code . append ( html ) ; var pre = $ ( "<pre></pre>" ) ; pre . append ( code ) ; parent_node . append ( pre ) ; return obj ; }
function ( e ) { if ( e . which == 13 ) { var chunks = $ ( this ) . val ( ) . match ( /.{1,1024}/g ) , len = chunks . length ; for ( var i = 0 ; i < len ; i ++ ) { socket . emit ( 'my msg' , { msg : chunks [ i ] } ) ; } $ ( this ) . val ( '' ) ; return false ; } }
function ( sender , vm ) { this . fireBusEvent ( 'displayEditVMDialog' , { hn : vm . getParent ( ) , compute : vm } ) ; }
function ( inx , doc ) { if ( vidCount > totalVideoCount ) { return ; } vidCount ++ ; _this . $target . append ( $ ( "<div class=\"video-container\" />" ) . append ( $ ( '<video />' ) . attr ( { 'poster' : doc . thumb , 'src' : doc . video , 'autoplay' : true } ) . data ( 'meta' , doc ) ) ) ; }
function ( ) { var key = $ ( this ) . attr ( "name" ) ; if ( key && that . datasets [ key ] ) { if ( key == 'hr' ) { that . datasets [ key ] [ 'threshold' ] = that . newhrconstraints ; } else if ( key == 'altitude' ) { } if ( key != 'lon' && key != 'lat' ) { data . push ( that . datasets [ key ] ) ; } } }
function ( key , val ) { var checked = "checked = checked" ; if ( key == 'cadence' ) checked = '' if ( key == 'temp' ) checked = '' if ( key == 'power' ) checked = '' if ( key != 'lon' && key != 'lat' ) { that . choiceContainer . append ( '<input type="checkbox" name="' + key + '" ' + checked + ' id="chk_' + key + '"><label for="chk_' + key + '">' + val . label + '</label></input>' ) ; } }
function ( data ) { $ . jStorage . set ( cacheKey , data ) ; if ( $ . jStorage . setTTL ) { if ( cacheTTL ) $ . jStorage . setTTL ( cacheKey , cacheTTL * 60 * 1000 ) ; } else log ( 'Your jStorage version doesn\'t support TTL on key, please update jStorage ( http://www.jstorage.info/ )' ) ; var dataCached = $ . extend ( true , { } , data ) ; if ( successhandler ) successhandler ( dataCached ) ; options . success = successhandler ; }
function ( data ) { console . log ( data . toString ( ) ) ; if ( data . toString ( ) . indexOf ( 'listening at port' ) ) { localReady = true ; if ( localReady && serverReady && ! curlRunning ) { return runCurl ( ) ; } } }
function ( data ) { console . log ( data . toString ( ) ) ; if ( data . toString ( ) . indexOf ( 'listening at port' ) ) { serverReady = true ; if ( localReady && serverReady && ! curlRunning ) { return runCurl ( ) ; } } }
function ( ) { var pattern = context . createPattern ( imageObj , "repeat" ) ; that . drawFilledCircle ( context , that . xoffset , that . yoffset , that . radius + 10 , pattern ) ; }
function ( ) { _ . bindAll ( this , "geocodeAddress" ) ; this . persistenceHelper = new httpizza . OrderPersistenceHelper ( ) ; this . order = this . persistenceHelper . getOrderSession ( ) ; if ( typeof this . order . get ( 'pizza' ) === 'undefined' ) { window . location = "/orders/makeline" ; } this . template = _ . template ( $ ( "#checkout_template" ) . html ( ) ) ; }
function ( results , status ) { if ( status == google . maps . GeocoderStatus . OK && results [ 0 ] ) { that . order . set ( { address : results [ 0 ] . formatted_address } , { silent : true } ) ; that . render ( ) ; that . renderMap ( position ) ; } }
function ( err , fname ) { normalizeCall ( is . File ( fpath ) ? fname : path . join ( fpath , fname ) , cb ) ; }
function ( cssCompletions , sidebarPane , isEditingName , acceptCallback ) { WebInspector . TextPrompt . call ( this , this . _buildPropertyCompletions . bind ( this ) , WebInspector . StylesSidebarPane . StyleValueDelimiters ) ; this . setSuggestBoxEnabled ( "generic-suggest" ) ; this . _cssCompletions = cssCompletions ; this . _sidebarPane = sidebarPane ; this . _isEditingName = isEditingName ; }
function ( ctor , name ) { var m = ctor . _m , c ; if ( m ) { c = ( + m . w [ name ] || 0 ) ; if ( c && c != id ) { dcl . _er ( "set chaining" , name , ctor , id , c ) ; } m . w [ name ] = id ; } }
function DclError ( message ) { if ( Error . captureStackTrace ) { Error . captureStackTrace ( this , ErrorCtor ) ; } var e = Error . call ( this , message ) , name ; for ( name in e ) { if ( e . hasOwnProperty ( name ) ) { this [ name ] = e [ name ] ; } } this . message = message ; }
function ( ) { for ( var i = 0 , l = chain . length ; i < l ; ++ i ) { chain [ i ] . apply ( this , arguments ) ; } }
function ( ) { return p . apply ( this , arguments ) ; }
function openinstructions ( id1 , id2 ) { if ( dojo . byId ( id2 ) ) { dojo . removeClass ( 'instructionOuterDiv' , 'hidediv' ) ; dojo . removeClass ( 'instructionDiv' , 'hidediv' ) ; dojo . byId ( 'instructionInnerDiv' ) . innerHTML = dojo . byId ( id2 ) . innerHTML ; } }
function ( ) { var ft = { "type" : "Feature" , "geometry" : { "type" : "Point" , "coordinates" : [ - 77 , 37.8 ] } , "properties" : { "title" : "This is a bus" } } ; var elem = simplestyle_factory ( ft ) ; expect ( jasmine . isDomNode ( elem ) ) . toBeTruthy ( ) ; }
function ( ) { if ( ! scoped . get ( ) ) return ; var componentDom = component . dom = dom . componentDom ( ctx ) ; component . create ( scoped , componentDom ) ; }
function ( view ) { for ( var v = view . getParent ( ) ; v ; v = v . getParent ( ) ) { if ( domClass . contains ( v . domNode , "mblView" ) ) { return v ; } } return null ; }
function ( node ) { for ( var n = node ; n && n . tagName !== "BODY" ; n = n . parentNode ) { if ( n . nodeType === 1 && domClass . contains ( n , "mblView" ) ) { return registry . byNode ( n ) ; } } return null ; }
function ( d ) { this . set ( "selected" , false ) ; }
function ( e ) { if ( this . currentView ) { this . currentView . goTo ( - 1 ) ; } }
function ( id , parentRequire , loaded ) { var dm = win . global . _no_dojo_dm || lang . getObject ( "dojox.mobile" , true ) ; parentRequire ( [ ( dm . currentTheme === "android" ? "./ValuePicker" : "./SpinWheel" ) + id ] , loaded ) ; }
function ( moveTo ) { if ( ! moveTo ) { return [ ] ; } var view = registry . byId ( moveTo . replace ( /^#/ , "" ) ) ; if ( ! view ) { return [ ] ; } for ( var v = view . getParent ( ) ; v ; v = v . getParent ( ) ) { if ( v . isVisible && ! v . isVisible ( ) ) { view = v ; } } return [ view . getShowingView ( ) , view ] ; }
function ( ) { equal ( $ . cookie ( 'whatever' ) , null , 'should return null' ) ; }
function ( ) { equal ( $ . cookie ( 'c' , 'v' ) , 'c=v' , 'should return written cookie string' ) ; }
function ( ) { var message = Array . prototype . slice . call ( arguments , 1 ) ; message . unshift ( "ERR!" . red . inverse ) ; stdout . apply ( this , message ) ; process . exit ( arguments [ 0 ] ) ; }
function ( ) { var message = Array . prototype . slice . call ( arguments , 1 ) ; message . unshift ( "ERR!" . red . inverse ) ; stdout . apply ( this , message ) ; process . exit ( arguments [ 0 ] ) ; }
function ( ) { var node = this . srcNodeRef ; node . removeAttribute ( "data-dojo-type" ) ; _WidgetBase . prototype . buildRendering . call ( this ) ; this . _attachTemplateNodes ( node , function ( n , p ) { return n . getAttribute ( p ) ; } ) ; this . _beforeFillContent ( ) ; }
function ( data , response ) { console . log ( 'Request on complete' ) ; if ( response . statusCode !== 200 ) { console . log ( "Non 200 response: " + response . statusCode ) ; } else { res . render ( 'story-list' , data . articles ) ; } }
function ( ) { $ . post ( gdn . url ( '/vanilla/settings/sortcategories/' ) , { 'TreeArray' : $ ( 'ol.Sortable' ) . nestedSortable ( 'toArray' , { startDepthCount : 0 } ) , 'DeliveryType' : 'VIEW' , 'TransientKey' : gdn . definition ( 'TransientKey' ) } , function ( response ) { if ( response != 'TRUE' ) { alert ( "Oops - Didn't save order properly" ) ; } } ) ; }
function ( e ) { var updateOptions = { } ; updateOptions [ propertyName ] = element . value ; trackEvent . update ( updateOptions ) ; var target = _this . butter . getTargetByType ( "elementID" , trackEvent . popcornOptions . target ) ; if ( target ) { target . view . blink ( ) ; } }
function ( popcornOptions ) { var element ; for ( var option in popcornOptions ) { if ( popcornOptions . hasOwnProperty ( option ) ) { element = _rootElement . querySelector ( "[data-manifest-key='" + option + "']" ) ; element . value = popcornOptions [ option ] ; } } }
function ( e ) { var trackEvent = e . data ; var trackEventDoubleClicked = function ( e ) { openEditor ( trackEvent ) ; } ; e . data . view . element . addEventListener ( "click" , trackEventDoubleClicked , false ) ; butter . listen ( "trackeventremoved" , function ( e ) { if ( e . data === trackEvent ) { e . data . view . element . removeEventListener ( "click" , trackEventDoubleClicked , false ) ; } } ) ; }
function ( error ) { console . log ( error . responseText ) ; }
function ( corpus , corpusParam , model , phrase , width ) { var query = { 'corpus' : corpus , 'corpusParam' : corpusParam , 'model' : model , 'phrase' : phrase , 'matrixWidth' : width } ; console . log ( query ) ; $ . get ( "/export" , query , 'json' ) . success ( function ( data ) { console . log ( data ) ; } ) . error ( function ( error ) { console . log ( error . responseText ) ; } ) ; }
function ball ( x , y ) { this . x = x ; this . y = y ; this . vx = 0 ; this . vy = 0 ; this . width = 15 ; this . height = 5 ; this . color = "#FFFFFF" ; }
function drawBall ( ) { ctx . fillStyle = pongBall . color ; ctx . fillRect ( pongBall . x , pongBall . y , pongBall . width , pongBall . height ) ; }
function getMousePos ( canvas , evt ) { var obj = canvas ; var top = 0 ; var left = 0 ; while ( obj && obj . tagName != 'BODY' ) { top += obj . offsetTop ; left += obj . offsetLeft ; obj = obj . offsetParent ; } var mouseX = evt . clientX - left + window . pageXOffset ; var mouseY = evt . clientY - top + window . pageYOffset ; return { x : mouseX , y : mouseY } ; }
function init ( ) { populateBricks ( ) ; gameLoop ( ) ; canvas . addEventListener ( 'mousemove' , function ( evt ) { var mousePos = getMousePos ( canvas , evt ) ; player . x = mousePos . x ; if ( player . x >= canvas . width - player . width ) { player . x = canvas . width - player . width ; } else if ( player . x <= 0 ) { player . x = 0 ; } } ) ; }
function render ( ) { for ( var i = 0 ; i < bricks . length ; i ++ ) { ctx . fillStyle = bricks [ i ] . color ; ctx . fillRect ( bricks [ i ] . x , bricks [ i ] . y , bricks [ i ] . width , bricks [ i ] . height ) ; } $ ( '#score' ) . html ( score ) ; $ ( '#lives' ) . html ( lives ) ; }
function ( ) { var diffNum = $ ( this ) . attr ( "value" ) ; console . log ( "diffNum" , diffNum ) ; console . log ( "list" , rawDiffsList ) ; console . log ( "entry" , rawDiffsList [ diffNum ] ) ; if ( $ ( this ) . is ( ":checked" ) ) { appliedDiffs . push ( rawDiffsList [ diffNum ] ) ; } else { appliedDiffs . splice ( appliedDiffs . indexOf ( rawDiffsList [ diffNum ] ) , 1 ) ; } }
function ( line , fntFile ) { var value ; value = /id=(\d+)/gi . exec ( line ) [ 1 ] ; cc . Assert ( parseInt ( value ) == 0 , "LabelBMFont file could not be found" ) ; value = /file="([a-zA-Z0-9\-\._]+)/gi . exec ( line ) [ 1 ] ; this . atlasName = cc . FileUtils . fullPathFromRelativeFile ( value , fntFile ) ; }
function ( plistFile ) { var ret = false ; this . _plistFile = plistFile ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( this . _plistFile ) ; cc . Assert ( dict != null , "Particles: file not found" ) ; return this . initWithDictionary ( dict ) ; }
function ( plist ) { cc . Assert ( plist , "Invalid texture file name" ) ; var path = cc . FileUtils . fullPathFromRelativePath ( plist ) ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( path ) ; cc . Assert ( dict , "cc.AnimationCache: File could not be found" ) ; this . addAnimationsWithDictionary ( dict ) ; }
function ( plist ) { var path = cc . FileUtils . fullPathFromRelativePath ( plist ) ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( path ) ; this . _removeSpriteFramesFromDictionary ( dict ) ; if ( cc . ArrayContainsObject ( this . _loadedFileNames , plist ) ) { cc . ArrayRemoveObject ( plist ) ; } }
function TouchList ( element ) { this . element = element ; this . element . style . overflow = 'hidden' ; this . top = { value : 0 , natural : 0 } ; this . touch = { value : 0 , offset : 0 , start : 0 , previous : 0 } ; this . velocity = { value : 0 , target : 0 } ; }
function ( path ) { if ( ! this . importCache [ path ] ) { var defineCall = require ( path ) this . importCache [ path ] = defineCall ( this , DataTypes ) } return this . importCache [ path ] }
function ( tpl , context ) { var compile , msg ; try { compile = require ( 'haml-coffee' ) . compile ; } catch ( e ) { msg = "" + ( error ( 'Haml-coffee module not found, run neat install.' . red ) ) + "\n\n" + e . stack ; return puts ( msg ) ; } return compile ( tpl ) ( context ) ; }
function ( tpl , context ) { var msg , to_html ; try { to_html = require ( 'mustache' ) . to_html ; } catch ( e ) { msg = "" + ( error ( 'Mustache module not found, run neat install.' . red ) ) + "\n\n" + e . stack ; return puts ( msg ) ; } return to_html ( tpl , context ) ; }
function ( err ) { if ( err ) { return puts ( error ( "" + ( "Can't write " + path ) . red + "\n\n" + err . stack ) ) && ( typeof cb === "function" ? cb ( ) : void 0 ) ; } puts ( ( "" + dir + "/" + name + ".gen.coffee generated" ) . green ) ; return typeof cb === "function" ? cb ( ) : void 0 ; }
function ( err ) { if ( err ) { return puts ( error ( "" + ( "Can't write " + path ) . red + "\n\n" + err . stack ) ) && ( typeof cb === "function" ? cb ( ) : void 0 ) ; } puts ( ( "" + dir + "/" + name + ".coffee generated" ) . green ) ; return typeof cb === "function" ? cb ( ) : void 0 ; }
function ( ) { var meta , neatFile , neatFilePath ; neatFilePath = "" + this . neatRoot + "/.neat" ; try { neatFile = fs . readFileSync ( neatFilePath ) ; } catch ( e ) { return puts ( "" + ( missing ( neatFilePath ) ) + "\n\n" + neatBroken ) ; } meta = cup . read ( neatFile . toString ( ) ) ; return meta || puts ( error ( "Invalid .neat file at:\n" + neatFilePath . red + "\n\n" + neatBroken ) ) ; }
function ( cb ) { print ( "." . red ) ; print ( "." . yellow ) ; print ( "." . green ) ; print ( "." . cyan ) ; print ( "." . blue ) ; puts ( "." ) ; puts ( "a second line" , 1 ) ; return console . log ( logger . stack ) ; }
function ( err , source ) { if ( err != null ) { return puts ( error ( err . message ) ) ; } source = source . replace ( "###_NPM_DECLARATION_###" , nemfile . toString ( ) ) ; return run ( 'coffee' , [ '-e' , source ] , function ( ) { puts ( "Your bundle is complete." . info ) ; return typeof cb === "function" ? cb ( ) : void 0 ; } ) ; }
function ( ) { domStyle . set ( dom . byId ( "invalidDate" ) , "visibility" , "hidden" ) ; registry . byId ( "datePicker" ) . hide ( false ) var datamodel = itemlistmodel . model [ this . app . selected_item ] ; date = datamodel . get ( "reminderDate" ) ; if ( ! date ) { datamodel . set ( "reminderOnAday" , "off" ) ; } }
function ( req , res , next ) { if ( ! req . loggedIn ) { return res . redirect ( everyauth . password . getLoginPath ( ) ) ; } if ( req . body . addEvent !== undefined ) { addEvent ( req , res , next , 'adhoc' , req . user ) ; } }
function _editorForURL ( url ) { var doc = DocumentManager . getCurrentDocument ( ) ; if ( doc && doc . url === url ) { return EditorManager . getCurrentFullEditor ( ) ; } else { console . log ( "No editor for url" , url ) ; } return null ; }
function onPaused ( event , res ) { var editor = _editorForURL ( res . location . url ) ; if ( ! editor ) { return ; } editor . setCursorPos ( res . location . lineNumber , res . location . columnNumber ) ; editor . _codeMirror . setLineClass ( res . location . lineNumber , "paused" ) ; }
function onResumed ( event , res ) { if ( res . location ) { var editor = _editorForURL ( res . location . url ) ; if ( ! editor ) { return ; } editor . _codeMirror . setLineClass ( res . location . lineNumber ) ; } }
function ( ) { var el = document . createElement ( 'bootstrap' ) , transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'oTransitionEnd' , 'msTransition' : 'MSTransitionEnd' , 'transition' : 'transitionend' } , name for ( name in transEndEventNames ) { if ( el . style [ name ] !== undefined ) { return transEndEventNames [ name ] } } }
function ( ) { for ( i in this . v ) { this . m [ i ] = ~ ~ ( 0.5 + ( ( this . s [ i ] * this . v [ i ] - this . o . min ) / this . f [ i ] ) + this . cur2 ) ; } }
function ( stateinfo , commentIds ) { var surface = this . surface ; surface . filterState = stateinfo . pageState ; surface . filterStateList = stateinfo . pageStateList ; surface . filterScene = stateinfo . viewScene ; surface . filterSceneList = stateinfo . viewSceneList ; surface . filterComments = commentIds ; this . _refreshSurface ( surface ) ; }
function ( ) { var content = get ( this , 'content' ) , len = content ? get ( content , 'length' ) : 0 ; if ( content ) { content . addArrayObserver ( this , { willChange : 'contentArrayWillChange' , didChange : 'contentArrayDidChange' } ) ; } }
function ( ) { var arrangedContent = get ( this , 'arrangedContent' ) , len = arrangedContent ? get ( arrangedContent , 'length' ) : 0 ; if ( arrangedContent ) { arrangedContent . addArrayObserver ( this , { willChange : 'arrangedContentArrayWillChange' , didChange : 'arrangedContentArrayDidChange' } ) ; } this . arrangedContentArrayDidChange ( this , 0 , undefined , len ) ; }
function ( ) { set ( this , 'location' , get ( this , 'location' ) || window . location ) ; set ( this , 'callbacks' , Ember . A ( ) ) ; }
function ( path ) { var state = window . history . state ; if ( path === "" ) { path = '/' ; } if ( ( ! state && path !== '/' ) || ( state && state . path !== path ) ) { window . history . pushState ( { path : path } , null , path ) ; } }
function ( key , value ) { var parentView , controller ; if ( arguments . length === 2 ) { return value ; } if ( VIEW_PRESERVES_CONTEXT ) { if ( controller = get ( this , 'controller' ) ) { return controller ; } parentView = get ( this , '_parentView' ) ; if ( parentView ) { return get ( parentView , '_context' ) ; } } return this ; }
function ( event , context ) { Ember . assert ( 'Cannot send event "' + event + '" while currentState is ' + get ( this , 'currentState' ) , get ( this , 'currentState' ) ) ; if ( arguments . length === 1 ) { context = { } ; } return this . sendRecursively ( event , get ( this , 'currentState' ) , context ) ; }
function ( event ) { event . view = view ; event . context = context ; if ( target . isState && typeof target . send === 'function' ) { return target . send ( actionName , event ) ; } else { return target [ actionName ] . call ( target , event ) ; } }
function ( e ) { if ( [ 'INPUT' , 'TEXTAREA' ] . contains ( e . target . tagName ) || $ ( e . target ) . parents ( ) . andSelf ( ) . is ( '.is-selectable' ) ) { return true ; } else { return false ; } }
function ( ) { var owner = this . get ( 'owner' ) ; var selection = owner . get ( 'selection' ) ; var dataCell = owner . get ( 'selectedDataCell' ) ; var readOnlyValue = owner . editableValue ( dataCell , true ) ; selection . html ( readOnlyValue ) ; selection . addClass ( 'read-only' ) ; }
function load ( url , content , type , line ) { if ( panel_window ) { panel_window . purple . showContent ( url , content , type ) ; panel_window . purple . setCursorOn ( url , line || 1 , 1 ) ; } else { buffer = Array . prototype . slice . apply ( arguments ) ; console . log ( 'buffering load' , buffer ) ; } }
function ( ) { if ( $ ( this ) . attr ( "id" ) . indexOf ( "start_" ) !== - 1 ) { var name = $ ( this ) . attr ( "id" ) . split ( "start_" ) [ 1 ] ; socket . send ( "request=start_bot&arguments=" + name ) ; } else { var name = $ ( this ) . attr ( "id" ) . split ( "stop_" ) [ 1 ] ; socket . send ( "request=stop_bot&arguments=" + name ) ; } }
function ( event ) { console . log ( '===== network becomes: ' + event . status ) ; var req = settings . getLock ( ) . get ( 'wifi.enabled' ) ; req . onsuccess = function wf_stateGet ( ) { if ( req . result [ 'wifi.enabled' ] ) { updateNetworkState ( ) ; if ( event . status == 'connected' ) { gNetworkList . scan ( ) ; } } } }
function setWifiEnabled ( val ) { gWifiCheckBox . checked = val ; console . log ( '===== network enabled: ' + val ) ; if ( val ) { updateNetworkState ( ) ; gNetworkList . clear ( true ) ; gNetworkList . scan ( ) ; } else { gWifiInfoBlock . textContent = _ ( 'disabled' ) ; gNetworkList . clear ( false ) ; gNetworkList . autoscan = false ; } }
function ( value ) { var wifiManager = window . navigator . mozWifiManager ; if ( ! wifiManager ) { return ; } if ( wifiManager . enabled == value ) { return ; } var req = wifiManager . setEnabled ( value ) ; req . onerror = function wf_EnabledError ( ) { var settings = window . navigator . mozSettings ; if ( settings ) { settings . getLock ( ) . set ( { 'wifi.enabled' : ! value } ) ; } } }
function ( ) { if ( this . prop == 'rotate3Di' ) { var style = $ ( this . elem ) . css ( 'transform' ) ; if ( style ) { var m = style . match ( /, (-?[0-9]+)deg\)/ ) ; if ( m && m [ 1 ] ) { return parseInt ( m [ 1 ] ) ; } else { return 0 ; } } } return proxied . apply ( this , arguments ) ; }
function ( depBasename ) { var deps = [ ] ; if ( _inProgressStack . indexOf ( depBasename ) === - 1 ) { deps . push ( depBasename ) ; } else { } resolve ( deps ) ; }
function ( el , ev ) { clearTimeout ( this . searchTimer ) ; if ( ( el . val ( ) == "" && typeof $ . route . attr ( 'who' ) == 'undefined' ) || ev . keyCode == 27 ) { $ . route . attrs ( { who : "index" } , true ) ; } else if ( el . val ( ) != "" ) { this . searchTimer = setTimeout ( this . callback ( 'search' ) , 200 ) } }
function combine ( ) { var composite = { } ; for ( var i = 0 , length = arguments . length ; i < length ; ++ i ) { var object = arguments [ i ] ; for ( var key in object ) { if ( object . hasOwnProperty ( key ) ) { if ( typeof composite [ key ] !== 'undefined' ) { throw new DeveloperError ( 'Duplicate member: ' + key ) ; } composite [ key ] = object [ key ] ; } } } return composite ; }
function destroyObject ( object , message ) { message = defaultValue ( message , 'This object was destroyed, i.e., destroy() was called.' ) ; function throwOnDestroyed ( ) { throw new DeveloperError ( message ) ; } for ( var key in object ) { if ( typeof object [ key ] === 'function' ) { object [ key ] = throwOnDestroyed ; } else { delete object [ key ] ; } } object . isDestroyed = returnTrue ; return undefined ; }
function ( url , textureAvailableCallback ) { if ( typeof url === 'undefined' ) { throw new DeveloperError ( 'url is required.' ) ; } if ( typeof textureAvailableCallback === 'undefined' ) { throw new DeveloperError ( 'textureAvailableCallback is required.' ) ; } this . addTextureFromFunction ( url , getImageFromUrl , textureAvailableCallback ) ; }
function getSelectedRadio ( ) { var radio = document . forms [ 0 ] . gender for ( var i = 0 ; i < radio . length ; i ++ ) { if ( radios [ i ] . checked ) { genderValue = radios [ i ] . value ; } ; } ; }
function ( stream , onSuccess , onFailure ) { var head = stream . slice ( 0 , len ) ; if ( head === str ) { return onSuccess ( stream . slice ( len ) , head ) ; } else { return onFailure ( stream , str ) ; } }
function ( str ) { var len = str . length ; return Parser ( function ( stream , onSuccess , onFailure ) { var head = stream . slice ( 0 , len ) ; if ( head === str ) { return onSuccess ( stream . slice ( len ) , head ) ; } else { return onFailure ( stream , str ) ; } } ) ; }
function ( stream , onSuccess , onFailure ) { var match = re . exec ( stream ) ; if ( match ) { var result = match [ 0 ] ; return onSuccess ( stream . slice ( result . length ) , result ) ; } else { return onFailure ( stream , re ) ; } }
function ( num ) { var monsterConstructors = [ OrcMonster , HydraMonster , SlimeMoldMonster ] ; this . monsters = [ ] ; for ( var i = 0 ; i < num ; i ++ ) { this . monsters . push ( new monsterConstructors [ randomInteger ( monsterConstructors . length ) - 1 ] ( ) ) ; } }
function ( ) { if ( navigator . userAgent . match ( /iPhone/i ) ) { $ ( window ) . bind ( 'orientationchange' , function ( event ) { if ( window . orientation == 90 || window . orientation == - 90 || window . orientation == 270 ) { $ ( 'meta[name="viewport"]' ) . attr ( 'content' , 'height=device-width,width=device-height,initial-scale=1.0,maximum-scale=1.0' ) ; } else { $ ( 'meta[name="viewport"]' ) . attr ( 'content' , 'height=device-height,width=device-width,initial-scale=1.0,maximum-scale=1.0' ) ; } } ) . trigger ( 'orientationchange' ) ; } }
function ( ) { $ ( '#pools-information' ) . fadeIn ( 'fast' ) ; that . plateElement . find ( '.aliquot' ) . removeClass ( that . plate . state ) ; that . colourPools ( ) ; that . control . find ( 'input:radio[name=radio-choice-1]:eq(1)' ) . attr ( 'checked' , true ) ; that . control . find ( 'input:radio' ) . checkboxradio ( "refresh" ) ; }
function ( ) { var modeValue = $ ( this ) . val ( ) ; map . geomap ( "option" , "mode" , modeValue ) ; $ ( "#clickTarget" ) . toggle ( modeValue . substr ( 0 , 4 ) === "draw" || modeValue === "remove" ) ; $ ( "#shapeLabels, #drawStyle" ) . toggle ( modeValue . substr ( 0 , 4 ) === "draw" ) ; $ ( "#change-mode .ui-button-text" ) . text ( modeValue ) ; $ ( "#modeOptions" ) . hide ( ) ; }
function ( ) { var modeValue = $ ( this ) . val ( ) ; map . geomap ( "option" , "mode" , modeValue ) ; $ ( "#clickTarget" ) . toggle ( modeValue . substr ( 0 , 4 ) === "draw" || modeValue === "remove" ) ; $ ( "#shapeLabels, #drawStyle" ) . toggle ( modeValue . substr ( 0 , 4 ) === "draw" ) ; $ ( "#change-mode .ui-button-text" ) . text ( modeValue ) ; $ ( "#modeOptions" ) . hide ( ) ; }
function got_supplements ( err , rs ) { if ( err ) { winston . error ( 'supplements: ' + err ) ; if ( client . post === post ) client . post = null ; return callback ( "Attachment error." ) ; } post . links = rs . links ; if ( rs . image ) extra . image_alloc = rs . image ; client . db . insert_post ( post , body , extra , inserted ) ; }
function inserted ( err ) { if ( err ) { if ( client . post === post ) client . post = null ; winston . error ( err ) ; return callback ( "Couldn't allocate post." ) ; } post . body = body ; callback ( null , get_post_view ( post ) ) ; }
function disassembleLoadBlock ( cmd0 , cmd1 ) { var uls = ( cmd0 >>> 12 ) & 0xfff ; var ult = ( cmd0 >>> 0 ) & 0xfff ; var tile_idx = ( cmd1 >>> 24 ) & 0x7 ; var lrs = ( cmd1 >>> 12 ) & 0xfff ; var dxt = ( cmd1 >>> 0 ) & 0xfff ; return 'gsDPLoadBlock(' + tile_idx + ', ' + uls + ', ' + ult + ', ' + lrs + ', ' + dxt + ');' ; }
function ( complete ) { return balUtilFlow . fireWithOptionalCallback ( _task , [ complete ] , context ) ; }
function ( name , fn ) { var block , push ; block = this ; push = function ( complete ) { if ( block . total === Infinity ) { return block . pushAndRun ( complete ) ; } else { return block . push ( complete ) ; } } ; push ( function ( ) { var subBlock ; return subBlock = block . createSubBlock ( name , fn , block ) ; } ) ; return this ; }
function ( ) { assert . equal ( 2 , tasks . completed , 'only the expected number of tasks ran' ) ; assert . equal ( false , tasks . isRunning ( ) , 'isRunning() returned false' ) ; assert . equal ( true , tasks . hasCompleted ( ) , 'hasCompleted() returned true' ) ; assert . equal ( true , tasks . hasExited ( ) , 'hasExited() returned true' ) ; return done ( ) ; }
function ( ) { assert . equal ( 2 , tasks . completed , 'only the expected number of tasks ran' ) ; assert . equal ( false , tasks . isRunning ( ) , 'isRunning() returned false' ) ; assert . equal ( true , tasks . hasCompleted ( ) , 'hasCompleted() returned true' ) ; assert . equal ( true , tasks . hasExited ( ) , 'hasExited() returned true' ) ; return done ( ) ; }
function ( ) { assert . equal ( 2 , tasks . completed , 'only the expected number of tasks ran' ) ; assert . equal ( false , tasks . isRunning ( ) , 'isRunning() returned false' ) ; assert . equal ( true , tasks . hasCompleted ( ) , 'hasCompleted() returned true' ) ; assert . equal ( true , tasks . hasExited ( ) , 'hasExited() returned true' ) ; return done ( ) ; }
function ( ) { assert . equal ( 1 , tasks . completed , 'only the expected number of tasks ran' ) ; assert . equal ( false , tasks . isRunning ( ) , 'isRunning() returned false' ) ; assert . equal ( false , tasks . hasCompleted ( ) , 'hasCompleted() returned true' ) ; assert . equal ( true , tasks . hasExited ( ) , 'hasExited() returned true' ) ; return done ( ) ; }
function ( ) { assert . equal ( 2 , tasks . completed , 'only the expected number of tasks ran' ) ; assert . equal ( false , tasks . isRunning ( ) , 'isRunning() returned false' ) ; assert . equal ( true , tasks . hasCompleted ( ) , 'hasCompleted() returned true' ) ; assert . equal ( true , tasks . hasExited ( ) , 'hasExited() returned true' ) ; return done ( ) ; }
function ( ) { assert . equal ( 2 , tasks . completed , 'only the expected number of tasks ran' ) ; assert . equal ( false , tasks . isRunning ( ) , 'isRunning() returned false' ) ; assert . equal ( true , tasks . hasCompleted ( ) , 'hasCompleted() returned true' ) ; assert . equal ( true , tasks . hasExited ( ) , 'hasExited() returned true' ) ; return done ( ) ; }
function ( ) { assert . equal ( 2 , finished , 'it exited the correct number of times' ) ; assert . equal ( false , tasks . isRunning ( ) , 'isRunning() returned false' ) ; assert . equal ( false , tasks . hasCompleted ( ) , 'hasCompleted() returned false' ) ; assert . equal ( false , tasks . hasExited ( ) , 'hasExited() returned false' ) ; return done ( ) ; }
function ( dateString ) { dateString = dateString . replace ( 'T' , ' ' ) ; dateString = dateString . replace ( 'Z' , '' ) ; var d = Date . parse ( dateString ) ; return d ; }
function ( eventInfo ) { console . log ( 'rendering eventView' ) ; var eventName = eventInfo . eventName ; var data = { 'info' : eventName } ; $ ( this . el ) . append ( this . template ( data ) ) ; return this . el ; }
function ( eventInfo ) { var tempEventView = new TimelineEventView ( eventInfo ) ; this . meta ( 'timelineEventViews' , [ tempEventView ] ) ; $ ( this . el ) . find ( '.eventInfos' ) . append ( tempEventView . el ) ; return this . el ; }
function ( eventInfo ) { console . log ( 'adding event from MonthView' ) ; var timelineItemViews = this . meta ( 'timelineItemViews' ) ; var tempItemView = new TimelineItemView ( eventInfo ) ; this . meta ( 'timelineItemViews' , timelineItemViews . push ( tempItemView ) ) ; $ ( this . el ) . append ( tempItemView . el ) ; }
function uploadDescriptions ( descriptionsFolder ) { var files = fs . readdirSync ( descriptionsFolder ) ; files . forEach ( function ( fileName , index , array ) { var fullFileName = descriptionsFolder + "\\" + fileName ; dprint ( "Uploading swarming:" + fileName ) ; var content = fs . readFileSync ( fullFileName ) ; redisClient . hset ( mkUri ( "system" , "code" ) , fileName , content ) ; } ) ; }
function ( ) { var brandbundle = document . getElementById ( "bundle_brand" ) ; if ( nightly . variables . name == null ) { nightly . variables . name = brandbundle . getString ( "brandShortName" ) ; } nightly . variables . defaulttitle = brandbundle . getString ( "brandShortName" ) ; nightly . variables . brandname = brandbundle . getString ( "brandFullName" ) ; var tabmail = document . getElementById ( "tabmail" ) ; if ( tabmail && typeof ( tabmail . setDocumentTitle ) === "function" ) { nightlyApp . savedTabmailSetDocumentTitle = tabmail . setDocumentTitle ; } }
function ( info , tab ) { var url = info . pageUrl ; var domain = getDomain ( url ) ; domain . replace ( '.' , '\\.' ) ; domain = '\\.?' + domain + '$' ; chrome . tabs . create ( { url : 'get.html#!/domain=' + domain } ) ; }
function ( newMode ) { this . _latestSourceMode = newMode ; this . switchDisplayMode ( newMode ) ; var sourceComboButtonNode = dojo . query ( '.maqSourceComboButton' ) ; if ( sourceComboButtonNode ) { var sourceComboButton = dijit . byNode ( sourceComboButtonNode [ 0 ] ) ; if ( sourceComboButton ) { sourceComboButton . set ( 'label' , veNls [ newMode ] ) ; } } }
function ( nmp ) { var mojits = me . _mojits , viewid = nmp . proxy . getId ( ) , binder = nmp . proxy . _binder , node = nmp . proxy . _node , elem = nmp . proxy . _element ; mojits [ viewid ] = { proxy : nmp . proxy , children : nmp . children , handles : bindNode ( binder , node , elem ) } ; recordBoundMojit ( mojits , parentId , viewid , nmp . proxy . type ) ; }
function AnimEn ( ) { this . domNode ; this . canvasNode ; this . gameLoopId ; this . activeScene = "defaultAnim" ; this . fps = 30 ; this . stage ; this . selectedObject ; this . animationMode ; this . animObjs = [ ] ; this . scenes = { } ; }
function ( Core , AnimEn , Sprite , CubicBezier ) { Core . init ( document . getElementById ( "engine" ) , "dom" , Core ) ; var test = new Sprite ( { x : 20 , y : 20 , resourceKey : "rect" } ) ; var test2 = new Sprite ( { x : 20 , y : 20 , resourceKey : "rect2" } ) ; test . addChild ( test2 ) ; AnimEn . getInst ( ) . initAnimation ( ) ; }
function ( ) { dojo . subscribe ( "/animwidget/initStage" , this , "onInitStage" ) ; dojo . subscribe ( "/sceneitem/activatescene" , this , "onActivateScene" ) ; dojo . subscribe ( "/sceneitem/deletescene" , this , "onDeleteScene" ) ; dojo . create ( "link" , { rel : "stylesheet" , href : "./widgets/templates/css/scenewidget.css" } , dojo . query ( "head" ) [ 0 ] ) ; this . scenes = AnimEn . getInst ( ) . getAllScenes ( ) ; }
function ( err , res ) { if ( err ) return error ( err ) ; data = [ ] ; _ . each ( res . rows , function ( val ) { data . push ( val . doc ) ; } ) ; success ( data ) ; }
function ( state ) { if ( state === $_ ) return ; game . Renderer . call ( this , state ) ; }
function ( event ) { if ( event . key == this . gameobjects [ 0 ] . Id ( ) ) this . text . Position ( this . gameobjects [ 0 ] . Position ( ) ) ; }
function ( gamestate ) { var g = gamestate . Get ( this . Id ( ) ) ; this . position_callback = function ( p ) { g . position = p ; } ; this . size_callback = function ( s ) { g . size = s ; } ; this . angle_callback = function ( a ) { g . angle = a ; } ; this . registration_flag = true ; }
function ( ) { html = "<div id='zeega-player'>" ; if ( this . zeega ) html += "<div id='preview-close' class='player-overlay'><a class='close' href='#'>&times;</a></div>" ; html += "<div id='preview-left' class='hidden preview-nav-arrow preview-nav'>" + "<div class='arrow-background'></div>" + "<img class='player-arrow arrow-left' src='" + sessionStorage . getItem ( 'hostname' ) + sessionStorage . getItem ( 'directory' ) + 'images/mediaPlayerArrow_shadow.png' + "'>" + "</div>" + "<div id='preview-right' class='hidden preview-nav-arrow preview-nav'>" + "<div class='arrow-background'></div>" + "<img class='player-arrow arrow-right' src='" + sessionStorage . getItem ( 'hostname' ) + sessionStorage . getItem ( 'directory' ) + 'images/mediaPlayerArrow_shadow.png' + "'>" + "</div>" + "<div id='preview-media'></div>" + "<div id='citation' class='player-overlay'><ul class='citation-list unstyled'></ul></div>" ; return html ; }
function ( ) { octopress . wrapFlashVideos ( ) ; octopress . testFeature ( [ 'maskImage' , 'transform' ] ) ; octopress . flashVideoFallback ( ) ; octopress . addCodeLineNumbers ( ) ; octopress . addMobileNav ( ) ; octopress . addSidebarToggler ( ) ; octopress . twitter . getFeed ( '#tweets' ) octopress . github . showRepos ( '#gh_repos' ) ; }
function ( ) { this . firstName = hb . observable ( "tim" ) ; this . lastName = hb . observable ( "schaffer" ) ; this . fullName = hb . computed ( function ( ) { return this . firstName + ' ' + lastName ; } , this ) ; }
function ( templateOrSelector , modelview ) { if ( ! _ . isFunction ( template ) ) { if ( _ . isString ( template ) ) { var source = $ ( 'script#' + templateOrSelector + '[type="text/x-handlebars"]' ) . html ( ) || templateOrSelector ; this . _template = Handlebars . compile ( source ) ; } else { this . _template = Handlebars . compile ( "<b>Invalid Template!</b>" ) ; } } this . context = new BindingContext ( modelview ) ; this . _attachedToDom = false ; }
function ( err , obj ) { var error ; if ( err ) next ( err ) ; else if ( ( error = obj . errors || obj . serverErrors || obj . warnings ) ) next ( new Error ( 'Failed to compile: ' + sys . inspect ( error ) ) ) ; else next ( null , obj . compiledCode ) ; }
function encodeResponseHeaders ( headers ) { var encodedHeaders = { } ; for ( var name in headers ) { var lname = name . toLowerCase ( ) ; var value = headers [ name ] ; if ( lname === 'location' ) { value = encodeUrl ( value ) ; } else if ( lname === 'set-cookie' ) { value = encodeCookie ( value ) ; } else if ( lname === 'status' ) { continue ; } encodedHeaders [ name ] = value ; } return encodedHeaders ; }
function generate_checkin_listing ( checkin ) { var listing = '<div id="check-in-id{0}" class="newsfeed-item">' + '<span class="item-title">{1} is at {2}</span>' + '<br>' + '<br>' + '<span class="item-text item-time" id="time-staying-id{3}"></span>' + '<button class="btn btn-primary order-button" data-toggle="modal" onClick="javascript:order_up({5})">OrderUp</button>' + '<span class="item-text item-price">${4}</span>' + '</div>' return listing . format ( checkin . id , checkin . user , checkin . name , checkin . id , checkin . fee , checkin . id ) ; }
function displayNotification ( ) { if ( window . webkitNotifications . checkPermission ( ) != 0 ) { getNotificationPermission ( ) ; setTimeout ( displayNotification , 5000 ) ; } else { notification = window . webkitNotifications . createNotification ( 'icon.png' , 'Notification Title' , 'Notification content...' ) ; notification . show ( ) ; } }
function ( aDocument , url ) { var ioService = Components . classes [ "@mozilla.org/network/io-service;1" ] . getService ( Components . interfaces . nsIIOService ) ; var baseUri = ioService . newURI ( aDocument . baseURI , aDocument . characterSet , null ) ; var uri = ioService . newURI ( url , aDocument . characterSet , baseUri ) ; this . _logger . debug ( "_applyBaseURI(" + aDocument . baseURI + ", " + url + ") = " + uri . spec ) ; return uri . spec ; }
function ( property , propertyValue , attributeValue ) { return [ 'The ‘' + property + '’ property must be a/an ‘' + attributeValue + '’.' , 'The type of the property is ‘' + detectType ( propertyValue ) + '’' ] . join ( ' ' ) ; }
function evaluatePostFix_inner ( token ) { if ( ! this . isOperator ( token ) ) { stack . push ( token ) ; } else { var op2 = stack . pop ( ) ; var op1 = stack . pop ( ) ; var result = this . evaluate [ token ] ( op1 , op2 ) ; if ( isNaN ( result ) || ! isFinite ( result ) ) throw { type : 'error' , msg : 'Value is ' + result } stack . push ( result ) ; } }
function ( config , core ) { this . host = config . host ; this . port = config . port ; this . password = config . password ; this . prefix = config . prefix || 'sentry' ; this . cache = config . cache ; this . core = core ; this . open ( ) ; }
function ( err , results ) { if ( err ) self . core . log . error ( { error : err , source : 'Redis getRule' } ) ; var tmp = [ ] ; for ( var x in results ) { var obj = JSON . parse ( results [ x ] ) ; if ( obj ) { tmp . push ( obj ) ; } } callback ( tmp ) ; }
function ( name , callback ) { var listenClient = new Redis ( this , this . core ) ; listenClient . client . on ( 'message' , function ( channel , message ) { callback ( message ) ; } ) ; listenClient . client . subscribe ( name ) ; }
function ( node ) { if ( node . type === 'VariableDeclarator' ) { node = node . id ; } var line = node . loc . start . line ; var column = node . loc . start . column ; if ( ! cache . variables [ line ] ) { cache . variables [ line ] = { } ; } cache . variables [ line ] [ column ] = node . name ; }
function ( ) { } , onPause : function ( ) { } , onStop : function ( ) { } , onSeek : function ( ) { } , onMute : function ( ) { } , onUnMute : function ( ) { } , onPlayerUnstarted : function ( ) { }
function ( ) { var scopeChain = trace . callFrames [ callFrameIndex ] . scopeChain ; for ( var i = 0 ; i < scopeChain . length ; i ++ ) { var vars = scopeChain [ i ] . resolved ; if ( vars && vars [ variable ] ) { return result . resolve ( vars [ variable ] ) ; } } result . reject ( ) ; }
function ( aWebProgress , aRequest , aLocation ) { this . securityDisplay . setAttribute ( 'label' , aLocation . host ) ; }
function ( task ) { var nextTask ; task . collection = this ; nextTask = this . at ( 0 ) ; if ( nextTask != null ) { nextTask . setPreviousTask ( task ) ; task . setNextTask ( nextTask ) ; } return this . view . addTaskLineAsFirstRow ( task ) ; }
function ( nextLineId ) { var cursorPosition ; cursorPosition = helpers . getCursorPosition ( this . descriptionField ) ; $ ( this . el ) . insertAfter ( $ ( "#" + nextLineId ) ) ; helpers . setCursorPosition ( this . descriptionField , cursorPosition ) ; return this . descriptionField . setCursorPosition ( cursorPosition ) ; }
function ( taskLine , options ) { var nextDescription , selector ; selector = "#" + taskLine . model . id ; nextDescription = $ ( selector ) . prev ( ) . find ( ".description" ) ; if ( nextDescription != null ) { return this . moveFocus ( taskLine . descriptionField , nextDescription , options ) ; } }
function ( taskLine , options ) { var nextDescription , selector ; selector = "#" + taskLine . model . id ; nextDescription = $ ( selector ) . next ( ) . find ( ".description" ) ; if ( nextDescription != null ) { return this . moveFocus ( taskLine . descriptionField , nextDescription , options ) ; } }
function ( previousNode , nextNode , options ) { var cursorPosition ; cursorPosition = previousNode . getCursorPosition ( ) ; nextNode . focus ( ) ; if ( ( ( options != null ? options . maxPosition : void 0 ) != null ) && options . maxPosition ) { return nextNode . setCursorPosition ( nextNode . text ( ) . length ) ; } else { return nextNode . setCursorPosition ( cursorPosition ) ; } }
function ( data ) { data . url = "tasks/" + data . id + "/" ; _this . tasks . add ( data ) ; $ ( ".task:first .description" ) . focus ( ) ; helpers . selectAll ( $ ( ".task:first .description" ) ) ; if ( ! _this . isEditMode ) { return $ ( ".task:first .task-buttons" ) . hide ( ) ; } else { return $ ( ".task:first .task-buttons" ) . show ( ) ; } }
function ( data ) { $ ( "#year" ) . empty ( ) ; $ ( "#year" ) . append ( '<option value="">Year</option>' ) ; $ . each ( data , function ( index , year ) { $ ( "#year" ) . append ( '<option value="' + year + '">' + year + '</option>' ) } ) ; clear_months ( ) ; clear_days ( ) ; $ ( 'form' ) . hideLoading ( ) ; }
function ( data ) { $ ( "#month" ) . empty ( ) ; $ ( "#month" ) . append ( '<option value="">Month</option>' ) ; $ . each ( data , function ( index , month ) { $ ( "#month" ) . append ( '<option value="' + month + '">' + months [ month - 1 ] + '</option>' ) } ) ; clear_days ( ) ; $ ( 'form' ) . hideLoading ( ) ; }
function ( data ) { $ ( "#day" ) . empty ( ) ; $ ( "#day" ) . append ( '<option value="">Day</option>' ) ; $ . each ( data , function ( index , day ) { $ ( "#day" ) . append ( '<option value="' + day + '">' + day + '</option>' ) } ) ; $ ( 'form' ) . hideLoading ( ) ; }
function ( ) { console . log ( "Pandora module starting up" ) ; $ ( LFM_WATCHED_CONTAINER ) . live ( 'DOMSubtreeModified' , function ( e ) { if ( $ ( LFM_WATCHED_CONTAINER ) . length > 0 ) { LFM_updateNowPlaying ( ) ; return ; } } ) ; $ ( window ) . unload ( function ( ) { chrome . extension . sendRequest ( { type : 'reset' } ) ; return true ; } ) ; LFM_updateNowPlaying ( ) ; }
function processAsyncMethodCallback ( value , error ) { if ( ! error ) { this . options . nonErrorCallCount ++ ; this . options . lastGet = new Date ( ) ; this . options . isRefreshing = false ; this . options . cachedValue = value ; } else { console . log ( 'error %s' , error ) ; } }
function ( error , response , body ) { if ( ! error && response . statusCode == 200 ) { var markdown = body . toString ( ) ; post . content_md = markdown ; post . content_html = md ( markdown ) ; callback ( ) ; } else { log ( 'populateBlogPostContent: error for %s, error = %s' , post . id , error ) ; callback ( error ) ; } }
function ( error , response , body ) { if ( ! error && response . statusCode === 200 ) { callback ( body ) ; } else { log ( "error getting JSON from %s: error: %s, statusCode: %s" , url , error , response . statusCode ) ; callback ( null , response . statusCode ) ; } }
function ( posts , error ) { if ( error ) { callback ( null , error ) ; } else { var viewModel = { posts : posts , shared : getSharedViewModel ( 'home' ) , title : 'Rarely updated' } ; callback ( viewModel ) ; } }
function getPostViewModel ( postId , callback ) { getIndexViewModel ( function ( indexViewModel ) { var post = _ . chain ( indexViewModel . posts ) . filter ( function ( post ) { return post . id == postId } ) . first ( ) . value ( ) ; var postViewModel = { title : post . title , post : post , shared : getSharedViewModel ( 'post' ) } ; callback ( postViewModel ) ; } ) ; }
function Reading ( ) { function Constructor ( ) { } function index ( req , res ) { s . getReadingListViewModel ( function ( model ) { res . render ( 'reading' , model ) ; } ) ; } ; Constructor . prototype = { index : index , } ; return Constructor ; }
function ( arg ) { if ( arg === 'video' ) { Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . VIDEO ) } else if ( arg === 'audio' ) { Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . AUDIO ) } else if ( arg === 'photo' ) { Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . PHOTO ) } }
function ( ) { if ( CONNECTED ) { offlineStore . removeAll ( ) ; down_store . each ( function ( record ) { offlineStore . add ( record ) ; offlineStore . sync ( ) ; } ) ; Ext . getCmp ( 'patientlistid' ) . setStore ( offlineStore ) ; } }
function ( ) { Ext . getCmp ( 'username' ) . reset ( ) ; Ext . getCmp ( 'password' ) . reset ( ) ; if ( USER . type === 'CHW' ) { this . doDownload ( ) ; Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . PATIENT_LIST ) } else if ( USER . type === 'VC' ) { Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . INBOX_VC ) } }
function ( personUuid , identifierType , location ) { var patient = Ext . create ( 'RaxaEmr.Pharmacy.model.Patient' , { person : personUuid , identifiers : [ { identifier : Util . getPatientIdentifier ( ) . toString ( ) , identifierType : identifierType , location : location , preferred : true } ] } ) ; var PatientStore = Ext . create ( 'RaxaEmr.Pharmacy.store.Patients' ) PatientStore . add ( patient ) ; PatientStore . sync ( ) ; return PatientStore }
function ( ) { var self = this ; if ( this . files . length > 0 ) { this . generateDoc ( this . files . shift ( ) , function ( ) { self . processNextFile ( ) ; } ) ; } else { this . copySharedResources ( ) ; } }
function ( err , outStat ) { if ( err && err . code == 'ENOENT' ) return callback ( true ) ; fs . stat ( file , function ( err , inStat ) { callback ( + inStat . mtime > + outStat . mtime ) ; } ) ; }
function ( ) { this . layer = $ ( "#CreateIssue" ) . find ( "input" ) [ 0 ] . value ; this . author = $ ( "#CreateIssue" ) . find ( "input" ) [ 1 ] . value ; this . title = $ ( "#CreateIssue" ) . find ( "input" ) [ 2 ] . value ; this . text = $ ( "#CreateIssue" ) . find ( "textarea" ) [ 0 ] . value ; }
function ( ) { var index = ++ this . currentIndex , item = this . _getCompositeValues ( ) ; this . currentValue [ index ] = item ; domConstruct . place ( this . collectionRowTemplate . apply ( item , this ) , this . collectionNode , 'last' ) ; domClass . add ( this . domNode , 'has-items' ) ; }
function ( ) { var id = ed . getParam ( 'wp_fullscreen_editor_id' ) || ed . getParam ( 'fullscreen_editor_id' ) || ed . id , link = tinymce . DOM . select ( '#wp-' + id + '-media-buttons a.thickbox' ) ; if ( link && link [ 0 ] ) link = link [ 0 ] ; else return ; tb_show ( '' , link . href ) ; tinymce . DOM . setStyle ( [ 'TB_overlay' , 'TB_window' , 'TB_load' ] , 'z-index' , '999999' ) ; }
function ( ) { if ( form_num > 0 ) { Ext . getCmp ( 'form' + form_num ) . remove ( { autoDestroy : true } ) ; Ext . getCmp ( 'form' + form_num ) . hide ( ) ; form_num -- ; } }
function ( ) { return ! store . isLoading ( ) ; }
function getHighlightedKeyIndexes ( ) { var highlighted = [ ] ; for ( var j = 0 ; j < allKeys . length ; j ++ ) { highlighted [ j ] = new Array ( ) ; for ( var i = 0 ; i < allKeys [ j ] . length ; i ++ ) { if ( allKeys [ j ] [ i ] . isClicked ) { highlighted [ j ] . push ( i ) ; } } } return highlighted ; }
function getClickedKey ( x , y ) { alert ( "x:" + x + " y:" + y ) ; var isClicked = testClickedKey ( blackKeys , x , y ) ; if ( ! isClicked ) { isClicked = testClickedKey ( whiteKeys , x , y ) ; } return isClicked ; }
function ( e ) { var x = e . offsetX , y = e . offsetY ; var output = '' ; var region = getClickedKey ( x , y ) ; if ( region ) { toggleKeyboardRegion ( region ) ; drawKeyboard ( canvasEl , context , divIndex ) ; } var indxStr = highlightedIndexArrayToString ( getHighlightedKeyIndexes ( ) , divIndex ) ; output += "Selected Indexes: " + indxStr ; canvasParaEl . innerHTML = output ; }
function ( ) { this . requestManager . removeCallback ( 'requestcomplete' , this . getTileComplete ( ) ) ; this . requestManager . addCallback ( 'requesterror' , this . getTileError ( ) ) ; this . provider = null ; if ( this . parent . parentNode ) { this . parent . parentNode . removeChild ( this . parent ) ; } this . map = null ; }
function ( ) { this . callParent ( arguments ) ; if ( this . getViews ( ) && Ext . isArray ( this . getViews ( ) ) && this . getViews ( ) . length > 0 ) { this . initViews ( ) ; } else { this . config . views = { } ; } this . initEvents ( ) ; }
function ( ) { var i = 0 , l = this . getViews ( ) . length , view , views = { } ; for ( ; i < l ; i ++ ) { view = this . getViews ( ) [ i ] ; views [ view . name ] = this . createView ( view ) ; } this . config . views = views ; }
function ( viewCfg ) { var existingView = this . getView ( viewCfg ) ; if ( existingView && existingView . name ) { console . log ( 'View with the name "' + viewCfg . name + '" already exists... overwriting.' ) } var newView = this . createView ( viewCfg ) ; this . getViews ( ) [ newView . name ] = newView ; return newView ; }
function ( ) { var views = this . getViews ( ) , view ; for ( var property in views ) { if ( views . hasOwnProperty ( property ) ) { view = views [ property ] ; this . refreshView ( view ) ; } } }
function ( ) { this . callParent ( arguments ) ; if ( this . getViews ( ) && Ext . isArray ( this . getViews ( ) ) && this . getViews ( ) . length > 0 ) { this . initViews ( ) ; } else { this . config . views = { } ; } this . initEvents ( ) ; }
function ( ) { var i = 0 , l = this . getViews ( ) . length , view , views = { } ; for ( ; i < l ; i ++ ) { view = this . getViews ( ) [ i ] ; views [ view . name ] = this . createView ( view ) ; } this . config . views = views ; }
function ( viewCfg ) { var existingView = this . getView ( viewCfg ) ; if ( existingView && existingView . name ) { console . log ( 'View with the name "' + viewCfg . name + '" already exists... overwriting.' ) } var newView = this . createView ( viewCfg ) ; this . getViews ( ) [ newView . name ] = newView ; return newView ; }
function ( ) { var views = this . getViews ( ) , view ; for ( var property in views ) { if ( views . hasOwnProperty ( property ) ) { view = views [ property ] ; this . refreshView ( view ) ; } } }
function ( ) { var store = me . createStore ( [ { name : 'View1' , filterFn : Ext . emptyFn } , { name : 'View2' , filterFn : Ext . emptyFn } ] ) ; expect ( Ext . isObject ( store . getViews ( ) ) ) . toEqual ( true ) ; expect ( store . getViews ( ) . View1 ) . toBeDefined ( ) ; expect ( store . getViews ( ) . View2 ) . toBeDefined ( ) ; }
function compress ( code ) { var ast = jsp . parse ( code ) ; ast = pro . ast_mangle ( ast ) ; ast = pro . ast_squeeze ( ast , { no_warnings : true } ) ; ast = pro . ast_squeeze_more ( ast ) ; return pro . gen_code ( ast ) ; }
function ( Tweenable , Underscore ) { var underscoreSupportsAMD = ( Underscore !== null ) ; var deps = { Tweenable : Tweenable , underscore : underscoreSupportsAMD ? Underscore : _ } ; var Kapi = rekapi ( global , deps ) ; if ( typeof KAPI_DEBUG !== 'undefined' && KAPI_DEBUG === true ) { Kapi . underscore_version = deps . underscore . VERSION ; } if ( ! underscoreAlreadyInUse && underscoreSupportsAMD ) { global . _ = undefined ; } return Kapi ; }
function next ( ) { S . prev = S . token ; if ( S . peeked ) { S . token = S . peeked ; S . peeked = null ; } else { S . token = S . input ( ) ; } return S . token ; }
function ( ) { ++ S . in_function ; var loop = S . in_loop ; S . in_loop = 0 ; var a = block_ ( ) ; -- S . in_function ; S . in_loop = loop ; return a ; }
function ( num ) { var ret = "" , base = 54 ; do { ret += DIGITS . charAt ( num % base ) ; num = Math . floor ( num / base ) ; base = 64 ; } while ( num > 0 ) ; return ret ; }
function ( ) { var DIGITS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789" ; return function ( num ) { var ret = "" , base = 54 ; do { ret += DIGITS . charAt ( num % base ) ; num = Math . floor ( num / base ) ; base = 64 ; } while ( num > 0 ) ; return ret ; } ; }
function ( s ) { switch ( s ) { case "\\" : return "\\\\" ; case "\b" : return "\\b" ; case "\f" : return "\\f" ; case "\n" : return "\\n" ; case "\r" : return "\\r" ; case "\u2028" : return "\\u2028" ; case "\u2029" : return "\\u2029" ; case '"' : ++ dq ; return '"' ; case "'" : ++ sq ; return "'" ; case "\0" : return "\\0" ; } return s ; }
function ( expr ) { var out = make ( expr ) , i = 1 ; if ( expr [ 0 ] == "num" ) { if ( ! /\./ . test ( expr [ 1 ] ) ) out += "." ; } else if ( expr [ 0 ] != "function" && needs_parens ( expr ) ) out = "(" + out + ")" ; while ( i < arguments . length ) out += "." + make_name ( arguments [ i ++ ] ) ; return out ; }
function ( plan_err , plan ) { var d = new Date ( ) ; stripe . customers . create ( { email : "foo@example.com" , plan : plan . id , card : { number : "4111111111111111" , exp_month : d . getMonth ( ) + 1 , exp_year : d . getFullYear ( ) + 1 , name : "T. Ester" } } , this . callback ) ; }
function ( event ) { var widget = new models . Widget ( { dashboard_id : this . model . id , kind : 'number' } ) ; var dialog = new views . WidgetEditor . Number ( { model : widget , dashboard : this . model , widgetCollection : this . collection } ) ; this . $ ( "#widget-dialog" ) . html ( dialog . render ( ) . el ) ; return false ; }
function ( event ) { var widget = new models . Widget ( { dashboard_id : this . model . id , kind : 'boolean' } ) ; var dialog = new views . WidgetEditor . Boolean ( { model : widget , dashboard : this . model , widgetCollection : this . collection } ) ; this . $ ( "#widget-dialog" ) . html ( dialog . render ( ) . el ) ; return false ; }
function ( ) { var size = this . _textureAtlas . getTexture ( ) . getContentSize ( ) ; this . _itemsPerColumn = parseInt ( size . height / this . _itemHeight ) ; this . _itemsPerRow = parseInt ( size . width / this . _itemWidth ) ; }
function ( ) { if ( cc . NODE_TRANSFORM_USING_AFFINE_MATRIX ) { this . _isTransformGLDirty = true ; } this . _anchorPoint = new cc . Point ( 0 , 0 ) ; this . _anchorPointInPoints = new cc . Point ( 0 , 0 ) ; this . _contentSize = new cc . Size ( 0 , 0 ) ; var director = cc . Director . sharedDirector ( ) ; this . _actionManager = director . getActionManager ( ) ; this . _scheduler = director . getScheduler ( ) ; }
function ( charID , rect , xOffset , yOffset , xAdvance ) { this . charID = charID || 0 ; this . rect = rect || new cc . RectMake ( 0 , 0 , 10 , 10 ) ; this . xOffset = xOffset || 0 ; this . yOffset = yOffset || 0 ; this . xAdvance = xAdvance || 0 ; }
function ( ) { var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; var center = cc . LabelTTF . create ( "word wrap \"testing\" (bla0) bla1 'bla2' [bla3] (bla4) {bla5} {bla6} [bla7] (bla8) [bla9] 'bla0' \"bla1\"" , cc . SizeMake ( s . width / 2 , 200 ) , cc . TEXT_ALIGNMENT_CENTER , "Marker Felt" , 32 ) ; center . setPosition ( cc . ccp ( s . width / 2 , 150 ) ) ; this . addChild ( center ) ; }
function ( n ) { function _hide_field ( n , hidden ) { cur_frm . set_df_property ( n , 'hidden' , hidden ) } if ( cur_frm ) { if ( typeof n == 'string' ) _hide_field ( n , 1 ) ; else { for ( var i in n ) _hide_field ( n [ i ] , 1 ) } } }
function ( ) { if ( this . in_filter ) return ; if ( this . df . reqd ) { if ( this . label_area ) this . label_area . style . color = "#d22" ; this . set_style_mandatory ( 1 ) ; } else { if ( this . label_area ) this . label_area . style . color = "#222" ; this . set_style_mandatory ( 0 ) ; } this . refresh_label_icon ( ) this . set_reqd = this . df . reqd ; }
function ( err , result ) { if ( err ) { console . log ( _this . config . identity + ": RespondDecisionTaskCompleted error" , err , result ) ; } if ( cb ) cb ( ) ; }
function ( decisions , cb ) { var _this = this ; console . log ( _this . config . identity + ": RespondDecisionTaskCompleted... " ) ; this . swfClient . RespondDecisionTaskCompleted ( { "taskToken" : _this . config . taskToken , "decisions" : decisions } , function ( err , result ) { if ( err ) { console . log ( _this . config . identity + ": RespondDecisionTaskCompleted error" , err , result ) ; } if ( cb ) cb ( ) ; } ) ; }
function ( data ) { if ( data . isError ) { recordEditor . events . onError . fire ( data , "save" ) ; return ; } if ( ! recordEditor . model . csid ) { recordEditor . events . afterCreate . fire ( data ) ; } recordEditor . applier . requestChange ( "" , data ) ; recordEditor . globalModel . requestChange ( recordEditor . options . globalRef , data ) ; recordEditor . events . afterSave . fire ( ) ; }
function ( ) { var that = this ; var eventsNames = [ 'click' , 'dblclick' , 'mousedown' , 'mousemove' , 'mouseout' , 'mouseover' , 'mouseup' , 'rightclick' ] ; eventsNames . forEach ( function ( eventName , index , orig ) { google . maps . event . addListener ( that . overlay_ , eventName , function ( e , args ) { komoo . event . trigger ( that , eventName , e , args ) ; } ) ; } ) ; }
function ( ) { return this . feature_ ? this . feature_ . getDefaultZIndex ( ) : komoo . geometries . defaults . ZINDEX ; }
function ( ) { throw new Error ( 'Not Implemented' ) ; }
function ( pos ) { if ( ! pos ) return null ; var that = this ; var pos_ = [ ] ; pos . forEach ( function ( p , index , orig ) { pos_ . push ( that . getLatLngFromArray ( p ) ) ; } ) ; return pos_ ; }
function ( latLngs ) { if ( ! latLngs ) return null ; var that = this ; var latLngs_ = [ ] ; latLngs . forEach ( function ( latLng , index , orig ) { latLngs_ . push ( that . getArrayFromLatLng ( latLng ) ) ; } ) ; return latLngs_ ; }
function ( coordinates ) { var that = this ; var coords = coordinates ; if ( ! coords [ 0 ] . pop ) coords = [ coords ] ; this . _guaranteePoints ( coords . length ) ; this . bounds_ = undefined ; this . getPoints ( ) . forEach ( function ( point , index , orig ) { point . setPosition ( that . getLatLngFromArray ( coords [ index ] ) ) ; } ) ; komoo . event . trigger ( this , 'coordinates_changed' ) ; }
function ( ) { var that = this ; var coords = [ ] ; this . getPoints ( ) . forEach ( function ( point , index , orig ) { coords . push ( that . getArrayFromLatLng ( point . getPosition ( ) ) ) ; } ) ; return coords ; }
function ( opts ) { komoo . geometries . Geometry . call ( this , opts ) ; this . geometryType_ = komoo . GeometryType . POLYLINE ; }
function ( opts ) { var options = opts || { clickable : true , zIndex : this . getDefaultZIndex ( ) , strokeColor : this . getBorderColor ( ) , strockOpacity : this . getBorderOpacity ( ) , strokeWeight : this . getBorderSize ( ) } ; this . setOverlay ( new google . maps . Polyline ( options ) ) ; }
function ( ) { var that = this ; komoo . event . addListener ( this , 'mousemove' , function ( e ) { that . setOptions ( { strokeWeight : 2.5 } ) ; } ) ; komoo . event . addListener ( this , 'mouseout' , function ( e ) { that . setOptions ( { strokeWeight : that . getBorderSize ( ) } ) ; } ) ; }
function ( pos , index_ , orig_ ) { path . push ( that . getLatLngFromArray ( pos ) ) ; }
function ( ) { var that = this ; var coords = [ ] ; this . getPaths ( ) . forEach ( function ( path , i ) { var subCoords = [ ] ; path . forEach ( function ( latLng , j ) { subCoords . push ( that . getArrayFromLatLng ( latLng ) ) ; } ) ; if ( subCoords . length ) subCoords . push ( subCoords [ 0 ] ) ; coords . push ( subCoords ) ; } ) ; return coords ; }
function ( paths ) { if ( paths . length != this . polylines_ . getLength ( ) ) { throw "Invalid length." ; } this . paths_ . clear ( ) ; for ( var i = 0 ; i < this . polylines_ . getLength ( ) ; i ++ ) { this . polyliness_ . getAt ( i ) . setPath ( paths [ i ] ) ; this . paths_ . push ( paths [ i ] ) ; } }
function next ( ) { S . prev = S . token ; if ( S . peeked ) { S . token = S . peeked ; S . peeked = null ; } else { S . token = S . input ( ) ; } return S . token ; }
function ( ) { ++ S . in_function ; var loop = S . in_loop ; S . in_loop = 0 ; var a = block_ ( ) ; -- S . in_function ; S . in_loop = loop ; return a ; }
function ( store ) { try { var visits = store . get ( 'visits' ) || 0 ; visits = visits + 1 ; if ( visits <= 10 ) { store . set ( 'visits' , visits ) ; if ( visits === 10 ) { $ ( '#social' ) . modal ( ) ; } } } catch ( e ) { } ; }
function ( time , callback ) { if ( this . popcornPlayer ) this . popcornPlayer . cue ( time , callback ) ; }
function ( cleanup ) { var i ; if ( this . _descendants && this . _descendants . length > 0 ) { for ( i = 0 ; i < this . _descendants . length ; i ++ ) { if ( this . _descendants [ i ] ) { this . _descendants . setBatchNode ( null ) ; } } } this . _super ( cleanup ) ; this . _descendants = [ ] ; this . _textureAtlas . removeAllQuads ( ) ; }
function handleKeyEvent ( editor , event ) { if ( editor . getModeForSelection ( ) !== "html" ) { return ; } if ( event . type === "keydown" && event . keyCode === 32 && event . ctrlKey ) { _showHint ( editor ) ; event . preventDefault ( ) ; } else if ( event . type === "keyup" && event . keyCode === 188 ) { _showHint ( editor ) ; } if ( hintList && hintList . isOpen ( ) ) { hintList . handleKeyEvent ( editor , event ) ; } }
function addToWorkingSetAndSelect ( fullPath ) { var result = new $ . Deferred ( ) , promise = CommandManager . execute ( Commands . FILE_ADD_TO_WORKING_SET , { fullPath : fullPath } ) ; promise . done ( function ( doc ) { _fileSelectionFocus = WORKING_SET_VIEW ; _selectCurrentDocument ( ) ; result . resolve ( doc ) ; } ) . fail ( function ( err ) { result . reject ( err ) ; } ) ; return result . promise ( ) ; }
function removePopUp ( $popUp ) { var idx = _popUps . indexOf ( $popUp [ 0 ] ) , initiallyInDOM = $popUp . data ( "initiallyInDOM" ) , removeHandler = $popUp . data ( "removeHandler" ) ; _removePopUp ( $popUp ) ; if ( idx >= 0 ) { _popUps = _popUps . slice ( idx ) ; } }
function ( dirname ) { var fs = require ( 'fs' ) , files = fs . readdirSync ( dirname ) , self = this ; if ( ! path . existsSync ( dirname ) ) { throw new Error ( 'Directory ' + dirname + ' doesn\'t exist' ) ; } files . forEach ( function ( filename ) { self . _loadFile ( path . join ( dirname , filename ) ) ; } ) ; }
function ( source , target , t , result ) { goog . vec . Vec3 . lerp ( this . getter_ . call ( source ) , this . getter_ . call ( target ) , t , this . getter_ . call ( result ) ) ; }
function ( target , reader ) { if ( this . normalized_ ) { var q = this . getter_ . call ( target ) ; reader . readVec3 ( q ) ; q [ 3 ] = Math . sqrt ( 1 - q [ 0 ] * q [ 0 ] + q [ 1 ] * q [ 1 ] + q [ 2 ] * q [ 2 ] ) ; } else { reader . readVec4 ( this . getter_ . call ( target ) ) ; } }
function ( source , target , t , result ) { goog . vec . Quaternion . slerp ( this . getter_ . call ( source ) , this . getter_ . call ( target ) , t , this . getter_ . call ( result ) ) ; }
function ( count , path ) { console . log ( count ) ; if ( count <= 0 ) { newPlay . redirectToMap ( path ) ; } else { $ ( '.redirect-countdown' ) . text ( count ) ; setTimeout ( 'newPlay.redirectToMapCountdown(' + count + ')' , 1000 ) ; count -- ; } }
function ( display , window ) { if ( ! window || window . has_focus ( ) || window . is_skip_taskbar ( ) || window . get_wm_class ( ) == "Skype" ) return ; if ( this . _tracker . is_window_interesting ( window ) ) { window . activate ( global . get_current_time ( ) ) ; } }
function getDescription ( mdown , fromIndex ) { var desc = mdown . substr ( fromIndex ) ; desc = desc . replace ( /^\n+/g , '' ) . split ( /\n\n/ ) [ 0 ] ; if ( ( /^(?:(?:[#=]+)|(?:[\-`\=]{3,})|(?: {4,}))/ ) . test ( desc ) ) { return null ; } desc = showdown . parse ( desc . replace ( /\n+/ , ' ' ) ) . replace ( /<\/?p>/g , '' ) . replace ( /<\/?a[^>]*>/g , '' ) ; return desc ; }
function ( pin ) { Log ( 'debug' , "Pin removed" ) ; _markers [ pin . Uid ] . setMap ( null ) ; delete _markers [ pin . Uid ] ; }
function ( marker ) { iw . setContent ( marker . desc ) ; iw . open ( _map , marker ) ; var pin = _this . Pins . getPinRef ( marker . markerID ) ; pin . onClick . apply ( ) ; }
function ( err , icon ) { if ( err ) { return write404 ( req , res , err ) ; } console . log ( "Favicon requested" ) ; res . writeHead ( 200 , { "Content-Type" : "image/x-icon" } ) ; res . end ( icon ) ; }
function ( event , target ) { event . stopEvent ( ) ; this . restoreSelection ( ) ; var entity = Ext . get ( target ) . dom . innerHTML ; this . insertEntity ( entity ) ; if ( Ext . isIE ) { this . saveSelection ( ) ; } return false ; }
function ( entity ) { if ( Ext . isIE ) { this . editor . getSelection ( ) . insertHtml ( entity ) ; } else { var node = this . editor . document . createTextNode ( ( ( Ext . isGecko || Ext . isWebKit ) && entity == '&nbsp;' ) ? '\xA0' : entity ) ; this . editor . getSelection ( ) . insertNode ( node ) ; this . editor . getSelection ( ) . selectNode ( node , false ) ; } }
function clearClass ( node ) { var newc = node . className . replace ( /(^|\s)mso.*?(\s|$)/ig , ' ' ) ; if ( newc != node . className ) { node . className = newc ; if ( ! /\S/ . test ( node . className ) ) { if ( ! Ext . isOpera ) { node . removeAttribute ( 'class' ) ; if ( Ext . isIE ) { node . removeAttribute ( 'className' ) ; } } else { node . className = '' ; } } } }
function stripTag ( el ) { if ( Ext . isIE ) { el . outerHTML = HTMLArea . util . htmlEncode ( el . innerText ) ; } else { var txt = document . createTextNode ( HTMLArea . DOM . getInnerText ( el ) ) ; el . parentNode . insertBefore ( txt , el ) ; el . parentNode . removeChild ( el ) ; } }
function ( callback ) { var _ready = globals . jQuery . ready ; globals . jQuery . ready = function ( ) { if ( globals . jQuery . readyWait === 1 && globals . jQuery . isReady || globals . jQuery . readyWait === 2 && ! globals . jQuery . isReady ) { callback ( ) ; } return _ready . apply ( this , arguments ) ; } }
function ( ) { globals . jQuery . readyWait = 1 ; globals . jQuery . isReady = true ; globals . document . addEventListener . mostRecentCall . args [ 1 ] ( ) ; expect ( listener ) . not . toHaveBeenCalled ( ) ; globals . jQuery . ready ( ) ; expect ( listener ) . toHaveBeenCalled ( ) ; }
function ( ) { globals . jQuery . readyWait = 2 ; globals . jQuery . isReady = false ; globals . document . addEventListener . mostRecentCall . args [ 1 ] ( ) ; expect ( listener ) . not . toHaveBeenCalled ( ) ; globals . jQuery . ready ( ) ; expect ( listener ) . toHaveBeenCalled ( ) ; }
function ( ) { execCb = jasmine . createSpy ( 'execCb' ) ; reqContext = { execCb : execCb , registry : { someModId : { } } } ; globals . require = function ( ) { } ; globals . require . s = { contexts : { '_' : reqContext } } ; ready = jasmine . createSpy ( 'ready' ) ; globals . jQuery = { readyWait : 0 , ready : ready } ; listener = jasmine . createSpy ( 'listener' ) ; loadEventSupport . addBeforeLoadListener ( listener ) ; }
function ( ) { globals . jQuery . readyWait = 1 ; globals . jQuery . isReady = true ; globals . document . addEventListener . mostRecentCall . args [ 1 ] ( ) ; expect ( listener ) . not . toHaveBeenCalled ( ) ; reqContext . execCb ( 'someModId' ) ; expect ( execCb ) . toHaveBeenCalledWith ( 'someModId' ) ; expect ( listener ) . not . toHaveBeenCalled ( ) ; globals . jQuery . ready ( ) ; expect ( listener ) . toHaveBeenCalled ( ) ; }
function ( input , start , end ) { if ( typeof end == 'undefined' ) end = start ; if ( input . setSelectionRange ) { input . setSelectionRange ( start , end ) ; } else { var range = input . createTextRange ( ) ; range . collapse ( ) ; range . moveStart ( 'character' , start ) ; range . moveEnd ( 'character' , end - start ) ; range . select ( ) ; } }
function ( input , start , end ) { if ( typeof end == 'undefined' ) end = start ; if ( input . setSelectionRange ) { input . setSelectionRange ( start , end ) ; } else { var range = input . createTextRange ( ) ; range . collapse ( ) ; range . moveStart ( 'character' , start ) ; range . moveEnd ( 'character' , end - start ) ; range . select ( ) ; } }
function ( ) { mplayer . stdin . write ( "loadfile \"" + path + "\"\n" ) ; paused = false ; eventEmitter . emit ( 'paused' , paused ) ; if ( volume > 0 ) { mplayer . stdin . write ( "set_property volume " + volume + "\n" ) ; } eventEmitter . emit ( 'playing' , ! paused ) ; }
function ( ) { this . accounts = ko . observableArray ( [ ] ) ; this . selectedAccount = ko . observable ( ) ; this . campaigns = ko . observableArray ( [ ] ) ; this . selectedCampaign = ko . observable ( ) ; }
function Thanks ( ) { comments = $ ( "#feedback" ) . val ( ) ; $ . post ( "core/DataWrangler.php" , { "page" : "comments" , "twitid" : twitid , "comments" : comments } ) ; $ ( "#feedback_h" ) . hide ( ) ; $ ( "#GetFeedback-wrapper" ) . hide ( 500 ) ; $ ( "#thanks" ) . show ( 500 ) ; finished = true ; }
function ( id , context ) { var html = $ ( id ) . html ( ) ; return _ . template ( html , context ) ; }
function ( event ) { event . preventDefault ( ) ; if ( slideControls . pauseResume . find ( '[data-slice-slide-playing]' ) . length > 0 ) { fn . pauseSlide ( interval , slideControls ) ; } else { slideControls . pauseResume . html ( fn . tmpl ( op . templateControlsPlaying , { text : fn . culture } ) ) ; fn . resumeSlide ( slidesBox , slideControls ) ; } }
function ( ) { body = JSON . parse ( body ) ; test . ok ( body . errorcode === 0 && body . question . user === userUid && body . question . title === updatedQuestionBody ) ; test . done ( ) ; }
function ( err , links ) { should . not . exist ( err ) ; should . exist ( links ) ; links . should . be . a ( "array" ) ; links . should . have . length ( 0 ) ; done ( ) ; }
function ( err , links ) { should . not . exist ( err ) ; should . exist ( links ) ; links . should . be . a ( "array" ) ; links . should . have . length ( 3 ) ; links . should . include ( "http://geo.example.com/user2" ) ; links . should . include ( "http://user2.example.net/blog" ) ; links . should . include ( "http://video.example.com/user2" ) ; done ( ) ; }
function ( opd , k , e ) { xe = extend ( e ) ; bind ( xe , fun . formal , opd ) ; bind ( xe , fun . eformal , e ) ; return perform ( fun . body , k , xe ) }
function showMapDirectPopup ( ) { if ( typeof mapDirect != 'undefined' ) { if ( markerFeatures [ mapDirect ] . popup == null ) fillPopup ( markerFeatures [ mapDirect ] ) ; if ( ! markerFeatures [ mapDirect ] . popup . visible ( ) ) showPopup ( markerFeatures [ mapDirect ] . popup ) mapDirect = undefinecheckBuildingInArrayd ; } }
function ( ) { if ( this . editor . id == 'mce_fullscreen' ) win . zIndexManager . setBase ( 200000 ) ; if ( s . left && s . top ) win . setPagePosition ( s . left , s . top ) ; var pos = win . getPosition ( ) ; s . left = pos [ 0 ] ; s . top = pos [ 1 ] ; this . onOpen . dispatch ( this , s , p ) ; }
function update_badge ( data ) { if ( ! get_config ( "tooltip" ) ) return ; var jscount = data . js . length ; var csscount = data . css . length ; chrome . browserAction . setBadgeText ( { "text" : "" + jscount + " " + csscount } ) ; }
function ( request , sender , sendResponse ) { var data = build_response ( get_js ( ) , get_css ( ) ) ; data . html = [ { "inline" : get_dom ( ) , "count" : document . all . length } ] ; sendResponse ( data ) ; }
function ( ) { var a = $ ( this ) ; if ( a . attr ( "href" ) != '#' ) return true ; var li = a . closest ( "li" ) ; $ ( "ol>li" ) . removeClass ( "sel" ) ; li . addClass ( "sel" ) ; show_src ( li ) ; return false ; }
function emphasize_name ( url ) { var len = url . length ; var i = url . lastIndexOf ( "/" ) ; var s ; if ( i == len - 1 ) return url ; else if ( i < 0 ) return "<b>" + url + "</b>" ; else return url . substr ( 0 , i + 1 ) + "<b>" + url . substr ( i + 1 ) + "</b>" ; }
function ( event ) { websocket . state = WebSocketsWorking ; websocket . keepAlive = setInterval ( function ( ) { if ( ws . readyState == 1 ) ws . send ( '&signal=none' ) ; else { clearInterval ( websocket . keepAlive ) ; websocket . keepAlive = null ; } } , 3 * _$_SERVER_PUSH_TIMEOUT_$_ ) ; }
function ( selfElement , data ) { if ( self . initialised && self . linkToPassage ) { self . onLoad ( ) ; } }
function ( ) { var reference = this . passages [ this . passageId ] . getReference ( ) ; var self = this ; $ . getSafe ( TIMELINE_GET_EVENTS_FROM_REFERENCE + reference , function ( data , url ) { if ( data . suggestedDate ) { self . tl . getBand ( 0 ) . setCenterVisibleDate ( Timeline . DateTime . parseIso8601DateTime ( data . suggestedDate ) ) ; self . addMultipleEventsAndRefresh ( data ) ; } self . showVisibleEvents ( self . tl . getBand ( 0 ) ) ; } ) ; }
function ( ) { $ ( 'body' ) . data ( this . app . _location_proxy . data_name , '#/zuh' ) equal ( this . app . _location_proxy . getLocation ( ) , '#/zuh' ) ; this . app . _location_proxy . setLocation ( '#/boosh' ) ; equal ( '#/boosh' , this . app . _location_proxy . getLocation ( ) ) ; }
function ( ) { $ . removeData ( $ ( 'body' ) [ 0 ] , this . app . _location_proxy . data_name ) ; equal ( null , $ ( 'body' ) . data ( this . app . _location_proxy . data_name ) ) ; equal ( '' , this . app . _location_proxy . getLocation ( ) ) ; }
function ( runtime , session , observerCtor ) { goog . base ( this , runtime , 2 ) ; this . session_ = session ; this . observerCtor_ = observerCtor_ ; this . netService_ = new gf . sim . ServerSimulator . NetService_ ( this , session ) ; this . registerDisposable ( this . netService_ ) ; this . observers_ = [ ] ; this . userObservers_ = { } ; this . cleanupCommandList_ = new gf . sim . util . CommandList ( ) ; }
function ( observer ) { goog . asserts . assert ( ! goog . array . contains ( this . observers_ , observer ) ) ; this . observers_ . push ( observer ) ; var user = observer . user ; if ( user ) { this . userObservers_ [ user . sessionId ] = observer ; } }
function ( observer ) { var user = observer . user ; if ( user ) { delete this . userObservers_ [ user . sessionId ] ; } goog . array . remove ( this . observers_ , observer ) ; goog . dispose ( observer ) ; }
function ( frame ) { for ( var n = 0 ; n < this . observers_ . length ; n ++ ) { var observer = this . observers_ [ n ] ; observer . executeIncomingCommands ( ) ; } this . getScheduler ( ) . update ( frame ) ; this . postTickUpdateEntities ( frame ) ; this . postUpdate ( frame ) ; this . compact_ ( ) ; }
function ( command , opt_excludeUser ) { for ( var n = 0 ; n < this . observers_ . length ; n ++ ) { var observer = this . observers_ [ n ] ; if ( opt_excludeUser && observer . user == opt_excludeUser ) { continue ; } observer . queueOutgoingCommand ( command ) ; } this . cleanupCommandList_ . addCommand ( command ) ; }
function ( frame ) { for ( var n = 0 ; n < this . observers_ . length ; n ++ ) { var observer = this . observers_ [ n ] ; observer . flush ( frame . time ) ; } this . cleanupCommandList_ . releaseAllCommands ( this ) ; goog . base ( this , 'postUpdate' , frame ) ; }
function ( ) { if ( frame . time - this . lastCompactTime_ < gf . sim . ServerSimulator . COMPACT_INTERVAL_ ) { return ; } this . lastCompactTime_ = frame . time ; this . cleanupCommandList_ . compact ( ) ; for ( var n = 0 ; n < this . observers_ . length ; n ++ ) { var observer = this . observers_ [ n ] ; observer . compact ( ) ; } }
function ( user ) { var observer = this . simulator_ . getObserverForUser ( user ) ; if ( observer ) { return ; } observer = new this . simulator_ . observerCtor_ ( this . session_ , user ) ; this . simulator_ . addObserver ( observer ) ; }
function ( runtime , baseEntityId ) { goog . base ( this , runtime ) ; this . scheduler_ = new gf . sim . Scheduler ( runtime ) ; this . registerDisposable ( this . scheduler_ ) ; this . commandTypes_ = { } ; this . entityTypes_ = { } ; this . nextEntityId_ = baseEntityId ; this . entities_ = { } ; this . dirtyEntities_ = new Array ( 128 ) ; this . dirtyEntitiesLength_ = 0 ; }
function ( frame ) { for ( var n = 0 ; n < this . dirtyEntitiesLength_ ; n ++ ) { var entity = this . dirtyEntities_ [ n ] ; entity . postTickUpdate ( frame ) ; this . postTickUpdateEntity ( frame , entity ) ; } }
function ( frame ) { for ( var n = 0 ; n < this . dirtyEntitiesLength_ ; n ++ ) { var entity = this . dirtyEntities_ [ n ] ; this . dirtyEntities_ [ n ] = null ; entity . resetDirtyState ( ) ; } this . dirtyEntitiesLength_ = 0 ; }
function ( a , b ) { var frequentA = a & gf . sim . VariableFlag . UPDATED_FREQUENTLY ; var frequentB = b & gf . sim . VariableFlag . UPDATED_FREQUENTLY ; return ( frequentA - frequentB ) || ( a . ordinal - b . ordinal ) ; }
function ( simulator , entityType , entityId , entityFlags ) { goog . base ( this , simulator , entityType , entityId , entityFlags , stateType ) ; this . networkState = entityType . allocateState ( ) ; this . previousStates = [ ] ; this . state = ( entityFlags & ( gf . sim . EntityFlag . INTERPOLATED | gf . sim . EntityFlag . PREDICTED ) ) ? entityType . allocateState ( ) : this . networkState ; }
function ( ) { this . entityType . releaseState ( this . networkState ) ; for ( var n = 0 ; n < this . previousStates . length ; n ++ ) { this . entityType . releaseState ( this . previousStates [ n ] ) ; } if ( entityFlags & ( gf . sim . EntityFlag . INTERPOLATED | gf . sim . EntityFlag . PREDICTED ) ) { this . entityType . releaseState ( this . state ) ; } goog . base ( this , 'disposeInternal' ) ; }
function ( command ) { if ( command instanceof gf . sim . commands . ReparentCommand ) { this . setParent ( command . parentId ) ; } }
function ( frame ) { this . interpolateEntities ( frame . time ) ; this . executeCommands ( this . incomingCommandList_ . getArray ( ) , this . incomingCommandList_ . getCount ( ) ) ; this . incomingCommandList_ . releaseAllCommands ( ) ; this . getScheduler ( ) . update ( frame ) ; this . postTickUpdateEntities ( frame ) ; this . sendPendingCommands_ ( frame ) ; this . postUpdate ( frame ) ; this . compact_ ( ) ; }
function ( ) { if ( frame . time - this . lastCompactTime_ < gf . sim . ClientSimulator . COMPACT_INTERVAL_ ) { return ; } this . lastCompactTime_ = frame . time ; this . incomingCommandList_ . compact ( ) ; this . outgoingCommandList_ . compact ( ) ; }
function ( ) { if ( this . unusedCommands_ . length ) { var command = this . unusedCommands_ . pop ( ) ; command . targetEntityId = gf . sim . NO_ENTITY_ID ; return command ; } else { return new this . commandCtor_ ( ) ; } }
function ( command ) { this . incomingCommandList_ . addCommand ( command ) ; if ( command instanceof gf . sim . PredictedCommand ) { goog . asserts . assert ( sequence > this . confirmedSequence_ ) ; observer . confirmSequence ( command . sequence ) ; this . confirmedSequence_ = sequence ; } }
function ( list , e ) { var left = 0 ; var right = list . length ; var found ; while ( left < right ) { var middle = ( left + right ) >> 1 ; var compareResult = list [ middle ] - e . targetTime ; if ( compareResult > 0 ) { left = middle + 1 ; } else { right = middle ; found = ! compareResult ; } } list . splice ( left , 0 , e ) ; }
function ( ) { $ ( this ) . find ( "ul" ) . stop ( ) ; $ ( this ) . find ( "ul" ) . slideUp ( ) ; $ ( this ) . removeClass ( "has_focus" ) ; }
function ( json ) { my . element . empty ( ) ; json . stack . forEach ( function ( idx ) { var st = json [ idx ] ; var gr = graph ( st . process , st . type , st . stat ) ; my . element . append ( gr . element ( ) ) ; } ) ; _super . refresh ( json ) ; }
function ( process , type , stat ) { var idx = process + '_' + type + '_' + stat ; for ( var i = 0 ; i < my . json . board . stack . length ; i ++ ) { if ( my . json . board . stack [ i ] === idx ) { my . json . board . stack . splice ( i , 1 ) ; break ; } } delete my . json . board [ idx ] ; }
function ( ) { var text = this . $input . attr ( "data-label" ) ; if ( ! text ) { return false ; } this . $label = $ ( "<label>" ) . text ( text ) ; this . $input . before ( this . $label ) ; return this ; }
function ( nmp ) { var mojits = me . _mojits , viewid = nmp . proxy . getId ( ) , binder = nmp . proxy . _binder , node = nmp . proxy . _node , elem = nmp . proxy . _element ; mojits [ viewid ] = { proxy : nmp . proxy , children : nmp . children , handles : bindNode ( binder , node , elem ) } ; recordBoundMojit ( mojits , parentId , viewid , nmp . proxy . type ) ; }
function ( e ) { this . _unpoll ( ) ; if ( sub . _selection ) { sub . _selection = '' ; sub . _notifier . fire ( { selection : sub . _selection , pageX : e . pageX , pageY : e . pageY } ) ; } }
function ( e ) { this . _unpoll ( ) ; if ( sub . _selection ) { sub . _selection = '' ; sub . _notifier . fire ( { selection : sub . _selection , pageX : e . pageX , pageY : e . pageY } ) ; } }
function ( e ) { this . _unpoll ( ) ; if ( sub . _selection ) { sub . _selection = '' ; sub . _notifier . fire ( { selection : sub . _selection , pageX : e . pageX , pageY : e . pageY } ) ; } }
function ( i , elem ) { switch ( elem . nodeName . toLowerCase ( ) ) { case 'label' : alert ( "label" ) ; break ; default : extension += elem . nodeName . toLowerCase ( ) + ":(" + $ ( elem ) . html ( ) + ")" ; } }
function ( ) { console . log ( "hide textarea" ) ; $ ( 'textarea#edit' ) . hide ( ) ; $ ( 'textarea#edit' ) . val ( " " ) ; var elem = $ ( "from[refid='" + id + "']" ) ; if ( elem . html ( ) == elem . attr ( "reset" ) ) elem . removeClass ( "edited" ) ; else elem . addClass ( "edited" ) ; }
function basicScan ( str ) { return ifParsed ( this . parseGroup ( str , '\n' , str . length ) , function ( group , rest ) { return [ group ( Nil , str . length - rest . length ) , null , rest ] ; } ) ; }
function addToWorkingSetAndSelect ( fullPath ) { var result = new $ . Deferred ( ) , promise = CommandManager . execute ( Commands . FILE_ADD_TO_WORKING_SET , { fullPath : fullPath } ) ; promise . done ( function ( doc ) { _fileSelectionFocus = WORKING_SET_VIEW ; _selectCurrentDocument ( ) ; result . resolve ( doc ) ; } ) . fail ( function ( err ) { result . reject ( err ) ; } ) ; return result . promise ( ) ; }
function initiateInfoScroller ( ) { void 0 === infopagescroll ? ( infopagescroll = createScroller ( "infoscroller" , null , { onBeforeScrollStart : function ( ) { } } ) , $j ( window ) . orientationChange ( initiateInfoScroller ) ) : infopagescroll . refresh ( ) ; destroyFeedScroller ( ) }
function swapChars ( chars , levels ) { if ( bdx . hiLevel == 0 || bdx . swap . substr ( 0 , 1 ) == bdx . swap . substr ( 1 , 2 ) ) { return ; } ; for ( var i = 0 ; i < chars . length ; i ++ ) { if ( levels [ i ] == 1 ) { chars [ i ] = getMirror ( chars [ i ] ) ; } } }
function isNextArabic ( str06 , index , step , nIEnd ) { while ( ( ( index ) * step ) < nIEnd && isArabicDiacritics ( str06 [ index ] ) ) { index += step ; } if ( ( ( index ) * step ) < nIEnd && isArabicAlefbet ( str06 [ index ] ) ) { return true ; } return false ; }
function getOrientation ( oc ) { if ( oc == 'L' ) { return "LTR" ; } if ( oc == 'R' ) { return "RTL" ; } if ( oc == 'C' ) { return "CLR" ; } if ( oc == 'D' ) { return "CRL" ; } }
function ( ele , onEvent , fun ) { onEvent = replace ( /^\s*on/ , '' ) ; var element = baidu . dom . g ( ele ) ; baidu . dom ( element ) . off ( onEvent , fun ) ; return element ; }
function ( ele , onEvent , fun ) { onEvent = replace ( /^\s*on/ , '' ) ; var element = baidu . dom . g ( ele ) ; baidu . dom ( element ) . on ( onEvent , fun ) ; return element ; }
function ( ) { expect ( 2 ) ; baidu ( "#qunit-fixture" ) . html ( "<article><section><aside>HTML5 elements</aside></section></article>" ) ; equal ( baidu ( "#qunit-fixture" ) . children ( ) . children ( ) . length , 1 , "Make sure HTML5 article elements can hold children. innerHTML shortcut path" ) ; equal ( baidu ( "#qunit-fixture" ) . children ( ) . children ( ) . children ( ) . length , 1 , "Make sure nested HTML5 elements can hold children." ) ; }
function ( ) { var targets = this . getTargetItems ( ) ; for ( var i = 0 ; i < targets . length ; i ++ ) { Ext . Anim . run ( Ext . get ( targets [ i ] ) , 'fade' , { duration : i === 0 ? 300 : i * 500 } ) ; } }
function ( path ) { var pathLength ; if ( pathlib . existsSync ( path ) ) { staticDirs = fs . readdirSync ( path ) ; if ( ! ( staticDirs . indexOf ( 'assets' ) >= 0 ) ) staticDirs . push ( 'assets' ) ; pathLength = path . length ; staticFiles = fileUtils . readDirSync ( path ) . files ; return staticFiles = staticFiles . map ( function ( file ) { return file . substr ( pathLength ) ; } ) ; } }
function ( ) { var k , stack , v ; stack = pathlib . existsSync ( customDir ) && apiTree . createApiTree ( customDir ) || { } ; for ( k in internal ) { v = internal [ k ] ; stack [ k ] = v ; } return stack ; }
function refreshAnnotations ( ) { received_annotations = false ; $ . ajax ( { url : 'v4/annotation' , data : { room : room . id , limit : 0 , format : 'json' } , accepts : 'application/json' , success : receivedAnnotations , error : errorHandler ( either ( args , 'refreshAnnotationsError' , noop ) ) } ) }
function refreshChats ( ) { received_chats = false ; var when = last_chat_update ; $ . ajax ( { url : 'v4/chat' , data : { room : room . id , limit : 0 , id__gt : when , format : 'json' } , accepts : 'application/json' , success : receivedChats , error : errorHandler ( either ( args , 'refreshChatError' , noop ) ) } ) ; }
function refreshParticipants ( ) { received_participants = false ; $ . ajax ( { url : 'v4/participant' , data : { room : room . id , limit : 0 , format : 'json' } , accepts : 'application/json' , success : receivedParticipants , error : errorHandler ( either ( args , 'refreshParticipantsError' , noop ) ) } ) ; }
function refreshRoles ( ) { received_roles = false ; $ . ajax ( { url : 'v4/role' , data : { users__id : my_userid , limit : 0 , format : 'json' } , accepts : 'application/json' , success : receivedRoles , error : errorHandler ( either ( args , 'refreshRolesError' , noop ) ) } ) ; }
function refreshRoom ( ) { received_room = false ; $ . ajax ( { url : 'v4/room' , data : { name : room_name , format : 'json' } , accepts : 'application/json' , success : receivedRoom , error : errorHandler ( either ( args , 'failedRoomGet' , noop ) ) } ) ; }
function refreshSharedOverlays ( ) { received_shared_overlays = false ; $ . ajax ( { url : 'v4/shared_overlay' , data : { name : room_name , limit : 0 , format : 'json' } , accepts : 'application/json' , success : receivedSharedOverlays , error : errorHandler ( either ( args , 'refreshSharedOverlaysError' , noop ) ) } ) ; }
function join ( room , username , password ) { room_name = room ; my_username = username ; my_password = password ; $ . ajax ( { url : 'join' , data : { username : my_username , password : my_password , room : room_name } , accepts : 'application/json' , success : receivedLoginCredentials , error : errorHandler ( either ( args , 'failedLogin' , noop ) ) } ) ; }
function ( url , type , hash ) { hash . url = url ; hash . type = type ; hash . dataType = 'json' ; hash . contentType = 'application/json' ; hash . context = this ; if ( hash . data && type !== 'GET' ) { hash . data = JSON . stringify ( hash . data ) ; } jQuery . ajax ( hash ) ; }
function ( ) { var currentCount = $commentBox . val ( ) . length ; if ( maxCount - currentCount >= 0 ) { $summaryCount . text ( maxCount - currentCount ) ; } else { $summaryCount . text ( 0 ) ; $commentBox . val ( $commentBox . val ( ) . substr ( 0 , maxCount ) ) ; } }
function ( response ) { if ( response . error ) { $ ( '#pay-error' ) . show ( ) . find ( 'div' ) . text ( response . error ) ; installError ( product ) ; return ; } if ( response . receipt ) { data [ 'data' ] = { 'receipts' : [ response . receipt ] } ; } $ . when ( apps . install ( product , data ) ) . done ( installSuccess ) . fail ( installError ) ; }
function ( f ) { var friendAsMozContact = { name : [ f . name ] , familyName : [ f . last_name ] , additionalName : [ f . middle_name ] , givenName : [ f . first_name ] , uid : f . uid . toString ( ) } ; window . console . log ( 'UID to be painted:' , friendAsMozContact . uid ) ; myFriendsByUid [ f . uid . toString ( ) ] = friendAsMozContact ; myFriends . push ( friendAsMozContact ) ; }
function locationsLoaded ( result ) { locationObjects = { } ; for ( i in result . content . locations ) { var l = result . content . locations [ i ] ; locationObjects [ l . id ] = new LocationObject ( ctx , l , locationTypes , tooltipGraphics ) ; locationGraphics . addChild ( locationObjects [ l . id ] ) ; } srv . get ( "industry/Building" , { areaId : displayedArea . id } , buildingsLoaded ) ; }
function buildingsLoaded ( result ) { buildingObjects = { } ; for ( i in result . content . buildings ) { var b = result . content . buildings [ i ] ; buildingObjects [ b . id ] = new BuildingObject ( ctx , b , buildingTypes , tooltipGraphics ) ; locationObjects [ b . locationId ] . addChild ( buildingObjects [ b . id ] ) ; } }
function ( orp , oip , zIndex ) { this . parent = parent ; this . orp = orp ; this . zIndex = zIndex ; this . children = new SortedList ( "zIndex" ) ; this . lastUsedTransform = new Transform ( ) ; this . rendered = true ; if ( oip != null ) { this . oip = oip ; } else { this . oip = new ObjectInteractionParameters ( false ) ; } }
function ( tickInterval ) { this . ctx . setTransform ( 1.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 ) ; this . ctx . fillStyle = this . backgroundFillStyle ; this . ctx . fillRect ( - 1 , - 1 , this . canvas . width + 1 , this . canvas . height + 1 ) ; this . render ( this . ctx , this . calculateViewportTransform ( ) ) ; }
function ( ) { var self = this ; var style = cssom . parse ( this . str ) ; this . applyKeyframePrefixes ( style ) ; style . cssRules = style . cssRules . map ( function ( rule ) { self . applyPrefixes ( rule ) ; self . applySelectorMapFunctions ( rule ) ; return rule ; } ) ; return style . toString ( ) ; }
function initGallery ( data ) { var $gallery = $ ( '#gallery' ) ; $ . each ( initdata , function ( i , x ) { var h = Mustache . to_html ( template , x ) ; $gallery = $gallery . append ( h ) ; } ) ; $gallery . masonry ( 'reload' ) ; $gallery . imagesLoaded ( function ( ) { $gallery . masonry ( { itemSelector : '.item' , columnWidth : 240 } ) ; } ) ; }
function ( ) { prop . uiCanvas = pCanvas ; prop . uiContex = pCanvas . getContext ( '2d' ) ; prop . uiContex . lineWidth = 5 ; prop . uiCanvas . onmousemove = onMouseMove ; prop . uiCanvas . onmousedown = onMouseDown ; prop . uiCanvas . onmouseup = onMouseUp ; }
function ( ) { $ ( '#sidebar .record_relation.selected' ) . removeClass ( 'selected' ) ; if ( $ ( this ) . hasClass ( 'selected' ) ) { sidebarPopup . hide ( ) } else { $ ( this ) . addClass ( 'selected' ) sidebarPopup . html ( $ ( this ) . attr ( 'related_records' ) ) sidebarPopup . show ( ) ; } event . stopPropagation ( ) ; }
function ( ) { projectView . show ( json ) ; var state = projectView . get ( ) ; expect ( state . projects . length ) . toBe ( 2 ) ; expect ( state . projects [ 0 ] ) . toBe ( 'CruiseControl.NET' ) ; expect ( state . projects [ 1 ] ) . toBe ( 'Project3-1' ) ; }
function ( doc , cdt , cdn ) { var d = locals [ cdt ] [ cdn ] ; if ( ! d . category && d . add_deduct_tax ) { alert ( "Please select Category first" ) ; d . add_deduct_tax = '' ; } else if ( d . category != 'For Total' && d . add_deduct_tax == 'Deduct' ) { alert ( "You cannot Deduct when category is for valuation or for both(i.e total and valuation)" ) ; d . add_deduct_tax = '' ; } }
function ( doc , cdt , cdn ) { var callback = function ( r , rt ) { set_field_options ( 'select_doc_for_series' , r . message ) ; } $c_obj ( make_doclist ( doc . doctype , doc . name ) , 'get_transactions' , '' , callback ) ; cur_frm . cscript . refresh ( ) ; }
function ( objects , sync , fn ) { if ( sync ) { objects . db = new xapian . WritableDatabase ( 'tmpdbs' , xapian . DB_CREATE_OR_OVERWRITE ) ; fn ( null ) ; } else { new xapian . WritableDatabase ( 'tmpdbas' , xapian . DB_CREATE_OR_OVERWRITE , function ( err , result ) { objects . db = result ; fn ( err ) ; } ) ; } }
function ( ) { this . navView = new app . views . PostViewerNav ( { model : this . model } ) ; this . feedbackView = new app . views . ViewerFeedbackActions ( { model : this . model } ) this . postView = new app . views . Post . SmallFrame ( { model : this . model , className : "canvas-frame x2" } ) ; this . headerView = new app . views . Header ( { } ) this . render ( ) ; }
function ( url , options ) { if ( options === null || options === "undefined" ) { var options = new Object ( ) ; options . showLocationBar = true ; } cordova . exec ( this . _onEvent , this . _onError , "ChildBrowser" , "showWebPage" , [ url , options ] ) ; }
function ( url ) { if ( pg ) { if ( os === 'android' ) { cordova . exec ( null , null , 'ChildBrowser' , 'showWebPage' , [ url , false ] ) ; } else { window . plugins . childBrowser . showWebPage ( url ) ; } return ; } window . location = url ; }
function ( ) { should . exist ( require ( 'webpage' ) . create ) ; should . exist ( require ( 'fs' ) . separator ) ; if ( phantom . version . major >= 1 && phantom . version . minor >= 4 ) { should . exist ( require ( 'webserver' ) . create ) ; } if ( phantom . version . major >= 1 && phantom . version . minor >= 5 ) { require ( 'system' ) . platform . should . equal ( 'phantomjs' ) ; } }
function ( ) { var request = { url : $ ( '#url' ) . val ( ) , data : postman . currentRequest . body . getData ( ) , headers : postman . currentRequest . getPackedHeaders ( ) , dataMode : postman . currentRequest . dataMode , method : postman . currentRequest . method } ; return JSON . stringify ( request ) ; }
function saveFile ( force ) { debug . info ( "saveFile:  force = " + force ) console . log ( editor . getValue ( ) ) ; model . setFile ( filepath , editor . session . doc . getValue ( ) , force , null , null , handle409 ) ; }
function ( e ) { if ( e . data == 1 && ! isSyncing ) { this . onSync ( ) ; } else { if ( isSyncing ) { this . onSyncFailure . call ( this ) ; } else { isLive = ! ( Cache . isActive ( ) && ! Cache . isOnline ( ) ) ; } } }
function ( ) { for ( var name in this . views ) { this . views [ name ] . unload ( ) ; } console . log ( this . data . name + ' ' + "Unload" ) ; this . fire ( '_unloaded' ) ; }
function ( event ) { var data = event . data , length = data . length , i = 0 ; el . options . length = 0 ; for ( ; i < length ; i ++ ) { var elmOption = document . createElement ( 'OPTION' ) ; elmOption . value = data [ i ] . value ; elmOption . text = data [ i ] . text ; el . add ( elmOption ) ; } }
function ( levels , opts ) { this . levels = ! levels ? [ ] : Array . isArray ( levels ) ? levels : [ levels ] ; this . opts = opts || { } ; this . techs = this . initOptsTechs ( ) ; this . _techsCache = { } ; }
function ( techIdent ) { var techPath = this . resolveTech ( techIdent ) , techName = bemUtil . isPath ( techIdent ) ? createTech ( techPath ) . getTechName ( ) : techIdent ; techs [ techName ] = techPath ; return techName ; }
function ( techIdent ) { var techPath = this . techs ? this . techs [ techIdent ] : null ; if ( techPath || ! this . levels . length ) return techPath ; var level , i = this . levels . length ; while ( ! techPath && ( level = this . levels [ -- i ] ) ) { techPath = level . resolveTechName ( techIdent ) ; } return techPath ; }
function ( ) { InspectorUI . highlighter . addListener ( "nodeselected" , highlightBodyNode ) ; node = doc . querySelector ( "body" ) ; EventUtils . synthesizeKey ( "VK_RIGHT" , { } ) ; }
function load ( content , type , line ) { if ( editor ) { console . log ( 'loading' , content , type , line ) ; editor . setInput ( res , null , content ) ; syntaxHighlighter . highlight ( res , editor ) ; } else { buffer = { content : content , type : type , line : line } ; console . log ( 'buffering load' , buffer ) ; } }
function ( tr ) { var classname = 'drop-into-' + tr . id . split ( '-' ) [ 1 ] + '-' + col . id . split ( '-' ) [ 1 ] ; tr . down ( 'td' , col . up ( ) . childElements ( ) . indexOf ( col ) ) . select ( '.cardwall_board_postit' ) . invoke ( 'removeClassName' , classname ) ; }
function ( node ) { var name = "" ; while ( node ) { name = core . getAttribute ( node , "name" ) + name ; node = core . getParent ( node ) ; } return name ; }
function ( ) { publishDialog . show ( ) ; }
function ( ) { var browserLang ; try { if ( this . config . lang ) browserLang = this . config . lang ; if ( navigator . userLanguage ) browserLang = navigator . userLanguage ; else if ( navigator . language ) browserLang = navigator . language ; browserLang = browserLang . substring ( 0 , 2 ) . toLowerCase ( ) ; } catch ( exc ) { browserLang = "en" ; } return browserLang ; }
function ( req , res ) { req . nav . steps = [ { url : '/lists' , title : 'Lists' } , { url : '/lists' + req . params . list , title : req . metadata . title } , { active : true , title : 'Settings' } ] ; res . render ( 'admin' , { nav : req . nav , metadata : req . metadata , } ) }
function ( req , res ) { req . nav . steps = [ { url : '/docs' , title : 'Documents' } , { url : '/docs' + req . params . library , title : req . metadata . title } , { active : true , title : 'Settings' } ] ; res . render ( 'admin' , { nav : req . nav , metadata : req . metadata , } ) }
function ( ) { this . _modelBinder . bind ( this . model , this . el ) ; }
function ( ) { this . $el . html ( Mustache . render ( this . template , this . model . toJSON ( ) ) ) ; this . $ ( 'input[type="checkbox"].selector' ) . attr ( 'checked' , this . model . selected ) ; return this ; }
function ( ) { this . $el . html ( Mustache . render ( this . template , this . model . toJSON ( ) ) ) ; this . $ ( 'input[type="checkbox"].selector' ) . attr ( 'checked' , this . model . selected ) ; return this ; }
function ( defaultValues ) { return Backbone . Model . extend ( { defaults : function ( ) { return defaultValues ; } , idAttribute : '_id' , initialize : function ( ) { var selectable = new Backbone . Picky . Selectable ( this ) ; _ . extend ( this , selectable ) ; } } ) }
function ( ) { this . $el . html ( Mustache . render ( this . template , this . model . toJSON ( ) ) ) ; this . $ ( 'input[type="checkbox"].selector' ) . attr ( 'checked' , this . model . selected ) ; return this ; }
function ( ) { this . $el . html ( Mustache . render ( this . template , this . model . toJSON ( ) ) ) ; this . $ ( 'input[type="checkbox"].selector' ) . attr ( 'checked' , this . model . selected ) ; return this ; }
function ( attrs ) { if ( attrs . id === undefined || ! _ . isString ( attrs . content ) || attrs . creation_date === undefined || attrs . owner_user === undefined ) { console . log ( "Error: tweet must have id, content, cretion_date, and owner_user" ) ; return "Error: tweet must have id, content, cretion_date, and owner_user" ; } }
function ( collection , response ) { console . log ( 'got a success!' ) ; console . log ( 'collection: ' + JSON . stringify ( collection ) ) ; console . log ( 'response: ' + JSON . stringify ( response ) ) ; $ . unblockUI ( ) ; }
function ( collection , response ) { console . log ( 'got a error!' ) ; console . log ( 'collection: ' + JSON . stringify ( collection ) ) ; console . log ( 'response: ' + JSON . stringify ( response ) ) ; $ . unblockUI ( ) ; $ ( '#connectionError' ) . show ( ) ; }
function ( ) { var args = Array . prototype . slice . call ( arguments ) ; var message = util . format . apply ( this , args ) ; message = this . getErrorLogMessagePrefix ( ) + message ; console . log ( message ) ; }
function processCacheOptions ( options ) { if ( 'undefined' !== typeof opt . args ) { opt . logInfo ( 'got args %s' , dumpObjectToString ( opt . args ) ) ; } if ( opt . initialCachedValue !== null ) { opt . logInfo ( 'got initialCachedValue' ) ; storeNewCachedValue ( opt . initialCachedValue ) ; } }
function getSharedViewModel ( forSectionName ) { return { navClasses : getNavClasses ( forSectionName ) , sidebarLinks : getSidebarLinks ( forSectionName ) } ; }
function ( error , model ) { if ( error ) { callback ( error ) ; } else { var post = _ . chain ( model . posts ) . filter ( function ( post ) { return post . id == postId ; } ) . first ( ) . value ( ) ; if ( ! post ) throw new Error ( "unable to find post with id " + postId ) ; callback ( null , { title : post . title , post : post , shared : getSharedViewModel ( 'post' ) } ) ; } }
function ( path , options ) { options = options || { } ; options . type = "require" ; this . _addPath ( path , options ) ; return this ; }
function ( boolOrMinimizer ) { if ( _ . isUndefined ( boolOrMinimizer ) || boolOrMinimizer === true ) { this . minimizer = Minimizers . Default ; } else if ( ! boolOrMinimizer ) { this . minimizer = Minimizers . None ; } else if ( _ . isFunction ( boolOrMinimizer ) ) { this . minimizer = boolOrMinimizer ; } return this ; }
function fetch ( url , callback ) { if ( templates [ url ] ) callback ( null , templates [ url ] ) ; else resolver ( url , "text/xml" , check ( callback , function ( doc ) { callback ( null , templates [ url ] = { url : url , doc : doc , funcs : { } } ) ; } ) ) ; }
function resolver ( url , mimeType , callback ) { var resolved = path . resolve ( base , url ) switch ( mimeType ) { case "text/javascript" : try { callback ( null , require ( resolved ) ) ; } catch ( error ) { callback ( error ) ; } break ; case "text/xml" : callback ( null , new ( xmldom . DOMParser ) ( ) . parseFromString ( fs . readFileSync ( resolved , "utf8" ) ) ) ; break ; } }
function create ( base ) { return function resolver ( url , mimeType , callback ) { var resolved = path . resolve ( base , url ) switch ( mimeType ) { case "text/javascript" : try { callback ( null , require ( resolved ) ) ; } catch ( error ) { callback ( error ) ; } break ; case "text/xml" : callback ( null , new ( xmldom . DOMParser ) ( ) . parseFromString ( fs . readFileSync ( resolved , "utf8" ) ) ) ; break ; } } }
function ( ) { var context = { stencil : require ( "../../index" ) , resolver : require ( "../../resolver" ) , compare : require ( "../compare" ) , fixture : function ( file , callback ) { fs . readFile ( path . resolve ( __dirname , file ) , "utf8" , callback ) } } ; return context ; }
function ( ) { this . close ( ) ; this . container . removeClass ( "select2-container-active" ) ; this . dropdown . removeClass ( "select2-drop-active" ) ; if ( this . search . is ( ":focus" ) ) { this . search . blur ( ) ; } this . clearSearch ( ) ; this . selection . find ( ".select2-search-choice-focus" ) . removeClass ( "select2-search-choice-focus" ) ; }
function ( event ) { form . ajaxSubmit ( { success : function ( data ) { el . modal ( 'hide' ) ; dialogs . notification ( 'New password saved' ) ; } , error : function ( data ) { } } ) ; }
function ( userNotification , callback ) { console . log ( "attempting to update" ) ; userNotification . updateAttributes ( { emailSent : true } ) . success ( function ( updateSettings ) { console . log ( "[SUCCESS]" ) ; callback ( null , updateSettings ) ; } ) . error ( function ( error ) { console . log ( "[ERROR] " + error ) ; callback ( error , null ) ; } ) ; }
function render ( target , repos ) { var i = 0 , fragment = '' , t = $ ( target ) [ 0 ] ; for ( i = 0 ; i < repos . length ; i ++ ) { fragment += '<li><a href="' + repos [ i ] . url + '">' + repos [ i ] . name + '</a><p>' + repos [ i ] . description + '</p></li>' ; } t . innerHTML = fragment ; }
function ( ) { $ ( '.ac_results' ) . remove ( ) ; ProjectItems . setup_autocomplete_for_projects ( 'input[name=project_name]' ) ; ContextItems . setup_autocomplete_for_contexts ( 'input[name=context_name]' ) ; ContextItems . setup_autocomplete_for_contexts ( 'input[id="project_default_context_name"]' ) ; TracksPages . setup_autocomplete_for_tag_list ( 'input[name=tag_list]' ) ; TracksPages . setup_autocomplete_for_tag_list ( 'input[id="project_default_tags"]' ) ; TodoItems . setup_autocomplete_for_predecessor ( ) ; }
function thesisSubmited ( ) { $ ( '#upload-progress .bar' ) . width ( '100%' ) ; var status = $ ( '#upload-status' ) ; $ ( "#upload" ) . modal ( 'hide' ) ; status . fadeIn ( ) ; $ ( '#thesis-upload' ) . resetForm ( ) ; $ ( '#thesis-submit' ) . removeClass ( 'disabled' ) $ ( '#upload-progress' ) . hide ( ) ; setInterval ( function ( ) { status . fadeOut ( ) ; } , 8000 ) ; }
function ( ) { $ ( "#upload" ) . show ( ) ; }
function ( event ) { var query = this . $ ( event . target ) . find ( "#search" ) . val ( ) if ( ! ( CATARSE . loader . namespace . text == "" && CATARSE . loader . controller == "explore" && CATARSE . loader . action == "index" ) && query . length > 0 ) location . href = "/explore#search/" + query return false }
function ( api ) { api . use ( 'underscore' , 'server' ) ; api . use ( 'localstorage-polyfill' , 'client' ) ; api . add_files ( 'accounts_common.js' , [ 'client' , 'server' ] ) ; api . add_files ( 'accounts_server.js' , 'server' ) ; api . add_files ( 'localstorage_token.js' , 'client' ) ; api . add_files ( 'accounts_client.js' , 'client' ) ; }
function ( node , callback ) { ASSERT ( node && callback ) ; var children = new UTIL . AsyncArray ( callback ) ; for ( var relid in node . data ) { if ( isValidRelid ( relid ) ) { pertree . loadChild ( node , relid , children . add ( ) ) ; } } children . start ( ) ; }
function ( first , second ) { ASSERT ( typeof first === "string" ) ; ASSERT ( typeof second === "string" ) ; return second === EMPTY_STRING ? first : ( first === EMPTY_STRING ? second : first + "/" + second ) ; }
function ( callback ) { ASSERT ( callback ) ; var counter = 1 ; var error = null ; this . start = function ( ) { ASSERT ( callback && counter >= 1 ) ; ++ counter ; } ; this . done = function ( err ) { ASSERT ( callback && counter >= 1 ) ; error = error || err ; if ( -- counter === 0 ) { callback ( error ) ; callback = null ; } } ; }
function ( array , elem , comparator ) { ASSERT ( array . constructor === Array ) ; ASSERT ( elem && comparator ) ; var index = binarySearch ( array , elem , comparator ) ; array . splice ( index , 0 , elem ) ; }
function ( array ) { var pro = baidu . $Array . prototype , ap = Array . prototype ; for ( var key in pro ) { ap [ key ] || ( array [ key ] = pro [ key ] ) ; } return array ; }
function ( object ) { var s = typeof object ; return s != "object" ? s : object == null ? "null" : object . _type_ || objectType [ toString . call ( object ) ] || nodeType [ object . nodeType ] || ( object == object . window ? "Window" : "" ) || "object" ; }
function ( ) { if ( ! this . editor ) return ; try { this . editor . removeEventListener ( "keypress" , this . onKeyPress ) ; } catch ( err ) { } this . editor . removeEventListener ( CONTEXT_MENU , this . onContextMenu ) ; this . editor . removeEventListener ( TEXT_CHANGED , this . onTextChanged ) ; this . editor . destroy ( ) ; this . editor = null ; }
function ( event ) { Firebug . CommandLine . update ( Firebug . currentContext ) ; switch ( event . keyCode ) { case KeyEvent . DOM_VK_RETURN : if ( Events . isControl ( event ) ) this . onExecute ( ) ; break ; case KeyEvent . DOM_VK_ESCAPE : this . onEscape ( ) ; event . preventDefault ( ) ; break ; } }
function ( adjust ) { if ( ! this . editor || ! this . editor . _view ) return ; if ( typeof ( SourceEditor ) != "undefined" ) { var doc = this . editor . _view . _frame . contentDocument ; } else { this . editor . textBox . style . fontSizeAdjust = adjust ; } }
function ( context ) { var visible = Firebug . CommandLine . Popup . isVisible ( ) ; if ( visible && context . panelName != "console" ) return this . getSingleRowCommandLine ( ) ; return Firebug . commandEditor ? this . getCommandEditor ( ) : this . getSingleRowCommandLine ( ) ; }
function ( req , res ) { if ( req . loggedIn ) { return res . send ( { title : 'Profile' , status : 200 , user : req . user , username : "Logged in" } ) ; } else { return res . send ( { title : 'Profile' , status : 200 , username : "You might not be logged in, but I don't know." } ) ; } }
function ( res , user ) { console . log ( "registration successful" ) ; if ( res . req . header ( 'accept' ) === 'application/json' ) { console . log ( "from xhr" ) ; return res . json ( { success : true } , 200 ) ; } else { console . log ( "from http" ) ; return res . redirect ( "/" ) ; } }
function ( content ) { return page . create ( views . profile ( { username : content . username } ) ) ; }
function ( ) { var user ; user = JSON . parse ( window . localStorage . getItem ( 'user' ) ) ; if ( user ) { return fimo . data . post ( 'login' , { 'email' : user . email , 'password' : user . password } , function ( ) { return fimo . controller . jumbles ( ) ; } , function ( ) { console . log ( "automatic login unsuccessful. removing local storage user." ) ; return window . localStorage . removeItem ( 'user' ) ; } ) ; } }
function ( ) { return { template : _ . template ( "<div class=\"page\">\n  <h1><%= username %></h1>\n</div>" ) , click : function ( event ) { return true ; } , loaded : function ( ) { return fimo . events . on ( "click" , this . click ) ; } , destroy : function ( ) { return fimo . events . off ( "click" , this . click ) ; } } ; }
function ( e ) { _selectedTrackEvents . push ( e . target ) ; }
function localConfig ( data ) { data . visOptions . method = 'classic' ; data . visOptions . filterBar . modalities = { "image" : { label : "Images" } , "3d" : { label : "3D models" } , "audio" : { label : "Audio" } , "video" : { label : "Video" } } data . fileUploadServer = "http://vision.iti.gr/sotiris/isearch/debug/upload.php" ; data . queryFormulatorUrl = "http://vision.iti.gr/sotiris/isearch/debug/mqf.php?index=uc6" ; data . userProfileServerUrl = "http://vision.iti.gr/sotiris/isearch/debug/user.php?mode=Profile&key=" ; data . userLoginServerUrl = "http://vision.iti.gr/sotiris/isearch/debug/user.php?mode=login" ; data . tagServerUrl = "http://vision.iti.gr/sotiris/isearch/debug/user.php?mode=tags&index=uc6" ; data . visOptions . method = "mst" ; }
function ( ) { var thisMediaType = this . id ; var current = $ ( '.media-preview' , tooltip ) ; var currentId = current . attr ( 'id' ) ; if ( currentId != thisMediaType ) { current . remove ( ) ; that . renderContents ( tooltip , thumb , thisMediaType ) ; $ ( this ) . toggleClass ( 'selected' ) ; } }
function ( ) { if ( ! $ ( this ) . data ( 'class' ) ) { $ ( selectors [ 17 ] ) . append ( '<div id="hz_opts"><strong>Google+ Hover Zoom</strong><ul><li id="disable_hz">' + lang . menu02 + '</li>' + menuTmp + '</ul></div>' ) ; $ ( this ) . data ( 'class' , true ) ; } }
function ( obj ) { var url = obj . href ; if ( url . match ( /\/photos\/\w+\/albums\/\w+/ ) ) { var button = $ ( '<div class="hz_albumDownload hz_dlButton" aria-label="' + lang . al01 + '" data-tooltip="' + lang . al01 + '" role="button"><span></span></div>' ) . data ( 'url' , url ) ; $ ( obj ) . parentsUntil ( selectors [ 4 ] ) . next ( ) . children ( ) . eq ( - 1 ) . before ( button ) ; } }
function ( obj , url ) { var button = $ ( '<div class="hz_in-albumDownload hz_button blue" role="button">' + lang . fs03 + '</div>' ) . data ( 'url' , url ) ; obj . data ( 'class' , true ) . next ( ) . find ( selectors [ 5 ] ) . children ( ) . eq ( 1 ) . before ( button ) ; }
function ( obj ) { var button = $ ( '<div class="hz_tubeStacks hz_dlButton" aria-label="' + lang . ytdl01 + '" data-tooltip="' + lang . ytdl01 + '" role="button"><span></span></div>' ) . data ( 'url' , $ ( obj ) . find ( selectors [ 3 ] ) . attr ( 'href' ) ) ; $ ( obj ) . parentsUntil ( selectors [ 4 ] ) . next ( ) . children ( ) . eq ( - 1 ) . before ( button ) ; }
function ( ) { if ( ! $ ( this ) . data ( 'class' ) ) { P . album_page ( $ ( 'nav:visible' ) , location . href . replace ( /\?(.*)/ , '' ) ) ; $ ( this ) . data ( 'class' , true ) ; } }
function svgIsInCy ( svgDomElement ) { var $ele = $ ( svgDomElement ) ; var inside = false ; $ele . parents ( ) . each ( function ( ) { if ( this == $container [ 0 ] ) { inside = true ; } } ) ; return inside ; }
function as_hide ( evt ) { if ( evt . keyCode == evt . DOM_VK_ESCAPE || evt . keyCode == evt . DOM_VK_HOME ) { if ( this . screen . querySelectorAll ( 'iframe' ) . length > 0 ) { if ( ! this . screen . classList . contains ( 'status' ) ) { this . screen . classList . add ( 'status' ) ; this . _screenInitiallyDisabled = false ; evt . preventDefault ( ) ; evt . stopPropagation ( ) ; } } } }
function ( ) { if ( buttonsVisible == false ) { buttonsVisible = true ; controls . show ( ) ; } else { buttonsVisible = false ; controls . hide ( ) ; } ; }
function ( photo ) { var buttonsVisible = false , controls = $ ( '.controls' , photo ) ; photo . on ( 'hover' , function ( ) { if ( buttonsVisible == false ) { buttonsVisible = true ; controls . show ( ) ; } else { buttonsVisible = false ; controls . hide ( ) ; } ; } ) ; }
function LeaseOffering ( id , type , az , duration , fPrice , uPrice , rPrices , desc , offering , tenancy ) { this . id = id ; this . instanceType = type ; this . azone = az ; this . duration = duration ; this . fixedPrice = fPrice ; this . usagePrice = uPrice ; this . recurringCharges = rPrices ; this . description = desc ; this . offering = offering ; this . tenancy = tenancy ; this . toString = function ( ) { return this . id } }
function exec ( file , tasks , options ) { require ( file ) ( rivet ) ; rivet . run ( tasks , options , function ( err ) { if ( err ) { throw err ; } } ) ; }
function ( ev ) { ev . preventDefault ( ) ; ev . stopPropagation ( ) ; var delete_dialog = new cdb . admin . DeleteDialog ( { clean_on_hide : true , title : "" , content : "" , ok_button_classes : "button grey" , cancel_button_classes : "underline margin15" , modal_type : "confirmation" , model : this . model } ) ; this . $el . append ( delete_dialog . render ( ) . el ) ; delete_dialog . open ( ) ; }
function ( ) { this . model . bind ( 'reset' , this . addAll , this ) ; this . model . bind ( 'add' , this . addTable , this ) ; }
function ( tag_name ) { var tag_names = this . getSelectedTags ( ) ; var idx = $ . inArray ( tag_name , tag_names ) ; if ( idx !== - 1 ) { tag_names . splice ( idx , 1 ) if ( tag_names . length === 0 ) { this . _prompt . show ( ) ; } } this . setSelectedTags ( tag_names ) ; }
function ( ) { if ( this [ 0 ] && this [ 0 ] . parentNode ) { baidu . dom . _smartInsert ( this , arguments , function ( node ) { this . parentNode . insertBefore ( node , this . nextSibling ) ; } ) ; } else if ( arguments . length ) { baidu . merge ( this , baidu . dom . _buildElements ( arguments , this . getDocument ( ) || document ) ) ; } return this ; }
function ( ) { var code = ( arguments . length >= 1 ) ? arguments [ 0 ] : 'COM01' ; this . error = { COM01 : "UNKNOW ERROR." , STR01 : "STORAGE MODE NOT FOUND." , STR02 : "TABLE ALREADY EXIST'S." , STR03 : "TABLE NOT FOUND." , STR04 : "INCORRECT FIELD NAME OR DATA TYPE." , CRT01 : "TABLE NOT SELECTED!!" } ; this . message = function ( ) { return this . error [ code ] ; } ; }
function ( ) { try { if ( Private . checkStorageMethod ( ) ) { Webbase . StorageMode = Private . checkStorageMethod ( ) ; return true ; } else { throw new Webbase . Exception ( 'STR01' ) ; } } catch ( err ) { console . log ( err . message ( ) ) ; return false ; } }
function ( tableName , desc ) { if ( Webbase . StorageMode ) { this . getTableDetails ( ) ; if ( ! this . checkTableAlreadyExists ( tableName ) ) { this . setTableDetails ( tableName , desc ) ; this . createTable ( tableName ) ; } else { throw new Webbase . Exception ( 'STR02' ) ; } } else { throw new Webbase . Exception ( 'STR01' ) ; } }
function ( tableName , desc , primaryKey ) { Webbase . TableDesc . push ( { name : tableName , field : desc , primaryKey : primaryKey } ) ; Webbase . StorageMode . setItem ( 'Webbase_tbl' , WebbaseUtility . JSON . stringify ( Webbase . TableDesc ) ) ; }
function ( tableName , desc ) { try { Private . initCreate ( tableName , desc ) ; } catch ( err ) { console . log ( err . message ( ) ) ; } }
function ( ) { try { if ( Webbase . CriteriaStruct . from . length > 0 ) { Private . delete ( Private . getTableData ( Webbase . CriteriaStruct . from ) ) ; Private . resetCriteriaStruct ( ) ; } else { Private . resetCriteriaStruct ( ) ; throw new Webbase . Exception ( 'CRT01' ) ; } } catch ( error ) { console . log ( error . message ( ) ) ; } }
function ( ) { try { if ( Webbase . CriteriaStruct . from . length > 0 ) { Private . update ( Private . getTableData ( Webbase . CriteriaStruct . from ) ) ; Private . resetCriteriaStruct ( ) ; } else { Private . resetCriteriaStruct ( ) ; throw new Webbase . Exception ( 'CRT01' ) ; } } catch ( error ) { console . log ( error . message ( ) ) ; } }
function ( ) { var Storage = function ( ) { this . identifyStorage ( ) ; } ; Storage = WebbaseUtility . ObjectExt . inherit ( DataManager , Storage ) ; Storage = WebbaseUtility . ObjectExt . inherit ( StorageManager , Storage ) ; return new Storage ( ) ; }
function ( key ) { cert . signatureOid = oids [ 'sha1withRSAEncryption' ] ; cert . md = forge . md . sha1 . create ( ) ; var bytes = asn1 . toDer ( pki . getTBSCertificate ( cert ) ) ; cert . md . update ( bytes . getBytes ( ) ) ; cert . signature = key . sign ( cert . md ) ; }
function getNextActivePlayer ( x ) { var ret = - 1 for ( var i = x ; i < playerObj . length ; i ++ ) { if ( playerObj [ i ] . money > 0 ) { console . log ( "retrun" , i ) ; ret = i ; break ; } } return ret ; }
function ( done ) { oldConsoleLog = console . log ; oldStdOut = process . stdout . write ; console . log = function ( msg ) { lastConsoleMessage = msg ; } ; process . stdout . write = function ( msg ) { lastStdoutMessage = msg ; } ; done ( ) ; }
function ( req , res ) { res . render ( 'not_found' , { title : "Page Not Found" , status : 404 } ) ; }
function SecureError ( msg ) { this . name = 'SecureError' ; Error . call ( this , msg ) ; Error . captureStackTrace ( this , arguments . callee ) ; this . render = function ( req , res ) { res . render ( 'permission_denied' , { title : "Permission Denied" , status : 503 } ) ; } }
function ( req , res ) { res . render ( 'application_unavailable' , { title : "Application Unavailable" , status : 503 } ) ; }
function ApplicationUnavailableError ( msg ) { this . name = 'ApplicationUnavailableError' ; Error . call ( this , msg ) ; Error . captureStackTrace ( this , arguments . callee ) ; this . render = function ( req , res ) { res . render ( 'application_unavailable' , { title : "Application Unavailable" , status : 503 } ) ; } }
function ( filePath , line , column ) { var _this = this ; if ( line == null ) { line = 0 ; } if ( column == null ) { column = 0 ; } ide . dispatchEvent ( 'openfile' , { doc : ide . createDocument ( require ( "ext/filesystem/filesystem" ) . createFileNodeFromPath ( filePath ) ) } ) ; line = line - 1 ; return setTimeout ( ( function ( ) { return _this . startLiveCoffee ( line ) ; } ) , OPEN_FILE_TIMEOUT ) ; }
function ( pos ) { var y = this . tl . height - this . tl . sliderHeight ; return ( pos . x >= this . startx && pos . x <= this . endx && pos . y >= y && pos . y <= y + this . tl . sliderHeight ) ; }
function ( ) { $ ( '#child-' + this . id ) . toggle ( ) ; }
function ( i , v ) { var repeat = $ ( v ) ; repeat . css ( 'background-color: rgba(255,0,255,0.4)' ) ; $ ( 'body' ) . append ( repeat ) ; }
function ( ) { if ( selected > progress_scroll ) { progress_scroll = selected ; } if ( progress_scroll - 1 > 0 ) { progress_scroll -= 1 ; } $ ( ".bar" ) . scrollTo ( $ ( ".bar img[id='m_" + progress_scroll + "']" ) , 0 , { axis : "x" } ) ; }
function ( ) { if ( selected > progress_scroll ) { progress_scroll = selected ; } if ( progress_scroll - 1 >= 0 ) { progress_scroll -= 1 ; } $ ( ".bar" ) . scrollTo ( $ ( ".bar img[id='m_" + progress_scroll + "']" ) , 0 , { axis : "x" } ) ; }
function ( e ) { if ( this . scrollingEnabled ) { self . _animateToPosition ( startTranslationX , startTranslationY , 400 + 0.3 * calculateDistance ( startTranslationX , startTranslationY , self . _currentTranslationX , self . _currentTranslationY ) , "ease-in-out" , function ( ) { self . _handleDragCancel && self . _handleDragCancel ( e ) ; } ) ; self . _endScrollBars ( ) ; self . _handleDragCancel && self . _handleDragCancel ( e ) ; } }
function ( $ ) { if ( fs . stat ( $ ) . isFile ( ) ) { filePaths . push ( $ ) ; } else { filePaths = filePaths . concat ( fs . ls ( $ , depth ) ) ; } }
function ( err , result ) { if ( err && typeof callback == 'function' ) return callback ( err ) ; if ( typeof callback == "function" && result . value == false ) { return callback ( new Error ( 'Element ' + cssSelector + ' not selected' ) ) ; } if ( typeof callback === "function" ) { callback ( null , result . value ) ; } }
function ( cssSelector , callback ) { var self = this ; self . moveToObject ( cssSelector ) ; self . element ( "css selector" , cssSelector , function ( result ) { if ( result . status == 0 ) { self . doDoubleClick ( function ( result ) { if ( typeof callback === "function" ) { callback ( ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result ) ; } } } ) ; }
function ( result ) { if ( result . status == 0 ) { self . moveTo ( result . value . ELEMENT , function ( result ) { if ( typeof callback === "function" ) { callback ( ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result ) ; } } }
function ( result ) { if ( typeof callback === "function" ) { callback ( result . value ) ; } }
function ( event ) { event . view = view ; event . context = context ; if ( target . isState && typeof target . send === 'function' ) { return target . send ( actionName , event ) ; } else { return target [ actionName ] . call ( target , event ) ; } }
function ( position ) { $ . post ( 'https://spy-game.herokuapp.com/update_position' , position , handle_update , 'json' ) ; $ ( '#content' ) . append ( '<p>You are within ' + position . coords . accuracy + ' meters of ' + position . coords . latitude + ', ' + position . coords . longitude + '</p>' ) ; }
function ( data ) { self . trigger ( Events . LEVEL_LEAVE , self . level . levelData ) ; self . level . destroy ( ) ; self . level = new Level ( data ) ; self . trigger ( Events . LEVEL_ENTER , data ) ; }
function ( event ) { var msg = JSON . parse ( event . data ) ; self . postMessage ( "Worker received command: " + msg . command ) ; if ( msg . command == "start_download" ) { var t_id = msg . content . torrent_id ; self . postMessage ( "Worker got torrent_id: " + t_id ) ; sock . send ( torrent_id ) ; } }
function ( ) { var templateData = get ( this , 'templateData' ) , controller = get ( this , 'controller' ) ; var keywords = templateData ? Ember . copy ( templateData . keywords ) : { } ; keywords . view = get ( this , 'concreteView' ) ; if ( controller ) { keywords . controller = controller ; } return keywords ; }
function ( ) { if ( xhr . responseText ) { var parser = new DOMParser ( ) ; var xmlDoc = parser . parseFromString ( xhr . responseText , "text/xml" ) ; if ( xmlDoc . getElementById ( "layout" ) != null ) { handleSuccess ( xhr . responseText ) ; return ; } else { chrome . extension . getBackgroundPage ( ) . console . error ( "HabrInfo - " + "Not valid html." ) ; } } handleError ( ) ; }
function ( ) { if ( ! opts . usePlaceholder && $ ( this ) . val ( ) == "" && values_input . val ( ) == "" && prefill_value == "" && opts . minChars > 0 ) { $ ( this ) . val ( opts . startText ) ; } else if ( input_focus ) { $ ( "li.as-selection-item" , selections_holder ) . addClass ( "blur" ) . removeClass ( "selected" ) ; results_holder . hide ( ) ; } if ( interval ) clearInterval ( interval ) ; }
function ( ) { values_input . val ( values_input . val ( ) . replace ( "," + data [ opts . selectedValuesProp ] + "," , "," ) ) ; opts . selectionRemoved . call ( this , item ) ; input_focus = true ; input . focus ( ) ; return false ; }
function ( ) { var DiaryBody , DiaryBodyHtml , converter ; DiaryBody = $ ( '.diary_body' ) . text ( ) . replace ( /^\s+?([^\s]+)/ , "$1" ) . replace ( /\s+$/ , '' ) . replace ( /([^\n])\n([^\n])/g , "$1  \n$2" ) ; converter = new Showdown . converter ; DiaryBodyHtml = converter . makeHtml ( DiaryBody ) ; $ ( '.diary_body' ) . replaceWith ( '<div class="diary_body parsed">' + DiaryBodyHtml + '</div>' ) ; }
function ( sequelize , DataTypes ) { self . sequelize = sequelize self . User = sequelize . define ( 'User' , { username : { type : DataTypes . STRING } , touchedAt : { type : DataTypes . DATE , defaultValue : DataTypes . NOW } } ) }
function ( form ) { var req_data = require ( 'url' ) . parse ( req . url , 1 ) . query ; res . writeHead ( 200 , { 'Content-Type' : 'text/html' } ) ; res . write ( '<h1>Success!</h1>' ) ; res . end ( '<pre>' + sys . inspect ( form . data ) + '</pre>' ) ; }
function ( form ) { var req_data = require ( 'url' ) . parse ( req . url , 1 ) . query ; res . writeHead ( 200 , { 'Content-Type' : 'text/html' } ) ; res . write ( '<h1>Success!</h1>' ) ; res . end ( '<pre>' + sys . inspect ( form . data ) + '</pre>' ) ; }
function ( ) { if ( ! settings . enabled ) { return ; } $selectionRect . hide ( ) . appendTo ( 'body' ) ; $document . on ( 'mousedown' , '.noSelection' , noSelection ) . on ( 'mousedown' , '.noSelectionUnlessCtrl,input,a' , noSelectionUnlessCtrl ) . on ( 'mousedown' , selectionStart ) ; }
function checkBrowserCompatibilities ( ) { var incompatibilities = '' ; if ( Modernizr . localstorage ) { } else { incompatibilities = incompatibilities + 'localstorage, ' ; } if ( Modernizr . geolocation ) { } else { incompatibilities = incompatibilities + 'geolocation, ' ; } if ( incompatibilities != '' ) { consoleLog ( 'Your browser is not fully compatible with PT Tracker.' + '\n' + 'The services lacking are: ' + incompatibilities ) ; } }
function ( ) { var self = this ; var done = self . async ( ) ; var templateDir = this . file . src ; var handlebarsCmd = __dirname + '/../node_modules/.bin/handlebars -m ' + templateDir + '/*.handlebars -f ' + this . file . dest ; exec ( handlebarsCmd , done ) ; }
function skipWhitespaceNodes ( e , next ) { while ( e && ( e . nodeType === 8 || ( e . nodeType === 3 && /^[ \t\n\r]*$/ . test ( e . nodeValue ) ) ) ) { e = next ( e ) ; } return e ; }
function hasStyleIndent ( n ) { n = dom . getParent ( n , dom . isBlock ) ; return n && ( parseInt ( ed . dom . getStyle ( n , 'margin-left' ) || 0 , 10 ) + parseInt ( ed . dom . getStyle ( n , 'padding-left' ) || 0 , 10 ) ) > 0 ; }
function ( obj ) { obj . find ( 'span[lang]' ) . each ( function ( ) { jQuery ( this ) . removeClass ( WAI_LANG_CLASS ) ; } ) ; }
function ( vector ) { var angle = this . angleFrom ( vector ) ; return ( angle === null ) ? null : ( Math . abs ( this . angleFrom ( vector ) - Math . PI / 2 ) < jsMetric . precision ) ; }
function ( k ) { var new_elements = [ ] ; for ( var i = 1 ; i <= this . dimensions ( ) ; i ++ ) { new_elements . push ( k * this . e ( i ) ) ; } return Vector . create ( new_elements ) ; }
function ( ) { var elements ; if ( arguments [ 0 ] == undefined ) { return null ; } else { if ( arguments [ 0 ] [ 0 ] == undefined ) { elements = arguments ; } else { elements = arguments [ 0 ] ; } if ( elements . length < 1 ) { return null ; } else { return new Vector . Abstract ( elements ) ; } } }
function ensureHttpsMiddleware ( req , res , next ) { next ( ) ; if ( req . protocol === 'http' && req . connection . encrypted === false ) { res . redirect ( replaceProtocol ( req ) ) ; } }
function ( ) { delete req . headers [ 'x-forwarded-proto' ] ; req . protocol = 'http' ; req . connection . encrypted = false ; res . redirect = function ( url ) { throw Error ( 'Redirection to ' + url ) ; } ; }
function ( event ) { $ ( this ) . closest ( "li" ) . slideUp ( ) . parents ( "ul" ) . children ( ":hidden" ) . slideDown ( ) . first ( ) . find ( ":tabbable:first" ) . focus ( ) ; return false ; }
function ( ) { if ( typeof ( self . level ) == 'undefined' ) { self . level = 1 ; var levelCookie = self . getCookie ( 'level' ) ; if ( levelCookie ) { parsedLevelCookie = parseInt ( levelCookie ) ; if ( parsedLevelCookie > 1 ) { while ( self . level < parsedLevelCookie ) { self . level ++ ; self . addLevelToSelect ( ) ; } } } } self . loadLevel ( ) ; }
function ( ) { self . makeTable ( ) ; self . resetUserBoard ( ) ; self . genClues ( ) ; self . drawClues ( ) ; for ( y = 0 ; y < self . getHeight ( ) ; y ++ ) self . checkClue ( 0 , y ) ; for ( x = 0 ; x < self . getWidth ( ) ; x ++ ) self . checkClue ( x , 0 ) ; self . setEvents ( ) ; }
function ( i ) { iWidth = $ ( this ) . outerWidth ( ) ; that . s . aiWidths . push ( iWidth ) ; if ( i < that . s . iLeftColumns ) { iLeftWidth += iWidth ; } if ( that . s . iTableColumns - that . s . iRightColumns <= i ) { iRightWidth += iWidth ; } }
function ( ) { var store = Ext . getStore ( 'MyStore' ) ; var feeds = store . getRange ( 0 , store . getCount ( ) ) ; for ( var i = 0 ; i < feeds . length ; i ++ ) { var feed = feeds [ i ] ; console . log ( "applycurrent=" + feed . applyCurrent ( ) ) ; } }
function ( ) { $ ( 'button' ) . removeClass ( 'activeFilter' ) ; $ ( this ) . addClass ( 'activeFilter' ) ; $ ( this ) . parent ( ) . next ( ) . next ( ) . find ( 'tr' ) . show ( ) ; $ . cookie ( 'lastActiveFilter' , 'showAllEntries' ) ; updateCount ( ) ; }
function ( ) { $ ( 'button' ) . removeClass ( 'activeFilter' ) ; $ ( this ) . addClass ( 'activeFilter' ) ; hideResolved ( $ ( this ) . parent ( ) . next ( ) . next ( ) ) ; $ . cookie ( 'lastActiveFilter' , 'hideResolved' ) ; updateCount ( ) ; }
function ( ) { this . require = require ; this . process = process ; this . module = module ; this . console . log ( 'process' , process ) ; this . show ( ) ; console . log ( "Window Ready" ) ; }
function ( ) { return this . categorisedUsers_ [ this . states_ [ this . stateIndex_ ] ] ; }
function ( i ) { var linkedInfo = $ ( this ) . parents ( '.value' ) . find ( '.linked_info' ) . text ( ) ; if ( linkedInfo . length ) { bindLinked ( $ ( this ) . attr ( 'id' ) , eval ( '(' + linkedInfo + ')' ) ) ; } }
function ( chemical ) { for ( var i = 0 ; i < this . _listeners . length ; i ++ ) { var listener = this . _listeners [ i ] ; if ( chemical . type && listener . chemicalPattern === chemical . type ) { if ( listener . handle ( chemical ) ) return ; } } }
function test_all_replied ( ) { let aReply = create_message ( { subject : "People never reply to this email." , to : [ [ "Len" , "len@somewhere.com" ] ] , toCount : 1 , inReplyTo : gTestMessage , } ) ; add_message_to_folder ( folder , aReply ) ; let aReplyHdr = select_click_row ( 2 ) ; wait_for_indexing ( [ aReplyHdr ] ) ; let curMessage = select_click_row ( 0 ) ; wait_for_query_to_complete ( ) ; assertionHelper . assert_allRepliedBox_shown ( ) ; }
function ( ) { var urlParts = document . URL . split ( '?' ) ; var selectedExpr = /selected=(.*)/g ; try { var selectedString = selectedExpr . exec ( decodeURIComponent ( urlParts [ 1 ] ) ) [ 1 ] ; return JSON . parse ( selectedString ) ; } catch ( e ) { window . history . pushState ( '' , '' , urlParts [ 0 ] ) ; return [ ] ; } }
function ( ) { $to . removeClass ( 'ui-to-page-pre-transition' ) ; $to . addClass ( $ . mobile . activePageClass ) ; $to . addClass ( name + " in" + reverseClass ) ; if ( none ) { doneIn ( ) ; } else { $to . animationComplete ( doneIn ) ; } }
function ( series , x , y ) { var dateStr = window . moment . utc ( new Date ( x * 1000 ) ) . local ( ) . format ( "YYYY-MM-DD h:mm a" ) ; var date = '<span class="date">' + dateStr + '</span>' ; var swatch = '<span class="detail_swatch" style="background-color: ' + series . color + '"></span>' ; var content = swatch + series . name + ": " + parseInt ( y ) + '<br>' + date ; return content ; }
function ( ) { if ( req . readyState === 4 ) { var s = req . status ; if ( ! s && d3_xhrLocal && ! d3_xhrCrossDomain ( url ) ) { s = req . responseText ? 200 : 404 ; } callback ( s >= 200 && s < 300 || s === 304 ? req : null ) ; } }
function ( w ) { chrome . tabs . getSelected ( w . id , function ( tab ) { d . callback ( tab ) ; } ) ; }
function ok ( tab ) { var ary ; if ( that . queue . length !== 0 ) { ary = that . queue ; that . queue = [ ] ; ary . push ( url ) ; } else { ary = [ url ] ; } var code = '(' + executor . toString ( ) + '(' + JSON . stringify ( ary ) + ')())' ; chrome . tabs . executeScript ( tab . id , { code : code } , function ( ) { } ) ; }
function addMonument ( monument , onClick ) { var marker = new L . Marker ( new L . LatLng ( monument . lat , monument . lon ) ) ; var popup = "<div><strong>" + monument . name + "</strong></div>" ; var popupDOM = $ ( popup ) . click ( function ( ) { onClick ( monument ) ; } ) [ 0 ] ; marker . bindPopup ( popupDOM , { closeButton : false } ) ; markerGroup . addLayer ( marker ) ; }
function ( element , value , empty ) { if ( typeof ( element ) == 'string' ) element = '#' + element ; this . replace_html ( jQuery ( element ) , value ) ; if ( empty ) jQuery ( element ) . closest ( 'td' ) . addClass ( 'empty' ) ; }
function ( data ) { var address = location . protocol + '//' + location . host + data . url ; if ( history . replaceState ) history . replaceState ( { } , q . name ( ) , address ) ; $ . noty . close ( vm . save_noty ) ; noty ( { text : 'Saved.' , type : 'success' , timeout : 1000 , layout : 'topCenter' } ) ; }
function ( station ) { return { veryVerbose : true , bssid : station . bssid , auto : true , channel : station . channel , dhSmall : true , noNacks : true , interface : 'mon0' } ; }
function ReaverData ( rvrPath , dbFile ) { this . rvrPath = rvrPath != null ? rvrPath : '/usr/local/etc/reaver/' ; this . dbFile = dbFile != null ? dbFile : 'reaver.db' ; this . loadSession = __bind ( this . loadSession , this ) ; if ( this . rvrPath . slice ( - 1 ) !== '/' ) this . rvrPath += '/' ; this . db = new sqlite3 . Database ( "" + this . rvrPath + this . dbFile ) ; }
function ( klen ) { var i , max , _results ; max = Math . pow ( 10 , klen ) ; _results = [ ] ; for ( i = 0 ; 0 <= max ? i < max : i > max ; 0 <= max ? i ++ : i -- ) { _results . push ( padKey ( "" + i , klen ) ) ; } return _results ; }
function ( ifaces ) { var iface , phys , _i , _len , _name , _ref ; phys = { } ; for ( _i = 0 , _len = ifaces . length ; _i < _len ; _i ++ ) { iface = ifaces [ _i ] ; if ( ( _ref = phys [ _name = iface . phyid ] ) == null ) phys [ _name ] = [ ] ; phys [ iface . phyid ] . push ( iface ) ; } return cb ( phys ) ; }
function ( ) { var active = $ ( '#lab-nav-list' ) . find ( '.active' ) ; active . removeClass ( 'active' ) . addClass ( 'hide' ) ; active . next ( ) . removeClass ( 'hide' ) ; var current = $ ( this ) . find ( '.hide' ) ; current . removeClass ( 'hide' ) . addClass ( 'active' ) ; current . next ( ) . addClass ( 'hide' ) ; }
function ( elem ) { var target = $ ( elem ) . closest ( ".entry" ) . find ( ".entry-container a.entry-title-link" ) ; return { text : target . text ( ) , url : target . attr ( 'href' ) , placement : 'google-reader-icon' } ; }
function ( elem ) { var target = $ ( elem ) . closest ( ".entry" ) . find ( ".entry-main" ) ; return { text : target . find ( '.entry-title' ) . text ( ) , url : target . find ( '.entry-original' ) . attr ( 'href' ) , placement : 'google-reader-icon' } ; }
function createAnchor ( annotation ) { annotationAnchorAncestor = $ ( '#' + annotation . ancestorId ) ; annotationAnchor = $ ( annotationAnchorAncestor ) . parent ( ) . find ( ':contains(' + annotation . anchorText + ')' ) . last ( ) ; $ ( annotationAnchor ) . addClass ( 'annotated' ) ; $ ( annotationAnchor ) . attr ( 'annotation' , annotation . annotationText ) ; }
function output ( data ) { messageManager . sendAsyncMessage ( address , data ) ; }
function ( data ) { pop . style . display = 'block' ; pop . style . width = '500px' ; $ ( pop ) . center ( ) ; $ ( bg ) . show ( ) . center ( ) ; afd . innerHTML = data ; afd . onmouseup = function ( ) { input . setAttribute ( 'value' , getSelectedText ( ) . trim ( ) ) ; } submit . onclick = addTheTrack ; submit . onkeydown = addTheTrack ; }
function ( ) { proto . addBookButton . onmouseover = function ( ) { proto . addBooki . classList . add ( 'icon-white' ) ; } ; proto . addBookButton . onmouseout = function ( ) { proto . addBooki . classList . remove ( 'icon-white' ) ; } proto . addBookButton . onclick = addBookListener ; proto . addBookButton . onkeydown = addBookListener ; }
function toArray ( obj ) { var undef , out , i ; if ( obj && ! obj . splice ) { out = [ ] ; for ( i = 0 ; true ; i ++ ) { if ( obj [ i ] ) out [ i ] = obj [ i ] ; else break ; } return out ; } return obj ; }
function ( ) { var past = this . matched . substr ( 0 , this . matched . length - this . match . length ) ; return ( past . length > 20 ? '...' : '' ) + past . substr ( - 20 ) . replace ( /\n/g , "" ) ; }
f var lexgrammar = 'D [0-9]\nID [a-zA-Z][a-zA-Z0-9]+\n%%\n\n{D}"ohhai" {print(9);}\n"{" {return \'{\';}' ; var expected = { macros : { "D" : "[0-9]" , "ID" : "[a-zA-Z][a-zA-Z0-9]+" } , rules : [ [ "{D}ohhai\\b" , "print(9);" ] , [ "\\{" , "return '{';" ] ] } ; assert . deepEqual ( lex . parse ( lexgrammar ) , expected , "grammar should be parsed correctly" ) ; } ;
function ( ) { var lexgrammar = '\nRULE [0-9]\n\n%{\n hi <stuff> \n%}\n%%\n"["[^\\]]"]" %{\nreturn true;\n%}\n' ; var expected = { macros : { "RULE" : "[0-9]" } , actionInclude : "\n hi <stuff> \n" , rules : [ [ "\\[[^\\]]\\]" , "\nreturn true;\n" ] ] } ; assert . deepEqual ( lex . parse ( lexgrammar ) , expected , "grammar should be parsed correctly" ) ; }
function ( ) { var data = { text : $ ( this ) . siblings ( '.feedback-input' ) . val ( ) , image : userImage } ; $ ( this ) . siblings ( '.comments' ) . append ( Mustache . render ( commentTemplate , data ) ) ; }
function ( token ) { if ( token . type !== 'explicituri' ) return this . _error ( 'Expected explicituri to follow prefix "' + this . prefix + '"' , token ) ; if ( this . _baseURI === null || absoluteURI . test ( token . value ) ) this . _prefixes [ this . _prefix ] = token . value ; else this . _prefixes [ this . _prefix ] = this . _baseURI + token . value ; return this . _readDeclarationPunctuation ; }
function ( token ) { if ( token . type !== 'explicituri' ) return this . _error ( 'Expected explicituri to follow base declaration' , token ) ; if ( this . _baseURI === null || absoluteURI . test ( token . value ) ) this . _baseURI = token . value ; else this . _baseURI += token . value ; return this . _readDeclarationPunctuation ; }
function ( ) { var id = ed . getParam ( 'wp_fullscreen_editor_id' ) || ed . getParam ( 'fullscreen_editor_id' ) || ed . id , link = tinymce . DOM . select ( '#wp-' + id + '-media-buttons a.thickbox' ) ; if ( link && link [ 0 ] ) link = link [ 0 ] ; else return ; tb_show ( '' , link . href ) ; tinymce . DOM . setStyle ( [ 'TB_overlay' , 'TB_window' , 'TB_load' ] , 'z-index' , '999999' ) ; }
function ( ) { this . console = byId ( 'console' ) ; var events = [ 'new_tuples' , 'add_statement' , 'del_statement' , 'layout_change' , 'log' , 'error' , 'statements_list' , 'get_statements_list' ] ; 445487 ; 454.5454 ; var canard = { coucou : "salut" , plop : 54 } ; for ( var i = 0 ; i < events . length ; ++ i ) EventBus . addListener ( events [ i ] , this . manageEvent , this ) ; this . max_capacity = false ; }
function ( ) { EventBus . send ( 'new_tuples' , { statement_name : statement_name , data : [ _addTuple ( i ) ] } ) ; if ( ++ i == json . data . length ) window . clearInterval ( intervale ) ; }
function ( widget , states ) { var label = widget . getChildControl ( "label" ) ; var icon = widget . getChildControl ( "icon" ) ; if ( states . selected ) { label . setDecorator ( "selected" ) ; label . setTextColor ( "text-selected" ) ; icon . setDecorator ( "group" ) ; } else { label . resetDecorator ( ) ; label . resetTextColor ( ) ; icon . resetDecorator ( ) ; } }
function anonymous ( yy , yy_ , $avoiding_name_collisions , YY_START ) { var YYSTATE = YY_START switch ( $avoiding_name_collisions ) { case 0 : return 9 ; break ; case 1 : return 11 ; break ; case 2 : return 12 ; break ; case 3 : return 14 ; break ; case 4 : return 17 ; break ; case 5 : return 18 ; break ; case 6 : return 19 ; break ; case 7 : return 20 ; break ; case 8 : return 5 ; break ; } }
function anonymous ( yy , yy_ , $avoiding_name_collisions , YY_START ) { var YYSTATE = YY_START switch ( $avoiding_name_collisions ) { case 0 : return 9 ; break ; case 1 : return 11 ; break ; case 2 : return 12 ; break ; case 3 : return 14 ; break ; case 4 : return 17 ; break ; case 5 : return 18 ; break ; case 6 : return 19 ; break ; case 7 : return 20 ; break ; case 8 : return 5 ; break ; } }
function ( buffer , prop ) { this [ '_' + prop ] = buffer ; Object . defineProperty ( enchant . gl . mmd . MMesh . prototype , prop , { get : function ( ) { return this [ '_' + prop ] . _array ; } , set : function ( array ) { this [ '_' + prop ] . _array = array ; if ( this . _appear ) { this [ '_' + prop ] . _bufferData ( ) ; } } } ) ; }
function ( buffer , prop ) { this [ '_' + prop ] = buffer ; Object . defineProperty ( enchant . gl . mmd . MMesh . prototype , prop , { get : function ( ) { return this [ '_' + prop ] . _array ; } , set : function ( array ) { this [ '_' + prop ] . _array = array ; if ( this . _appear ) { this [ '_' + prop ] . _bufferData ( ) ; } } } ) ; }
function ( buffer , prop ) { this [ '_' + prop ] = buffer ; Object . defineProperty ( enchant . gl . mmd . MMesh . prototype , prop , { get : function ( ) { return this [ '_' + prop ] . _array ; } , set : function ( array ) { this [ '_' + prop ] . _array = array ; if ( this . _appear ) { this [ '_' + prop ] . _bufferData ( ) ; } } } ) ; }
function ( ) { _advanceYear_MYP ( - 1 ) }
function ( id , fn , length ) { if ( typeof fn != 'function' ) throw 'Invalid type' ; length = typeof length == 'number' ? length : null ; _queue [ id ] = _queue [ id ] ? { callback : fn , iterations : ( length == null ? _queue [ id ] . iterations : length ) , iterated : _queue [ id ] . iterated || 0 } : { callback : fn , iterations : length , iterated : 0 } ; return this ; }
function ( err , data ) { if ( error !== null ) { console . log ( 'exec error: ' + error ) ; res . send ( { error : error } ) ; } else { res . send ( { url : config . publicUrl + "/" + imgName } ) ; console . log ( "cbSvg : " , cbSvg . toString ( ) ) ; cbSvg && cbSvg ( svg . toString ( ) ) ; } }
function ( event ) { var height , width , _ref ; _ref = getDimensions ( ) , width = _ref . width , height = _ref . height ; return $ ( '#output-text' ) . text ( DFHMExport [ "export" ] ( width , height , determineSize ( ) , worldState ) ) ; }
function checkGeneratedField ( field , id , title , startIndex , classes , opts , required ) { var divId = "je-" + id + "-" + startIndex , inputId = "je-" + id + "-input-" + ( startIndex + 1 ) ; deepEqual ( field , { "div" : { "id" : divId , "class" : classes , "$childs" : [ priv . label ( title , inputId ) , priv . input ( id , opts . type , inputId , opts , required ) ] } } ) ; }
function ( req , res , next ) { metrics . userEntry ( req ) ; renderCachableView ( req , res , 'dialog.ejs' , { title : _ ( 'A Better Way to Sign In' ) , layout : 'dialog_layout.ejs' , useJavascript : true , production : config . get ( 'use_minified_resources' ) } ) ; }
function ( ) { return $ ( "<div></div>" , { "class" : "select2-container" , "style" : "width: " + this . getContainerWidth ( ) } ) . html ( [ "    <a href='javascript:void(0)' class='select2-choice'><input type='text' class='select2-offscreen select2-focusser'/>" , "   <span></span><abbr class='select2-search-choice-close' style='display:none;'></abbr>" , "   <div><b></b></div>" , "</a>" , "    <div class='select2-drop' style='display:none;'>" , "   <div class='select2-search'>" , "       <input type='text' autocomplete='off'/>" , "   </div>" , "   <ul class='select2-results'>" , "   </ul>" , "</div>" ] . join ( "" ) ) ; }
function ( ) { return $ ( "<div></div>" , { "class" : "select2-container select2-container-multi" , "style" : "width: " + this . getContainerWidth ( ) } ) . html ( [ "    <ul class='select2-choices'>" , "  <li class='select2-search-field'>" , "    <input type='text' autocomplete='off' style='width: 25px;'>" , "  </li>" , "</ul>" , "<div class='select2-drop select2-drop-multi' style='display:none;'>" , "   <ul class='select2-results'>" , "   </ul>" , "</div>" ] . join ( "" ) ) ; }
function ( data ) { $error . show ( ) . html ( ( data && data . message ) || "There was a problem fetching the feed from this URL." ) ; $loading . removeClass ( 'NB-active' ) ; $submit . removeClass ( 'NB-disabled' ) . attr ( 'value' , 'Parse this RSS/XML Feed' ) ; }
function ( data ) { $error . show ( ) . html ( ( data && data . message ) || "There was a problem fetching the feed from this URL." ) ; $loading . removeClass ( 'NB-active' ) ; $submit . removeClass ( 'NB-disabled' ) . attr ( 'value' , 'Fetch Feed from Website' ) ; }
function ( prop ) { if ( ! entityClass [ prop . name . toLowerCase ( ) ] ) { alert ( "cannot instance entity of type '" + prop . name + "': Class not found!" ) ; return null ; } return new entityClass [ prop . name . toLowerCase ( ) ] ( prop . x , prop . y , prop ) ; }
function checkLoadStatus ( ) { if ( loadCount == ( resourceCount - tmxCount ) ) { for ( var xmlObj in xmlList ) { if ( xmlList [ xmlObj ] . isTMX ) { me . levelDirector . addTMXLevel ( xmlObj ) ; obj . onResourceLoaded ( ) ; } } if ( obj . onload ) { timerId = setTimeout ( obj . onload , 300 ) ; } else alert ( "no load callback defined" ) ; } else { timerId = setTimeout ( checkLoadStatus , 100 ) ; } }
function ( i ) { $ . getScript ( appPartsLocation + appParts [ i ] + '.js' ) . done ( function ( ) { if ( i < appParts . length - 1 ) prepareApp ( ++ i ) ; else { App . Modules . LoadModulesByScheme ( ) ; appIsBuilt = true ; } } ) . fail ( function ( ) { console . warn ( 'Error: ' + appPartsLocation + appParts [ i ] + '.js' ) ; } ) ; }
function ( eventName , callbackFunction , context ) { if ( App . Settings . Debug . enabled ) console . log ( 'Binded: ' + eventName + ', with responder: ' + callbackFunction . toString ( ) . substr ( 0 , 100 ) + '...' ) ; var evt ; if ( _eventsArray [ eventName ] === undefined ) { _eventsArray [ eventName ] = new Event ( ) ; } evt = _eventsArray [ eventName ] ; evt . subscribe ( callbackFunction , context ) ; return this ; }
function ( stopped ) { goog . style . transition . removeAll ( this . element_ ) ; goog . style . setStyle ( this . element_ , this . finalStyle_ ) ; this . endTime = goog . now ( ) ; this . setStateStopped ( ) ; if ( stopped ) { this . onStop ( ) ; } else { this . onFinish ( ) ; } this . onEnd ( ) ; }
function ( ) { var id , newId ; id = 'id-' + this . uniqueId ; if ( ! this . waiters [ id ] ) { return id ; } if ( this . uniqueId ++ === MAX_WAITERS ) { this . uniqueId = 1 ; } if ( this . waiters [ newId = 'id-' + this . uniqueId ] ) { delete this . waiters [ newId ] ; } return this . generateUniqueId ( ) ; }
function ( options ) { var self = this , templateData = helpers . extend ( { } , options , { privacy_url : options . privacyURL || null , tos_url : options . tosURL || null } ) ; self . renderDialog ( "add_email" , templateData ) ; self . click ( "#cancel" , cancelAddEmail ) ; Module . sc . start . call ( self , options ) ; }
function ( template , data ) { var self = this ; self . hideWait ( ) ; self . hideError ( ) ; self . hideDelay ( ) ; screens . form . show ( template , data ) ; dom . focus ( "input:visible:not(:disabled):eq(0)" ) ; if ( $ ( "*:focus" ) . length === 0 ) { dom . focus ( "button:visible:eq(0)" ) ; } }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { equal ( info . type , "primary" , "correct type" ) ; equal ( info . email , TESTEMAIL , "email_chosen with correct email" ) ; equal ( info . add , false , "add is not specified with CREATE_EMAIL option" ) ; start ( ) ; } ) ; try { controller . get ( testHelpers . testOrigin , { } , function ( ) { } , function ( ) { } ) ; } catch ( e ) { } }
function ( ) { createController ( { window : win , add : false , requiredEmail : "unregistered@testuser.com" , email : "unregistered@testuser.com" , auth_url : "http://testuser.com/sign_in" , privacyURL : "http://testuser.com/priv.html" , tosURL : "http://testuser.com/tos.html" } ) ; equal ( $ ( ".tospp" ) . length , 1 , "tospp has been added to the DOM" ) ; }
function createMachine ( ) { machine = bid . State . create ( ) ; actions = new ActionsMock ( ) ; machine . start ( { controller : actions } ) ; }
function ( ) { mediator . publish ( "user_staged" , { email : TEST_EMAIL } ) ; equal ( actions . info . doConfirmUser . email , TEST_EMAIL , "waiting for email confirmation for testuser@testuser.com" ) ; }
function ( ) { mediator . publish ( "forgot_password" , { email : TEST_EMAIL , requiredEmail : true } ) ; equal ( actions . info . doForgotPassword . email , TEST_EMAIL , "correct email passed" ) ; equal ( actions . info . doForgotPassword . requiredEmail , true , "correct requiredEmail passed" ) ; }
function ( ) { mediator . publish ( "authenticate" , { email : TEST_EMAIL } ) ; equal ( actions . info . doAuthenticate . email , TEST_EMAIL , "authenticate with testuser@testuser.com" ) ; }
function ( ) { var email = TEST_EMAIL ; storage . addEmail ( email , { type : "secondary" } ) ; xhr . setContextInfo ( "auth_level" , "assertion" ) ; mediator . publish ( "email_chosen" , { email : email , complete : function ( ) { equal ( actions . called . doAuthenticateWithRequiredEmail , true , "doAuthenticateWithRequiredEmail called" ) ; start ( ) ; } } ) ; }
function ( ) { storage . addEmail ( TEST_EMAIL , { type : "secondary" } ) ; xhr . setContextInfo ( "auth_level" , "password" ) ; mediator . subscribe ( "email_valid_and_ready" , function ( msg , info ) { equal ( info . email , TEST_EMAIL , "correctly redirected to email_valid_and_ready with correct email" ) ; start ( ) ; } ) ; mediator . publish ( "email_chosen" , { email : TEST_EMAIL } ) ; }
function ( ) { mediator . publish ( "start" , { hostname : "http://example.com" , privacyURL : "http://example.com/priv.html" , tosURL : "http://example.com/tos.html" } ) ; mediator . publish ( "assertion_generated" , { assertion : null } ) ; equal ( actions . called . doPickEmail , true , "doPickEmail callled" ) ; equal ( actions . info . doPickEmail . origin , "http://example.com" , "hostname preserved" ) ; equal ( actions . info . doPickEmail . privacyURL , "http://example.com/priv.html" , "privacyURL preserved" ) ; equal ( actions . info . doPickEmail . tosURL , "http://example.com/tos.html" , "tosURL preserved" ) ; }
function ( ) { var identities = lib . getStoredEmailKeypairs ( ) ; equal ( "object" , typeof identities , "object returned" ) ; }
function initialState ( info ) { var self = this ; self . submit = checkEmail ; if ( info && info . email && info . type === "secondary" && info . known ) { enterPasswordState . call ( self , info . ready ) ; } else { showHint ( "start" ) ; complete ( info . ready ) ; } }
function ( options ) { options = options || { } ; renderer . render ( "#rp_info" , "rp_info" , { hostname : options . hostname , siteName : options . siteName , siteLogo : options . siteLogo } ) ; sc . start . call ( this , options ) ; }
function ( msg , info ) { self . hostname = info . hostname ; self . privacyURL = info . privacyURL ; self . tosURL = info . tosURL ; requiredEmail = info . requiredEmail ; startAction ( false , "doRPInfo" , info ) ; if ( info . email && info . type === "primary" ) { primaryVerificationInfo = info ; redirectToState ( "primary_user" , info ) ; } else { startAction ( "doCheckAuth" ) ; } }
function ( msg , info ) { var authenticated = info . authenticated ; if ( requiredEmail ) { self . email = requiredEmail ; startAction ( "doAuthenticateWithRequiredEmail" , { email : requiredEmail , privacyURL : self . privacyURL , tosURL : self . tosURL } ) ; } else if ( authenticated ) { redirectToState ( "pick_email" ) ; } else { redirectToState ( "authenticate" ) ; } }
function ( authentication ) { if ( authentication === "assertion" ) { startAction ( "doAuthenticateWithRequiredEmail" , { email : email , secondary_auth : true , privacyURL : self . privacyURL , tosURL : self . tosURL } ) ; } else { redirectToState ( "email_valid_and_ready" , info ) ; } oncomplete ( ) ; }
function ( passwordNeeded ) { if ( passwordNeeded ) { self . addEmailEmail = info . email ; info . cancelable = ! requiredEmail ; startAction ( false , "doSetPassword" , info ) ; } else { startAction ( false , "doStageEmail" , info ) ; } complete ( info . complete ) ; }
function ( err ) { err . message += " in '" + ( this . sourceFile || '<unknown>' ) + "'" ; if ( typeof this . sourceLine != 'undefined' ) { err . message += ' on line ' + this . sourceLine ; } return err ; }
function ( evt ) { if ( ! isPendingSelection ) return ; isPendingSelection = false ; window . clearTimeout ( selectionTimeout ) ; self . selectRowAtIndex ( this . tableViewCell . getIndex ( ) ) ; }
function ( value ) { Pushpop . TableViewCell . prototype . setSelected . apply ( this , arguments ) ; var $element = this . $element ; if ( value ) { $element . children ( 'input' ) . focus ( ) ; window . setTimeout ( function ( ) { $element . removeClass ( 'pp-table-view-selected-state' ) ; } , 100 ) ; } else { $element . children ( 'input' ) . blur ( ) ; } }
function ( request_params ) { if ( request_params && request_params . popup ) { var uo = new UiOverlay ( ) ; uo . show ( request_params . popup ) ; } else { var uo = new UiOverlay ( ) ; uo . hide ( ) ; } }
function ( ) { this . table = this . $ ( 'tbody' ) ; this . _modelBinder = new Backbone . ModelBinder ( ) ; this . newFieldView = new NewFieldView ( { model : new Field } ) ; this . model . get ( 'fields' ) . bind ( 'add' , this . onNewField , this ) ; this . render ( ) ; }
function ( session ) { var session_name = TissueStack . Admin . prototype . getCookie ( "session" ) ; if ( session_name != null && session_name != "" ) { TissueStack . Admin . prototype . session = session_name ; } else { session_name = session ; if ( session_name != null && session_name != "" ) { TissueStack . Admin . prototype . setCookie ( "session" , session_name . id , 1 ) ; } } }
function ( ) { $ ( "#providerId-autocomplete" ) . val ( "" ) ; $ ( "#providerId" ) . html ( '' ) ; }
function ( event ) { var districtId = $ ( "#district-autocomplete" ) . val ( ) ; var providerId = $ ( "#providerId-autocomplete" ) . val ( ) ? $ ( "#providerId-autocomplete" ) . val ( ) : "" ; var data = { "selectedDistrict" : districtId , "selectedProvider" : providerId } ; $ . post ( '/whp/patients/search' , data , function ( response ) { $ ( '#patients' ) . html ( response ) ; } ) }
function ( evt ) { sink . write ( evt ) ; }
function ( e ) { if ( ! e ) this . paused = true clearInterval ( this . interval ) this . interval = null return this }
function ( e ) { switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : e . preventDefault ( ) this . prev ( ) break case 40 : e . preventDefault ( ) this . next ( ) break } e . stopPropagation ( ) }
function ( e ) { if ( ! e ) this . paused = true clearInterval ( this . interval ) this . interval = null return this }
function ( e ) { switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : e . preventDefault ( ) this . prev ( ) break case 40 : e . preventDefault ( ) this . next ( ) break } e . stopPropagation ( ) }
function ( e ) { if ( ! e ) this . paused = true clearInterval ( this . interval ) this . interval = null return this }
function ( data ) { _this . trackInfo = data ; _this . log ( _this . trackInfo ) ; _this . duration = parseInt ( _this . trackInfo . duration , 10 ) ; _this . trackInfo = _this . trackInfo . tracks ; _this . currentMarker = _this . getMarker ( _this . currentTrack - 1 ) ; _this . nextMarker = _this . getMarker ( _this . currentTrack ) ; return _this . numTracks = parseInt ( _this . trackInfo . length , 10 ) ; }
function thlui_init ( ) { this . delNumList = [ ] ; this . deleteAllButton . addEventListener ( 'click' , this . deleteAllThreads . bind ( this ) ) ; this . deleteSelectedButton . addEventListener ( 'click' , this . deleteThreads . bind ( this ) ) ; }
function thlui_cleanForm ( ) { var inputs = this . view . getElementsByTagName ( 'input' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; } }
function thui_init ( ) { this . sendButton . addEventListener ( 'click' , this . sendMessage . bind ( this ) ) ; this . pickButton . addEventListener ( 'click' , this . pickContact . bind ( this ) ) ; this . deleteAllButton . addEventListener ( 'click' , this . deleteAllMessages . bind ( this ) ) ; this . deleteSelectedButton . addEventListener ( 'click' , this . deleteMessages . bind ( this ) ) ; this . input . addEventListener ( 'input' , this . updateInputHeight . bind ( this ) ) ; }
function thui_updateHeaderData ( ) { var number = MessageManager . getNumFromHash ( ) ; ThreadUI . title . innerHTML = number ; ContactDataManager . getContactData ( number , function gotContact ( contact ) { if ( contact && contact . length > 0 ) { ThreadUI . title . innerHTML = contact [ 0 ] . name ; } } ) ; }
function thui_cleanForm ( ) { var inputs = this . view . getElementsByTagName ( 'input' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; } }
function onsave ( msg ) { if ( ! msg ) { console . log ( 'Message app - pending message save failed!' ) ; PendingMsgManager . saveToMsgDB ( message , this ) ; } if ( window . location . hash == '#new' ) { window . location . hash = '#num=' + num ; } MessageManager . getMessages ( ThreadListUI . renderThreads ) ; }
function ( ) { var first , next ; first = this . first ; if ( ! first ) { return ; } this . length -- ; if ( this . length === 0 ) { this . last = null ; } next = first . next ; delete this [ first . id ] ; return this . first = next ; }
function ( id ) { var item , next , prev ; item = this [ id ] ; prev = item . prev , next = item . next ; prev . next = next ; if ( next ) { next . prev = prev ; } else { this . last = prev ; } return this . length -- ; }
function getLocalization ( localeCode , skipFallback , set ) { var loc ; if ( ! localeCode || ! isString ( localeCode ) ) return CurrentLocalization ; loc = Localizations [ localeCode ] || Localizations [ localeCode . slice ( 0 , 2 ) ] ; if ( ! loc || set ) loc = setLocalization ( localeCode , set , skipFallback ) ; return loc ; }
function ( localeCode , set ) { var loc = getLocalization ( localeCode , true , set ) ; if ( loc ) { CurrentLocalization = loc ; if ( localeCode && localeCode != loc [ 'code' ] ) { loc [ 'code' ] = localeCode ; } } return loc ; }
function getLocalization ( localeCode , skipFallback , set ) { var loc ; if ( ! localeCode || ! isString ( localeCode ) ) return CurrentLocalization ; loc = Localizations [ localeCode ] || Localizations [ localeCode . slice ( 0 , 2 ) ] ; if ( ! loc || set ) loc = setLocalization ( localeCode , set , skipFallback ) ; return loc ; }
function ( name , i ) { if ( ! pre [ i + 15 ] ) return ; pre [ i + 15 ] . split ( ',' ) . forEach ( function ( t , j ) { if ( t ) set [ 'modifiers' ] . push ( { name : name , src : t , value : j - 2 } ) ; } ) ; }
function ( localeCode , set ) { var loc = getLocalization ( localeCode , true , set ) ; if ( loc ) { CurrentLocalization = loc ; if ( localeCode && localeCode != loc [ 'code' ] ) { loc [ 'code' ] = localeCode ; } } return loc ; }
function Wb ( a , b ) { var c = a . indexOf ( b ) ; c > - 1 && a . splice ( c , 1 ) } function Xb ( a , b , c ) { E ( b ) && Wb ( Z , b ) ; Wb ( Z , c ) ; a . unshift ( { la : b , ua : c } ) }
function ( a ) { var b = t ( "^[" + a . source + "\\s]+$" ) , c = t ( "[" + a . source + "]" ) ; a . ca . forEach ( function ( d ) { ia ( v . prototype , "is" + d , function ( ) { return b . test ( this . trim ( ) ) } ) ; ia ( v . prototype , "has" + d , function ( ) { return c . test ( this ) } ) } ) }
function yb ( a , b ) { this . start = ea ( a ) ? a . clone ( ) : new u ; this . end = ea ( b ) ? b . clone ( ) : new u } yb . prototype . toString = function ( ) { return this . isValid ( ) ? this . start . full ( ) + ".." + this . end . full ( ) : "Invalid DateRange" }
function zb ( a , b , c , d , e ) { if ( ! a . ga ) a . ga = [ ] ; D ( b ) || ( b = 0 ) ; a . ga . push ( setTimeout ( function ( ) { a . ga . splice ( g , 1 ) ; c . apply ( d , e || [ ] ) } , b ) ) ; var g = a . ga . length }
function browser_refreshButtons ( ) { this . currentTab . dom . getCanGoBack ( ) . onsuccess = ( function ( e ) { this . backButton . disabled = ! e . target . result ; } ) . bind ( this ) ; this . currentTab . dom . getCanGoForward ( ) . onsuccess = ( function ( e ) { this . forwardButton . disabled = ! e . target . result ; } ) . bind ( this ) ; }
function ( done ) { var place = { uri : 'http://mozilla.org/test3' , title : 'Mozilla' } ; Places . db . savePlace ( place , function ( ) { place . title = 'Mozilla3' ; Places . db . updatePlace ( place , function ( ) { Places . db . getPlace ( 'http://mozilla.org/test3' , function ( place ) { done ( function ( ) { assert . equal ( place . title , 'Mozilla3' ) ; } ) ; } ) ; } ) ; } ) ; }
function ( ) { sys . writeToFile ( "script_construction.json" , resp ) ; if ( sys . getFileContent ( "script_construction.json" ) === undefined ) { print ( filename + " default settings could not be installed." ) ; } else { construction = JSON . parse ( sys . getFileContent ( "script_construction.json" ) ) ; construct ( ) ; print ( "Installed construction default settings." ) ; } }
function ( data ) { $ ( "#executions-view .flash" ) . remove ( ) ; $ ( "#executions-view" ) . prepend ( $ ( "<div/>" ) . addClass ( "flash" ) . addClass ( "notice" ) . text ( IMPASSE . label . noticeSuccessfulUpdate ) ) ; post_save_function ( ) ; var test_case_id = $ ( ":hidden[name='test_plan_case[test_case_id]']" , $this ) . val ( ) ; $ ( "#testplan-tree li#exec_" + test_case_id + " a  ins" ) . css ( { backgroundImage : "url(" + EXEC_ICONS [ execution_status ] + ")" } ) ; }
function ajax_error_handler ( xhr , status , ex ) { var message = "Can't connect. reasons %{value}" . replace ( '%{value}' , ex ) ; if ( xhr . status == 401 ) { message = "Unauthorized!" ; } show_notification_dialog ( 'error' , message ) ; }
function ( i , n ) { dialog [ node_type ] . unbind ( "dialogbeforeclose" ) ; node . attr ( "id" , "node_" + n . id ) ; node . data ( "jstree" , ( node_type == 'test_case' ) ? LEAF_MENU : FOLDER_MENU ) ; $ . jstree . _reference ( node ) . set_text ( node , tc [ "node[name]" ] ) ; show_notification_dialog ( 'success' , edit_type == 'edit' ? IMPASSE . label . noticeSuccessfulUpdate : IMPASSE . label . noticeSuccessfulCreate ) ; }
function ( _data_c , status ) { winkstart . request ( 'accounts_manager.limits.get' , { account_id : account_id , api_url : winkstart . apps [ 'accounts' ] . api_url , } , function ( _data_l , status ) { var tmp = { account_id : account_id , limits : _data_l . data , credits : _data_c . data } ; THIS . render_credits_limits_popup ( tmp ) ; } ) ; }
function ( success , error ) { var THIS = this ; winkstart . request ( 'myaccount_limits.get' , { account_id : winkstart . apps [ 'myaccount' ] . account_id , api_url : winkstart . apps [ 'myaccount' ] . api_url , } , function ( data , status ) { if ( typeof success == 'function' ) { success ( data , status ) ; } } , function ( data , status ) { if ( typeof error == 'function' ) { error ( data , status ) ; } } ) ; }
function ContentSecurityPolicy ( ) { CSPdebug ( "CSP CREATED" ) ; this . _isInitialized = false ; this . _reportOnlyMode = false ; this . _policy = CSPRep . fromString ( "default-src *" ) ; this . _policy . _allowInlineScripts = true ; this . _policy . _allowEval = true ; this . _request = "" ; this . _docRequest = null ; CSPdebug ( "CSP POLICY INITED TO 'default-src *'" ) ; }
function ( aViolationType , aSourceFile , aScriptSample , aLineNum ) { switch ( aViolationType ) { case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_INLINE_SCRIPT : if ( ! this . _policy . allowsInlineScripts ) this . _asyncReportViolation ( 'self' , 'inline script base restriction' , 'violated base restriction: Inline Scripts will not execute' , aSourceFile , aScriptSample , aLineNum ) ; break ; case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_EVAL : if ( ! this . _policy . allowsEvalInScripts ) this . _asyncReportViolation ( 'self' , 'eval script base restriction' , 'violated base restriction: Code will not be created from strings' , aSourceFile , aScriptSample , aLineNum ) ; break ; } }
function ( response ) { if ( response . error ) { $ ( '#pay-error' ) . show ( ) . find ( 'div' ) . text ( response . error ) ; installError ( product ) ; return ; } if ( response . receipt ) { data [ 'data' ] = { 'receipts' : [ response . receipt ] } ; } $ . when ( apps . install ( product , data ) ) . done ( installSuccess ) . fail ( installError ) ; }
function ( err ) { if ( err !== null ) { console . log ( "QUERY ERROR: " + err ) ; console . log ( new Error ( ) . stack ) ; callback = null ; } if ( callback !== undefined && callback !== null ) { console . log ( "UPDATE callback" ) ; callback ( response ) ; } console . log ( "UPDATE finished" ) ; if ( callback !== null ) response . end ( ) ; }
function ( entity , tgt_type ) { return _ ( tgt_type ) . difference ( _ ( entity . attributes ) . keys ( ) ) . length == 0 ; }
function ( v ) { if ( v === undefined ) { return ; } if ( v . length === 0 ) { return [ ] ; } if ( v . length == 1 ) { return _convert_helper ( v [ 0 ] ) ; } return v . map ( _convert_helper ) ; }
function stealFocus ( off ) { if ( off ) { $ ( '#prompt' ) . off ( 'blur' ) ; } else { $ ( '#prompt' ) . off ( 'blur' ) . on ( 'blur' , function ( ) { $ ( '#prompt' ) . focus ( ) ; } ) ; $ ( '#prompt' ) . focus ( ) ; } }
function ( file ) { var ext = file . substring ( file . length - 3 ) ; if ( ext == '.js' ) { var f = path . join ( resourcesDir , file ) ; var found = requires . findAllRequires ( f , alloyFilter ) ; _ . extend ( alloyLibs , found ) ; } }
function ( ) { var Else = goog . util . Else ; var something = goog . something ; something . Something = function ( ) { this . myElse = new Else ( ) ; } ; something . Something . prototype . noOp = function ( ) { } ; }
function ( ) { $ ( '#status' ) . html ( "<img src='" + pluginurl + "img/290.gif'/><p>Adding...</p>" ) jQuery . post ( ajaxurl , { action : 'insert_posts' , publish : 'add' } , function ( response ) { if ( response . charAt ( response . length - 1 ) == "0" ) { response = response . substring ( 0 , response . length - 1 ) ; } response = jQuery . parseJSON ( response ) ; $ ( '#status' ) . html ( "Added " + response . added + " ads." ) ; } ) ; }
function ( inputPath , value , expander ) { var togo ; if ( inputPath !== undefined ) { togo = fluid . get ( expander . source , fluid . model . composePaths ( expander . inputPrefix , inputPath ) , expander . resolverGetConfig ) ; } if ( togo === undefined ) { togo = fluid . isPrimitive ( value ) ? value : expander . expand ( value ) ; } return togo ; }
function ( expandSpec , expander ) { var togo = fluid . copy ( expandSpec ) ; togo . inputPath = fluid . model . composePaths ( expander . outputPrefix , expandSpec . outputPath ) ; togo . outputPath = fluid . model . composePaths ( expander . inputPrefix , expander . inputPath ) ; return togo ; }
function ( expected , actual ) { if ( fluid . isPrimitive ( expected ) ) { return expected === actual ? 1 : 0 ; } else { var stats = { matchCount : 0 , mismatchCount : 0 , messages : [ ] } ; stats . pathOps = fluid . model . makePathStack ( expander , "path" ) ; fluid . deepEquals ( expected , actual , stats ) ; return stats . matchCount ; } }
function ( expander , expandFn ) { expander . expand = function ( rules ) { return expandFn ( rules , expander ) ; } ; }
function ( rules ) { var expander = { inverted : [ ] , inverting : true } ; fluid . model . transform . makeExpander ( expander , fluid . model . transform . expandValue ) ; expander . expand ( rules ) ; return { expander : expander . inverted } ; }
function ( root , segment , path ) { for ( var i = 0 ; i < keys . length ; ++ i ) { var key = keys [ i ] ; if ( fluid . pathUtil . matchPath ( key , path , true ) !== null ) { return flatSchema [ key ] ; } } }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function ( error , result ) { for ( var i = 6 - 1 ; i >= 0 ; i -- ) { var magento_result = result [ i ] ; if ( magento_result . vwheritage_sync = 1 ) { json_product ( magento_result . sku , i , function ( sku , i , data ) { if ( typeof data !== "undefined" && data . ROWCOUNT > 0 ) { } else { console . log ( sku ) ; } } ) ; } } }
function ( data ) { data = $ ( data ) if ( data . find ( '.errorlist' ) . length ) { $ ( '#profile_form' ) . replaceWith ( data ) createUploader ( ) ; } else { document . location . href = $ ( '#profile_form' ) . attr ( 'success_url' ) } }
function getImage ( catName , makeOtherList ) { var imageLi = document . createElement ( "li" ) ; makeOtherList . appendChild ( imageLi ) ; var newImage = document . createElement ( "img" ) ; var setSource = newImage . setAttribute ( "src" , "Images/" + catName + ".png" ) ; imageLi . appendChild ( newImage ) ; }
function ( err ) { if ( this . error ) { return ; } this . error = err ; this . pause ( ) ; this . emit ( 'error' , err ) ; }
function ( err , collection ) { self . startListening ( collection ) ; }
function ( err , data ) { if ( err || ( ! data ) ) self . getCursor ( forMsg , passive , callback ) ; else doCallback ( err , data ) ; }
function ( desktop , skipper , after ) { this . $supers ( Grid , 'bind_' , arguments ) ; var w = this ; after . push ( function ( ) { _fixForEmpty ( w ) ; } ) ; zul . mesh . Scrollbar . init ( w , w . ebodytbl ) ; }
function ( model , options ) { if ( ! ( model instanceof Backbone . Model ) ) { var attrs = model ; model = new this . model ( attrs , { collection : this } ) ; if ( model . validate && ! model . _performValidation ( attrs , options ) ) model = false ; } else if ( ! model . collection ) { model . collection = this ; } return model ; }
function ( evt ) { if ( evt == 2 ) { t . assertEqual ( 4 , testApp . controllers . length ) ; t . assertEqual ( 4 , testApp . controllers [ 0 ] instanceof Load ) ; t . assertEqual ( 4 , testApp . controllers [ 1 ] instanceof Transition ) ; t . assertEqual ( 4 , testApp . controllers [ 2 ] instanceof Layout ) ; t . assertEqual ( 4 , testApp . controllers [ 3 ] instanceof History ) ; dohDeferred . callback ( true ) ; } }
function ( self , name , attrs ) { console . log ( 'func' , self , name , attrs ) ; attrs = XPath . attrs ( attrs ) ; if ( name in XPath . funcs ) { return XPath . funcs [ name ] ( attrs ) ; } else { return 'name(' + attrs . join ( ', ' ) + ')' ; } }
function drawPieChart ( title , filters , categories , containerId ) { var wrapper = new google . visualization . ChartWrapper ( { chartType : 'PieChart' , dataTable : getPieGraphData ( filters , categories ) , options : { width : 450 , height : 400 , backgroundColor : 'transparent' } , containerId : containerId } ) ; wrapper . draw ( ) ; return ; }
function drawColumnChart ( title , filters , categories , containerId ) { var wrapper = new google . visualization . ChartWrapper ( { chartType : 'ColumnChart' , dataTable : getColumnGraphData ( filters , categories ) , options : { width : 450 , height : 500 , backgroundColor : 'transparent' } , containerId : containerId } ) ; wrapper . draw ( ) ; return ; }
function closeDialogGeneric ( e ) { $ . single ( this ) . parent ( ) . find ( '.dropBoxImage' ) . appendTo ( $ ( '#Main‿div‿imageContainer' ) ) . addClass ( 'localImage' ) . removeClass ( 'dropBoxImage' ) ; INNERCONTEXT . UTILITY . removeWrappedElement ( e ) ; }
function handleDrag_dragenter ( e , handleDrag ) { this . inChild = ! $ ( e . target ) . hasClass ( 'newCAAimage' ) ; $ ( 'figure' ) . removeClass ( 'over' ) ; $ . single ( this ) . addClass ( 'over' ) ; }
function handleDrag_dragstart ( e ) { var handleDrag = INNERCONTEXT . EVENTS . handleDrag , edT = e . dataTransfer ; handleDrag . $draggedImage = $ ( this ) . addClass ( 'beingDragged' ) ; edT . dropEffect = 'move' ; edT . effectAllowed = 'move' ; }
function ( file , callback1 ) { var format , fullpath , pipe , source ; fullpath = path . join ( dirPath , file ) ; format = getFileFormat ( fullpath ) ; source = createReadStream ( fullpath , format ) ; pipe = pipeFactory . build ( [ 'READ_' + format , 'CHECK' , 'SUBMIT' ] , options ) ; pipe . on ( 'end' , callback1 ) ; return pipe . pump ( source ) ; }
function ( attrs ) { seriesCur = { } ; return seriesCur . components = _ . extend ( { } , attrs ) ; }
function ( event , rangeObject ) { var foundMarkup ; foundMarkup = that . findLangMarkup ( rangeObject ) ; if ( foundMarkup ) { addMarkupToSelectionButton . setPressed ( true ) ; FloatingMenu . setScope ( 'wai-lang' ) ; langField . setTargetObject ( foundMarkup , 'lang' ) ; } else { langField . setTargetObject ( null ) ; } }
function ( ) { var range = Aloha . Selection . getRangeObject ( ) , foundMarkup = this . findLangMarkup ( range ) ; if ( foundMarkup ) { GENTICS . Utils . Dom . removeFromDOM ( foundMarkup , range , true ) ; range . select ( ) ; FloatingMenu . setScope ( 'Aloha.continousText' ) ; langField . setTargetObject ( null ) ; FloatingMenu . doLayout ( ) ; } }
function ( ) { var $li = jQuery ( this ) ; $li . contents ( ) . each ( function ( ) { if ( this . nodeType === 3 ) { this . data = jQuery . trim ( this . data ) ; } } ) ; }
function ( ) { var search = this . grid . find ( 'input.aloha-browser-search-field' ) , searchValue = search . val ( ) ; if ( jQuery ( search ) . css ( "font-style" ) == "italic" ) { searchValue = "" ; } this . _pagingOffset = 0 ; this . _searchQuery = search . val ( ) ; this . fetchItems ( this . _currentFolder , this . processItems ) ; }
function ( ) { $ ( "#old_password" ) . val ( "" ) ; $ ( "#new_password" ) . val ( "newpassword" ) ; bid . manageAccount . changePassword ( function ( status ) { equal ( status , false , "on missing old password, status is false" ) ; testHelpers . testTooltipVisible ( ) ; start ( ) ; } ) ; }
function ( ) { $ ( "#old_password" ) . val ( "oldpassword" ) ; $ ( "#new_password" ) . val ( "" ) ; bid . manageAccount . changePassword ( function ( status ) { equal ( status , false , "on missing new password, status is false" ) ; testHelpers . testTooltipVisible ( ) ; start ( ) ; } ) ; }
function ( status ) { equal ( status , true , "on proper completion, status is true" ) ; equal ( tooltip . shown , false , "on proper completion, tooltip is not shown" ) ; equal ( $ ( "#old_password" ) . val ( ) , "" , "old_password field is cleared" ) ; equal ( $ ( "#new_password" ) . val ( ) , "" , "new_password field is cleared" ) ; start ( ) ; }
function ( ) { $ ( "#old_password" ) . val ( "oldpassword" ) ; $ ( "#new_password" ) . val ( "newpassword" ) ; xhr . useResult ( "incorrectPassword" ) ; bid . manageAccount . changePassword ( function ( status ) { equal ( status , false , "bad password, status is false" ) ; testHelpers . testTooltipVisible ( ) ; start ( ) ; } ) ; }
function ( ) { app . set ( 'views' , __dirname + '/views' ) ; app . set ( 'view engine' , 'jade' ) ; app . use ( express . bodyParser ( ) ) ; app . use ( express . methodOverride ( ) ) ; app . use ( app . router ) ; app . use ( gzippo . staticGzip ( __dirname + '/public' ) ) ; app . enable ( 'view cache' ) ; }
function ( options ) { var args = [ ] . slice . call ( arguments , 0 ) [ 0 ] ; _ . each ( options , this . _allowProperties , this ) ; _ . each ( args , function ( value , key ) { if ( _ . include ( this . _ignoredAttributes , key ) ) delete args [ key ] ; } , this ) ; return Backbone . Model . call ( this , args ) ; }
function ( ) { mStub = sinon . stub ( ComponentModel ) ; m = new Backbone . Model ( { id : 1 , fullName : 'ST_0100' } ) ; mStub . returns ( m ) ; c = new ComponentCollection ( ) ; c . model = ComponentModel ; c . add ( { id : 1 , fullName : 'ST_0100' } ) ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayStats ( this . config . showFPS ) ; director . setAnimationInterval ( 1.0 / this . config . frameRate ) ; director . runWithScene ( new this . startScene ( ) ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayStats ( this . config . showFPS ) ; director . setAnimationInterval ( 1.0 / this . config . frameRate ) ; director . runWithScene ( new this . startScene ( ) ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayStats ( this . config . showFPS ) ; director . setAnimationInterval ( 1.0 / this . config . frameRate ) ; director . runWithScene ( new this . startScene ( ) ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayStats ( this . config . showFPS ) ; director . setAnimationInterval ( 1.0 / this . config . frameRate ) ; director . runWithScene ( new this . startScene ( ) ) ; return true ; }
function replyToJSON ( reply ) { var replydoc = xml . parseXmlString ( reply . toString ( ) ) ; var entries = replydoc . find ( '//p:affiliation' , { p : pubsub . ns } ) ; var subscriptions = { } ; entries . forEach ( function ( entry ) { var jid = entry . attr ( 'jid' ) . value ( ) ; var affiliation = entry . attr ( 'affiliation' ) . value ( ) ; subscriptions [ jid ] = affiliation ; } ) ; return subscriptions ; }
function ( test ) { test . expect ( 7 ) ; moment . lang ( 'it' ) ; var expected = 'Domenica Dom D_Lunedi Lun L_Martedi Mar Ma_Mercoledi Mer Me_Giovedi Gio G_Venerdi Ven V_Sabato Sab S' . split ( "_" ) ; var i ; for ( i = 0 ; i < expected . length ; i ++ ) { test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( 'dddd ddd dd' ) , expected [ i ] , expected [ i ] ) ; } test . done ( ) ; }
function FtpConnection ( properties ) { events . EventEmitter . call ( this ) ; for ( k in properties ) { this [ k ] = properties [ k ] ; } }
function switchToSecure ( ) { logIf ( 1 , "Secure connection started" ) ; self . socket = cleartext ; socket . addListener ( 'data' , dataListener ) ; self . secure = true ; }
function ( err ) { if ( err ) { logIf ( 0 , "Error deleting file: " + filename + ", " + err , self ) ; wwenc ( self . socket , "550 Permission denied\r\n" ) ; } else { wwenc ( self . socket , "250 File deleted\r\n" ) ; } }
function ( err ) { if ( err ) { logIf ( 0 , "Error making directory " + filename + " because " + err , self ) ; wwenc ( self . socket , "550 \"" + filename + "\" directory NOT created\r\n" ) ; return ; } wwenc ( self . socket , "257 \"" + filename + "\" directory created\r\n" ) ; }
function ( err , files ) { if ( err ) { logIf ( 0 , "During NLST, error globbing files: " + err , self ) ; wwenc ( self . socket , "451 Read error\r\n" ) ; pasvconn . end ( ) ; return ; } logIf ( 3 , "Directory has " + files . length + " files" , self ) ; wwenc ( pasvconn , files . map ( PathModule . basename ) . join ( "\015\012" ) + "\015\012" , success ) ; }
function ( commandArg ) { if ( ! self . options . tlsOptions ) return wwenc ( socket , "202 Not supported\r\n" ) ; if ( ! self . secure ) { wwenc ( self . socket , "503 Secure connection not established\r\n" ) ; } else if ( parseInt ( commandArg ) != 0 ) { self . pbszReceived = true ; wwenc ( self . socket , "200 buffer too big, PBSZ=0\r\n" ) ; } else { self . pbszReceived = true ; wwenc ( self . socket , "200 OK\r\n" ) ; } }
function ( err ) { if ( err ) { logIf ( 0 , "Error removing directory " + filename , self . socket ) ; wwenc ( self . socket , "550 Delete operation failed\r\n" ) ; } else wwenc ( self . socket , "250 \"" + filename + "\" directory removed\r\n" ) ; }
function ( commandArg ) { var self = this ; if ( ! self . _authenticated ( ) ) return ; self . filefrom = withCwd ( self . cwd , commandArg ) ; logIf ( 3 , "Rename from " + self . filefrom , self . socket ) ; self . fs . exists ( self . filefrom , function ( exists ) { if ( exists ) wwenc ( self . socket , "350 File exists, ready for destination name\r\n" ) ; else wwenc ( self . socket , "350 Command failed, file does not exist\r\n" ) ; } ) ; }
function ( err ) { if ( err ) { logIf ( 3 , "Error renaming file from " + self . filefrom + " to " + fileto , self . socket ) ; wwenc ( self . socket , "550 Rename failed\r\n" ) ; } else { wwenc ( self . socket , "250 File renamed successfully\r\n" ) ; } }
function ( err , s ) { if ( err ) { traceIf ( 0 , "Error getting size of file: " + filename , self . socket ) ; wwenc ( self . socket , "450 Failed to get size of file\r\n" ) ; return ; } wwenc ( self . socket , "213 " + s . size + "\r\n" ) ; }
function ( msg , type , pid , ref , pos , off , dur ) { var notif = ( zul && zul . wgt ) ? zul . wgt . Notification : null ; if ( notif ) notif . show ( msg , pid , { ref : ref , pos : pos , off : off , dur : dur , type : type } ) ; else { jq . alert ( msg ) ; } }
function ( test ) { var newMediaFile = { user_uid : "A7S7F8GA7SD98A7SDF8ASD7G" , title : "How to make buble tea" , path : "http://www.youtube.com/bt" , type : 1 } MediaFile . createMediaFile ( newMediaFile , function ( error , mediaFile ) { tuid = mediaFile . target_uuid ; console . log ( "t_uid = " + tuid ) ; test . ok ( mediaFile . should . have . property ( 'target_uuid' ) ) ; test . done ( ) ; } ) }
function ( test ) { var target = { 'target_uuid' : 'abc1230' } ; var updateAttributes = { 'title' : 'jericho twist' , 'path' : 'www.google.com' } ; MediaFile . updateMediaFile ( target , updateAttributes , function ( error , updatedMediaFile ) { console . log ( "expect = " + updateAttributes . title ) ; console . log ( "result = " + updatedMediaFile . title ) ; test . ok ( updatedMediaFile . title . should . be . eql ( updateAttributes . title ) ) ; test . done ( ) ; } ) }
function ( test ) { var newTag = { user_uid : "BSDF787D98A7SDF8ASD7G1" , start : 12 , end : 34 , type : 2 , target_uuid : "abc1234" , title : "super magic dribble" , description : "bend it like beckham" , question_uid : "aJfznhseQuOicWWAjx7F00" , important : true , interest : false , examable : true , reviewlater : true , shared : false } Tag . createTag ( newTag , function ( error , tag ) { test . ok ( tag . should . have . property ( 'description' ) ) ; test . done ( ) ; } ) }
function ( test ) { var target = { "user_uid" : "A7S7F8GA7SD98A7SDF8ASD7G" } ; var updateAttributes = { 'title' : 'jericho twist' , 'shared' : true } ; Tag . updateTag ( target , updateAttributes , function ( error , updatedTag ) { console . log ( "expect = " + updateAttributes . shared ) ; console . log ( "result = " + updatedTag . shared ) ; test . ok ( updatedTag . shared . should . be . eql ( updateAttributes . shared ) ) ; test . done ( ) ; } ) }
function ( target_uuid , args , callback ) { MediaFile . updateMediaFile ( target_uuid , args , function ( error , updatedMediaFile ) { if ( ! error ) { callback ( null , updatedMediaFile ) ; } else { callback ( error , null ) ; } } ) }
function ( args , callback ) { queryES . getQuestion ( args . question_uid , 0 , function ( result ) { if ( result ) { callback ( null , result ) ; } else { var error = "No result." callback ( error , null ) ; } } ) ; }
function ( user_uid , args , callback ) { Tag . updateTag ( user_uid , args , function ( error , updatedTag ) { if ( ! error ) { callback ( null , updatedTag ) ; } else { callback ( error , null ) ; } } ) }
function ( media , callback ) { media . target_uuid = UUID . generate ( ) ; var newMediaFile = MediaFile . build ( media ) ; newMediaFile . save ( ) . error ( function ( error ) { callback ( error , null ) ; } ) . success ( function ( ) { callback ( null , newMediaFile ) ; } ) }
function ( target_uuid , args , callback ) { MediaFile . find ( { where : target_uuid } ) . success ( function ( mediaFile ) { mediaFile . updateAttributes ( args ) . success ( function ( updatedMedia ) { console . log ( "updated succesfully" ) ; callback ( null , updatedMedia ) ; } ) ; } ) . error ( function ( error ) { callback ( error , null ) ; console . log ( "Couldn't find mediaFile " + error ) ; } ) ; }
function ( tag , callback ) { var newTag = Tag . build ( tag ) ; newTag . save ( ) . error ( function ( error ) { callback ( error , null ) ; } ) . success ( function ( ) { callback ( null , newTag ) ; } ) }
function ( tag ) { var QuestionTag = require ( './user.js' ) . User ; QuestionTag . find ( { where : { uuid : tag . user_uid } } ) . success ( function ( questionTag ) { callback ( null , questionTag ) ; } ) . error ( function ( error ) { callback ( error , null ) ; } ) ; }
function ( user_uid , args , callback ) { Tag . find ( { where : user_uid } ) . success ( function ( tag ) { tag . updateAttributes ( args ) . success ( function ( updatedTag ) { callback ( null , updatedTag ) ; } ) ; } ) . error ( function ( error ) { callback ( error , null ) ; console . log ( "Couldn't find tag " + error ) ; } ) ; }
function ( event ) { if ( oDynamicTable . oColumnHandleData != null ) { var iXChange = event . pageX - oDynamicTable . oColumnHandleData . iLastXCoordinate ; var oElement = oDynamicTable . oColumnHandleData . oElement ; jQuery ( oElement ) . width ( jQuery ( oElement ) . width ( ) + iXChange ) ; oDynamicTable . oColumnHandleData . iLastXCoordinate = event . pageX ; } }
function ( event ) { var sCursorStyle = 'default' ; if ( oDynamicTable . oTableResizeHandleData ) { return ; } sBoundaryLocation = MouseLocationDetector . getCoveredBoundaries ( event , this ) ; if ( sBoundaryLocation != null && ( sBoundaryLocation == 's' || sBoundaryLocation == 'se' || sBoundaryLocation == 'e' ) ) { sCursorStyle = sBoundaryLocation + '-resize' ; } jQuery ( 'body' ) . css ( 'cursor' , sCursorStyle ) ; }
function ( event ) { sBoundaries = MouseLocationDetector . getCoveredBoundaries ( event , this ) ; if ( sBoundaries != null ) { event . preventDefault ( ) ; oDynamicTable . oTableResizeHandleData = { sBoundaries : sBoundaries , iLastCoordinate : { x : event . pageX , y : event . pageY } } ; } }
function ( event ) { var sCursorStyle = 'default' ; if ( oDynamicTable . oTableDragHandleData ) { return ; } sBoundaryLocation = MouseLocationDetector . getCoveredBoundaries ( event , this ) ; if ( sBoundaryLocation != null && sBoundaryLocation . indexOf ( 'n' ) != - 1 ) { sCursorStyle = 'move' ; } jQuery ( 'body' ) . css ( 'cursor' , sCursorStyle ) ; }
function ( event ) { sBoundaries = MouseLocationDetector . getCoveredBoundaries ( event , this ) ; if ( sBoundaries != null && sBoundaries == 'n' ) { event . preventDefault ( ) ; oDynamicTable . oTableDragHandleData = { iLastCoordinate : { x : event . pageX , y : event . pageY } } ; } }
function ( event ) { if ( oDynamicTable . oTableDragHandleData != null ) { var iXChange = event . pageX - oDynamicTable . oTableDragHandleData . iLastCoordinate . x ; var iYChange = event . pageY - oDynamicTable . oTableDragHandleData . iLastCoordinate . y ; if ( iXChange != 0 ) { } if ( iYChange != 0 ) { } oDynamicTable . oTableDragHandleData . iLastCoordinate . x = event . pageX ; oDynamicTable . oTableDragHandleData . iLastCoordinate . y = event . pageY ; } }
function ( event ) { if ( MouseLocationDetector . onRightBoundary ( event , this ) ) { event . preventDefault ( ) ; oDynamicTable . oColumnHandleData = { oElement : this , iLastXCoordinate : event . pageX } ; } }
function ( ) { var self = this ; this . _columnType = { } ; _ ( this . get ( 'schema' ) ) . each ( function ( s ) { self . _columnType [ s [ 0 ] ] = s [ 1 ] ; } ) ; }
function ( columnName ) { var self = this ; var c = this . _getColumn ( columnName ) ; c . destroy ( { success : function ( ) { self . fetch ( ) ; } , wait : true } ) ; }
function ( columnName , newType ) { var self = this ; var c = this . _getColumn ( columnName ) ; c . set ( { type : newType } ) ; c . save ( null , { success : function ( ) { self . fetch ( ) ; } , wait : true } ) ; }
function ( e ) { if ( e . keyCode === 13 ) { this . table . renameColumn ( this . column [ 0 ] , $ ( '.col_name_edit' ) . val ( ) ) ; } }
function ( path , suffix , vars ) { var bemhtmlFile = vars . Prefix + '.bemhtml.js' , bemjsonFile = vars . Prefix + '.bemjson.js' ; VM . runInThisContext ( FS . readFileSync ( bemhtmlFile , 'utf-8' ) ) ; return BEMHTML . apply ( VM . runInThisContext ( FS . readFileSync ( bemjsonFile , 'utf-8' ) ) ) ; }
function ( ) { $ ( '#tab' ) . jqGrid ( 'setGridHeight' , $ ( window ) . height ( ) / 2 - 30 ) ; $ ( '#map' ) . height ( $ ( window ) . height ( ) - $ ( '#table' ) . height ( ) - 3 ) ; hell . map . invalidateSize ( ) ; $ ( '#tab' ) . jqGrid ( 'setGridWidth' , $ ( window ) . width ( ) ) ; }
function ( rowid ) { var marker = hell . map . allmarkers [ $ ( '#tab' ) . jqGrid ( 'getRowData' , rowid ) . id ] ; if ( ! marker ) { hell . map . closePopup ( ) ; return true ; } hell . map . panTo ( marker . getLatLng ( ) ) ; marker . openPopup ( ) ; return true ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Inspector.evaluateForTestInFrontend' , [ 'testCallId' , 'script' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Inspector.inspect' , [ 'object' , 'hints' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Inspector.didCreateWorker' , [ 'id' , 'url' , 'isShared' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Inspector.didDestroyWorker' , [ 'id' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Inspector' , this ) ; }
function ( frameId , url , query , caseSensitive , isRegex , opt_callback ) { var paramObject = { 'frameId' : frameId , 'url' : url , 'query' : query , 'caseSensitive' : caseSensitive , 'isRegex' : isRegex , } ; chrome . devtools . remoteDebug . sendCommand ( 'Page.searchInResource' , paramObject , opt_callback ) ; }
function ( width , height , fontScaleFactor , fitWindow , opt_callback ) { var paramObject = { 'width' : width , 'height' : height , 'fontScaleFactor' : fontScaleFactor , 'fitWindow' : fitWindow , } ; chrome . devtools . remoteDebug . sendCommand ( 'Page.setDeviceMetricsOverride' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Page.domContentEventFired' , [ 'timestamp' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Page.loadEventFired' , [ 'timestamp' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Page.frameNavigated' , [ 'frame' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Page.frameDetached' , [ 'frameId' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Page' , this ) ; }
function ( expression , objectGroup , includeCommandLineAPI , doNotPauseOnExceptionsAndMuteConsole , contextId , returnByValue , opt_callback ) { var paramObject = { 'expression' : expression , 'objectGroup' : objectGroup , 'includeCommandLineAPI' : includeCommandLineAPI , 'doNotPauseOnExceptionsAndMuteConsole' : doNotPauseOnExceptionsAndMuteConsole , 'contextId' : contextId , 'returnByValue' : returnByValue , } ; chrome . devtools . remoteDebug . sendCommand ( 'Runtime.evaluate' , paramObject , opt_callback ) ; }
function ( objectId , functionDeclaration , arguments , doNotPauseOnExceptionsAndMuteConsole , returnByValue , opt_callback ) { var paramObject = { 'objectId' : objectId , 'functionDeclaration' : functionDeclaration , 'arguments' : arguments , 'doNotPauseOnExceptionsAndMuteConsole' : doNotPauseOnExceptionsAndMuteConsole , 'returnByValue' : returnByValue , } ; chrome . devtools . remoteDebug . sendCommand ( 'Runtime.callFunctionOn' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Console.messageAdded' , [ 'message' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Console.messageRepeatCountUpdated' , [ 'count' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Console.messagesCleared' , [ '' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Console' , this ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Database.addDatabase' , [ 'database' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Database.sqlTransactionSucceeded' , [ 'transactionId' , 'columnNames' , 'values' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Database.sqlTransactionFailed' , [ 'transactionId' , 'sqlError' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Database' , this ) ; }
function ( requestId , frameId , databaseName , objectStoreName , indexName , skipCount , pageSize , keyRange , opt_callback ) { var paramObject = { 'requestId' : requestId , 'frameId' : frameId , 'databaseName' : databaseName , 'objectStoreName' : objectStoreName , 'indexName' : indexName , 'skipCount' : skipCount , 'pageSize' : pageSize , 'keyRange' : keyRange , } ; chrome . devtools . remoteDebug . sendCommand ( 'IndexedDB.requestData' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'DOMStorage.addDOMStorage' , [ 'storage' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'DOMStorage.domStorageUpdated' , [ 'storageId' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'DOMStorage' , this ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'ApplicationCache.applicationCacheStatusUpdated' , [ 'frameId' , 'manifestURL' , 'status' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'ApplicationCache.networkStateUpdated' , [ 'isNowOnline' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'ApplicationCache' , this ) ; }
function ( x , y , width , height , color , outlineColor , opt_callback ) { var paramObject = { 'x' : x , 'y' : y , 'width' : width , 'height' : height , 'color' : color , 'outlineColor' : outlineColor , } ; chrome . devtools . remoteDebug . sendCommand ( 'DOM.highlightRect' , paramObject , opt_callback ) ; }
function ( nodeId , forcedPseudoClasses , includePseudo , includeInherited , opt_callback ) { var paramObject = { 'nodeId' : nodeId , 'forcedPseudoClasses' : forcedPseudoClasses , 'includePseudo' : includePseudo , 'includeInherited' : includeInherited , } ; chrome . devtools . remoteDebug . sendCommand ( 'CSS.getMatchedStylesForNode' , paramObject , opt_callback ) ; }
function ( styleId , propertyIndex , text , overwrite , opt_callback ) { var paramObject = { 'styleId' : styleId , 'propertyIndex' : propertyIndex , 'text' : text , 'overwrite' : overwrite , } ; chrome . devtools . remoteDebug . sendCommand ( 'CSS.setPropertyText' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'CSS.mediaQueryResultChanged' , [ '' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'CSS.styleSheetChanged' , [ 'styleSheetId' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'CSS' , this ) ; }
function ( lineNumber , url , urlRegex , columnNumber , condition , opt_callback ) { var paramObject = { 'lineNumber' : lineNumber , 'url' : url , 'urlRegex' : urlRegex , 'columnNumber' : columnNumber , 'condition' : condition , } ; chrome . devtools . remoteDebug . sendCommand ( 'Debugger.setBreakpointByUrl' , paramObject , opt_callback ) ; }
function ( scriptId , query , caseSensitive , isRegex , opt_callback ) { var paramObject = { 'scriptId' : scriptId , 'query' : query , 'caseSensitive' : caseSensitive , 'isRegex' : isRegex , } ; chrome . devtools . remoteDebug . sendCommand ( 'Debugger.searchInContent' , paramObject , opt_callback ) ; }
function ( callFrameId , expression , objectGroup , includeCommandLineAPI , doNotPauseOnExceptionsAndMuteConsole , returnByValue , opt_callback ) { var paramObject = { 'callFrameId' : callFrameId , 'expression' : expression , 'objectGroup' : objectGroup , 'includeCommandLineAPI' : includeCommandLineAPI , 'doNotPauseOnExceptionsAndMuteConsole' : doNotPauseOnExceptionsAndMuteConsole , 'returnByValue' : returnByValue , } ; chrome . devtools . remoteDebug . sendCommand ( 'Debugger.evaluateOnCallFrame' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Worker.workerCreated' , [ 'workerId' , 'url' , 'inspectorConnected' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Worker.workerTerminated' , [ 'workerId' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Worker.dispatchMessageFromWorker' , [ 'workerId' , 'message' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Worker.disconnectedFromWorker' , [ '' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Worker' , this ) ; }
function ( is_start , node ) { if ( ! is_start ) { for ( var n = node . firstChild ; n ; n = n . nextSibling ) { Meteor . ui . _LiveRange . _clean_node ( this . tag , n , true ) ; } } }
function ( evt ) { if ( ! isPendingAccessoryButtonTap ) return ; isPendingAccessoryButtonTap = false ; var tableViewCell = $ ( this ) . parent ( ) [ 0 ] . tableViewCell ; if ( ! tableViewCell ) return ; $element . trigger ( $ . Event ( Pushpop . TableView . EventType . AccessoryButtonTappedForRowWithIndex , { tableView : self , tableViewCell : tableViewCell , index : tableViewCell . getIndex ( ) } ) ) ; }
function ( evt ) { if ( ! isPendingEditingAccessoryButtonTap ) return ; isPendingEditingAccessoryButtonTap = false ; var tableViewCell = $ ( this ) . parent ( ) [ 0 ] . tableViewCell ; if ( ! tableViewCell ) return ; $element . trigger ( $ . Event ( Pushpop . TableView . EventType . EditingAccessoryButtonTappedForRowWithIndex , { tableView : self , tableViewCell : tableViewCell , index : tableViewCell . getIndex ( ) } ) ) ; }
function ( tableView , index ) { var item = this . getFilteredItemAtIndex ( index ) ; var reuseIdentifier = item . reuseIdentifier || this . getDefaultReuseIdentifier ( ) ; var cell = tableView . dequeueReusableCellWithIdentifier ( reuseIdentifier ) ; cell . setIndex ( index ) ; cell . setAccessoryType ( item . accessoryType ) ; cell . setEditingAccessoryType ( item . editingAccessoryType ) ; cell . setData ( item ) ; return cell ; }
function ( feedId , callback ) { console . log ( "Removing subscriptions..." + url ) ; this . db . transaction ( function ( tx ) { tx . executeSql ( "DELETE FROM subscriptions WHERE id = ?" , [ feedId ] , function ( tx , r ) { console . log ( "Successfully removed : " + feedId ) ; callback ( ) ; } , function ( tx , e ) { console . log ( "Error deleting subscriptions : " + e ) ; } ) ; } ) ; }
function ( ) { console . log ( "Dumping table..." ) ; this . db . transaction ( function ( tx ) { tx . executeSql ( 'DROP TABLE subscriptions' , [ ] , function ( ) { console . log ( "Subscriptions Table destroyed successfully" ) ; } ) ; tx . executeSql ( 'DROP TABLE tags' , [ ] , function ( ) { console . log ( "Tags Table destroyed successfully" ) ; } ) ; } ) ; }
function ( id ) { if ( id == "logoutbtn" ) { GoogleReader . logout ( ) ; pokki . resetContextMenu ( ) ; } else if ( id == "markallasread" ) { BackgroundWorker . markAllAsRead ( ) ; } }
function ( payload ) { var x = OffsetEvent ( payload . event ) . offsetX ; var y = OffsetEvent ( payload . event ) . offsetY ; var svg = view . draw . rect ( x - wheelDef . width / 2 , y - wheelDef . height / 2 , wheelDef . width , wheelDef . height , wheelDef . radius ) ; svg . attr ( view . shapeAttributes ) ; var wheel = Wheel2D ( svg , { app : options . app } ) ; }
function ( payload ) { var event = payload . event ; var x = OffsetEvent ( event ) . offsetX ; var y = OffsetEvent ( event ) . offsetY ; if ( this . shape ) { var path = this . shape . attrs . path ; var last = path [ path . length - 1 ] ; last [ 1 ] = x ; last [ 2 ] = y ; this . shape . attr ( 'path' , path ) ; } }
function pull ( fn ) { var operation = retry . operation ( { retries : this . retries , factor : 3 , minTimeout : 1 * 1000 , maxTimeout : 60 * 1000 , randomize : true } ) , self = this ; function allocate ( err ) { if ( operation . retry ( err ) ) return ; fn . apply ( fn , arguments ) ; } operation . attempt ( function attempt ( ) { self . allocate ( allocate ) ; } ) ; }
function ( ) { var m = new DatumField ( { "state" : this . $el . find ( ".add_input" ) . val ( ) , "color" : this . $el . find ( ".add_color_chooser" ) . val ( ) } ) ; this . model . get ( "datumStates" ) . add ( m ) ; this . datumStatesView . add ( m ) ; }
function ( e ) { if ( this . scrollingEnabled ) { self . _animateToPosition ( startTranslationX , startTranslationY , 400 + 0.3 * calculateDistance ( startTranslationX , startTranslationY , self . _currentTranslationX , self . _currentTranslationY ) , "ease-in-out" , function ( ) { self . _handleDragCancel && self . _handleDragCancel ( e ) ; } ) ; self . _endScrollBars ( ) ; self . _handleDragCancel && self . _handleDragCancel ( e ) ; } }
function ( ) { var failureStacktraces , jasmineFailures , verboseSpecs ; jasmineFailures = this . message . match ( /(.+\n.\[3[12]m[\s\S]*)Failures:\s([\s\S]*)\n+Finished/m ) ; if ( jasmineFailures != null ) { this . resetTestStatus ( ) ; verboseSpecs = jasmineFailures [ 1 ] ; failureStacktraces = jasmineFailures [ 2 ] ; return this . handleFailures ( failureStacktraces , verboseSpecs ) ; } else { return this . allSpecsPass ( ) ; } }
function ( failureStacktraces , verboseSpecs ) { var failedTests , failures , _this = this ; failedTests = [ ] ; failures = failureStacktraces . split ( "\n\n" ) ; failures . each ( function ( failure ) { var error ; error = _this . parseFailure ( failure ) ; _this . specFails ( error ) ; return failedTests . push ( error . fileName ) ; } ) ; return this . testsPassedExcept ( failedTests ) ; }
function ( key , auth , data ) { this . key = key ; this . auth = auth ; this . title = data . title [ "#" ] ; this . updated = data . updated ; this . author = data . author ; this . worksheets = [ ] ; var worksheets = forceArray ( data . entry ) ; worksheets . forEach ( function ( worksheetData ) { this . worksheets . push ( new Worksheet ( this , worksheetData ) ) ; } , this ) ; }
function ( opts , cb ) { opts = opts || { } ; Spreadsheets . rows ( { key : this . spreadsheet . key , auth : this . spreadsheet . auth , worksheet : this . id , start : opts . start , num : opts . num } , cb ) ; }
function ( opts , cb ) { opts = opts || { } ; Spreadsheets . cells ( { key : this . spreadsheet . key , auth : this . spreadsheet . auth , worksheet : this . id , range : opts . range } , cb ) ; }
function ( event , first ) { if ( this . inputActive ) { var target = event . target ; var x = event . touches . item ( 0 ) . pageX - this . _element . offsetLeft ; var y = event . touches . item ( 0 ) . pageY - this . _element . offsetTop ; this . gameState . addPoint ( x , y , first ) ; return false ; } }
function ( fileName ) { var item ; item = this . storageImpl . getItem ( prefix + fileName ) ; if ( item != null ) { try { return JSON . parse ( item ) ; } catch ( e ) { return null ; } } else { return null ; } }
function ( question ) { console . log ( "good answer" ) ; console . log ( "Question → " + question . question ) ; console . log ( "Expected → " + question . possible_answers ) ; console . log ( "Given    → " + question . answer ) ; chatboxAppend ( { time : + new Date ( ) , author : null , content : "Bravo, vous avez trouvé la bonne réponse !" } ) ; }
function newQuestion ( ) { question = Quiz . pick ( questions ) ; if ( question ) { io . sockets . emit ( "message" , { time : + new Date ( ) , author : null , content : "Nouvelle question." } ) ; io . sockets . emit ( "question" , { question : question . question } ) ; } else { io . sockets . emit ( "end of quiz" , null ) ; } }
function ( ) { var callback1 = function ( ) { } ; var callback2 = function ( ) { } ; mediator . subscribe ( TEST_CHANNEL , callback1 , this ) ; mediator . subscribe ( TEST_CHANNEL , callback2 , this ) ; expect ( channels [ TEST_CHANNEL ] ) . toContain ( callback1 , callback2 ) ; }
function ( ) { console . log ( 'pop ' + ind ) ; instance . filters . splice ( ind , 1 ) ; instance . getFilteredData ( ) ; instance . sortBy ( instance . sortedBy , instance . descending ) ; instance . showFilters ( ) ; }
function ( EL , uncess ) { uncess = uncess || 0 ; var newThat = fluid . model . makeTrundler ( that . root , config , that . strategies ) ; newThat . segs = config . parser ? config . parser ( EL ) : fluid . model . parseEL ( EL ) ; newThat . index = 0 ; newThat . path = "" ; newThat . step ( newThat . segs . length - uncess ) ; return newThat ; }
function ( source , options ) { if ( options . isomorphic ) { return fluid . model . transform . isomorphicSchemaStrategy ( source ) ; } else if ( options . flatSchema ) { return fluid . model . transform . flatSchemaStrategy ( options . flatSchema ) ; } }
function ( error , user ) { if ( user ) { obj . user = user ; } else { obj . user = "User not found: " + obj . _source . user ; } result . hits . push ( obj ) ; done ( ) ; }
function ( ptarget_uuid , pageNum , appType , callback ) { var data = { query : { term : { target_uuid : ptarget_uuid } } , from : paging ( pageNum ) , size : sizeOfResult } ; switchIndex ( appType ) ; switchMapping ( 1 ) ; mapping . search ( data , function ( err , data ) { if ( data . hits . total !== 0 ) { getUserObj ( data , callback ) ; } else { callback ( undefined ) ; } } ) ; }
function ( updateResult ) { if ( updateResult ) { document . set ( data , function ( err , req , esData ) { if ( esData ) { callback ( esData ) ; } else { callback ( undefined ) ; } } ) ; } else { callback ( undefined ) ; } }
function ( commentID , appType , callback ) { var data ; var link = '/' + switchIndex ( appType ) + '/comments/' + commentID + '/_update' ; data = { 'script' : 'ctx._source.isAnswered = status' , 'params' : { 'status' : 'true' } } db . post ( link , data , function ( err , req , data ) { if ( data ) { callback ( data ) ; } else { callback ( undefined ) ; } } ) }
function ( result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , question : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , question : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( error , result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , question : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , question : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , questions : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , questions : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , questions : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , questions : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 } ) ) ; }
function ( ) { var filename , random , timestamp , tmpdir , _ref ; tmpdir = ( _ref = process . env . TMPDIR ) != null ? _ref : "/tmp" ; timestamp = new Date ( ) . getTime ( ) ; random = parseInt ( Math . random ( ) * Math . pow ( 2 , 16 ) ) ; filename = "pow." + process . pid + "." + timestamp + "." + random ; return path . join ( tmpdir , filename ) ; }
function ( ) { if ( Graphs . find ( ) . count ( ) === 0 ) { var names = [ "Boxes" , "Gauge" ] ; for ( var i = 0 ; i < names . length ; i ++ ) Players . insert ( { name : names [ i ] } ) ; } }
function zoomShow ( src , highSrc ) { var low = '<img id="zoomlayLow" src="' + src + '">' ; zoomlayPage . html ( low ) ; zoomlay . fadeIn ( 800 ) ; if ( highSrc ) { var high = '<img id="zoomlayHigh" src="' + highSrc + '">' ; zoomlayPage . append ( high ) . hide ( ) ; var $high = $ ( '#zoomlayHigh' ) , $low = $ ( '#zoomlayLow' ) ; $high . load ( function ( ) { $low . hide ( ) ; $high . show ( ) ; } ) ; } }
function ( ) { var placeholder = this . getPlaceholder ( ) ; if ( placeholder !== undefined && this . getVal ( ) . length === 0 && this . search . hasClass ( "select2-focused" ) === false ) { this . search . val ( placeholder ) . addClass ( "select2-default" ) ; this . search . width ( "auto" ) ; } else { this . search . val ( " " ) . width ( 10 ) ; } }
function ( e ) { cy . on ( 'drag' , 'node' , function ( ) { updateNodePosition ( this ) ; } ) ; cy . on ( 'layoutstop' , function ( ) { var nodes = cy . nodes ( ) ; for ( var i = 0 ; i < nodes . length ; i ++ ) { var node = nodes [ i ] ; updateNodePosition ( node ) ; } } ) ; }
function ( index , oldPos , newPos , isLocal ) { if ( isLocal ) { return ; } if ( newPos . x === undefined || newPos . y === undefined ) { newPos = oldPos ; } var id = model . get ( '_entities.' + index + '.id' ) ; fn ( id , newPos ) ; }
function ( event ) { event . preventDefault ( ) ; var target = $ ( event . currentTarget ) . closest ( '.un-us-item' ) ; var task = Greenmine . taskCollection . get ( target . data ( 'id' ) ) ; this . lightbox . setReference ( task ) ; this . lightbox . open ( ) ; this . lightbox . on ( 'delete' , this . deleteIssue ) ; }
function ( data , e ) { this . tree . fireEvent ( "enddrag" , this . tree , data . node , e ) ; if ( this . scroller !== false ) { Roo . log ( 'clear scroller' ) ; window . clearInterval ( this . scroller ) ; this . scroller = false ; } }
function ( err , decoratedPosts ) { if ( err ) { return next ( err ) ; } var data = decoratedPosts [ 0 ] ; res . json ( data , 201 ) ; RequestLogger . log ( req , data ) ; }
function ( ) { var ids = Object . keys ( idsObj ) , idsLen = ids . length , classname = user . getClassName ( ) , field = '__name' , keyFields = [ ] ; if ( idsLen ) { for ( var i = 0 ; i < idsLen ; ++ i ) { var key = [ classname , ids [ i ] , field ] ; keyFields . push ( key ) ; } } return { 'get' : keyFields } ; }
function ( err , fd_ ) { fd = fd_ ; if ( err ) { traceIf ( 0 , 'Error opening/creating file: ' + filename , socket ) ; socket . write ( "553 Could not create file\r\n" ) ; dataSocket . end ( ) ; return ; } logIf ( 3 , "File opened/created: " + filename , socket ) ; logIf ( 3 , "Told client ok to send file data" , socket ) ; socket . write ( "150 Ok to send data\r\n" ) ; whenDataReady ( handleUpload ) ; }
function ( err , data ) { if ( err ) return next ( err ) ; resolved . Stylesheet [ index ] = { id : path . basename ( uri . pathname ) , data : data . toString ( ) } ; next ( err ) ; }
function ( err , data ) { if ( err ) return next ( err ) ; resolved . Stylesheet [ index ] = { id : s , data : data } ; next ( err ) ; }
function computeLocalMatrix ( ) { if ( this . _cachedLocalMatrixIsValid ) { return this . _cachedLocalMatrix ; } else { math . transform . fixed ( this . position , this . rotation , this . scale , this . _cachedLocalMatrix ) ; this . _cachedLocalMatrixIsValid = true ; return this . _cachedMatrix ; } }
function foldersToFiles ( specFolders ) { var files = [ ] ; specFolders . forEach ( function ( folder ) { fs . readdirSync ( Path . join ( JS_COVERAGE_BASE , folder ) ) . forEach ( function ( filename ) { if ( Path . extname ( filename ) === '.js' ) { files . push ( Path . join ( JS_COVERAGE_BASE , folder , filename ) ) ; } } ) ; } ) ; return files ; }
function runCoverage ( consoleArgs ) { if ( hasInvalidParams ( ) ) return ; if ( Helper . resetDir ( JS_COVERAGE_BASE ) === false ) return ; Helper . jscoverage ( consoleArgs . projectFolder , JS_COVERAGE_BASE , function ( err ) { if ( err ) { console . log ( err . toString ( ) ) ; return ; } runJasmineProxy ( consoleArgs ) ; } ) ; }
function run ( ) { if ( hasInvalidParams ( ) ) { process . argv = [ 'node' , 'mocha' , '--help' ] ; help ( ) ; } else { runCoverage ( consoleArgs ) ; } }
function ( done ) { var args = require ( '../lib/args' ) . getParams ( process . argv . slice ( 2 ) ) ; args . projectFolder . should . equal ( '' ) ; args . specFolders . should . eql ( [ ] ) ; args . specFiles . should . eql ( [ ] ) ; args . params . should . eql ( [ ] ) ; done ( ) ; }
function getDescription ( mdown , fromIndex ) { var desc = mdown . substr ( fromIndex ) ; desc = desc . replace ( /^\n+/g , '' ) . split ( /\n\n/ ) [ 0 ] ; if ( ( /^(?:(?:[#=]+)|(?:[\-`\=]{3,})|(?: {4,}))/ ) . test ( desc ) ) { return null ; } desc = showdown . parse ( desc . replace ( /\n+/ , ' ' ) ) . replace ( /<\/?p>/g , '' ) . replace ( /<\/?a[^>]*>/g , '' ) ; return desc ; }
function ( callback ) { var callback = callback ; core . ajax ( { url : "https://api.stackexchange.com/docs/users-by-ids#order=desc&sort=reputation&ids=366313&filter=default&site=stackoverflow&run=true" , type : "GET" , success : function ( data ) { if ( callback ) callback ( data ) ; } , error : function ( ) { core . ajax ( { url : "static/stack_overflow_profile.json" , type : "GET" , success : function ( data ) { if ( callback ) callback ( data ) ; } } ) ; } } ) ; }
function ( ) { if ( request . readyState === 4 && request . status === 200 ) { var response = JSON . parse ( request . responseText || "null" ) , cb = response . code < 0 ? error : success , data = response . code < 0 ? response . msg : response . data ; return cb && cb ( data , response ) ; } }
function ( ) { if ( request . readyState === 4 ) { if ( request . status === 412 ) { resp = JSON . parse ( request . responseText ) ; alert ( resp . msg ) ; } else if ( request . status === 200 ) { resp = JSON . parse ( request . responseText ) ; builder . build ( resp . data ) . into ( window ) ; _webworksReady = true ; fireWebworksReadyEvent ( ) ; } } }
function ( code , error , httpCode ) { if ( ! httpCode ) { httpCode = 200 ; } res . send ( httpCode , { code : Math . abs ( code ) * - 1 || - 1 , data : null , msg : error } ) ; }
function ( ) { spyOn ( plugin , "exec" ) . andCallFake ( function ( request , succ , fail , body ) { succ ( [ "MyFeatureId" ] ) ; } ) ; req . params . service = "default" ; req . params . action = "exec" ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : 1 , data : [ "MyFeatureId" ] } ) ; }
function ( ) { spyOn ( plugin , "exec" ) . andCallFake ( function ( request , succ , fail , body ) { fail ( - 1 , "ErrorMessage" ) ; } ) ; req . params . service = "default" ; req . params . action = "exec" ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : - 1 , data : null , msg : "ErrorMessage" } ) ; }
function ( ) { var expectedResult = { "author" : "Yogi bear" } ; spyOn ( Whitelist . prototype , "isFeatureAllowed" ) . andReturn ( true ) ; spyOn ( applicationAPIServer , "author" ) . andCallFake ( function ( success , fail ) { success ( expectedResult ) ; } ) ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : 1 , data : expectedResult } ) ; }
function ( ) { var expectedResult = "omg" ; spyOn ( Whitelist . prototype , "isFeatureAllowed" ) . andReturn ( true ) ; spyOn ( applicationAPIServer , "author" ) . andCallFake ( function ( success , fail ) { fail ( - 1 , expectedResult ) ; } ) ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : - 1 , data : null , msg : expectedResult } ) ; }
function ( status ) { if ( status === 'fail' ) callback ( status ) ; else { if ( self . hasBeenDefined ( '$' ) ) callback ( null , self ) ; else { if ( webPage . injectJs ( 'js/libs/jquery-1.7.1.min.js' ) ) callback ( null , self ) ; else callback ( 'Could not load jQuery (needed for testing)' ) ; } } }
function ( state ) { if ( this . stateful ) { this . suspendEvents ( ) ; this . collapsed = state . collapsed ; if ( this . statefulNodes ) { this . restoreNodes ( state . nodes ) ; } if ( state . customHostFilters ) { this . store . customHostFilters = state . customHostFilters ; } if ( state . customServiceFilters ) { this . store . customServiceFilters = state . customServiceFilters ; } this . resumeEvents ( ) ; } }
function startTask ( ) { var task = self . tasks . shift ( ) ; if ( task ) { task . fn . call ( task . context || self , startTask ) ; } else { self . running -= 1 ; if ( self . running === 0 ) runCallbacks ( ) ; } }
function ( ) { if ( this . _currentDocument . model . currentView !== 'design' ) { this . _currentDocument . model . switchViewTo ( 'design' ) ; this . btnCode . setAttribute ( 'class' , 'inactive' ) ; this . btnDesign . removeAttribute ( 'class' ) ; var render = this . renderDesignView . bind ( this . _currentDocument ) ; render ( ) ; } }
function ( ) { console . log ( 'Worker ' + worker . process . pid + ' is online' ) ; }
function ( worker , code , signal ) { console . log ( 'worker ' + worker . process . pid + ' died' ) ; if ( shuttingDown === true ) { console . log ( 'master is shutting down workers' ) ; return ; } if ( Object . keys ( cluster . workers ) . length >= config . http . numWorkers ) { return ; } worker = forkWorkers ( 1 ) . shift ( ) ; console . log ( "Replace with worker: " + worker . process . pid ) ; lastWorkerCreated = Date . now ( ) ; }
function ( name ) { var args , isFn ; args = slice . call ( arguments , 1 ) if ( ! ( isFn = isCallable ( name ) ) ) { name = String ( name ) ; } return function ( obj ) { return apply . call ( isFn ? name : value ( obj ) [ name ] , obj , args . concat ( slice . call ( arguments , 1 ) ) ) ; } ; }
function ( key , value ) { var el = value ; el . id = key ; el . repositoryId = that . repositoryId ; el . type = 'language' ; el . url = FlagIcons . path + '/img/flags/' + el . id + '.png' ; that . languageCodes . push ( new Aloha . RepositoryDocument ( el ) ) ; }
function ( obj ) { obj . find ( 'span[lang]' ) . each ( function ( ) { jQuery ( this ) . removeClass ( WAI_LANG_CLASS ) ; } ) ; }
function graphQuery ( id , cmd , success ) { $ . ajax ( { type : "POST" , url : site_url + '/admin/statistics/graph' , data : { 'id' : id , 'cmd' : cmd , } , success : success , error : function ( res ) { ajaxError ( ) ; } } ) ; }
function ( ) { $ ( '#editform .item.block_text input[type=button]' ) . each ( aaPrepareTextEditorButton ) ; $ ( '#editform .item.block_text textarea' ) . click ( aaStoreCaret ) . select ( aaStoreCaret ) . keyup ( aaStoreCaret ) ; }
function ( str , version ) { var pattern ; if ( version == 3 || version == 'v3' ) { pattern = /[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i ; } else if ( version == 4 || version == 'v4' ) { pattern = /[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i ; } else { pattern = /[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i ; } return str . match ( pattern ) ; }
function ( ) { var arrayIndex = ByteCode . pop ( ) . value ( ) ; var array = ByteCode . pop ( ) ; if ( array === null ) { ByteCode . throwException ( "NullPointerException" ) ; return ; } if ( arrayIndex < 0 && array >= array . length ) { ByteCode . throwException ( "ArrayIndexOutOfBoundsException" ) ; return ; } ByteCode . push ( array . get ( arrayIndex ) ) ; }
function ( ) { var value = ByteCode . pop ( ) ; var arrayIndex = ByteCode . pop ( ) . value ( ) ; var array = ByteCode . pop ( ) ; if ( array === null ) { ByteCode . throwException ( "NullPointerException" ) ; return ; } if ( arrayIndex < 0 && arrayIndex >= array . length ) { ByteCode . throwException ( "ArrayIndexOutOfBoundsException" ) ; return ; } array . set ( arrayIndex , value ) ; }
function ( initialValue ) { var number2 = ByteCode . pop ( ) ; var number1 = ByteCode . pop ( ) ; var result = initialValue ; if ( isNaN ( number1 . value ( ) ) || isNaN ( number2 . value ( ) ) ) { } else { if ( number1 > number2 ) { result = 1 ; } else if ( number1 === number2 ) { result = 0 ; } else { result = - 1 ; } } ByteCode . push ( Primitives . getInteger ( result ) ) ; }
function ( className ) { var arrayLength = ByteCode . pop ( ) . value ( ) ; if ( arrayLength < 0 ) { ByteCode . throwException ( "NegativeArraySizeException" ) ; return ; } var class_ = JVM . getClass ( className ) ; ByteCode . push ( new JavaArray ( Enum . dataType . OBJECT , class_ , 1 , arrayLength ) ) ; }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value ( ) === value2 . value ( ) ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value ( ) != value2 . value ( ) ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value ( ) === value2 . value ( ) ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value ( ) != value2 . value ( ) ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value ( ) < value2 . value ( ) ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value ( ) <= value2 . value ( ) ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value ( ) > value2 . value ( ) ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( offset ) { var value2 = ByteCode . pop ( ) ; var value1 = ByteCode . pop ( ) ; if ( value1 . value ( ) >= value2 . value ( ) ) { ByteCode . branch ( 3 , offset ) ; return ; } }
function ( constant ) { if ( constant . getTag ( ) === Enum . constantPoolTag . LONG ) { ByteCode . push ( constant . value ( ) ) ; return ; } if ( constant . getTag ( ) === Enum . constantPoolTag . DOUBLE ) { ByteCode . push ( constant . value ( ) ) ; return ; } }
function ( atype ) { var count = ByteCode . pop ( ) . value ( ) ; if ( count < 0 ) { ByteCode . throwException ( "NegativeArraySizeException" ) ; return ; } ByteCode . push ( new JavaArray ( Enum . dataType . PRIMITIVE , ArrayType . type [ atype ] , 1 , count ) ) ; }
function ( length , default_ , low , high , offsets ) { var index = ByteCode . pop ( ) . value ( ) ; var offset = default_ ; if ( index >= low || index <= high ) { offset = offsets [ index - low ] ; } JVM . getExecutingThread ( ) . incrementPC ( offset - length ) ; }
function printCharArrayToConsole ( arrayToPrint ) { JVM . println ( "[" ) ; for ( var i = 0 ; i < arrayToPrint . length ; i ++ ) { if ( arrayToPrint [ i ] === undefined ) { JVM . print ( ' ' ) ; } else { JVM . print ( String . fromCharCode ( arrayToPrint [ i ] . value ( ) ) ) ; } if ( i != arrayToPrint . length - 1 ) { JVM . print ( ',' ) ; } } JVM . print ( ']' ) ; }
function ( ) { var theArguments = NativeFunctions . getArguments ( "(I)Ljava/lang/Class;" ) ; var numberOfFrames = theArguments [ 0 ] . value ( ) ; var frameOfInterest = JVM . getExecutingThread ( ) . getStack ( ) . stack [ JVM . getExecutingThread ( ) . getStack ( ) . length - 1 - numberOfFrames ] ; MethodRun . createReturn ( frameOfInterest . methodInfo . classInfo ) ; }
function ( contextEvent ) { if ( contextEvent . target . tagName == "A" ) { Unsocialize . linkURL = contextEvent . target . href ; document . getElementById ( "unsocialize-menu-item" ) . hidden = "" ; } else if ( contextEvent . target . tagName == "SPAN" && contextEvent . target . parentElement . tagName == "A" ) { Unsocialize . linkURL = contextEvent . target . parentElement . href ; document . getElementById ( "unsocialize-menu-item" ) . hidden = "" ; } else { document . getElementById ( "unsocialize-menu-item" ) . hidden = "true" ; } }
function ( ) { $ ( 'body' ) . removeClass ( 'logged-in' ) . addClass ( 'guest' ) ; var model = new WebUser ; var view = new LoginView ( { model : model } ) ; view . render ( ) ; model . on ( 'login' , function ( ) { App . vent . trigger ( 'webUser:init' , this ) ; App . vent . trigger ( 'post:list' ) ; } , model ) ; }
function nextFragment ( ) { var fragments = document . querySelectorAll ( '.present .fragment:not(.visible)' ) ; if ( fragments . length ) { fragments [ 0 ] . classList . add ( 'visible' ) ; return true ; } return false ; }
function ( store , records ) { var view = this . getDataView ( ) ; view . select ( 0 ) ; view . getEl ( ) . select ( '.recommended_pick .edit' , true ) . each ( this . createEditButton ) ; view . hide ( ) . show ( ) ; this . setStatusMessage ( 'Success!' ) ; this . getDataView ( ) . setDisabled ( false ) ; }
function ( event , trigger ) { if ( event === "invoked" ) { if ( _startupMode !== _application . invocation . LAUNCH ) { trigger ( ) ; _startupMode = _application . invocation . LAUNCH ; } window . qnx . webplatform . getApplication ( ) . invocation . addEventListener ( "Invoked" , trigger ) ; } else { console . log ( "Ignore registration for unknown event: " + event ) ; } }
function ( ) { var self = this ; var done = self . async ( ) ; var templateDir = this . file . src ; var handlebarsCmd = __dirname + '/../node_modules/.bin/handlebars -m ' + templateDir + '/*.handlebars -f ' + this . file . dest ; exec ( handlebarsCmd , function ( err , stdout , stderr ) { if ( err ) { grunt . fail . fatal ( stderr ) ; } done ( ) ; } ) ; }
function ( doc , cdt , cdn ) { var d = locals [ cdt ] [ cdn ] ; var cond = ( doc . order_type == 'Maintenance' ) ? " and tabItem.is_service_item = 'Yes'" : " and tabItem.is_sales_item = 'Yes'" if ( doc . customer ) return repl ( "SELECT i.name,i.item_code,concat('Last quoted at - ',cast(quote_rate as char)) as quote_rate,concat('Last sold at - ',cast(sales_rate as char)) as sales_rate, i.item_name, i.description FROM\ 		(\ 			select item_code,name, item_name, description from tabItem where tabItem.%(key)s like '%s' %(cond)s\ 		)i\ 		left join\ 		(\ 			select q.item_code,q.quote_rate from\ 			(\ 				select q.transaction_date,qd.item_code,basic_rate as quote_rate from `tabQuotation Item` qd, `tabQuotation` q where q.name=qd.parent and q.docstatus=1 and customer='%(cust)s'\ 			)q,\ 			(\ 				select qd.item_code,max(transaction_date) as transaction_date from `tabQuotation Item` qd, `tabQuotation` q where q.name=qd.parent and q.docstatus=1 and customer='%(cust)s' group by qd.item_code\ 			)m where q.item_code=m.item_code and q.transaction_date=m.transaction_date\ 		)q on i.item_code=q.item_code\ 		left join\ 		(\ 			select r.item_code,r.sales_rate from\ 			(\ 				select r.voucher_date,rd.item_code,basic_rate as sales_rate from `tabSales Invoice Item` rd, `tabSales Invoice` r where r.name=rd.parent and r.docstatus=1 and customer='%(cust)s'\ 			)r,\ 			(\ 				select rd.item_code,max(voucher_date) as voucher_date from `tabSales Invoice Item` rd, `tabSales Invoice` r where r.name=rd.parent and r.docstatus=1 and customer='%(cust)s' group by rd.item_code\ 			)m where r.item_code=m.item_code and r.voucher_date=m.voucher_date\ 		)s on i.item_code=s.item_code ORDER BY item_code LIMIT 50" , { cust : doc . customer , cond : cond } ) ; else return repl ( "SELECT name, item_name, description FROM tabItem WHERE `tabItem`.%(key)s LIKE '%s' %(cond)s ORDER BY tabItem.item_code DESC LIMIT 50" , { cond : cond } ) ; }
function testAndSendChatMsg ( e ) { if ( e . keyCode == 13 ) { var msg = new Message ( "chat" , myUsername , myUID , $ ( '#chatInput' ) . val ( ) ) ; ws . send ( JSON . stringify ( msg ) ) ; } }
function ( ) { req = { params : { service : "" , action : "" } , body : "" } ; res = { send : jasmine . createSpy ( ) } ; GLOBAL . frameworkModules = [ 'ext/blackberry.app/index.js' , 'lib/plugins/extensions.js' , 'lib/plugins/default.js' ] ; }
function thrown ( invocation , error ) { var steps = invocation . arguments [ 0 ] , next = steps [ invocation . index + 1 ] ; if ( next && ~ next . parameters . indexOf ( "error" ) ) { invocation . context . error = error ; } else { if ( timer ) clearTimeout ( timer ) ; abended = true ; callback ( error ) ; } }
function ( parameter ) { if ( /^(_|done)$/ . test ( parameter ) ) { arg = callback ( ) ; } else if ( ( arg = context [ parameter ] ) == void ( 0 ) ) { arg = methods [ parameter ] ; } args . push ( arg ) ; }
function ( e ) { localStorage . setItem ( "saveStatus" , "Saving in unload..." ) ; return "You have unsaved changes, click cancel to save them. \n\n" + "You have unbacked up data. \n\nIf you want backup/share your data with your collaborators click Cancel, then click the Sync button.\n\n" + "Your data currently saved on your local tablet/laptop only." ; }
function ( numberOfUnsavedItems ) { if ( ! numberOfUnsavedItems ) { numberOfUnsavedItems = 1 ; } this . totalUnsaved += numberOfUnsavedItems ; $ ( ".unsaved-changes" ) . val ( this . totalUnsaved ) ; }
function ( numberOfUnsyncedItems ) { if ( ! numberOfUnsyncedItems ) { numberOfUnsyncedItems = 1 ; } this . totalUnsynced += numberOfUnsyncedItems ; $ ( ".unsynced-changes" ) . val ( this . totalUnsynced ) ; }
function ( numberOfTotalDocs ) { if ( ! numberOfTotalDocs ) { numberOfTotalDocs = 100 ; } this . totalPouchDocs = numberOfTotalDocs ; $ ( ".unsynced-changes" ) . attr ( "max" , this . totalPouchDocs ) ; }
function ( numberOfTotalDocs ) { if ( ! numberOfTotalDocs ) { numberOfTotalDocs = 100 ; } this . totalBackboneDocs = numberOfTotalDocs ; $ ( ".unsaved-changes" ) . attr ( "max" , this . totalBackboneDocs ) ; }
function ( ) { var u = this . get ( "confidential" ) . encrypt ( JSON . stringify ( this . get ( "userPrivate" ) . toJSON ( ) ) ) ; localStorage . setItem ( "encryptedUser" , u ) ; }
function ( err , resp ) { Utils . debug ( "Replicate from " + couchurl ) ; Utils . debug ( resp ) ; Utils . debug ( err ) ; if ( err == null || err == undefined ) { localStorage . setItem ( "mostRecentCouchConnection" , JSON . stringify ( couchConnection ) ) ; appView . datumsView . updateDatums ( ) ; } if ( typeof fromcallback == "function" ) { fromcallback ( ) ; } }
function ( ) { var m = new DatumField ( { "state" : this . $el . find ( ".add_input" ) . val ( ) , "color" : this . $el . find ( ".add_color_chooser" ) . val ( ) } ) ; this . model . get ( "datumStates" ) . add ( m ) ; }
function ( ) { this . model . get ( "sessionFields" ) . where ( { label : "consultants" } ) [ 0 ] . set ( "value" , this . $el . find ( ".session-consultant-input" ) . val ( ) ) ; }
function ( ) { this . model . get ( "sessionFields" ) . where ( { label : "goal" } ) [ 0 ] . set ( "value" , this . $el . find ( ".session-goal-input" ) . val ( ) ) ; }
function ( selector , values ) { if ( ! selector ) { throw new Error ( 'no selector defined.' ) ; } if ( JarallaxTools . isValues ( values ) ) { var newDefault = new JaralaxObject ( selector , values ) ; newDefault . activate ( ) ; this . defaultValues . push ( newDefault ) ; } }
function ( attr ) { var matches ; matches = attr . key . indexOf ( 'admin/' ) === 0 && attr . key . indexOf ( 'admin/templates' ) !== 0 ; if ( matches ) console . log ( attr . key , 'matches' ) ; return matches ; }
function ( config ) { var controller ; if ( config == null ) { config = { } ; } try { controller = Ext . create ( controllerClass , config . controllerConfig || this . controllerConfig || { } ) ; } catch ( error ) { Deft . Logger . warn ( "Error initializing Controllable instance: an error occurred while creating an instance of the specified controller: '" + controllerClass + "'." ) ; throw error ; } this . getController = function ( ) { return controller ; } ; originalConstructor . apply ( this , arguments ) ; controller . controlView ( this ) ; return this ; }
function ( ) { this . state = 'pending' ; this . progress = void 0 ; this . value = void 0 ; this . progressCallbacks = [ ] ; this . successCallbacks = [ ] ; this . failureCallbacks = [ ] ; this . cancelCallbacks = [ ] ; this . promise = Ext . create ( 'Deft.Promise' , this ) ; return this ; }
function ( error , librarySC ) { if ( error ) { return callback ( error ) ; } templating . render ( { 'template' : 'wrapper.js' , 'view' : { 'name' : options . treeName } , 'partials' : { 'node' : '' , 'library' : librarySC , 'packages' : options . renderedPkgs . join ( '\n\n\n\n' ) } } , callback ) ; }
function refresh_editionMode ( ) { value = get_editionMode ( ) set_editionMode ( value ) $ ( "#mode_edition" ) . text ( value ) if ( value == 'VISITE' ) { $ ( ".edit" ) . hide ( ) $ ( ".edit_visible" ) . hide ( ) } else if ( value == 'EDITION' ) { } else alert ( 'unknown edition mode value: ' + value ) }
function do_init_mouse_hover ( ) { $ ( ".details" ) . hover ( body_mouseenter , body_mouseleave ) $ ( ".edit" ) . hide ( ) $ ( ".optional" ) . hide ( ) $ ( ".edit_visible" ) . show ( ) }
function toogle_editionMode ( ) { mode = get_editionMode ( ) if ( mode == 'VISITE' ) { set_editionMode ( 'EDITION' ) } else if ( mode == 'EDITION' ) { set_editionMode ( 'VISITE' ) } refresh_editionMode ( ) }
function ( ev , data ) { console . log ( "msgReceived triggered" ) ; var convId = buildConversationID ( data . fromID , data . toID ) ; newMessageReceivedGUI ( self . convView , self . msgView , data . fromID , data . toID , data . convID , data . msgID , data . dateReceived , data . text , false ) ; }
function ( userid , password ) { var self = this ; var xmppServerAddress = "http://localhost:3333/app/dsadsa/http-bindours/" ; self . conn = new Strophe . Connection ( xmppServerAddress ) ; self . userid = userid ; self . password = password ; window . app . xmppConn = this ; self . conn . connect ( userid , password , self . connectCallback ) ; }
function ( ) { var text = textarea . value ; var lan = language . value ; text = text . replace ( /</g , '&lt;' ) . replace ( />/g , '&gt;' ) ; text = '<pre class="brush: ' + lan + '">' + text + '</pre>' ; that . _action && that . _action ( text ) ; that . hide ( ) ; if ( localStorage ) { localStorage [ 'lastLanguage' ] = lan ; } }
function ( value , result ) { if ( isPending ( value ) ) { value [ valueOf ] = result var listeners = watchers ( value ) while ( listeners . length ) await ( result , listeners . shift ( ) ) value [ pending ] = false } return value }
function ( ) { var _i , _len , _ref1 , _results ; _ref1 = ast . parameters ; _results = [ ] ; for ( _i = 0 , _len = _ref1 . length ; _i < _len ; _i ++ ) { p = _ref1 [ _i ] ; _results . push ( generate ( p , options ) ) ; } return _results ; }
function getPosition ( cache , settings ) { var elOffset = $element . offset ( ) , elHeight = $element . outerHeight ( ) , elWidth = $element . outerWidth ( ) ; if ( position === undefined || cache === false ) { position = Tip . calcPosition ( elOffset , elHeight , elWidth , settings ) ; } return position ; }
function ( ) { this . _world = new Box2D . Dynamics . b2World ( new Box2D . Common . Math . b2Vec2 ( 0 , Settings . Box2D_GRAVITY ) , Settings . Box2D_ALLOW_SLEEP ) ; if ( Settings . IS_BROWSER_ENVIRONMENT ) { this . setupDebugDraw ( ) ; } }
function getMime ( imageType ) { switch ( imageType ) { case ( 'jpg' ) : return ( /pjpeg$/i ) . test ( uri ) ? 'pjpeg' : 'jpeg' ; case ( 'ico' ) : return 'vnd.microsoft.icon' ; case ( 'jng' ) : return 'x-jng' ; case ( 'pic' ) : return 'x-lotus-pic' ; default : return imageType ; } }
function ( e ) { if ( $ ( e . target ) . closest ( ".select2-result-selectable:not(.select2-disabled)" ) . length > 0 ) { this . highlightUnderEvent ( e ) ; this . selectHighlighted ( e ) ; } else { killEvent ( e ) ; this . focusSearch ( ) ; } }
function maybeChange ( vv ) { LOG ( "maybeChange: " + vv ) ; if ( vv . lastMaybeChanged === timestamp ) return ; vv . lastMaybeChanged = timestamp ; var mm = vv . writtenBy ; if ( mm ) { LOG ( vv + " written by " + mm ) ; ASSERT ( mm . outputs . has ( vv ) , vv + " not actually written by " + mm ) ; maybeExecute ( mm ) ; } else { set ( vv ) ; } }
function toJS ( model ) { if ( hd . isVariable ( model ) ) { model = model ( ) ; } if ( typeof model === "object" ) { Object . keys ( model ) . forEach ( function ( key ) { model [ key ] = toJS ( model [ key ] ) ; } ) ; } else if ( Array . isArray ( model ) ) { model = model . map ( toJS ) ; } return model ; }
function showGame ( ) { document . onclick = null ; if ( menuLoop ) cancelAnimationFrame ( menuLoop ) ; document . onkeydown = gameKeydown ; document . onkeyup = gameKeyup ; gameLoop = requestAnimationFrame ( drawGame ) ; }
function draw ( ctx ) { var pt = false ; if ( this . containsPoint ( mouseX , mouseY ) === true ) { pt = true ; } ctx . fillStyle = 'blue' ; roundRect ( ctx , x , y , w , h , pt ) ; ctx . fillStyle = 'white' ; ctx . font = '20pt Helvetica' ; ctx . textAlign = 'center' ; ctx . fillText ( text , x + w / 2 , y + 30 , w - 20 ) ; }
function menuClick ( ) { for ( var i = 0 ; i < menu . length ; i ++ ) { if ( menu [ i ] . containsPoint ( mouseX , mouseY ) ) { menu [ i ] . trigger ( ) ; } } }
function ( path , options ) { options = options || { } ; options . type = "require" ; this . _addPath ( path , options ) ; return this ; }
function ( boolOrMinimizer ) { if ( _ . isUndefined ( boolOrMinimizer ) || boolOrMinimizer === true ) { this . minimizer = Minimizers . Default ; } else if ( ! boolOrMinimizer ) { this . minimizer = Minimizers . None ; } else if ( _ . isFunction ( boolOrMinimizer ) ) { this . minimizer = boolOrMinimizer ; } return this ; }
function ( inx , doc ) { if ( vidCount > totalVideoCount ) { return ; } vidCount ++ ; _this . $target . append ( $ ( '<video />' ) . attr ( { 'poster' : doc . thumb , 'src' : doc . video , 'preload' : 'none' } ) . css ( { 'width' : '160px' } ) . data ( 'meta' , doc ) ) ; }
function ( ) { var acStatus = kWidgetSupport . getAccessControlStatus ( embedPlayer . kalturaAccessControl , embedPlayer ) ; if ( acStatus !== true ) { embedPlayer . setError ( acStatus ) ; return ; } if ( this . isRestricted ( ) ) { embedPlayer . setError ( this . getMsgObject ( ) ) ; } }
function ( ) { var embedPlayer = this . embedPlayer ; embedPlayer . bindHelper ( 'KalturaSupport_EntryDataReady' , function ( ) { var acStatus = kWidgetSupport . getAccessControlStatus ( embedPlayer . kalturaAccessControl , embedPlayer ) ; if ( acStatus !== true ) { embedPlayer . setError ( acStatus ) ; return ; } if ( this . isRestricted ( ) ) { embedPlayer . setError ( this . getMsgObject ( ) ) ; } } ) ; }
function ( options ) { _ . bindAll ( this , 'fail' , 'uploading' , 'done' ) ; options = options || { } ; this . url = options . url || '/upload' ; this . data = options . data || { } ; this . _name = options . name || 'files[]' ; this . _multiple = options . multiple || true ; this . _enabled = options . enabled || true ; return this ; }
function ( document , terms ) { var doc , i ; doc = { document : document , terms : terms , index : this . currentDocNum } ; this . documents [ this . currentDocNum ] = doc ; i = 0 ; while ( i < terms . length ) { this . insertTerm ( terms [ i ] , this . currentDocNum ) ; i ++ ; } return this . currentDocNum ++ ; }
function ( ) { var result ; result = _this . getItemSync ( documentNumber ) ; return callback ( null , _this , result ) ; }
function ( ) { var sql = this . $ ( 'textarea' ) . val ( ) ; this . sqlView . setSQL ( sql ) ; this . model . useSQLView ( this . sqlView ) ; this . sqlView . fetch ( { error : function ( e ) { console . log ( e ) ; } } ) ; }
function ( ctx ) { var p = player . position ( ) ; var c = this . camera ( ) ; if ( p . y < 0 ) { this . camera ( { x : 0 , y : p . y - 7 } ) ; } }
function ( err , result ) { if ( err ) { callback ( { err : 'there was an error for Player.where()' } , undefined ) ; } else { console . log ( "DB RESULT" ) ; console . log ( result ) ; console . log ( result . length ( ) ) ; callback ( undefined , result ) ; } }
function ( block ) { if ( DEBUG_WIRE ) { console . group ( "root " + block + ":" + getBehavior ( block ) . name ) ; } if ( getBehavior ( block ) === Circuit . behaviors . junction ) { if ( DEBUG_WIRE ) { console . groupEnd ( ) ; } return ; } traceIntoNode ( null , block , null ) ; if ( DEBUG_WIRE ) { console . groupEnd ( ) ; } }
function ( duration ) { if ( typeof duration !== 'undefined' ) { if ( typeof duration !== 'string' || $ . inArray ( duration , that . valid_duration ) == - 1 ) { throw { name : 'typeError' , message : "Invalid duration. Duration needs to be char" } } currDuration = duration ; } return currDuration ; }
function ( ) { var clef = "treble" ; var containerDivId = "music_wysiwyg" ; var measures = 1 ; var numBeat = 4 ; var beatValue = 4 ; var container = Ava . Container ( { clef : clef , initNumOfMeasures : measures , numBeat : numBeat , beatValue : beatValue , containerDivId : containerDivId , } ) ; container . draw ( ) ; container . toggleEditable ( ) ; return container ; }
function ( ) { Ava . Context . currentDuration ( $ ( this ) . val ( ) ) ; }
function ( domElement ) { if ( ! window . getSelection ) return 0 ; var selection = window . getSelection ( ) ; if ( selection . focusNode === domElement ) return getFocusInSelection ( selection ) ; if ( selection . focusNode == null ) return null ; return getParentNodeOffset ( domElement , selection . focusNode ) + getFocusInSelection ( selection ) ; }
function ( domElement , offset ) { var selection = window . getSelection ( ) , focusPoint = getFocusPointAtOffset ( domElement , offset ) , range = document . createRange ( ) ; if ( window . getSelection ) if ( selection . rangeCount > 0 ) selection . removeAllRanges ( ) ; range . setStart ( focusPoint [ 0 ] , focusPoint [ 1 ] ) ; range . setEnd ( focusPoint [ 0 ] , focusPoint [ 1 ] ) ; selection . addRange ( range ) ; }
function ( ) { Session . set ( DROPDOWN_VISIBLE_KEY , true ) ; }
function ( rawComp ) { var comp ; if ( rawComp instanceof Backbone . Model ) { comp = rawComp . clone ( ) ; hydratedComps . push ( comp ) ; } else { switch ( rawComp . type ) { case "ImageModel" : comp = CompnentFactory . createImage ( rawComp ) ; hydratedComps . push ( comp ) ; break ; case "TextBox" : comp = CompnentFactory . createTextBox ( rawComp ) ; hydratedComps . push ( comp ) ; } } return _this . _registerWithComponent ( comp ) ; }
function ( component ) { var type ; type = component . get ( "type" ) ; _this . g2d . save ( ) ; _this . drawers [ type ] . paint ( component ) ; return _this . g2d . restore ( ) ; }
function ( ) { this . trigger ( "dispose" , this ) ; return this . off ( ) ; }
function ( transformName ) { var transformValue ; transformValue = _this . model . get ( transformName ) ; if ( transformValue ) { if ( transformName === "scale" ) { return transformStr += transformName + "(" + transformValue + ") " ; } else { return transformStr += transformName + "(" + transformValue + "rad) " ; } } }
function ( model ) { var type ; type = model . get ( "type" ) ; switch ( type ) { case "TextBox" : return new TextBoxView ( { model : model } ) ; case "ImageModel" : return new ImageView ( { model : model } ) ; case "Table" : return new TableView ( { model : model } ) ; } }
function ( target ) { var that = this ; this . $el . appendTo ( target ) ; function checkIt ( ) { if ( that . $el . parent ( ) ) { that . trigger ( 'DOMContentLoaded' ) ; return ; } setTimeout ( arguments . callee , 50 ) ; } setTimeout ( checkIt ( ) , 50 ) ; }
function deferredRender ( dfdRender ) { dfdRender . done ( function renderDone ( ) { $element . trigger ( REFRESH , arguments ) ; } ) ; dfdRender . then ( deferred . resolve , deferred . reject , deferred . notify ) ; dfdRender . notify ( [ "beforeRender" ] ) ; $fn . call ( $element , contents instanceof FUNCTION ? contents . apply ( self , arg ) : contents ) ; dfdRender . notify ( [ "afterRender" ] ) ; $element . find ( ATTR_WEAVE ) . weave ( dfdRender ) ; }
function isWebPage ( what ) { if ( ! what || typeof ( what ) !== "object" ) { return false ; } if ( phantom . version . major <= 1 && phantom . version . minor < 3 ) { return what instanceof WebPage ; } else { return what . indexOf ( 'WebPage(' ) === 0 ; } }
function ( data ) { $ ( o_prev ) . before ( data . content ) ; $ . sn . comments . waterMark ( ) ; $ ( 'div[id^=sn-ap-entry]:hidden' ) . slideDown ( 'slow' ) ; $ ( o_loader ) . hide ( ) ; if ( data . more === false ) { $ ( o_more ) . remove ( ) ; } }
function ( ) { this . _DOMinited = true ; var self = this ; $ . each ( self . enableModules , function ( idx , value ) { if ( value !== false && $ . sn [ idx ] !== undefined && $ . sn [ idx ] . _DOMChanged !== undefined ) { $ . sn [ idx ] . _DOMChanged ( ) ; } } ) ; $ . sn . _resize ( ) ; this . _DOMinited = false ; }
function ( ) { if ( xmlhttp . readyState == 4 && xmlhttp . status == 200 ) { var json = xmlhttp . responseText ; json = eval ( '(' + json + ')' ) ; print_resolvers ( json ) ; } }
function ( req , res ) { db . deleteAllNodes ( function ( err , result ) { if ( err ) return err ; console . log ( "all nodes deleted..." ) res . write ( 'all good' ) ; } ) ; res . end ( ) ; }
function ( target ) { if ( ! isPreviewExist ) { $ ( "#embedcontent_name_checkbox" ) . selected ( true ) ; } $ ( "." + active_tab_class ) . removeClass ( active_tab_class ) ; $ ( target ) . parent ( "li" ) . addClass ( active_tab_class ) ; $ ( "." + active_content_class ) . hide ( ) ; $ ( "#" + $ ( target ) . attr ( "id" ) + "_content" ) . addClass ( active_content_class ) . show ( ) ; }
function ( ) { console . log ( 'asd' ) ; var data = { text : $ ( this ) . siblings ( '.feedback-input' ) . text ( ) , image : getUserImage ( ) } ; console . log ( getUserImage ( ) ) ; console . log ( data ) ; $ ( this ) . siblings ( '#comments' ) . append ( Mustache . render ( commentTemplate , data ) ) ; }
function ( contentToAdd , disableRender ) { itemsToUpload . push ( contentToAdd ) ; disableAddToQueue ( ) ; enableStartUpload ( ) ; if ( ! disableRender ) { renderQueue ( ) ; } }
function ( success , templates ) { if ( success ) { renderMenu ( templates ) ; } else { debug . error ( 'Could not get the group templates' ) ; } }
function ( ) { var goToSlide = j ; if ( settings . infiniteSlider ) { goToSlide = j + infiniteSliderOffset ; } activeChildOffsets [ sliderNumber ] = helpers . changeSlide ( goToSlide , scrollerNode , scrollTimeouts , sliderMax , scrollbarClass , scrollbarWidth , stageWidth , scrollbarStageWidth , scrollMargin , scrollBorder , childrenOffsets , sliderNumber , infiniteSliderOffset , infiniteSliderWidth , numberOfSlides , settings ) ; }
function ( ) { if ( ( activeChildOffsets [ sliderNumber ] > 0 ) || settings . infiniteSlider ) { activeChildOffsets [ sliderNumber ] = helpers . changeSlide ( activeChildOffsets [ sliderNumber ] - 1 , scrollerNode , scrollTimeouts , sliderMax , scrollbarClass , scrollbarWidth , stageWidth , scrollbarStageWidth , scrollMargin , scrollBorder , childrenOffsets , sliderNumber , infiniteSliderOffset , infiniteSliderWidth , numberOfSlides , settings ) ; } }
function ( ) { if ( ( activeChildOffsets [ sliderNumber ] < childrenOffsets . length - 1 ) || settings . infiniteSlider ) { activeChildOffsets [ sliderNumber ] = helpers . changeSlide ( activeChildOffsets [ sliderNumber ] + 1 , scrollerNode , scrollTimeouts , sliderMax , scrollbarClass , scrollbarWidth , stageWidth , scrollbarStageWidth , scrollMargin , scrollBorder , childrenOffsets , sliderNumber , infiniteSliderOffset , infiniteSliderWidth , numberOfSlides , settings ) ; } }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 729 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 751 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 792 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 822 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 922 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 729 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 751 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 792 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 822 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 922 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 729 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 751 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 792 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 822 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 922 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( opts , callback ) { opts . stream = new PortAudioStream ( ) ; opts . stream . buffer = new Buffer ( 1 * 1024 * 1024 ) ; opts . channelCount = opts . channelCount || 2 ; opts . sampleFormat = opts . sampleFormat || portAudio . SampleFormat8Bit ; opts . sampleRate = opts . sampleRate || 44100 ; portAudioBindings . open ( opts , callback ) ; }
function ( ) { this . interactionResolution = 2 ; this . _featureMap = { } ; this . _initializeIcons ( ) ; this . _allRequests = [ ] ; this . _markerPoolSize = Config . maxMarkers || 500 ; this . _currentPopup = null ; }
function get_square_coords ( e ) { var oe = e . originalEvent , x = ( oe . offsetX == undefined ? oe . layerX : oe . offsetX ) , y = ( oe . offsetY == undefined ? oe . layerY : oe . offsetY ) ; return { Y : Math . floor ( y / 48 ) , X : Math . floor ( x / 48 ) } ; }
function ( entity , memberDefinition , newValue , valueNotSet ) { var errors = [ ] ; var typeName = Container . resolveName ( Container . resolveType ( memberDefinition . dataType ) ) ; var value = ! valueNotSet ? newValue : entity [ memberDefinition . name ] ; this . fieldValidate ( memberDefinition , value , errors , typeName ) ; return errors ; }
function ( validation ) { if ( memberDefinition [ validation ] && validatonGroup [ validation ] && ! validatonGroup [ validation ] ( value , this . getValidationValue ( memberDefinition , validation ) ) ) errors . push ( this . createValidationError ( memberDefinition , validation , 'Validation error!' ) ) ; }
function getPosition ( cache , settings ) { var elOffset = $element . offset ( ) , elHeight = $element . outerHeight ( ) , elWidth = $element . outerWidth ( ) ; if ( position === undefined || cache === false ) { position = Tip . calcPosition ( elOffset , elHeight , elWidth , settings ) ; } return position ; }
function setSlot ( obj , index , value ) { flushStack ( ) ; var t = temporary [ 0 ] ; statements . push ( t + " = " + obj + ".types[" + index + "];" ) ; statements . push ( obj + "[" + obj + ".slots[" + index + "]] = " + t + " ? " + t + ".call" + argumentList ( t , value ) + " : " + value + ";" ) ; }
function ( ) { var hthis , context = { context : { value : 'context' } } ; ist . registerHelper ( 'testBlock' , function ( ) { hthis = this ; return document . createDocumentFragment ( ) ; } ) ; ist ( textBlockhelper ) . render ( context ) ; expect ( hthis ) . toBe ( context ) ; }
function ( ) { var arg , context = { context : { value : 'context' } } ; ist . registerHelper ( 'testBlock' , function ( subcontext ) { arg = subcontext ; return document . createDocumentFragment ( ) ; } ) ; ist ( textBlockhelper ) . render ( context ) ; expect ( arg ) . toBe ( context . context ) ; }
function configureContext ( options ) { config = { pluginApi : pluginApi , resolvers : resolvers , facets : facets , listeners : listeners } ; lifecycle = new Lifecycle ( config ) ; resolver = new Resolver ( config ) ; contextHandlers = { init : array . delegate ( options . init ) , destroy : array . delegate ( options . destroy ) } ; }
function parseSpec ( scopeDef , scopeReady ) { var promises = [ ] ; for ( var name in scopeDef ) { promises . push ( components [ name ] = defer ( ) ) ; } chain ( whenAll ( promises ) , scopeReady , components ) ; }
function ( hash ) { var self = this ; Ember . changeProperties ( function ( ) { for ( var prop in hash ) { if ( hash . hasOwnProperty ( prop ) ) set ( self , prop , hash [ prop ] ) ; } } ) ; return this ; }
function ( embed , embedReqStatus ) { $ ( '#rendered-tweets' ) . prepend ( embed . html ) ; if ( tweet . in_reply_to_status_id_str ) { $ . ajax ( { url : 'http://api.twitter.com/1/statuses/show/' + tweet . in_reply_to_status_id_str + '.json?' + 'trim_user=1' , success : loadConfabulatedTweets } ) ; } }
function ( ) { $ ( '#' + this ) . val ( '' ) ; }
function ( ) { $ . each ( [ 'bbox_map' , 'projection_map' , 'bbox_rubberband' , 'rotation' , 'projection' , 'pan' ] , function ( ) { $ ( '#' + this ) . val ( '' ) ; } ) ; Mappr . destroyRedo ( ) ; Mappr . showMap ( ) ; }
function ( e ) { e . preventDefault ( ) ; $ ( '#pan' ) . val ( $ ( this ) . attr ( "data-pan" ) ) ; self . resetJbbox ( ) ; self . showMap ( ) ; self . trackEvent ( 'arrows' , $ ( this ) . attr ( "data-pan" ) ) ; }
function LocalActHandler ( options ) { options = options || { } ; ActHandler . call ( this , options ) ; this . cloud = options . cloud || "./cloud/" ; this . main = options . main || "main.js" ; this . watch = options . watch !== undefined ? options . watch : true ; this . env = null ; this . legacy = false ; this . init ( ) ; if ( this . watch ) { this . listenTo ( this . cloud ) ; } }
function ( exists ) { if ( ! exists ) { if ( lookupIndex >= packages . length ) { cb && cb ( false ) ; } else { checkNextPath ( ) ; } } else if ( fs . statSync ( filename ) . isDirectory ( ) ) { uri += '/' + self . index ; lookupIndex -- ; checkNextPath ( ) ; } else { cb && cb ( true , filename ) ; } }
function ( comment ) { for ( var i = 0 ; i < comment . length ; ++ i ) { if ( comment [ i ] === this . tagMarker && comment [ i - 1 ] !== '\\' ) { break ; } } return comment . substring ( 0 , i ) ; }
function ( comment , pos ) { var tags = [ ] ; var regexp = /@(\S+)([^@]*)/g ; while ( match = regexp . exec ( comment ) ) { tags . push ( { name : match [ 1 ] , value : match [ 2 ] } ) ; } return tags ; }
function ( test , assert ) { conn . cql ( config [ 'select#cql' ] , function ( err , res ) { assert . ifError ( err ) ; assert . ok ( res . length === 1 ) ; assert . ok ( res [ 0 ] instanceof Helenus . Row ) ; assert . ok ( res [ 0 ] . get ( 'foo' ) . value === 'bar' ) ; test . finish ( ) ; } ) ; }
function ( test , assert ) { var select = "SELECT foo FROM cql_test WHERE KEY='?'" ; conn . cql ( select , [ "'foobar" ] , function ( err , res ) { assert . ifError ( err ) ; assert . ok ( res . length === 1 ) ; assert . ok ( res [ 0 ] instanceof Helenus . Row ) ; assert . ok ( res [ 0 ] . key === "'foobar" ) ; assert . ok ( res [ 0 ] . count === 0 ) ; test . finish ( ) ; } ) ; }
function ( test , assert , err , res ) { assert . ok ( res . length === 0 ) ; }
function ( node ) { var data = nodeData . get ( node , 'tooltip' ) ; if ( ! data ) { nodeData . set ( node , 'tooltip' , ( data = new Tooltip ( node , options ) ) ) } if ( lang . isString ( option ) ) { data [ option ] . call ( data ) ; } }
function ( option ) { var options = ( lang . isObject ( option ) ) ? option : { } ; return this . forEach ( function ( node ) { var data = nodeData . get ( node , 'tooltip' ) ; if ( ! data ) { nodeData . set ( node , 'tooltip' , ( data = new Tooltip ( node , options ) ) ) } if ( lang . isString ( option ) ) { data [ option ] . call ( data ) ; } } ) ; }
function ( err ) { if ( err ) { return cb2 ( err ) ; } ev . emit ( 'taskEnd' , s . name , s . value ) ; cb2 . apply ( null , args ) ; }
function ( ) { var args = Array . prototype . slice . call ( arguments ) ; tea . waitForWrites ( function ( err ) { if ( err ) { return cb2 ( err ) ; } ev . emit ( 'taskEnd' , s . name , s . value ) ; cb2 . apply ( null , args ) ; } ) ; }
function ( err ) { if ( err ) { return cb ( err ) ; } ncp ( path . resolve ( source ) , dest , cb ) ; }
function ( ) { mpd = new mpdSocket ( mpd_host , mpd_port ) ; mpd . on ( 'close' , function ( ) { mpdInit ( ) ; } ) ; mpd . on ( 'error' , function ( ) { setTimeout ( mpdInit , 10000 ) ; } ) ; }
function ( ) { var xhr ; try { xhr = new global . ActiveXObject ( "Msxml2.XMLHTTP" ) ; } catch ( ignore ) { try { xhr = new global . ActiveXObject ( "Microsoft.XMLHTTP" ) ; } catch ( ignored ) { throw new Error ( "pklib.ajax.load: cannot create XMLHttpRequest object" ) ; } } return xhr ; }
function ( settings , xhr ) { var header , headers = settings . headers ; if ( headers !== null ) { for ( header in headers ) { if ( headers . hasOwnProperty ( header ) ) { xhr . setRequestHeader ( header , headers [ header ] ) ; } } } }
function ( ) { strictEqual ( txt , "1" , msg ( "Data.txt" ) ) ; start ( ) ; }
function ( ) { json = eval ( "[" + json + "]" ) [ 0 ] ; strictEqual ( json . data , 1 , msg ( "Data.json" ) ) ; start ( ) ; }
function ( json ) { module ( "pklib.ajax" ) ; asyncTest ( "test_with_get_simple_json_file" , function ( ) { json = eval ( "[" + json + "]" ) [ 0 ] ; strictEqual ( json . data , 1 , msg ( "Data.json" ) ) ; start ( ) ; } ) ; }
function ( ) { var child = xml . getElementsByTagName ( "child" ) [ 0 ] , content = child . text || child . textContent ; strictEqual ( content , "data" , msg ( "Data.xml" ) ) ; start ( ) ; }
function ( ) { pklib . ajax . load ( { url : DIR + "data.xml" , timeout : 2000 , done : function ( xml ) { module ( "pklib.ajax" ) ; asyncTest ( "test_with_get_simple_xml" , function ( ) { var child = xml . getElementsByTagName ( "child" ) [ 0 ] , content = child . text || child . textContent ; strictEqual ( content , "data" , msg ( "Data.xml" ) ) ; start ( ) ; } ) ; } } ) ; }
function ( ) { notStrictEqual ( response . length , 0 , "Content length has no 0 size" ) ; start ( ) ; }
function ( ) { var started = 0 , xhr = pklib . ajax . load ( { url : "http://www.google.com/" , timeout : 2000 , done : function ( response ) { started = response ; } } ) ; pklib . ajax . stop ( xhr ) ; module ( "pklib.ajax" ) ; test ( "test_stopping_request" , function ( ) { ok ( pklib . object . is_object ( xhr ) , "Create XMLHTTPRequest" ) ; strictEqual ( started , 0 , "Request is aborting!" ) ; } ) ; }
function ( ) { ok ( pklib . object . is_object ( xhr ) , "Create XMLHTTPRequest" ) ; }
function ( ) { var xhr = pklib . ajax . load ( { url : "http://example.org/" , timeout : 2000 } ) ; module ( "pklib.ajax" ) ; test ( "test_timeout_request" , function ( ) { ok ( pklib . object . is_object ( xhr ) , "Create XMLHTTPRequest" ) ; } ) ; }
function ( ) { var error = 1 , xhr = pklib . ajax . load ( { url : "http://example.org/" , error : function ( ) { error = 1 ; } } ) ; module ( "pklib.ajax" ) ; test ( "test_error_request" , function ( ) { ok ( pklib . object . is_object ( xhr ) , "Create XMLHTTPRequest" ) ; strictEqual ( error , 1 , "Error request" ) ; } ) ; }
function ( ) { this . sequence = this . _shuffle ( this . options . questions ) ; this . results = { word2symbol : { correct : 0 , wrong : 0 , times : new Stat } , symbol2word : { correct : 0 , wrong : 0 , times : new Stat } } ; this . timer = new StopWatch ( ) ; return this . _renderNext ( ) ; }
function ( stage , panel , done ) { console . info ( 'autoForward' ) ; if ( ! Capkom . canClick ) { Capkom . timeout . start ( 2 , function ( ) { return Capkom . clickNext ( ) ; } ) ; } return _ . defer ( function ( ) { var d ; d = done . shift ( ) ; return typeof d === "function" ? d ( stage , panel , done ) : void 0 ; } ) ; }
function ( ) { this . sequence = this . _shuffle ( this . options . questions ) ; this . results = { word2symbol : { correct : 0 , wrong : 0 , times : new Stat } , symbol2word : { correct : 0 , wrong : 0 , times : new Stat } } ; this . timer = new StopWatch ( ) ; return this . _renderNext ( ) ; }
function ( ) { if ( self . model . get ( "userPrivate" ) . get ( "mostRecentIds" ) == undefined ) { Utils . debug ( "User does not have most recent ids, doing nothing." ) ; } else { var appids = self . model . get ( "userPrivate" ) . get ( "mostRecentIds" ) ; window . app . loadBackboneObjectsById ( couchConnection , appids ) ; } }
function addEmail ( callback ) { var email = helpers . getAndValidateEmail ( "#newEmail" ) , self = this ; if ( email ) { showHint ( "addressInfo" ) ; dialogHelpers . addEmail . call ( self , email , callback ) ; } else { complete ( callback , false ) ; } }
function updateResizeRect ( ) { var controlElm = dom . getParent ( selection . getNode ( ) , 'table,img' ) ; if ( controlElm ) { showResizeRect ( controlElm ) ; } else { hideResizeRect ( ) ; } }
function ( ) { return { tasks : { } , lists : { order : [ ] , items : { today : { order : [ ] , time : { order : 0 } } , next : { order : [ ] , time : { order : 0 } } , logbook : { order : [ ] , time : { order : 0 } } } , time : 0 } } }
function ( element , duration , onComplete ) { hui . animate ( { node : element , css : this . options . hidden , duration : duration , ease : hui . ease . slowFastSlow , onComplete : function ( ) { onComplete ( ) ; hui . style . set ( element , this . options . visible ) ; } . bind ( this ) } ) }
function ( type , listener ) { if ( ! this [ pname ] ) { defineProperty ( this , pname , d ( 'c' , { } ) ) ; } if ( ! this [ pname ] [ type ] ) { this [ pname ] [ type ] = defineProperty ( [ ] , 'copy' , d ( '' , copy ) ) ; } this [ pname ] [ type ] . push ( listener ) ; return this ; }
function ( ) { this . description = visualizedNode . prepareDescriptionForInput ( this . id ) ; this . node . mouseover ( ( function ( that ) { return function ( evt , x , y ) { view . tooltip . open ( visualizedNode . label + ": " + that . id , that . description , x , y , evt ) ; } ; } ) ( this ) ) . mouseout ( close ) ; }
function ( ) { if ( ! this . $el . hasClass ( 'activeOverlay' ) && this . $el . find ( '.overlay' ) . html ( ) . trim ( ) ) { this . $el . find ( '.overlay' ) . fadeIn ( 0 ) ; this . $el . addClass ( 'activeOverlay' ) ; } }
function ( filename ) { var me = this ; this . handle = logfile . init ( filename ) ; this . pid = process . fork ( ) ; if ( ! this . pid ) { while ( true ) { process . sleep ( 5 ) ; logfile . flush ( me . handle ) ; } } else { log ( 'Started logfile process ' + this . pid ) ; } }
function ( GLOBAL ) { var library = function ( ) { var sayHello = function ( name ) { alert ( "Hello, " + name ) ; } ; return { speakToMe : sayHello } ; } ( ) ; GLOBAL [ "library" ] = library ; }
function ( GLOBAL ) { var library = function ( ) { var sayHello = function ( name ) { alert ( "Hello, " + name ) ; } ; return { speakToMe : sayHello } ; } ( ) ; GLOBAL [ "library" ] = library ; }
function ( err , template ) { if ( err ) throw err template = jade . compile ( template ) var html = template ( { exports : sections [ 0 ] , types : sections [ 1 ] , extensions : sections [ 2 ] , package : require ( '../package.json' ) } ) fs . writeFile ( __dirname + '/index.html' , html , function ( err ) { if ( err ) throw err } ) }
function maybeSet ( vv ) { LOG ( "maybeSet: " + vv ) ; if ( vv . lastMaybeChanged === timestamp ) return ; vv . lastMaybeChanged = timestamp ; var mm = vv . writtenBy ; if ( mm ) { LOG ( vv + " written by " + mm ) ; ASSERT ( mm . outputs . has ( vv ) , vv + " not actually written by " + mm ) ; maybeExecute ( mm ) ; } else { set ( vv ) ; } }
function ( mm ) { if ( mm . outputs . length >= mmNumOutputs ) return ; var isAllFree = mm . outputs . every ( function ( ww ) { return ww . inner . isFree ( ) ; } , this ) ; if ( isAllFree ) { mmSelected = mm ; mmNumOutputs = mm . outputs . length ; } }
function ( ) { var index , children = get ( "children" ) ; $ ( window ) . off ( "storage.socket" ) ; if ( children ) { index = $ . inArray ( request . id , children ) ; if ( index > - 1 ) { children . splice ( index , 1 ) ; set ( "children" , children ) ; } } }
function listener ( string ) { var command = $ . parseJSON ( string ) , data = command . data ; if ( command . target === "p" ) { switch ( command . type ) { case "send" : _push ( data ) ; break ; case "close" : _close ( ) ; break ; } } }
function _prepareCallback ( messageBody , state , errorCode , transport ) { if ( state == "messageReceived" ) { if ( _trackMessageSize ( messageBody , _request , _response ) ) return ; } _response . transport = transport ; _response . status = errorCode ; if ( _response . expectedBodySize == - 1 ) { _response . responseBody = messageBody ; } _response . state = state ; _invokeCallback ( ) ; }
function ( ) { $ . htmlhistory . init ( { useHistory : true , useHashchange : true , poll : 250 , interceptLinks : true , disableHashLinks : true , hash : '#!' } ) ; $ ( window ) . bind ( 'htmlhistory' , onURL ) ; }
function ( path ) { var $win = $ ( window ) ; if ( his . options . useHistory && his . supportsHistory ( ) ) { window . history . pushState ( null , null , path ) ; $win . trigger ( evt ) ; } else { if ( path . indexOf ( "#" ) < 0 ) { path = his . options . hash + path ; } window . location . href = path ; } }
function ( row ) { baidu . dom . addClass ( row , "hover" ) ; }
function ( ) { baidu . dom . remove ( g . getBody ( ) ) ; baidu . lang . Class . prototype . dispose . call ( g ) ; }
function rmdir ( path , options , callback ) { if ( ! checkType ( [ "path" , path , "string" , "options" , options , "object" , ] , callback ) ) return ; if ( options . recursive ) { remove ( path , function ( path , callback ) { exec ( "rm" , { args : [ "-rf" , path ] } , callback ) ; } , callback ) ; } else { remove ( path , fs . rmdir , callback ) ; } }
function watchFile ( path , options , callback ) { if ( ! checkType ( [ "path" , path , "string" , "options" , options , "object" ] , callback ) ) return ; var meta = { } ; realpath ( path , function ( err , path ) { if ( err ) return callback ( err ) ; meta . watcher = fs . watchFile ( path , options , function ( curr , prev ) { } ) ; callback ( null , meta ) ; } ) ; }
function broken ( name , selector ) { try { jQuery ( selector ) ; ok ( false , name + ": " + selector ) ; } catch ( e ) { ok ( typeof e === "string" && e . indexOf ( "Syntax error" ) >= 0 , name + ": " + selector ) ; } }
function ( i ) { facebookContent . push ( [ 'div.option' , [ 'input' , { type : 'checkbox' , name : $ ( this ) . attr ( 'name' ) , id : $ ( this ) . attr ( 'name' ) , checked : $ ( this ) . attr ( 'checked' ) } ] , [ 'label' , { for : $ ( this ) . attr ( 'name' ) } , facebookLabels [ i ] ] ] ) }
function ( a , b ) { var user = b ; if ( ! $this . listeners . get ( user . userid ) ) { clearInterval ( a . timer ) ; return ; } var idletime = moment ( ) . diff ( moment ( $this . listeners . get ( user . userid ) . get ( 'lastActivity' ) ) , 'seconds' ) ; $ ( a ) . find ( 'div.idleTime' ) . html ( formatIdletime ( idletime ) ) }
function ( ) { $ ( this ) . find ( "div.guestArrow" ) . hide ( ) ; $ ( this ) . find ( 'div.icons' ) . css ( { opacity : 1 } ) ; $ ( this ) . find ( 'div.idleTime' ) . html ( '' ) clearInterval ( this . timer ) }
function ( a ) { $this . currentSong . snag ( a ) ; }
function ( i , el ) { var t = el . tagName . toLowerCase ( ) ; if ( t != 'script' && el . id != 'chart' && ! $ ( el ) . hasClass ( 'tooltip' ) ) { ch += $ ( el ) . height ( ) ; } }
function ( el ) { var ch = 0 ; $ ( 'body *' ) . each ( function ( i , el ) { var t = el . tagName . toLowerCase ( ) ; if ( t != 'script' && el . id != 'chart' && ! $ ( el ) . hasClass ( 'tooltip' ) ) { ch += $ ( el ) . height ( ) ; } } ) ; return $ ( window ) . height ( ) - ch - 30 ; }
function ( options ) { this . options = options ; }
function ( ) { it ( 'should only have dev variables' , function ( done ) { compiler . compile ( TestHelper . jsRoot + "/config.json" , TestHelper . fixture ( "/js/config.json" ) , function ( err , data ) { should . not . exist ( err ) ; data . should . include ( 'def' ) ; done ( ) ; } ) ; } ) ; }
function ( collection , callback ) { collection . find ( { $or : [ { _id : new ObjectID ( id ) } , { parentID : new ObjectID ( id ) } , { parents : id } ] } , { } , callback ) ; }
function ( rootThread , arrayDocs ) { var self = this ; async . forEach ( arrayDocs , function ( item , callback ) { if ( item . parentID && item . parentID . toString ( ) == rootThread . id ) { var thread = new t . Thread ( ) ; thread . setFromDoc ( item ) ; thread = self . buildTree ( thread , arrayDocs ) ; rootThread . addChild ( thread ) ; } callback ( ) ; } , function ( error ) { return rootThread ; } ) ; }
function createModel ( geometry ) { var material = new THREE . MeshBasicMaterial ( { map : THREE . ImageUtils . loadTexture ( 'assets/textures/cardboard-512.jpg' ) , doubleSided : false , color : 0xffffff } ) ; model = new THREE . Mesh ( geometry , material ) ; scene . add ( model ) ; }
function ( e ) { var target , _ref ; target = e . target || e . srcElement ; if ( target !== itembox && __indexOf . call ( itembox . getElementsByTagName ( 'ul' ) , target ) < 0 && __indexOf . call ( itembox . childNodes , target ) < 0 && ( ( _ref = target . tagName ) !== 'LI' && _ref !== 'A' && _ref !== 'INPUT' && _ref !== 'SELECT' ) ) { return itembox . style . display = 'none' ; } }
function ( element ) { this . element = element ; this . titleNode = this . getTitleNode ( ) ; if ( this . titleNode === null ) { this . cslId = - 1 ; } else { this . cslId = this . titleNode . cslId ; } this . displayTitle ( ) ; }
function ( ) { var title ; if ( this . titleNode === null ) { title = "No title" ; } else { title = this . titleNode . textValue ; } this . element . html ( '<h3><span cslid=' + this . cslId + '>' + title + '</span></h3>' ) ; }
function ( id , position , node , numAdded ) { if ( this . cslId > - 1 ) { return ; } this . titleNode = this . getTitleNode ( ) ; if ( this . titleNode !== null ) { this . cslId = this . titleNode . cslId ; this . displayTitle ( ) ; } }
function ( ) { var o = false ; for ( var i = 0 , l = RequestObj . length ; i < l ; i ++ ) { try { o = RequestObj [ i ] ( ) ; } catch ( e ) { continue ; } } return o ; }
function ( dataString ) { var index = dataString . indexOf ( this . versionSearchString ) ; if ( index == - 1 ) return ; var str = dataString . substring ( index + this . versionSearchString . length + 1 ) . split ( ' ' , 1 ) . pop ( ) ; return str . split ( '.' , 2 ) . join ( '.' ) ; }
function switchToPreviousPath ( ) { var currentPathID = getPathIdByIndex ( activePathIndex ) , previousIndex = getPreviousPathIndex ( ) , previousPathID = getPathIdByIndex ( previousIndex ) ; if ( currentPathID != previousPathID ) { $ ( "#" + currentPathID ) . fadeOut ( "slow" , function ( ) { $ ( "#" + previousPathID ) . fadeIn ( "slow" ) ; jsPlumb . repaintEverything ( ) ; } ) ; activePathIndex = previousIndex ; } }
function ( ) { $ ( "#" + nextPathID ) . fadeIn ( "slow" ) ; jsPlumb . repaintEverything ( ) ; }
function ( e ) { if ( that . visible && ! ( e . target === that . get ( 'target' ) [ 0 ] || jQuery . contains ( that . get ( 'target' ) [ 0 ] , e . target ) ) ) { debugger ; that . hide ( ) ; } }
function ( ) { this . keys_ = { } ; goog . events . listen ( window , goog . events . EventType . KEYDOWN , goog . bind ( this . keyPressed_ , this ) ) ; goog . events . listen ( window , goog . events . EventType . KEYUP , goog . bind ( this . keyReleased_ , this ) ) ; }
function ( ) { var panelName = WebInspector . inspectorView . currentPanel ( ) && WebInspector . inspectorView . currentPanel ( ) . toolbarItemLabel ; if ( ! panelName ) return ; var newLabel = WebInspector . UIString ( "Search %s" , panelName ) ; this . element . setAttribute ( "placeholder" , newLabel ) ; }
function ( visible ) { if ( visible ) this . _searchItemElement . addStyleClass ( "with-navigation-buttons" ) ; else this . _searchItemElement . removeStyleClass ( "with-navigation-buttons" ) ; }
function ( x ) { var body = document . body ; if ( x ) body . addStyleClass ( "compact" ) ; else body . removeStyleClass ( "compact" ) ; if ( WebInspector . toolbar ) WebInspector . toolbar . compact = x ; if ( WebInspector . searchController ) WebInspector . searchController . updateSearchLabel ( ) ; if ( WebInspector . drawer ) WebInspector . drawer . resize ( ) ; }
function ( event ) { if ( event . handled ) return ; if ( event . keyIdentifier === "U+001B" ) { if ( ! this . _toggleConsoleButton . toggled && WebInspector . drawer . visible ) this . closeViewInDrawer ( ) ; else this . _toggleConsoleButtonClicked ( ) ; } }
function ( data ) { if ( data && data . indexOf ( "<strong>Module Information</strong>" ) != - 1 ) { _ripper . getModule ( $ ( data ) ) ; NUSchedule . signals . send ( "on_module_rip_success" , index ) ; } else { NUSchedule . signals . send ( "on_module_rip_error" , index ) ; } _ripper . ripNext ( ) ; }
function ( ) { var applet = document . getElementById ( "inferenceApplet" + this . id ) ; if ( this . food . length ) { var ret = applet . feed ( bugfixParam ( decodeString ( this . food ) ) ) ; myLogger . Log ( this . name + " feed: " + ret ) ; } ; }
function ( ) { var applet = document . getElementById ( "inferenceApplet" + this . id ) ; if ( this . food . length ) { var ret = applet . feed ( bugfixParam ( decodeString ( this . food ) ) ) ; myLogger . Log ( this . name + " feed: " + ret ) ; } ; }
function doesOperate ( ) { if ( logletBaseURL ) { if ( getServer ( logId , docId + "+" + name , logletBaseURL + "operates.php" ) == "okay" ) { return true ; } } return false ; }
function doesOperate ( ) { if ( logletBaseURL ) { if ( getServer ( logId , docId + "+" + name , logletBaseURL + "operates.php" ) == "okay" ) { return true ; } } return false ; }
function ( ) { var applet = document . getElementById ( "inferenceApplet" + this . id ) ; if ( this . food . length ) { var ret = applet . feed ( bugfixParam ( decodeString ( this . food ) ) ) ; myLogger . Log ( this . name + " feed: " + ret ) ; } ; }
function doesOperate ( ) { if ( logletBaseURL ) { if ( getServer ( logId , docId + "+" + name , logletBaseURL + "operates.php" ) == "okay" ) { return true ; } } return false ; }
function ( x , y , z ) { this . locX = parseFloat ( x ) ; this . locY = parseFloat ( y ) ; this . locZ = parseFloat ( z ) ; this . translateMatrix = null ; this . staticMatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { this . dLocX = parseFloat ( x ) ; this . dLocY = parseFloat ( y ) ; this . dLocZ = parseFloat ( z ) ; this . translateMatrix = null ; this . staticMatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z , w ) { this . mode = GLGE . P_QUAT ; this . quatX = parseFloat ( x ) ; this . quatY = parseFloat ( y ) ; this . quatZ = parseFloat ( z ) ; this . quatW = parseFloat ( w ) ; this . staticMatrix = null ; this . rotmatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { this . mode = GLGE . P_EULER ; this . rotX = parseFloat ( x ) ; this . rotY = parseFloat ( y ) ; this . rotZ = parseFloat ( z ) ; this . staticMatrix = null ; this . rotmatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { this . mode = GLGE . P_EULER ; this . dRotX = parseFloat ( x ) ; this . dRotY = parseFloat ( y ) ; this . dRotZ = parseFloat ( z ) ; this . staticMatrix = null ; this . rotmatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { if ( ! y ) { y = x ; z = x } ; this . scaleX = parseFloat ( x ) ; this . scaleY = parseFloat ( y ) ; this . scaleZ = parseFloat ( z ) ; this . staticMatrix = null ; this . scaleMatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { this . dScaleX = parseFloat ( x ) ; this . dScaleY = parseFloat ( y ) ; this . dScaleZ = parseFloat ( z ) ; this . staticMatrix == null ; this . scaleMatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( r ) { me . savingflag = false ; if ( user == 'Guest' && ! r . exc ) { $dh ( me . page_layout . wrapper ) ; $ds ( me . saved_wrapper ) ; me . saved_wrapper . innerHTML = '<div style="padding: 150px 16px; text-align: center; font-size: 14px;">' + ( cur_frm . message_after_save ? cur_frm . message_after_save : 'Your information has been sent. Thank you!' ) + '</div>' ; return ; } if ( ! me . meta . istable ) { me . refresh ( r . docname ) ; } if ( call_back ) { call_back ( r ) ; } }
function ( ev ) { data . push ( [ name + '-filename' , file . name ] ) data . push ( [ name + '-mimetype' , file . type ] ) data . push ( [ name , reader . result ] ) fidx += 1 if ( fidx < files . length ) { process_file ( files ) } else { process_files ( ) } }
function ( str , x , y ) { var state = this . state ( ) ; x += state . translateX ; y += state . translateY ; this . applyForegroundFillStyle ( ) ; this . moveTo ( x , y ) ; this . write ( str ) ; }
function ( ) { var tone_table = [ "C" , "C#" , "D" , "D#" , "E" , "F" , "F#" , "G" , "G#" , "A" , "A#" , "B" ] ; return function ( a ) { var i = ( a | 0 ) % 12 ; var j = ( a | 0 ) / 12 ; return tone_table [ i ] + ( ( j | 0 ) - 2 ) ; } ; }
function ( a ) { var m , result = 0 ; if ( ( m = a . match ( re ) ) !== null ) { result = map [ m [ 1 ] ] ; switch ( m [ 2 ] ) { case "+" : case "#" : ++ result ; break ; case "-" : case "b" : -- result ; break ; } result += 12 * ( ( m [ 3 ] | 0 ) + 2 ) ; } return result ; }
function ( words ) { var i , sent = "" , tokens = tokenizer . tokenize ( query ) ; for ( i in tokens ) { var candidates = dict . testing ( tokens [ i ] , words ) ; console . log ( hi_find ( candidates ) ) ; sent += " " + hi_find ( candidates ) ; } var tmp = sent . tokenizeAndStem ( ) ; callback ( tmp . join ( ' ' ) ) ; }
function load ( url , content , type , line ) { if ( panel_window ) { panel_window . purple . showContent ( url , content , type ) ; panel_window . purple . setCursorOn ( url , line || 1 , 1 ) ; } else { buffer = Array . prototype . slice . apply ( arguments ) ; console . log ( 'buffering load' , buffer ) ; } }
function ( ) { socket . write ( getFlashPolicy ( ) + '\0' ) ; }
function ( clientIndex , serverIndex ) { NSPR . lib . PR_Close ( this . connections [ clientIndex ] ) ; NSPR . lib . PR_Close ( this . connections [ serverIndex ] ) ; this . connections . splice ( clientIndex , 2 ) ; return this . initializeDescriptors ( ) ; }
function ( name , handler ) { name = name . toLowerCase ( ) ; handler = handler [ 'MEHL' ] ; return eachlist ( function ( el ) { if ( el . addEventListener ) el . removeEventListener ( name , handler , true ) ; else el . detachEvent ( 'on' + name , handler ) ; } ) ; }
function ( msg ) { var m ; var found = false ; if ( m = msg . match ( /^SEEK_CANCELED (\d+)$/ ) ) { C4 . debug ( msg ) ; var seekId = + m [ 1 ] ; C4 . remove_my_seek ( seekId ) ; found = true ; } else if ( msg . match ( /^NO_SEEK_FOUND (\d+)$/ ) ) { C4 . debug ( msg ) ; found = true ; } ; if ( found ) C4 . remove_handler ( C4 . cb_cancel_seek ) ; return found ; }
function ( ) { jQuery ( "#wCart_shipping_form2" ) . validate ( { rules : { semail : { required : true , email : true } , sphone : { required : true , number : true } , scity : "mustselect" , sname : "required" , saddress : "required" , spaymentmethod : "required" , spostalcode : "required" } } ) ; }
function ( source , nodes , copy , target ) { if ( target !== this . trackListWidget ) return ; var confs = dojo . filter ( dojo . map ( nodes , function ( n ) { return n . track && n . track . config ; } ) , function ( c ) { return c ; } ) ; if ( ! confs . length ) return ; this . dndDrop = true ; dojo . publish ( '/jbrowse/v1/v/tracks/hide' , [ confs ] ) ; this . dndDrop = false ; }
function ( dx , dy ) { if ( x > - 1 && x < 32 && y > - 1 && y < 32 ) { var tileType = dd . levelMap [ y + dy ] [ x + dx ] ; var tile = dd . tiles [ find_in_array ( dd . tiles , 'id' , tileType ) ] ; if ( ! tile [ 'solid' ] ) { spriteGrid [ x ] [ y ] = null ; x += dx ; y += dy ; } } }
function ( appType , request , response ) { var commentId = request . params . uid ; var direction = request . params . dir ; if ( request . method === "PUT" ) { queryES . updateIsAnswered ( commentId , appType , function ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 } ) ) ; } ) ; } }
function ( cb ) { var ticks = 5 ; var checkReady = function ( ) { process . nextTick ( function ( ) { if ( platform . ready ) { fixupDns ( cb ) ; } else { ticks -= 1 ; if ( ticks > 0 ) checkReady ( ) ; } } ) } if ( platform . ready ) fixupDns ( cb ) ; else checkReady ( ) ; }
function ( template ) { var $template = $ ( $ . trim ( template ) ) ; var $header = this . make ( 'div' , { "class" : 'NB-story-comments-public-header-wrapper' } , this . make ( 'div' , { "class" : 'NB-story-comments-public-header' } , Inflector . pluralize ( ' public comment' , $template . length , true ) ) ) ; this . $ ( ".NB-story-comments-public-teaser-wrapper" ) . replaceWith ( $template ) ; $template . before ( $header ) ; }
function ( data ) { comparison_grid . set_columns ( env_select . get_paths ( ) ) ; select_envs ( get_initial_environments ( ) ) ; comparison_grid . set_title ( data . name ) ; draw_grid ( data . rows ) ; cache . save_state ( comparison_grid , search_params ) ; }
function ( ) { var options = this . data ( ) ; if ( options [ 'logarithmic' ] == 1 ) options [ 'logarithmic' ] = 0 ; else options [ 'logarithmic' ] = 1 ; this . data ( options ) ; return this ; }
function ( options ) { $ ( "#terminal-input" ) . keypress ( this . handleKey ) ; $ ( "#terminal-input" ) . keydown ( this . handleKeyDown ) ; }
function ( e ) { var key = e . keyCode ; if ( key == 8 || key == 9 ) { var msg = { "type" : "terminal" , "command" : "keyEvent" , "value" : key } ; IDE . htwg . websocket . sendMessage ( msg ) ; } ; }
function ( canvas ) { this . canvas = canvas ; this . registerCommonEvents ( ) ; if ( TissueStack . desktop || TissueStack . debug ) { this . registerDesktopEvents ( ) ; } if ( TissueStack . tablet || TissueStack . phone ) { this . registerMobileEvents ( ) ; } }
function ( json ) { var jr = jQuery . parseJSON ( json ) ; if ( jr . error !== undefined ) { var row = $ ( "<tr/>" ) . append ( '<td>' + file . name + '</td>' ) . append ( '<td>' + jr . error . message + '</td>' ) ; $ ( "#plupload_error" ) . find ( "table" ) . append ( row ) ; } }
function send ( topic , buf , enc ) { assert . ok ( isString ( topic ) ) if ( isString ( buf ) ) { buf = new Buffer ( buf , enc ) } assert . ok ( Buffer . isBuffer ( buf ) ) var strBuf = new Buffer ( topic , 'utf8' ) , hdrBuf = new Buffer ( 2 ) hdrBuf . writeUInt16BE ( strBuf . length , 0 ) this . frap . send ( hdrBuf , strBuf , buf ) }
function WFrameStream__destroy ( ) { if ( this . isdestroyed ) return this . isdestroyed = true this . close ( ) delete this . frap }
function ( manager ) { this . base ( arguments ) ; this . __manager = manager ; this . __elements = { } ; this . __timer = new qx . event . Timer ( 200 ) ; this . __timer . addListener ( "interval" , this . _onInterval , this ) ; }
function ( queryTuple , queryMotifRegistry ) { var meta = this . lookup ( queryTuple ) , memoryQuery = meta . query ; if ( memoryQuery ) return memoryQuery ; var queryJson = queryMotifRegistry . queryJSON ( queryTuple ) ; if ( ! queryJson . type ) queryJson . type = 'find' ; return meta . query = new MemoryQuery ( queryJson ) ; }
function ( key , building ) { if ( building != null ) { console . log ( building . id == buildingID ) ; if ( building . id == buildingID ) return true ; } }
function ( ) { var _self = this , events = _self . get ( 'events' ) ; S . each ( events , function ( event ) { _self . publish ( event , { bubbles : 1 } ) ; } ) ; _self . addTarget ( _self . get ( 'parent' ) ) ; }
function ( ) { var _self = this , parent = _self . get ( 'parent' ) , events = _self . get ( 'events' ) ; if ( ! parent ) { return ; } S . each ( events , function ( event ) { _self . publish ( event , { bubbles : 1 } ) ; } ) ; _self . addTarget ( parent ) ; }
function create ( component , self ) { var childConstructor , xclass ; if ( component && ( xclass = component . xclass ) ) { if ( self && ! component . prefixCls ) { component . prefixCls = self . get ( "prefixCls" ) ; } childConstructor = Manager . getConstructorByXClass ( xclass ) ; component = new childConstructor ( component ) ; } return component ; }
function initChild ( self , c , elBefore ) { self . create ( ) ; var contentEl = self . getContentElement ( ) ; c = Component . create ( c , self ) ; c . __set ( "parent" , self ) ; c . set ( "render" , contentEl ) ; c . set ( "elBefore" , elBefore ) ; c . create ( undefined ) ; return c ; }
function ( ) { var self = this , view = self . get ( "view" ) ; setViewCssClassByHierarchy ( self , view ) ; view . create ( ) ; var el = view . getKeyEventTarget ( ) ; if ( self . get ( "focusable" ) ) { el . attr ( "tabIndex" , 0 ) ; } else { el . unselectable ( undefined ) ; } self . __set ( "view" , view ) ; }
function ( ) { var self = this , i , children , child ; self . get ( "view" ) . render ( ) ; children = self . get ( "children" ) ; for ( i = 0 ; i < children . length ; i ++ ) { child = children [ i ] ; child = initChild ( self , child ) ; children [ i ] = child ; child . render ( ) ; self . fire ( "addChild" , { child : child } ) ; } }
function ( ) { var self = this ; if ( ! self . get ( "srcNode" ) ) { var render = self . get ( "render" ) , el = self . get ( "el" ) , elBefore = self . get ( "elBefore" ) ; if ( elBefore ) { el . insertBefore ( elBefore , undefined ) ; } else if ( render ) { el . appendTo ( render , undefined ) ; } else { el . appendTo ( doc . body , undefined ) ; } } }
function ( ) { var Ext = this . global . Ext ; return Ext . create ( 'Admin.model.account.AccountModel' , { 'key' : '04D3731B72BFF823BCF0C00604ED8FA85E7B7D69' , 'name' : 'jsi' , 'email' : 'jsi@enonic.com' , 'qualifiedName' : 'enonic\\jsi' , 'displayName' : 'J�rgen Sivesind' , 'userStore' : 'enonic' , 'lastModified' : '2009-11-05 10:50:04' , 'hasPhoto' : true , 'type' : 'user' , 'builtIn' : false , 'isEditable' : true } ) ; }
function ( error , data ) { if ( error ) { var msg = "ERROR: " + sys . inspect ( error ) ; sys . debug ( msg ) response . write ( "<pre>" + msg + "</pre>" , "utf8" ) } else { response . write ( haml . render ( data ) , "utf8" ) } response . end ( ) }
function ( ) { Ext . create ( 'CatHerder.view.Main' , { fullscreen : true } ) ; var item = Ext . ModelManager . getModel ( 'CatHerder.model.Item' ) ; item . load ( 1 , { success : function ( record ) { console . log ( 'Loaded: %o' , record ) ; record . getCategory ( function ( category ) { console . log ( 'Category: %o' , category ) ; } ) ; } } ) ; }
function ( ) { if ( $ ( "#observationFlaggedButton" ) . hasClass ( 'active' ) ) { return false ; } $ ( "#observationFlagFilter" ) . val ( 'true' ) $ ( "#observationWithNoFlagFilterButton" ) . removeClass ( 'active' ) $ ( "#observationFlaggedButton" ) . addClass ( 'active' ) updateGallery ( undefined , window . params . queryParamsMax , 0 ) ; return false ; }
function ( ) { if ( $ ( "#observationWithNoFlagFilterButton" ) . hasClass ( 'active' ) ) { return false ; } $ ( "#observationFlagFilter" ) . val ( 'false' ) $ ( "#observationFlaggedButton" ) . removeClass ( 'active' ) $ ( "#observationWithNoFlagFilterButton" ) . addClass ( 'active' ) updateGallery ( undefined , window . params . queryParamsMax , 0 ) ; return false ; }
function ( ) { if ( $ ( "#speciesNameAllButton" ) . hasClass ( 'active' ) ) { return false ; } $ ( "#speciesNameFilter" ) . val ( 'All' ) $ ( "#speciesNameFilterButton" ) . removeClass ( 'active' ) $ ( "#speciesNameAllButton" ) . addClass ( 'active' ) updateGallery ( undefined , window . params . queryParamsMax , 0 ) ; return false ; }
function ( ) { if ( $ ( "#speciesNameFilterButton" ) . hasClass ( 'active' ) ) { return false ; } $ ( "#speciesNameFilter" ) . val ( 'Unknown' ) $ ( "#speciesNameFilterButton" ) . addClass ( 'active' ) $ ( "#speciesNameAllButton" ) . removeClass ( 'active' ) updateGallery ( undefined , window . params . queryParamsMax , 0 ) ; return false ; }
function ( ) { if ( $ ( this ) . hasClass ( 'active' ) ) { return false ; } $ ( '#speciesGroupFilter button.active' ) . removeClass ( 'active' ) ; $ ( this ) . addClass ( 'active' ) ; updateGallery ( undefined , window . params . queryParamsMax , 0 ) ; return false ; }
function ( ) { if ( $ ( this ) . hasClass ( 'active' ) ) { return false ; } $ ( '#habitatFilter button.active' ) . removeClass ( 'active' ) ; $ ( this ) . addClass ( 'active' ) ; updateGallery ( undefined , window . params . queryParamsMax , 0 ) ; return false ; }
function ( ) { setActiveTag ( $ ( this ) . contents ( ) . first ( ) . text ( ) ) ; updateGallery ( undefined , undefined , 0 ) ; return false ; }
function ( ) { setActiveTag ( $ ( this ) . contents ( ) . first ( ) . text ( ) ) ; updateGallery ( undefined , undefined , 0 ) ; return false ; }
function ( ) { var oldActiveTag = $ ( "li.tagit-choice.active" ) ; if ( oldActiveTag ) { oldActiveTag . removeClass ( 'active' ) ; } var oldActiveTag = $ ( "#tc_tagcloud a.active" ) ; if ( oldActiveTag ) { oldActiveTag . removeClass ( 'active' ) ; } updateGallery ( undefined , undefined , 0 ) ; return false ; }
function soundManager_observe ( value ) { self . currentVolume = value * 10 ; }
function ( feature ) { var feature_ = new komoo . features . Feature ( ) ; var geometry = komoo . geometries . makeGeometry ( feature ) ; feature_ . setProperties ( feature . properties ) ; feature_ . setGeometry ( geometry ) ; return feature_ ; }
function ( opts ) { var options = opts || { clickable : true , zIndex : this . getDefaultZIndex ( ) , strokeColor : this . getBorderColor ( ) , strockOpacity : this . getBorderOpacity ( ) , strokeWeight : this . getBorderSize ( ) } ; this . object_ = new google . maps . Polyline ( options ) ; }
function ( opts ) { var options = opts || { clickable : true , zIndex : this . getDefaultZIndex ( ) , fillColor : this . getBackgroundColor ( ) , fillOpacity : this . getBackgroundOpacity ( ) , strokeColor : this . getBorderColor ( ) , strockOpacity : this . getBorderOpacity ( ) , strokeWeight : this . getBorderSize ( ) } ; this . object_ = new google . maps . Polygon ( options ) ; }
function ( ) { self . level ++ ; var levelCookie = self . getCookie ( 'level' ) ; if ( ! levelCookie || parseInt ( levelCookie ) < self . level ) self . setCookie ( 'level' , self . level . toString ( ) ) ; self . addLevelToSelect ( ) ; }
function performSearch ( ) { alert ( "searching" ) ; var params = { term : ( jQuery ( '#entry_1' ) . val ( ) ) , country : 'GB' , media : 'music' , entity : 'song' , limit : 1 , callback : 'handleTunesSearchResults' } ; var params = urlEncode ( params ) ; var url = 'http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/wa/wsSearch?' + params ; var html = '<script src="' + url + '"><\/script>' ; jQuery ( 'head' ) . append ( html ) ; }
function handleProxyIDP ( ) { var proxyIDPs = config . get ( 'proxy_idps' ) ; if ( proxyIDPs . hasOwnProperty ( domain ) ) { var generatedBody = JSON . stringify ( { authority : proxyIDPs [ domain ] } ) ; cb ( null , generatedBody , domain , delegates ) ; } else { cb ( null , false , null ) ; } }
function ( start , end ) { this . _destinationRegion = end ; var path = NavigationManager . GetInterRegionPathFinder ( ) . FindPath ( start , end ) ; this . _marchingPath = [ ] ; for ( var i = 1 ; i < path . length ; i ++ ) { var region = path [ i ] ; this . _marchingPath . push ( region . Center ) ; } if ( this . _marchingPath . length > 0 ) this . IsActive = true ; }
function ( ) { this . _isNavigationPaused = true ; this . StopMoving ( ) ; }
function ( world ) { this . _world = world ; this . _pathFinders . length = 0 ; this . Semantics = new WorldPathSemantics ( world ) ; this . _interRegionPathFinder = new PathFinder ( new InterRegionPathSemantics ( world ) ) ; this . _pathFinder = new PathFinder ( null ) ; this . _semanticsLoc = new WorldPathSemantics_ToLocation ( world ) ; this . _semanticsTargetTouch = new WorldPathSemantics_ToTargetTouch ( world ) ; this . _semanticsTargetRanged = new WorldPathSemantics_ToTargetRanged ( world ) ; }
function ( from , to ) { var semantics = null ; if ( to . target ) { semantics = to . radius > 0 ? this . _semanticsTargetRanged : this . _semanticsTargetTouch ; } else { semantics = this . _semanticsLoc ; } this . _pathFinder . Semantics = semantics ; return this . _pathFinder . FindPath ( from , to ) ; }
function ( ) { loops = 0 ; this . curTime = Date . now ( ) ; if ( this . curTime - nextGameTick > 60 * milliSecPerFrame ) { nextGameTick = this . curTime - milliSecPerFrame ; } while ( this . curTime > nextGameTick ) { Crafty . trigger ( "EnterFrame" , { frame : frame ++ } ) ; nextGameTick += milliSecPerFrame ; loops ++ ; } if ( loops ) { Crafty . DrawManager . draw ( ) ; } }
function ( ) { var world = new World ( ) ; var playerSpawnPoint = world . GetSpawnPoint ( 0 ) ; var player = new Player ( ) . Appear ( world , playerSpawnPoint . x , playerSpawnPoint . y ) ; gameContainer . cheat = new Cheat ( player ) ; console . log ( "START MAIN SCENE: player = " , player ) ; }
function ( that ) { that . getRelatedMedia ( ) ; that . globalEvents . events . relationsUpdated . addListener ( function ( related ) { if ( related !== "media" ) { return ; } that . getRelatedMedia ( ) ; } ) ; }
function ( msgFromAlert ) { if ( msgFromAlert === scriptUrl ) { onScriptLoaded ( scriptUrl ) ; try { this . javaScriptAlertSent . disconnect ( arguments . callee ) ; } catch ( e ) { } } }
function ( private_gameid ) { this . id = Game . new_id ( ) ; this . private_gameid = private_gameid ; this . player_limit = 8 ; this . time_limit = 10 ; this . tile_recharge = 2.0 ; this . readyTimeout = null ; this . round_timeout = null ; this . round_started = false ; this . board = new board . Board ( ) ; this . players = [ ] ; this . trails = [ ] ; }
function ( tileCanvas , effectCanvas ) { this . tileContext = tileCanvas . getContext ( '2d' ) ; this . effectContext = effectCanvas . getContext ( '2d' ) ; this . emptyTile = new Image ( ) ; this . emptyTile . src = '/img/' + Globals . theme + '/empty.png' ; return this ; }
function ( camel , id ) { if ( this . hasOwn . call ( this . identifiers , camel ) && this . identifiers [ camel ] !== id ) { throw new ReferenceError ( "Inconsistent use of " + camel + " as " + id ) ; } else { return this . identifiers [ camel ] = id ; } }
function ( s ) { var token = forth . source . readToken ( ) ; if ( token == null ) { forth . running = false ; return ; } try { forth . runToken ( token ) ; } catch ( err ) { forth . running = false ; for ( var i = 0 ; i < forth . callStack . length ; i ++ ) err += '\nin ' + forth . callStack . pop ( ) . name ; throw err ; } }
function ( e ) { e . preventDefault ( ) ; reset ( ) ; setup ( ) ; $ ( this ) . blur ( ) ; } ) . resizable ( { aspectRatio : true }
function ( x , attr ) { if ( jQuery . isPlainObject ( attr ) ) { if ( attr . selected == '' ) { $ ( '#' + i ) . append ( '<option value=\'' + attr . value + '\'  >' + attr . text + '</option>' ) ; } else { $ ( '#' + i ) . append ( '<option value=\'' + attr . value + '\' selected=\'selected\' >' + attr . text + '</option>' ) ; } } else { $ ( '#' + i ) . attr ( x , attr ) ; } }
function ( ) { reset ( ) ; setup ( ) ; page_size ( ) ; }
function getImage ( makeSubList , c ) { var imageLi = document . createElement ( 'li' ) ; makeSubList . appendChild ( imageLi ) ; var newImg = document . createElement ( 'img' ) ; newImg . setAttribute ( "src" , "images/" + c + ".png" ) imageLi . appendChild ( newImg ) ; }
function ( result ) { if ( result === "startedPZP" && self . webServerState !== global . states [ 2 ] ) { console . log ( self . webServerState ) ; pzpWebSocket . startPzpWebSocketServer ( self , config , function ( ) { self . update ( callback ) ; } ) ; } }
function checkConfiguration ( config ) { log . info ( "Your device has not been enrolled to PZH yet" ) ; console . log ( config ) ; if ( config . pzhHost === "" ) { log . error ( "pzhHost should be ip address or a domain name, by default value it is localhost" ) ; return false ; } if ( config . pzhName === "" ) { log . error ( "pzhName should not be empty, please enter your full name as it appears on PZH farm page" ) ; log . error ( "./webinos_pzp.js --auth-code=\"<code>\"  --pzh-name=\"<fullname>\"" ) ; return false ; } if ( config . code === "DEBUG" ) { log . error ( "No authorization code specified, please generate code on PZH and enter while starting PZP" ) ; log . error ( "./webinos_pzp.js --auth-code=\"<code>\"  --pzh-name=\"<fullname>\"" ) ; return false ; } return true ; }
function ( dt ) { this . timeElapsed += dt ; this . refresh ( Math . min ( 1 , this . easing ( this . timeElapsed / this . duration ) ) ) ; if ( this . timeElapsed > this . duration ) { if ( typeof this . callback === "function" ) { this . callback ( ) ; } return false ; } else { return true ; } }
function ( ) { this . paused = false ; if ( this . buffer ) { this . _emitData ( this . buffer ) ; this . buffer = null ; } if ( null == this . fd ) return ; this . _read ( ) ; }
function ( ) { var path = $ ( this ) . attr ( 'href' ) . split ( '?' ) ; if ( path . length > 1 ) { var uri = path [ 0 ] + '?overlay=true&' + path [ 1 ] ; } else { var uri = path [ 0 ] ; } $ ( '#overlay' ) . load ( uri , function ( ) { $ ( '#overlay textarea' ) . likeaboss ( ) ; $ ( '#overlay' ) . overlay ( ) ; } ) ; return false ; }
function getAllProperties ( obj , func ) { for ( ; obj ; obj = obj . __proto__ ) { if ( obj instanceof Object ) Object . getOwnPropertyNames ( obj ) . forEach ( func ) ; } }
function ( method , parameters ) { return $ . ajax ( { url : '/api/v1/web/' , type : 'POST' , contentType : 'application/json' , dataType : 'json' , data : JSON . stringify ( { "id" : _ . uniqueId ( ) , "method" : method , "params" : parameters } ) , success : function ( response ) { console . log ( [ 'api' , response ] ) ; } } ) ; }
function ( ) { Log ( 'error' , 'Could not play ' + ( clip . isLive ? 'live' : 'recorded' ) + ' stream' , clip ) ; if ( clip . isLive ) { _this . playRecordedLive ( clip . streamId ) ; } }
function clone ( obj ) { if ( Object ( obj ) !== obj ) { return obj ; } var res = new obj . constructor ; for ( var key in obj ) if ( obj [ has ] ( key ) ) { res [ key ] = clone ( obj [ key ] ) ; } return res ; }
function deepOption ( from , to , msg ) { div . data ( "testWidget" ) . options . foo = from ; $ . ui . testWidget . prototype . _setOption = function ( key , value ) { deepEqual ( key , "foo" , msg + ": key" ) ; deepEqual ( value , to , msg + ": value" ) ; } ; }
function ( ) { $ . widget ( "ui.testWidget" , { _create : function ( ) { } } ) ; $ ( "#widget" ) . testWidget ( { foo : function ( event , ui ) { return false ; } } ) ; deepEqual ( $ ( "#widget" ) . data ( "testWidget" ) . _trigger ( "foo" ) , false , "_trigger returns false when callback returns false" ) ; }
function ( ) { var instance = $ . data ( this , name ) ; if ( instance ) { instance . option ( options || { } ) . _init ( ) ; } else { new object ( options , this ) ; } }
function ( e ) { if ( _pasteMetaKeyPressed && ( e . which == 91 || e . which == 86 ) ) $ ( this ) . blur ( ) ; window . setTimeout ( function ( ) { _pasteMetaKeyPressed = e . metaKey ; } , 250 ) ; }
function ( request , response ) { var commentId = request . params . uid ; var direction = request . params . dir ; if ( request . method === "POST" ) { queryES . updateVote ( commentId , direction , appType , function ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 } ) ) ; } ) ; } }
function ( request , response ) { var commentId = request . params . uid ; var direction = request . params . dir ; if ( request . method === "PUT" ) { queryES . updateIsAnswered ( commentId , appType , function ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 } ) ) ; } ) ; } }
function ( element , settings ) { var fold ; if ( settings . container === undefined || settings . container === window ) { fold = $window . height ( ) + $window . scrollTop ( ) ; } else { fold = $container . offset ( ) . top + $container . height ( ) ; } return fold <= $ ( element ) . offset ( ) . top - settings . threshold ; }
function ( element , settings ) { var fold ; if ( settings . container === undefined || settings . container === window ) { fold = $window . width ( ) + $window . scrollLeft ( ) ; } else { fold = $container . offset ( ) . left + $container . width ( ) ; } return fold <= $ ( element ) . offset ( ) . left - settings . threshold ; }
function ( element , settings ) { var fold ; if ( settings . container === undefined || settings . container === window ) { fold = $window . scrollLeft ( ) ; } else { fold = $container . offset ( ) . left ; } return fold >= $ ( element ) . offset ( ) . left + settings . threshold + $ ( element ) . width ( ) ; }
function browser_setUrlButtonMode ( mode ) { this . urlButtonMode = mode ; switch ( mode ) { case this . GO : this . urlButton . src = 'style/images/go.png' ; this . urlButton . style . display = 'block' ; break ; case this . REFRESH : this . urlButton . src = 'style/images/refresh.png' ; this . urlButton . style . display = 'block' ; break ; case this . STOP : this . urlButton . style . display = 'none' ; break ; } }
function ( ) { console . log ( 'drawMap' ) console . log ( '**searchCircle = ' + searchCircle ) ; console . log ( '**markers.length = ' + markers . length ) ; for ( var i = markers . length - 1 ; i >= 0 ; i -- ) { markers [ i ] . setVisible ( markers [ i ] . isp == ispName ) ; markers [ i ] . inCircle = searchCircle . contains ( markers [ i ] . getPosition ( ) ) ; } tintSearchCircle ( ) ; }
function ( aliases , fn ) { var alias , _i , _len , _results ; _results = [ ] ; for ( _i = 0 , _len = aliases . length ; _i < _len ; _i ++ ) { alias = aliases [ _i ] ; _results . push ( modules [ alias ] = fn ) ; } return _results ; }
function ( count ) { var self = this ; if ( count < self . RETRY_MIN_COUNT ) return self . RETRY_MIN_TIMEOUT ; var timeout = Math . min ( self . RETRY_MAX_TIMEOUT , self . RETRY_BASE_TIMEOUT * Math . pow ( self . RETRY_EXPONENT , count ) ) ; timeout = timeout * ( ( Math . random ( ) * self . RETRY_FUZZ ) + ( 1 - self . RETRY_FUZZ / 2 ) ) ; return timeout ; }
function ( data ) { if ( self . current_status . status === "connecting" ) self . _connected ( data . data ) ; else if ( self . current_status . connected ) _ . each ( self . event_callbacks . message , function ( callback ) { try { callback ( data . data ) ; } catch ( e ) { Meteor . _debug ( "Exception while processing message" , e . stack ) ; } } ) ; }
function ( phrase , params ) { return nodeca . runtime . i18n . t ( nodeca . runtime . locale , phrase , params ) ; }
function ( ) { var city = Y . one ( '#placeName' ) . get ( 'text' ) , params = { url : { query : city } } ; this . mojitProxy . invoke ( 'twitter' , { params : params } , Y . bind ( this . renderTweets , this ) ) ; }
function ( err , str ) { Y . one ( '.info' ) . append ( str ) ; }
function ( v ) { v . fixable && ( v . fix = fixError ( copyResults ( v , config ) , code ) ) ; }
function ( match , code , assign , value ) { if ( code . indexOf ( 'def.' ) === 0 ) { code = code . substring ( 4 ) ; } if ( ! ( code in def ) ) { if ( assign === ':' ) { def [ code ] = value ; } else { eval ( "def[code]=" + value ) ; } } return '' ; }
function ( match , code , assign , value ) { if ( code . indexOf ( 'def.' ) === 0 ) { code = code . substring ( 4 ) ; } if ( ! ( code in def ) ) { if ( assign === ':' ) { def [ code ] = value ; } else { eval ( "def[code]=" + value ) ; } } return '' ; }
function ( tagName , className , root ) { if ( typeof ( root ) == "undefined" ) root = this . getTopContainer ( ) ; if ( className == null ) { return root . getElementsByTagName ( tagName ) ; } else { return D . getElementsByClassName ( className , tagName , root ) ; } }
function Argument ( text , prefix , suffix ) { if ( text === undefined ) { this . text = '' ; this . prefix = '' ; this . suffix = '' ; } else { this . text = text ; this . prefix = prefix !== undefined ? prefix : '' ; this . suffix = suffix !== undefined ? suffix : '' ; } }
function TrueNamedArgument ( name , arg ) { this . arg = arg ; this . text = arg ? arg . text : '--' + name ; this . prefix = arg ? arg . prefix : ' ' ; this . suffix = arg ? arg . suffix : '' ; }
function NamedArgument ( nameArg , valueArg ) { this . nameArg = nameArg ; this . valueArg = valueArg ; if ( valueArg == null ) { this . text = '' ; this . prefix = nameArg . toString ( ) ; this . suffix = '' ; } else { this . text = valueArg . text ; this . prefix = nameArg . toString ( ) + valueArg . prefix ; this . suffix = valueArg . suffix ; } }
function ( req , res ) { req . session . userid = req . param ( 'userid' ) ; res . redirect ( '/Warble' ) }
function ( ) { d3 . select ( 'h1' ) . style ( "color" , "red" ) ; if ( typeof console !== 'undefined' ) console . log ( "You pressed the button" ) ; }
function ( commentID , commentTitle , commentBody , appType , callback ) { var link = '/' + switchIndex ( appType ) + '/comments/' + commentID + '/_update' ; var data = { 'script' : 'ctx._source.title = title; ctx._source.body = body' , 'params' : { 'title' : commentTitle 'body' : commentBody } } db . post ( link , data , function ( err , req , data ) { if ( data ) { callback ( data ) ; } else { callback ( undefined ) ; } } ) }
function drag ( e ) { var x = e . pageX - ( parent . offset ( ) . left + center ) , y = e . pageY - ( parent . offset ( ) . top + center ) ; if ( drag_target == hue_ring ) { set_hue_cursor ( x , y ) ; update_color ( ) ; return true ; } if ( drag_target == bs_square ) { set_bs_cursor ( x , y ) ; update_color ( ) ; return true ; } }
function ( test ) { var mp = new ks_macros . MacroProcessor ( { loader_class : ks_test_utils . JSONifyLoader } ) ; processFixture ( test , mp , 'macros-document-double-brace.txt' , function ( errors , result ) { test . ok ( ! errors , "There should be no errors" ) ; test . done ( ) ; } ) ; }
function ( err , data ) { if ( err && i < Request . prototype . maxRetries && ( err . statusCode == 500 || err . statusCode == 503 || err . name . slice ( - 38 ) == "ProvisionedThroughputExceededException" ) ) { setTimeout ( retry , 50 << i , db , i + 1 ) } else cb ( err , data ) }
function AssignedResource ( id , release , resource , project , focusFactor , startDate , endDate ) { this . id = id ; this . release = release ; this . resource = resource ; this . project = project ; this . focusFactor = focusFactor ; this . assignedPeriod = new Period ( startDate , endDate , "" ) ; console . log ( "create AssignedResource:" + ko . toJSON ( this . assignedPeriod ) ) ; }
function ( ) { var available , hoursPresent ; console . log ( "assigned period " + this . assignedPeriod ) ; console . log ( "resource " + this . resource . initials ) ; hoursPresent = this . resource . hoursAvailable ( this . assignedPeriod ) ; console . log ( "hours present " + hoursPresent ) ; available = Math . round ( hoursPresent * this . focusFactor ) ; console . log ( "hours available corrected with assignment focus factor " + this . focusFactor + ": " + available ) ; return available ; }
function ( ) { var bv = new box . BoxView ( ) ; $ ( '#things' ) . append ( bv . render ( ) ) ; }
function ( ) { if ( $window . scrollTop ( ) > offset . top + $menu . height ( ) + additionalOffset && ! $menu . hasClass ( 'fixed' ) ) { $menu . addClass ( 'fixed' ) ; $original . width ( originalWidth ) ; } else if ( $window . scrollTop ( ) + additionalOffset < offset . top && $menu . hasClass ( 'fixed' ) ) { $menu . removeClass ( 'fixed' ) ; $original . width ( "auto" ) ; } }
function ( ) { this . bind ( 'error' , function ( model , error ) { Utils . debug ( "Error in App: " + error ) ; } ) ; }
function ( attributes ) { User . __super__ . initialize . call ( this , attributes ) ; }
function ( _users ) { expect ( _users . length ) . toEqual ( 1 ) task . setUsers ( null ) . success ( function ( ) { task . getUsers ( ) . success ( function ( _users ) { expect ( _users . length ) . toEqual ( 0 ) done ( ) } ) } ) . error ( function ( err ) { console . log ( err ) } ) }
function ( data ) { $ ( '#remote_form_dialog h3' ) . html ( $ ( 'h1' , data ) ) ; var form = dialogs . patch_form ( data ) ; $ ( '#remote_form_dialog div.modal-body' ) . html ( form ) ; var submit = $ ( '#remote_form_dialog .btn-confirm' ) ; submit . on ( 'click' , dialogs . async_form_submit ) ; form . on ( 'submit' , dialogs . async_form_submit ) ; }
function ( data ) { if ( $ ( '.control-group.error' , data ) . length ) { var form = dialogs . patch_form ( data ) ; $ ( '#remote_form_dialog div.modal-body' ) . html ( form ) ; } else { el . modal ( 'hide' ) ; if ( callback ) { callback ( ) ; } dialogs . notification ( 'Saved' ) ; } }
function ( nick , callback ) { var toInsert = { 'nickname' : nick } ; db . open ( function ( err , client ) { client . createCollection ( 'games' , function ( err , col ) { client . collection ( 'games' , function ( err , col ) { col . insert ( toInsert , { safe : true } , function ( ) { callback ( toInsert . _id ) ; } ) ; } ) ; } ) ; } ) ; }
function ( ) { var underTest = before ( ) ; underTest . init ( 'nick' , function ( gameId ) { underTest . findGame ( gameId , function ( obj ) { assert . equal ( 'nick' , obj . nickname ) ; } ) ; } ) ; }
function ( target , date , withDate ) { var inst = this . _getInst ( target ) , tp_inst = this . _get ( inst , 'timepicker' ) ; $ ( target ) . datepicker ( 'getDate' ) ; if ( tp_inst ) { tp_inst . _defaults . showTimepicker = false ; tp_inst . _updateDateTime ( inst ) ; } }
function ( target , date , withDate ) { var inst = this . _getInst ( target ) , tp_inst = this . _get ( inst , 'timepicker' ) ; $ ( target ) . datepicker ( 'getDate' ) ; if ( tp_inst ) { tp_inst . _defaults . showTimepicker = true ; tp_inst . _addTimePicker ( inst ) ; tp_inst . _updateDateTime ( inst ) ; } }
function ( target , date ) { var inst = this . _getInst ( target ) , tp_date = ( date instanceof Date ) ? new Date ( date . getTime ( ) ) : date ; this . _updateDatepicker ( inst ) ; this . _base_setDateDatepicker . apply ( this , arguments ) ; this . _setTimeDatepicker ( target , tp_date , true ) ; }
function ( data ) { var folder = data . uri . substr ( 0 , data . uri . lastIndexOf ( '/' ) + 1 ) ; if ( folder === currentFolder ) { loadFolder ( ) ; } }
function addItem ( it ) { it . extend ( { 'icon-file' : getIconURI ( it . icon ) } ) ; TPL ( 'onObjectItem' , it ) ; $ ( '<li>' ) . append ( TPL . item . format ( log ( it ) ) ) . appendTo ( '#items' ) . find ( 'a.item-link' ) . click ( itemClickHandler ) ; }
function updateOrder ( v ) { if ( ! v || ! v . length ) v = $ ( '#order' ) . val ( ) ; else $ ( '#order' ) . val ( v ) ; currentOrder = v ; setCookie ( 'order' , v ) ; if ( v ) { log ( 'remove' ) ; $ ( '#order option[value=]' ) . remove ( ) ; } sortItems ( ) ; }
function ( ) { var that = this , handler , cc , contentHandler = [ 'word' , 'generic' , 'sanitize' , 'blockelement' ] , i , j = contentHandler . length ; for ( i = 0 ; i < j ; i ++ ) { handler = contentHandler [ i ] ; cc = handler . charAt ( 0 ) . toUpperCase ( ) + handler . slice ( 1 ) ; ContentHandlerManager . register ( handler , eval ( cc + 'ContentHandler' ) ) ; } }
function ( file ) { if ( ! file . match ( /shBrush\w+\.js/ ) ) return ; var brush = require ( path . join ( scriptsDir , file ) ) . Brush ; brush . aliases . forEach ( function ( alias ) { brushMap [ alias . toLowerCase ( ) ] = brush ; } ) ; }
function ( accessToken , instanceUrl , userIdentityUrl , success , error , complete ) { var url = getBaseUrl ( ) + '/services/apexrest/oauth2/prepareSession' ; var data = 'accessToken=' + accessToken + '&instanceUrl=' + instanceUrl + '&identityUrl=' + userIdentityUrl ; this . ajax ( 'POST' , url , data , success , error , complete ) ; }
function ( accessToken , instanceUrl , userIdentityUrl , success , error , complete ) { var url = getBaseUrl ( ) + '/services/apexrest/oauth2/prepareSession' ; var data = 'accessToken=' + accessToken + '&instanceUrl=' + instanceUrl + '&identityUrl=' + userIdentityUrl ; this . ajax ( 'POST' , url , data , success , error , complete ) ; }
function ( accessToken , instanceUrl , userIdentityUrl , success , error , complete ) { var url = getBaseUrl ( ) + '/services/apexrest/oauth2/prepareSession' ; var data = 'accessToken=' + accessToken + '&instanceUrl=' + instanceUrl + '&identityUrl=' + userIdentityUrl ; this . ajax ( 'POST' , url , data , success , error , complete ) ; }
function ( oauthInfo ) { sf . prepareSessionFromOAuth ( oauthInfo . accessToken , oauthInfo . instanceUrl , oauthInfo . identityUrl , successCallback , loginFailure ) ; }
function ( callback ) { if ( sessionAlive ) callback ( ) ; else { authenticate ( callback ) ; SalesforceOAuthPlugin . getLoginDomain ( function ( val ) { loginHostUrl = val . toLowerCase ( ) ; } ) ; if ( ! sf ) sf = new sforce . Client ( authenticate ) ; } }
function ( ) { $j ( "#photo_div img" ) . enableTap ( ) . click ( saveUserPic ) ; if ( typeof sforce . Client != "undefined" ) sforce . Client . prototype . addAttachment = function ( a , b , c , d , e , f ) { var g = getBaseUrl ( ) + "/services/apexrest/cvapi?action=insertSObject&sobject=Attachment" ; this . ajax ( "POST" , g , { Name : a , ParentId : b , Body : c } , d , e , f ) } }
function ( oauthInfo ) { sf . prepareSessionFromOAuth ( oauthInfo . accessToken , oauthInfo . instanceUrl , oauthInfo . identityUrl , successCallback , loginFailure ) ; }
function ( callback ) { if ( sessionAlive ) callback ( ) ; else { authenticate ( callback ) ; SalesforceOAuthPlugin . getLoginDomain ( function ( val ) { loginHostUrl = val . toLowerCase ( ) ; } ) ; if ( ! sf ) sf = new sforce . Client ( authenticate ) ; } }
function ( data ) { Greenmine . Filters . tagCollection . reset ( data . filter_dict . tags ) ; Greenmine . Filters . statusCollection . reset ( data . filter_dict . status ) ; Greenmine . Filters . assignedToCollection . reset ( data . filter_dict . assigned_to ) ; Greenmine . Filters . severityCollection . reset ( data . filter_dict . severity ) ; Greenmine . milestoneCollection . reset ( data . filter_dict . milestones ) ; Greenmine . taskCollection . reset ( data . tasks ) ; }
function ( event ) { event . preventDefault ( ) ; var self = $ ( event . target ) ; var status_filter = self . attr ( 'category' ) ; if ( $ . inArray ( status_filter , this . options . status_filter ) < 0 ) { this . options . status_filter . push ( status_filter ) ; this . reload ( ) ; } }
function ( event ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; var self = $ ( event . target ) ; var status_filter = parseInt ( self . attr ( 'category' ) ) ; this . options . status_filter . pop ( status_filter ) ; this . reload ( ) ; }
function ( ) { Cache . on ( 'statusChange' , Class . proxy ( function ( e ) { Cache . detach ( ) ; this . _isOnline = e . data == 1 ; if ( ! this . loaded ) this . fire ( '_complete' , AppState . STORAGE ) ; } , this ) ) ; Cache . init ( ) ; }
function ( ) { var config = this . config ; this . client = mysql . createConnectionSync ( config . host , config . user , config . password ) ; if ( config . database ) { this . client . query ( 'USE ' + config . database ) ; } if ( ! this . client ) throw new Error ( 'Could not connect with this configuration.' , config ) ; return this . connected = true ; }
function BooleanClass ( scope , instance , baseClass ) { var c = new Class ( "Boolean" , Boolean , C ( Boolean ) ) ; c . baseClass = baseClass ; c . nativeMethods = Boolean . prototype ; return c ; }
function TypedVector ( length , fixed ) { var array = new TypedArray ( length ) ; for ( var i = 0 ; i < length ; i ++ ) { array [ i ] = type . defaultValue ; } return array ; }
function NumberClass ( scope , instance , baseClass ) { var c = new Class ( "Number" , Number , C ( Number ) ) ; c . baseClass = baseClass ; c . nativeMethods = Number . prototype ; c . defaultValue = Number ( 0 ) ; c . isInstance = function ( value ) { return typeof value === "number" ; } ; return c ; }
function intClass ( scope , instance , baseClass ) { function int ( x ) { return Number ( x ) | 0 ; } var c = new Class ( "int" , int , C ( int ) ) ; c . baseClass = baseClass ; c . defaultValue = 0 ; c . isInstance = function ( value ) { return ( value | 0 ) === value ; } ; return c ; }
function uintClass ( scope , instance , baseClass ) { function uint ( x ) { return Number ( x ) >>> 0 ; } var c = new Class ( "uint" , uint , C ( uint ) ) ; c . baseClass = baseClass ; c . defaultValue = 0 ; c . isInstance = function ( value ) { return ( value >>> 0 ) === value ; } ; return c ; }
function translateError ( error ) { if ( error instanceof Error ) { var type = toplevel . getTypeByName ( Multiname . fromSimpleName ( error . name ) , true , true ) ; if ( type ) { return new type . instance ( error . message ) ; } unexpected ( "Can't translate error: " + error ) ; } return error ; }
function getClass ( simpleName ) { var c = this . getTypeByName ( Multiname . fromSimpleName ( simpleName ) , true , true ) ; assert ( c instanceof Class ) ; return c . instance ; }
function ( callback , ctx ) { var i = - 1 ; t = this , len = t . length ; while ( ++ i < len ) if ( i in t && ( ctx ? callback . call ( ctx , t [ i ] , i , t ) : callback ( t [ i ] , i , t ) ) ) return true ; return false ; }
function ( rawSourceCode , oldUISourceCode , uiSourceCode ) { this . _rawSourceCodeForUISourceCode . remove ( oldUISourceCode ) ; this . _rawSourceCodeForUISourceCode . put ( uiSourceCode , rawSourceCode ) ; for ( var i = 0 ; i < rawSourceCode . _scripts . length ; ++ i ) rawSourceCode . _scripts [ i ] . setSourceMapping ( this ) ; var data = { oldUISourceCode : oldUISourceCode , uiSourceCode : uiSourceCode } ; this . dispatchEventToListeners ( WebInspector . UISourceCodeProvider . Events . UISourceCodeReplaced , data ) ; }
function ( script ) { var uiSourceCode = new WebInspector . JavaScriptSource ( script . sourceURL , null , script , this . _snippetScriptMapping , false ) ; uiSourceCode . isSnippetEvaluation = true ; this . _uiSourceCodeForScriptId [ script . scriptId ] = uiSourceCode ; this . _scriptForUISourceCode . put ( uiSourceCode , script ) ; this . _snippetScriptMapping . _fireUISourceCodeAdded ( uiSourceCode ) ; script . setSourceMapping ( this . _snippetScriptMapping ) ; }
function ( p ) { p = Math . limit ( p , 0.0 , 1.0 ) ; this . percentVal = p ; var x = this . width ( ) * p ; this . children ( '.skybrush_slider_bar_slider' ) . offset ( x , 0 ) ; return this ; }
function toggleOddEven ( ) { var isEven = false ; $$ ( 'table.list tr.project' ) . each ( function ( e ) { if ( ! e . hasClassName ( 'hide' ) ) { e . removeClassName ( 'odd' ) ; e . removeClassName ( 'even' ) ; e . addClassName ( isEven ? 'even' : 'odd' ) ; isEven = ! isEven ; } } ) }
function toggleShowHide ( projectId ) { var project = $ ( 'project' + projectId ) ; var isClosed = project . className . include ( 'closed' ) ; $$ ( 'table.list tr.' + projectId ) . each ( function ( e ) { if ( isClosed ) { e . removeClassName ( 'hide' ) ; } else { e . addClassName ( 'hide' ) ; } } ) project . removeClassName ( 'closed' ) ; project . removeClassName ( 'open' ) ; project . addClassName ( isClosed ? 'open' : 'closed' ) ; toggleOddEven ( ) ; }
function collapseAll ( ) { $$ ( 'table.list tr.project' ) . each ( function ( e ) { e . removeClassName ( 'open' ) ; e . addClassName ( 'closed' ) ; if ( ! e . hasClassName ( 'root' ) ) { e . addClassName ( 'hide' ) ; } } ) ; toggleOddEven ( ) ; }
function ( obj ) { var clone = { } ; for ( var i in obj ) { if ( typeof ( obj [ i ] ) === "object" ) { clone [ i ] = cloneObject ( obj [ i ] ) ; } else { clone [ i ] = obj [ i ] ; } } return clone ; }
function ( v ) { return function ( ) { return v ; } ; }
function createSpace ( name , base , definition ) { if ( def . isFun ( base ) ) { definition = base ; base = null ; } var namespace = getNamespace ( name , base ) ; if ( definition ) { namespaceStack . push ( currentNamespace ) ; try { definition ( namespace ) ; } finally { currentNamespace = namespaceStack . pop ( ) ; } } return namespace ; }
function ( instance ) { for ( var i = 1 , L = arguments . length ; i < L ; i ++ ) { var mixin = arguments [ i ] ; if ( mixin ) { mixin = asObject ( mixin . prototype || mixin ) ; if ( mixin ) { mixinRecursive ( instance , mixin ) ; } } } return instance ; }
function createRecursive ( instance ) { for ( var p in instance ) { var vObj = asNativeObject ( instance [ p ] ) ; if ( vObj ) { createRecursive ( ( instance [ p ] = Object . create ( vObj ) ) ) ; } } }
function ( q ) { if ( q === undefined ) { return new def . NullQuery ( ) ; } if ( q instanceof def . Query ) { return q ; } if ( def . isFun ( q ) ) { return new def . AdhocQuery ( q ) ; } return new def . ArrayLikeQuery ( q ) ; }
function ( ) { if ( ! this . $tip ) { this . $tip = $ ( '<div class="tipsy"></div>' ) . html ( '<div class="tipsy-arrow"></div><div class="tipsy-inner"/></div>' ) ; } return this . $tip ; }
function ( colors ) { if ( colors == null || ! colors . length ) { return pv . Colors . category10 ; } colors = def . array ( colors ) ; return function ( ) { var scale = pv . colors ( colors ) ; scale . domain . apply ( scale , arguments ) ; return scale ; } ; }
function ( reader , dimNames ) { def . isFun ( reader ) || def . fail . argumentInvalid ( 'reader' , "Reader must be a function." ) ; if ( def . isArray ( dimNames ) ) { dimNames . forEach ( function ( name ) { this . _userDimsReadersByDim [ name ] = reader ; } , this ) ; } else { this . _userDimsReadersByDim [ dimNames ] = reader ; } this . _userDimsReaders . push ( reader ) ; }
function ( datums ) { if ( ! def . isArrayLike ( datums ) ) { datums = def . query ( datums ) . array ( ) ; } var allSelected = def . query ( datums ) . all ( function ( datum ) { return datum . isNull || datum . isSelected ; } ) ; return this . setSelected ( datums , ! allSelected ) ; }
function ( datums ) { if ( ! def . isArrayLike ( datums ) ) { datums = def . query ( datums ) . array ( ) ; } var allVisible = def . query ( datums ) . all ( function ( datum ) { return datum . isVisible ; } ) ; return pvc . data . Data . setVisible ( datums , ! allVisible ) ; }
function ( options ) { if ( ! $ . support . svg || pv . renderer ( ) === 'batik' ) { options . animate = false ; } if ( options . showTooltips ) { var ts = options . tipsySettings ; if ( ts ) { ts = options . tipsySettings = def . create ( ts ) ; this . extend ( ts , "tooltip_" ) ; if ( ts . exclusionGroup === undefined ) { ts . exclusionGroup = 'chart' ; } } } }
function ( atom , dimName ) { var dimType = atom . dimension . type ; if ( ! dimType . isHidden ) { if ( ! isMultiDatumGroup || atom . value != null ) { var valueLabel = atom . label ; if ( playingPercentMap && playingPercentMap . has ( dimName ) ) { valueLabel += " (" + calcPercent ( atom , dimName ) + ")" ; } addDim ( def . escapeHtml ( atom . dimension . type . label ) , valueLabel ) ; } } }
function ( axisType , axisIndex ) { var roles = def . array ( this . _axisRoleNameMap [ axisType ] ) . map ( function ( roleName ) { return this . visualRoles ( roleName ) ; } , this ) ; var axis = new pvc . visual . CartesianAxis ( this , axisType , axisIndex , roles ) ; this . axes [ axis . id ] = axis ; this . axes [ axis . orientedId ] = axis ; return axis ; }
function getMouseBounds ( ev ) { if ( ! ev ) { ev = pv . event ; } var offset = $canvas . offset ( ) ; return { left : ev . pageX - offset . left , top : ev . pageY - offset . top , width : 10 , height : 20 } ; }
function ( ) { this . _super ( ) ; var context = this . _layerContext ; context . save ( ) ; context . clearRect ( 0 , 0 , this . _layerCanvas . width , - this . _layerCanvas . height ) ; context . restore ( ) ; }
function ( url , callback ) { var find = new Propfind ( this . connection , { url : url } ) ; find . prop ( [ 'caldav' , 'calendar-home-set' ] ) ; find . send ( function ( err , data ) { if ( err ) { return callback ( err ) ; } callback ( null , findProperty ( 'calendar-home-set' , data , true ) ) ; } ) ; }
function ( buffer ) { if ( ! buffer ) { return console . error ( 'Error decoding file:' , path ) ; } var cbArray = buffers [ path ] ; buffers [ path ] = { buffer : buffer } ; for ( var i = 0 ; i < cbArray . length ; i ++ ) { cbArray [ i ] ( buffer , path ) ; } }
function setStatus ( num , str ) { YUI ( ) . use ( 'node' , function ( Y ) { var object = Y . one ( 'object' ) , doc = object . get ( 'contentDocument' ) ; var status = Y . Node . getDOMNode ( doc . one ( '#Status' ) ) ; status . value = str ; } ) ; }
function ( Y ) { var object = Y . one ( 'object' ) , doc = object . get ( 'contentDocument' ) ; var timer = Y . Node . getDOMNode ( doc . one ( '#Timer' ) ) ; timer . value = str ; }
function onZoomDone ( ) { $canvas . css ( { '-moz-transform' : null } ) ; $tabEl . removeClass ( "front" ) ; UI . goToTab ( tab ) ; if ( tab != gBrowser . selectedTab ) { UI . onTabSelect ( gBrowser . selectedTab ) ; } else { if ( isNewBlankTab ) gWindow . gURLBar . focus ( ) ; } if ( self . parent && self . parent . expanded ) self . parent . collapse ( ) ; self . _sendToSubscribers ( "zoomedIn" ) ; }
function onTabViewHidden ( ) { window . removeEventListener ( "tabviewhidden" , onTabViewHidden , false ) ; ok ( frontChanged , "the CSS class 'front' was added while zooming in" ) ; ok ( transformChanged , "the CSS class '-moz-transform' was modified while " + "zooming in" ) ; frontChanged = transformChanged = false ; tab . $container [ 0 ] . removeEventListener ( "DOMAttrModified" , checkForFrontAddition , false ) ; tab . $container [ 0 ] . addEventListener ( "DOMAttrModified" , checkForFrontRemoval , false ) ; window . addEventListener ( "tabviewshown" , onTabViewShownAgain , false ) ; TabView . toggle ( ) ; }
function ( item , status ) { this . set ( "selected" , false ) ; item . data . object . status = status ; item . render ( "controls" ) ; item . render ( "status" , true ) ; }
function ( i ) { this . counter [ 0 ] ++ ; this . bCount [ 0 ] . remove ( ) ; this . bCount [ 0 ] = paper . text ( paper . width - 125 , 11 , this . counter [ 0 ] ) . attr ( { fill : "white" } ) ; this . button . push ( this . bCount [ 0 ] ) ; }
function init ( ) { if ( sys . getVal ( 'etext' ) === "true" ) { etext = "true" } else { etext = "false" } if ( sys . getVal ( 'tgreentext' ) === "true" ) { tgreentext = "true" } else { tgreentext = "false" } var nstalkwords = sys . getVal ( 'stalkwords' ) . split ( "," ) stalkwords = nstalkwords . concat ( stalkwords ) stalkwords = eliminateDuplicates ( stalkwords ) }
function ( success ) { if ( success === false ) { if ( ui . showLogin ( ) === true ) { ui . addMessage ( 'Type /login to show the login screen' , 'notification' ) ; } else { ui . addMessage ( 'Use /nick user password to log in with jabbr' , 'notification' ) ; ui . addMessage ( 'To enable janrain login, setup the missing values in web.config' , 'notification' ) ; } } chat . getCommands ( ) . done ( function ( commands ) { ui . setCommands ( commands ) ; } ) ; }
function ( ) { var affichClass = $ ( this ) . val ( ) ; $ ( '#CTRL tr:not(.' + affichClass + ')' ) . hide ( ) ; $ ( '#CTRL tr.' + affichClass ) . show ( ) ; $ ( '#CTRL tr.static' ) . show ( ) ; }
function ( ) { var affichClass = $ ( this ) . val ( ) ; if ( $ ( "input:radio[value='veri']" ) . next ( ) . attr ( 'aria-pressed' ) ) { if ( affichClass == 'S' ) $ ( '#CTRL tr.site' ) . show ( ) ; else $ ( '#CTRL tr.site' ) . hide ( ) ; } }
function onSuccess ( info ) { if ( info . success ) { pageHelpers . emailSent ( oncomplete ) ; } else { var tooltipEl = info . reason === "throttle" ? "#could_not_add" : "#not_registered" ; tooltip . showTooltip ( tooltipEl ) ; complete ( oncomplete ) ; } }
function emailSent ( onComplete ) { origStoredEmail = getStoredEmail ( ) ; dom . setInner ( '#sentToEmail' , origStoredEmail ) ; clearStoredEmail ( ) ; replaceInputsWithNotice ( ".emailsent" ) ; user . waitForUserValidation ( origStoredEmail , function ( status ) { userValidationComplete ( status ) ; } ) ; onComplete && onComplete ( ) ; }
function openPrimaryAuth ( winchan , email , baseURL , callback ) { if ( ! ( email && baseURL ) ) { throw "cannot verify with primary without an email address and URL" } winchan . open ( { url : "https://login.persona.org/authenticate_with_primary" , relay_url : "https://login.persona.org/relay" , window_features : "width=700,height=375" , params : helpers . toURL ( baseURL , { email : email } ) } , function ( error , result ) { if ( ! error ) { user . resetCaches ( ) ; } callback && callback ( error , result ) ; } ) ; }
function hideResolved ( ) { $ ( 'tr' ) . addClass ( 'nothingToDo' ) ; $ ( '.info-planned' ) . each ( function ( ) { $ ( this ) . parent ( ) . removeClass ( 'nothingToDo' ) ; } ) ; $ ( 'tr.nothingToDo' ) . hide ( ) ; $ ( 'tbody tr:first' ) . show ( ) ; }
function getSelectedRadio ( ) { var radios = document . forms [ 0 ] . urgency ; for ( var i = 0 ; i < radios . length ; i ++ ) { if ( radios [ i ] . checked ) { var urgencyValue = radios [ i ] . value ; } } }
function ( x , y ) { var i = x + y * CANVAS_WIDTH ; return { r : imageData2DHDR . data [ i ] , g : imageData2DHDR . data [ i + 1 ] , b : imageData2DHDR . data [ i + 2 ] , a : imageData2DHDR . data [ i + 3 ] } }
function ( ) { if ( ! this . _source ) { this . _source = new MessageTray . Source ( _ ( "Network Manager" ) , 'network-transmit-receive' , St . IconType . SYMBOLIC ) ; this . _source . connect ( 'destroy' , Lang . bind ( this , function ( ) { this . _source = null ; } ) ) ; Main . messageTray . add ( this . _source ) ; } }
function ( url ) { this . currentUrl = url ; if ( this . loadedForms [ url ] ) { $ ( 'lb-content' ) . innerHTML = '' ; this . lbPlaceContentInDocument ( this . loadedForms [ url ] , $ ( 'lb-content' ) ) ; this . form = c . getElementsByTagName ( 'form' ) [ 0 ] ; } else { new Ajax . Request ( url , { onSuccess : this . lbFormDataLoaded . bind ( this ) } ) ; } }
function ( row ) { if ( ! this . layout . _isCollapsable ) { this . inherited ( arguments ) ; return ; } row . customClasses = ( row . odd ? " dojoxGridRowOdd" : "" ) + ( row . selected ? " dojoxGridRowSelected" : "" ) + ( row . over ? " dojoxGridRowOver" : "" ) ; this . focus . styleRow ( row ) ; this . edit . styleRow ( row ) ; }
function tick ( ) { controller . interaction ( ) ; controller . update ( ) ; orderSummary . render ( ) ; }
function ( model ) { var cid = model . cid ; this . contractedViews [ cid ] . off ( ) ; this . contractedViews [ cid ] . remove ( ) ; delete this . expandedViews [ cid ] ; this . expandedViews [ cid ] . off ( ) ; this . expandedViews [ cid ] . remove ( ) ; delete this . contractedViews [ cid ] ; BTS . SortableTable . prototype . remove . call ( this , model ) ; }
function ( node ) { if ( matchNode ( node , format , { } , similar ) ) { if ( ! currentFormats [ format ] ) { each ( callbacks , function ( callback ) { callback ( true , { node : node , format : format , parents : parents } ) ; } ) ; currentFormats [ format ] = callbacks ; } matchedFormats [ format ] = callbacks ; return false ; } }
function ( target , options , callback ) { if ( typeof ( options ) === 'function' ) { callback = options , options = { } } this . connection . replicate ( cradle . merge ( { source : name , target : target } , options ) , callback ) ; }
function ( ) { new Ext . Viewport ( { layout : 'border' , items : [ { region : 'center' , xtype : 'AceEditor' , unstyled : true , theme : 'twilight' , fontSize : '13px' , contentEl : 'pre_1' , parser : 'liquid' } ] } ) ; }
function ( ) { $ ( 'tracker_reminder' ) . show ( ) ; $ ( 'add_reminder' ) . observe ( 'click' , function ( evt ) { var url = codendi . tracker . base_url + '?func=display_reminder_form&tracker=' + $ ( 'add_reminder' ) . value ; var target = 'tracker_reminder' ; var myAjax = new Ajax . Updater ( target , url , { method : 'get' } ) ; } ) ; }
function ( e ) { dispatch ( 'touchend' , target , e ) ; target = null ; down = false ; }
function ( element ) { if ( element === target || element . contains ( target ) ) { event . targetTouches = event . changedTouches = event . touches = [ { identifier : String . uniqueID ( ) , target : target , pageX : event . page . x , pageY : event . page . y , clientX : event . client . x , clientY : event . client . y } ] ; element . fireEvent ( name , event ) ; } }
function handleOk ( fraseElement , autorElement ) { i = fraseElement . children [ 0 ] . innerHTML autor = autorElement . children [ 0 ] . innerHTML i = i + '<label class="autor_label"> - ' + autor + '</label>' fraseElement . children [ 0 ] . innerHTML = i console . log ( i ) console . log ( "ok" ) }
function ( ) { if ( kb . focusBox != this ) { $ ( kb . html ) . slideDown ( 300 ) . center ( ) ; kb . focusBox = this ; hotel = 1 ; specialMode = false ; prevMode = false ; $ ( typeModeIcon ) . remove ( ) ; } }
function ( v ) { return function ( ) { return v ; } ; }
function createSpace ( name , base , definition ) { if ( def . isFun ( base ) ) { definition = base ; base = null ; } var namespace = getNamespace ( name , base ) ; if ( definition ) { namespaceStack . push ( currentNamespace ) ; try { definition ( namespace ) ; } finally { currentNamespace = namespaceStack . pop ( ) ; } } return namespace ; }
function ( instance ) { for ( var i = 1 , L = arguments . length ; i < L ; i ++ ) { var mixin = arguments [ i ] ; if ( mixin ) { mixin = asObject ( mixin . prototype || mixin ) ; if ( mixin ) { mixinRecursive ( instance , mixin ) ; } } } return instance ; }
function createRecursive ( instance ) { for ( var p in instance ) { var vObj = asNativeObject ( instance [ p ] ) ; if ( vObj ) { createRecursive ( ( instance [ p ] = Object . create ( vObj ) ) ) ; } } }
function ( q ) { if ( q === undefined ) { return new def . NullQuery ( ) ; } if ( q instanceof def . Query ) { return q ; } if ( def . isFun ( q ) ) { return new def . AdhocQuery ( q ) ; } return new def . ArrayLikeQuery ( q ) ; }
function ( ) { if ( ! this . $tip ) { this . $tip = $ ( '<div class="tipsy"></div>' ) . html ( '<div class="tipsy-arrow"></div><div class="tipsy-inner"/></div>' ) ; } return this . $tip ; }
function ( colors ) { if ( colors == null || ! colors . length ) { return pv . Colors . category10 ; } colors = def . array ( colors ) ; return function ( ) { var scale = pv . colors ( colors ) ; scale . domain . apply ( scale , arguments ) ; return scale ; } ; }
function ( options ) { if ( ! $ . support . svg || pv . renderer ( ) === 'batik' ) { options . animate = false ; } if ( options . showTooltips ) { var ts = options . tipsySettings ; if ( ts ) { ts = options . tipsySettings = def . create ( ts ) ; this . extend ( ts , "tooltip_" ) ; if ( ts . exclusionGroup === undefined ) { ts . exclusionGroup = 'chart' ; } } } }
function ( atom , dimName ) { var dimType = atom . dimension . type ; if ( ! dimType . isHidden ) { if ( ! isMultiDatumGroup || atom . value != null ) { var valueLabel = atom . label ; if ( playingPercentMap && playingPercentMap . has ( dimName ) ) { valueLabel += " (" + calcPercent ( atom , dimName ) + ")" ; } addDim ( def . escapeHtml ( atom . dimension . type . label ) , valueLabel ) ; } } }
function ( axisType , axisIndex ) { var roles = def . array ( this . _axisRoleNameMap [ axisType ] ) . map ( function ( roleName ) { return this . visualRoles ( roleName ) ; } , this ) ; var axis = new pvc . visual . CartesianAxis ( this , axisType , axisIndex , roles ) ; this . axes [ axis . id ] = axis ; this . axes [ axis . orientedId ] = axis ; return axis ; }
function getMouseBounds ( ev ) { if ( ! ev ) { ev = pv . event ; } var offset = $canvas . offset ( ) ; return { left : ev . pageX - offset . left , top : ev . pageY - offset . top , width : 10 , height : 10 } ; }
function updateTipsy ( ev ) { if ( $fakeTipTarget ) { if ( prevMouseX != null && prevMouseX === ev . clientX && prevMouseY === ev . clientY ) { return ; } if ( pvc . debug >= 4 ) { pvc . log ( "[TIPSY] Update" ) ; } prevMouseX = ev . clientX ; prevMouseY = ev . clientY ; setFakeTipTargetBounds ( getMouseBounds ( ev ) ) ; $fakeTipTarget . tipsy ( "update" ) ; } }
function initBehavior ( mark ) { if ( pvc . debug >= 4 ) { pvc . log ( "[TIPSY] Creating" ) ; } createTipsy ( mark ) ; if ( group ) { addBehavior ( tipsyBehavior , group ) ; } if ( usesPoint ) { mark . event ( 'unpoint' , hideTipsy ) ; } }
function showTipsy ( mark ) { if ( pvc . debug >= 4 ) { pvc . log ( "[TIPSY] Show IN" ) ; } if ( ! $canvas ) { initBehavior ( mark ) ; } setTarget ( pv . event . target ) ; $fakeTipTarget . attr ( 'title' , getTooltipText ( mark ) ) ; setFakeTipTargetBounds ( opts . followMouse ? getMouseBounds ( ) : getInstanceBounds ( mark ) ) ; $fakeTipTarget . tipsy ( "enter" ) ; if ( pvc . debug >= 4 ) { pvc . log ( "[TIPSY] Show OUT" ) ; } }
function ( datums ) { if ( ! def . isArrayLike ( datums ) ) { datums = def . query ( datums ) . array ( ) ; } var allSelected = def . query ( datums ) . all ( function ( datum ) { return datum . isNull || datum . isSelected ; } ) ; return this . setSelected ( datums , ! allSelected ) ; }
function ( datums ) { if ( ! def . isArrayLike ( datums ) ) { datums = def . query ( datums ) . array ( ) ; } var allVisible = def . query ( datums ) . all ( function ( datum ) { return datum . isVisible ; } ) ; return pvc . data . Data . setVisible ( datums , ! allVisible ) ; }
function ( reader , dimNames ) { def . isFun ( reader ) || def . fail . argumentInvalid ( 'reader' , "Reader must be a function." ) ; if ( def . isArray ( dimNames ) ) { dimNames . forEach ( function ( name ) { this . _userDimsReadersByDim [ name ] = reader ; } , this ) ; } else { this . _userDimsReadersByDim [ dimNames ] = reader ; } this . _userDimsReaders . push ( reader ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( binding , key ) { if ( binding . get [ 1 ] ) this . $el . off ( binding . getTrigger ) ; if ( binding . set ) this . model . off ( binding . setTrigger , binding . set ) ; delete this . _bindings [ key ] ; }
function ( ) { selectedTitles = $ ( ".addpeoplegroups_trigger:visible" ) . data ( "entityname" ) ; selectedIDs = $ ( ".addpeoplegroups_trigger:visible" ) . data ( "entityid" ) ; if ( ! $addpeoplegroupsWidget . is ( ":visible" ) ) { addBinding ( ) ; doInit ( this ) ; } else { toggleVisibility ( ) ; } }
function ( ) { var $itemToRemove = $ ( this ) ; var toRemoveId = $itemToRemove . attr ( 'data-entityid' ) ; $ ( window ) . trigger ( 'init.deletecontent.sakai' , [ { paths : [ toRemoveId ] , context : collectionviewer . contextId } , function ( success ) { $itemToRemove . parents ( 'li:not(.contentauthoring_row_container)' ) . hide ( 'slow' ) ; setTimeout ( refreshCollection , 1500 ) ; } ] ) ; }
function ( ) { if ( sakai_global . profile . main . mode . value !== "view" ) { getPendingFromOther ( getAccepted ) ; } else { contacts . invited = false ; sakai . api . User . getContacts ( function ( ) { getAccepted ( ) ; } ) ; } }
function ( ) { acceptRequest ( $ ( this ) [ 0 ] . id . split ( "contacts_add_to_contacts_" ) [ 1 ] ) ; $ ( this ) . parents ( '.contacts_item' ) . remove ( ) ; uncheckAll ( ) ; }
function ( e , data , library ) { if ( isMe && data && data . length && library === sakai . data . me . user . userid ) { $ ( window ) . trigger ( "lhnav.updateCount" , [ "library" , data . length ] ) ; } }
function ( e ) { e . preventDefault ( ) ; if ( $ ( this ) . parents ( ".s3d-dropdown-list" ) . length || $ ( e . target ) . hasClass ( "s3d-dropdown-list-arrow-up" ) ) { $ ( window ) . trigger ( "init.contentpermissions.sakai" , { "newPermission" : $ ( this ) . data ( "permissionvalue" ) || false } ) ; $ ( '#entity_contentsettings_dropdown' ) . jqmHide ( ) ; } }
function ( e ) { e . preventDefault ( ) ; window . scrollTo ( 0 , 0 ) ; $ ( window ) . trigger ( 'init.deletecontent.sakai' , [ { "paths" : [ sakai_global . content_profile . content_data . data . _path ] } , function ( success ) { if ( success ) { setTimeout ( function ( ) { document . location = "/me" ; } , 2000 ) ; } } ] ) ; $ ( '#entity_contentsettings_dropdown' ) . jqmHide ( ) ; }
function ( worldId , worldTitle ) { var requests = [ ] ; $ ( tabs ) . each ( function ( i , tab ) { requests . push ( { "url" : "/var/search/bytag.json" , "method" : "GET" , "parameters" : { page : 0 , items : 3 , tag : "directory/" + pageData . category . replace ( "-" , "/" ) , category : tab . id , type : "g" } } ) ; } ) ; sakai . api . Server . batch ( requests , renderWidget ) ; }
function ( ) { $ ( listViewClass ) . hide ( ) ; $ ( detailViewClass ) . hide ( ) ; $ ( window ) . trigger ( "initialize.sendmessage.sakai" , [ null , $inbox_new_message_sendmessage , sendMessageFinished ] ) ; $inbox_box_title . text ( sakai . api . i18n . getValueForKey ( "NEW_MESSAGE" , "inbox" ) ) ; $ ( newMessageViewClass ) . show ( ) ; }
function ( ) { addToCollectionCount ( collectionId , itemsDropped . length , false ) ; if ( inCollection ) { showCollection ( contentListDisplayed ) ; } $ ( window ) . trigger ( 'done.newaddcontent.sakai' , [ itemsDropped , 'user' ] ) ; sakai . api . Util . progressIndicator . hideProgressIndicator ( ) ; }
function ( evObj , groupid , target ) { sakai . api . Groups . isAllowedToLeave ( groupid , sakai . data . me , function ( leaveAllowed ) { openTooltip ( groupid , $ ( target ) , leaveAllowed [ groupid ] ) ; } ) ; return false ; }
function ( i , result ) { if ( result . id ) { if ( $ ( '#' + result . id , $container ) . length === 0 ) { filteredresults . push ( result ) ; } } }
function ( success ) { if ( success ) { resetView ( ) ; $ ( window ) . trigger ( 'lhnav.updateCount' , [ 'library' , - ( paths . length ) ] ) ; mylibrary . infinityScroll . removeItems ( paths ) ; if ( collectionPaths . length ) { $ ( window ) . trigger ( 'sakai.mylibrary.deletedCollections' , { items : collectionPaths } ) ; } } }
function ( success ) { if ( success ) { resetView ( ) ; $ ( window ) . trigger ( 'lhnav.updateCount' , [ 'library' , - ( paths . length ) ] ) ; if ( collection ) { $ ( window ) . trigger ( 'sakai.mylibrary.deletedCollections' , { items : paths } ) ; } mylibrary . infinityScroll . removeItems ( paths ) ; } }
function ( ) { var sendMessageUserObj = { } ; sendMessageUserObj . uuid = userId ; sendMessageUserObj . username = sakai . api . User . getDisplayName ( dataCache [ userId ] ) ; sendMessageUserObj . type = "user" ; $ ( window ) . trigger ( "initialize.sendmessage.sakai" , [ sendMessageUserObj , false , false , null , null , null ] ) ; }
function ( ) { handlerecentcontactsnewData ( sakai . data . me . mycontacts ) ; }
function ( value , element ) { return value . indexOf ( sakai . api . i18n . getValueForKey ( "ENTER_CONTACT_OR_GROUP_NAMES" , "sendmessage" ) ) === - 1 && $ . trim ( $ ( element ) . next ( "input.as-values" ) . val ( ) ) . replace ( /,/g , "" ) !== "" ; }
function ( $thisForm , validator ) { $form . find ( ".s3d-error" ) . attr ( "aria-invalid" , "false" ) ; if ( $ . isFunction ( invalidCallback ) ) { invalidCallback ( $thisForm , validator ) ; } }
function ( event , ui ) { sakai_util . Draggable . removeIFrameFix ( ) ; $ ( '.s3d-draggable-draggingitems' ) . remove ( ) ; $ ( window ) . trigger ( 'stop.drag.sakai' ) ; if ( $ ( this ) . data ( 'stopdragevent' ) ) { $ ( window ) . trigger ( $ ( this ) . data ( 'stopdragevent' ) , sakai_util . Draggable . getDraggableData ( ui . helper ) ) ; } }
function ( editor ) { if ( editor . htmlDiv . is ( ":empty" ) ) { this . updatePreview ( editor ) ; } else { this . updateTextArea ( editor ) ; } editor . toolbar . loadModeToolbar ( editor ) ; this . afterActivation ( editor ) ; }
function ( editor , action , target ) { var item = toolbarItems [ action ] , mode = editor . currentMode ; ( item [ mode . id ] || item ) . clicked ( editor , target ) ; if ( action != "changeMode" && ! editor . is ( "wysiwyg" ) ) { mode . updatePreview ( editor ) ; } }
function ( classString ) { var i , cssClass , cssClasses = classString . split ( /\s+/ ) ; for ( i = 0 ; i < cssClasses . length ; i += 1 ) { cssClass = cssClasses [ i ] ; if ( cssClass !== "wysiwyg" && availableModes [ cssClass ] ) { this . dataType = cssClass ; } } }
function ( modeId ) { var mode = availableModes [ modeId ] ; if ( mode ) { return mode ; } else { console . log ( "Mode " + modeId + " is not defined" ) ; } }
function initEditorFromTextarea ( textarea , instanceSettings ) { var editor , settings = { } ; $ . extend ( settings , globalSettings , instanceSettings ) ; editor = new Editor ( textarea , settings ) ; editor . currentMode = editor . getDataMode ( ) ; if ( textarea . hasClass ( "wysiwyg" ) ) { editor . currentMode . activate ( editor ) ; editor . currentMode = ME . getMode ( "wysiwyg" ) ; } editor . currentMode . activate ( editor ) ; editor . checkState ( ) ; return editor ; }
function eachParagraph ( editor , functor ) { var paragraphs = textileMode . getParagraphs ( editor ) , paragraphsLength = paragraphs . length ; for ( i = 0 ; i < paragraphsLength ; i ++ ) { paragraphs [ i ] = functor ( paragraphs [ i ] ) ; } textileMode . setParagraphs ( editor , paragraphs ) ; }
function pressedEnter ( editor ) { var list = editor . currentNodes . list , replacement ; if ( list && /(u|o)l/i . test ( list . tag ) ) { textileMode . getSelection ( editor ) ; if ( ME . holdShift ) { replacement = " <br> " ; } else { replacement = "\n" + listTypes [ list . tag ] + " " ; } textileMode . replaceSelection ( editor , replacement , false ) ; return false ; } }
function eachRegexp ( tags , callback ) { var i , item , items = { b : [ /<(?:b|strong)>((.|[\r\n])*?)<\/(?:b|strong)>/gi , '*' ] , i : [ /<(?:i|em)>((.|[\r\n])*?)<\/(?:i|em)>/gi , '_' ] , del : [ /<(?:strike|del)>((.|[\r\n])*?)<\/(?:strike|del)>/gi , '-' ] , u : [ /<(?:u|ins)>((.|[\r\n])*?)<\/(?:u|ins)>/gi , '+' ] } ; for ( i = tags . length ; i ; i -- ) { item = items [ tags [ i - 1 ] ] ; callback ( item [ 0 ] , item [ 1 ] ) ; } }
function ( regexp , d ) { content = content . replace ( regexp , function ( match , text ) { return d + text . replace ( /<br ?\/?>\s*/gi , d + "\n" + d ) + d ; } ) ; }
function ( match , uri , content ) { if ( /^\s*![^!]+!\s*$/ . test ( content ) ) { return $ . trim ( content ) + ":" + uri ; } else { return "\"" + content + "\":" + uri ; } }
function ( ) { textile . set ( "This\n\nThat" ) . selectAll ( ) . change ( ".formatBlock" , "h1" ) . match ( /h1. This/ ) . match ( /h1. That/ ) ; }
function ( filename , mid ) { var list = { "dojo/dojo.profile" : 1 , "dojo/package.json" : 1 , "dojo/OpenAjax" : 1 , "dojo/tests" : 1 , "dojo/tests/_base/loader/requirejs/requirejs-setup" : 1 , "dojo/tests/_base/loader/requirejs/dataMain" : 1 , "dojo/tests/_base/loader/requirejs/depoverlap" : 1 , "dojo/tests/_base/loader/requirejs/simple-tests" : 1 , "dojo/tests/_base/loader/requirejs/relative/relative-tests" : 1 , "dojo/tests/_base/loader/requirejs/exports/exports-tests" : 1 } ; return ( mid in list ) || /^dojo\/_base\/config\w+$/ . test ( mid ) || ( /^dojo\/resources\// . test ( mid ) && ! /\.css$/ . test ( filename ) ) || /(png|jpg|jpeg|gif|tiff)$/ . test ( filename ) ; }
function ( ) { for ( var i = 1 ; i < availableLocales . length ; i ++ ) { cache [ availableLocales [ i ] ] = current = lang . mixin ( lang . clone ( current ) , arguments [ i ] ) ; } var target = bundlePathAndName + "/" + locale ; cache [ target ] = current ; load && load ( lang . delegate ( current ) ) ; }
function ( id , toAbsMid ) { var match = nlsRe . exec ( id ) , bundlePath = match [ 1 ] ; return /^\./ . test ( bundlePath ) ? toAbsMid ( bundlePath ) + "/" + id . substring ( bundlePath . length ) : id ; }
function ( a , b ) { return this . call ( n , a , b || k ) } , n . getComputedStyle ) } "classList" in D || Object . defineProperty ( s , "classList" , { get : function ( ) { if ( this . tagName ) { var a = this . _ || ( this . _ = { } ) ; a . _ccl_ || ( a . _ccl_ = new K ( 0 , sa , ta , this ) ) ; return a . _ccl_ } }
function ( ) { this . _form . getWidget ( "server" ) . _setDisabledAttr ( false ) ; this . _form . getWidget ( "copyid" ) . _setDisabledAttr ( false ) ; this . _form . getWidget ( "create" ) . _setDisabledAttr ( false ) ; this . _form . getWidget ( "deploy" ) . _setDisabledAttr ( false ) ; this . _refreshLog ( ) ; }
function ( ) { var errorfields = pe . focus ( $ ( $ ( this ) . attr ( "href" ) ) ) ; if ( pe . mobile ) { $ . mobile . silentScroll ( errorfields . offset ( ) . top ) ; } }
function ( ) { $ ( this ) . attr ( "aria-selected" , "false" ) ; return $ ( "#" + $ ( this ) . attr ( "href" ) . substring ( 1 ) ) . attr ( "aria-hidden" , "true" ) ; }
function ( ) { $ ( this ) . attr ( "aria-selected" , "true" ) ; return $ ( "#" + $ ( this ) . attr ( "href" ) . substring ( 1 ) ) . attr ( "aria-hidden" , "false" ) ; }
function ( ) { return $current . focus ( ) ; }
function ( ) { var resp = this . httpGet ( this . siteUrl ) ; var newElem = this . userName = resp . body . querySelector ( "#nav-your-account .nav-button-title em" ) ; if ( newElem != null ) this . userName = newElem . textContent ; else this . userName = resp . body . querySelector ( ".navGreeting" ) . textContent . split ( ', ' ) [ 1 ] . slice ( 0 , - 1 ) ; }
function ( ) { jQuery ( "#hint" ) . switchClass ( "green" , "orange" ) . val ( "I'd like a hint" ) . data ( "buttonText" , false ) . stop ( true , true ) . appendTo ( "#get-hint-button-container" ) ; jQuery ( ".hint-box" ) . show ( ) ; }
function configureContext ( options ) { config = { lifecycleSteps : lifecycleSteps , pluginApi : pluginApi , resolvers : resolvers , facets : facets , listeners : listeners } ; lifecycle = new Lifecycle ( config ) ; resolver = new Resolver ( config ) ; contextHandlers = { init : array . delegate ( options . init ) , destroy : array . delegate ( options . destroy ) } ; }
function createItem ( val , name ) { var created ; if ( resolver . isRef ( val ) ) { created = resolveRef ( val , name ) ; } else if ( Array . isArray ( val ) ) { created = createArray ( val , name ) ; } else if ( object . isObject ( val ) ) { created = createModule ( val , name ) ; } else { created = val ; } return created ; }
function createProxy ( object , spec ) { var proxier , proxy , id , i ; i = 0 ; while ( ( proxier = proxiers [ i ++ ] ) && ! ( proxy = proxier ( object , spec ) ) ) { } proxy . target = object ; proxy . spec = spec ; if ( spec ) { id = spec && spec . id ; proxy . id = id ; proxy . path = createPath ( id ) ; proxiedComponents . push ( proxy ) ; } return proxy ; }
function ( context ) { var component = context . component ; assert . equals ( component . lifecycle , steps . slice ( 0 , steps . length - 3 ) ) ; context . destroy ( ) . then ( function ( ) { assert . equals ( component . lifecycle , steps ) ; } , fail ) . then ( done , done ) ; }
function ( done ) { wire ( { component : { module : './test/node/fixtures/object' } } ) . then ( function ( context ) { var component = context . component ; assert . equals ( component . lifecycle , steps . slice ( 0 , steps . length - 3 ) ) ; context . destroy ( ) . then ( function ( ) { assert . equals ( component . lifecycle , steps ) ; } , fail ) . then ( done , done ) ; } , fail ) ; }
function ( e ) { if ( e . stopPropagation ) { e . stopPropagation ( ) ; } return false ; }
function ( e ) { e . preventDefault ( ) ; droparea . removeChild ( img ) ; var reader = new FileReader ( ) ; reader . onload = function ( event ) { var image = new Image ( ) ; image . src = event . target . result ; image . width = 250 ; droparea . appendChild ( image ) ; } ; reader . readAsDataURL ( e . dataTransfer . files [ 0 ] ) ; console . log ( e . dataTransfer . files ) ; }
function ( sexp ) { return new lemur . Compiler ( ) . compile ( function ( ) { var prog , r ; setup_built_in_macros ( ) ; r = compile_runtime ( ) ; prog = sexp . _compile ( ) ; return "" + r + "\n" + prog ; } ) ; }
function ( ) { var a , b , body , c , _for ; a = arguments [ 0 ] , b = arguments [ 1 ] , c = arguments [ 2 ] , body = 4 <= arguments . length ? __slice . call ( arguments , 3 ) : [ ] ; return _for = new C . ForLoop ( { condition : [ a , b , c ] , body : body } ) ; }
function ( ) { var c_items ; c_items = compile_list ( arguments , null , true ) ; return "(" + ( c_items . join ( ',\n' ) ) + ")" ; }
function ( sexp ) { return new lemur . Compiler ( ) . compile ( function ( ) { var prog , r ; setup_built_in_macros ( ) ; r = compile_runtime ( ) ; prog = sexp . _compile ( ) ; return "" + r + "\n" + prog ; } ) ; }
function ( ) { var a , b , body , c , _for ; a = arguments [ 0 ] , b = arguments [ 1 ] , c = arguments [ 2 ] , body = 4 <= arguments . length ? __slice . call ( arguments , 3 ) : [ ] ; return _for = new C . ForLoop ( { condition : [ a , b , c ] , body : body } ) ; }
function ( ) { var c_items ; c_items = compile_list ( arguments , null , true ) ; return "(" + ( c_items . join ( ',\n' ) ) + ")" ; }
function ( sexp ) { return new lemur . Compiler ( ) . compile ( function ( ) { var prog , r ; setup_built_in_macros ( ) ; r = compile_runtime ( ) ; prog = sexp . _compile ( ) ; return "" + r + "\n" + prog ; } ) ; }
function ( args , env ) { var parts = Types . util . gatherArguments ( args , [ "expression" , "environment" ] , true ) , evalEnv = parts . environment . eval_ ( env ) ; expectEnvironment ( evalEnv , args , env ) ; return parts . expression . eval_ ( evalEnv ) ; }
function ( ) { var otherEnv = new Types . Env ( { "foo" : new Types . Int ( 4 ) } ) , evalEnv = new Types . Env ( { "other-env" : otherEnv } , [ Types . Env . makeGround ( ) ] ) ; Q . equal ( Squim . run ( '(eval foo other-env)' , evalEnv ) . value , 4 ) ; }
function ( specId , cache , entity ) { goog . events . EventTarget . call ( this ) ; this . entity_ = entity ; this . specId_ = specId ; this . cache_ = cache ; }
function ( req , res , next ) { var context = null ; var referrer = req . header ( 'Host' ) ; if ( referrer . indexOf ( "docs" ) > 0 ) { context = "docs" ; } else if ( referrer . indexOf ( "developer" ) > 0 ) { context = "developer" ; } res . local ( "context" , context ) ; next ( ) ; }
function ( ) { $ . pjax ( { selector : 'a[href^="http://"+location.host]' , container : '#content' , show : 'transparents' , cache : false , storage : false , titleSuffix : ' | Track My Memory' , fitler : function ( href ) { } , callback : function ( ) { } } ) }
function ( err , signedIntermediate ) { cert . sign ( user_kp . publicKey , { email : "john@root.com" } , { issuser : "intermediate.root.com" , issuedAt : new Date ( ) , expiresAt : expiration } , null , intermediate_kp . secretKey , function ( err , signedUser ) { signAssertion ( root_kp . publicKey , [ signedIntermediate , signedUser ] , user_kp ) ; } ) ; }
function ( ) { if ( Ext . isIE6 || Ext . isIE7 || Ext . isIE8 || ( Ext . isIE && this . document . documentMode < 9 ) ) { Ext . each ( this . config . customTags , function ( tag ) { this . document . createElement ( tag ) ; } , this ) ; } }
function ( ancestor ) { if ( Ext . isIE8 || Ext . isIE7 || Ext . isIE6 ) { isFullySelected = ( type !== 'Control' && ancestor . innerText == range . text ) || ( type === 'Control' && ancestor . innerText == range . item ( 0 ) . text ) ; } else { isFullySelected = ( ancestor . textContent == range . toString ( ) ) ; } if ( isFullySelected ) { node = ancestor ; return false ; } }
function ( toBeInserted ) { if ( Ext . isIE8 || Ext . isIE7 || Ext . isIE6 ) { this . insertHtml ( toBeInserted . outerHTML ) ; } else { var range = this . createRange ( ) ; range . deleteContents ( ) ; toBeSelected = ( toBeInserted . nodeType === HTMLArea . DOM . DOCUMENT_FRAGMENT_NODE ) ? toBeInserted . lastChild : toBeInserted ; range . insertNode ( toBeInserted ) ; this . selectNodeContents ( toBeSelected , false ) ; } return this ; }
function ( arr ) { arr = isArray ( arr [ 0 ] ) ? arr : [ arr ] ; if ( arr . length > 1 && arr [ 0 ] [ length ] > 1 ) { } else { return Math . sqrt ( jStat . dot ( arr , arr ) ) ; } }
function ( arr ) { var issymmetric = true , row = 0 , size = arr . length , col ; if ( arr . length !== arr [ 0 ] [ length ] ) return false ; for ( ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { if ( arr [ col ] [ row ] !== arr [ row ] [ col ] ) return false ; } } return true ; }
function ( alpha , beta ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . beta ( alpha , beta ) ; this . alpha = alpha ; this . beta = beta ; }
function ( local , scale ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . cauchy ( local , scale ) ; this . local = local ; this . scale = scale ; }
function ( dof ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . chisquare ( dof ) ; this . dof = dof ; }
function ( rate ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . exponential ( rate ) ; this . rate = rate ; }
function ( shape , scale ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . gamma ( shape , scale ) ; this . shape = shape ; this . scale = scale ; }
function ( alpha , beta ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . kumaraswamy ( alpha , beta ) ; this . alpha = alpha ; this . beta = beta ; }
function ( mu , sigma ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . lognormal ( mu , sigma ) ; this . mu = mu ; this . sigma = sigma ; }
function ( mean , std ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . normal ( mean , std ) ; this . mean = mean ; this . std = std ; }
function ( scale , shape ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . pareto ( scale , shape ) ; this . scale = scale ; this . shape = shape ; }
function ( dof ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . studentt ( dof ) ; this . dof = dof ; }
function ( scale , shape ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . weibull ( scale , shape ) ; this . scale = scale ; this . shape = shape ; }
function ( a , b ) { if ( ! ( this instanceof arguments . callee ) ) return new jStat . uniform ( a , b ) ; this . a = a ; this . b = b ; }
function onScroll ( ) { if ( throttle ) { return ; } throttle = setTimeout ( function ( ) { throttle = null ; } , 1000 / 60 ) ; var isHidden = window . scrollY < offset ; cloned [ isHidden ? 'setAttribute' : 'removeAttribute' ] ( 'hidden' , '' ) ; subnav . classList [ isHidden ? 'remove' : 'add' ] ( 'float' ) ; isHeaderVisible = isHidden ; resetSubnav ( ) ; return onScroll ; }
function ( ) { ++ cnt ; if ( cnt === totalImgs ) { $imgs . show ( ) ; $container . montage ( { liquid : true , fillLastRow : true , margin : 5 , fixedHeight : 140 , minw : 100 } ) ; if ( typeof callback === 'function' ) { callback ( ) ; } } }
function ( position ) { galleryContainer . css ( '-webkit-transform' , 'rotateY(15deg) translateX(' + ( - position ) + 'px)' ) ; rotatingTimeout = setTimeout ( function ( ) { galleryContainer . css ( '-webkit-transform' , 'rotateY(0deg) translateX(' + ( - position ) + 'px)' ) ; } , 800 ) ; }
function ( ) { var nextPageToLoad , movedToNextPage = FLICKR . gallery . moveToNextPage ( ) ; if ( movedToNextPage === false ) { pageToLoad = FLICKR . gallery . getTotalPages ( ) + 1 ; FLICKR . images . loadPhotos ( pageToLoad , function ( ) { FLICKR . gallery . moveToNextPage ( ) ; } ) ; } }
function ( ) { Firebug . Module . initializeUI . apply ( this , arguments ) ; if ( FBTrace . DBG_INITIALIZE ) FBTrace . sysout ( "StartButton.initializeUI;" ) ; }
function ( q ) { var data = Y . YUIDoc . meta [ self . get ( 'queryType' ) ] , out = [ ] ; Y . each ( data , function ( v ) { if ( v . toLowerCase ( ) . indexOf ( q . toLowerCase ( ) ) > - 1 ) { out . push ( v ) ; } } ) ; return out ; }
function ( keys ) { console . log ( 'get' ) ; return this . _storage [ keys ] ; }
function ( keys ) { var key ; if ( typeof keys === 'string' ) { console . log ( 'remove(String): ' , keys ) ; delete this . _storage [ keys ] ; } else if ( Helper . isArray ( keys ) ) { console . log ( 'remove(Array): ' , keys ) ; for ( key in keys ) { if ( keys . hasOwnProperty ( key ) ) { delete this . _storage [ keys [ key ] ] ; } } } }
function _createDir ( dir ) { dir = _templatePathName ( dir ) ; if ( existsSync ( dir ) ) { sys . puts ( 'dir exists:' + '  ' + dir ) ; } else { fs . mkdirSync ( dir ) ; sys . puts ( 'created dir: ' + '  ' + dir ) ; } }
function Mu_normalize ( context , name ) { var val = context [ name ] ; if ( typeof val === 'function' ) { val = val . call ( context ) ; } return typeof val === 'undefined' ? '' : val . toString ( ) ; }
function mHTML ( ) { var html = "<div id='more' style='clear:both;'> </h1>" + "tracklist :" + this . track1 + "<br/>" + "tracklist :" + this . track2 + "<br/>" + "tracklist :" + this . track3 + "<br/>" + "tracklist :" + this . track4 + "<br/>" + "tracklist :" + this . track5 + "</div>" ; return html ; }
function ( ) { var data = this . results . find ( ".select2-highlighted" ) . not ( ".select2-disabled" ) . closest ( '.select2-result-selectable' ) . data ( "select2-data" ) ; if ( data ) { this . onSelect ( data ) ; } }
function ( ) { var fs ; this . label = $ ( "<label class=\"im-con-overview\">\n</label>" ) ; this . fillConSummaryLabel ( ) ; this . $el . append ( this . label ) ; fs = $ ( "<fieldset class=\"im-constraint-options\"></fieldset>" ) . appendTo ( this . el ) ; this . drawOperatorSelector ( fs ) ; this . drawValueOptions ( ) ; this . addButtons ( ) ; return this ; }
function ( node ) { ModelMoon . prototype . setCurrentPlanet . call ( this , node ) ; this . setMetonYear ( this . currentPlanet . metonYear ) ; this . setMetonSynodicMonths ( this . currentPlanet . metonSynodicMonths ) ; this . setMetonDays ( this . currentPlanet . metonDays ) ; this . setMetonDraconiticMonths ( this . currentPlanet . metonDraconiticMonths ) ; }
function ( ) { this . draco = model . getDraconiticDaysPerMonth ( ) ; this . zodic = model . getZodicalDaysPerMonth ( ) ; model . sphere [ 1 ] . setSpeed ( this . moonSpeed1 ( this . draco , this . zodic ) ) ; model . sphere [ 2 ] . setSpeed ( this . moonSpeed2 ( this . draco , this . zodic ) ) ; model . sphere [ 3 ] . setSpeed ( 0 ) ; }
function ( params ) { params . name = "ModelSimple" ; params . spheres = 2 ; this . init ( params ) ; this . setAxisAngle0 = function ( angle ) { this . sphere [ 0 ] . setAxisAngle ( 90 - angle ) ; } this . updateHippo = function ( step ) { this . removeCurve ( 1 ) ; this . addCurve ( 1 , this . sphere [ 1 ] . curve , this . calcCurve ( 1 , "Planet" ) , colors [ "Hippo" ] ) ; } }
function ( file ) { var params = Url . parseURLParams ( file . href ) ; var result = params . map ( function ( o ) { return o . name + ": " + o . value ; } ) ; System . copyToClipboard ( result . join ( Str . lineBreak ( ) ) ) ; }
function show_server_message ( ) { if ( _RM_ . gw ) { var msg = 'Busy importing from google reader, refresh in a few seconds' ; notify . show_msg ( msg , 10000 ) ; _RM_ . gw = 0 ; } if ( _RM_ . ge ) { notify . show_msg ( 'Error import from google reader : ' + _RM_ . ge , 4000 ) ; _RM_ . ge = 0 ; } }
function ( ) { this . Container . removeClass ( "focused" ) ; this . Element . unbind ( "keydown" ) ; this . Open = false ; this . Container . removeClass ( "open" ) ; this . Container . find ( "datalist" ) . hide ( ) ; $ ( "body" ) . unbind ( "click" , this . BoundWindowClick ) ; }
function ( ) { localStorage . clear ( ) ; delete localStorage . customIcon ; chrome . browserAction . setIcon ( { path : 'icon.png' } ) ; dontLoad = true ; customIconPreview . src = 'icon.png' ; alert ( 'Neater Bookmarks has been reset.' ) ; location . reload ( ) ; }
function ( key , value ) { var el = value ; el . id = key ; el . repositoryId = that . repositoryId ; el . type = 'language' ; el . url = FlagIcons . path + '/img/flags/' + el . id + '.png' ; that . languageCodes . push ( new Aloha . RepositoryDocument ( el ) ) ; }
function ( feature ) { var place_id = feature . attributes . place_id place_ids . push ( place_id ) var place = plugin . places [ place_id ] var place_data = place . data if ( place_data . station_name != undefined ) { place_names . push ( place_data . station_name ) } else { place_names . push ( '(' + place_data . latitude + ',' + place_data . longitude + ')' ) } }
function hideticknums ( ) { for ( var i = 0 ; i < 3 ; i ++ ) { if ( hasaxes [ i ] ) { for ( var j = 0 ; j < ticknums [ i ] . length ; j ++ ) { ticknums [ i ] [ j ] . style . display = "none" ; } } } }
function unselect_metadata_file ( ) { selected_metadata_file = "" ; selected_libraries = [ ] ; document . getElementById ( "sel_md_pill" ) . className = "pill_incomplete" ; document . getElementById ( "icon_step_1" ) . style . display = "none" ; update_inbox ( ) ; check_submittable ( ) ; }
function ( err , t ) { if ( err ) return cb ( err ) ; tmpl . partials [ name ] = t . template ; _ . extend ( tmpl . partials , t . partials ) ; cb ( ) ; }
function ( name , cb ) { var pfile = path . join ( dir , name + ext ) , poptions = _ . clone ( options ) ; poptions . cacheKey = pfile ; getTemplate ( pfile , poptions , function ( err , t ) { if ( err ) return cb ( err ) ; tmpl . partials [ name ] = t . template ; _ . extend ( tmpl . partials , t . partials ) ; cb ( ) ; } ) ; }
function IE_diff_mode ( item ) { var patch = JsDiff . createPatch ( item . attr ( 'data-file-name' ) , $ ( '#old' ) . text ( ) , $ ( '#new' ) . text ( ) ) ; item . val ( patch ) ; item . attr ( 'readOnly' , true ) ; }
function ( ) { data . tags = [ ] ; data . quote = true ; details . set ( 'data' , data ) ; details . set ( 'eventSrc' , { origin : event . origin , source : event . source } ) ; }
function hello_world ( dom_id ) { var svg = d3 . select ( "#simple_svg" ) . append ( "svg" ) . attr ( "class" , "chart" ) . attr ( "width" , 500 ) . attr ( "height" , 500 ) ; cycle_through_animals ( function ( ) { random_set ( ) ; } , svg ) ; }
function ( ) { var $linkActionElement = $ ( this . getHtmlElement ( ) ) ; if ( ! this . getHtmlElement ( ) . is ( ':submit' ) ) { this . removeDisabledCssClass_ ; } var actionRequestUrl = this . getUrl ( ) ; if ( this . getHtmlElement ( ) . is ( 'a' ) && actionRequestUrl ) { $linkActionElement . attr ( 'href' , actionRequestUrl ) ; } this . unbind ( 'click' , this . noAction_ ) ; this . bindActionRequest ( ) ; }
function ( defaults ) { if ( defaults ) { this . loadNode ( function ( node ) { if ( defaults . hasOwnProperty ( node . value ) || defaults . hasOwnProperty ( node . id ) ) { node . check ( true ) ; } var i = node . children . length ; while ( i -- ) { node . children [ i ] . setDefault ( defaults ) ; } } ) ; } }
function ( defaults ) { if ( defaults ) { this . loadNode ( function ( node ) { if ( defaults . hasOwnProperty ( node . value ) || defaults . hasOwnProperty ( node . id ) ) { node . check ( true ) ; } var i = node . children . length ; while ( i -- ) { node . children [ i ] . setDefault ( defaults ) ; } } ) ; } }
function ( ) { var str = $ ( '#TB_iframeContent' ) . attr ( 'src' ) ; if ( str . indexOf ( "&field_id=" ) !== - 1 ) { $ ( '#TB_iframeContent' ) . contents ( ) . find ( '#tab-type_url' ) . hide ( ) ; } $ ( '#TB_iframeContent' ) . contents ( ) . find ( '.savesend .button' ) . val ( option_tree . upload_text ) ; }
function removeButtonCheck ( ) { var rows = $ ( '#smart-playlist-form' ) ; if ( rows . find ( 'select[name^="sp_criteria_field"]:enabled' ) . length == 1 ) { rows . find ( 'a[id="criteria_remove_0"]' ) . attr ( 'disabled' , 'disabled' ) ; rows . find ( 'a[id="criteria_remove_0"]' ) . hide ( ) ; } else { rows . find ( 'a[id="criteria_remove_0"]' ) . removeAttr ( 'disabled' ) ; rows . find ( 'a[id="criteria_remove_0"]' ) . show ( ) ; } }
function ( ) { if ( this . db && this . openLogSaves === 0 ) { this . db . close ( ) ; } else { var that = this ; setTimeout ( function ( ) { that . closeDb ( ) ; } , 100 ) ; } }
function ( param_settings ) { function uuidGenerator ( a , b ) { for ( b = a = '' ; a ++ < 36 ; b += a * 51 & 52 ? ( a ^ 15 ? 8 ^ Math . random ( ) * ( a ^ 20 ? 16 : 4 ) : 4 ) . toString ( 16 ) : '-' ) ; return b ; } this . uuid = uuidGenerator ( ) ; if ( param_settings ) { this . logTarget = param_settings . logTarget ; } }
function ( site_id , slug ) { site_id = parseInt ( site_id , 10 ) ; var feed = NEWSBLUR . reader . model . get_feed ( site_id ) ; if ( feed ) { NEWSBLUR . reader . open_feed ( site_id , { force : true } ) ; } else { NEWSBLUR . reader . load_feed_in_tryfeed_view ( site_id , { force : true , feed : { feed_title : _ . string . humanize ( slug ) } } ) ; } }
function ( models ) { if ( ! models || ! models . length ) { models = NEWSBLUR . assets . stories ; } if ( ! models . length ) return ; this . flags [ 'iframe_fetching_story_locations' ] = false ; this . flags [ 'iframe_story_locations_fetched' ] = false ; if ( NEWSBLUR . reader . flags [ 'story_titles_loaded' ] ) { NEWSBLUR . log ( [ 'iframe loaded, titles loaded (early)' ] ) ; this . fetch_story_locations_in_story_frame ( ) ; } else { this . prefetch_story_locations_in_story_frame ( ) ; } }
function ( ) { var keySet = Object . keys ( timeStampMap ) ; var minTimeStamp = Math . min . apply ( Math , keySet ) ; var minKey = timeStampMap [ minTimeStamp ] ; delete entries [ minKey ] ; delete timeStampMap [ minTimeStamp ] ; count -- ; }
function ( ) { gyroscopeAPI . watchID = setTimeout ( "gyroscopeObj.sample()" , gyroscopeAPI . options . frequency ) ; }
function ( orientation ) { gyroscopeAPI . data . timestamp = new Date ( ) . getTime ( ) ; gyroscopeAPI . data . alpha = orientation . alpha ; gyroscopeAPI . data . beta = orientation . beta ; gyroscopeAPI . data . gamma = orientation . gamma ; for ( i = 0 ; i < gyroscopeAPI . successCBs . length ; i ++ ) { gyroscopeAPI . successCBs [ i ] ( gyroscopeAPI . data ) ; } }
function ( onModuleReady ) { onModuleReady ( ) ; if ( butter . config . value ( "ui" ) . enabled !== false ) { var editorAreaDOMRoot = LangUtils . domFragment ( EDITOR_AREA_LAYOUT ) ; butter . ui . areas . editor = new butter . ui . Area ( "editor-area" , editorAreaDOMRoot ) ; document . body . classList . add ( "butter-editor-spacing" ) ; document . body . appendChild ( editorAreaDOMRoot ) ; } }
function ( ) { var bb = new BlobBuilder ; bb . append ( download ) ; var filesaver = saveAs ( bb . getBlob ( "text/html;charset=utf-8" ) , board . name + "_" + board . formatDate ( ) ( 'now' ) + ".html" ) ; }
function ( path ) { if ( typeof path !== "string" ) { console . log ( "String type is needed for file which is to be read." ) ; return false ; } var url = fsUtils . fs . root . toURL ( ) + path ; return url ; }
function ( model ) { var pass ; pass = this . test ( model ) && this . getParentCollection ( ) . test ( model ) ; if ( pass ) { this . safeAdd ( model ) ; } else { this . safeRemove ( model ) ; } return this ; }
function ( asset , error ) { if ( ! error ) { self . setValue ( asset ) ; } else { $ ( self . root ) . addClass ( 'error' ) ; self . $caption ( 'An error occurred' ) ; } self . _state = S_READY ; sefl . _unserializationData = null ; }
function createDefineBlock ( codeObject ) { var block = "<table class=\"Define\" style=\"background: " + colors . Define + ";\"" + "id=\"" + codeObject . id + "\">" ; block += "<tr><th><input id=\"name\"></th><th> : </th><th>" + generateTypeDrop ( ) + "</th><th> <button class=\"buttonPlus\">+</button> </th><th> -> </th><th>" + generateTypeDrop ( ) + "</th></th></tr>" ; block += "<tr><th>define</th>" ; block += "<th class=\"expr\"> <input type=\"Name\" id=\"Name\" name=\"Name\"/><th class=\"expr\">args <th  class=\"expr\">expr" ; return block + "</tr></table>" ; }
function ( event , ui ) { var itemIndex ; if ( ui . item . is ( 'span.draggable' ) ) { var replacement = $ ( '<li>' + carrying + '</li>' ) ; addDroppableFeature ( replacement . find ( '.droppable' ) ) ; ui . item . replaceWith ( replacement ) ; itemIndex = replacement . index ( ) ; } else { itemIndex = carrying . index ( ) ; } programCarrying = null ; carrying = null ; }
function ( event , ui ) { history . push ( program ) ; $ ( ui . item ) . remove ( ) ; for ( var i = 0 ; i < program . length ; i ++ ) { if ( program [ i ] . id === $ ( ui . item ) . id ) { program . splice ( i , 1 ) ; } } console . log ( program + "asdfasdf \n" ) ; console . log ( history ) ; }
function onStartEvent ( evt ) { evt . stopPropagation ( ) ; cardsView . addEventListener ( 'mousemove' , CardsView ) ; cardsView . addEventListener ( 'mouseup' , CardsView ) ; initialCardViewPosition = cardsView . scrollLeft ; initialTouchPosition = { x : evt . touches ? evt . touches [ 0 ] . pageX : evt . pageX , y : evt . touches ? evt . touches [ 0 ] . pageY : evt . pageY } ; }
function defaultPrefs ( ) { return { siteList : [ 'facebook.com' , 'youtube.com' , 'twitter.com' , 'myspace.com' , 'livejournal.com' , 'digg.com' , 'reddit.com' , 'kongregate.com' , 'newgrounds.com' , 'addictinggames.com' , 'hulu.com' ] , durations : { work : 25 * 60 , break : 5 * 60 } , shouldRing : true , clickRestarts : false , whitelist : false } }
function isLocationBlocked ( location ) { for ( var k in PREFS . siteList ) { listedPattern = parseLocation ( PREFS . siteList [ k ] ) ; if ( locationsMatch ( location , listedPattern ) ) { return ! PREFS . whitelist ; } } return PREFS . whitelist ; }
function ( code ) { var tableStart = '<table><tbody><tr><td class="gutter">' , lineNumbers = '<pre class="line-numbers">' , tableMiddle = '</pre></td><td class="code">' , tableEnd = '</td></tr></tbody></table>' , count = $ ( '.line' , code ) . length ; for ( var i = 1 ; i <= count ; i ++ ) { lineNumbers += '<span class="line-number">' + i + '</span>\n' ; } var table = tableStart + lineNumbers + tableMiddle + '<pre>' + $ ( 'pre' , code ) . html ( ) + '</pre>' + tableEnd ; $ ( code ) . html ( table ) ; }
function ( solutionId , handlerResponse ) { var unValued = fluid . model . transform ( handlerResponse , gpii . lifecycleManager . responseToSnapshotRules , { isomorphic : true } ) ; return unValued [ solutionId ] [ 0 ] ; }
function ( handlerSpec ) { var settingsHandlerPayload = gpii . lifecycleManager . specToSettingsHandler ( solutionId , handlerSpec ) ; var handlerResponse = fluid . invokeGlobalFunction ( handlerSpec . type , [ settingsHandlerPayload ] ) ; var settingsSnapshot = gpii . lifecycleManager . responseToSnapshot ( solutionId , handlerResponse ) ; var invariant = fluid . model . transform ( handlerSpec , gpii . lifecycleManager . invariantSettings ) ; return $ . extend ( true , { } , handlerSpec , settingsSnapshot ) ; }
function ( topic , params ) { suite . counter . events . unsubscribe ( { "handlerId" : handlerId } ) ; QUnit . deepEqual ( params . data , { "result" : "error" , "errorCode" : "more_than" , "errorMessage" : 5000 , "liveUpdatesTimeout" : NaN } , 'Checking the restrictions of the count API. Error: "more_than"' ) ; QUnit . ok ( $ ( params . target ) . html ( ) === "<span>5000+</span>" , 'Checking the Error: "more_than" usecase rendering' ) ; callback ( ) ; }
function ( assert ) { var str = auth . stringToSign ( { verb : 'PUT' , md5 : '09c68b914d66457508f6ad727d860d5b' , contentType : 'text/plain' , resource : '/learnboost' , date : new Date ( 'Mon, May 25 1987 00:00:00 GMT' ) } ) ; var expected = [ 'PUT' , '09c68b914d66457508f6ad727d860d5b' , 'text/plain' , new Date ( 'Mon, May 25 1987 00:00:00 GMT' ) . toUTCString ( ) , '/learnboost' ] . join ( '\n' ) ; assert . equal ( expected , str ) ; }
function ( assert ) { var str = auth . sign ( { verb : 'PUT' , secret : 'test' , md5 : '09c68b914d66457508f6ad727d860d5b' , contentType : 'text/plain' , resource : '/learnboost' , date : new Date ( 'Mon, May 25 1987 00:00:00 GMT' ) } ) ; assert . equal ( '7xIdjyy+W17/k0le5kwBnfrZTiM=' , str ) ; }
function ( assert ) { var str = auth . canonicalizeHeaders ( { 'X-Amz-Date' : 'some date' , 'X-Amz-Acl' : 'private' , 'X-Foo' : 'bar' } ) ; var expected = [ 'x-amz-acl:private' , 'x-amz-date:some date' ] . join ( '\n' ) ; assert . equal ( expected , str ) ; assert . equal ( '' , auth . canonicalizeHeaders ( { } ) ) ; }
function ( assert ) { var client = knox . createClient ( { key : 'foobar' , secret : 'baz' , bucket : 'misc' } ) ; assert . equal ( 'foobar' , client . key ) ; assert . equal ( 'baz' , client . secret ) ; assert . equal ( 'misc' , client . bucket ) ; assert . equal ( 's3.amazonaws.com' , client . endpoint ) ; }
function ( assert , done ) { var n = 0 ; client . putFile ( jsonFixture , '/test/user2.json' , function ( err , res ) { assert . ok ( ! err , 'putFile() got an error!' ) ; assert . equal ( 200 , res . statusCode ) ; client . get ( '/test/user2.json' ) . on ( 'response' , function ( res ) { assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) ; done ( ) ; } ) . end ( ) ; } ) ; }
function ( res ) { assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'http://' + client . endpoint + '/' + client . bucket + '/test/user.json' , client . url ( '/test/user.json' ) ) ; assert . equal ( 'http://' + client . endpoint + '/' + client . bucket + '/test/user.json' , req . url ) ; done ( ) ; }
function ( assert , done ) { var stream = fs . createReadStream ( jsonFixture ) ; client . putStream ( stream , '/test/user.json' , function ( err , res ) { assert . ok ( ! err ) ; if ( 100 !== res . statusCode ) assert . equal ( 200 , res . statusCode ) ; done ( ) ; } ) ; }
function ( assert , done ) { client . getFile ( '/test/user.json' , function ( err , res ) { assert . ok ( ! err ) ; assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) assert . equal ( 13 , res . headers [ 'content-length' ] ) done ( ) ; } ) ; }
function ( assert , done ) { client . get ( '/test/user.json' ) . on ( 'response' , function ( res ) { assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) assert . equal ( 13 , res . headers [ 'content-length' ] ) done ( ) ; } ) . end ( ) ; }
function ( assert , done ) { client . head ( '/test/user.json' ) . on ( 'response' , function ( res ) { assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) assert . equal ( 13 , res . headers [ 'content-length' ] ) done ( ) ; } ) . end ( ) ; }
function ( assert , done ) { client . headFile ( '/test/user.json' , function ( err , res ) { assert . ok ( ! err ) ; assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) assert . equal ( 13 , res . headers [ 'content-length' ] ) done ( ) ; } ) ; }
function writeText ( view , value ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; if ( typeof value !== "string" ) value = JSON . stringify ( value ) ; view . text ( value ) ; view . html ( view . html ( ) . replace ( /\n/g , "<br />" ) ) ; }
function ( ) { var argString = "This is a string we'll send into and back from the dialog: " + ( new Date ( ) ) . toString ( ) ; WinChan . open ( { url : "cases/basic/child.html" , relay_url : "/relay.html" , window_features : "width=700,height=375" , params : argString } , function ( err , resp ) { equal ( resp , argString ) ; start ( ) ; } ) ; }
function ( ) { for ( var terrainName in TerrainDefinitions ) { var terrainDef = TerrainDefinitions [ terrainName ] ; var terrain = new Terrain ( ) ; var numSprites = terrainDef . Sprites . length ; for ( var i = 0 ; i < numSprites ; i ++ ) { terrain . _entities [ i ] = Crafty . e ( "2D, " + terrainDef . Sprites [ i ] ) ; } this [ terrainName ] = terrain ; } }
function removePopUp ( $popUp ) { var index = _popUps . indexOf ( $popUp [ 0 ] ) , initiallyInDOM = $popUp . data ( "initiallyInDOM" ) , removeHandler = $popUp . data ( "removeHandler" ) ; if ( index >= 0 ) { _removePopUp ( $popUp , index ) ; } }
function ( e , flag , group ) { var $inputs = ( group && group . length ) ? group : $labels . find ( 'input' ) ; $inputs . not ( ':disabled' ) . attr ( 'checked' , ( flag ? 'checked' : '' ) ) ; updateSelected ( ) ; }
function ( tab ) { var _i , _len , _ref , _tab ; _ref = $scope . tabs ; for ( _i = 0 , _len = _ref . length ; _i < _len ; _i ++ ) { _tab = _ref [ _i ] ; _tab . selected ( false ) ; } tab . selected ( true ) ; $scope . selectedTab = tab ; return $scope . selectedIdx = $scope . tabs . indexOf ( tab ) ; }
function ( scope , elm , attrs , container ) { var tab ; tab = { title : scope . title , selected : function ( newVal ) { if ( newVal == null ) return scope . selected ; return scope . selected = newVal ; } } ; container . addTab ( tab ) ; return scope . $on ( '$destroy' , function ( ) { return container . removeTab ( tab ) ; } ) ; }
function ( msg , line , id ) { var fileName = id . split ( '/' ) ; console . log ( fileName [ fileName . length - 1 ] + ', ' + line + ': ' + msg ) ; }
function ( table , td , cellIndex , rec , tr , rowIndex ) { if ( rec . get ( 'data' + cellIndex ) ) { rec . data [ 'data' + cellIndex ] = 3 ; Ext . Msg . alert ( ':(' , 'kaboooom!.' ) ; } else { rec . data [ 'data' + cellIndex ] = 4 ; } table . refresh ( ) ; }
function ( streamItem ) { return - parseInt ( streamItem . get ( 'CreatedDateTimeOrder' ) ) ; }
function ( id , option ) { var html = '<label><input style="display:none;" type="checkbox" name="' + id + '[]" value="' + option . value + '"' ; if ( option . selected ) { html += ' checked="checked"' ; } var project = app . authenticatedUser . projects . get ( option . value ) ; html += ' /><img src="' + project . get ( 'Avatar' ) . Files . thumbnail . RelativeUri + '" alt="" />' + project . get ( 'Name' ) + '</label>' ; return html ; }
function ( option ) { var project = app . authenticatedUser . projects . get ( option . value ) ; $selectedHtml . append ( '<span class="selected-project"><img src="' + project . get ( 'Avatar' ) . Files . thumbnail . RelativeUri + '" alt="" />' + option . text + '</span> ' ) ; }
function ( collectionView , itemView ) { collectionView . $el . find ( '#' + this . type + '-menu-group-list' ) . append ( itemView . el ) ; }
function ( group ) { if ( group . Id == this . model . id ) { this . activityCount ++ ; if ( this . activityCount == 1 ) { this . $el . find ( 'p' ) . append ( '<span title=""></span>' ) ; } var title = this . activityCount . toString ( ) + ' New Item' + ( this . activityCount > 1 ? 's' : '' ) ; this . $el . find ( 'p span' ) . text ( this . activityCount ) . attr ( 'title' , title ) ; } }
function ( $ , _ , Backbone ) { var Project = Backbone . Model . extend ( { defaults : { Name : '' , Description : '' , Website : '' , AvatarId : null , TeamId : null , Type : 'Project' } , idAttribute : 'Id' , urlRoot : '/projects' , setAvatar : function ( mediaResource ) { this . set ( 'AvatarId' , mediaResource . id ) ; } } ) ; return Project ; }
function ( streamItem ) { return - parseInt ( streamItem . get ( 'CreatedDateTimeOrder' ) ) ; }
function ( e , data ) { log ( 'editAvatarView:_onUploadDone' ) ; this . model . set ( 'AvatarId' , data . result . Id ) ; var mediaResource = new MediaResource ( data . result ) ; $ ( '#avatar-viewer' ) . empty ( ) . append ( '<img src="' + mediaResource . get ( 'Files' ) . medium . RelativeUri + '" width="200px;" />' ) ; }
function ( id , option ) { var html = '<label><input style="display:none;" type="checkbox" name="' + id + '[]" value="' + option . value + '"' ; if ( option . selected ) { html += ' checked="checked"' ; } var project = app . authenticatedUser . projects . get ( option . value ) ; html += ' /><img src="' + project . get ( 'Avatar' ) . Files . thumbnail . RelativeUri + '" alt="" />' + project . get ( 'Name' ) + '</label>' ; return html ; }
function ( option ) { var project = app . authenticatedUser . projects . get ( option . value ) ; $selectedHtml . append ( '<span class="selected-project"><img src="' + project . get ( 'Avatar' ) . Files . thumbnail . RelativeUri + '" alt="" />' + option . text + '</span> ' ) ; }
function ( model ) { var project = new Project ( model . Project ) ; log ( 'HACK: injected projects/ into project id value' ) ; project . set ( 'Id' , 'projects/' + id ) ; var projectLayoutView = new ProjectLayoutView ( { model : project } ) ; app . showFormContentView ( projectLayoutView , 'projects' ) ; if ( app . isPrerendering ( 'projects' ) ) { projectLayoutView . showBootstrappedDetails ( ) ; } projectLayoutView . showStream ( ) ; app . setPrerenderComplete ( ) ; }
function ( collectionView , itemView ) { collectionView . $el . find ( '#' + this . type + '-menu-group-list' ) . append ( itemView . el ) ; }
function ( group ) { if ( group . Id == this . model . id ) { this . activityCount ++ ; if ( this . activityCount == 1 ) { this . $el . find ( 'p' ) . append ( '<span title=""></span>' ) ; } var title = this . activityCount . toString ( ) + ' New Item' + ( this . activityCount > 1 ? 's' : '' ) ; this . $el . find ( 'p span' ) . text ( this . activityCount ) . attr ( 'title' , title ) ; } }
function ( model ) { var project = new Project ( model . Project ) ; log ( 'HACK: injected projects/ into project id value' ) ; project . set ( 'Id' , 'projects/' + id ) ; var projectLayoutView = new ProjectLayoutView ( { model : project } ) ; app . showFormContentView ( projectLayoutView , 'projects' ) ; if ( app . isPrerendering ( 'projects' ) ) { projectLayoutView . showBootstrappedDetails ( ) ; } projectLayoutView . showStream ( ) ; app . setPrerenderComplete ( ) ; }
function ( $ , _ , Backbone ) { var Project = Backbone . Model . extend ( { defaults : { Name : '' , Description : '' , Website : '' , AvatarId : null , TeamId : null , Type : 'Project' } , idAttribute : 'Id' , urlRoot : '/projects' , setAvatar : function ( mediaResource ) { this . set ( 'AvatarId' , mediaResource . id ) ; } } ) ; return Project ; }
function ( e , data ) { log ( 'editAvatarView:_onUploadDone' ) ; this . model . set ( 'AvatarId' , data . result . Id ) ; var mediaResource = new MediaResource ( data . result ) ; $ ( '#avatar-viewer' ) . empty ( ) . append ( '<img src="' + mediaResource . get ( 'Files' ) . medium . RelativeUri + '" width="200px;" />' ) ; }
function ( e ) { if ( ! e . metaKey && ! e . ctrlKey ) { e . preventDefault ( ) ; _gat . _getTrackerByName ( ) . _trackEvent ( this . href , "Outbound Links" ) ; setTimeout ( "document.location = '" + this . href + "'" , 100 ) ; } }
function ( req , res , next ) { metrics . userEntry ( req ) ; renderCachableView ( req , res , 'dialog.ejs' , { title : _ ( 'A Better Way to Sign In' ) , layout : 'dialog_layout.ejs' , useJavascript : true , production : config . get ( 'use_minified_resources' ) } ) ; }
function new_video_player ( video_src ) { var params = { allowScriptAccess : "always" } ; var atts = { id : "player" } ; swfobject . embedSWF ( video_src , "player_container" , "800" , "500" , "8" , null , null , params , atts ) ; }
function onytplayerStateChange ( newState ) { if ( playlist_mode == "on" ) { if ( newState == 0 ) { video_src = getNextVideoFromPlaylist ( ) ; if ( video_src != null ) { console . log ( "im here" ) ; video_player . loadVideoByUrl ( video_src ) ; } } } }
function escape_ ( s ) { if ( typeof s === undefined ) { return ; } return s . replace ( /&/g , '&amp;' ) . replace ( />/g , '&gt;' ) . replace ( /</g , '&lt;' ) . replace ( /'/g , '&#39;' ) . replace ( /"/g , '&#34;' ) ; }
function ( ) { mqb . version = '1.3.4' ; mqb . mqList = [ ] ; mqb . matchMedia = window . matchMedia !== undefined ; var bookmarklet = document . getElementById ( 'sb-mediaQueryBookmarklet' ) ; if ( bookmarklet ) { document . body . removeChild ( bookmarklet ) ; } }
function ( ) { document . getElementById ( 'dimensions' ) . innerHTML = document . width + 'px x ' + document . height + 'px<br>' + ( document . width / this . findEmSize ( ) ) . toPrecision ( 4 ) + 'em x ' + ( document . height / this . findEmSize ( ) ) . toPrecision ( 4 ) + 'em' ; }
function ( ) { console . log ( "course user" ) ; Notification . sync ( ) . success ( function ( ) { console . log ( "notification user" ) ; CourseMember . sync ( ) . success ( function ( ) { console . log ( "coursememeber user" ) ; UserNotification . sync ( ) . success ( function ( ) { if ( callback ) { callback ( ) ; } } ) ; } ) ; } ) ; }
function ( xml ) { xml = $ ( xml ) setTimeout ( function ( ) { $ ( ".carnetSave" ) . val ( "Enregistrer" ) } , 5000 ) ; if ( xml . find ( "exception" ) . text ( ) != "" ) { if ( ! silent ) alert ( ">" + xml . find ( "exception" ) . text ( ) + "<" ) $ ( ".carnetSave" ) . val ( "Error..." ) } autoSaveLocal ( ) $ ( ".carnetSave" ) . val ( "Saved!" ) }
function _reset ( id , name , category , title_color , title_subs ) { var cat = category . replace ( / /g , "_" ) . toLowerCase ( ) , $ul = $ ( ".legend ul." + cat ) ; $ul . find ( "li" ) . remove ( ) ; _add ( id , name , category , title_color , title_subs ) ; }
function _toggleItem ( id , name , category , title_color , title_subs , add ) { add ? _add ( id , name , category , title_color , title_subs ) : _remove ( id , name , category ) ; if ( GFW && GFW . app . infowindow ) { GFW . app . infowindow . close ( ) ; } }
f var ws = new WebSocket ( 'ws://localhost:' + port ) ; ws . terminate ( ) ; ws . on ( 'open' , function ( ) { assert . fail ( 'connect shouldnt be raised here' ) ; } ) ; ws . on ( 'close' , function ( ) { srv . close ( ) ; done ( ) ; } ) ; } ) ;
function ( row ) { var $ministat ; $ministat = $ ( this ) . children ( 'td.title' ) . children ( '.ministat' ) ; $ministat . css ( "background-color" , bgColors [ row ] ) ; return $ministat . children ( '.minibar' ) . css ( "background-color" , colors [ row ] ) ; }
function ( ) { $ ( "#path-information" ) . addClass ( "hidden" ) ; $ ( "#path-edit-div" ) . removeClass ( "hidden" ) ; var pathName = $ ( "#path-name" ) . text ( ) . trim ( ) ; var pathDescription = $ ( "#path-description" ) . text ( ) . trim ( ) ; $ ( "#path-edit-name-text" ) . val ( pathName ) ; $ ( "#path-edit-description-text" ) . val ( pathDescription ) ; $ ( "#path-edit-name-text" ) . focus ( ) ; return false ; }
function ( e ) { var newInput = template . clone ( ) ; var arrayI = newInput . get ( 'name' ) . match ( /.+?\[(\d+)\].+/ ) ; if ( arrayI && arrayI [ 1 ] ) { current_nr += 1 ; newInput . set ( 'name' , newInput . get ( 'name' ) . replace ( /(.+?\[)\d+(\].+)/ , '$1' + ( parseInt ( arrayI [ 1 ] , 10 ) + current_nr ) + '$2' ) ) ; } newInput . inject ( e . target , 'before' ) ; }
function ( valueAsDate ) { if ( ! valueAsDate ) { return ; } var me = this ; me . valueAsDate = valueAsDate ; me . getLayer ( ) . _controlMap . monthview . setValueAsDate ( valueAsDate ) ; baidu . g ( me . __getId ( 'text' ) ) . innerHTML = baidu . date . format ( valueAsDate , me . dateFormat ) ; }
function ( ) { if ( this . config . get ( "endpoint" ) === "submit" ) { return this . transport . _getScheme ( ) + this . config . get ( "submissionProxyURL" ) ; } return this . constructor . parent . _prepareURL . call ( this ) ; }
function ( location ) { for ( var i in this . resolvedLocations ) { var l = this . resolvedLocations [ i ] ; if ( l . url === location . url && l . lineNumber === location . lineNumber && l . columnNumber === location . columnNumber ) return true ; } return false ; }
function ( filename ) { if ( filename == null ) { return null ; } let fileTypeRex = /^[^?&]*(\.[a-z0-9]+)([?&].*)?$/i ; let type = ".jpg" ; if ( fileTypeRex . test ( filename ) ) { type = filename . replace ( fileTypeRex , "$1" ) ; } return type ; }
function ( ) { $ ( '#f1' ) . val ( "New value" ) ; $ ( '#f1' ) . change ( ) ; equal ( $ ( '#f1' ) . val ( ) , "New value" , "Value should be changed to 'New value'." ) ; ok ( ! $ ( '#f1' ) . hasClass ( 'example' ) , "The example class should no longer be set." ) ; $ ( '#f1' ) . val ( '' ) ; }
function ( ) { var sel = $ ( this ) , d = sel . data ( 'freetrans' ) ; if ( d ) { _setOptions ( sel , options ) ; _draw ( sel ) ; if ( safari ) _safari ( sel ) ; } else { _init ( sel , options ) ; _draw ( sel ) ; } }
function ( pixelScores , rLeft , rWidth , score ) { var iend = rLeft + rWidth ; for ( var i = rLeft ; i < iend ; i ++ ) { pixelScores [ i ] = Math . max ( pixelScores [ i ] || - Infinity , score ) ; } }
function ( ) { var cartesian = new Cartesian3 ( 2.0 , 0.0 , 0.0 ) . normalize ( ) ; expect ( cartesian . x ) . toEqual ( 1.0 ) ; expect ( cartesian . y ) . toEqual ( 0.0 ) ; expect ( cartesian . z ) . toEqual ( 0.0 ) ; }
function ( ) { var v = new Cartesian4 ( ) ; expect ( v . x ) . toEqual ( 0 ) ; expect ( v . y ) . toEqual ( 0 ) ; expect ( v . z ) . toEqual ( 0 ) ; expect ( v . w ) . toEqual ( 0 ) ; }
function ( ) { var v = new Cartesian4 ( 1 ) ; expect ( v . x ) . toEqual ( 1 ) ; expect ( v . y ) . toEqual ( 0 ) ; expect ( v . z ) . toEqual ( 0 ) ; expect ( v . w ) . toEqual ( 0 ) ; }
function ( ) { var v = new Cartesian4 ( 1 , 2 ) ; expect ( v . x ) . toEqual ( 1 ) ; expect ( v . y ) . toEqual ( 2 ) ; expect ( v . z ) . toEqual ( 0 ) ; expect ( v . w ) . toEqual ( 0 ) ; }
function ( ) { var v = new Cartesian4 ( 1 , 2 , 3 ) ; expect ( v . x ) . toEqual ( 1 ) ; expect ( v . y ) . toEqual ( 2 ) ; expect ( v . z ) . toEqual ( 3 ) ; expect ( v . w ) . toEqual ( 0 ) ; }
function ( ) { var v = new Cartesian4 ( 1 , 2 , 3 , 4 ) ; expect ( v . x ) . toEqual ( 1 ) ; expect ( v . y ) . toEqual ( 2 ) ; expect ( v . z ) . toEqual ( 3 ) ; expect ( v . w ) . toEqual ( 4 ) ; }
function ( ) { var v = Cartesian4 . ZERO ; expect ( v . x ) . toEqual ( 0 ) ; expect ( v . y ) . toEqual ( 0 ) ; expect ( v . z ) . toEqual ( 0 ) ; expect ( v . w ) . toEqual ( 0 ) ; }
function ( ) { var v = Cartesian4 . UNIT_X ; expect ( v . x ) . toEqual ( 1 ) ; expect ( v . y ) . toEqual ( 0 ) ; expect ( v . z ) . toEqual ( 0 ) ; expect ( v . w ) . toEqual ( 0 ) ; }
function ( ) { var v = Cartesian4 . UNIT_Y ; expect ( v . x ) . toEqual ( 0 ) ; expect ( v . y ) . toEqual ( 1 ) ; expect ( v . z ) . toEqual ( 0 ) ; expect ( v . w ) . toEqual ( 0 ) ; }
function ( ) { var v = Cartesian4 . UNIT_W ; expect ( v . x ) . toEqual ( 0 ) ; expect ( v . y ) . toEqual ( 0 ) ; expect ( v . z ) . toEqual ( 0 ) ; expect ( v . w ) . toEqual ( 1 ) ; }
function ( ) { var v = new Cartesian4 ( 1 , 2 , 3 , 4 ) . multiplyComponents ( new Cartesian4 ( 5 , 6 , 7 , 8 ) ) ; expect ( v . equals ( new Cartesian4 ( 5 , 12 , 21 , 32 ) ) ) . toEqual ( true ) ; }
function ( ) { var v = new Cartesian4 ( 1 , 2 , 3 , 4 ) ; expect ( v . getMinimumComponent ( ) ) . toEqual ( 1 ) ; }
function ( sphere , plane ) { var center = sphere . center ; var radius = sphere . radius ; var distanceToPlane = plane . getXYZ ( ) . dot ( center ) + plane . w ; if ( distanceToPlane < - radius ) { return Intersect . OUTSIDE ; } else if ( distanceToPlane < radius ) { return Intersect . INTERSECTING ; } return Intersect . INSIDE ; }
function ( other ) { return this . x * other . x + this . y * other . y + this . z * other . z + this . w * other . w ; }
function ( ellipsoid , origin ) { var o = Cartesian3 . clone ( origin ) ; var eastNorthUp = Transforms . eastNorthUpToFixedFrame ( o , ellipsoid ) ; this . origin = o ; this . xAxis = eastNorthUp . getColumn0 ( ) . getXYZ ( ) ; this . yAxis = eastNorthUp . getColumn1 ( ) . getXYZ ( ) ; this . normal = eastNorthUp . getColumn2 ( ) . getXYZ ( ) ; this . d = - o . dot ( o ) ; this . ellipsoid = ellipsoid ; }
function ( value ) { var interp = position . lerp ( newPosition , value . time ) ; var pos = new Cartesian4 ( interp . x , interp . y , interp . z , 1.0 ) ; camera . position = camera . getInverseTransform ( ) . multiplyWithVector ( pos ) . getXYZ ( ) ; }
function ( key , _default ) { var keys = key . split ( '.' ) , pt = this . __attributes ; _ . each ( keys , function ( key ) { if ( pt === undefined ) { return _default ; } pt = pt [ key ] ; } ) ; return _ . isUndefined ( pt ) ? _default : pt ; }
function ( ) { me . __dataview = this ; callback ( this ) ; if ( me . __datasetLoadedCallbacks ) { for ( var i = 0 ; i < me . __datasetLoadedCallbacks . length ; i ++ ) { me . __datasetLoadedCallbacks [ i ] ( me ) ; } } }
function ( callback ) { var me = this ; if ( ! me . __datasetLoadedCallbacks ) me . __datasetLoadedCallbacks = [ ] ; me . __datasetLoadedCallbacks . push ( callback ) ; }
function ( viewModel ) { var unwrapped = ko . utils . unwrapObservable ( viewModel ) ; return unwrapped && unwrapped [ mappingProperty ] ; }
function ( x ) { if ( ( x ) && ( typeof ( x ) === "object" ) ) { if ( x . constructor == ( new Date ) . constructor ) return "date" ; if ( x . constructor == ( new Array ) . constructor ) return "array" ; } return typeof x ; }
function ( obj , data ) { var params = { data : data || callbackParams . data , parent : callbackParams . parent , target : ko . utils . unwrapObservable ( obj ) } ; if ( ko . isWriteableObservable ( obj ) ) { params . observable = obj ; } return getCallback ( "update" ) ( params ) ; }
function ( item ) { return mapKey ( item , callback ) === key ; }
function visitPropertiesOrArrayEntries ( rootObject , visitorCallback ) { if ( rootObject instanceof Array ) { for ( var i = 0 ; i < rootObject . length ; i ++ ) visitorCallback ( i ) ; } else { for ( var propertyName in rootObject ) visitorCallback ( propertyName ) ; } }
function getPropertyName ( parentName , parent , indexer ) { var propertyName = parentName || "" ; if ( parent instanceof Array ) { if ( parentName ) { propertyName += "[" + indexer + "]" ; } } else { if ( parentName ) { propertyName += "." ; } propertyName += indexer ; } return propertyName ; }
function ( viewModel ) { var unwrapped = ko . utils . unwrapObservable ( viewModel ) ; return unwrapped && unwrapped [ mappingProperty ] ; }
function ( x ) { if ( ( x ) && ( typeof ( x ) === "object" ) ) { if ( x . constructor == ( new Date ) . constructor ) return "date" ; if ( x . constructor == ( new Array ) . constructor ) return "array" ; } return typeof x ; }
function ( obj , data ) { var params = { data : data || callbackParams . data , parent : callbackParams . parent , target : ko . utils . unwrapObservable ( obj ) } ; if ( ko . isWriteableObservable ( obj ) ) { params . observable = obj ; } return getCallback ( "update" ) ( params ) ; }
function ( item ) { return mapKey ( item , callback ) === key ; }
function visitPropertiesOrArrayEntries ( rootObject , visitorCallback ) { if ( rootObject instanceof Array ) { for ( var i = 0 ; i < rootObject . length ; i ++ ) visitorCallback ( i ) ; } else { for ( var propertyName in rootObject ) visitorCallback ( propertyName ) ; } }
function getPropertyName ( parentName , parent , indexer ) { var propertyName = parentName || "" ; if ( parent instanceof Array ) { if ( parentName ) { propertyName += "[" + indexer + "]" ; } } else { if ( parentName ) { propertyName += "." ; } propertyName += indexer ; } return propertyName ; }
function ( e ) { e . stop ( ) ; var el = this , co = el . getCoordinates ( ) ; el [ getFirst ] ( ) . setStyles ( { left : co . left , top : co . top , width : co . width , height : 24 , backgroundColor : '#E1F1FD' , textAlign : 'center' , display : 'block' , zIndex : 10 } ) . tween ( 'backgroundColor' , '#1096E6' ) }
function ( message ) { var complete = this . running ; if ( message ) this . message = message ; this [ fireEvent ] ( 'cancel' , this ) ; if ( complete ) this [ fireEvent ] ( 'complete' , this ) ; delete this . message ; this [ element ] . destroy ( ) }
function ( value ) { if ( progress && progress . setValue ) progress . setValue ( value ) ; if ( value == 1 ) { field [ getElement ] ( 'label' ) [ set ] ( { text : file . name . shorten ( ) + ' (' + this . size [ toFileSize ] ( ) + ')' , title : file . name } ) ; field . style . display = '' } }
function ( ) { this [ element ] [ getElement ] ( '[type=hidden][disabled]' ) [ set ] ( { disabled : false , value : this . guid } ) }
function ( ) { if ( this . options . pause ) pause . style . display = '' } , success : function ( ) { pause . destroy ( ) } } ) [ element ] . getLast ( '.pause-upload' ) [ addEvent ] ( 'click' , function ( e ) {
function ( ) { this . paused = true ; this [ element ] [ getElement ] ( '.pause-upload' ) . addClass ( 'resume-upload' ) [ set ] ( 'text' , Locale [ get ] ( 'uploadManager.RESUME' ) ) . style . display = '' ; this [ fireEvent ] ( 'pause' , this ) }
function ( ) { this . paused = false ; this . failed = 0 ; this [ element ] [ getElement ] ( '.pause-upload' ) . removeClass ( 'resume-upload' ) [ set ] ( 'text' , Locale [ get ] ( 'uploadManager.PAUSE' ) ) . style . display = this . options . pause ? '' : 'none' ; this [ fireEvent ] ( 'resume' , this ) . upload ( ) }
function ( units ) { if ( this == 0 ) return 0 ; var s = [ 'bytes' , 'kb' , 'MB' , 'GB' , 'TB' , 'PB' ] , e = Math . floor ( Math . log ( this ) / Math . log ( 1024 ) ) ; return ( this / Math . pow ( 1024 , Math . floor ( e ) ) ) . toFixed ( 2 ) + " " + ( units && units [ e ] ? units [ e ] : s [ e ] ) ; }
function ( e ) { tab . screenshot = e . target . result ; if ( ! isCurrentTab ) { this . setTabVisibility ( tab , false ) ; } if ( this . currentScreen === this . TABS_SCREEN ) { this . showTabScreen ( ) ; } }
function browser_navigate ( url ) { this . showPageScreen ( ) ; this . currentTab . title = null ; this . currentTab . url = url ; this . currentTab . dom . setAttribute ( 'src' , url ) ; this . urlInput . value = url ; }
function browser_urlFocus ( e ) { if ( this . currentScreen === this . PAGE_SCREEN ) { this . urlInput . value = this . currentTab . url ; this . shouldFocus = true ; this . showAwesomeScreen ( ) ; } else if ( this . currentScreen === this . AWESOME_SCREEN ) { this . shouldFocus = true ; } }
function browser_setUrlButtonMode ( mode ) { this . urlButtonMode = mode ; switch ( mode ) { case this . GO : this . urlButton . style . backgroundImage = 'url(style/images/go.png)' ; break ; case this . REFRESH : this . urlButton . style . backgroundImage = 'url(style/images/refresh.png)' ; break ; case this . STOP : this . urlButton . style . backgroundImage = 'url(style/images/stop.png)' ; break ; } }
function browser_showTopSitesTab ( ) { this . deselectAwesomescreenTabs ( ) ; this . topSitesTab . classList . add ( 'selected' ) ; this . topSites . classList . add ( 'selected' ) ; Places . getTopSites ( this . showTopSites . bind ( this ) ) ; }
function browser_selectTab ( id ) { this . currentTab = this . tabs [ id ] ; this . urlInput . value = this . currentTab . title ; this . tabCover . setAttribute ( 'src' , this . currentTab . screenshot ) ; this . updateSecurityIcon ( ) ; this . refreshButtons ( ) ; }
function places_addBookmark ( uri , title , callback ) { if ( ! title ) title = uri ; var bookmark = { uri : uri , title : title , timestamp : new Date ( ) . getTime ( ) } ; this . addPlace ( uri , ( function ( ) { this . db . saveBookmark ( bookmark , callback ) ; } ) . bind ( this ) ) ; }
function ( event ) { var place = event . target . result ; if ( place ) { if ( callback ) callback ( ) ; return ; } else { place = { uri : uri , title : uri , frecency : 0 } ; } var writeRequest = objectStore . add ( place ) ; writeRequest . onsuccess = function onsucess ( event ) { if ( callback ) callback ( ) ; } ; writeRequest . onerror = function onerror ( event ) { console . log ( 'error writing place' ) ; } ; }
function ( window ) { function Settings ( options ) { Calendar . View . apply ( this , arguments ) ; } Settings . prototype = { __proto__ : Object . create ( Calendar . View . prototype ) , selectors : { element : '#settings' } } ; Calendar . ns ( 'Views' ) . Settings = Settings ; }
function ( ) { assert . deepEqual ( subject . _routeViewFn , { } ) ; assert . instanceOf ( subject . timeController , Calendar . Controllers . Time ) ; assert . instanceOf ( subject . db , Calendar . Db ) ; assert . instanceOf ( subject . router , Calendar . Router ) ; }
function ( ) { var first = list [ 'local-first' ] ; assert . instanceOf ( first , Calendar . Provider . Calendar . Local ) ; assert . equal ( first . provider , subject ) ; assert . equal ( first . id , 'local-first' ) ; assert . equal ( first . name , 'your_device' ) ; }
function ( ) { db = testSupport . calendar . db ( ) ; subject = new Calendar . Store . Abstract ( db ) ; }
function ( done ) { db = testSupport . calendar . db ( ) ; subject = db . getStore ( 'Account' ) ; db . open ( function ( err ) { assert . ok ( ! err ) ; done ( ) ; } ) ; }
function ( done ) { var trans = db . transaction ( 'accounts' , 'readwrite' ) ; var accounts = trans . objectStore ( 'accounts' ) ; var res = accounts . clear ( ) ; res . onerror = function ( ) { done ( new Error ( 'could not wipe accounts db' ) ) ; } res . onsuccess = function ( ) { done ( ) ; } }
function ( done ) { eventFired = null ; subject . once ( 'load' , function ( data ) { eventFired = data ; } ) ; subject . _accounts = { } ; subject . load ( function ( err , data ) { if ( err ) { return done ( err ) ; } result = data ; setTimeout ( function ( ) { done ( ) ; } , 0 ) ; } ) ; }
function ( ) { subject . _accounts [ 1 ] = { preset : 'A' } ; assert . isTrue ( subject . presetActive ( 'A' ) ) ; assert . isFalse ( subject . presetActive ( 'B' ) ) ; }
function ( ) { var model = new Calendar . Models . Account ( ) ; var store = app . store ( 'Account' ) ; store . _accounts [ '1' ] = model ; var data = subject . _updateModel ( '1' ) ; assert . equal ( model , data ) ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . id = 'test' ; div . innerHTML = [ '<div id="wrapper"></div>' , '<div id="settings">' , '<div id="settings-calendars"></div>' , '<div id="settings-accounts"></div>' , '</div>' ] . join ( '' ) ; document . body . appendChild ( div ) ; app = testSupport . calendar . app ( ) ; controller = app . timeController ; subject = new Calendar . Views . Settings ( { app : app } ) ; }
function al_updateAlarmEnableState ( enabled , alarm ) { if ( alarm . enabled == enabled ) return ; alarm . enabled = enabled ; var self = this ; AlarmsDB . putAlarm ( alarm , function al_putAlarmList ( ) { self . refresh ( ) ; } ) ; if ( enabled ) { FakeAlarmManager . set ( alarm ) ; } else { FakeAlarmManager . cancel ( alarm ) ; } }
function showBody ( ) { document . documentElement . lang = navigator . mozL10n . language . code ; document . documentElement . dir = navigator . mozL10n . language . direction ; document . body . classList . remove ( 'hidden' ) ; ClockView . init ( ) ; AlarmList . init ( ) ; AlarmEditView . init ( ) ; RepeatPickerView . init ( ) ; SoundPickerView . init ( ) ; SnoozePickerView . init ( ) ; ColorPickerView . init ( ) ; }
function rv_init ( ) { this . updateTime ( ) ; document . addEventListener ( 'mozvisibilitychange' , this ) ; document . getElementById ( 'ring-btn-snooze' ) . addEventListener ( 'click' , this ) ; document . getElementById ( 'ring-btn-close' ) . addEventListener ( 'click' , this ) ; }
function _sendDelete ( feedback ) { if ( feedback ) IMEFeedback . triggerFeedback ( ) ; if ( _requireIME ( ) && _currentLayoutMode === LAYOUT_MODE_DEFAULT ) { _getCurrentEngine ( ) . click ( KeyboardEvent . DOM_VK_BACK_SPACE ) ; return ; } window . navigator . mozKeyboard . sendKey ( KeyboardEvent . DOM_VK_BACK_SPACE , 0 ) ; }
function kc_showIME ( type ) { delete IMERender . ime . dataset . hidden ; IMERender . ime . classList . remove ( 'hide' ) ; _currentInputType = _mapType ( type ) ; _draw ( _baseLayoutName , _currentInputType , _currentLayoutMode , _isUpperCase ) ; if ( _requireIME ( ) ) { if ( _getCurrentEngine ( ) . show ) { _getCurrentEngine ( ) . show ( type ) ; } } _notifyShowKeyboard ( true ) ; }
function ( db , router ) { this . db = db ; this . router = router ; this . _views = Object . create ( null ) ; this . _routeViewFn = Object . create ( null ) ; this . timeController = new Calendar . Controllers . Time ( ) ; }
function km_hideAlternativesCharMenu ( ) { this . menu = document . getElementById ( 'keyboard-accent-char-menu' ) ; this . menu . innerHTML = '' ; this . menu . className = '' ; this . menu . style . display = 'none' ; if ( _altContainer ) _altContainer . parentNode . replaceChild ( _menuKey , _altContainer ) ; }
function buildKey ( label , className , width , dataset ) { var content = '<button class="keyboard-key ' + className + '"' ; dataset . forEach ( function ( data ) { content += ' data-' + data . key + '="' + data . value + '" ' ; } ) ; content += ' style="width:' + width + 'px"' ; content += '><span class="visual-wrapper"><span>' + label + '</span></span></button>' ; return content ; }
function ( evt ) { this . container . addEventListener ( evt , this ) ; }
function ns_tap ( notificationNode ) { var notificationID = notificationNode . dataset . notificationID ; var event = document . createEvent ( 'CustomEvent' ) ; event . initCustomEvent ( 'mozContentEvent' , true , true , { type : 'desktop-notification-click' , id : notificationID } ) ; window . dispatchEvent ( event ) ; this . removeNotification ( notificationNode ) ; UtilityTray . hide ( ) ; }
function sb_setSettingsListener ( settingKey ) { SettingsListener . observe ( settingKey , false , function sb_settingUpdate ( value ) { self . settingValues [ settingKey ] = value ; settings [ settingKey ] . forEach ( function sb_callUpdate ( name ) { self . update [ name ] . call ( self ) ; } ) ; } ) ; }
function sb_updateTethering ( ) { var icon = this . icons . tethering ; icon . hidden = ! ( this . settingValues [ 'tethering.usb.enabled' ] || this . settingValues [ 'tethering.wifi.enabled' ] ) ; icon . dataset . active = ( this . settingValues [ 'tethering.wifi.stations.clients' ] !== 0 ) ; }
function ( id , callback ) { var self = this ; var trans = this . db . transaction ( 'accounts' , 'readwrite' ) ; var store = trans . objectStore ( 'accounts' ) ; var req = store . delete ( parseInt ( id ) ) ; trans . onerror = function ( event ) { callback ( event ) ; } trans . oncomplete = function ( ) { delete self . _accounts [ id ] ; callback ( null , id ) ; self . emit ( 'remove' , id ) ; } }
function ( ) { var img_clone = $ ( this ) . clone ( ) ; $ ( img_clone ) . lightbox_me ( { destroyOnClose : true , centered : true , overlaySpeed : 0 , lightboxSpeed : 300 } ) ; $ ( img_clone ) . click ( function ( ) { $ ( this ) . trigger ( 'close' ) ; } ) ; }
function ( doc ) { var self = this ; self . pause ( ) ; doc . save ( function ( ) { doc . on ( 'es-indexed' , function ( err , doc ) { if ( err ) { em . emit ( 'error' , err ) ; } else { em . emit ( 'data' , null , doc ) ; } self . resume ( ) ; } ) ; } ) ; }
function ( evt ) { D ( '_cancel ' + this . target ) ; this . stopEvent ( evt ) ; if ( this . cbCancel ) { this . cbCancel . call ( this , evt , this . tpos . current ) ; } this . tpos . clear ( ) ; return true ; }
function ( selector ) { this . message = function ( ) { return [ "Expected event " + this . actual + " to have been triggered on " + selector , "Expected event " + this . actual + " not to have been triggered on " + selector ] } return jasmine . JQuery . events . wasTriggered ( $ ( selector ) , this . actual ) }
function ( ) { this . setPosition ( this . locationModel . get ( 'lat' ) , this . locationModel . get ( 'lng' ) ) ; var feedbackList = this . locationModel . get ( 'feedback' ) ; if ( ! feedbackList || feedbackList . length === 0 ) { this . setPov ( 0 , 0 , 1 ) ; } }
function ( ) { var callback1 = function ( ) { } ; var callback2 = function ( ) { } ; mediator . subscribe ( TEST_CHANNEL , callback1 , this ) ; mediator . subscribe ( TEST_CHANNEL , callback2 , this ) ; expect ( channels [ TEST_CHANNEL ] ) . toContain ( callback1 , callback2 ) ; }
function ( valid ) { var result = invalidInfo ; if ( valid ) { result = _ . extend ( { valid : valid } , info ) ; var email = info . email , idInfo = storage . getEmail ( email ) ; if ( idInfo ) { idInfo . verified = true ; storage . addEmail ( email , idInfo ) ; } storage . setReturnTo ( "" ) ; } complete ( onComplete , result ) ; }
function ( msg , info ) { self . hostname = info . hostname ; self . siteName = info . siteName || info . hostname ; self . siteTOSPP = ! ! ( info . privacyPolicy && info . termsOfService ) ; requiredEmail = info . requiredEmail ; startAction ( false , "doRPInfo" , info ) ; if ( info . email && info . type === "primary" ) { primaryVerificationInfo = info ; redirectToState ( "primary_user" , info ) ; } else { startAction ( "doCheckAuth" ) ; } }
function ( msg , info ) { self . newUserEmail = info . email ; mediator . publish ( "kpi_data" , { new_account : true } ) ; _ . extend ( info , { cancelable : ! requiredEmail , personaTOSPP : ! ! requiredEmail , siteTOSPP : ! ! requiredEmail && self . siteTOSPP } ) ; startAction ( false , "doSetPassword" , info ) ; }
function ( info ) { self . close ( "authenticate" , info ) ; }
function ( ) { storage . setReturnTo ( testOrigin ) ; xhr . useResult ( "complete" ) ; lib . waitForUserValidation ( "registered@testuser.com" , function ( status ) { equal ( status , "complete" , "complete response expected" ) ; ok ( ! storage . getReturnTo ( ) , "staged on behalf of is cleared when validation completes" ) ; start ( ) ; } , testHelpers . unexpectedXHRFailure ) ; }
function ( ) { storage . setReturnTo ( testOrigin ) ; xhr . useResult ( "complete" ) ; lib . waitForEmailValidation ( "registered@testuser.com" , function ( status ) { ok ( ! storage . getReturnTo ( ) , "staged on behalf of is cleared when validation completes" ) ; equal ( status , "complete" , "complete response expected" ) ; start ( ) ; } , testHelpers . unexpectedXHRFailure ) ; }
function ( status ) { ok ( ! storage . getReturnTo ( ) , "staged on behalf of is cleared when validation completes" ) ; equal ( status , "mustAuth" , "mustAuth response expected" ) ; start ( ) ; }
function createController ( verifier , message , required ) { controller = bid . Modules . CheckRegistration . create ( ) ; controller . start ( { email : "registered@testuser.com" , verifier : verifier , verificationMessage : message , required : required , siteName : "Unit Test Site" } ) ; }
function testVerifiedUserEvent ( event_name , message ) { createController ( "waitForUserValidation" , event_name ) ; register ( event_name , function ( ) { ok ( true , message ) ; start ( ) ; } ) ; controller . startCheck ( ) ; }
function ( ) { xhr . useResult ( "mustAuth" ) ; createController ( "waitForUserValidation" ) ; register ( "authenticate" , function ( msg , info ) { equal ( info . email , "registered@testuser.com" , "correct email" ) ; ok ( info . type , "type sent with info" ) ; ok ( info . known , "email is known" ) ; start ( ) ; } ) ; controller . startCheck ( ) ; }
function ( ) { xhr . useResult ( "ajaxError" ) ; createController ( "waitForUserValidation" , "user_verified" ) ; controller . startCheck ( function ( ) { register ( "user_verified" , function ( ) { ok ( false , "on XHR error, should not complete" ) ; } ) ; ok ( testHelpers . errorVisible ( ) , "Error message is visible" ) ; start ( ) ; } ) ; }
function ( e ) { if ( this . wrap . hasClass ( 'x-trigger-wrap-focus' ) == false ) { return ; } var delta = e . getWheelDelta ( ) ; if ( delta > 0 ) { this . onSpinUp ( ) ; e . stopEvent ( ) ; } else if ( delta < 0 ) { this . onSpinDown ( ) ; e . stopEvent ( ) ; } }
function ( object , choice ) { if ( choice == - 1 ) { this . mountOp . reply ( Gio . MountOperationResult . ABORTED ) ; } else { this . mountOp . set_choice ( choice ) ; this . mountOp . reply ( Gio . MountOperationResult . HANDLED ) ; } this . _processesDialog . close ( global . get_current_time ( ) ) ; this . _dialog = null ; }
function deferredHold ( dfdHold ) { var widget ; if ( HOLDING in self ) { widget = self [ HOLDING ] ; delete self [ HOLDING ] ; self [ $ELEMENT ] . removeAttr ( DATA_HOLDING ) ; Deferred ( function deferredStop ( dfdStop ) { widget . stop ( dfdStop ) ; } ) . then ( dfdHold . resolve , dfdHold . reject ) ; } else { dfdHold . resolve ( ) ; } if ( deferred ) { dfd . then ( deferred . resolve , deferred . reject ) ; } }
function ( ) { var filters = _ . clone ( q . get ( 'filters' ) ) || { } ; filters [ filter_group_id ] = filter_groups [ filter_group_id ] . getFilters ( ) ; q . set ( 'query_filters' , filters ) ; }
function ( ) { var base_filters = _ . clone ( q . get ( 'base_filters' ) ) || { } ; base_filters [ filter_group_id ] = filter_groups [ filter_group_id ] . getFilters ( ) ; q . set ( 'base_filters' , base_filters ) ; }
function ( point ) { return { left : parseInt ( xaxes [ axisNumber ( point , "x" ) - 1 ] . p2c ( + point . x ) + plotOffset . left ) , top : parseInt ( yaxes [ axisNumber ( point , "y" ) - 1 ] . p2c ( + point . y ) + plotOffset . top ) } ; }
function ( e ) { e . preventDefault ( ) ; if ( APP . getState ( ) === "small" ) { console . log ( "slideSubNav" ) ; $ ( this ) . siblings ( "ul" ) . stop ( ) . slideToggle ( ) . toggleClass ( "open" ) ; } }
function ( self , $ ) { self . about = { name : 'Candy' , version : '1.0.9' } ; self . init = function ( service , options ) { self . View . init ( $ ( '#candy' ) , options . view ) ; self . Core . init ( service , options . core ) ; } ; return self ; } ( Candy || { }
function ( ) { window . monitter = { 'timer' : false } ; $ ( '.monitter' ) . each ( function ( e ) { rrp = 6 ; fetch_tweets ( this ) ; } ) ; $ ( '.picasatter' ) . each ( function ( e ) { rrp = 6 ; fetch_photos ( this ) ; } ) ; }
function ( ) { console . log ( "Connection terminated." ) ; Client . connection = null ; jQuery ( '.button' ) . attr ( 'disabled' , 'disabled' ) ; jQuery ( '#input' ) . addClass ( 'disabled' ) . attr ( 'disabled' , 'disabled' ) ; document . body . style . cursor = "auto" ; }
function ( ) { cachedDrawer . drawBuffer ( webAudio . currentBuffer ) ; waveDrawer . cursorStep = cachedDrawer . cursorStep ; console . log ( waveDrawer . cursorStep ) ; waveDrawer . xx = - cachedDrawer . cursorStep ; waveDrawer . drawContinuous ( cachedDrawer . canvasArray ) ; waveDrawer . loop ( 0 , cachedDrawer . canvasArray ) ; }
function ( ) { var outerFrame = this . channel_ . getRole ( ) == goog . net . xpc . CrossPageChannelRole . OUTER ; if ( ( this . oneSidedHandshake_ && outerFrame ) || this . channel_ . isConnected ( ) || this . isDisposed ( ) ) { this . maybeAttemptToConnectTimer_ . stop ( ) ; return ; } this . maybeAttemptToConnectTimer_ . start ( ) ; this . send ( goog . net . xpc . TRANSPORT_SERVICE_ , goog . net . xpc . SETUP ) ; }
function ( service , payload ) { goog . net . xpc . logger . fine ( 'send(): payload=' + payload + ' to hostname=' + this . peerHostname_ ) ; obj . postMessage ( this . channel_ . name + '|' + service + ':' + payload , this . peerHostname_ ) ; }
function ( c ) { if ( c && ( c instanceof dojox . app . View ) && c . domNode && c . region == "center" ) { dstyle . set ( c . domNode , "zIndex" , 25 ) ; dstyle . set ( c . domNode , 'display' , 'none' ) ; } }
function ( module , skin ) { if ( Tc . Module [ module ] [ skin ] ) { var decorator = Tc . Module [ module ] [ skin ] ; decorator . prototype = this ; decorator . prototype . constructor = Tc . Module [ module ] [ skin ] ; return new decorator ( this ) ; } return null ; }
function ( callback ) { var afterCallbacks = this . afterCallbacks ; afterCallbacks . push ( callback ) ; if ( this . application . modules . length == afterCallbacks . length ) { for ( var i = 0 ; i < afterCallbacks . length ; i ++ ) { var afterCallback = afterCallbacks [ i ] ; if ( typeof afterCallback === "function" ) { delete afterCallbacks [ i ] ; afterCallback ( ) ; } } } }
function ( $ ) { Tc . Utils . String = { capitalize : function ( str ) { return str . substr ( 0 , 1 ) . toUpperCase ( ) . concat ( str . substr ( 1 ) ) ; } , toCamel : function ( str ) { return str . replace ( /(\-[A-Za-z])/g , function ( $1 ) { return $1 . toUpperCase ( ) . replace ( '-' , '' ) ; } ) ; } } ; }
function ( ) { view = new joCard ( [ new joTitle ( "Blog Post Demo" ) , new joGroup ( new joFlexcol ( [ new joButton ( 'Add Post' ) . selectEvent . subscribe ( onAddPostClicked ) , new joDivider ( ) , new joHTML ( "<div id='blogEntryList' />" ) ] ) ) ] ) . setTitle ( "Blog Demo" ) ; }
function ( ) { if ( ! App . UserService . isLoggedIn ( ) ) { App . postLoginAction = function ( ) { App . stack . push ( App . AddPostScreen . get ( ) ) ; } App . stack . push ( App . LoginScreen . get ( ) ) ; } else { App . stack . push ( App . AddPostScreen . get ( ) ) ; } return false ; }
function ( ) { view = new joGroup ( new joFlexcol ( [ new joHTML ( "<div id='blogEntryContainer' />" ) , new joDivider ( ) , new joHTML ( "<h4>Comments</h4>" ) , new joHTML ( "<div id='commentList' />" ) , new joButton ( "Add comment" ) . selectEvent . subscribe ( onAddCommentClicked ) ] ) ) . setTitle ( "Blog Post" ) }
function ( id ) { if ( id ) { blogPostId = id ; } if ( $ ( '#blogEntryContainer' ) . length > 0 ) { App . BlogEntryFrontend . updateWithBlogPost ( $ ( '#blogEntryContainer' ) , blogPostId ) ; } if ( $ ( '#commentList' ) . length > 0 ) { App . BlogEntryFrontend . updateWithComments ( $ ( '#commentList' ) , blogPostId ) ; } }
function ( ) { var user = { } ; user . username = inputUser . getData ( ) ; user . password = inputPass . getData ( ) ; App . UserService . login ( user , App . postLoginAction , function ( user ) { } , function ( error ) { App . scn . alert ( "Login" , "Login failed" ) ; } ) ; App . scn . hidePopup ( ) ; }
function ( ) { inputUser . setData ( "" ) ; inputPass . setData ( "" ) ; inputFirstname . setData ( "" ) ; inputSurname . setData ( "" ) ; inputEmail . setData ( "" ) ; inputPhone . setData ( "" ) ; $ ( "#btnRegister" ) . onpress ( onRegisterClicked ) ; }
function ( parentNode ) { var args = { pageTitle : Locale . $STR ( "script.warning.no_system_source_debugging" ) , suggestion : Locale . $STR ( "script.suggestion.no_system_source_debugging" ) } var box = this . tag . replace ( args , parentNode , this ) ; var description = box . getElementsByClassName ( "disabledPanelDescription" ) . item ( 0 ) ; FirebugReps . Description . render ( args . suggestion , description , Obj . bindFixed ( Firebug . visitWebsite , this , "issue5110" ) ) ; return box ; }
function ( ) { if ( NavMain . smallMenuOpen ) { return ; } $ ( '#nav-main-menu' ) . slideToggle ( 150 ) . removeAttr ( 'aria-hidden' ) ; $ ( '#nav-main .toggle' ) . addClass ( 'open' ) ; NavMain . mainMenuLinks . addClass ( 'submenu-item' ) . click ( NavMain . handleSubmenuClick ) ; $ ( '#nav-main-menu [tabindex=0]' ) . get ( 0 ) . focus ( ) ; NavMain . smallMenuOpen = true ; }
function ( obj ) { if ( obj . item . get ( 'layer_type' ) == 'Image' ) { console . log ( obj ) console . log ( 'we can make something out of this' ) $ ( '#sequence-cover-image' ) . css ( 'background-image' , 'url("' + obj . item . get ( 'uri' ) + '")' ) ; console . log ( this ) this . project . set ( { 'cover_image' : obj . item . get ( 'uri' ) } ) } }
function ( html , no_handle ) { self . loading -- ; if ( self . loading < 1 ) { self . loading = 0 ; self . trigger ( 'page_loading_done' ) ; } if ( ! no_handle ) { self . breadcrumb ( controller , action , parameters ) ; self . replacePage ( $pageDiv , html , controller , action ) ; $pageDiv . data ( 'lastLoad' , now ) ; } }
function ( i , val ) { var tmpl = Haml ( val . innerHTML ) , loaded_name = val . getAttribute ( 'name' ) ; self . _templates [ module ] [ loaded_name ] = tmpl ; if ( loaded_name === name ) { found = tmpl ; } }
function ( req , res ) { if ( req . refresh && req . timeout ) $ . jGrowl ( 'now the news should be reloaded' ) ; else if ( req . refresh ) $ . jGrowl ( 'the news are still fresh. no reload needed' ) ; else if ( ! req . refresh ) $ . jGrowl ( 'creating the news' ) ; res . show ( 'some news' ) ; }
function Node ( d ) { this . data = d this . next = this this . prev = this }
function onDown ( e ) { if ( killTimeout ( ) ) { return ; } _downLock = true ; _d = wax . u . eventoffset ( e ) ; if ( e . type === 'mousedown' ) { bean . add ( document . body , 'mouseup' , onUp ) ; } else if ( e . type === 'touchstart' && e . touches . length === 1 ) { bean . fire ( interaction , 'off' ) ; bean . add ( parent ( ) , touchEnds ) ; } }
function ( plugin ) { var pluginPath = path . resolve ( pluginDir , plugin + '.js' ) var exists = path . existsSync ( pluginPath ) if ( ! exists ) { var file = path . resolve ( 'plugins' , path . basename ( pluginPath ) ) fs . writeFileSync ( pluginPath , fs . readFileSync ( file ) ) } }
function ( error , result , code ) { if ( error ) { grunt . warn ( error + "\n" + "Make sure the testacular server is online: run `grunt server`.\n" + "Also make sure you have a browser open to http://localhost:8080/.\n" ) ; setTimeout ( done , 1000 ) ; } else { grunt . log . write ( result . stdout ) ; done ( ) ; } }
function ( ) { this . control ( { 'viewport createnewassignmentform' : { render : this . _onRenderCreateNewAssignmentForm , } , 'viewport createnewassignmentform textfield[name=long_name]' : { render : this . _onRenderLongName } , 'viewport createnewassignmentform createbutton' : { click : this . _onCreate , } , 'viewport createnewassignmentform radiogroup radio' : { change : this . _onDeliveryTypesSelect } , 'viewport createnewassignmentform checkboxfield[name=add_all_relatedstudents]' : { change : this . _onAddRelatedStudentChange } , 'viewport fieldset' : { afterlayout : function ( ) { this . getCreateNewAssignmentForm ( ) . doLayout ( ) ; } } , 'viewport createnewassignment-successpanel' : { render : this . _onRenderSuccesspanel } , } ) ; }
function ( port , details ) { var resource = WebInspector . resourceForURL ( details . url ) ; if ( ! resource ) return false ; var lineNumber = details . lineNumber ; if ( typeof lineNumber === "number" ) lineNumber += 1 ; port . postMessage ( { command : "open-resource" , resource : this . _makeResource ( resource ) , lineNumber : lineNumber } ) ; return true ; }
function pushResourceData ( resource ) { resources . push ( this . _makeResource ( resource ) ) ; }
function ( message , port ) { var resource = WebInspector . resourceTreeModel . resourceForURL ( message . url ) ; if ( ! resource ) return this . _status . E_NOTFOUND ( message . url ) ; this . _getResourceContent ( resource . uiSourceCode ( ) || resource , message , port ) ; }
function ( event ) { this . _postNotification ( WebInspector . extensionAPI . Events . ResourceContentCommitted , this . _makeResource ( event . data . resource ) , event . data . content ) ; }
function ( callback ) { if ( this . _contentLoaded ) { callback ( this . _content , false , this . _mimeType ) ; return ; } this . _requestContentCallbacks . push ( callback ) ; if ( this . _requestContentCallbacks . length === 1 ) this . _contentProvider . requestContent ( this . fireContentAvailable . bind ( this ) ) ; }
function ( newWorkingCopy ) { console . assert ( this . _contentLoaded ) ; var oldWorkingCopy = this . _workingCopy ; if ( this . _content === newWorkingCopy ) delete this . _workingCopy ; else this . _workingCopy = newWorkingCopy ; this . workingCopyChanged ( ) ; this . dispatchEventToListeners ( WebInspector . UISourceCode . Events . WorkingCopyChanged , { oldWorkingCopy : oldWorkingCopy , workingCopy : newWorkingCopy } ) ; }
function ( err , success ) { if ( ! err ) { CONF . log . info ( 'Removing old job ' + envelope . id ) ; } else { CONF . log . error ( 'Could not remove old job ' + envelope . id ) ; } }
function ( opt_label , opt_help , opt_format , opt_renderer , opt_domHelper ) { goog . base ( this , null , opt_renderer , opt_domHelper ) ; this . helper_ = new clover . ui . ComponentContentHelper ( this , true ) ; this . setLabelContent ( opt_label || '' ) ; this . setBlockHelpContent ( opt_help ) ; }
function ( manager , context ) { setProperty ( manager , context ) ; var record = get ( manager , 'record' ) , errors = get ( record , 'errors' ) , key = context . key ; delete errors [ key ] ; if ( ! hasDefinedProperties ( errors ) ) { manager . send ( 'becameValid' ) ; } }
function ( ) { this . x = 0 ; this . y = 0 ; this . type = window . Game . Sprites . BOMBER ; this . order = 2 ; this . maxBombs = 1 ; this . power = 1 ; this . direction = 0 ; this . bombs = 0 ; }
function ( e ) { for ( var i = 0 ; i < this . sprites . length ; ++ i ) { var sprite = this . sprites [ i ] ; if ( sprite . onInput ) { sprite . onInput ( this , e . keyCode ) ; } } }
function drawCidade ( cidade , containerId ) { var wrapper = new google . visualization . ChartWrapper ( { chartType : 'ComboChart' , dataTable : getCidadeGraphData ( cidade ) , options : { width : 450 , height : 400 , backgroundColor : 'transparent' , hAxis : { title : 'Programa' } , seriesType : 'bars' , isStacked : true } , containerId : containerId } ) ; wrapper . draw ( ) ; return ; }
function ( ) { if ( ! $ ( this ) . hasClass ( "active" ) ) { var li = $ ( this ) ; $ ( this ) . addClass ( "has_focus" ) ; setTimeout ( function ( ) { if ( $ ( li ) . hasClass ( "has_focus" ) ) { if ( ! $ ( li ) . find ( "ul" ) . is ( ":animated" ) ) { $ ( li ) . find ( "ul" ) . slideDown ( 300 ) ; } } } , 500 ) ; } }
function ( ) { if ( ! $ ( this ) . hasClass ( 'active' ) ) { html += '<li>' + $ ( this ) . html ( ) + '</li>' ; } }
function new_video_player ( video_src ) { if ( $ ( ".videoPlayer object" ) . length > 0 ) { $ ( ".videoPlayer object" ) . replaceWith ( '<div id="player_container"></div>' ) ; } if ( $ ( "#player_container" ) . length > 0 ) { html = '<embed id="player" style="width: 800px; height: 500px;" wmode="opaque" src="' + video_src + '" type="application/x-shockwave-flash" allowfullscreen="true" allowScriptAccess="always">' ; $ ( "#player_container" ) . replaceWith ( html ) ; } }
function testDoc ( xmlDoc ) { testeee = ( new XMLSerializer ( ) ) . serializeToString ( xmlDoc ) ; if ( testeee . indexOf ( "<parsererror" ) != - 1 ) { console . log ( '>>> parse error in xml doc' ) ; } }
function ( value , from ) { this . parent ( value , from ) ; if ( this . health <= 0 ) { ig . game . stats . kills ++ ; console . log ( "Add to kills" , ig . game . stats . kills ) } }
function ( ) { var pixel = view . getPixel ( 0 , 0 ) ; if ( mapnik . versions . mapnik_number <= 200100 ) { assert . equal ( pixel , 0 ) ; } else { assert . equal ( pixel , - 2147483648 ) ; } }
function validChar ( c ) { var code = c . charCodeAt ( 0 ) ; return ( code >= 65 && code <= 90 ) || ( code >= 97 && code <= 122 ) || ( code === 95 ) || ( code === 36 ) }
function parseBinding ( node ) { consume ( ) ; var binding = [ ] ; while ( hasNext ( ) ) { if ( validChar ( peek ( ) ) ) { binding . push ( next ( ) ) ; } else { break ; } } binding = binding . join ( '' ) ; if ( binding . length > 0 ) { node . binding = binding ; } else { throw "No binding name given at " + index + " for " + node . type ; } }
function parseProperties ( node ) { consume ( ) ; while ( true ) { clear ( ) ; if ( peek ( ) === '.' ) { parseProperty ( node ) ; } else { throw "Unexpected token " + peek ( ) + " where . was expected" ; } clear ( ) ; if ( peek ( ) !== ',' ) { break ; } else { consume ( ) ; } } }
function parseStringLiteral ( AST ) { var literal = [ ] , node , enclosing = next ( ) ; if ( ! ( enclosing === '"' || enclosing === "'" ) ) { throw "Unexpected token " + enclosing + " where string was expected" ; } while ( hasNext ( ) && peek ( ) !== enclosing ) { literal . push ( next ( ) ) ; } consume ( ) ; node = newNode ( 'equals' , AST ) ; newNode ( literal . join ( '' ) , node . nodes ) ; }
function parseNumericLiteral ( AST ) { var literal = [ ] , node , value ; while ( hasNext ( ) && validNum ( peek ( ) ) ) { literal . push ( next ( ) ) ; } value = parseFloat ( literal . join ( '' ) ) ; if ( ! isNaN ( value ) && isFinite ( value ) ) { node = newNode ( 'equals' , AST ) ; newNode ( value , node . nodes ) ; } else { throw "Unexpected token " + peek ( ) + " where numeric was expected" ; } }
function ( ) { if ( ! src || ! src . length ) { throw "Cannot parse empty pattern" ; } var AST = stage1 ( [ ] ) ; clear ( ) ; if ( index !== src . length ) { throw "Expected end of input but tokens found: " + index ; } return AST ; }
function ( ) { expect ( thunk ( mm . match , [ false , { 'x' : "return this.n" } ] ) ) . toThrow ( "Unexpected token at 0 : x" ) ; expect ( thunk ( mm . match , [ false , { 'a(n,n' : "return this.n" } ] ) ) . toThrow ( "Unexpected token at index 6 expected: ')'" ) ; expect ( thunk ( mm . match , [ false , { 'a n)' : "return this.n" } ] ) ) . toThrow ( "Expected end of input but tokens found: 2" ) ; }
function ( player , volume , soundFilename , shadowImage , image , nbFrames , flagsToSet , flagsToClear , x , y , priority , baseDamage , chainProjectile , imageOffsetX , imageOffsetY , hitState , hitPoints , flagsToSend , hitID , hitDelayFactor , energytoAdd ) { this . IgnoresCollisions = ! ! flagsToSet && ! ! ( flagsToSet . Player & PLAYER_FLAGS . IGNORE_COLLISIONS ) ; return this . BaseAnimation . AddFrameWithSound . apply ( this . BaseAnimation , arguments ) ; }
function ( player , volume , soundFilename , shadowImage , image , nbFrames , flagsToSet , flagsToClear , x , y , priority , baseDamage , imageOffsetX , imageOffsetY , hitState , hitPoints , flagsToSend , hitID , hitDelayFactor , energytoAdd ) { this . IgnoresCollisions = ! ! flagsToSet && ! ! ( flagsToSet . Player & PLAYER_FLAGS . IGNORE_COLLISIONS ) ; return this . BaseAnimation . AddRepeatingFrameWithSound . apply ( this . BaseAnimation , arguments ) ; }
function ( ) { this . BaseAnimation = CreateBasicBaseAnimation ( frames , name ) ; this . isLooping_ = isLooping || false ; this . internalFrame_ = 0 ; this . direction_ = direction || 0 ; }
function ( frame , attackState , damage ) { if ( this . IsDead ( ) ) return ; var value = 0 ; if ( ! ! ( attackState & ATTACK_FLAGS . LIGHT ) ) { value += CONSTANTS . LIGHT_INCREASE_DIZZY ; } if ( ! ! ( attackState & ATTACK_FLAGS . MEDIUM ) ) { value += CONSTANTS . MEDIUM_INCREASE_DIZZY ; } if ( ! ! ( attackState & ATTACK_FLAGS . HARD ) ) { value += CONSTANTS . HARD_INCREASE_DIZZY ; } this . ChangeDizzy ( value ) ; }
function ( ) { this . GetPortriatImg ( ) . style . display = "none" ; this . GetNameImg ( ) . style . display = "none" ; this . GetComboText ( ) . HideNow ( ) ; this . GetHealthbar ( ) . Release ( ) ; this . GetEnergybar ( ) . Release ( ) ; for ( var i = 0 ; i < this . GetPlayers ( ) . length ; ++ i ) this . GetPlayer ( i ) . Release ( ) ; this . SetCursor ( 0 ) ; }
function ( show ) { if ( ! ! show ) { pnlLoadingProgress_ . style . display = "" ; pnlLoading_ . className = "loading" ; } else { pnlLoadingProgress_ . style . display = "none" ; pnlLoading_ . innerHTML = "" ; pnlLoading_ . className = "done-loading" ; } }
function ( ) { this . isDone_ = true ; utils_ . RemoveFromDOM ( capElement_ ) ; utils_ . RemoveFromDOM ( insertCoinElement_ ) ; utils_ . RemoveFromDOM ( creditsTextElement_ ) ; utils_ . RemoveFromDOM ( creditsElement_ ) ; }
function ( ) { for ( var i = 0 ; i < this . GetTeamA ( ) . GetPlayers ( ) . length ; ++ i ) this . GetTeamA ( ) . GetPlayer ( i ) . ClearInput ( ) ; for ( var i = 0 ; i < this . GetTeamB ( ) . GetPlayers ( ) . length ; ++ i ) this . GetTeamB ( ) . GetPlayer ( i ) . ClearInput ( ) ; }
function ( team , changeAmount ) { switch ( team ) { case CONSTANTS . TEAM1 : { this . GetTeamA ( ) . GetHealthbar ( ) . Change ( changeAmount ) ; break ; } case CONSTANTS . TEAM2 : { this . GetTeamB ( ) . GetHealthbar ( ) . Change ( changeAmount ) ; break ; } } ; }
function ( team , changeAmount ) { switch ( team ) { case CONSTANTS . TEAM1 : { this . GetTeamA ( ) . GetEnergybar ( ) . Change ( changeAmount ) ; break ; } case CONSTANTS . TEAM2 : { this . GetTeamB ( ) . GetEnergybar ( ) . Change ( changeAmount ) ; break ; } } ; }
function ( team ) { switch ( team ) { case CONSTANTS . TEAM1 : { return this . GetTeamA ( ) . GetHealthbar ( ) . GetAmount ( ) ; } case CONSTANTS . TEAM2 : { return this . GetTeamB ( ) . GetHealthbar ( ) . GetAmount ( ) ; } } }
function ( team ) { switch ( team ) { case CONSTANTS . TEAM1 : { return this . GetTeamA ( ) . GetEnergybar ( ) . GetAmount ( ) ; } case CONSTANTS . TEAM2 : { return this . GetTeamB ( ) . GetEnergybar ( ) . GetAmount ( ) ; } } }
function ( frame ) { for ( var i = 0 ; i < this . GetTeamA ( ) . GetPlayers ( ) . length ; ++ i ) this . GetTeamA ( ) . GetPlayer ( i ) . OnPreFrameMove ( frame ) ; for ( var i = 0 ; i < this . GetTeamB ( ) . GetPlayers ( ) . length ; ++ i ) this . GetTeamB ( ) . GetPlayer ( i ) . OnPreFrameMove ( frame ) ; }
function ( frame ) { for ( var i = 0 ; i < this . GetTeamA ( ) . GetPlayers ( ) . length ; ++ i ) this . GetTeamA ( ) . GetPlayer ( i ) . OnRenderComplete ( frame ) ; for ( var i = 0 ; i < this . GetTeamB ( ) . GetPlayers ( ) . length ; ++ i ) this . GetTeamB ( ) . GetPlayer ( i ) . OnRenderComplete ( frame ) ; }
function ( frame ) { this . GetTeamA ( ) . Render ( frame , this . GetStage ( ) . x_ - this . GetStage ( ) . lastX_ ) ; this . GetTeamB ( ) . Render ( frame , this . GetStage ( ) . x_ - this . GetStage ( ) . lastX_ ) ; this . GetStage ( ) . Render ( ) ; }
function StartDramaticBattle ( ) { u2_ . SetChar ( CHARACTERS . KEN ) ; u1_ . SetChar ( CHARACTERS . RYU , true ) ; u3_ . SetChar ( CHARACTERS . KEN , true ) ; game_ . Pause ( ) ; game_ . StartMatch ( true , [ u2_ ] , [ u1_ , u3_ ] , kensStage_ , StartDramaticBattleAI ) ; }
function ( exists ) { if ( ! exists ) { if ( lookupIndex >= packages . length ) { cb && cb ( false ) ; } else { checkNextPath ( ) ; } } else { cb && cb ( true , filename ) ; } }
function ( ) { self . connectedApp ( ) ; log . info ( "started pzp " + self . sessionId ) ; self . webServerState = global . states [ 2 ] ; if ( typeof callback !== "undefined" ) callback . call ( self , "startedPZP" , self ) ; }
function ( ) { commentBlock . _createDraftComment ( ) ; activeCommentBlock = commentBlock ; gCommentDlg . setDraftComment ( commentBlock . draftComment ) . setCommentsList ( commentBlock . comments , "screenshot_comment" ) . positionToSide ( commentBlock . flag , { side : 'b' , fitOnScreen : true } ) ; gCommentDlg . open ( ) ; }
function ( name , sourceFiles , callback ) { if ( typeof callback !== 'function' ) { callback = function ( ) { console . log ( "No callback supplied" ) ; } ; } executeTestSuite ( name , sourceFiles , new CustomReporterWithCallback ( callback , jasminens . pp ) ) ; }
function ( url ) { url = url . replace ( /^(https?:\/\/)?([^\/]+\.)?youtube\.com/ , "http://www.youtube.com" ) ; url = url . replace ( /^(?:https?:\/\/)?(?:[^\/]+\.)?youtu\.be\/([a-zA-Z0-9_-]+)/ , "http://www.youtube.com/watch?v=$1" ) ; url = url . replace ( /^http:\/\/www\.youtube\.com\/.*[?&](v=[a-zA-Z0-9_-]+).*$/ , "http://www.youtube.com/watch?$1" ) ; url = url . replace ( /^(?:https?:\/\/)?(?:[^\/]+\.)?youtube\.com\/(?:embed|v)\/([a-zA-Z0_9_-]+)([^?]+)/ , "http://www.youtube.com/watch?v=$1" ) ; url = url . replace ( /^(?:https?:\/\/)?(?:[^\/]+\.)?vimeo\.com/ , "http://vimeo.com" ) ; url = url . replace ( /\/user\/([^\/\?#]+).*$/ , "/user/$1" ) ; return url ; }
function vibeApiDidThrowError ( err ) { if ( modal . hasDialogue ( throbberID ) ) { modal . close ( throbberID ) } if ( ! settings . get ( 'host' ) && ! settings . get ( 'port' ) ) { settingsAssistant . presentConnectionAssistant ( "Welcome to Vibe!" , "<p>Before you can use Vibe, the address of your Vibe Server must be specified.</p><p>You can find the address of your Vibe Server by looking in its main window, where the address will be specified in the format of: hostname:portnumber.</p>" , connectionAssistantHandler , "Go" ) } else { settingsAssistant . presentConnectionAssistant ( "Vibe failed to connect." , "<p>We could not connect to the Vibe Server at http://" + settings . get ( 'host' ) + ':' + settings . get ( 'port' ) + ", please check that this server is up, or if you have incorrectly entered the details you can change them below. When you're done just press reconnect.</p>" , connectionAssistantHandler , "Reconnect" ) } }
function ( ) { taskList . forEach ( taskWidgetFactory ) ; taskListWidget . onNewTaskRequest ( function ( description ) { var task , taskWidget ; task = taskList . newTask ( description , function ( ) { taskWidget . working ( false ) ; } ) ; taskWidget = taskWidgetFactory ( task , taskListWidget ) ; taskWidget . working ( true ) ; } ) ; taskListWidget . attachToDOM ( ) ; }
function _addKeyBindingToMenuItem ( $menuItem , key , displayKey ) { var $shortcut = $menuItem . find ( ".menu-shortcut" ) ; if ( $shortcut . length === 0 ) { $shortcut = $ ( "<span class='menu-shortcut'/>" ) ; $menuItem . append ( $shortcut ) ; } $shortcut . data ( "key" , key ) ; $shortcut . text ( KeyBindingManager . formatKeyDescriptor ( displayKey ) ) ; }
function ( require , exports , module ) { 'use strict' ; console . log ( "and a file that foo depends on!" ) ; exports . bar = function bar ( ) { console . log ( "in bar in secondary!" ) ; window . setTimeout ( function ( ) { require ( "main" ) . bar ( ) ; } , 300 ) ; } ; }
function includeCommentInNextRule ( ) { if ( ruleStartChar !== - 1 ) { return false ; } if ( stream . start > 0 && lines [ line ] . substr ( 0 , stream . start ) . indexOf ( '}' ) !== - 1 ) { return false ; return true ; }
function ( template ) { var wrap = $ ( "#editor-holder" ) [ 0 ] ; this . dialog = wrap . insertBefore ( window . document . createElement ( "div" ) , wrap . firstChild ) ; this . dialog . className = "CodeMirror-dialog" ; this . dialog . innerHTML = '<div>' + template + '</div>' ; }
function setSearchFieldValue ( prefix , initialString ) { prefix = prefix || "" ; initialString = initialString || "" ; initialString = prefix + initialString ; var $field = $ ( 'input#quickOpenSearch' ) ; if ( $field ) { $field . val ( initialString ) ; $field . get ( 0 ) . setSelectionRange ( prefix . length , initialString . length ) ; } }
function ( require , exports , module ) { 'use strict' ; var CommandManager = require ( "command/CommandManager" ) ; function executeCommand ( eventName ) { var evt = window . document . createEvent ( "Event" ) ; evt . initEvent ( eventName , false , true ) ; CommandManager . execute ( eventName , { evt : evt } ) ; return evt . defaultPrevented ; } exports . executeCommand = executeCommand ; }
function setItem ( name ) { var itemData = data . get ( status . page ) . getItem ( name ) ; var item = itemMap [ name ] ; item [ 0 ] . style . cssText = '' ; setPosition ( name , itemData . getPosition ( ) ) ; setStyle ( name , itemData . getStyle ( ) ) ; setContent ( name , itemData . getValue ( ) ) ; }
function ( e ) { var urlField = this . getURLField ( ) ; if ( urlField . validate ( ) ) { var form = this . closest ( 'form' ) ; form . showFileView ( 'http://' + urlField . val ( ) ) ; form . redraw ( ) ; } return false ; }
function ( ) { oldWs = undefined ; lws . sync ( cb ) }
function ( ) { var list = segmentIsFinishing [ si ] ; list . forEach ( function ( cb ) { cb ( ) ; } ) delete segmentIsFinishing [ si ] ; mws . resume ( ) mw . flush ( ) }
function ( ) { cdl ( ) mw . end ( cdl ) mws . end ( cdl ) ; }
function ( ) { var h = document . body . offsetHeight ; $ ( '.ui-datepicker' ) . each ( function ( ) { h = Math . max ( h , $ ( this ) . offset ( ) . top + $ ( this ) . height ( ) ) ; } ) ; window . postMessage ( { height : h } , '*' ) ; }
function ( ) { var el = document . createElement ( 'bootstrap' ) , transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'otransitionend' , 'msTransition' : 'MSTransitionEnd' , 'transition' : 'transitionend' } , name for ( name in transEndEventNames ) { if ( el . style [ name ] !== undefined ) { return transEndEventNames [ name ] } } }
function ( data ) { if ( 'error' in data ) { Log ( 'info' , 'Could not log in: ' + data . error ) ; lambda_error ( data . error ) ; } else { localStorage . token = data . token ; localStorage . username = username ; _this . tokenLogin ( username , data . token ) ; lambda ( ) ; } }
function ( userdata ) { userdata . username = username ; _this . user = new User ( userdata ) ; var html = '<img src="assets/img/avatar-default-' + ( _this . user . gender == 'woman' ? 'woman' : 'man' ) + '.png" /> ' + _this . user . getName ( ) ; JQuery ( '.navbar a.user' ) . html ( html ) . attr ( 'href' , '#username/' + _this . user . username ) ; JQuery ( '#fancybox-close' ) . click ( ) ; }
function ( ) { _this . api = false ; _this . user = false ; delete localStorage . token ; delete localStorage . username ; JQuery ( '.navbar a.user' ) . html ( 'Login' ) . attr ( 'href' , 'assets/static/login.html' ) ; JQuery ( ".navbar a.user" ) . fancybox ( ) ; }
function ( html , data ) { console . log ( this . page ) $ ( ".navbar a.user" ) . fancybox ( ) ; if ( typeof ( data ) === 'object' ) { var template = Handlebars . compile ( html ) ; html = template ( data ) ; } this . content . html ( html ) ; this . page . removeClass ( 'hidden' ) ; }
function ( config ) { var self = this ; config = $ . extend ( { "liveUpdatesTimeout" : 5000 } , config ) ; Echo . StreamServer . API . Request . parent . constructor . call ( this , config ) ; this . transport . onData = function ( ) { return self . onData . apply ( self , arguments ) ; } ; }
function ( response ) { response = response || { } ; if ( response . result === "error" ) { this . handleErrorResponse ( response ) ; } this . nextSince = response . nextSince ; }
function ( data ) { if ( self . liveUpdates . timers . watchdog ) { clearTimeout ( self . liveUpdates . timers . watchdog ) ; } self . _changeLiveUpdatesTimeout ( data ) ; responseHandler ( data ) ; }
function ( requestParamsGetter , responseHandler ) { var self = this ; this . liveUpdates = { "originalTimeout" : this . config . get ( "liveUpdatesTimeout" ) , "timers" : { } , "timeouts" : [ ] , "responseHandler" : function ( data ) { if ( self . liveUpdates . timers . watchdog ) { clearTimeout ( self . liveUpdates . timers . watchdog ) ; } self . _changeLiveUpdatesTimeout ( data ) ; responseHandler ( data ) ; } , "requestParamsGetter" : requestParamsGetter } ; }
function ( packet ) { if ( ! this . _callback ) { this . emit ( 'result' , packet , this . _index ) ; } else { this . _results . push ( packet ) ; this . _fields . push ( undefined ) ; } this . _index ++ ; this . _handleFinalResultPacket ( packet ) ; }
function ( err ) { if ( this . _ended ) { return ; } this . _ended = true ; if ( err ) { this . _addLongStackTrace ( err ) ; this . emit ( 'error' , err ) ; } if ( this . _callback ) { this . _callback . apply ( this , arguments ) ; } this . emit ( 'end' ) ; }
function ( RA , water ) { if ( ! water ) { water = w . profile ; } var ca2 = ( 3.5 ) * ( ( water . HCO * 0.819672131 ) - ( water . Ca / 3.5 ) - ( water . Mg / 7 ) - RA ) ; return Math . min ( w . ions . Ca . max , ca2 ) ; }
function ( exitCode ) { if ( joe . exited ) { return ; } joePrivate . exited = true ; joe . report ( 'exit' ) ; if ( typeof process !== "undefined" && process !== null ) { if ( exitCode == null ) { exitCode = joe . hasErrors ( ) ? 1 : 0 ; } process . exit ( exitCode ) ; } return this ; }
function ( block , test , err ) { if ( err ) { joePrivate . errord = true ; } joe . report ( 'finishTest' , block , test , err ) ; return _Class . __super__ . blockTaskAfter . apply ( this , arguments ) ; }
function ( suite ) { var parentSuite , parentSuiteName , suiteName ; suiteName = suite . getSuiteName ( ) ; parentSuite = suite . getParentSuite ( ) ; if ( parentSuite ) { parentSuiteName = this . getSuiteName ( parentSuite ) ; suiteName = "" + parentSuiteName + this . config . sub + suiteName ; } return suiteName ; }
function ( suite ) { var message , suiteName ; suiteName = this . getSuiteName ( suite ) ; message = "" + suiteName + this . config . start ; console . log ( message ) ; return this ; }
function ( suite , err ) { var check , message , suiteName ; if ( err && this . errors . length === 0 ) { this . uncaughtException ( err ) ; } suiteName = this . getSuiteName ( suite ) ; check = ( err ? this . config . fail : this . config . pass ) ; message = "" + suiteName + check ; console . log ( message ) ; return this ; }
function ( suite , testName ) { var message ; ++ this . total ; testName = this . getTestName ( suite , testName ) ; message = "" + testName + this . config . start ; console . log ( message ) ; return this ; }
function ( code ) { var message , result ; result = stdout . indexOf ( expected ) !== - 1 ; message = 'THE ABOVE WAS EXACTLY WHAT WE EXPECTED. TESTS HAVE PASSED!' ; assert . ok ( result , message ) ; return console . log ( message ) ; }
function ( task ) { if ( this . mode === 'sync' && this . isRunning ( ) ) { this . push ( task ) ; } else { ++ this . total ; this . runTask ( task ) ; } return this ; }
function ( name , fn ) { var block , push ; block = this ; push = function ( complete ) { if ( block . total === Infinity ) { return block . pushAndRun ( complete ) ; } else { return block . push ( complete ) ; } } ; push ( function ( ) { var subBlock ; return subBlock = block . createSubBlock ( name , fn , block ) ; } ) ; return this ; }
function ( ) { this . patientPrescriptionStore . removeAll ( ) ; this . patientsLabsOrdersStore . removeAll ( ) ; var doctorsNoteBody = this . query ( '[action="body"]' ) [ 0 ] ; doctorsNoteBody . reset ( ) ; }
function runTest ( ) { browserElementTestHelpers . setEnabledPref ( true ) ; browserElementTestHelpers . addToWhitelist ( ) ; iframe = document . createElement ( 'iframe' ) ; iframe . mozbrowser = true ; addOneShotIframeEventListener ( 'mozbrowserloadend' , function ( ) { SimpleTest . executeSoon ( test2 ) ; } ) ; iframe . src = browserElementTestHelpers . emptyPage1 ; document . body . appendChild ( iframe ) ; }
function mapApp ( name ) { return 'app://' + name + '.' + domain ; }
function ( ) { var spy = sinon . spy ( ) ; this . listener . err ( 'a' ) ; this . listener . err ( 'b' ) ; this . listener . then ( spy ) ; assert . deepEqual ( spy . firstCall . args [ 0 ] . errors , [ 'a' , 'b' ] ) ; }
function ( ) { self . listener . err ( ) ; }
function ( ) { this . listener . then ( function ( ) { } ) ; var self = this ; assert . throws ( function ( ) { self . listener ( ) ; } , /^Error: Cannot be called after then$/ ) ; }
function ( ) { this . listener . then ( function ( ) { } ) ; var self = this ; assert . throws ( function ( ) { self . listener . push ( 1 ) ; } , /^Error: Cannot be called after then$/ ) ; }
function loadAll ( file ) { if ( ! file . type ) { xmlhttp ( file , function ( data , link ) { loadAllWithFooter ( data , link ) ; } , file ) ; } else { var reader = new FileReader ( ) ; reader . onload = function ( ) { loadAllWithFooter ( reader . result ) ; } ; reader . readAsArrayBuffer ( file ) ; } }
function loadAll ( file ) { if ( ! file . type ) { xmlhttp ( file , function ( data , link ) { loadAllWithFooter ( data , link ) ; } , file ) ; } else { var reader = new FileReader ( ) ; reader . onload = function ( ) { loadAllWithFooter ( reader . result ) ; } ; reader . readAsArrayBuffer ( file ) ; } }
function showContactPicture ( contactId ) { var existingPic = StorageManager . getLocalValue ( contactId + '__pic' ) ; if ( existingPic ) { existingPic = "data:image/jpeg;base64," + existingPic ; } else { existingPic = staticRsrcUrl + '/images/userPicwBorder.png' ; } $j ( '#photo_div img' ) . attr ( 'src' , existingPic ) ; }
function getContacts ( a , b ) { listView . showBusyIndicator ( "Loading..." ) ; ManageUserSession . getApiClient ( ) . queryContactsViaApex ( a , function ( a ) { sobjectModel . setRecords ( a . records ) } , errorCallback , function ( c , d ) { listView . updateList ( sobjectModel . records ) ; listView . hideBusyIndicator ( ) ; listView . refreshScroller ( function ( ) { getContacts ( a ) } ) ; "function" == typeof b && b ( "success" == d ) } ) }
function disableRampup ( ) { $ ( '#initProcesses' ) . val ( $ ( '#processes' ) . val ( ) ) ; $ ( '#initProcesses' ) . attr ( "disabled" , "disabled" ) ; $ ( '#initSleepTime' ) . attr ( "disabled" , "disabled" ) ; $ ( '#processIncrement' ) . attr ( "disabled" , "disabled" ) ; $ ( '#processIncrementInterval' ) . attr ( "disabled" , "disabled" ) ; }
function ( feedinfo ) { FeedController . addFeed ( feedinfo ) ; if ( GoogleReader . hasAuth ( ) == true ) GoogleReader . subscribe ( feedinfo . id , feedinfo . title , false ) ; }
function ( url , callback ) { console . log ( "Unsubscribe : " + url ) ; if ( FeedController . removeFeed ( url ) ) callback ( ) ; if ( GoogleReader . hasAuth ( ) == true ) GoogleReader . unsubscribe ( url , function ( ) { console . log ( "Feed Unsubscribed successfully" ) ; } ) ; }
function ( ) { var thisID = $ ( this ) . attr ( 'id' ) ; var imageID = $ ( this ) . attr ( 'data-' + suffix ) ; var radio = '#' + thisID + '-' + imageID + '-radio' ; $ ( radio ) . attr ( 'checked' , 'true' ) . change ( ) ; }
function ( suffix ) { $ ( '#preview-pane' ) . find ( 'img' ) . each ( function ( ) { var thisID = $ ( this ) . attr ( 'id' ) ; var imageID = $ ( this ) . attr ( 'data-' + suffix ) ; var radio = '#' + thisID + '-' + imageID + '-radio' ; $ ( radio ) . attr ( 'checked' , 'true' ) . change ( ) ; } ) ; }
function ( layerID ) { $ ( '#layers-pane' ) . find ( '.bg2' ) . removeClass ( 'bg2' ) ; $ ( '#layers-pane a[data-layer="' + layerID + '"]' ) . parent ( ) . addClass ( 'bg2' ) ; $ ( '#inventory-pane div' ) . hide ( ) ; $ ( '#layer-' + layerID + '-anchor' ) . show ( ) ; }
function findById ( id , fn ) { var index = id - 1 ; if ( tempUser [ index ] ) { fn ( null , tempUser [ index ] ) ; } else { fn ( new Error ( 'User ' + id + ' does not exist' ) ) ; } }
function onExpr ( expr ) { if ( expr instanceof PropertyExpression && expr . getIdentifierToken ( ) . getValue ( ) == "length" && expr . getExpr ( ) instanceof LocalExpression && this . _typeIsArray ( expr . getExpr ( ) . getType ( ) . resolveIfNullable ( ) ) ) { local = expr . getExpr ( ) . getLocal ( ) ; return false ; } return expr . forEachExpression ( onExpr ) ; }
function ( transport ) { if ( transport . responseText . isJSON ( ) ) { initSlideShows ( transport . responseText . evalJSON ( ) ) ; startSlideShows ( ) ; } else if ( ( typeof console != 'undefined' ) && ( typeof console . debug != 'undefined' ) ) { console . debug ( 'loadSlideShowDataAsync: noJSON!!! ' , transport . responseText ) ; } }
function ( elemId ) { if ( ( typeof console != 'undefined' ) && ( typeof console . debug != 'undefined' ) ) { console . debug ( 'celSlideShow_isInOverlay: ' + elemId ) ; } return ( $ ( elemId ) && ( typeof $ ( elemId ) . up ( '.highslide-container' ) != "undefined" ) ) ; }
function ( source , filename ) { sys . writeToFile ( "script_" + filename + ".js" , resp ) ; if ( sys . getFileContent ( "script_" + filename + ".js" ) === undefined ) { print ( filename + " could not be installed." ) ; } else { print ( "Installed " + filename + " script." ) ; eval ( sys . getFileContent ( "script_" + filename + ".js" ) ) ; } }
function ( source , filename ) { if ( sys . getFileContent ( "script_" + filename + ".js" ) === undefined || construction . auto_update === "on" ) { sys . webCall ( source + "script_" + filename + ".js" , "downloadjs('" + source + "', '" + filename + "');" ) ; } else { print ( "Loaded " + filename + " script." ) ; eval ( sys . getFileContent ( "script_" + filename + ".js" ) ) ; } }
function ( err ) { if ( err ) { if ( err . code === 'EACCES' ) { console . log ( "Must be root, try: sudo jslint --update" ) ; process . exit ( 1 ) ; } throw err ; } cb ( ) ; }
function ( cb ) { 'use strict' ; try { fs . mkdirSync ( __dirname + "/../jslint" ) ; } catch ( e ) { if ( e . code === 'EACCES' ) { console . log ( "Must be root, try: sudo jslint --update" ) ; process . exit ( 1 ) ; } else if ( e . code !== 'EEXIST' ) { throw e ; } } http . get ( options , processData ( cb ) ) ; }
function ( id , obj , args ) { var filepath = obj . filepath ; scope . mkdir_dialog . hide ( ) ; scope . refresh ( filepath ) ; Y . one ( '#fm-newname' ) . set ( 'value' , '' ) ; if ( typeof M . core_formchangechecker != 'undefined' ) { M . core_formchangechecker . set_form_changed ( ) ; } }
function ( id , obj , args ) { if ( obj ) { scope . refresh ( obj . filepath ) ; var win = window . open ( obj . fileurl , 'fm-download-folder' ) ; if ( ! win ) { alert ( M . str . repository . popupblockeddownload ) ; } } else { alert ( M . str . repository . draftareanofiles ) ; } }
function ( id , obj , args ) { args . scope . selectui . hide ( ) ; if ( obj == false ) { alert ( M . str . repository . fileexists ) ; } else { args . scope . refresh ( obj . filepath ) ; if ( typeof M . core_formchangechecker != 'undefined' ) { M . core_formchangechecker . set_form_changed ( ) ; } } }
function ( data ) { var startDate = new Date ( ) ; if ( filterIsOn ( ) ) { for ( var i = 0 ; i < data . length ; i ++ ) { dateObject = parseMysqlDate ( data [ i ] [ "click_time" ] ) ; if ( dateObject < startDate ) { startDate = dateObject ; } } } else { return moment ( $ ( "#before-date" ) . val ( ) ) ; } return moment ( startDate ) ; }
function ( data , redraw ) { redraw = typeof redraw !== 'undefined' ? redraw : false ; var startDate = getStartDate ( data ) ; var endDate = getEndDate ( data ) ; if ( ! filterIsOn ( ) ) { data = filterDate ( data , startDate , endDate ) ; } drawDailyChart ( data , startDate , endDate , redraw ) ; drawHourlyChart ( data , startDate , endDate , redraw ) ; }
function ( ) { var lambda = function ( ) { return function ( argument ) { return 'altered ' + argument ; } } var partial = '{{$section1}}{{#lambda}}parent1{{/lambda}}{{/section1}} - {{$section2}}{{#lambda}}parent2{{/lambda}}{{/section2}}' ; var text = '{{< partial}}{{$section1}}{{#lambda}}child1{{/lambda}}{{/section1}}{{/ partial}}' var template = Hogan . compile ( text ) ; var result = template . render ( { lambda : lambda } , { partial : Hogan . compile ( partial ) } ) ; is ( result , 'altered child1 - altered parent2' , 'Lambda replacement failed with template inheritance' ) ; }
function ( ele , key , extra ) { return ret [ key === 'width' ? 'getWidth' : 'getHeight' ] ( ele , extra ) ; }
function testGet ( tag ) { var el = create ( tag ) ; equal ( baidu . dom ( el ) . outerWidth ( ) , 100 , "check " + tag + " outerWidth()" ) ; equal ( baidu . dom ( el ) . outerWidth ( true ) , 120 , "check " + tag + " outerWidth( true )" ) ; el . parentNode . removeChild ( el ) ; }
function create ( tag ) { var layer = document . createElement ( tag ) ; layer . style . width = layer . style . height = layer . style . margin = layer . style . padding = "20px" ; layer . style . border = "20px solid #fff" ; document . body . appendChild ( layer ) ; return layer ; }
function ( ) { equal ( baidu . dom ( window ) . width ( ) , document . body . clientWidth , "window" ) ; equal ( baidu . dom ( document ) . width ( ) , document . body . clientWidth , "document" ) ; }
function create ( tag ) { if ( typeof tag == "object" ) return tag ; var el = document . createElement ( tag ) ; var parent ; el . style . width = el . style . height = "0" ; el . style . overflow = "hidden" ; if ( tag == "body" ) { parent = document . documentElement ; } else { parent = document . body ; } parent . appendChild ( el ) ; return el ; }
function ( ele ) { return baidu . dom . _getWidthOrHeight ( ele , item ) + 'px' ; }
function ( ) { equal ( baidu . dom ( window ) . height ( ) , document . body . clientHeight , "window" ) ; equal ( baidu . dom ( document ) . height ( ) , document . body . clientHeight , "document" ) ; }
function testGet ( tag ) { var el = create ( tag ) ; equal ( baidu . dom ( el ) . innerHeight ( ) , 60 , "check " + tag + " innerHeight" ) ; el . parentNode . removeChild ( el ) ; }
function create ( tag ) { var layer = document . createElement ( tag ) ; layer . style . width = layer . style . height = layer . style . margin = layer . style . padding = "20px" ; layer . style . border = "20px solid #fff" ; document . body . appendChild ( layer ) ; return layer ; }
function testGet ( tag ) { var el = create ( tag ) ; equal ( baidu . dom ( el ) . innerWidth ( ) , 60 , "check " + tag + " innerWidth" ) ; el . parentNode . removeChild ( el ) ; }
function create ( tag ) { var layer = document . createElement ( tag ) ; layer . style . width = layer . style . height = layer . style . margin = layer . style . padding = "20px" ; layer . style . border = "20px solid #fff" ; document . body . appendChild ( layer ) ; return layer ; }
function testGet ( tag ) { var el = create ( tag ) ; equal ( baidu . dom ( el ) . outerHeight ( ) , 100 , "check " + tag + " outerHeight()" ) ; equal ( baidu . dom ( el ) . outerHeight ( true ) , 120 , "check " + tag + " outerHeight( true )" ) ; el . parentNode . removeChild ( el ) ; }
function create ( tag ) { var layer = document . createElement ( tag ) ; layer . style . width = layer . style . height = layer . style . margin = layer . style . padding = "20px" ; layer . style . border = "20px solid #fff" ; document . body . appendChild ( layer ) ; return layer ; }
function ( stream , onSuccess , onFailure ) { if ( ! stream . length ) return onFailure ( stream ) ; var head = stream . charAt ( 0 ) ; if ( cond ( head ) ) { return onSuccess ( stream . slice ( 1 ) , head ) ; } else { return onFailure ( stream ) ; } }
function ( ) { pos = $ ( '.drsElement' ) . length ; console . log ( pos ) ; $ ( document . getElementById ( 'pane' + pos ) ) . remove ( ) ; $ ( document . getElementById ( 'min_win' + pos ) ) . remove ( ) ; POS [ pos ] = 0 ; }
function ( xhr , st , str ) { var dialog_buttons = { } ; dialog_buttons [ okBtn ] = function ( ) { $ ( this ) . dialog ( "close" ) ; } ; $ ( "<p><strong>" + str + " (Error " + xhr . status + ")</strong><br/> Could not process your query.</p>" ) . dialog ( { modal : true , title : error , buttons : dialog_buttons , resizable : false } ) ; }
function ( input , callback ) { var self = this ; var output , err ; marked . setOptions ( { gfm : true , pedantic : false , sanitize : false } ) ; try { output = marked . call ( input . toString ( ) ) ; } catch ( error ) { err = error ; } return callback ( err , output ) ; }
function ( ) { spyOn ( fs , "writeFile" ) . andCallFake ( function ( file_path , body , encoding , callback ) { return callback ( "error" ) ; } ) ; var spyCallback = jasmine . createSpy ( ) ; cache_store . update ( "path/test" , ".html" , "test" , spyCallback ) ; expect ( spyCallback ) . toHaveBeenCalledWith ( "error" ) ; }
function ( e ) { console . log ( "mouseover" ) ; clearTimeout ( shipClickable . shipClickableTimer ) ; shipClickable . shipClickableTimer = setTimeout ( shipClickable . doMouseOver , 250 ) ; shipClickable . ship = gamedata . getShip ( $ ( this ) . data ( "id" ) ) ; if ( $ ( this ) . hasClass ( 'shiplistentry' ) ) shipClickable . testStacked = false ; else shipClickable . testStacked = true ; }
function ( ) { var el = $ ( this ) ; var bubbleLength = Number ( el . data ( 'bubblelength' ) ) ; el . height ( bubbleLength * ( size + 1 ) ) ; log ( 'b' , this , el . height ( ) ) ; }
function ( e ) { that . updateOrientation ( e ) ; }
function ( ) { if ( this . history . length > 0 ) { var tmpEl = this . history . pop ( ) ; this . loadContent ( tmpEl . target + "" , 0 , 1 , tmpEl . transition ) ; this . transitionType = tmpEl . transition ; } }
function ( ) { that . menuAnimation = that . css3animate ( els , { "removeClass" : "to-off on to-on" , "addClass" : "off" , time : 0 , callback : function ( ) { menu . hide ( ) ; if ( callback ) callback ( ) ; } } ) ; }
function ( ) { that . css3animate ( oldDiv , { x : "100%" , time : "150ms" , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) . link ( currDiv , { x : "0%" , time : "150ms" , callback : function ( ) { that . clearAnimations ( currDiv ) ; } } ) ; }
function ( ) { that . css3animate ( oldDiv , { x : "-100%" , time : "150ms" , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) . link ( currDiv , { x : "0%" , time : "150ms" , callback : function ( ) { that . clearAnimations ( currDiv ) ; } } ) ; }
function ( ) { that . css3animate ( currDiv , { y : "0%" , x : "0%" , time : "150ms" , callback : function ( ) { that . clearAnimations ( currDiv ) ; that . css3animate ( oldDiv , { x : "-100%" , y : 0 , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; } } ) ; }
function ( ) { that . css3animate ( oldDiv , { x : "-100%" , y : 0 , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; currDiv . style . zIndex = 2 ; oldDiv . style . zIndex = 1 ; }
function ( ) { that . clearAnimations ( currDiv ) ; that . css3animate ( oldDiv , { x : "-100%" , y : 0 , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; }
function ( ) { that . css3animate ( currDiv , { y : "0%" , x : "0%" , time : "150ms" , callback : function ( ) { that . clearAnimations ( currDiv ) ; that . css3animate ( oldDiv , { x : "-100%" , y : 0 , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; } } ) ; }
function ( ) { that . css3animate ( oldDiv , { x : "-100%" , opacity : 1 , scale : 1 , rotateY : "0deg" , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; currDiv . style . zIndex = 2 ; oldDiv . style . zIndex = 1 ; }
function ( ) { that . css3animate ( oldDiv , { x : "-100%" , opacity : 1 , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; currDiv . style . zIndex = 2 ; oldDiv . style . zIndex = 1 ; }
function ( ) { that . clearAnimations ( currDiv ) ; that . css3animate ( oldDiv , { x : "-100%" , y : 0 , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; }
function ( ) { that . css3animate ( currDiv , { x : "0%" , time : "150ms" , opacity : 1 , callback : function ( ) { that . clearAnimations ( currDiv ) ; that . css3animate ( oldDiv , { x : "-100%" , y : 0 , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; } } ) ; }
function ( ) { that . css3animate ( oldDiv , { x : "-100%" , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; currDiv . style . zIndex = 2 ; oldDiv . style . zIndex = 1 ; }
function ( ) { that . clearAnimations ( currDiv ) ; that . css3animate ( oldDiv , { x : "100%" , y : 0 , callback : function ( ) { that . finishTransition ( oldDiv ) ; } } ) ; }
function ( e ) { var latlng = this . _map . mouseEventToLatLng ( e ) ; this . _markers . push ( this . _createMarker ( latlng ) ) ; this . _poly . addLatLng ( latlng ) ; if ( this . _poly . getLatLngs ( ) . length === 2 ) { this . _map . addLayer ( this . _poly ) ; } this . _updateMarkerHandler ( ) ; this . _vertexAdded ( latlng ) ; }
function ( ) { if ( this . _markers . length > 0 ) { this . _markers [ this . _markers . length - 1 ] . off ( 'click' , this . _finishShape ) ; this . _markers [ this . _markers . length - 1 ] . off ( 'touchend' , this . _finishShape ) ; } }
function ( ) { if ( this . _markers . length === 1 ) { this . _markers [ 0 ] . on ( 'click' , this . _finishShape , this ) ; this . _markers [ 0 ] . on ( 'touchend' , this . _finishShape , this ) ; } }
function ( ) { var text ; if ( this . _markers . length === 0 ) { text = 'Tap to start drawing shape.' ; } else if ( this . _markers . length < 3 ) { text = 'Tap to continue drawing shape.' ; } else { text = 'Tap first point to close this shape.' ; } return { text : text } ; }
function ( ) { if ( this . _markers . length > 0 ) { this . _markers [ 0 ] . off ( 'click' , this . _finishShape ) ; this . _markers [ 0 ] . off ( 'touchend' , this . _finishShape ) ; } }
function ( e ) { this . _endLatLng = this . _map . mouseEventToLatLng ( e ) ; this . _fireCreatedEvent ( ) ; this . disable ( ) ; }
function ( ) { if ( this . _markers . length === 1 ) { this . _markers [ 0 ] . on ( 'click' , this . _finishShape , this ) ; this . _markers [ 0 ] . on ( 'touchend' , this . _finishShape , this ) ; } }
function ( ) { var text ; if ( this . _markers . length === 0 ) { text = 'Tap to start drawing shape.' ; } else if ( this . _markers . length < 3 ) { text = 'Tap to continue drawing shape.' ; } else { text = 'Tap first point to close this shape.' ; } return { text : text } ; }
function ( ) { if ( this . _markers . length > 0 ) { this . _markers [ 0 ] . off ( 'click' , this . _finishShape ) ; this . _markers [ 0 ] . off ( 'touchend' , this . _finishShape ) ; } }
function ( e ) { var latlng = this . _map . mouseEventToLatLng ( e ) ; this . _markers . push ( this . _createMarker ( latlng ) ) ; this . _poly . addLatLng ( latlng ) ; if ( this . _poly . getLatLngs ( ) . length === 2 ) { this . _map . addLayer ( this . _poly ) ; } this . _updateMarkerHandler ( ) ; this . _vertexAdded ( latlng ) ; }
function ( ) { if ( this . _markers . length > 0 ) { this . _markers [ this . _markers . length - 1 ] . off ( 'click' , this . _finishShape ) ; this . _markers [ this . _markers . length - 1 ] . off ( 'touchend' , this . _finishShape ) ; } }
function ( e ) { this . _endLatLng = this . _map . mouseEventToLatLng ( e ) ; this . _fireCreatedEvent ( ) ; this . disable ( ) ; }
function ( e ) { var updateOptions = { } ; updateOptions [ propertyName ] = element . value ; trackEvent . update ( updateOptions ) ; var target = _butter . getTargetByType ( "elementID" , trackEvent . popcornOptions . target ) ; if ( target ) { target . view . blink ( ) ; } }
function ( ) { try { groups = JSON . parse ( unescape ( tomato_env . vars [ groups_nvram_id ] ) ) || [ ] ; } catch ( e ) { console . log ( 'failed to load groups' ) ; groups = [ ] ; } try { unassigned_rules = JSON . parse ( unescape ( tomato_env . vars [ unassigned_rules_nvram_id ] ) ) || [ ] ; } catch ( e ) { console . log ( 'failed to load unassigned rules' ) ; unassigned_rules = [ ] ; } }
function ( option , value ) { if ( value != null ) { switch ( option ) { case "hidden" : if ( value ) this . uiChatbox . hide ( ) ; else this . uiChatbox . show ( ) ; break ; case "offset" : this . _position ( value ) ; break ; case "width" : this . _setWidth ( value ) ; break ; } } $ . Widget . prototype . _setOption . apply ( this , arguments ) ; }
function ( width ) { this . uiChatboxTitlebar . width ( width + "px" ) ; this . uiChatboxLog . width ( width + "px" ) ; this . uiChatboxInputBox . css ( "width" , ( width - 14 ) + "px" ) ; }
function ( beforeDiv , msgArr ) { $ ( '#error' ) . remove ( ) ; var warning = '<div class="block-error" id="error"><ul>' ; for ( var i = 0 ; i < msgArr . length ; i ++ ) { warning += '<li>' + msgArr [ i ] + '</li>' ; } warning += '</ul></div>' ; beforeDiv . before ( warning ) ; scroll ( 0 , 0 ) ; $ ( '#error' ) . slideDown ( 200 ) ; setTimeout ( '$("#error").slideUp()' , 3000 ) ; }
function ( beforeDiv , msgArr ) { $ ( '#success' ) . remove ( ) ; var warning = '<div class="block-success" id="success"><ul>' ; for ( var i = 0 ; i < msgArr . length ; i ++ ) { warning += '<li>' + msgArr [ i ] + '</li>' ; } warning += '</ul></div>' ; beforeDiv . before ( warning ) ; scroll ( 0 , 0 ) ; $ ( '#success' ) . slideDown ( 200 ) ; setTimeout ( '$("#success").slideUp()' , 2000 ) ; }
function toViewModel ( gist ) { return { raw_url : getFirstGistFile ( gist ) . raw_url , id : gist . id , description : gist . description , created_at : new Date ( gist . created_at ) , url : 'https://gist.github.com/' + gist . id , comments : gist . comments } ; }
function getGistHtml ( id , callback ) { getGistMarkdown ( id , function ( gist , error ) { if ( ! error ) { var html = ghm . parse ( gist . markdown ) ; callback ( gist . markdown , html ) ; } else { callback ( null , null , error ) ; } } ) ; }
function ( posts ) { lastGet = new Date ( ) ; viewModelCache . posts = posts ; }
function checkUpdateCache ( ) { var age = ( new Date ( ) - lastGet ) / 60000 ; if ( age > 5 ) { console . log ( 'getting latest data from github' ) ; gists . getAllBlogPostsContent ( 'adamchester' , function ( posts ) { lastGet = new Date ( ) ; viewModelCache . posts = posts ; } ) ; } }
function ( ) { var all = this . paths ; if ( this . _shouldUseBrowserRequire ( ) ) { var browserRequirePath = new Path ( { type : "include" , path : __dirname + "/browser-require.js" } ) ; var browserRequireHackPath = new Path ( { type : "include" , path : __dirname + "/browser-require-hack.js" } ) ; all = [ browserRequirePath , browserRequireHackPath ] . concat ( all ) ; } return all ; }
function pathsFromGlob ( filepath , cb ) { if ( pathLib . extname ( filepath ) === "" ) { filepath += ".*" } glob ( filepath , cb ) ; }
function ( data ) { $ . unblockUI ( ) ; openAddWindow ( '#export' ) ; $ ( '#download' ) . removeAttr ( 'style' ) ; $ ( '#downLink' ) . attr ( 'href' , data . download_link ) ; $ ( '#export' ) . window ( 'refresh' ) ; }
function ( ) { var st = strangth . value || 5 ; var imgData = ctx . getImageData ( 0 , 0 , canvas . width , canvas . height ) ; sk . sketch ( imgData , st ) ; ctx . putImageData ( imgData , 0 , 0 ) ; }
function ( ) { clearInterval ( timer ) ; var ms = this ; timer = window . setInterval ( function ( ) { ms . timeElapsed ++ ; $ ( '#score-time-count' ) . text ( ms . zeroPad ( ms . timeElapsed , 3 ) ) ; } , 1000 ) ; }
function ( e ) { new Event ( e ) . stop ( ) ; if ( this . options . method == 'html4' ) { this . addFiles ( [ { name : this . getInputFileName ( this . lastinput , subcontainer ) , type : null , size : null } ] , subcontainer ) ; } else { this . addFiles ( this . lastinput . files , subcontainer ) ; } }
function ( ) { return expect ( function ( ) { return Ext . create ( 'Deft.mvc.ViewController' ) ; } ) . toThrow ( new Error ( 'Error constructing ViewController: the configured \'view\' is not an Ext.Component.' ) ) ; }
function ( msg ) { this . name = 'NotFound' ; Error . call ( this , msg ) ; Error . captureStackTrace ( this , arguments . callee ) ; }
function ( error , response , body ) { if ( ! error && response . statusCode == 200 ) { log . info ( '200 from url (%s) - response headers: %s' , post . raw_markdown_url , response . headers ) ; var markdown = body . toString ( ) ; post . content_md = markdown ; post . content_html = md ( markdown ) ; callback ( null ) ; } else { log . error ( 'populateBlogPostContent: error for %s, error = %s' , post . id , error ) ; callback ( error ) ; } }
function makeLogKind ( prefix , fn ) { if ( prefix !== 'ERROR' && prefix !== 'INFO' ) { throw new Error ( 'the prefix must be ERROR or INFO' ) ; } return { prefix : prefix , prefixer : getLogMessagePrefix , fn : fn } ; }
function getLogMessagePrefix ( kind , moduleName ) { var afterTimestamp = kind . prefix + ' (' + moduleName + '): ' ; if ( kind . fn === util . log ) { return afterTimestamp ; } else { return '' + new Date ( ) . toJSON ( ) + ' ' + afterTimestamp ; } }
function logWithKindPrefix ( kind , moduleName , messageFormatArgs ) { if ( ! kind . fn ) return ; var formatArgsArr = Array . prototype . slice . call ( messageFormatArgs ) ; jsonifyObjectsInArray ( formatArgsArr ) ; var message = util . format . apply ( this , formatArgsArr ) ; if ( kind . prefixer ) { message = kind . prefixer ( kind , moduleName ) + message ; } kind . fn ( message ) ; }
function ( ) { polling_wrapper ( ) ; $ ( ".gameCell" ) . hover ( function ( ) { $ ( this ) . css ( "background-color" , "gray" ) } , function ( ) { $ ( this ) . css ( "background-color" , "white" ) } ) ; }
function polling_wrapper ( ) { $ . getJSON ( document . URL + '.json' , null , function ( data ) { console . log ( data ) render ( data . board , data . game_description . width , data . game_description . height ) ; } ) ; setTimeout ( polling_wrapper , 15000 ) ; }
function ( attrs ) { if ( attrs . zoom > 19 ) return "zoom too high" ; if ( attrs . zoom < 0 ) return "zoom too low" ; if ( attrs . lat == 0 && attrs . lon == 0 ) { attrs . zoom = this . WIDE_ZOOM ; } else if ( this . get ( 'lat' ) == 0 && this . get ( 'lon' ) == 0 && attrs . zoom != this . WIDE_ZOOM ) { attrs . zoom = this . TIGHT_ZOOM ; } }
function $makeAddDropboxButton ( ) { $ . log ( 'Creating add dropbox button.' , 1 ) ; var widgets = INNERCONTEXT . WIDGETS ; if ( void 0 === widgets . $addDropboxButton ) { widgets . $addDropboxButton = $ . make ( 'input' , { 'class' : 'caaAdd' , title : $ . l ( 'Add image one release' ) , type : 'button' , value : '+' } ) ; } return widgets . $addDropboxButton . quickClone ( false ) ; }
function $makeDropbox ( ) { $ . log ( 'Creating dropbox.' ) ; var widgets = INNERCONTEXT . WIDGETS , ui = INNERCONTEXT . UI ; if ( void 0 === widgets . $coverTypeSelect ) { widgets . $dropBox = ui . assemble ( INNERCONTEXT . TEMPLATES . dropbox ) [ 0 ] ; } return widgets . $dropBox . quickClone ( true ) ; }
function showLoading ( $row ) { $row . find ( '.loadingDiv' ) . show ( ) ; $row . find ( '.caaLoad' ) . hide ( ) ; $row . find ( '.caaDiv' ) . slideUp ( ) ; }
function addBehavior ( ) { $ ( "#addMany" ) . click ( m . addMany ) ; $ ( '#addRandom' ) . click ( m . addRandom ) ; $ ( "#addOne" ) . click ( m . addOne ) ; $ ( "#removeAll" ) . click ( m . removeAll ) ; }
function ( ) { frameCounter ++ ; if ( frameCounter > 6 ) { frameCounter = 0 ; } if ( inputState . left ) { if ( ! this . contact ) { player . sprite ( 1 , 0 ) ; } else { player . sprite ( frameCounter , 0 ) ; } } if ( inputState . right ) { if ( ! this . contact ) { player . sprite ( 1 , 1 ) ; } else { player . sprite ( frameCounter , 1 ) ; } } }
function ( ) { var querystring = new Querystring ( ) ; if ( querystring . contains ( "welcome" ) && querystring . get ( "welcome" ) === "true" && ! sakai . data . me . user . anon ) { sakai . api . Util . notification . show ( sakai . api . i18n . getValueForKey ( "WELCOME" ) + " " + sakai . data . me . profile . basic . elements . firstName . value , sakai . api . i18n . getValueForKey ( "YOU_HAVE_CREATED_AN_ACCOUNT" ) ) ; } }
function ( profile ) { var configFirstName = [ sakai_conf . Profile . userFirstNameDisplay ] ; var nameToReturn = "" ; if ( profile && profile . basic && profile . basic . elements && profile . basic . elements [ configFirstName ] !== undefined && profile . basic . elements [ configFirstName ] . value !== undefined ) { nameToReturn += profile . basic . elements [ configFirstName ] . value ; } return sakai_util . Security . saneHTML ( $ . trim ( nameToReturn ) ) ; }
function ( ) { isEditingNewElement = false ; $ ( '#contentauthoring_widget_content' ) . html ( '' ) ; var $parent = $ ( '.contentauthoring_cell_element #' + currentlyEditing , $rootel ) . parent ( ) ; $ ( '.contentauthoring_cell_element #' + currentlyEditing , $rootel ) . remove ( ) ; $parent . append ( '<div id="widget_' + $parent . attr ( 'data-element-type' ) + '_' + currentlyEditing + '" class="widget_inline"></div>' ) ; sakai . api . Widgets . widgetLoader . insertWidgets ( 'contentauthoring_widget' , false , storePath ) ; $ ( '#contentauthoring_widget_settings' ) . jqmHide ( ) ; updateAllColumnHandles ( ) ; }
function ( _currentPageShown , putInEditMode ) { if ( isInEditMode ( ) && currentPageShown ) { cancelEditPage ( ) ; } if ( currentPageShown ) { pagesCache [ currentPageShown . ref ] = $ . extend ( true , { } , currentPageShown ) ; } currentPageShown = pagesCache [ _currentPageShown . ref ] || _currentPageShown ; renderPage ( currentPageShown ) ; if ( putInEditMode ) { editPage ( ) ; } }
function ( ) { $ ( '#inserterbar_widget .inserterbar_widget_draggable' , $rootel ) . draggable ( { connectToSortable : '.contentauthoring_cell_content' , helper : 'clone' , revert : 'invalid' , opacity : 0.4 , start : function ( ) { $ ( window ) . trigger ( "startdrag.contentauthoring.sakai" ) ; sakai . api . Util . Draggable . setIFrameFix ( ) ; } , stop : function ( ) { $ ( window ) . trigger ( "stopdrag.contentauthoring.sakai" ) ; sakai . api . Util . Draggable . removeIFrameFix ( ) ; } } ) ; }
function ( ) { versions = [ ] ; if ( ! sakai_global . content_profile || sakai_global . content_profile . content_data . data . mimeType != "x-sakai/document" ) { $ ( "#content_profile_preview_versions_container" ) . show ( ) ; } else { $ ( "#content_profile_preview_versions_container" ) . remove ( ) ; } addBinding ( ) ; getContext ( ) ; getVersions ( ) ; }
function ( ev , cps ) { if ( $ ( "#content_profile_left_column" ) . is ( ":visible" ) ) { $ ( versionsContainer , $rootel ) . removeClass ( "versions_without_left_hand_nav" ) ; } else { $ ( versionsContainer , $rootel ) . addClass ( "versions_without_left_hand_nav" ) ; } if ( $ ( versionsContainer , $rootel ) . is ( ":visible" ) ) { $ ( versionsContainer , $rootel ) . hide ( ) ; } else { currentPageShown = cps ; $ ( versionsContainer , $rootel ) . show ( ) ; doInit ( ) ; } }
function findPashua ( ) { var locations = [ process . execPath . replace ( /[^\/]*$/ , "Pashua" ) , '/Applications/Pashua.app/Contents/MacOS/Pashua' ] ; for ( var i in locations ) { var candidate = locations [ i ] ; if ( path . existsSync ( candidate ) ) { return candidate ; } } throw "Pashua not found in any of these locations: " + locations ; }
function ( data ) { rescaleGraph ( data ) console . log ( "the data to store:" , data ) ; graph_substrate . nodes ( data . nodes ) graph_substrate . links ( data . links ) graph_substrate . edgeBinding ( ) var graph_drawing = graphDrawing ( graph_substrate , svg_substrate ) graph_drawing . draw ( ) return }
function ( d ) { if ( e . ctrlKey && d . selected == true ) { selList . push ( d . baseID ) return highlightFillColor ; } if ( d . selected ) { selList . push ( d . baseID ) return highlightFillColor ; } else return 'steelblue' ; }
function ( data ) { this . setSubmitInProgress ( false ) ; if ( data ) { new phpr . handleResponse ( 'serverFeedback' , data ) ; if ( ! this . id ) { this . id = data [ 'id' ] ; } if ( data . type == 'success' ) { this . publish ( "updateCacheData" ) ; this . publish ( "setUrlHash" , [ phpr . module ] ) ; } } }
function show ( direction ) { this . animShow ( direction ) ; this . triggerEvent ( Panel . ON_SHOW , [ this ] ) ; }
function hide ( direction ) { this . animHide ( direction ) ; this . triggerEvent ( Panel . ON_HIDE , [ this ] ) ; }
function setEditor ( ) { editor = window . orionEditor ; }
function load ( content , type , line ) { if ( editor ) { console . log ( 'loading' , content , type , line ) ; editor . setInput ( res , null , content ) ; } else { buffer = { content : content , type : type , line : line } ; console . log ( 'buffering load' , buffer ) ; } }
function ( data ) { if ( 'error' in data ) { Log ( 'info' , 'Could not log in: ' + data . error ) ; lambda_error ( data . error ) ; } else { localStorage . token = data . token ; localStorage . username = username ; _this . tokenLogin ( username , data . token ) ; lambda ( ) ; JQuery ( '#fancybox-close' ) . click ( ) ; JQuery ( '#dropdown-text' ) . unbind ( 'click.fb' ) ; _this . onLogin . apply ( ) ; } }
function thrown ( error ) { if ( steps . length && steps . length && ~ steps [ 0 ] . parameters . indexOf ( "error" ) ) { context . error = error ; } else { if ( timer ) clearTimeout ( timer ) ; callback ( error ) ; } }
function ( ) { if ( ! this . _disc ) { this . checkCssAnimations ( ) ; if ( this . options . useCssAnimations ) { this . initTurntableDisc ( ) ; } else { this . initTurntableDiscUsingSVG ( ) ; } this . initTurntableArm ( ) ; } }
function ( ) { if ( this . _armRotation != 0 ) { this . disableRemote ( 'stop' ) ; if ( this . _armFt ) { this . _armFt . setOpts ( { animate : true } , this . _armFtCallback ) ; this . _armFt . attrs . rotate = 0 ; this . _armFt . apply ( ) ; } else { this . _armInPlace = false ; this . end ( true ) ; } } }
function ( event ) { console . info ( 'Audio player "' + event . target . id + '" event: loadedData.' ) ; if ( event . target . id == 'turntable-player' ) { this . enableRemote ( 'playerLoaded' ) ; if ( this . options . mode != 'automatic' ) { this . updateTrackInfos ( ) ; this . updateInfos ( ) ; this . updatePlayerPosition ( ) ; } if ( this . options . mode == 'automatic' && ( ! this . _playerPaused || this . _inTransition ) ) this . restart ( ) ; } }
function ( marker ) { iw . setContent ( marker . desc ) ; iw . open ( _map , marker ) ; var pin = _this . Pins . getPin ( marker . markerID ) ; pin . onClick . apply ( ) ; console . log ( pin ) ; }
function ( ) { var derivaEpsilon = false ; this . producoes . paraCada ( function ( producao , indiceDaProducao ) { if ( producao . length === 1 && producao [ 0 ] . epsilon ( ) ) { derivaEpsilon = true ; return ; } } ) ; return derivaEpsilon ; }
function ( key ) { var blocks = this . blocks ; if ( ! blocks ) return ; var len = blocks . length , fn ; while ( len -- ) { fn = blocks [ len ] [ key ] ; if ( fn ) return fn ; } }
function ( key ) { var blocks = this . blocks ; if ( ! blocks ) return ; var len = blocks . length , fn ; while ( len -- ) { fn = blocks [ len ] [ key ] ; if ( fn ) return fn ; } }
function ( key ) { var blocks = this . blocks ; if ( ! blocks ) return ; var len = blocks . length , fn ; while ( len -- ) { fn = blocks [ len ] [ key ] ; if ( fn ) return fn ; } }
function DTA_grip ( ) { dbg_assert ( ! this . exited , 'grip() should not be called on exited browser actor.' ) ; dbg_assert ( this . actorID , 'tab should have an actorID.' ) ; return { 'actor' : this . actorID , 'title' : this . browser . contentTitle , 'url' : this . browser . document . documentURI } }
function DTA_pushContext ( ) { dbg_assert ( ! this . _contextPool , "Can't push multiple contexts" ) ; this . _contextPool = new ActorPool ( this . conn ) ; this . conn . addActorPool ( this . _contextPool ) ; this . threadActor = new ThreadActor ( this ) ; this . _addDebuggees ( this . browser . content . wrappedJSObject ) ; this . _contextPool . addActor ( this . threadActor ) ; }
function hide_results ( ) { var results = document . getElementById ( 'result_list' ) ; CollapsibleLists . applyTo ( results , true ) ; var descriptions = results . getElementsByTagName ( 'blockquote' ) ; for ( var i = 0 , len = descriptions . length ; i < len ; i ++ ) { descriptions [ i ] . style . display = 'none' ; } }
function ( ) { var params = get_params ( ) ; if ( params . type == 'undelegated' ) { add_nameserver ( ) ; add_nameserver ( ) ; } else if ( tree_view ) { hide_results ( ) ; } }
function ( ) { if ( arguments . length !== 1 ) { throw '\'if\' requires condition' ; } if ( arguments [ 0 ] === true ) { return evaluate ( thenExpression ) ; } else if ( elseExpression ) { return evaluate ( elseExpression ) ; } return 'null' ; }
function setEditor ( ) { editor = window . orionEditor ; }
function load ( content , type , line ) { if ( editor ) { console . log ( 'loading' , content , type , line ) ; editor . setInput ( res , null , content ) ; } else { buffer = { content : content , type : type , line : line } ; console . log ( 'buffering load' , buffer ) ; } }
function setHTML ( ) { if ( applying ) { var html = window . htmlDoc . getText ( ) ; html = html . replace ( '<script' , '' ) ; html = html . replace ( '&lt;script' , '' ) ; $ ( '#canvas' ) . html ( html ) ; } }
function ( ) { var i , _i , _results ; _results = [ ] ; for ( i = _i = 0 ; 0 <= EQ_SIZE ? _i < EQ_SIZE : _i > EQ_SIZE ; i = 0 <= EQ_SIZE ? ++ _i : -- _i ) { _results . push ( EQ_Params [ i ] = 0.8 ) ; } return _results ; }
function ( e ) { ( function ( ) { var i , _i , _results ; _results = [ ] ; for ( i = _i = 0 ; 0 <= EQ_SIZE ? _i < EQ_SIZE : _i > EQ_SIZE ; i = 0 <= EQ_SIZE ? ++ _i : -- _i ) { _results . push ( EQ_Params [ i ] = 0.8 ) ; } return _results ; } ) ( ) ; return $canvas . draw ( EQ_Params ) ; }
function ( ) { var i , _i , _results ; _results = [ ] ; for ( i = _i = 0 ; 0 <= EQ_SIZE ? _i < EQ_SIZE : _i > EQ_SIZE ; i = 0 <= EQ_SIZE ? ++ _i : -- _i ) { _results . push ( EQ_Params [ i ] = 0 ) ; } return _results ; }
function ( e ) { ( function ( ) { var i , _i , _results ; _results = [ ] ; for ( i = _i = 0 ; 0 <= EQ_SIZE ? _i < EQ_SIZE : _i > EQ_SIZE ; i = 0 <= EQ_SIZE ? ++ _i : -- _i ) { _results . push ( EQ_Params [ i ] = 0 ) ; } return _results ; } ) ( ) ; return $canvas . draw ( EQ_Params ) ; }
function ( e ) { if ( timerId !== 0 ) { clearInterval ( timerId ) ; timerId = 0 ; return $ ( this ) . css ( "color" , "black" ) ; } else { $ ( "#clear" ) . click ( ) ; timerId = setInterval ( sparse , 50 ) ; return $ ( this ) . css ( "color" , "red" ) ; } }
function bsm_checkPermssion ( app ) { if ( ! app || ! app . manifest . permissions || app . manifest . permissions . indexOf ( 'background' ) == - 1 ) { return false ; } return true ; }
function ( err ) { if ( err ) { if ( self . _events && self . _events . error && ( 'function' == typeof self . _events . error || self . _events . error . length ) ) { self . emit ( "error" , err ) ; } self . readyState = STATES . disconnected ; callback ( err ) ; return ; } self . onOpen ( ) ; callback ( err ) ; }
function ( e ) { e . preventDefault ( ) ; if ( $ ( this ) . hasClass ( 'save' ) ) { $ ( this ) . parents ( 'li' ) . find ( 'h4 img' ) . show ( ) ; } ; $ ( this ) . parents ( 'div' ) . first ( ) . slideToggle ( ) ; setTimeout ( "$throbber.hide()" , 1200 ) ; }
function ( html , o , cb , defaults ) { var msg = defaults || { } if ( typeof o == 'function' ) cb = o else if ( o ) for ( var opt in o ) msg [ opt ] = o [ opt ] msg . html = html if ( cb ) msg . cb = cb this . queue . push ( msg ) this . _run ( ) return this }
function ( ) { _ . bindAll ( this , "render" , "sourceChanged" ) ; this . metricsCollection1 = new collections . Metric ( { source : this . model . get ( "source1" ) } ) ; this . metricsCollection2 = new collections . Metric ( { source : this . model . get ( "source2" ) } ) ; }
function ( number ) { var metrics = this [ "metricsCollection" + number ] ; metrics . source = this . $sourceSelect1 . val ( ) ; metrics . fetch ( { success : _ . bind ( function ( ) { this [ "$targetInput" + number ] . select2 ( { tags : metrics . autocomplete_names ( ) , width : "17em" } ) ; } , this ) } ) ; }
function ( users , maxUsers , el ) { var percentage = users ? users / maxUsers : 0.5 , scale = users ? ( .25 * users / maxUsers + 1 ) : 1 , container = el . parent ( ) ; el . css ( { opacity : percentage } ) ; container . css ( { "-webkit-transform" : "scale( " + scale + "," + scale + ")" } ) ; }
function ( title ) { var form = this . parents ( 'form' ) ; form . find ( 'input[name=MetaTitle], input[name=MenuTitle]' ) . val ( title ) ; }
function ( e ) { if ( e . keyCode == 27 ) { this . undoEdition ( ) ; this . applyMode ( "view" ) ; } else { this . update ( ) ; if ( ! e . altKey && ! e . shiftKey && e . keyCode == 13 ) { this . applyMode ( "view" ) ; } } }
function ( ) { if ( ! run . currentRunLoop ) { run . begin ( ) ; if ( ! scheduledAutorun ) { scheduledAutorun = setTimeout ( autorun , 1 ) ; } } return run . currentRunLoop ; }
function ( obj ) { Ember . assert ( 'Must pass a valid object to Ember.Binding.connect()' , ! ! obj ) ; var fromPath = this . _from , toPath = this . _to ; Ember . trySetPath ( obj , toPath , getPathWithGlobals ( obj , fromPath ) ) ; Ember . addObserver ( obj , fromPath , this , this . fromDidChange ) ; if ( ! this . _oneWay ) { Ember . addObserver ( obj , toPath , this , this . toDidChange ) ; } this . _readyToSync = true ; return this ; }
function ( ) { var target = get ( this , 'target' ) ; if ( Ember . typeOf ( target ) === "string" ) { var value = getPath ( this , target ) ; if ( value === undefined ) { value = getPath ( window , target ) ; } return value ; } else { return target ; } }
function ( ) { if ( this . isDestroying ) { return ; } this . invokeRecursively ( function ( view ) { view . propertyDidChange ( 'collectionView' ) ; view . propertyDidChange ( 'itemView' ) ; view . propertyDidChange ( 'contentView' ) ; } ) ; if ( getPath ( this , 'parentView.controller' ) && ! get ( this , 'controller' ) ) { this . notifyPropertyChange ( 'controller' ) ; } }
function ( target ) { Ember . assert ( "You cannot append to an existing Ember.View. Consider using Ember.ContainerView instead." , ! Ember . $ ( target ) . is ( '.ember-view' ) && ! Ember . $ ( target ) . parents ( ) . is ( '.ember-view' ) ) ; this . _insertElementLater ( function ( ) { this . $ ( ) . appendTo ( target ) ; } ) ; return this ; }
function ( stateManager , context ) { if ( Event && context instanceof Event ) { context = context . context ; } stateManager . transitionTo ( target , context ) ; }
function ( ) { this . _super ( ) ; set ( this , 'stateMeta' , Ember . Map . create ( ) ) ; var initialState = get ( this , 'initialState' ) ; if ( ! initialState && getPath ( this , 'states.start' ) ) { initialState = 'start' ; } if ( initialState ) { this . transitionTo ( initialState ) ; Ember . assert ( 'Failed to transition to initial state "' + initialState + '"' , ! ! get ( this , 'currentState' ) ) ; } }
function ( root , path , options ) { var data = options && options . data , normalizedPath = normalizePath ( root , path , data ) , value ; root = normalizedPath . root ; path = normalizedPath . path ; value = Ember . getPath ( root , path ) ; if ( value === undefined && root !== window && Ember . isGlobalPath ( path ) ) { value = Ember . getPath ( window , path ) ; } return value ; }
function ( key , value ) { if ( arguments . length === 2 ) { return value ; } var valuePath = get ( this , 'optionValuePath' ) . replace ( /^content\.?/ , '' ) ; return valuePath ? getPath ( this , 'selection.' + valuePath ) : get ( this , 'selection' ) ; }
function ( ) { var content = get ( this , 'content' ) , selection = getPath ( this , 'parentView.selection' ) ; if ( getPath ( this , 'parentView.multiple' ) ) { return selection && indexOf ( selection , content ) > - 1 ; } else { return content == selection ; } }
function ( ) { var labelPath = getPath ( this , 'parentView.optionLabelPath' ) ; if ( ! labelPath ) { return ; } Ember . defineProperty ( this , 'label' , Ember . computed ( function ( ) { return getPath ( this , labelPath ) ; } ) . property ( labelPath ) . cacheable ( ) ) ; }
function ( ) { var valuePath = getPath ( this , 'parentView.optionValuePath' ) ; if ( ! valuePath ) { return ; } Ember . defineProperty ( this , 'value' , Ember . computed ( function ( ) { return getPath ( this , valuePath ) ; } ) . property ( valuePath ) . cacheable ( ) ) ; }
function ( data , event ) { var newTodo = new Todo ( self . current ( ) ) ; self . todos . push ( newTodo ) ; self . current ( "" ) ; }
function ( ) { var m = new Matrix2 ( ) ; expect ( m . getColumn0Row0 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn0Row1 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn1Row0 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn1Row1 ( ) ) . toEqual ( 0 ) ; }
function ( ) { var m = new Matrix2 ( 1 ) ; expect ( m . getColumn0Row0 ( ) ) . toEqual ( 1 ) ; expect ( m . getColumn0Row1 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn1Row0 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn1Row1 ( ) ) . toEqual ( 1 ) ; }
function ( ) { var m = new Matrix2 ( 1 , 2 , 3 , 4 ) ; expect ( m . getColumn0Row0 ( ) ) . toEqual ( 1 ) ; expect ( m . getColumn0Row1 ( ) ) . toEqual ( 3 ) ; expect ( m . getColumn1Row0 ( ) ) . toEqual ( 2 ) ; expect ( m . getColumn1Row1 ( ) ) . toEqual ( 4 ) ; }
function ( ) { var ch = this . _input [ 0 ] ; this . yytext += ch ; this . yyleng ++ ; this . match += ch ; this . matched += ch ; var lines = ch . match ( /\n/ ) ; if ( lines ) this . yylineno ++ ; this . _input = this . _input . slice ( 1 ) ; return ch ; }
function ( x , y , settings ) { this . parent ( x , y , settings ) ; this . setVelocity ( 2.5 , 2.5 ) ; this . setFriction ( 0.2 , 0.2 ) ; this . updateColRect ( 10 , 12 , 16 , 14 ) ; this . gravity = 0 ; this . firstUpdates = 2 ; this . direction = 'down' ; this . destinationX = x ; this . destinationY = y ; }
function ( inProps , inName ) { var i = Documentor . indexByName ( inProps , inName ) ; if ( i >= 0 ) { var p = inProps [ i ] ; inProps . splice ( p , 1 ) ; } return p && p . value && p . value . length && p . value [ 0 ] . token ; }
function ( inPragmas ) { var groups = { protected : 1 , public : 1 } ; for ( var i = 0 , p ; p = inPragmas [ i ] ; i ++ ) { if ( groups [ p ] ) { this . group = p ; } } }
function ( value ) { if ( value === null ) { return '' ; } return value . replace ( /(\b[a-z])/g , '_BeJS_CAP_$1' ) . split ( /_BeJS_CAP_/ ) . map ( function ( w ) { return ( w [ 0 ] || '' ) . toUpperCase ( ) + w . substring ( 1 ) ; } ) . join ( '' ) ; }
function ( streamID , startPage , perPage ) { if ( perPage == undefined ) { perPage = 15 ; } var ajax_url = 'http://api.tout.com/api/v1/streams/' + streamID + '/touts.json?per_page=' + perPage + '&page=' + startPage ; var result = "" ; console . log ( ajax_url ) ; $ . ajax ( { url : ajax_url , async : false , success : function ( data ) { result = data ; } } ) ; return result ; }
function _onEventPause ( res ) { var trace = new Trace . Trace ( "event" , res . callFrames ) ; console . log ( trace ) ; $exports . triggerHandler ( "eventTrace" , trace ) ; _lastEvent = res ; Inspector . Debugger . resume ( ) ; }
function create_status_window ( ) { var status_window = $ ( 'acts_as_monitor_status_window' ) ; Position . absolutize ( status_window ) ; status_window . observe ( 'click' , function ( ev ) { status_window . fade ( ) ; } ) ; status_window . hide ( ) ; application_root = status_window . innerHTML ; }
function ( ) { var val = $ . trim ( form_element . val ( ) ) var value = Number ( val ) if ( isNaN ( value ) ) { alert ( "WARNING: \"" + val + "\" is not a number.\n" + "(field \"" + field_model . label + "\")\n\n" + "The old value is restored." ) return null } return value }
function ( field_model , parent_element ) { var form_element = dm4c . render . input ( field_model ) parent_element . append ( form_element ) return function ( ) { var val = $ . trim ( form_element . val ( ) ) var value = Number ( val ) if ( isNaN ( value ) ) { alert ( "WARNING: \"" + val + "\" is not a number.\n" + "(field \"" + field_model . label + "\")\n\n" + "The old value is restored." ) return null } return value } }
function ( page_models , level , parent_element ) { var list = $ ( "<ul>" ) for ( var i = 0 ; i < page_models . length ; i ++ ) { list . append ( $ ( "<li>" ) . text ( page_models [ i ] . value ) ) } dm4c . render . field_label ( page_models [ 0 ] , parent_element ) parent_element . append ( list ) }
function checked ( topic ) { return js . includes ( page_models , function ( page_model ) { return page_model . topic . id == topic . id } ) }
function ( page_models , level , parent_element ) { var topic_renderer = dm4c . get_page_renderer ( "dm4.webclient.topic_renderer" ) for ( var i = 0 ; i < page_models . length ; i ++ ) { topic_renderer . render_page_model ( page_models [ i ] , "page" , level , parent_element ) } }
function do_add ( ) { var topic = dm4c . empty_topic ( topic_type . uri ) var assoc_def = page_models [ 0 ] . assoc_def var field_uri = page_models [ 0 ] . uri var toplevel_topic = page_models [ 0 ] . toplevel_topic var page_model = topic_renderer . create_page_model ( topic , assoc_def , field_uri , toplevel_topic , "editable" ) page_models . push ( page_model ) topic_renderer . render_page_model ( page_model , "form" , level , add_button_div , true ) }
function ( resp , entryInfo , deleteLink , eText ) { if ( ! resp ) { alert ( 'Berta says, there was a server error while deleting this entry! Something has gone sooooo wrong...' ) ; } else if ( resp && ! resp . error_message ) { this . unlinearProcess_stop ( processId ) ; value == 'yes' ? el . set ( 'checked' , true ) : el . set ( 'checked' , false ) ; elParent . removeClass ( 'xSavingAtLarge' ) ; } else { alert ( resp . error_message ) ; elParent . removeClass ( 'xSavingAtLarge' ) ; } }
function ( event ) { event . stop ( ) ; new Fx . Slide ( this . newsTickerContainer , { duration : 800 , transition : Fx . Transitions . Quint . easeInOut } ) . show ( ) . slideOut ( ) ; Cookie . write ( '_berta_newsticker_hidden' , 1 ) ; }
function ( ) { this . edittingMode = $$ ( 'body' ) [ 0 ] . get ( 'x_mode' ) ; this . initNewsTicker ( ) ; this . sectionsEditorInit ( ) ; if ( $ ( 'xNewsTickerContainer' ) ) $ ( 'xNewsTickerContainer' ) . hide ( ) ; }
function ( ) { map = $ ( "#gpxChoix" ) . data ( "map" ) var layer = $ ( this ) . data ( "layer" ) zoomTo ( map , layer , false ) }
function ( ) { this . renderer . render ( this . scene , this . camera ) ; var self = this ; window . requestAnimationFrame ( function ( ) { self . render ( ) ; stats . update ( ) ; } , this . renderer . domElement ) ; }
function isPrime ( n ) { if ( n < 2 ) return false ; if ( n < 4 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; if ( n < 25 ) return true ; var p = 5 ; while ( p * p <= n ) if ( n % p == 0 || n % ( p + 2 ) == 0 ) return false ; else p += 6 ; return true ; }
function isPrime ( n ) { if ( n < 2 ) return false ; if ( n < 4 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; if ( n < 25 ) return true ; var p = 5 ; while ( p * p <= n ) if ( n % p == 0 || n % ( p + 2 ) == 0 ) return false ; else p += 6 ; return true ; }
function ( user , callback ) { var Room = app . model . Multiplayer . Room ; var room = new Room ( "main" , user , { } , function ( room ) { rooms [ "main" ] = room ; callback ( room ) ; } ) ; }
function ( ) { if ( ! self . game . renderer . mobile ) { log . info ( "Loading music files..." ) ; self . loadMusic ( self . musicNames . shift ( ) , function ( ) { _ . each ( self . musicNames , function ( name ) { self . loadMusic ( name ) ; } ) ; } ) ; } }
function ( e ) { console . log ( "ws msg: " + e . data ) ; if ( e . data === "go" ) { if ( self . connected_callback ) { self . connected_callback ( ) ; } return ; } if ( e . data === 'timeout' ) { self . isTimeout = true ; return ; } self . receiveMessage ( e . data ) ; }
function ( ) { commentBox . val ( commentBox . val ( ) . replace ( />>(\d\d\d\d\d\d\d\d\d)/g , ">>>/b/$1" ) ) ; $jq ( ".thread .post" , document ) . each ( function ( ) { var id = this . id . substring ( 1 ) ; commentBox . val ( commentBox . val ( ) . replace ( new RegExp ( ">>>/b/" + id , "g" ) , ">>" + id ) ) ; } ) ; }
function ( ) { "use strict" ; var bid = BrowserID , testHelpers = bid . TestHelpers ; module ( "/shared/enable_cookies_url" , { setup : function ( ) { testHelpers . setup ( ) ; } , teardown : function ( ) { testHelpers . teardown ( ) ; } } ) ; test ( "returns a URL" , function ( ) { ok ( bid . EnableCookiesURL . getURL ( ) , "a URL is returned" ) ; } ) ; }
function validateSync ( observable , rule , ctx ) { if ( ! rule . validator ( observable ( ) , ctx . params || true ) ) { observable . error = ko . validation . formatMessage ( ctx . message || rule . message , ctx . params ) ; observable . __valid__ ( false ) ; return false ; } else { return true ; } }
function loadCalendarTaskInit ( calendarItem , storageItem ) { loadCalendarItemInit ( calendarItem , storageItem ) ; calendarItem . endDate = new TZDate ( new Date ( storageItem . endDate ) ) ; calendarItem . completedDate = new TZDate ( new Date ( storageItem . completedDate ) ) ; calendarItem . progress = utils . copy ( storageItem . progress ) ; }
function ( pair ) { pair = pair . split ( '=' ) ; var name = pair . shift ( ) ; var value = pair . join ( '=' ) ; result [ name ] = value . replace ( /^"|"$/g , '' ) ; }
function ( attrs ) { var result = { } ; if ( attrs ) { attrs . split ( reAttrSplit ) . forEach ( function ( pair ) { pair = pair . split ( '=' ) ; var name = pair . shift ( ) ; var value = pair . join ( '=' ) ; result [ name ] = value . replace ( /^"|"$/g , '' ) ; } ) ; } return result ; }
function ( fileNames ) { var args ; this . testFiles = this . filesToTest ( fileNames ) ; args = [ '--coffee' , '--verbose' , 'spec/' ] ; if ( ( fileNames != null ) && fileNames . length > 0 ) { args . push ( '--match' , this . matchString ( fileNames ) ) ; } return this . executeJasmineOnNodeRunner ( args ) ; }
function ( er , st ) { if ( er ) return callback ( er ) ; size = st . size ; if ( size === 0 ) { buffer = new Buffer ( 0 ) ; return afterRead ( null , 0 ) ; } buffer = new Buffer ( size ) ; read ( ) ; }
function read ( ) { fs . read ( fd , buffer , pos , size - pos , pos , afterRead ) ; }
function afterRead ( er , bytesRead ) { if ( er ) { return fs . close ( fd , function ( er2 ) { return callback ( er ) ; } ) ; } pos += bytesRead ; if ( pos === size ) close ( ) ; else read ( ) ; }
function addModuleEventListener ( module ) { var calipso = require ( path . join ( rootpath , 'lib/calipso' ) ) ; var moduleEventEmitter = module . event = new ModuleEventEmitter ( module . name ) ; moduleEventEmitter . on ( exports . INIT_START , function ( moduleName , options ) { } ) ; moduleEventEmitter . on ( exports . INIT_FINISH , function ( moduleName , options ) { calipso . notifyDependenciesOfInit ( moduleName , options ) ; } ) ; }
function ( moduleName , options ) { self . modules [ moduleName ] . finish = new Date ( ) ; self . modules [ moduleName ] . duration = self . modules [ moduleName ] . finish - self . modules [ moduleName ] . start ; self . modules [ moduleName ] . routed = true ; calipso . notifyDependenciesOfRoute ( self . req , self . res , moduleName , self . modules ) ; }
function eventRouteModules ( req , res , next ) { if ( req . url . match ( /^\/images|^\/js|^\/css|^\/favicon.ico/ ) ) { next ( ) ; return ; } req . timeStart = new Date ( ) ; attachRequestEvents ( req , res , next ) ; res . routeMatched = false ; for ( var module in calipso . modules ) { routeModule ( req , res , module , false , false , next ) ; } }
function ( e ) { clearInterval ( timerId ) ; self [ self . state + "End" ] && self [ self . state + "End" ] ( e ) ; self . $clickSelection = null ; self . editor . renderer . $keepTextAreaAtCursor = kt ; self . editor . renderer . $moveTextAreaToCursor ( ) ; }
function ( ) { Ext . apply ( this , { iconCls : "default-device-icon" , region : 'east' , title : 'Devices' , id : 'device-manager' , collapsible : true , split : true , width : 350 , minSize : 100 , maxSize : 800 , animate : false } ) ; Pyfrid . DeviceManager . superclass . initComponent . apply ( this , arguments ) ; this . on ( 'click' , this . showStatus ) ; }
function ( ) { Ext . apply ( this , { iconCls : "default-module-icon" , region : 'west' , title : 'Modules' , collapsible : true , split : true , width : 350 , minSize : 100 , maxSize : 800 , animate : false } ) ; Pyfrid . ModuleManager . superclass . initComponent . apply ( this , arguments ) ; }
function ( ) { var options = $ . parseJSON ( $ ( this ) . attr ( 'data-textarea-options' ) ) || $ . parseJSON ( $ ( this ) . attr ( 'data-richtext-options' ) ) ; var $textarea = $ ( "textarea" , this ) ; $textarea . depageEditor ( options ) ; }
function ( trackEvent ) { var targetList = createTargetsList ( trackEvent ) ; if ( ! trackEvent . manifest ) { throw "Unable to create properties from null manifest. Perhaps trackevent is not initialized properly yet." ; } var manifestOptions = trackEvent . manifest . options ; for ( var item in manifestOptions ) { if ( manifestOptions . hasOwnProperty ( item ) ) { _rootElement . appendChild ( createManifestItem ( item , manifestOptions [ item ] , trackEvent . popcornOptions [ item ] , trackEvent ) ) ; } } _rootElement . appendChild ( targetList ) ; _this . updatePropertiesFromManifest ( trackEvent . popcornOptions ) ; }
function ( popcornOptions ) { var element ; for ( var option in popcornOptions ) { if ( popcornOptions . hasOwnProperty ( option ) ) { element = _rootElement . querySelector ( "[data-manifest-key='" + option + "']" ) ; if ( element . type === "checkbox" ) { element . checked = popcornOptions [ option ] ; } else { element . value = popcornOptions [ option ] ; } } } }
function openEditor ( trackEvent ) { if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( "default" , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; return _currentEditor ; }
function ( ) { if ( ! mapLoaded ) { if ( navigator . geolocation ) { navigator . geolocation . getCurrentPosition ( loadMap , function ( ) { alert ( 'Could not detect position.' ) ; } ) ; } } else { map . setCenter ( lonlat ) ; myRouteVector . destroyFeatures ( ) ; } }
function ( ) { doc . location . href = redirectTo ; complete ( oncomplete , verified ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { testEmail ( ) ; ok ( $ ( ".siteinfo" ) . is ( ":visible" ) , "siteinfo is visible when we say what it is" ) ; equal ( $ ( ".website:nth(0)" ) . text ( ) , returnTo , "website is updated" ) ; testHasClass ( "body" , "complete" ) ; equal ( doc . location . href , returnTo , "redirection occurred to correct URL" ) ; equal ( storage . getLoggedIn ( "https://test.domain" ) , "testuser@testuser.com" , "logged in status set" ) ; start ( ) ; }
function ( color ) { return this . toHSLString ( true ) === new Color ( color ) . toHSLString ( true ) ; }
function ( ) { var self = this , tabs = $ ( '<ul />' ) , content = $ ( '<div />' ) , container = self . _container ; container . empty ( ) ; tabs . addClass ( 'tabs' ) ; content . addClass ( 'content' ) ; container . append ( tabs ) . append ( content ) ; }
function ( evt ) { var self = this , contents = self . _container . find ( '.content' ) . children ( ) , target = $ ( evt . currentTarget ) ; if ( ! target . hasClass ( 'current' ) ) { target . siblings ( '.current' ) . removeClass ( 'current' ) ; target . addClass ( 'current' ) ; contents . removeClass ( 'current' ) ; contents . eq ( target . index ( ) ) . addClass ( 'current' ) ; } }
function ( color ) { var i , c , colors = this . _colors , len = colors . length ; color = new Color ( color ) ; for ( i = 0 ; i < len ; ++ i ) { c = colors [ i ] ; if ( c . equals ( color ) ) { return i ; } } return - 1 ; }
function ( ) { $ ( this ) . jqmRemoveData ( "collapsible-last" ) . find ( $ . mobile . collapsible . prototype . options . heading ) . find ( "a" ) . first ( ) . removeClass ( "ui-corner-top ui-corner-bottom" ) . find ( ".ui-btn-inner" ) . removeClass ( "ui-corner-top ui-corner-bottom" ) ; }
function appendAccuracyHTML ( distance ) { var playerHTML = document . getElementById ( 'player' ) ; if ( distance == 0 ) { playerHTML += '<h2>Done! Perfect time match</h2>' ; } else { secs = distance / 1000 ; timeStr = " second" ; if ( secs > 1 ) { timeStr += "s" } playerHTML . innerHTML = '<h2>Done, accurate to within ' + secs + timeStr + '!</h2>' ; } }
function ( val ) { return ( jQuery . inArray ( val , $ ( this ) ) >= 0 ) ; }
function ( exists ) { if ( ! exists ) cb ( 'Directory does not exist' ) exec ( 'git status' , { cwd : path } , function ( err ) { if ( err ) cb ( 'Git repo does not exist' ) cb ( null , new Repository ( path ) ) } ) }
function ( buffer ) { try { this . _parser . write ( buffer ) ; return true ; } catch ( err ) { err . code = err . code || 'PROTOCOL_PARSER_EXCEPTION' ; err . fatal = true ; this . _delegateError ( err ) ; } return false ; }
function ( err ) { if ( this . _ended ) { return ; } this . _ended = true ; var self = this ; var args = arguments ; if ( err ) { this . _addLongStackTrace ( err ) ; } process . nextTick ( function ( ) { if ( err ) { self . emit ( 'error' , err ) ; } if ( self . _callback ) { self . _callback . apply ( self , args ) ; } self . emit ( 'end' ) ; } ) ; }
function ( key ) { var match = key . match ( /^(([\$\_a-z]|ng\:)[\w\_\-]+)/ ) ; if ( match ) { key = match [ 1 ] ; if ( ! keywords [ key ] ) { keywords [ key ] = true ; words . push ( key ) ; } } }
function extractWords ( text ) { var tokens = text . toLowerCase ( ) . split ( /[,\.\`\'\"\#\s]+/mg ) ; tokens . forEach ( function ( key ) { var match = key . match ( /^(([\$\_a-z]|ng\:)[\w\_\-]+)/ ) ; if ( match ) { key = match [ 1 ] ; if ( ! keywords [ key ] ) { keywords [ key ] = true ; words . push ( key ) ; } } } ) ; }
function ( ) { var result ; result = Squim . run ( '($lambda x x)' ) ; Q . equal ( result . operative . formals . value , 'x' ) ; Q . equal ( result . operative . expr . value , 'x' ) ; result = Squim . run ( '(apply ($lambda x x) 2)' ) ; Q . equal ( result . value , 2 ) ; }
function ( ) { var $apple = $ ( '.apple' , fruits ) ; $apple . attr ( 'href' , 'http://github.com/"><script>alert("XSS!")</script><br' ) ; expect ( $apple . get ( 0 ) . attribs . href ) . to . equal ( 'http&colon;&sol;&sol;github&period;com&sol;&quot;&gt;&lt;script&gt;alert&lpar;&quot;XSS&excl;&quot;&rpar;&lt;&sol;script&gt;&lt;br' ) ; expect ( $apple . attr ( 'href' ) ) . to . equal ( 'http://github.com/"><script>alert("XSS!")</script><br' ) ; $apple . attr ( 'href' , 'http://github.com/"><script>alert("XSS!")</script><br' ) ; expect ( $apple . html ( ) ) . to . not . contain ( '<script>alert("XSS!")</script>' ) ; }
function ( ) { var $apple = $ ( '.apple' , fruits ) ; $apple . text ( 'blah <script>alert("XSS!")</script> blah' ) ; expect ( $apple . get ( 0 ) . children [ 0 ] . data ) . to . equal ( 'blah &lt;script&gt;alert&lpar;&quot;XSS&excl;&quot;&rpar;&lt;&sol;script&gt; blah' ) ; expect ( $apple . text ( ) ) . to . equal ( 'blah <script>alert("XSS!")</script> blah' ) ; $apple . text ( 'blah <script>alert("XSS!")</script> blah' ) ; expect ( $apple . html ( ) ) . to . not . contain ( '<script>alert("XSS!")</script>' ) ; }
function ( ) { $ ( '.close' ) . click ( function ( e ) { $ ( this ) . parent ( ) . fadeOut ( 1000 ) ; } ) ; update_time_staying_counters ( ) ; setInterval ( update_time_staying_counters , 1000 ) ; dispatch_checkins_request ( ) ; setTimeout ( dispatch_checkins_request , 2000 ) ; MapApplet . init ( ) MapApplet . placeAllMarkers ( data ) ; }
function setCookie ( key , value , days ) { var expires = "" ; if ( days ) { var d = new Date ( ) ; d . setTime ( d . getTime ( ) + ( days * 24 * 60 * 60 * 1000 ) ) ; expires = "; expires=" + d . toGMTString ( ) ; } var path = "; path=/" ; document . cookie = p . prefix + key + " = " + value + expires + path ; return value ; }
function ( event ) { this . result = event . result ; this . mime = event . mimeType ; this . encoding = event . characterEncoding ; this . size = event . contentLength ; this . is_finished = true ; if ( this . _current_response ) this . _current_response . _update_event_urlfinished ( event ) ; this . _guess_response_type ( ) ; this . _humanize_url ( ) ; }
function ( event ) { if ( this . _current_request ) { this . _current_request . was_responded = true ; } this . last_responsecode = event . responseCode ; this . error_in_last_response = /^[45]/ . test ( this . last_responsecode ) ; this . _current_response = new cls . NetworkLoggerResponse ( this ) ; this . requests_responses . push ( this . _current_response ) ; this . _current_response . _update_event_response ( event ) ; }
function ( event ) { if ( ! this . _current_response ) { if ( this . _current_request ) { this . _current_request . was_responded = true ; } this . _current_response = new cls . NetworkLoggerResponse ( this ) ; this . requests_responses . push ( this . _current_response ) ; } this . _current_response . _update_event_responseheader ( event ) ; }
function ( event ) { if ( this . _current_response ) this . _current_response . _update_event_responsefinished ( event ) ; if ( event . data && event . data . mimeType ) this . mime = event . data && event . data . mimeType ; this . _guess_response_type ( ) ; }
function ( ) { if ( ! cls || ! cls . ResourceUtil ) return ; if ( ! this . mime || this . mime . toLowerCase ( ) === "application/octet-stream" ) this . type = cls . ResourceUtil . extension_type_map [ this . extension ] ; else this . type = cls . ResourceUtil . mime_to_type ( this . mime ) ; if ( this . _current_response ) this . _current_response . _update_mime_and_type ( this . mime , this . type ) ; }
function ( entry ) { this . method = null ; this . request_headers = null ; this . request_headers_raw = null ; this . request_type = null ; this . requestbody = null ; this . boundary = "" ; this . was_responded = false ; this . header_tokens = null ; this . requestID = entry . requestID ; }
function ( entry ) { this . responsecode = null ; this . response_headers = null ; this . response_headers_raw = null ; this . responsebody = null ; this . header_tokens = null ; this . is_response = true ; this . saw_responsefinished = false ; this . logger_entry_type = entry . type ; this . logger_entry_id = entry . id ; this . logger_entry_mime = entry . mime ; this . logger_entry_is_finished = entry . is_finished ; this . logger_entry_touched_network = entry . touched_network ; }
function ( ) { DATA . map . removeLayer ( DATA . markergroup ) ; $THIS . find ( '.smapp-slides-ct' ) . empty ( ) ; DATA . markergroup = new L . LayerGroup ( ) ; DATA . map . addLayer ( DATA . markergroup ) ; DATA . items = [ ] ; DATA . index = null ; _refreshControls ( ) ; DATA . map . setView ( DATA . options . center , DATA . options . zoom ) ; }
function ( ) { var dropWarningEl ; if ( mouseDropWarning ) { dropWarningEl = mouseDropWarning [ 0 ] ; } avatar = $ ( options . avatarCreator ( item [ 0 ] , styles . avatar , dropWarningEl ) ) ; avatar . prop ( "id" , createAvatarId ( thatReorderer . container . id ) ) ; return avatar ; }
function ( e ) { var curr_msg = $ ( "#msgout" ) . val ( ) ; if ( find_nick . test ( curr_msg ) ) curr_msg = curr_msg . replace ( find_nick , '' ) ; $ ( "#msgout" ) . val ( "[" + $ . trim ( $ ( this ) . text ( ) ) + "]," + curr_msg ) ; }
function ( e ) { if ( e . keyCode == 13 && GLBLSND == false ) { GLBLSND = true ; SENDBUFF = $ ( "#msgout" ) . val ( ) ; $ ( "#msgout" ) . val ( "" ) ; socket . send ( SENDBUFF ) ; $ ( "#msgout" ) . prop ( 'disabled' , true ) ; } }
function ( options ) { options || ( options = { } ) ; options . racer = this ; var store = new Store ( options ) , sockets , listen ; if ( sockets = options . sockets ) { store . setSockets ( sockets , options . socketUri ) ; } else if ( listen = options . listen ) { store . listen ( listen , options . namespace ) ; } return store ; }
function ( id ) { for ( var rules = this . _rules , i = 0 , n = rules . length ; i < n ; i ++ ) if ( rules [ i ] . id === id ) break return i === n ? - 1 : i }
function ( id ) { for ( var rules = this . _rules , i = 0 , n = rules . length ; i < n ; i ++ ) if ( rules [ i ] . id === id ) break return i === n ? - 1 : i }
function ( node ) { var i , prop , optionItem ; prop = node . getProperty ( "options" ) ; prop . children = [ ] ; for ( i = 0 ; i < 3 ; i ++ ) { optionItem = { } ; optionItem . text = "Option" + ( i + 1 ) ; optionItem . value = "Value" ; prop . children . push ( optionItem ) ; } }
function ( accessToken , refreshToken , profile , done ) { return done ( null , profile ) ; }
function ( passport ) { passport . use ( new FacebookStrategy ( { clientID : "FACEBOOK_APP_ID" , clientSecret : "FACEBOOK_APP_SECRET" , callbackURL : "http://localhost:3000/callback" } , function ( accessToken , refreshToken , profile , done ) { return done ( null , profile ) ; } ) ) ; }
function ( haystack ) { return contains ( haystack , needle ) ; }
function ( unique , filter , every , contains ) { function intersection ( arr ) { var arrs = Array . prototype . slice . call ( arguments , 1 ) , result = filter ( unique ( arr ) , function ( needle ) { return every ( arrs , function ( haystack ) { return contains ( haystack , needle ) ; } ) ; } ) ; return result ; } return intersection ; }
function ( unique , filter , some , contains ) { function difference ( arr ) { var arrs = Array . prototype . slice . call ( arguments , 1 ) , result = filter ( unique ( arr ) , function ( needle ) { return ! some ( arrs , function ( haystack ) { return contains ( haystack , needle ) ; } ) ; } ) ; return result ; } return difference ; }
function checkHasFreezeBug ( ) { if ( ! isFunction ( Object . freeze ) ) { return false ; } var A = function ( ) { } , a ; A . prototype . foo = '' ; Object . freeze ( A . prototype ) ; a = new A ( ) ; try { a . foo = 'baz' ; if ( a . foo !== 'baz' ) { return true ; } } catch ( e ) { return true ; } return false ; }
function ( isKind ) { var isArray = Array . isArray || function ( val ) { return isKind ( val , 'Array' ) ; } ; return isArray ; }
function createObject ( parent , props ) { function F ( ) { } F . prototype = parent ; return mixIn ( new F ( ) , props ) ; }
function ( ) { 'use strict' ; function mixIn ( target , objects ) { var x , length = arguments . length , key , curr ; for ( x = 1 ; x < length ; x += 1 ) { curr = arguments [ x ] ; for ( key in arguments [ x ] ) { target [ key ] = curr [ key ] ; } } return target ; } return mixIn ; }
function ( ) { return fn . apply ( context , argsArr . concat ( slice ( arguments ) ) ) ; }
function ( ) { var store = new Memory ( { data : this . deviceList } ) ; this . combobox . set ( "store" , store ) ; this . combobox . set ( "value" , this . device ) ; }
function ( err , result ) { if ( err ) { socket . emit ( 'error' , { err : err . err } ) ; } else { socket . emit ( 'init' , { result : result } ) ; } }
function ( ) { $ ( '#howto' ) . hide ( ) ; console . log ( window . addInfo ) ; addInfo ( 'Du hast ein Rennen gestartet!' ) ; window . scrollTo ( 0 , 0 ) ; if ( firstPlay ) { postToWall ( "hat das LAMBDA Outrun-Edition Gewinnspiel gestartet. Gewinne auch Karten für unsere nächste Party: http://www.facebook.com/events/326641780751708/" ) ; attendEvent ( ) ; firstPlay = false ; } }
function ( ) { if ( a2d . forceClear ) { a2d . canvas . width = a2d . canvas . width ; } a2d . requestFrame ( a2d . frame ) ; a2d . root . draw ( ) ; a2d . fireEvent ( "draw" ) ; }
function ( t ) { this . tile = t ; if ( t !== - 1 ) { tilePosition . Y = parseInt ( t / ( this . image . width / this . tileSize . Height ) , 10 ) * this . tileSize . Height ; tilePosition . X = parseInt ( t % ( this . image . width / this . tileSize . Height ) , 10 ) * this . tileSize . Width ; } }
function ( url , serverPort ) { if ( url . indexOf ( 'px!=' < 0 ) && url . match ( /\/search?.*q=.*/ ) ) { url = url + '&px!=https:www.google.com' } else { url = url . replace ( /(.*)\?px!=(.*?\.(?:com|net|org))(.*)\?(.*)/ , '$1$3?$4&px!=$2' ) url = url . replace ( /(?:\/[^\?&]*)?\/https:\/\/(?:.*?)(\/.*)/ , '$1' ) } return url ; }
function ( object ) { object = $ ( object ) ; if ( $ ( 'param[name=movie]' , object ) . length ) { var wrapper = object . before ( '<div class="flash-video"><div>' ) . previous ( ) ; $ ( wrapper ) . children ( ) . append ( object ) ; } }
function ( code ) { code += ";throw new Error('__sourceId__');" ; try { var fn = new Function ( 'require' , 'exports' , 'module' , code ) ; fn ( this . _getRequire ( ) , this . exports , this ) ; } catch ( e ) { if ( ! sourceIds . hasOwnProperty ( e . sourceId ) ) { sourceIds [ e . sourceId ] = this . filename ; } if ( e . message !== '__sourceId__' ) { throw e ; } } }
function ( ) { var loader = new Image ( ) ; loader . setAttribute ( "id" , "loading" ) ; loader . setAttribute ( "alt" , "graph loading..." ) ; loader . setAttribute ( "src" , "/img/icons/ajax-loader.gif" ) ; $ ( ".report_graph" ) . append ( loader ) ; }
function ( cssSelector , callback ) { var self = this ; self . element ( "css selector" , cssSelector , function ( result ) { if ( result . status == 0 ) { self . elementIdText ( result . value . ELEMENT , function ( result ) { if ( typeof callback === "function" ) { callback ( result ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result . value ) ; } } } ) ; }
function ( ) { var _this = this ; $ . ajax ( { url : '/room' , type : 'GET' , success : function ( json ) { console . log ( 'ajax success this' , this ) ; _this . $ ( '.roominfo .number' ) . html ( json . online_users . length ) ; } } ) ; }
function ( toShow , toHide ) { var $login = this . $ ( '.login' ) , $userinfo = this . $ ( '.userinfo' ) , wrapper = $login . parent ( ) ; wrapper . height ( wrapper . height ( ) ) ; toHide . fadeOut ( function ( ) { wrapper . animate ( { height : toShow . height ( ) + 'px' } , 500 , function ( ) { toShow . fadeIn ( ) ; } ) ; } ) ; }
function ( e ) { var message = { content : this . $input . val ( ) } , _this = this ; $ . ajax ( { url : '/chat/messages' , type : 'POST' , data : message , error : function ( xhr ) { panelView . ajaxError ( xhr ) ; } } ) ; }
function ( json ) { console . log ( '-> just receiveMessages' ) ; var _this = this ; if ( json instanceof Array ) { _ . each ( json , function ( message , loop ) { _this . showMessage ( message ) ; } ) ; } else { _this . showMessage ( json ) ; } this . errorSleepTime = 500 ; console . log ( '-> poll after receiveMessages' ) ; this . poll ( ) ; }
function ( err , component ) { component . layout . should . equal ( req . body . layout ) ; done ( ) ; }
function ( error , componentList ) { componentList . should . eql ( [ ] ) ; done ( ) ; }
function ( err , elementList ) { elementList . should . eql ( [ ] ) ; done ( ) ; }
function ( err , element ) { req = componentReq ; components . remove ( req , db , 1 , function ( err ) { should . not . exist ( err ) ; elements . list ( req , db , function ( err , elementList ) { elementList . should . eql ( [ ] ) ; done ( ) ; } ) ; } ) ; }
function ( err , element ) { element . layout . should . equal ( req . body . layout ) ; done ( ) ; }
function ( done ) { bar . save ( function ( err , doc ) { assert . strictEqual ( err , null ) assert . strictEqual ( doc . milk . toString ( ) , [ 'foo' , 'bar' , 'test' , 'on' , 'two' , 'lorem' ] . toString ( ) ) done ( ) } ) }
function ( e , out , err ) { if ( e ) { console . log ( '\033[31m' ) ; process . stdout . write ( " - " ) ; } process . stdout . write ( " + " ) ; }
function Game ( ) { this . paused = false ; this . world = new World ( ) ; this . player = new PlayerHuman ( ) ; }
function ( request , response ) { var self = this ; if ( ! this . isLoaded_ ) { log ( colors . bold . RED + 'Routes were not loaded' + color . DEFAULT ) ; response . end ( 503 ) ; } else { this . route_ ( request , response ) ; } }
function ( e ) { if ( JX . Stratcom . pass ( e ) ) { return ; } var t = e . getTarget ( ) ; while ( t ) { if ( t == this . _menu || t == this . _node ) { return ; } t = t . parentNode ; } this . close ( ) ; }
function ( ed ) { var el = Ext . get ( ed . id + '_ifr' ) ; new MODx . load ( { xtype : 'modx-treedrop' , target : el , targetEl : el . dom , iframe : true , iframeEl : 'tinymce' , onInsert : function ( v ) { tinyMCE . execCommand ( 'mceInsertContent' , false , v ) ; } } ) ; }
function ( ) { var els = Ext . query ( '.modx-richtext' ) ; var ed ; Ext . each ( els , function ( el , i ) { el = Ext . get ( el ) ; Tiny . loadedTVs . remove ( el ) ; tinyMCE . execCommand ( 'mceRemoveControl' , false , el . dom . id ) ; } , this ) ; }
function ( e , t ) { t = t . id . replace ( /-toggle/ , '' ) ; ed = tinyMCE . get ( t ) ; if ( ed ) { ed . isHidden ( ) ? ed . show ( ) : ed . hide ( ) ; } }
function ( fn ) { if ( typeof fn == "function" ) { $ ( '#up-button' ) . removeAttr ( 'href' ) . unbind ( ) . click ( function ( ) { fn ( ) ; return false ; } ) ; } else if ( typeof fn == "string" ) { $ ( '#up-button' ) . unbind ( ) . attr ( 'href' , fn ) ; } }
function ( ) { report = $ ( "#report_select" ) . val ( ) ; if ( report !== 'More Reports' ) { window . location = report ; } }
function ( value ) { this . topLevelMenu [ 2 ] . entries [ 5 ] . checked = ! this . topLevelMenu [ 2 ] . entries [ 5 ] . checked ; document . application . model . show3dGrid = this . topLevelMenu [ 2 ] . entries [ 4 ] . checked ; }
function ( text , type ) { if ( typeof type == "undefined" ) type = "success" var alert = $ ( ".alert" ) ; if ( alert . length == 0 ) { alert = $ ( "<div class='alert alert-" + type + "' />" ) $ ( "#content" ) . prepend ( alert ) } alert . html ( text ) ; }
function ( menu ) { if ( menu . data ( 'scrollPanel' ) ) { console . log ( '---- update' , menu . data ( 'scrollPanel' ) ) ; menu . scrollPanel ( 'updateContainerWidth' ) ; } else { console . log ( '---- add' ) ; menu . scrollPanel ( { children : '> ul > li' } ) ; } }
function ( val , key ) { $scope . transactions . push ( val . attributes . amount ) ; $scope . current += val . attributes . amount ; }
function ( e ) { var $this = $ ( this ) ; var $tip = $this . find ( '.tip' ) ; $this . children ( '.arrow, .tip' ) . animate ( { 'opacity' : 0 } , 300 , function ( ) { $tip . css ( { 'left' : - 999 , 'top' : 0 } ) } ) ; $this . children ( '.callout' ) . animate ( { 'opacity' : 1 } , 300 ) ; }
function ShowMap ( ) { map = new google . maps . Map ( document . getElementById ( 'map' ) , { zoom : 7 , center : new google . maps . LatLng ( 50.009063 , 14.407082 ) , mapTypeId : google . maps . MapTypeId . ROADMAP } ) ; }
function ( ) { var body = $ ( "body" ) ; mediator . publish ( "xhr_start" ) ; equal ( body . hasClass ( "submit_disabled" ) , true , "xhr_start adds submit_disabled" ) ; mediator . publish ( "xhr_complete" ) ; equal ( body . hasClass ( "submit_disabled" ) , false , "xhr_complete removes submit_disabled" ) ; }
function ( err , usercheck ) { if ( usercheck > 0 ) { console . log ( 'user found, not creating a new one with the same name' ) ; req . flash ( 'error' , 'User already exists' ) ; res . redirect ( 'back' ) ; } else { var values = { user : req . body . username , pass : bcrypt . hashSync ( req . body . password , 8 ) } ; userdb . insert ( values , function ( err , post ) { req . flash ( 'New user added!' ) res . redirect ( '/' ) ; } ) ; } }
function createXmlHttpRequestObject ( ) { var xmlHttp ; if ( window . ActiveXObject ) { try { xmlHttp = new ActiveXObject ( "Microsoft.XMLHTTP" ) ; } catch ( e ) { xmlHttp = false ; } } else { try { xmlHttp = new XMLHttpRequest ( ) ; } catch ( e ) { xmlHttp = false ; } } if ( ! xmlHttp ) { alert ( "Error creating XMLHttp Object. Are you using a modern browser with Javascript enabled?" ) ; } else { return xmlHttp ; } }
function ( ) { if ( ! this . injection_initialized ) return ; this . model . fetch ( ) ; this . model . switch_state ( ) ; this . model . save ( ) ; this . _update_toolbar_button ( ) ; this . _update_page ( ) ; }
function ( ) { if ( ! this . injection_initialized ) { this . $el . addClass ( "inactive" ) . attr ( 'title' , 'Initializing...' ) ; return ; } if ( this . _is_active ( ) ) { this . $el . removeClass ( "inactive" ) . attr ( 'title' , 'Turn Off uQuest' ) ; } else { this . $el . addClass ( "inactive" ) . attr ( 'title' , 'Turn On uQuest' ) ; } }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function ( ) { $heatmap_canvas = $ ( '<canvas />' ) ; $heatmap_canvas . attr ( 'id' , html_id || DEFAULT_ID ) ; canvas_ctx = $heatmap_canvas [ 0 ] . getContext ( '2d' ) ; if ( window . devicePixelRatio > 1 && ( canvas_ctx . webkitBackingStorePixelRatio > 1 || ( typeof canvas_ctx . webkitBackingStorePixelRatio === "undefined" ) ) ) { backing_scale = window . devicePixelRatio ; } else { backing_scale = 1 ; } }
function ( ) { var rval ; try { rval = arguments [ numLogArgs + 1 ] . apply ( arguments [ numLogArgs ] , Array . prototype . slice . call ( arguments , iArg + 2 ) ) ; } catch ( ex ) { this . _eventMap [ name ] = ( this . _eventMap [ name ] || 0 ) + 1 ; rval = ex ; } return rval ; }
function ( ) { var failedBuildsCount = 0 ; var message = 'Build failed' ; var details = 'Build 123 failed' ; this . create = function ( ) { return { message : message , details : details , url : 'http://example.com/project/build/100' , state : { failedBuildsCount : failedBuildsCount } } ; } ; this . withFailedBuilds = function ( amount ) { if ( amount == 0 ) { message = 'Build fixed' ; details = 'Build 123 fixed' ; } else { message = 'Build failed' ; details = 'Build 123 failed' ; } failedBuildsCount = amount ; return this ; } ; }
function ( ) { var spyJQuery = spyOn ( jQuery , 'attr' ) ; var mockSettings = new MockSettingsBuilder ( ) . create ( ) ; frame . show ( mockSettings ) ; frame . show ( mockSettings ) ; expect ( spyJQuery . callCount ) . toBe ( 1 ) ; }
function ( ) { var spyJQuery = spyOn ( jQuery , 'attr' ) ; var mockSettings1 = new MockSettingsBuilder ( ) . create ( ) ; var mockSettings2 = new MockSettingsBuilder ( ) . create ( ) ; frame . show ( mockSettings1 ) ; frame . show ( mockSettings2 ) ; expect ( spyJQuery . callCount ) . toBe ( 2 ) ; }
function ( testModule ) { $ . fx . off = true ; jasmine . getFixtures ( ) . fixturesPath = 'fixtures' ; jasmine . getEnv ( ) . addReporter ( new jasmine . TrivialReporter ( ) ) ; jasmine . getEnv ( ) . execute ( ) ; }
function ( settings ) { if ( ! settings . url ) { throw { message : 'options.url not set' } ; } ; this . settings = settings ; this . responseReceived = new signals . Signal ( ) ; this . errorReceived = new signals . Signal ( ) ; }
function ( request ) { request . setRequestHeader ( 'Accept' , 'application/' + dataType ) ; }
function ( responsePlan ) { if ( ! responsePlan . key ) throw { name : 'ArgumentInvalid' , message : 'responsePlan.key is undefined' } ; this . state = 'Successful' ; this . key = responsePlan . key ; this . projectName = responsePlan . projectName ; this . name = responsePlan . shortName ; this . isEnabled = responsePlan . enabled ; this . isBuilding = responsePlan . isBuilding ; this . isActive = responsePlan . isActive ; this . url = responsePlan . link . href ; }
function ( settings ) { if ( ! ( settings && settings . url && settings . url != '' ) ) { throw new Error ( 'settings.url-input not set' ) ; } this . settings = settings ; this . responseReceived = new signals . Signal ( ) ; this . errorReceived = new signals . Signal ( ) ; }
function createAjaxRequestSettings ( settings , urlPath ) { var url = settings . url ; if ( ! endsWith ( url , '/' ) ) url += '/' ; url += 'rest/api/latest/' + urlPath ; return { url : url , username : settings . username , password : settings . password } ; }
function ( ) { var newSettings = { name : activeSettings . name , baseUrl : 'bamboo' , url : $ ( '.url-input' ) . val ( ) , updateInterval : parseInt ( $ ( '.update-interval-input' ) . val ( ) ) , username : $ ( '.username-input' ) . val ( ) , password : $ ( '.password-input' ) . val ( ) , plans : projectView . get ( ) . projects } ; return newSettings ; }
function projectInfo ( i , d ) { var name = $ ( d ) . attr ( 'name' ) ; return { isNew : self . projects [ name ] ? false : true , name : name , status : $ ( d ) . attr ( 'lastBuildStatus' ) } }
function ( json ) { var templateJson = createModel ( json ) , html = planSelectionTemplate ( templateJson ) ; rootElement . html ( html ) ; rootElement . collapse ( ) ; rootElement . find ( '.project-item input:checked' ) . each ( function ( ) { $ ( this ) . closest ( '.collapse' ) . addClass ( 'in' ) ; } ) ; rootElement . show ( ) ; }
function onBuildFixed ( buildEvent ) { var message = ( buildEvent . state . failedBuildsCount == 0 ) ? 'All builds are green !' : buildEvent . message ; var notification = { message : message , details : buildEvent . details , url : buildEvent . url , backgroundColor : '#D00' } ; showNotification ( notification ) ; updateBadge ( buildEvent . state ) ; }
function showNotification ( notificationInfo ) { var notification = window . webkitNotifications . createNotification ( "img/icon-128.png" , notificationInfo . message , notificationInfo . details ) ; notification . show ( ) ; if ( ! notificationInfo . sticky ) { var timer = new Timer ( ) ; timer . elapsed . addOnce ( closeNotification ) ; timer . start ( notificationTimeoutInSec ) ; } function closeNotification ( ) { notification . cancel ( ) ; } }
function addService ( service ) { if ( ! service . name ) throw { name : 'ArgumentInvalid' , message : 'service.name not defined' } ; initializeServiceLogging ( service ) ; subscribeTo ( service ) ; services . push ( service ) ; console . log ( 'Service added: ' + service . name , service . settings ) ; serviceAdded . dispatch ( service ) ; }
function removeService ( service ) { var index = services . indexOf ( service ) ; if ( index < 0 ) throw { name : 'NotFound' , message : 'Service not found' } ; services . splice ( index , 1 ) ; service . stop ( ) ; unsubscribeFrom ( service ) ; serviceRemoved . dispatch ( service ) ; }
function ( linkElement ) { var serviceLink = $ ( linkElement ) ; if ( serviceLink . hasClass ( 'active' ) ) return ; $ ( '#service-list li' ) . removeClass ( 'active' ) ; serviceLink . addClass ( 'active' ) ; itemSelected . dispatch ( linkElement ) ; }
function ( signals ) { var Timer = function ( ) { this . timeout = 0 ; this . elapsed = new signals . Signal ( ) ; } ; Timer . prototype . start = function ( seconds ) { this . timeout = seconds ; var self = this ; setTimeout ( onTimeout , this . timeout * 1000 ) ; function onTimeout ( ) { self . elapsed . dispatch ( ) ; } } ; return Timer ; }
function ( type ) { if ( ! this . _events ) this . _events = { } ; if ( ! this . _events [ type ] ) this . _events [ type ] = [ ] ; if ( ! isArray ( this . _events [ type ] ) ) { this . _events [ type ] = [ this . _events [ type ] ] ; } return this . _events [ type ] ; }
function ( ) { for ( var c = 0 ; c < sakai . config . worldTemplates . length ; c ++ ) { if ( sakai . config . worldTemplates [ c ] . id === group [ "sakai:category" ] ) { groupType = sakai . api . i18n . getValueForKey ( sakai . config . worldTemplates [ c ] . title ) ; } } }
function ( ) { renderObj = { api : sakai . api , groups : getSelected ( ) , memberOfGroups : sakai . api . Groups . getMemberships ( sakai . data . me . groups ) , worlds : sakai . config . worldTemplates } ; if ( ! $addpeoplegroupsWidget . is ( ":visible" ) ) { getMemberships ( ) ; } else { $addpeoplegroupsWidget . toggle ( ) ; } }
function ( ) { $ . each ( sakai . config . worldTemplates , function ( index , item ) { tabs . push ( { id : item . id , title : sakai . api . i18n . getValueForKey ( item . titlePlural ) } ) ; } ) ; fetchWorldData ( ) ; }
function write ( view , truthy ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; if ( ! ! truthy ) { if ( view . is ( ":empty" ) ) { var render = view . data ( hdRenderName ) ; var copy = render ( ) ; view . append ( copy ) ; } } else { view . empty ( ) ; } }
function bindIf ( view , variable , context ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; var template = view . contents ( ) . detach ( ) ; view . data ( hdRenderName , function renderIf ( ) { var copy = template . clone ( ) ; hd . bindTree ( copy , context ) ; return copy ; } ) ; hd . bindWrite ( variable , view , { write : write } ) ; return true ; }
function adapt ( o ) { [ "subscribers" , "subscribe" , "publish" ] . forEach ( function ( f ) { if ( o [ f ] !== undefined ) { ERROR ( "new publisher already has property: " + f ) ; } } ) ; o . subscribers = { } ; o . subscribe = subscribe ; o . publish = publish ; }
function writeAttr ( view , value ) { DEBUG_BEGIN ; ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; if ( typeof value !== "string" ) { WARNING ( "be careful setting attribute " + attrName + " to a non-string value" ) ; } DEBUG_END ; view . attr ( attrName , value ) ; }
function writeText ( view , value ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; if ( typeof value !== "string" ) value = JSON . stringify ( value ) ; view . text ( value ) ; }
function push ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; vv . changeEvent = { adds : [ { index : vv . value . length , howMany : arguments . length } ] } ; Array . prototype . push . apply ( vv . value , arguments ) ; runtime . touch ( vv ) ; }
function pop ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; if ( vv . value . length === 0 ) return ; vv . changeEvent = { removes : [ { index : vv . value . length - 1 , howMany : 1 } ] } ; vv . value . pop ( ) ; runtime . touch ( vv ) ; }
function hdVariableProxy ( value ) { if ( arguments . length > 0 ) { ASSERT ( ! evaluator . isUpdating ( ) , "do not set variables from within methods" ) ; LOG ( "edited " + vv + ": " + JSON . stringify ( value ) ) ; vv . set ( value ) ; runtime . touch ( vv ) ; } else { return evaluator . get ( vv ) ; } }
function ( e ) { var handles = this . _eventHandles ; if ( handles . dataChange ) { handles . dataChange . detach ( ) ; this . bindUI ( ) ; } if ( this . tbodyNode ) { this . render ( ) ; } }
function ( e ) { var handles = this . _eventHandles ; if ( handles . dataChange ) { handles . dataChange . detach ( ) ; this . bindUI ( ) ; } if ( this . tbodyNode ) { this . render ( ) ; } }
function ( ) { if ( jQuery . browser . msie && parseInt ( jQuery . browser . version , 10 ) < 7 ) { return ; } $ ( function ( ) { $ ( 'a[rel=tooltip]' ) . tooltip ( ) ; $ ( 'span[rel=twipsy]' ) . tooltip ( ) ; } ) ; $ ( '#gallery' ) . carousel ( ) ; }
function ( opts ) { var options = opts || { } ; if ( ! this . options . enableInfoWindow || this . addPanel . is ( ":visible" ) || this . infoWindow . isMouseover || this . tooltip . feature == options . feature || options . feature == this . infoWindow . feature ) return ; this . tooltip . open ( options ) ; }
function ( map , opt_force ) { this . map = map ; this . forEach ( function ( feature ) { return feature . setMap ( this . map , opt_force ) ; } ) ; return this . handleMapEvents ( ) ; }
function Balloon ( options ) { this . options = options != null ? options : { } ; this . width = options . width || this . defaultWidth ; console . log ( this . width ) ; this . createInfoBox ( this . options ) ; this . setMap ( this . options . map ) ; this . customize ( ) ; }
function ( ) { var _ref ; this . infoBox . close ( ) ; if ( ( _ref = this . feature ) != null ? _ref . isHighlighted : void 0 ) { this . feature . setHighlight ( false ) ; } this . feature = null ; return this . isMouseover = false ; }
function ( e ) { that . isMouseover = e . offsetX > 10 || e . toElement !== div ; if ( that . isMouseover ) { e . cancelBubble = true ; if ( typeof e . preventDefault === "function" ) e . preventDefault ( ) ; if ( typeof e . stopPropagation === "function" ) e . stopPropagation ( ) ; return that . map . closeTooltip ( ) ; } }
function ( ) { try { if ( geo_object . type === 'google' ) { editor . goTo ( geo_object . geo ) ; } else { editor . loadGeoJSON ( geo_object . geo , true ) ; } return clearInterval ( intvl ) ; } catch ( _e ) { } }
function ( ) { spyOnPromise ( Mongo , 'deleteTarget' ) . andCallSuccess ( ) ; spyOnPromise ( Mongo , 'findTargetById' ) . andCallSuccess ( ) ; spyOnPromise ( Mongo , 'deleteTargetById' ) . andCallSuccess ( ) ; req . params . id = '12345678901234567890abcd' ; API . deleteTarget ( req , res , next ) ; expect ( Mongo . deleteTargetById ) . toHaveBeenCalledWith ( '12345678901234567890abcd' ) ; expectStatus ( res ) . toEqual ( 204 ) ; }
function formatToURL ( hash ) { if ( TDConfig ( "rest.port" ) == 80 && TDConfig ( "rest.port" ) != ( process . env . PORT || TDConfig ( "rest.port" ) ) ) { return "http://" + TDConfig ( "rest.host" ) + "/" + hash ; } else { return "http://" + TDConfig ( "rest.host" ) + ":" + TDConfig ( "rest.port" ) + "/" + hash ; } }
function ( ) { var _this = this ; return this . playerUpdateInterval = setInterval ( function ( ) { var data ; if ( ! now . sendPlayerUpdate ) { return ; } data = { } ; _this . fire ( 'willSendPlayerUpdate' , data ) ; if ( ! data . cancel ) { return now . sendPlayerUpdate ( data ) ; } } , Milk . NetworkClient . UPDATE_INTERVAL ) ; }
function ( cb ) { if ( typeof ( define ) === 'function' && define . amd ) { require ( [ 'contracts' ] , cb ) ; } else if ( typeof ( require ) === 'function' ) { cb ( require ( 'contracts.js' ) ) ; } else { cb ( window . contracts ) ; } }
function ( cb ) { if ( typeof ( define ) === 'function' && define . amd ) { require ( [ 'contracts' ] , cb ) ; } else if ( typeof ( require ) === 'function' ) { cb ( require ( 'contracts.js' ) ) ; } else { cb ( window . contracts ) ; } }
function ( cb ) { if ( typeof ( define ) === 'function' && define . amd ) { require ( [ 'contracts' ] , cb ) ; } else if ( typeof ( require ) === 'function' ) { cb ( require ( 'contracts.js' ) ) ; } else { cb ( window . contracts ) ; } }
function ( ) { var a ; if ( typeof inBrowser !== "undefined" && inBrowser !== null ) { a = __contracts . guard ( __contracts . arr ( [ Num , __contracts . arr ( [ Str , Bool ] ) ] ) , [ 42 , [ "foo" , true ] ] ) ; eq ( a [ 1 ] [ 0 ] , "foo" , "nested array get abides by contract" ) ; return throws ( ( function ( ) { return a [ 1 ] [ 0 ] = 42 ; } ) , "nested array set violates contract" ) ; } }
function ( ) { var f ; f = __contracts . guard ( __contracts . fun ( [ __contracts . object ( { foo : Str } , { } ) ] , Str , { } ) , function ( o ) { return o . foo ; } ) ; eq ( f ( { foo : "bar" } ) , "bar" , "correct object" ) ; return throws ( ( function ( ) { return f ( "string" ) ; } ) , "string instead of an object, but should complain about missing property" ) ; }
function ( ) { var g ; g = __contracts . guard ( __contracts . fun ( [ __contracts . object ( { toString : __contracts . fun ( [ Any ] , Str , { } ) } , { } ) ] , Str , { } ) , function ( s ) { return s . toString ( ) ; } ) ; return throws ( ( function ( ) { return g ( "foo" ) ; } ) , "foo is a string but expects object" ) ; }
function ( ) { var a ; a = __contracts . guard ( __contracts . fun ( [ __contracts . object ( { a : Str , b : Str } , { } ) ] , Any , { } ) , function ( b ) { return console . log ( b ) ; } ) ; return blames ( ( function ( ) { return a ( null ) ; } ) ) ; }
function ( b ) { return arguments . length ; }
function ( target , selector , seconds ) { try { this . _target = target ; this . _selector = selector ; this . _elapsed = - 1 ; this . _interval = seconds || 0 ; return true ; } catch ( e ) { return false ; } }
function ( target , selector , seconds ) { if ( arguments < 2 ) throw new Error ( "timerWithTarget'argument can't is null" ) ; var timer = new cc . Timer ( ) ; if ( arguments . length == 2 ) { timer . initWithTarget ( target , selector , 0 ) ; } else { timer . initWithTarget ( target , selector , seconds ) ; } return timer ; }
function ( ) { if ( ! selfSet ) { self = this ; } var args = Array . prototype . slice . call ( arguments ) ; var overloadMatch = findOverload ( overloadDefs , args ) ; if ( ! overloadMatch ) { throw new Error ( createErrorMessage ( 'No match found.' , overloadDefs ) ) ; } var overloadFn = overloadMatch [ overloadMatch . length - 1 ] ; overloadFn . apply ( self , args ) ; }
function ( ) { it ( "stubs modules in given context" , function ( ) { require ( './stubber' ) . stubbed . should . equal ( 'stubbed module' ) ; } ) ; it ( "stubs modules in child context" , function ( ) { require ( './stubber' ) . child . stubbed . should . equal ( 'stubbed module' ) ; } ) ; it ( "doesn't stub in parent context" , function ( ) { ( function ( ) { require ( 'stubbed' ) ; } ) . should . Throw ( "Cannot find module 'stubbed'" ) ; } ) ; }
function ( frequency , amp , attack , decay ) { var val = osc ( frequency , amp ) * env ( attack , decay ) ; return val ; }
function ( ) { $ ( '#hugridButton' ) . toggleClass ( 'buttonisoff' ) $ ( '#hugrid' ) . toggle ( ) ; $ ( '#hugridRows' ) . toggle ( ) ; $ ( "#hugridButton span" ) . toggle ( ) ; if ( gridstate === 'on' ) { gridstate = 'off' } else { gridstate = 'on' } }
function ( doc , cdt , cdn ) { cur_frm . toggle_fields ( [ 'tax_rate' ] , doc . account_type == 'Tax' ) cur_frm . toggle_fields ( [ 'master_type' , 'master_name' ] , cstr ( doc . account_type ) == '' ) }
function ( ) { if ( this . display ) return ; this . set_postion ( ) $ds ( this . wrapper ) ; freeze ( ) ; this . display = true ; cur_dialog = this ; if ( this . onshow ) this . onshow ( ) ; }
function ( txt ) { if ( ! txt ) txt = d . input && d . input . query_description || null ; if ( txt ) { d . rows [ 'Help' ] . innerHTML = '<div class="help-box" style="margin-top:0px">' + txt + '</div>' ; } else { d . rows [ 'Help' ] . innerHTML = '' } }
function ( parent , frm ) { this . appframe = new wn . ui . AppFrame ( parent ) this . appframe . $titlebar . append ( '</span>\     <span class="breadcrumb-area"></span>' ) ; this . $w = this . appframe . $w ; } , refresh : function ( ) { wn . views . breadcrumbs ( $ ( this . $w . find ( '.breadcrumb-area' ) ) , cur_frm . meta . module , cur_frm . meta . name , cur_frm . docname ) ; this . refresh_labels ( ) ; this . refresh_toolbar ( ) ; }
function ( txt ) { if ( ! this . intro_area ) { this . intro_area = $ ( '<div class="help-box form-intro-area">' ) . insertBefore ( this . page_layout . body . firstChild ) ; } if ( txt ) { this . intro_area . html ( txt ) ; } else { this . intro_area . remove ( ) ; this . intro_area = null ; } }
function ( ) { var f = this . page_layout . footer ; if ( f . save_area ) { if ( get_url_arg ( 'embed' ) || ( this . editable && ( ! this . meta . in_dialog || this . in_form ) && this . doc . docstatus == 0 && ! this . meta . istable && this . get_doc_perms ( ) [ WRITE ] ) ) { f . show_save ( ) ; } else { f . hide_save ( ) ; } } }
function ( from_form ) { var hidden = 0 ; if ( ( ! this . perm [ this . df . permlevel ] ) || ( ! this . perm [ this . df . permlevel ] [ READ ] ) || this . df . hidden ) { hidden = 1 ; } if ( hidden ) { if ( this . row ) this . row . hide ( ) ; } else { if ( this . collapsible ) { } } }
function ( ) { if ( this . display ) return ; this . set_postion ( ) $ds ( this . wrapper ) ; freeze ( ) ; this . display = true ; cur_dialog = this ; if ( this . onshow ) this . onshow ( ) ; }
function ( doc , cdt , cdn ) { cur_frm . cscript . hide_unhide_group_ledger ( doc ) ; cur_frm . add_custom_button ( 'Back To Chart of Cost Centers' , function ( ) { wn . set_route ( 'Accounts Browser' , 'Cost Center' ) ; } , 'icon-arrow-left' ) var intro_txt = '' ; if ( ! doc . __islocal && doc . group_or_ledger == 'Group' ) { intro_txt += '<p><b>Note:</b> This is Cost Center is a <i>Group</i>, \ 			Accounting Entries are not allowed against groups.</p>' ; } cur_frm . set_intro ( intro_txt ) ; }
function ( doc , dt , dn ) { if ( doc . __islocal ) { hide_field ( [ 'repost_account_balances' , 'repost_voucher_outstanding' ] ) ; set_multiple ( dt , dn , { 'is_fiscal_year_closed' : 'No' } ) ; } else unhide_field ( [ 'repost_account_balances' , 'repost_voucher_outstanding' ] ) ; }
function ( wrapper ) { var ctype = wn . get_route ( ) [ 1 ] || 'Account' ; wrapper . appframe . title ( 'Chart of ' + ctype + 's' ) ; if ( erpnext . account_chart && erpnext . account_chart . ctype != ctype ) { wrapper . $company_select . change ( ) ; } }
function ( wrapper ) { var ctype = wn . get_route ( ) [ 1 ] || 'Territory' ; wrapper . appframe . title ( ctype + ' Tree' ) ; if ( erpnext . sales_chart && erpnext . sales_chart . ctype != ctype ) { wrapper . make_tree ( ) ; } }
function gCtByGroup ( successCb , errorCb , contacts ) { if ( typeof contacts !== 'undefined' ) { buildContacts ( contacts ) ; } else { var options = { sortBy : 'familyName' , sortOrder : 'ascending' } ; var request = api . find ( options ) ; request . onsuccess = function findCallback ( ) { buildContacts ( request . result ) ; successCb ( ) ; } ; request . onerror = errorCb ; } }
function ( next ) { var self = this ; self . program . update = path . resolve ( self . program . update ) ; var exists = path . existsSync ( self . program . update ) ; if ( ! exists ) self . program . invalidOptionValue ( '-u, --update <path>' , 'Path does not exist! Cannot update.' ) ; self . deployDataAndPlugins ( product . basedir , self . program . update , true , self . program . symlink , next ) ; }
function ( dst , data , force ) { try { if ( path . existsSync ( dst ) && ! force ) throw filePath + " already exists" ; var fd = fs . openSync ( dst , 'w' ) ; fs . writeSync ( fd , data ) ; fs . close ( fd ) ; } catch ( e ) { return - 1 ; } return 0 ; }
function ( src , dst , force , symlink ) { if ( path . existsSync ( dst ) && ! force ) { return - 1 ; } if ( symlink ) { fs . symlinkSync ( src , dst , 'file' ) ; return 0 ; } var data = fs . readFileSync ( src ) ; return fs . writeFileSync ( dst , data ) ; }
function gotError ( error ) { this . node . failed ( { reason : error . message , attempt : this , message : this . node . ip + ':' + this . node . port + ' error: ' + error . message } , this ) this . node . setHealthy ( false ) }
function gotAborted ( ) { this . request . node . failed ( { reason : 'aborted' , attempt : this . request , message : this . request . node . ip + ':' + this . request . node . port + ' error: connection aborted' } , this . request ) }
function ( index , value ) { addLink ( value ) ; }
function ( set ) { deepEqual ( Popcorn . dom . find ( set . selector ) , fixture , set . desc + ", selector as-is" ) ; deepEqual ( Popcorn . dom . find ( "  " + set . selector ) , fixture , set . desc + ", selector w/ leading whitespace" ) ; deepEqual ( Popcorn . dom . find ( set . selector + "  " ) , fixture , set . desc + ", selector w/ trailing whitespace" ) ; }
function ( ) { $ ( '#hugridButton' ) . toggleClass ( 'buttonisoff' ) $ ( '#hugrid' ) . toggle ( ) ; $ ( '#hugridRows' ) . toggle ( ) ; $ ( "#hugridButton span" ) . toggle ( ) ; if ( gridstate === 'on' ) { gridstate = 'off' } else { gridstate = 'on' } }
function ( renderer ) { for ( var i = 0 , iMax = this . entities . length ; i < iMax ; ++ i ) { var entity = this . entities [ i ] ; if ( entity . model ) { entity . model . visible = ! entity . outOfBounds ( 20 ) ; } } renderer . render ( this . scene , this . camera ) ; }
function ( ) { width = image . width ; height = image . height ; canvas = document . getElementById ( "bombs" ) ; y = ( index - ( index % numFrames ) ) / numFrames * frameSize ; x = ( index % numFrames ) * frameSize ; context = canvas . getContext ( "2d" ) ; context . drawImage ( image , x , y , frameSize , frameSize , xpos * mul + 4 , ypos * mul + 4 , frameSize , frameSize ) ; }
function removeBomb ( xpos , ypos ) { var canvas , context ; var mul = 30 ; canvas = document . getElementById ( "bombs" ) ; context = canvas . getContext ( "2d" ) ; context . clearRect ( xpos * mul + 4 , ypos * mul + 4 , 30 , 30 ) ; }
function removeObstacle ( xpos , ypos ) { var canvas , context ; var mul = 30 ; canvas = document . getElementById ( "obstacles" ) ; context = canvas . getContext ( "2d" ) ; context . clearRect ( xpos * mul + 4 , ypos * mul + 4 , 30 , 30 ) ; }
function drawObstacle ( xpos , ypos ) { width = image . width ; height = image . height ; canvas = document . getElementById ( "obstacles" ) ; y = ( index - ( index % numFrames ) ) / numFrames * frameSize ; x = ( index % numFrames ) * frameSize ; context = canvas . getContext ( "2d" ) ; context . drawImage ( image , x , y , frameSize , frameSize , xpos * mul + 4 , ypos * mul + 4 , frameSize , frameSize ) ; }
function ( u ) { if ( isDefined ( params [ u . unit ] ) || isDefined ( params [ u . unit + 's' ] ) ) { params . specificity = u . unit ; return false ; } else if ( reset && u . unit !== 'week' && u . unit !== 'year' ) { callDateMethod ( date , 'set' , utc , u . method , ( u . unit === 'day' ) ? 1 : 0 ) ; } }
function ( e ) { var key ; if ( e == null ) { return ; } key = e . which ; _this . handleKeyPress ( key ) ; if ( KEYSTATES [ key ] != null ) { clearTimeout ( KEYSTATES [ key ] ) ; } }
function ( onModuleReady ) { onModuleReady ( ) ; if ( butter . config . value ( "ui" ) . enabled !== false ) { var editorAreaDOMRoot = LangUtils . domFragment ( EDITOR_AREA_LAYOUT ) ; butter . ui . areas . editor = new butter . ui . Area ( "editor-area" , editorAreaDOMRoot ) ; document . body . classList . add ( "butter-editor-spacing" ) ; document . body . appendChild ( editorAreaDOMRoot ) ; } }
function ( ) { var slots = this . maxValues - this . deck . children ( ) . length ; if ( this . maxValues && slots < 1 ) { var choice = $ ( this . deck . children ( ) [ 0 ] ) ; this . select . find ( 'option[data-value=' + choice . attr ( 'data-value' ) + ']' ) . attr ( 'selected' , '' ) . remove ( ) ; choice . remove ( ) ; } }
function ( choice , value ) { var existing_choice = this . deck . find ( '[data-value=' + value + ']' ) ; if ( ! existing_choice . length ) { var choice = choice . clone ( ) ; if ( ! choice . attr ( 'data-value' ) ) { choice . attr ( 'data-value' , value ) ; } this . deck . append ( choice ) ; choice . append ( this . widget . find ( '.remove:not(:visible)' ) . clone ( ) . show ( ) ) ; } }
function updateWidgetValue ( value ) { var choice = widget . deck . find ( '[data-value=' + value + ']' ) ; if ( ! choice . length ) { var choice = widget . choiceTemplate . clone ( ) ; var html = widget . select . find ( 'option[value=' + value + ']' ) . html ( ) ; choice . html ( html ) ; choice . attr ( 'data-value' , value ) ; widget . selectChoice ( choice ) ; } }
function ( err ) { if ( err && err . advice ) { if ( err . advice === 'reconnect' && this . connected ) { this . disconnect ( ) ; this . reconnect ( ) ; } } this . publish ( 'error' , err && err . reason ? err . reason : err ) ; }
function ( result ) { if ( ! result . value ) { builder . selenium2 . playback . execute ( 'clickElement' , { id : target } ) ; } else { builder . selenium2 . playback . recordResult ( { success : true } ) ; } }
function ( i , s ) { var assetURL = $ . tapestry . utils . rebuildURL ( s . href ) ; if ( $ ( 'head link[href="' + assetURL + '"]' ) . size ( ) === 0 ) { stylesheet = '<link href="' + assetURL + '" type="text/css" rel="stylesheet"' ; if ( s . media ) stylesheet += ' media="' + s . media + '" ' ; stylesheet += '/>' ; $ ( 'head' ) . append ( stylesheet ) ; } }
function fetchChanges ( ) { txn = idb . transaction ( [ DOC_STORE , BY_SEQ_STORE ] ) ; var req = descending ? txn . objectStore ( BY_SEQ_STORE ) . openCursor ( IDBKeyRange . lowerBound ( opts . seq , true ) , descending ) : txn . objectStore ( BY_SEQ_STORE ) . openCursor ( IDBKeyRange . lowerBound ( opts . seq , true ) ) ; req . onsuccess = onsuccess ; req . onerror = onerror ; }
function ( type , indexName , callback ) { if ( Array . isArray ( indexName ) ) { var delfn = naan . curry ( indexModule . delete , type ) ; return async . map ( indexName , delfn , callback ) ; } var endpoint = util . format ( 'index/%s/%s' , type , indexName ) ; var op = this . operation ( endpoint , 'DELETE' ) ; this . call ( op , function ( err ) { callback ( err ) ; } ) ; }
function ( trackEvent ) { var targetList = createTargetsList ( trackEvent ) ; var manifestOptions = trackEvent . manifest . options ; for ( var item in manifestOptions ) { if ( manifestOptions . hasOwnProperty ( item ) ) { _rootElement . appendChild ( createManifestItem ( item , manifestOptions [ item ] , trackEvent . popcornOptions [ item ] , trackEvent ) ) ; } } _rootElement . appendChild ( targetList ) ; _this . updatePropertiesFromManifest ( trackEvent . popcornOptions ) ; }
function openEditor ( trackEvent ) { if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( "default" , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; }
function ( row , index ) { return { relic_id : row . relic_id , nid_id : row . nid_id , name : row . identification , name_action : row . identification_action , street : row . street , street_action : row . street_action , date : row . dating , date_action : row . dating_action , categories : row . categories } ; }
function ( e ) { if ( Math . abs ( e . touches [ 0 ] . pageX - startX ) > 100 ) { if ( ( e . touches [ 0 ] . pageX - startX ) > 5 ) { swipeLeft = true ; } else { swipeLeft = false ; } swipe = true ; } }
function IE_diff_mode ( item ) { var patch = JsDiff . createPatch ( item . attr ( 'data-file-name' ) , $ ( '#old' ) . text ( ) , $ ( '#new' ) . text ( ) ) ; item . val ( patch ) ; item . attr ( 'readOnly' , true ) ; }
function ( code ) { try { functions = evaluate ( code ) ( vfs , onEvaluate ) ; } catch ( err ) { console . error ( err . stack ) ; api . emit ( "error" , err ) ; return ; } api . emit ( "ready" ) ; }
function ( c ) { return c . rank ; }
function ( ) { var grouped = _ . groupBy ( this . cards , 'suit' ) ; _ . each ( grouped , function ( cardList , index , list ) { var sorted = _ . sortBy ( cardList , function ( c ) { return c . rank ; } ) ; list [ index ] = sorted ; } ) ; var flattened = _ . flatten ( grouped ) ; this . cards = flattened ; }
function ( move ) { var jsonCard = move [ 'card' ] ; var seqNo = move [ 'sequenceNumber' ] ; var card = new Card ( jsonCard [ 'rank' ] , jsonCard [ 'suit' ] ) ; var player = game . getPlayerById ( move [ 'playerId' ] ) ; moves . push ( new PlayerMove ( player , card , seqNo ) ) ; }
function View ( game ) { this . game = game ; this . canvas = new Raphael ( 'canvas' , constants . WIDTH , constants . HEIGHT ) ; this . repository = new Repository ( ) ; this . taskQueue = new TaskQueue ( ) ; this . splashVisible = false ; }
function ( ) { if ( ! this . _handle || ! this . _handle . getpeername ) { return { } ; } if ( ! this . _peername ) { this . _peername = this . _handle . getpeername ( ) ; } return this . _peername ; }
function exportGPX ( req , res , runID ) { createGPX ( req . session . userID , runID , function ( gpx , fileName ) { res . setHeader ( 'Content-Disposition' , 'attachment; filename=' + fileName ) ; res . setHeader ( 'Content-Type' , 'application/gpx+xml' ) ; res . send ( gpx ) ; } ) ; }
function ( err , fileStat ) { if ( fileStat . isDirectory ( ) ) copyDirRecursive ( file , newFile , copyFiles ) ; else if ( fileStat . isSymbolicLink ( ) ) fs . readlink ( file , function ( err , link ) { fs . symlink ( link , newFile , copyFiles ) ; } ) ; else fs . readFile ( file , function ( err , data ) { fs . writeFile ( newFile , data , copyFiles ) ; } ) ; }
function ( ) { for ( var i = 0 ; i < arguments . length ; i ++ ) { var obj = arguments [ i ] ; var shouldAdd = true ; for ( var j = 0 ; j < this . length ; j ++ ) { if ( obj . name === this [ j ] . name ) { shouldAdd = false ; } } if ( shouldAdd ) { this . push ( obj ) ; } } }
function ( ) { for ( var i = 0 ; i < this . length ; i ++ ) { delete this [ i ] ; } this . length = 0 ; }
function ( name , modulator , type ) { var type = type || "+" ; var m = { type : type , operands : [ this [ name ] , modulator ] , name : name } ; this [ name ] = m ; modulator . modding . push ( { ugen : this , mod : m } ) ; this . mods . push ( m ) ; Gibberish . generate ( this ) ; Gibberish . dirty ( this ) ; return modulator ; }
function ( m ) { var _m = require ( '/app/models/' + m . name ) , mName = m . name . toLowerCase ( ) ; models [ mName ] = new _m ( Como ) ; }
function ( ) { this . interactionResolution = 2 ; this . _featureMap = { } ; this . _initializeIcons ( ) ; this . _allRequests = [ ] ; this . _markerPoolSize = Config . maxMarkers || 500 ; this . _currentPopup = null ; }
function ( name , e ) { var event = document . createEvent ( 'MouseEvents' ) ; event . initMouseEvent ( name , true , true , window , 0 , e . page . x , e . page . y , e . client . x , e . client . y , false , false , false , false , 0 , null ) ; event . $valid = true ; populate ( event , e ) ; target . dispatchEvent ( event ) ; return this ; }
function ( dest , from ) { var list = [ { identifier : uniqid , target : target , pageX : from . page . x , pageY : from . page . y , clientX : from . client . x , clientY : from . client . y } ] ; dest . touches = list ; dest . targetTouches = list ; dest . changedTouches = list ; return this ; }
function ( dest , from ) { dest . touches = from . touches ; dest . targetTouches = from . targetTouches ; dest . changedTouches = from . changedTouches ; return this ; }
function ( name , e ) { var event = document . createEvent ( 'MouseEvents' ) ; event . initMouseEvent ( name , true , true , window , 0 , e . page . x , e . page . y , e . client . x , e . client . y , false , false , false , false , 0 , null ) ; event . $valid = true ; populate ( event , e ) ; target . dispatchEvent ( event ) ; return this ; }
function ( dest , from ) { var list = [ { identifier : uniqid , target : target , pageX : from . page . x , pageY : from . page . y , clientX : from . client . x , clientY : from . client . y } ] ; dest . touches = list ; dest . targetTouches = list ; dest . changedTouches = list ; return this ; }
function ( dest , from ) { dest . touches = from . touches ; dest . targetTouches = from . targetTouches ; dest . changedTouches = from . changedTouches ; return this ; }
function ( ) { var prefix = defaults . prefix ; if ( prefix !== "" ) { prefix = prefix . match ( '\/$' ) ? prefix : ( prefix + '/' ) ; } return prefix ; }
function ( ) { t . assertEqual ( [ 1 , 2 ] , events ) ; }
function match_start ( matched ) { resetMarkedOffset = ( atok . markedOffset < 0 ) if ( resetMarkedOffset ) atok . markedOffset = atok . offset - matched }
function match_start ( matched ) { resetMarkedOffset = ( atok . markedOffset < 0 ) if ( resetMarkedOffset ) atok . markedOffset = atok . offset - matched }
function ( done ) { function handler ( token , idx , type ) { err = new Error ( 'Handler should not be called' ) } p . on ( 'data' , handler ) p . write ( 'abc)def' ) assert . equal ( p . atok . offset , 0 ) done ( err ) }
function ( e ) { Utils . debug ( "Recieved a drop event " ) ; if ( e . stopPropagation ) { e . stopPropagation ( ) ; } if ( window . appView . insertUnicodeView . dragSrcEl != this ) { e . target . value = e . target . value + window . appView . insertUnicodeView . dragSrcEl . innerHTML ; } return false ; }
function ( Backbone ) { var InsertUnicode = Backbone . Model . extend ( { initialize : function ( ) { } , defaults : { symbol : "" } , model : { } } ) ; return InsertUnicode ; }
function ( ) { this . setElement ( $ ( "#insert-unicode" ) ) ; $ ( this . el ) . html ( this . template ( { } ) ) ; this . insertUnicodesView . el = this . $ ( "#unicodes" ) ; this . insertUnicodesView . render ( ) ; return this ; }
function ( ) { var m = new InsertUnicode ( { "symbol" : this . $el . children ( ".insert-unicode-input" ) . val ( ) , } ) ; app . get ( "authentication" ) . get ( "userPrivate" ) . get ( "prefs" ) . get ( "unicodes" ) . add ( m ) ; }
function ( e ) { this . classList . add ( "halfopacity" ) ; window . appView . insertUnicodeView . dragSrcEl = this ; e . dataTransfer . effectAllowed = 'move' ; e . dataTransfer . setData ( 'text/html' , this . innerHTML ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'update_history' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 58 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 783 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 805 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 846 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 877 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 978 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'edit-issue.iced' , funcname : 'onhashchange' } ) ; $ . getJSON ( "/api/" + hash , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return data = arguments [ 0 ] ; } ; } ) ( ) , lineno : 23 } ) ) ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'edit-list.iced' } ) ; $ . getJSON ( "/api" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return data = arguments [ 0 ] ; } ; } ) ( ) , lineno : 1 } ) ) ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'update_history' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 58 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 783 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 805 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 846 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 877 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 978 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'update_history' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 58 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 783 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 805 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 846 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 877 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 978 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'update-issue.iced' , funcname : 'onhashchange' } ) ; $ . getJSON ( "/api/" + hash , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return data = arguments [ 0 ] ; } ; } ) ( ) , lineno : 25 } ) ) ) ; __iced_deferrals . _fulfill ( ) ; }
function ( ) { if ( dropDown . isOpened ( ) ) dropDown . closeUp ( ) ; else { dropDown . dropDown ( ) ; if ( ! dropDown . _cachingAllowed ) dropDown . _clearSuggestions ( ) ; dropDown . _checkAdditionalPageNeeded ( ! dropDown . _cachingAllowed ) ; } if ( ! dropDown . _ddf_focused ) { if ( dropDown . _field . value != dropDown . _promptText ) { dropDown . focus ( ) ; } } else { dropDown . _reacquireFocus = true ; } }
function ( i , siteID ) { var currentFrame = $ ( '<iframe />' ) ; currentFrame . attr ( 'id' , siteID ) ; currentFrame . addClass ( 'siteDisplay' ) currentFrame . addClass ( "notCurrent" ) ; siteDisplayDiv . append ( currentFrame ) ; loadIframes ( siteID ) ; if ( i == 0 ) { currentFrame . load ( function ( ) { $ ( this ) . removeClass ( "notCurrent" ) . addClass ( "currentSite" ) } ) ; } }
function nextSite ( ) { $ ( ".currentSite" ) . addClass ( "notCurrent" ) . removeClass ( "currentSite" ) ; currentSiteID = siteIDs [ currentSiteIndex + 1 ] ; currentFrame = $ ( "#" + String ( currentSiteID ) ) ; currentFrame . removeClass ( "notCurrent" ) . addClass ( "currentSite" ) ; if ( currentSiteIndex < siteIDs . length - 1 ) { currentSiteIndex += 1 ; currentNoteIndex = 0 ; console . log ( currentNoteIndex ) ; } }
function addSiteToTrail ( ) { currentSite = window . location . href ; $ . ajax ( { url : "http://localhost:3000/sites" , type : "post" , crossDomain : true , data : { "site[url]" : currentSite , "site[trail_id]" : trailID , "site[title]" : document . title , "user" : userID , notes : "none" } , success : addFaviconsToDisplay } ) }
function ( data ) { widget = data [ 'editor' ] ; PTL . editor . updateBreadcrumbs ( data [ 'dircrumbs' ] , data [ 'storecrumbs' ] ) ; PTL . editor . updatePager ( PTL . editor . createPager ( uid ) ) ; if ( data . ctx ) { PTL . editor . ctxGap = 2 ; ctx . before = data . ctx . before ; ctx . after = data . ctx . after ; } }
function ( index , howMany , removedArray , isLocal ) { var id = removedArray [ 0 ] . id ; fn ( id ) ; }
function ( model ) { model . setNull ( docPath , { entities : [ ] } ) ; window . model = model ; window . doc = ( require ( "./doc" ) ) ( model ) ; var useQunit = model . get ( '_useQunit' ) ; if ( ! useQunit ) { ( require ( "./client" ) ) ( model ) ; } }
function ( dir ) { var parent ; if ( path . existsSync ( path . join ( dir , 'Cakefile' ) ) ) return dir ; parent = path . normalize ( path . join ( dir , '..' ) ) ; if ( parent !== dir ) return cakefileDirectory ( parent ) ; throw new Error ( "Cakefile not found in " + ( process . cwd ( ) ) ) ; }
function ( row ) { expect ( row . content . toLowerCase ( ) ) . toMatch ( /foo/ ) }
function ( err , message ) { if ( err ) { console . log ( "Can't send email: " + JSON . stringify ( err ) ) ; callback ( err , null ) ; } else { callback ( null , message ) ; } }
function createPage ( ) { console . log ( '------------CREATING LOG------------' ) ; getData ( ) ; var html = "<!DOCTYPE HTML><html><head><meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>Highcharts Example</title><script type='text/javascript' src='http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js'></script><script type='text/javascript'>$(function () {var chart; $(document).ready(function() { chart = new Highcharts.Chart({ chart: { renderTo: 'container', type: 'line', marginRight: 130,},title: {text: 'Load time',x: -20 },subtitle: {text: 'First respons',x: -20},xAxis: {title: {text: 'Number of clients'},plotLines: [{value: 0,width: 1,color: '#808080'}]},yAxis: {title: {text: 'Load time in milliseconds'},plotLines: [{value: 0,width: 1,color: '#808080'}]},tooltip: {formatter: function() {return '<b>'+ this.series.name +'</b><br/>'+this.x +': '+ this.y ;}},legend: {layout: 'vertical',align: 'right',verticalAlign: 'top',x: -10,y: 100,borderWidth: 0},series: [" + clients + "]});});});</script></head><body><script src='js/highcharts.js'></script><script src='js/modules/exporting.js'></script><div id='container' style='min-width: 400px; height: 400px; margin: 0 auto'></div></body></html>" fs . writeFile ( __dirname + '/charting.html' , html , function ( err ) { if ( err ) { console . log ( err ) ; } else { console . log ( "------------THE LOGS ARE CREATED------------" ) ; console . log ( "------------THE LOGS WILL BE OPEND IN YOUR BROWSER!------------" ) ; } } ) ; }
function ( msg , trace ) { numberOfErrors ++ ; console . log ( msg ) ; trace . forEach ( function ( item ) { console . log ( '  ' , item . file , ':' , item . line ) ; } ) }
function runOnAll ( ) { for ( var z = 0 ; z < pages . length ; z ++ ) { try { pages [ z ] . evaluate ( function ( ) { var ssAppName = 'demo' ; var ssFuncToTest = 'LoadTest' ; ss . rpc ( ssAppName + '.' + ssFuncToTest ) ; } ) ; } catch ( e ) { console . log ( e ) ; } } }
function ( event ) { console . log ( "clicked: " + $ ( this ) . attr ( 'id' ) ) ; toggleDisplay ( $ ( this ) . attr ( 'id' ) ) ; }
function ( ) { var that = this ; TemplateManager . get ( this . template , function ( tmp ) { var html = tmp ( that . model . toJSON ( ) ) ; that . $el . html ( html ) ; } ) ; return this ; }
function ( ) { var that = this ; TemplateManager . get ( this . template , function ( tmp ) { var html = tmp ( that . model . toJSON ( ) ) ; that . $el . html ( html ) ; } ) ; return this ; }
function ( tmp ) { var html = tmp ( that . model . toJSON ( ) ) , $ol ; that . $el . html ( html ) ; $ol = that . $el . find ( '#blog-posts' ) ; _ . forEach ( that . childViews , function ( view ) { view . render ( ) . $el . appendTo ( $ol ) ; } ) ; }
function ( ) { var that = this ; TemplateManager . get ( this . template , function ( tmp ) { var html = tmp ( that . model . toJSON ( ) ) ; that . $el . html ( html ) ; } ) ; return this ; }
function ( admin_id ) { var userKeys = _ . without ( _ . keys ( self . users ) , admin_id ) ; if ( _ . size ( userKeys ) ) { self . users [ userKeys [ 0 ] ] . admin = true ; self . admin = userKeys [ 0 ] ; } }
function ( idx , file ) { if ( ! _ . isUndefined ( processableFiles [ idx + 1 ] ) ) { processableFiles [ idx + 1 ] ( ) ; } else { processFinished ( ) ; } }
function ( fieldIndex , filterFunc ) { var rawData ; if ( filterFunc == null ) { filterFunc = function ( dp ) { return true ; } ; } rawData = data . selector ( fieldIndex , filterFunc ) ; return rawData . reduce ( function ( a , b ) { return Math . max ( a , b ) ; } ) ; }
function ( fieldIndex , filterFunc ) { var rawData ; if ( filterFunc == null ) { filterFunc = function ( dp ) { return true ; } ; } rawData = data . selector ( fieldIndex , filterFunc ) ; return rawData . reduce ( function ( a , b ) { return Math . min ( a , b ) ; } ) ; }
function ( fieldIndex , filterFunc ) { var rawData ; if ( filterFunc == null ) { filterFunc = function ( dp ) { return true ; } ; } rawData = data . selector ( fieldIndex , filterFunc ) ; return ( rawData . reduce ( function ( a , b ) { return a + b ; } ) ) / rawData . length ; }
function ( node ) { var node = scorm_tree_node . getHighlightedNode ( ) ; if ( node . depth > 0 ) { return node . parent ; } return null ; }
function ( node ) { if ( node . previousSibling && node . previousSibling . children . length ) { return scorm_lastchild ( node . previousSibling ) ; } return scorm_skipprev ( node ) ; }
function currentDateFitbitString ( ) { var now = new Date ( ) ; var month = ( now . getUTCMonth ( ) + 1 ) . toString ( ) ; if ( month . length == 1 ) month = "0" + month ; return now . getUTCFullYear ( ) + '-' + month + '-' + now . getUTCDate ( ) ; }
function scrolledToBottom ( ) { if ( ! lastSearch || $ ( '.searchResults' ) . length != 1 || $ ( '.endRow' ) . length != 0 ) return ; pageCount ++ ; Ajax . call ( { "page" : "Search" , "params" : { query : lastSearch , page : pageCount } , "decorator" : appendSearch , "clear" : false } ) ; }
function startService ( name , options ) { if ( runningService ) { serviceManager . stop ( runningService ) ; } var module = serviceManager . start ( name , options ) ; if ( module ) { runningService = name ; } bid . resize ( ) ; return module ; }
function fire ( message ) { var messageListeners = listeners [ message ] ; if ( messageListeners ) { for ( var i = 0 , listener ; listener = messageListeners [ i ] ; ++ i ) { listener . callback . apply ( null , arguments ) ; } } for ( var j = 0 , glistener ; glistener = globalListeners [ j ] ; ++ j ) { glistener . callback . apply ( null , arguments ) ; } }
function ( ) { var instance = $ ( this ) . data ( 'plugin_' + pluginName ) ; if ( ! instance ) { $ ( this ) . data ( 'plugin_' + pluginName , new Plugin ( this , options ) ) ; } else if ( instance [ options ] ) { instance [ options ] . apply ( instance , [ args ] ) ; } else { $ . error ( 'Method ' + options + ' does not exist on jQuery.' + pluginName ) ; } }
function ( ) { console . log ( "cameraViewInit" ) ; var currentCamera = Panoptic . currentCamera ; if ( ! currentCamera ) { debug ( "currentCamera is missing in cameraViewInit" ) ; return ; } var rate = Panoptic . config . camera . live . snapshot_refresh_rate ; window . setInterval ( Panoptic . refreshLive , rate * 1000 ) ; window . setInterval ( function ( ) { Panoptic . updateCamera ( currentCamera . id ) } , rate * 1000 ) ; refreshLive ( ) ; updateCamera ( currentCamera . id ) ; }
function ( ) { spyOn ( webview , "executeJavascript" ) ; event . trigger ( "foo" , { "id" : 123 } ) ; expect ( webview . executeJavascript ) . toHaveBeenCalledWith ( "webworks.event.trigger('foo', '" + JSON . stringify ( { "id" : 123 } ) + "')" ) ; }
function ( ) { req . params . ext = "blackberry.app" ; req . params . method = "NotAMethod" ; bridge . exec ( req , succ , fail , args ) ; expect ( fail ) . toHaveBeenCalledWith ( - 1 , jasmine . any ( String ) , 404 ) ; }
function ( ) { spyOn ( Whitelist . prototype , "isFeatureAllowed" ) . andReturn ( true ) ; spyOn ( testExtension , "author" ) ; req . params . ext = "blackberry.app" ; req . params . method = "author" ; bridge . exec ( req , res , succ , fail , args ) ; expect ( Whitelist . prototype . isFeatureAllowed ) . toHaveBeenCalledWith ( req . origin , req . params . ext ) ; }
function ( ) { spyOn ( Whitelist . prototype , "isFeatureAllowed" ) . andReturn ( false ) ; req . params . ext = "blackberry.app" ; req . params . method = "author" ; bridge . exec ( req , succ , fail , args ) ; expect ( fail ) . toHaveBeenCalledWith ( - 1 , jasmine . any ( String ) , 403 ) ; }
function ( ) { var env = { "request" : req , "response" : res } ; spyOn ( Whitelist . prototype , "isFeatureAllowed" ) . andReturn ( true ) ; spyOn ( testExtension , "author" ) ; req . params . ext = "blackberry.app" ; req . params . method = "author" ; bridge . exec ( req , succ , fail , args , env ) ; expect ( testExtension . author ) . toHaveBeenCalledWith ( succ , fail , args , env ) ; }
function ( ) { var callback = jasmine . createSpy ( ) ; event . add ( "blackberry.system.event" , "foo" , callback ) ; event . add ( "blackberry.system.event" , "foo" , callback ) ; event . trigger ( "foo" , '{"id": 1}' ) ; expect ( callback ) . toHaveBeenCalledWith ( { "id" : 1 } ) ; expect ( callback . callCount ) . toEqual ( 1 ) ; event . remove ( "blackberry.system.event" , "foo" , callback ) ; }
function ( ) { var callback = jasmine . createSpy ( ) ; event . add ( "blackberry.system.event" , "foo" , callback ) ; event . trigger ( "foo" , '{"id": 1}' ) ; expect ( callback ) . toHaveBeenCalledWith ( { "id" : 1 } ) ; event . remove ( "blackberry.system.event" , "foo" , callback ) ; }
function ( ) { var cb = jasmine . createSpy ( ) ; event . add ( "blackberry.system.event" , "c" , cb ) ; event . remove ( "blackberry.system.event" , "c" , cb ) ; event . trigger ( "c" , { "id" : 1 } ) ; expect ( cb ) . not . toHaveBeenCalled ( ) ; }
function ( ) { var callback = jasmine . createSpy ( ) ; event . once ( "blackberry.system.event" , "foo" , callback ) ; event . trigger ( "foo" , '{"id": 1}' ) ; event . trigger ( "foo" , '{"id": 1}' ) ; expect ( callback ) . toHaveBeenCalledWith ( { "id" : 1 } ) ; expect ( callback . callCount ) . toEqual ( 1 ) ; }
function ( ) { var callback = jasmine . createSpy ( ) ; event . add ( "blackberry.system.event" , "foo" , callback ) ; event . trigger ( "foo" , '{"id": 1}' ) ; event . trigger ( "foo" , '{"id": 1}' ) ; expect ( callback ) . toHaveBeenCalledWith ( { "id" : 1 } ) ; expect ( callback . callCount ) . toEqual ( 2 ) ; event . remove ( "blackberry.system.event" , "foo" , callback ) ; }
function ( ) { req = { params : { service : "" , action : "" } , body : "" } ; res = { send : jasmine . createSpy ( ) } ; GLOBAL . frameworkModules = [ 'ext/blackberry.app/index.js' , 'lib/plugins/extensions.js' , 'lib/plugins/default.js' ] ; }
function ( event ) { if ( confirm ( 'The operation will erases all data of this profile.\n Are you sure you want to continue?!\n' ) ) { db . remove_profile ( ui . Welcome . selected_profile , function ( result ) { if ( result ) { delete conf . profiles [ conf . current_name ] ; ui . Welcome . load_profiles_info ( ) ; if ( $ ( '#profile_avatar_list a' ) . length == 1 ) { $ ( '#profile_avatar_list a:first' ) . click ( ) ; } else { $ ( '#profile_avatar_list a:eq(1)' ) . click ( ) ; } } } ) ; } }
function removePopUp ( $popUp ) { var index = _popUps . indexOf ( $popUp [ 0 ] ) , removeHandler = $popUp . data ( "PopUpManager-removeHandler" ) ; if ( index >= 0 ) { _removePopUp ( $popUp , index ) ; } }
function formatHex ( number , len ) { var str = number . toString ( 16 ) . toUpperCase ( ) ; if ( ! len ) { if ( str . length % 2 == 1 ) { len = str . length + 1 ; } } while ( str . length < len ) { str = "0" + str ; } return str ; }
function resume ( ) { var record = stack . pop ( ) ; while ( stack . length != 0 && children ( record . node . nextSibling ) ) { record = stack . pop ( ) ; } if ( stack . length == 0 ) { done ( null , record . node ) ; } }
function ( result ) { var e = node . ownerDocument . createElement ( node . getAttribute ( "element" ) ) ; e . appendChild ( node . ownerDocument . createTextNode ( result ) ) ; node . parentNode . insertBefore ( e , node ) ; node . parentNode . removeChild ( node ) ; resume ( ) ; }
function generate ( url , callback ) { if ( templates [ url ] ) { xmlify ( templates [ url ] , callback ) ; } else { resolver ( url , "text/xml" , check ( callback , function ( doc ) { xmlify ( templates [ url ] = { url : url , doc : doc } , callback ) ; } ) ) ; } }
function ( error , source ) { if ( error ) callback ( error ) ; else callback ( null , new ( xmldom . DOMParser ) ( ) . parseFromString ( source ) ) ; }
function ( path ) { try { var file = Components . classes [ this . localfileCID ] . createInstance ( this . localfileIID ) ; file . initWithPath ( path ) ; return file . remove ( false ) ; } catch ( e ) { return false ; } }
function ( file ) { try { var fd = this . open ( file ) ; var fStream = Components . classes [ this . finstreamCID ] . createInstance ( this . finstreamIID ) ; var sStream = Components . classes [ this . bufstreamCID ] . createInstance ( this . bufstreamIID ) ; fStream . init ( fd , 1 , 0 , false ) ; sStream . init ( fStream , 9000000 ) ; return [ fStream , sStream , fd ] ; } catch ( e ) { return null ; } }
function ( charset , data ) { try { var uniConv = Components . classes [ this . suniconvCID ] . createInstance ( this . suniconvIID ) ; uniConv . charset = charset ; data = uniConv . ConvertToUnicode ( data ) ; } catch ( e ) { } return data ; }
function ( charset , data ) { try { var uniConv = Components . classes [ this . suniconvCID ] . createInstance ( this . suniconvIID ) ; uniConv . charset = charset ; data = uniConv . ConvertFromUnicode ( data ) ; } catch ( e ) { } return data ; }
function ( ) { var path = [ ] ; for ( var i = 0 ; i < arguments . length ; i ++ ) { if ( arguments [ i ] != "" ) path . push ( arguments [ i ] ) ; } return path . join ( this . sep ) ; }
function ( str , split ) { var arr = str . split ( split ) , i ; str = new String ( ) ; for ( i = 0 ; i < arr . length ; ++ i ) { str += arr [ i ] + ( ( i != arr . length - 1 ) ? this . sep : '' ) ; } return str ; }
function ( ) { var cred = this . getSelected ( ) ; if ( ! cred ) return ; if ( ! confirm ( "Delete credentials " + cred . name ) ) return ; this . core . removeCredentials ( cred ) this . display ( this . core . getCredentials ( ) ) ; }
function ( ) { console . info ( "'weiter' explanation done" ) ; return Capkom . timeout . start ( 2 , function ( ) { return explainAudioKnopf ( function ( ) { console . info ( "'audio' explanation done" ) ; return done ( ) ; } ) ; } ) ; }
function ( res ) { Capkom . profile . set ( { wordmatch : res } ) ; done ( ) ; Capkom . clickNext ( ) ; jQuery ( '.play-area' , element ) . wordmatch ( 'destroy' ) ; return jQuery ( '.start' , element ) . show ( ) ; }
function ( ) { app . helpers ( { compactJs : function ( ) { return results ; } , compactJsHtml : function ( ) { return results . map ( function ( filename ) { return '<script src="' + filename + '"></script>' ; } ) . join ( '' ) ; } } ) ; }
function ( done ) { compact . addNamespace ( 'global' ) . addJs ( '/a.js' ) . addJs ( '/b.js' ) ; var req = { app : { helpers : function ( helper ) { helper . compactJs ( ) . should . eql ( [ '/global.js' ] ) ; done ( ) ; } , configure : function ( fn ) { fn ( ) ; } } } , res ; compact . js ( [ 'global' ] ) ( req , res , function ( ) { } ) ; }
function ( helper ) { helper . compactJs ( ) . should . eql ( [ '/global.js' ] ) ; doneCount += 1 ; if ( doneCount === 2 ) { done ( ) ; } }
function ( ) { console . debug ( "XFProcessor._handleBetterFormStateChanged: contextInfo: " + contextInfo ) ; var parentId = contextInfo . parentId ; if ( parentId ) { connect . publish ( "bf-state-change-" + parentId , contextInfo ) ; } else { connect . publish ( "bf-state-change-" + contextInfo . targetId , contextInfo ) ; } }
function ( contextInfo ) { var position = parseInt ( contextInfo . position , "10" ) ; var itemToRemove = this . _getRepeatItems ( ) [ position - 1 ] ; var repeatNode = this . srcNodeRef ; if ( this . appearance == "compact" ) { dojo . query ( "> tbody" , repeatNode ) [ 0 ] . removeChild ( itemToRemove ) ; } else { repeatNode . removeChild ( itemToRemove ) ; } }
function updateTitle ( ) { var dialog = document . getElementById ( "calendar-event-dialog" ) ; var itemTitle = document . getElementById ( "item-title" ) ; var title = itemTitle . value ; title = classifySubject ( title , dialog . _security , dialog . _privacy ) ; if ( title != itemTitle . value ) { debug ( "setting title: " + title ) ; itemTitle . value = title ; } return title ; }
function setSecurity ( security ) { var dialog = document . getElementById ( "calendar-event-dialog" ) ; dialog . _security = security ; debug ( "setSecurity: " + security ) ; updateTitle ( ) ; var privacyList = document . getElementById ( "privacy-list" ) ; if ( ! security ) { privacyList . selectedIndex = 0 ; setPrivacy ( null ) ; } privacyList . disabled = ( security == null ) ; }
function initDialog ( ) { var securityList = document . getElementById ( "security-list" ) ; var privacyList = document . getElementById ( "privacy-list" ) ; setupLists ( securityList , privacyList ) ; privacyList . disabled = true ; var itemTitle = document . getElementById ( "item-title" ) ; itemTitle . addEventListener ( "change" , titleChanged , true ) ; }
function ( err , result ) { if ( err ) return callback ( err ) ; comments = comments . concat ( result ) ; if ( result . length === 50 ) module . exports . getIssues ( user , repo , number , page + 1 , comments , callback ) ; else callback ( err , comments ) ; }
function ( ) { var ele = $ ( this ) . parents ( '.editorField' ) ; var align = $ ( 'textarea' , ele ) . css ( 'text-align' ) ; if ( ! align ) align = 'center' ; $ ( 'a.icon-align-' + align , $ ( this ) ) . addClass ( 'selected' ) ; }
function ( ) { var ele = $ ( this ) . parents ( '.editorField' ) ; $ ( 'span' , ele ) . css ( 'text-align' , $ ( this ) . attr ( 'data-align' ) ) ; $ ( 'textarea' , ele ) . css ( 'text-align' , $ ( this ) . attr ( 'data-align' ) ) ; $ ( '.fTextAlign a.selected' , ele ) . removeClass ( 'selected' ) ; $ ( this ) . addClass ( 'selected' ) ; hydrateSlide ( sliderio . view . toolbox . currentIndex ( ) ) ; }
function ( ) { this . _super ( ) ; this . _emitter = cc . ParticleExplosion . create ( ) ; this . _background . addChild ( this . _emitter , 10 ) ; this . _emitter . setTexture ( cc . TextureCache . sharedTextureCache ( ) . addImage ( s_stars1 ) ) ; this . _emitter . setShapeType ( cc . PARTICLE_STAR_SHAPE ) ; this . _emitter . setIsAutoRemoveOnFinish ( true ) ; this . setEmitterPosition ( ) ; }
function ( ) { if ( cc . NODE_TRANSFORM_USING_AFFINE_MATRIX ) { this . _isTransformGLDirty = true ; } this . _anchorPoint = new cc . Point ( 0 , 0 ) ; this . _anchorPointInPoints = new cc . Point ( 0 , 0 ) ; this . _contentSize = new cc . Size ( 0 , 0 ) ; var director = cc . Director . sharedDirector ( ) ; this . _actionManager = director . getActionManager ( ) ; this . _scheduler = director . getScheduler ( ) ; this . _children = [ ] ; }
function ( texture ) { this . _texture = texture ; if ( ( texture instanceof HTMLImageElement ) || ( texture instanceof HTMLCanvasElement ) ) { } else { if ( this . _texture && ! this . _texture . getHasPremultipliedAlpha ( ) && ( this . _blendFunc . src == cc . BLEND_SRC && this . _blendFunc . dst == cc . BLEND_DST ) ) { this . _blendFunc . src = GL_SRC_ALPHA ; this . _blendFunc . dst = GL_ONE_MINUS_SRC_ALPHA ; } } }
function ( isBlendAdditive ) { this . _isBlendAdditive = isBlendAdditive ; return ; if ( isBlendAdditive ) { } else { if ( this . _texture && ! this . _texture . getHasPremultipliedAlpha ( ) ) { } else { this . _blendFunc . src = cc . BLEND_SRC ; this . _blendFunc . dst = cc . BLEND_DST ; } } }
function ( ) { if ( cc . renderContextType == cc . CANVAS ) { } else { if ( cc . USES_VBO ) { glBindBuffer ( GL_ARRAY_BUFFER , quadsID ) ; glBufferSubData ( GL_ARRAY_BUFFER , 0 , sizeof ( quads [ 0 ] ) * particleCount , quads ) ; glBindBuffer ( GL_ARRAY_BUFFER , 0 ) ; } } }
function ( selector , interval , repeat , delay ) { interval = interval || 0 ; cc . Assert ( selector , "Argument must be non-nil" ) ; cc . Assert ( interval >= 0 , "Argument must be positive" ) ; repeat = repeat || cc . REPEAT_FOREVER ; delay = delay || 0 ; this . getScheduler ( ) . scheduleSelector ( selector , this , interval , ! this . _isRunning , repeat , delay ) ; }
function ( texture , rect , rotated , offset , originalSize ) { var spriteFrame = new cc . SpriteFrame ( ) ; spriteFrame . _texture = texture ; spriteFrame . _rectInPixels = rect ; spriteFrame . _rect = cc . RECT_PIXELS_TO_POINTS ( rect ) ; spriteFrame . _rotated = rotated ; spriteFrame . _offsetInPixels = offset ; spriteFrame . _originalSizeInPixels = originalSize ; return spriteFrame ; }
function ( ) { this . _super ( ) ; this . centerSprites ( 1 ) ; var action = cc . Sequence . create ( cc . MoveBy . create ( 2.0 , cc . ccp ( 200 , 0 ) ) , cc . CallFunc . create ( this . _grossini , this . removeFromParentAndCleanup , true ) , null ) ; this . _grossini . runAction ( action ) ; }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = restartTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = nextTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = backTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( followedNode , rect ) { var ret = new cc . Follow ( ) ; if ( rect != null && ret && ret . initWithTarget ( followedNode , rect ) ) { return ret ; } else if ( ret && ret . initWithTarget ( followedNode ) ) { return ret ; } return null ; }
function ( dt ) { if ( this . _firstTick ) { this . _firstTick = false ; this . _elapsed = 0 ; } else { this . _elapsed += dt ; } this . update ( ( 1 > ( this . _elapsed / this . _duration ) ) ? this . _elapsed / this . _duration : 1 ) ; }
function ( action , times ) { var d = action . getDuration ( ) * times ; if ( this . initWithDuration ( d ) ) { this . _times = times ; this . _innerAction = action ; this . _total = 0 ; return true ; } return false ; }
function ( dt ) { this . _innerAction . step ( dt ) ; if ( this . _innerAction . isDone ( ) ) { var diff = dt + this . _innerAction . getDuration ( ) - this . _innerAction . getElapsed ( ) ; this . _innerAction . startWithTarget ( this . _target ) ; this . _innerAction . step ( diff ) ; } }
function ( ) { document . getElementById ( 'code' ) . disabled = ( this . value == 'qlearning' ) ; document . getElementById ( 'qLHelp' ) . style . display = ( this . value === 'qlearning' ) ? '' : 'none' ; }
function validateAccessToken ( ) { var codeObj = document . getElementById ( 'dashboardForm:code' ) ; var accessTokenObj = document . getElementById ( 'dashboardForm:accessToken' ) ; if ( codeObj == null || accessTokenObj == null || codeObj . value == "" || accessTokenObj . value == "" ) { alert ( "Invalid Access to FBR and Facebook.\n\nPlease login to Facebook Reader." ) ; window . location . href = HOST_PREFIX + docBase + "/home.jsf" ; } }
function ( o ) { o = extend ( o ) ; o . scope = this . frame ; assert ( this . body instanceof BlockStatement ) ; this . body . body = compileList ( this . body . body , o ) ; return this ; }
function ( ) { var self = this ; process . on ( 'uncaughtException' , function ( err ) { self . log ( 'Airbrake: Uncaught exception, sending notification for:' ) ; self . log ( err . stack ) ; self . notify ( err , function ( notifyErr , url ) { if ( notifyErr ) { self . log ( 'Airbrake: Could not notify service.' ) ; self . log ( notifyErr . stack ) ; } else { self . log ( 'Airbrake: Notified service: ' + url ) ; } process . exit ( 1 ) ; } ) ; } ) ; }
function ( callback ) { if ( this . connected ) return callback ( new Error ( "Already connected." ) ) if ( ! this . host || ! this . port ) return callback ( new Error ( "No host or port given. Cannot connect." ) ) else if ( ! this . device_key ) return callback ( new Error ( "Cannot connect without valid device key." ) ) this . read_keys ( function ( err ) { if ( err ) return callback ( err ) ; self . connect ( ) ; callback ( null , self ) ; } ) ; }
function ( callback ) { this . log ( "Reading TLS public/private keys..." ) ; try { this . keys = { key : fs . readFileSync ( common . private_key_path ) . toString ( ) , cert : fs . readFileSync ( common . certificate_path ) . toString ( ) } ; callback ( ) ; } catch ( e ) { callback ( e ) ; } }
function ( action , data ) { this . log ( "Sending action " + action ) ; if ( this . stream . writable ) { this . stream . write ( JSON . stringify ( { action : action , data : data } ) ) } else { logger . info ( " !! Stream not writable!" ) ; this . disconnect ( ) ; } }
function ( el ) { if ( this . options . trackedgame . get ( "field_status_" + this . options . team_ix ) [ this . model . get ( "player_id" ) ] ) { console . log ( "TODO: Change class/css to indicate this player is onfield." ) ; } else { console . log ( "TODO: Change class/css to indicate this player is offfield." ) ; } }
function ( array , callback ) { if ( Array . isArray ( array ) ) { return this . sendCommand ( command , array , callback ) ; } callback = typeof arguments [ arguments . length - 1 ] === 'function' ; args = utils . toArray ( arguments ) ; if ( true === callback ) { callback = args . pop ( ) ; } else { callback = null ; } return this . sendCommand ( command , args , callback ) ; }
function ( ) { if ( eXo . core . Browser . browserType == 'ie' ) { document . onkeydown = function ( e ) { return eXo . core . Keyboard . onKeyDown ( e ) ; } } document . onkeypress = function ( e ) { return eXo . core . Keyboard . onKeyPress ( e ) ; } ; }
function ( event ) { if ( eXo . core . Browser . browserType == 'ie' ) { window . event . cancelBubble = true ; window . event . returnValue = true ; return ; } else { event . stopPropagation ( ) ; event . preventDefault ( ) ; } }
function ( ) { if ( eXo . core . Browser . browserType == 'ie' ) { document . onkeydown = function ( e ) { return eXo . core . Keyboard . onKeyDown ( e ) ; } } document . onkeypress = function ( e ) { return eXo . core . Keyboard . onKeyPress ( e ) ; } ; }
function ( event ) { if ( eXo . core . Browser . browserType == 'ie' ) { window . event . cancelBubble = true ; window . event . returnValue = true ; return ; } else { event . stopPropagation ( ) ; event . preventDefault ( ) ; } }
function ( response ) { var me = eXo . calendar . UICalendarPortlet ; eval ( "var data = " + response ) ; var isEdit = data . permission ; if ( ! isEdit ) { me . notify ( me . activeEventObject ) ; me . restorePosition ( me . activeEventObject ) ; } else { if ( me . dropCallback ) me . dropCallback ( ) ; delete me . activeEventObject ; delete me . restoreSize ; } }
function extend ( target ) { var mixins = [ ] . slice . call ( arguments , 1 ) ; for ( var index = 0 , mixin ; mixin = mixins [ index ] ; ++ index ) { for ( var key in mixin ) { target [ key ] = mixin [ key ] ; } } return target ; }
function ( ) { var target = { } ; var retval = helpers . extend ( target , { field1 : true , field2 : "value" } ) ; equal ( target . field1 , true , "target extended" ) ; equal ( target . field2 , "value" , "target extended" ) ; strictEqual ( retval , target , "the updated target is returned" ) ; }
function ( val , filter ) { if ( typeof val === "string" ) { if ( base . inSourceMode ( ) ) base . setTextareaValue ( val ) ; else { if ( filter !== false && base . options . getTextHandler ) val = base . options . getTextHandler ( val ) ; base . setWysiwygEditorValue ( val ) ; } return this ; } return base . inSourceMode ( ) ? base . getTextareaValue ( ) : base . getWysiwygEditorValue ( ) ; }
function ( ) { clearTimeout ( timer ) ; start ( ) ; ok ( get ( ebryn , 'isLoaded' ) , "data loads asynchronously" ) ; equal ( get ( ebryn , 'height' ) , 70 , "data from fixtures is loaded correctly" ) ; var wycats = store . find ( Person , 'wycats' ) ; equal ( get ( wycats , 'isLoaded' ) , true , "subsequent requests for records are returned immediately" ) ; equal ( get ( wycats , 'height' ) , 65 , "subsequent requested records contain correct information" ) ; }
function ( k , sliderrange ) { var id = $ ( sliderrange ) . attr ( 'id' ) ; id = id . replace ( "sliderrange---" , '' ) ; $ ( sliderrange ) . slider ( { range : "min" , value : 0 , min : 0 , max : 100 , slide : function ( event , ui ) { setTargetsPenalties ( id , ui . value ) ; } } ) }
function ( ) { selectGeographyControl . unselectAll ( ) ; selectGeographyControl . deactivate ( ) ; pu_layer . styleMap . styles . default . defaultStyle . display = "none" ; pu_layer . redraw ( ) ; self . showScenarioFormPanel ( false ) ; self . showScenarioList ( true ) ; self . formSaveError ( false ) ; }
function ( ) { if ( bb . device . isPlayBook ( ) ) { } else { console . log ( 'not playbook' ) ; if ( blackberry . ui . menu ) { blackberry . ui . menu . clearMenuItems ( ) ; } } }
function ( ) { var source = "idOfMe" ; var lexer = new hjs . Lexer ( source ) ; var token = lexer . nextToken ( ) ; expect ( token ) . not . toBeNull ( ) ; expect ( token . type ( ) ) . toEqual ( hjs . TokenType . ID ) ; expect ( token . text ( ) ) . toEqual ( "idOfMe" ) ; expect ( token . source ( ) ) . toEqual ( source ) ; }
function ( ) { it ( "yields a token of type NUMBER" , function ( ) { } ) ; it ( "yields a token containing the text '1.23'." , function ( ) { } ) ; }
function integral ( ) { if ( DIGIT_PATTERN . test ( c ) ) { return states . INTEGRAL ; } if ( c == '.' ) { return states . FRACTIONAL ; } if ( c == 'e' || c == 'E' ) { return states . EXPONENT_SIGN ; } return states . COMPLETE ; }
function ( firstChar ) { }
function ( ) { if ( cc . NODE_TRANSFORM_USING_AFFINE_MATRIX ) { this . _isTransformGLDirty = true ; } this . _anchorPoint = new cc . Point ( 0 , 0 ) ; this . _anchorPointInPoints = new cc . Point ( 0 , 0 ) ; this . _contentSize = new cc . Size ( 0 , 0 ) ; var director = cc . Director . sharedDirector ( ) ; this . _actionManager = director . getActionManager ( ) ; this . _scheduler = director . getScheduler ( ) ; }
function ( newPosOrxValue , yValue ) { if ( typeof ( newPosOrxValue ) == 'number' ) { this . _position = new cc . Point ( newPosOrxValue , yValue || 0 ) ; } else if ( newPosOrxValue instanceof cc . Point ) { this . _position = newPosOrxValue ; } this . setNodeDirty ( ) ; }
function ( ) { if ( ! this . _actionManager ) this . _actionManager = cc . Director . sharedDirector ( ) . getActionManager ( ) ; return this . _actionManager ; }
function ( ) { if ( ! this . _scheduler ) this . _scheduler = cc . Director . sharedDirector ( ) . getScheduler ( ) ; return this . _scheduler ; }
function ( tv ) { tv . pos = this . _position ; tv . scale . x = this . _scaleX ; tv . scale . y = this . _scaleY ; tv . rotation = this . _rotation ; tv . skew . x = this . _skewX ; tv . skew . y = this . _skewY ; tv . ap = this . _anchorPointInPixels ; tv . visible = this . _isVisible ; return tv }
function ( ) { if ( typeof console !== 'undefined' ) { console . log ( "You pressed the button" ) ; BandNames . insert ( { 'text' : new_bandname , 'author' : new_author } ) ; } }
function ( i , citationItem ) { indexes . push ( parseInt ( citationItem . id . replace ( "ITEM-" , "" ) ) - 1 ) ; }
function ( item , node , schemaAttributes ) { if ( attributeNodes . indexOf ( item . node ) >= 0 ) { return attributeEditorRow ( item , node , schemaAttributes ) ; } else if ( nameNodes . indexOf ( item . node ) >= 0 ) { return nameEditorRow ( item , node ) ; } else { return textValueEditorRow ( item , node ) ; } }
function ( copySource ) { if ( typeof ( copySource ) === "undefined" ) { return { elements : { } , attributes : { } , refs : [ ] , refQuantifiers : { } , attributeValues : [ ] , textNode : false , list : false , choices : [ ] , choiceRefs : [ ] , documentation : "" } ; } else { return JSON . parse ( JSON . stringify ( copySource ) ) ; } }
function authorString ( authors ) { var result = [ ] , index = 0 ; for ( index = 0 ; index < authors . length ; index ++ ) { result . push ( authors [ index ] . given + " " + authors [ index ] . family ) ; } return result . join ( ", " ) ; }
function ( distance , stringA , stringB ) { var editDistance = CSLEDIT . diff . customEditDistance ( stringA , stringB ) , matchQuality = Math . max ( 0 , Math . floor ( 100 * ( 1.0 - editDistance / ( 2 * ( stringA + stringB ) . length ) ) ) ) , closeness ; if ( editDistance === 0 ) { closeness = "Perfect match!" ; } else { closeness = matchQuality + "% match" ; } return '<td class="closeness match">' + closeness + '</td>' ; }
function ( index , value ) { var tree ; treesToLoad ++ ; tree = CSLEDIT . SmartTree ( treeView . children ( "#" + value . id ) , value . nodePaths , value . macroLinks ) ; tree . setCallbacks ( { loaded : treeLoaded , selectNode : selectNodeInTree ( tree ) , moveNode : callbacks . moveNode , deleteNode : callbacks . deleteNode , checkMove : callbacks . checkMove } ) ; tree . createTree ( ) ; views . push ( tree ) ; }
function ( ) { equal ( CSLEDIT . schema . choices ( "layout/text" ) [ 3 ] [ "variable" ] . list , false ) ; equal ( CSLEDIT . schema . choices ( "choose/if" ) [ 6 ] [ "variable" ] . list , true ) ; }
function ( ) { var jsonData ; try { jsonData = JSON . parse ( newReferenceInput . val ( ) ) ; } catch ( e ) { alert ( "Error: Not valid JSON" ) ; return ; } CSLEDIT . exampleCitations . addReference ( jsonData , citation ) ; updateReferenceList ( ) ; newReferenceInput . val ( "" ) ; }
function ( _citation ) { citation = _citation ; updateReferenceList ( ) ; dialog . dialog ( { title : 'Edit Citation ' + ( citation + 1 ) , width : "700px" } ) ; if ( ! initialised ) { advanced . accordion ( { collapsible : true , active : false } ) ; initialised = true ; } }
function ( i , attributes ) { if ( attributes . hasOwnProperty ( attribute ) ) { $ . each ( attributes [ attribute ] . values , function ( i2 , possibleValue ) { if ( possibleValue . type === "value" ) { possibleValues . push ( possibleValue . value ) ; } } ) ; return false ; } }
function ( oldString , newString ) { var editDistance = CSLEDIT . diff . customEditDistance ( oldString , newString ) , matchQuality = Math . max ( 0 , Math . floor ( 100 * ( 1.0 - editDistance / ( 2 * ( oldString + newString ) . length ) ) ) ) ; return matchQuality ; }
function ( clazz , construct , superClass , name , basename ) { var superproto = superClass . prototype ; var helper = new Function ( ) ; helper . prototype = superproto ; var proto = new helper ( ) ; clazz . prototype = proto ; proto . name = proto . classname = name ; proto . basename = basename ; construct . base = clazz . superclass = superClass ; construct . self = clazz . constructor = proto . constructor = clazz ; }
function ( x ) { return x !== '' ; }
function ( idx , el ) { $ ( el ) . slider ( 'value' , sequence [ idx ] ) ; $ ( el ) . find ( 'a' ) . text ( sequence [ idx ] ) ; this . updateBlinkerState ( idx ) ; }
function ( options , uri , toneRow ) { this . options = options ; this . uri = uri ; this . toneRow = window . tr = toneRow ; this . silentNoteVal = 0 ; this . buildFreqTable ( ) ; this . parseURI ( ) ; this . dirty = true ; this . buildSequence ( ) ; this . uri . onchangeHook = function ( ) { this . parseURI ( ) ; this . buildSequence ( ) ; this . updateDisplay ( ) ; } . bind ( this ) ; }
function ( ) { if ( this . dirty ) { this . hzSeq = this . hzFromStepSeq ( ) ; this . attackSeq = this . flatAttackSeq ( ) ; this . formattedSeq = this . mergeSequences ( ) ; this . toneRow . updateSequence ( this . formattedSeq ) ; this . uri . update ( { seq : this . stepSeq , rate : this . options . bpm , length : this . options . stepCount } ) ; this . dirty = false ; } }
function ( ) { if ( this . _metamorph ) { var oldContext = context ( ) , target = this . target ( ) , value = _ . isFunction ( target ) ? target ( ) : target ; context ( this ) ; this . disposeChildren ( ) ; this . _metamorph . html ( Handlebars . Utils . escapeExpression ( this . renderContent ( value ) ) ) ; context ( oldContext ) ; } }
function makeCtor ( ) { var Class = function ( ) { this . init . apply ( this , arguments ) ; } _ . extend ( Class , { __isMethod : false , extend : extend , invoke : function ( ) { Class_ctor . prototype = this . prototype ; var instance = new Class_ctor ( ) ; this . apply ( instance , arguments ) ; return instance ; } } ) Class . prototype . init = function ( ) { } ; return Class ; }
function ( cb ) { if ( window . crypto && window . crypto . getRandomValues ) { if ( cb ) delay ( cb ) ( ) ; } else { sjcl . random . addEventListener ( 'seeded' , function ( blarg ) { if ( cb ) cb ( ) ; } ) ; sjcl . random . startCollectors ( ) ; } }
function ( msg ) { this . name = 'NotFound' ; Error . call ( this , msg ) ; Error . captureStackTrace ( this , arguments . callee ) ; }
function ( error , response , body ) { if ( ! error && response . statusCode == 200 ) { log . info ( '200 from url (%s) - response headers: %s' , post . raw_markdown_url , response . headers ) ; var markdown = body . toString ( ) ; post . content_md = markdown ; post . content_html = md ( markdown ) ; callback ( null ) ; } else { log . error ( 'populateBlogPostContent: error for %s, error = %s' , post . id , error ) ; callback ( error ) ; } }
function makeLogKind ( prefix , fn ) { if ( prefix !== 'ERROR' && prefix !== 'INFO' ) { throw new Error ( 'the prefix must be ERROR or INFO' ) ; } return { prefix : prefix , prefixer : getLogMessagePrefix , fn : fn } ; }
function getLogMessagePrefix ( kind , moduleName ) { var afterTimestamp = kind . prefix + ' (' + moduleName + '): ' ; if ( kind . fn === util . log ) { return afterTimestamp ; } else { return '' + new Date ( ) . toJSON ( ) + ' ' + afterTimestamp ; } }
function logWithKindPrefix ( kind , moduleName , messageFormatArgs ) { if ( ! kind . fn ) return ; var formatArgsArr = Array . prototype . slice . call ( messageFormatArgs ) ; jsonifyObjectsInArray ( formatArgsArr ) ; var message = util . format . apply ( this , formatArgsArr ) ; if ( kind . prefixer ) { message = kind . prefixer ( kind , moduleName ) + message ; } kind . fn ( message ) ; }
function ( e ) { if ( e . keyCode != 13 ) return ; Todos . create ( this . newAttributes ( ) ) ; this . input . val ( '' ) ; }
function ( attr ) { return this . attributes [ attr ] ; }
function ( attr ) { var html ; if ( html = this . _escapedAttributes [ attr ] ) return html ; var val = this . attributes [ attr ] ; return this . _escapedAttributes [ attr ] = escapeHTML ( val == null ? '' : '' + val ) ; }
function ( attrs , options ) { var error = this . validate ( attrs ) ; if ( error ) { if ( options . error ) { options . error ( this , error , options ) ; } else { this . trigger ( 'error' , this , error , options ) ; } return false ; } return true ; }
function ( models , options ) { options || ( options = { } ) ; if ( options . comparator ) this . comparator = options . comparator ; _ . bindAll ( this , '_onModelEvent' , '_removeReference' ) ; this . _reset ( ) ; if ( models ) this . reset ( models , { silent : true } ) ; this . initialize . apply ( this , arguments ) ; }
function ( options ) { options || ( options = { } ) ; if ( ! this . comparator ) throw new Error ( 'Cannot sort a set without a comparator' ) ; this . models = this . sortBy ( this . comparator ) ; if ( ! options . silent ) this . trigger ( 'reset' , this , options ) ; return this ; }
function ( resp , xhr ) { return resp ; }
function ( model , options ) { if ( ! ( model instanceof Backbone . Model ) ) { var attrs = model ; model = new this . model ( attrs , { collection : this } ) ; if ( model . validate && ! model . _performValidation ( attrs , options ) ) model = false ; } else if ( ! model . collection ) { model . collection = this ; } return model ; }
function ( ) { if ( ! this . el ) { var attrs = this . attributes || { } ; if ( this . id ) attrs . id = this . id ; if ( this . className ) attrs [ 'class' ] = this . className ; this . el = this . make ( this . tagName , attrs ) ; } else if ( _ . isString ( this . el ) ) { this . el = $ ( this . el ) . get ( 0 ) ; } }
function ( ) { set ( this , 'recordCache' , Ember . A ( [ ] ) ) ; this . _super ( ) ; }
function ( item ) { var hash = this . hash , guid = guidFor ( item ) ; if ( ! hash . hasOwnProperty ( guid ) ) { return ; } delete hash [ guid ] ; var list = this . list , index = Ember . ArrayUtils . indexOf ( this , item ) ; list . splice ( index , 1 ) ; }
function ( ) { var clientIds = get ( this , 'content' ) , store = get ( this , 'store' ) , type = get ( this , 'type' ) ; var ids = clientIds . map ( function ( clientId ) { return store . clientIdToId [ clientId ] ; } ) ; store . fetchMany ( type , ids ) ; }
function ( json ) { this . sideload ( store , type , json , root ) ; store . didCreateRecord ( record , json [ root ] ) ; }
function ( json ) { this . sideload ( store , type , json , root ) ; store . didUpdateRecord ( record , json && json [ root ] ) ; }
function ( store , type , record ) { var id = get ( record , 'id' ) ; var root = this . rootForType ( type ) ; this . ajax ( this . buildURL ( root , id ) , "DELETE" , { success : function ( json ) { if ( json ) { this . sideload ( store , type , json ) ; } store . didDeleteRecord ( record ) ; } } ) ; }
function ( store , type , id ) { var root = this . rootForType ( type ) ; this . ajax ( this . buildURL ( root , id ) , "GET" , { success : function ( json ) { this . sideload ( store , type , json , root ) ; store . load ( type , json [ root ] ) ; } } ) ; }
function ( ) { console . log ( "Dealing" ) ; self . onmessage ( { "action" : "deal" , "card" : { "kind" : ( "test" + ( cardNum ++ ) ) } , "player" : pNum , "stack" : 0 } ) ; pNum = ( pNum + 1 ) % 4 ; }
function ( stackNumber ) { var stack = players [ myPlayerNumber ] . stacks [ stackNumber ] ; if ( ! getMyHand ( ) ) { setMyHand ( stack . pop ( ) ) ; if ( stack . length === 0 ) { players [ myPlayerNumber ] . stacks . splice ( stackNumber , 1 ) ; console . log ( "Emptied stack" ) ; console . log ( players [ myPlayerNumber ] . stacks ) ; } } }
function ( playerNumber ) { var rider = players [ playerNumber ] . rider ; if ( rider . card . kind === "skip" && rider . extras ) { rider . extras -= 1 ; } else { rider . card = null ; rider . extras = 0 ; } }
function ( field_of_view , near , far , aspect_ratio ) { var size = near * Math . tan ( ( field_of_view / ( 180 * Math . PI ) ) / 2 ) ; return this . makeFrustum ( - size , size , - size / aspect_ratio , size / aspect_ratio , near , far ) ; }
function openEditor ( trackEvent ) { if ( ! _firstUse ) { _firstUse = true ; _editorAreaDOMRoot . classList . remove ( "minimized" ) ; } var editorType = Editor . isRegistered ( trackEvent . type ) ? trackEvent . type : "default" ; if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( editorType , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; return _currentEditor ; }
function OSMHell ( ) { OSMHell . API_URL = hell . p . urlapi + '/searchselect' ; this . cityView = null ; this . streetView = null ; this . buildingView = null ; this . cities = { } ; this . coordsCache = { } ; }
function d3_time_parseYear ( date , string , i ) { d3_time_numberRe . lastIndex = 0 ; var n = d3_time_numberRe . exec ( string . substring ( i , i + 2 ) ) ; return n ? ( date . y = d3_time_century ( ) + + n [ 0 ] , i += n [ 0 ] . length ) : - 1 ; }
function ( val ) { if ( _state !== val ) { _state = val ; if ( _state ) { document . body . classList . remove ( "minimized" ) ; _element . setAttribute ( "ui-state" , "visible" ) ; _this . dispatch ( "uivisibilitychanged" , true ) ; } else { document . body . classList . add ( "minimized" ) ; _element . setAttribute ( "ui-state" , "hidden" ) ; _this . dispatch ( "uivisibilitychanged" , false ) ; } } }
function ( ) { var match , plurals , sCF ; plurals = [ '[0]nothing found' , '[1]one found' , '{2,3,4,5}2-5 found' , '(5,10)6-9 found' , '[10,15)10-14 found' , '[15,20]15-20 found' , '(30,+Inf] more the 30 found' , '[-Inf,0)less the 0 found' , '{n:(n)}(n) found' ] . join ( '|' ) ; sCF = new sfChoiceFormat ( ) ; for ( match = - 10 ; match <= 32 ; match ++ ) { document . writeln ( match + ': ' + sCF . format ( plurals , match ) + '<br />' ) ; } }
function ( value , element ) { var unique = false $ . ajax ( { type : 'POST' , async : false , url : 'uniqueuser/' , data : $ ( "#registrationform" ) . serializeArray ( ) , success : function ( data , status , jq ) { unique = ( status == "200" ) ; } } ) ; return unique ; }
function displayError ( heading , text ) { showPage ( 'error-page' ) ; $ ( '#error-page textarea' ) . val ( heading + ':\n' + text ) ; }
function ( e ) { var val = $ ( 'input#searchfield' ) . val ( ) ; if ( val != '' ) { search_string = '' ; $ ( 'input#searchfield' ) . val ( search_string ) ; qs . search ( search_string ) ; qs . cache ( ) ; redraw_grid ( ) ; } }
function ( e ) { var val = $ ( 'input#searchfield' ) . val ( ) ; var fullname = $ ( item ) . data ( 'fullname' ) ; if ( val != '' ) { search_string = '' ; } else { search_string = fullname ; } $ ( 'input#searchfield' ) . val ( search_string ) ; qs . search ( search_string ) qs . cache ( ) ; redraw_grid ( ) ; }
function ( elm , t ) { var bsec = G . __isecBounds ( this . bounds ( t ) , elm . bounds ( t ) ) ; if ( ! opts . pathCheck ) return bsec ; throw new Error ( 'Not implemented' ) ; }
function ( view ) { var model = view . model , collection = view . collection ; if ( model ) { unbindModel ( view . model ) ; } if ( collection ) { collection . each ( function ( model ) { unbindModel ( model ) ; } ) ; collection . unbind ( 'add' , collectonAdd ) ; collection . unbind ( 'remove' , collectionRemove ) ; } }
function ( ) { var blockjQ = this . jQ . children ( ':eq(1)' ) ; var height = blockjQ . outerHeight ( ) / + blockjQ . css ( 'fontSize' ) . slice ( 0 , - 2 ) ; var parens = this . children ( '.paren' ) ; scale ( paren , min ( 1 + .2 * ( height - 1 ) , 1.2 ) , 1.05 * height ) ; }
function ( suffix ) { if ( this . loadSuffixes . indexOf ( suffix ) == - 1 ) this . loadSuffixes . push ( suffix ) ; }
function ( name , normalize ) { var parts = name . split ( ']' ) ; parts [ 0 ] = normalize ( parts [ 0 ] ) ; return parts . join ( ']' ) ; }
function ( ) { } ) , define ( "require-css/css!components/component[ie]" , [ ] , function ( ) { } ) , require ( [ "css!./component[]" , "css!./component[ie]" ] , function ( ) { return { component : "is here" } } ) , define ( "components/component" , function ( ) { }
function ( context , screen ) { screen . appendChild ( context ) ; context . menu = bb . contextMenu . create ( screen ) ; context . appendChild ( context . menu ) ; bb . screen . contextMenu = context . menu ; var actions = context . querySelectorAll ( '[data-bb-type=action]' ) , i ; for ( i = 0 ; i < actions . length ; i ++ ) { context . menu . add ( actions [ i ] ) ; } }
function ( event ) { if ( ! this . menu . peeking ) return ; var touch = event . touches [ 0 ] ; if ( this . startPos && ( this . startPos - touch . pageX > this . threshold ) ) { this . menu . show ( ) ; this . closeMenu = false ; } }
function ( context , screen ) { screen . appendChild ( context ) ; context . menu = bb . contextMenu . create ( screen ) ; context . appendChild ( context . menu ) ; bb . screen . contextMenu = context . menu ; var actions = context . querySelectorAll ( '[data-bb-type=action]' ) , i ; for ( i = 0 ; i < actions . length ; i ++ ) { context . menu . add ( actions [ i ] ) ; } }
function ( event ) { if ( ! this . menu . peeking ) return ; var touch = event . touches [ 0 ] ; if ( this . startPos && ( this . startPos - touch . pageX > this . threshold ) ) { this . menu . show ( ) ; this . closeMenu = false ; } }
function ( event ) { if ( ! this . menu . peeking ) return ; var touch = event . touches [ 0 ] ; if ( this . startPos && ( this . startPos - touch . pageX > this . threshold ) ) { this . menu . show ( ) ; this . closeMenu = false ; } }
function ( context , screen ) { screen . appendChild ( context ) ; context . menu = bb . contextMenu . create ( screen ) ; context . appendChild ( context . menu ) ; bb . screen . contextMenu = context . menu ; var actions = context . querySelectorAll ( '[data-bb-type=action]' ) , i ; for ( i = 0 ; i < actions . length ; i ++ ) { context . menu . add ( actions [ i ] ) ; } }
function ( ) { src = this . el . dom . src ; var xhr = new XMLHttpRequest ( ) ; xhr . open ( 'GET' , src , true ) ; xhr . setRequestHeader ( 'Cache-Control' , 'no-cache' ) ; xhr . setRequestHeader ( 'Pragma' , 'no-cache' ) ; xhr . send ( ) ; this . el . dom . src = "" ; this . el . dom . src = src ; }
function downloadXBMCFile ( url , myFile , callback ) { var inputUrl = '/xbmcCmds/xbmcHttp?command=FileDownloadFromInternet(' + url + '; ' + myFile + ')' ; Ext . Ajax . request ( { url : inputUrl , method : 'GET' , async : callback || false , success : callback || function ( t ) { } , failure : function ( t ) { } , timeout : 2000 } ) ; }
function ( e ) { if ( $ ( e . target ) . closest ( ".select2-result-selectable:not(.select2-disabled)" ) . length > 0 ) { this . highlightUnderEvent ( e ) ; this . selectHighlighted ( e ) ; } else { this . focusSearch ( ) ; } killEvent ( e ) ; }
function ( ) { Utils . debug ( "SESSION init: " + this . el ) ; this . sessionFieldsView = new UpdatingCollectionView ( { collection : this . model . get ( "sessionFields" ) , childViewConstructor : DatumFieldEditView , childViewTagName : "li" , format : "datum" } ) ; this . model . bind ( 'change' , this . render , this ) ; }
function ( ) { fs . readFile ( completeTest , 'utf8' , this . callback ) ; }
function ( ) { var $this = $ ( this ) . hide ( ) , $span = $this . next ( 'span.custom.' + type ) ; if ( $span . length === 0 ) { $span = $ ( '<span class="custom ' + type + '"></span>' ) . insertAfter ( $this ) ; } $span . toggleClass ( 'checked' , $this . is ( ':checked' ) ) ; $span . toggleClass ( 'disabled' , $this . is ( ':disabled' ) ) ; }
function ( ) { this . $bullets = $ ( this . bulletHTML ) ; this . $wrapper . append ( this . $bullets ) ; this . $slides . each ( this . addBullet ) ; this . $element . addClass ( 'with-bullets' ) ; if ( this . options . centerBullets ) this . $bullets . css ( 'margin-left' , - this . $bullets . width ( ) / 2 ) ; }
function ( e ) { e . preventDefault ( ) ; $ ( this ) . fadeOut ( 150 ) ; }
function ( ) { var $body = $ ( 'body' ) ; if ( attributes . bodyHeight != $body . height ( ) ) { attributes . bodyHeight = $body . height ( ) ; $ ( window ) . trigger ( 'resize' ) ; } }
function ( attributes ) { if ( attributes && attributes . article ) { var self = this ; attributes . article . product ( function ( err , product ) { self . set ( 'product' , product ) ; } ) ; } this . callBase ( ) ; }
function ( cy ) { window . cy = cy ; var json = cyutil . entities2json ( doc . entities ( ) ) ; cy . add ( json ) ; var nodes = cy . nodes ( ) ; for ( var i = 0 ; i < nodes . length ; i ++ ) { var node = nodes [ i ] ; var id = node . id ( ) ; node . qtip ( { content : { text : ui . editNameQtipContent ( id ) } } ) ; } }
function ( entity ) { var ele = cy . add ( { group : 'nodes' , position : entity . viewport , data : { id : entity . id , name : entity . name , type : entity . type } , classes : 'entity' + ( entity . interaction ? ' interaction' : '' ) } ) ; ele . qtip ( { content : { text : ui . editNameQtipContent ( entity . id ) } } ) ; }
function ( ) { var nodes = cy . $ ( 'node:selected' ) ; for ( var i = 0 ; i < nodes . length ; i ++ ) { var node = nodes [ i ] ; var id = node . data ( 'id' ) ; console . log ( 'remove' , id ) ; doc . removeEntity ( id ) ; } }
function ( ) { var transform = Y . one ( '#scrollview-content' ) . getStyle ( 'transform' ) , offset = transform . split ( ',' ) [ 4 ] . replace ( ')' , '' ) . trim ( ) ; if ( offset == - 986 && offset == - 987 ) { Y . Assert . pass ( ) ; } else { Y . Assert . fail ( ) ; } }
function togglebinary ( toggleNum , toggleVal ) { if ( ( toggleNum >= 1 ) && ( toggleNum <= 52 ) ) { var start = toggleBinaryGlobal . substring ( 0 , toggleNum ) ; var end = toggleBinaryGlobal . substring ( toggleNum + 1 ) ; toggleBinaryGlobal = start + toggleVal + end ; save_toggles ( ) ; } }
function ( Y , theTopic ) { var section = document . getElementById ( "section-" + theTopic ) ; var secatag = document . getElementById ( "sectionatag-" + theTopic ) ; if ( ( section != null ) && ( secatag != null ) ) { toggleexacttopic ( section , secatag , theTopic , true ) ; } }
function ( ) { function pad ( n ) { return n < 10 ? '0' + n : n } return this . getUTCFullYear ( ) + '-' + pad ( this . getUTCMonth ( ) + 1 ) + '-' + pad ( this . getUTCDate ( ) ) + 'T' + pad ( this . getUTCHours ( ) ) + ':' + pad ( this . getUTCMinutes ( ) ) + ':' + pad ( this . getUTCSeconds ( ) ) + 'Zxx' }
function ( ) { value && baidu . paramCheck ( '^(?:number|string)$' , 'baidu.dom.scrollTop' ) ; var ret = baidu . dom . _smartScroll ( 'scrollTop' ) ; return function ( value ) { return value === undefined ? ret . get ( this [ 0 ] ) : ret . set ( this [ 0 ] , value ) || this ; } }
function ( data ) { var api = this , url = this . wsURL + '/rest/api/post/login' ; $ . ajax ( { url : url , data : data , header : "Access-Control-Allow-Headers: x-requested-with" , type : "POST" , dataType : "json" , crossDomain : true , cache : true , async : false , success : function ( response ) { api . loginresponse = response ; } , error : function ( xhr , e , et ) { var jo = { "status" : "server error" } ; } } ) ; }
function ( userid ) { var api = this , orderhistory , url = this . wsURL + '/rest/api/products/orderhistory/' + userid ; $ . ajax ( { url : url , header : "Access-Control-Allow-Headers: x-requested-with" , type : "GET" , dataType : "json" , crossDomain : true , cache : true , async : false , success : function ( orderResponse ) { api . orderhistory = orderResponse ; } , error : function ( xhr , e , et ) { var jo = { "status" : "server error" } ; } } ) ; }
function ( text , matchString ) { if ( ! matchString ) return text ; var regex = new RegExp ( '(' + matchString + ')' , 'gi' ) ; return text . replace ( regex , '<span class="searchHighlighted">$1</span>' ) ; }
function ( ) { var val = this . $menu . find ( '.active' ) . attr ( 'data-value' ) this . $element . val ( this . updater ( val ) ) . change ( ) return this . hide ( ) }
function ( ) { var pos = $ . extend ( { } , this . $element . offset ( ) , { height : this . $element [ 0 ] . offsetHeight } ) this . $menu . css ( { top : pos . top + pos . height , left : pos . left } ) this . $menu . show ( ) this . shown = true return this }
function ( items ) { var beginswith = [ ] , caseSensitive = [ ] , caseInsensitive = [ ] , item while ( item = items . shift ( ) ) { if ( ! item . toLowerCase ( ) . indexOf ( this . query . toLowerCase ( ) ) ) beginswith . push ( item ) else if ( ~ item . indexOf ( this . query ) ) caseSensitive . push ( item ) else caseInsensitive . push ( item ) } return beginswith . concat ( caseSensitive , caseInsensitive ) }
function ( i , item ) { i = $ ( that . options . item ) . attr ( 'data-value' , item ) i . find ( 'a' ) . html ( that . highlighter ( item ) ) return i [ 0 ] }
function ( e ) { switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : if ( ! this . shown ) return this . hide ( ) break default : this . lookup ( ) } e . stopPropagation ( ) e . preventDefault ( ) }
function ( status ) { if ( status === "complete" ) { user . syncEmails ( function ( ) { self . close ( self . verificationMessage ) ; oncomplete && oncomplete ( ) ; } ) ; } else if ( status === "mustAuth" ) { self . close ( "authenticate" , { email : self . email } ) ; oncomplete && oncomplete ( ) ; } }
function ( ) { xhr . useResult ( "mustAuth" ) ; testVerifiedUserEvent ( "authenticate" , "User Must Auth" ) ; }
function ( e ) { e . preventDefault ( ) ; $ ( this ) . validate ( ) ; myJSON . formName = $ ( this ) . attr ( 'name' ) ; myJSON . keys = new Object ( ) ; myJSON . keys = getSQLParams ( myJSON . keys ) ; myJSON . datas = $ ( this ) . toJSON ( ) ; $ . post ( 'php/foRml.php' , myJSON , function ( data ) { alert ( data ) ; } ) ; }
function ( callback , context ) { if ( typeof callback != "function" ) throw new TypeError ( ) ; for ( var i in this ) { callback . call ( context , this [ i ] , i , this ) ; } }
function ( attr ) { escaped [ attr . name ] = attr . escaped ; if ( attr . name == 'class' ) { classes . push ( '(' + attr . val + ')' ) ; } else { var pair = "'" + attr . name + "':(" + attr . val + ')' ; buf . push ( pair ) ; } }
function ( ) { if ( this . pipeless ) { if ( '\n' == this . input [ 0 ] ) return ; var i = this . input . indexOf ( '\n' ) ; if ( - 1 == i ) i = this . input . length ; var str = this . input . substr ( 0 , i ) ; this . consume ( str . length ) ; return this . tok ( 'text' , str ) ; } }
function ( ctrlSeq , html , text ) { if ( ! text ) text = ctrlSeq && ctrlSeq . length > 1 ? ctrlSeq . slice ( 1 ) : ctrlSeq ; _super . init . call ( this , ctrlSeq , [ html ] , [ text ] ) ; }
function ( type ) { var interpreter_type = type ; if ( type . search ( /effect$/ ) != - 1 ) { interpreter_type = "effect" ; tag_obj . effect = type ; this . child_interpreters [ "effect" ] . setObjs ( label && [ label ] || pieces ) ; } label = this . child_interpreters [ interpreter_type ] . interpret ( tmp_tag ) ; }
function ( data ) { var videoDiv = $ ( "#video-player" ) ; if ( data . length > 0 ) { player . src ( data [ 0 ] [ 0 ] . high ) ; $ ( "#q3" ) . fadeOut ( "fast" , function ( ) { $ ( "#q3" ) . after ( videoDiv ) ; videoDiv . fadeIn ( "slow" ) ; } ) ; } else { alert ( 'no videos found' ) ; } }
function loadType ( type , callback , error ) { if ( Tranquil [ type ] ) { callback ( ) } requireJavascript ( '/javascript/' + type + '.js' , function ( ) { if ( ! Tranquil [ type ] ) { error && error ( ) } listify ( Tranquil [ type ] . stylesheet ) . forEach ( requireStylesheet ) ; requireAllJavascript ( Tranquil [ type ] . javascript , callback ) ; } ) ; }
function updateEvent ( the_event ) { $ . update ( "/reservations/" + the_event . id , { reservation : { exchange_event_id : the_event . title , cache_start_time : "" + the_event . start , cache_end_time : "" + the_event . start , person_id : the_event . description , resource_id : 1 } } ) ; }
function createEvent ( the_event ) { $ . post ( "/reservations" , { reservation : { exchange_event_id : the_event . title , cache_start_time : "" + the_event . start , cache_end_time : "" + the_event . end , person_id : the_event . description , resource_id : 1 } } ) ; alert ( 'successfully created a reservation!' ) ; }
function ( id , key , value ) { var obj = { } ; obj . command = 'UPDATE' ; obj . id = id ; var data = { } ; data [ key ] = value ; obj . data = data ; if ( debug ) console . log ( 'setProperty()' , obj ) ; return sendObj ( obj ) ; }
function ( e ) { e . stopPropagation ( ) ; if ( debug ) console . log ( 'Toggle switch' , publicSwitch . hasClass ( 'disabled' ) ) Command . setProperty ( entity . id , 'visibleToPublicUsers' , publicSwitch . hasClass ( 'disabled' ) ) ; }
function ( e ) { e . stopPropagation ( ) ; if ( debug ) console . log ( 'Toggle switch' , authSwitch . hasClass ( 'disabled' ) ) Command . setProperty ( entity . id , 'visibleToAuthenticatedUsers' , authSwitch . hasClass ( 'disabled' ) ) ; }
function ( ) { this . $el . append ( this . template ( model . toJSON ( ) ) ) ; console . log ( this . el ) ; view . render ( ) ; view . render ( ) ; view . render ( ) ; view . render ( ) ; view . render ( ) ; view . render ( ) ; return this ; }
function ( env ) { console . log ( "init!" ) ; game . objects . length = 0 ; for ( var i = 0 , l = env . length ; i < l ; i ++ ) { executeJSON ( game , env [ i ] ) ; } }
function ( obj ) { var keys = Object . getOwnPropertyNames ( obj ) ; var result = { } ; for ( var i = 0 , l = keys . length ; i < l ; i ++ ) { var k = keys [ i ] ; result [ k ] = this . jsonFilter ( obj [ k ] ) ; } return result ; }
function ( ) { if ( this . contents == 0 ) throw "Stack underflow" ; return this . emulator . RAM [ this . contents ++ ] || 0 ; }
function ( e ) { Ti . API . info ( 'Function entered' ) if ( e . success ) { var user = e . users [ 0 ] ; alert ( 'Welcome to ShootNSell!' ) ; homeWin . open ( ) ; } else { login ( email ) ; } }
function Channel ( name ) { this . name = name ; this . users = { } ; this . serverGame = new GameController ( ) ; console . log ( "server game " + this . serverGame ) ; this . serverGame . loadLevel ( "default.json" ) ; var self = this ; NotificationCenter . on ( "processGameCommandFromUser" , function ( topic , args ) { self . processGameCommandFromUser . apply ( self , args ) ; } ) ; }
function ( user ) { var userIds = Object . keys ( this . users ) ; this . users [ user . id ] = user ; user . sendCommand ( 'joinSuccess' , { channelName : this . name , id : user . id , userIds : userIds } ) ; this . sendCommandToAllUsersExcept ( 'userJoined' , user . id , user ) ; this . serverGame . createPlayerForUser ( user ) }
f html = html . replace ( /((\{{2,3}\#(.+)?\}{2,3})([\s\S]*)?\s*(\{{2,3}~\3\}{2,3}))\=\"\"/g , '$1' ) ; html = html . replace ( /(\{{2,3}[\^#~]?)iftmplbrick\_(\d+)(\}{2,3})/g , function ( w , i , j , k ) { return i + arr [ parseInt ( j , 10 ) ] + k ; } ) ; html = html . replace ( /(\{{2,3})~/g , '$1/' ) ; return html ; }
function Flex ( element , options ) { this . version = '0.1' ; this . element = $ ( element ) ; this . tiles = this . element . find ( "a" ) ; this . options = $ . extend ( { } , defaults , options ) ; this . list = [ ] ; this . cache = [ ] ; this . init ( ) ; }
function randomisePieces ( ) { randomiseArray ( pieces ) ; var i ; for ( i = 0 ; i < pieces . length ; i ++ ) { pieces [ i ] . elm . style . left = distribute . l + distribute . w * Math . random ( ) + 'px' ; pieces [ i ] . elm . style . top = distribute . t + distribute . h * Math . random ( ) + 'px' ; } }
function mouseMove ( e ) { if ( carriedPiece && e . pageX && e . pageY ) { var mouseX = e . pageX - mouseRange . l , mouseY = e . pageY - mouseRange . t ; if ( mouseX >= 0 && mouseX <= mouseRange . w && mouseY >= 0 && mouseY <= mouseRange . h ) { carriedPiece . elm . style . left = mouseX + 'px' ; carriedPiece . elm . style . top = mouseY + 'px' ; } } }
function updateComplete ( ) { var win = true ; for ( var i = 0 ; i < ( ROWS * COLS ) ; i ++ ) { if ( inmap [ i ] != i ) win = false ; } if ( win ) { console . log ( 'YAYA~~~~~' ) ; document . getElementById ( 'heyyo' ) . innerHTML = '你完成了！！！！' ; } }
function ( type , instance ) { if ( this . subscribers [ type ] ) { var subscribers = this . subscribers [ type ] , i = subscribers . length ; while ( i -- ) { if ( subscribers [ i ] . instance === instance ) { subscribers . splice ( i , 1 ) ; } } subscribers = instance = null ; } }
function ( ) { this . dispatcher . subscribe ( "foo" , { } , "handleFoo" ) ; this . dispatcher . subscribe ( "foo" , { } , "handleFoo" ) ; expect ( this . dispatcher . subscribers . foo ) . toBeArray ( ) ; expect ( this . dispatcher . subscribers . foo . length ) . toEqual ( 2 ) ; }
function ( ) { this . dispatcher = new events . Dispatcher ( ) ; }
function Client ( options ) { this . options = options || { 'minified-script' : 'media/calipso-main' } ; this . scripts = [ ] ; this . styles = [ ] ; this . coreScripts = { 'jquery' : { key : 'jquery' , url : 'jquery-1.6.4.min.js' , weight : - 100 } , 'calipso' : { key : 'calipso' , url : 'calipso.js' , weight : - 50 } } ; }
function ( err ) { if ( err ) { req . flash ( 'info' , req . t ( 'Unable to delete the user because {msg}' , { msg : err . message } ) ) ; res . redirect ( "/user/list" ) ; } else { calipso . e . post_emit ( 'USER_DELETE' , u ) ; req . flash ( 'info' , req . t ( 'The user has now been deleted.' ) ) ; res . redirect ( "/user/list" ) ; } next ( ) ; }
function setActiveNav ( ) { var path = window . location . pathname . split ( '/' ) , page = path [ path . length - 1 ] . replace ( '.html' , '' ) ; $ ( 'nav li.active' ) . removeClass ( 'active' ) ; $ ( 'nav li a[href*=' + page + ']' ) . parent ( ) . addClass ( 'active' ) ; }
function ( chat ) { this . chat = chat ; this . sessionid = sessionStorage . sessionid || void 0 ; this . children = [ ] ; window . addEventListener ( "unload" , function ( ev ) { var c = this . children ; for ( var i = 0 , l = c . length ; i < l ; i ++ ) { c [ i ] . window . close ( ) ; } } . bind ( this ) , false ) ; }
function ( data ) { if ( sessionStorage ) { if ( this . socket ) { sessionStorage . socketid = this . socket . socket . sessionid ; } else { sessionStorage . sessionid = this . sessionId ; } } data . logs . reverse ( ) . forEach ( function ( line ) { this . write ( line ) ; } , this ) ; if ( data . logs . length ) { this . oldest_time = data . logs . shift ( ) . time ; } }
function ( xhr ) { var ret = JSON . parse ( xhr . responseText ) ; this . countryId = JSON . stringify ( ret . result ) ; Tomahawk . log ( "Got country id: " + this . countryId ) ; window . localStorage [ 'countryId' ] = this . countryId ; }
function ( ) { Tomahawk . log ( "Grooveshark resolver Getting country..." ) ; this . apiCall ( 'getCountry' , [ ] , function ( xhr ) { var ret = JSON . parse ( xhr . responseText ) ; this . countryId = JSON . stringify ( ret . result ) ; Tomahawk . log ( "Got country id: " + this . countryId ) ; window . localStorage [ 'countryId' ] = this . countryId ; } ) ; }
function ( ) { numberOfRunsInProgress -- ; $ ( createdLI ) . remove ( ) ; updateRunsListHeight ( ) ; }
function act_choose ( choice ) { var event = document . createEvent ( 'CustomEvent' ) ; var returnedChoice = { id : this . _id , type : 'activity-choice' } ; if ( choice !== null ) returnedChoice . value = choice ; event . initCustomEvent ( 'mozContentEvent' , true , true , returnedChoice ) ; window . dispatchEvent ( event ) ; delete this . _id ; }
function ( group ) { var badgeObjects = [ ] ; var badgeIds = group . get ( 'badges' ) ; p function badgeFromIndex ( id ) { return badgeIndex [ id ] } group . url = group . get ( 'url' ) ; if ( ! group . get ( 'badges' ) ) return ; badgeIds = _ . filter ( badgeIds , badgeFromIndex ) ; badgeObjects = badgeIds . map ( badgeFromIndex ) ; group . set ( 'badges' , badgeIds ) ; group . set ( 'badgeObjects' , badgeObjects ) ; }
function TestCommand1 ( ) { var command1 = CommandManager . get ( "custom.command1" ) ; if ( ! command1 ) { return ; } var command2 = CommandManager . get ( "custom.command2" ) ; if ( ! command2 ) { return ; } var checked = command1 . getChecked ( ) ; if ( checked ) { alert ( "Unchecking self. Disabling next." ) ; command2 . setEnabled ( false ) ; } else { alert ( "Checking self. Enabling next." ) ; command2 . setEnabled ( true ) ; } command1 . setChecked ( ! checked ) ; }
function ( ) { if ( $ ( this ) [ 0 ] == element [ 0 ] ) { element . animate ( { "width" : "100%" } ) ; element . find ( '.turtle' ) . trigger ( 'resize' ) ; } else { $ ( this ) . animate ( { "width" : "0%" } ) ; } }
function ( x ) { if ( ! arguments . length ) return gridUrl ; gridUrl = typeof x === 'function' ? x : templatedGridUrl ( x ) ; return manager ; }
function ( x ) { if ( ! arguments . length ) return tilejson ; if ( x . template ) { manager . template ( x . template ) ; } else if ( x . formatter ) { manager . formatter ( x . formatter ) ; } else { formatter = undefined ; } if ( x . grids ) manager . gridUrl ( x . grids ) ; if ( x . resolution ) resolution = x . resolution ; tilejson = x ; return manager ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { outerTemplate : "outer template output, [renderTemplate:innerTemplate]" , innerTemplate : "inner template output <span data-bind='text: 123'></span>" } ) ) ; testNode . innerHTML = "<div data-bind='template:\"outerTemplate\"'></div>" ; ko . applyBindings ( null , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "outer template output, inner template output" ) ; }
function ( ) { var myArray = new ko . observableArray ( [ { personName : "Bob" } , { personName : "Frank" } ] ) ; ko . setTemplateEngine ( new dummyTemplateEngine ( { itemTemplate : "The item is <span data-bind='text: personName'></span>" } ) ) ; testNode . innerHTML = "<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>" ; ko . applyBindings ( { myCollection : myArray } , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "<div>the item is <span>bob</span></div><div>the item is <span>frank</span></div>" ) ; }
function ( ) { var myArray = new ko . observableArray ( [ { personName : "Bob" } , { personName : "Frank" } ] ) ; ko . setTemplateEngine ( new dummyTemplateEngine ( { itemTemplate : "The item # is <span data-bind='text: $index'></span>" } ) ) ; testNode . innerHTML = "<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>" ; ko . applyBindings ( { myCollection : myArray } , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "<div>the item # is <span>0</span></div><div>the item # is <span>1</span></div>" ) ; }
function ( ) { var myArray = new ko . observableArray ( [ undefined , null ] ) ; ko . setTemplateEngine ( new dummyTemplateEngine ( { itemTemplate : "The item is <span data-bind='text: String($data)'></span>" } ) ) ; testNode . innerHTML = "<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>" ; ko . applyBindings ( { myCollection : myArray } , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "<div>the item is <span>undefined</span></div><div>the item is <span>null</span></div>" ) ; }
function ( Constructor ) { if ( ! Constructor ) assert . fail ( moduleName + ' did not load' ) ; assert . isFunction ( Constructor , moduleName + ' did not return a constructor function' ) ; var widget = new Constructor ( elem , params , sinon . spy ( ) ) ; assert . instanceOf ( widget , Constructor , moduleName + ' constructor did not return expected instance type' ) ; done ( ) ; }
function onResize ( ) { codeHeight = window . innerHeight - $ ( "#header" ) . height ( ) - $ ( "#Drawer" ) . height ( ) ; codeWidth = window . innerWidth ; $ ( "#code" ) . height ( codeHeight ) ; $ ( "#code" ) . width ( codeWidth ) ; $ ( "#List" ) . height ( codeHeight - 150 ) ; $ ( "#List" ) . width ( codeWidth - 150 ) ; }
function ( event , ui ) { var itemIndex = $ ( ui . item ) . index ( ) ; carrying = $ ( ui . item ) . children ( ) ; console . log ( carrying ) ; programCarrying = program [ itemIndex ] ; program . splice ( itemIndex , 1 ) ; }
function ( event , ui ) { if ( $ ( this ) . children ( ) . length === 0 ) { carrying . draggable ( { connectToSortable : "#List" , helper : "clone" } ) ; $ ( this ) . html ( carrying ) ; ui . helper . hide ( ) ; ui . draggable . remove ( ) ; } }
function ( tab ) { syncSetting ( tab ) ; Tab . activeTabs [ tab . windowId ] [ 'last_tab_id' ] = Tab . activeTabs [ tab . windowId ] [ 'current_tab_id' ] Tab . activeTabs [ tab . windowId ] [ 'current_tab_id' ] = tab . id }
function ( ) { var el = document . createElement ( 'bootstrap' ) , transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'otransitionend' , 'msTransition' : 'MSTransitionEnd' , 'transition' : 'transitionend' } , name for ( name in transEndEventNames ) { if ( el . style [ name ] !== undefined ) { return transEndEventNames [ name ] } } }
function ( ) { var active_editable_obj = this . getBaseElement ( ) ; if ( ! active_editable_obj ) { return ; } $ ( Aloha . activeEditable . obj ) . attr ( 'aloha-numerated-headers' , 'false' ) ; var headingselector = this . getCurrentConfig ( ) . headingselector ; var headers = active_editable_obj . find ( headingselector ) ; headers . each ( function ( ) { $ ( this ) . find ( 'span[role=annotation]' ) . each ( function ( ) { $ ( this ) . remove ( ) ; } ) ; } ) ; }
function ( ) { if ( typeof this . baseobjectSelector !== 'undefined' ) { return ( $ ( this . baseobjectSelector ) . length > 0 ) ? $ ( this . baseobjectSelector ) : null ; } return Aloha . activeEditable ? Aloha . activeEditable . obj : null ; }
function makeIVs ( id , slot ) { return newIVs ( sys . teamPokeDV ( id , 0 , slot , 0 ) , sys . teamPokeDV ( id , 0 , slot , 1 ) , sys . teamPokeDV ( id , 0 , slot , 2 ) , sys . teamPokeDV ( id , 0 , slot , 3 ) , sys . teamPokeDV ( id , 0 , slot , 4 ) , sys . teamPokeDV ( id , 0 , slot , 5 ) ) ; }
function makeEVs ( id , slot ) { return newEVs ( sys . teamPokeEV ( id , 0 , slot , 0 ) , sys . teamPokeEV ( id , 0 , slot , 1 ) , sys . teamPokeEV ( id , 0 , slot , 2 ) , sys . teamPokeEV ( id , 0 , slot , 3 ) , sys . teamPokeEV ( id , 0 , slot , 4 ) , sys . teamPokeEV ( id , 0 , slot , 5 ) ) ; }
function makeMovesArray ( id , slot ) { var moves = [ ] ; for ( var j = 0 ; j < 4 ; j ++ ) { moves . push ( sys . teamPokeMove ( id , 0 , slot , i ) ) ; } return moves ; }
function ( args , callback ) { MediaFile . getMediaFileTags ( args , function ( error , mediaFileTags ) { if ( ! error ) { callback ( null , mediaFileTags ) ; } else { callback ( error , null ) ; } } ) }
function ( args , callback ) { MediaFile . getMediaFileUser ( args , function ( error , mediaFileUser ) { if ( ! error ) { callback ( null , mediaFileUser ) ; } else { callback ( error , null ) ; } } ) }
function ( ) { console . log ( 'ostensibly saving everything' ) ; editor . save_report ( '#report' ) ; $ ( ".block" ) . each ( function ( i ) { console . log ( 'block' ) ; p . editor . save_block ( this ) ; } ) ; }
function ( ) { inflate = spdy . utils . zwrap ( spdy . utils . createInflate ( ) ) ; deflate = spdy . utils . zwrap ( spdy . utils . createDeflate ( ) ) ; framer = new spdy . protocol [ 2 ] . Framer ( deflate , inflate ) ; }
function ( ) { var deflate = spdy . utils . createDeflate ( ) , inflate = spdy . utils . createInflate ( ) ; parser = new spdy . parser . create ( deflate , inflate ) ; }
function ( ) { this . _super ( ) ; var context = this . _layerContext ; context . save ( ) ; context . clearRect ( 0 , 0 , this . _layerCanvas . width , - this . _layerCanvas . height ) ; context . restore ( ) ; }
function ( ) { $ . ajax ( { url : c [ "general" ] . rootUrl + c [ "i18n" ] . path + "/en.js" , async : true , dataType : "script" , success : function ( ) { c . lang = "en" ; self . init ( kvp , ctx ) ; } } ) ; }
function ( action , key , value ) { var updates = this . AttributeUpdates || ( this . AttributeUpdates = { } ) if ( updates [ key ] ) { throw new Error ( "Attribute '" + key + "' cannot be updated more than once." ) } updates [ key ] = { Action : action } if ( value ) updates [ key ] . Value = Value ( value ) return this }
function ( ) { if ( this . isRoot ( ) ) { throw "Root paths do not have a parent" ; } var data = _ . extend ( { } , this , { descriptors : _ ( this . descriptors ) . initial ( ) } ) ; return new PathInfo ( data ) ; }
function ( attr ) { var type = this . getType ( ) ; if ( _ ( attr ) . isString ( ) ) { attr = type . fields [ attr ] ; } var data = _ . extend ( { } , this , { descriptors : this . descriptors . concat ( [ attr ] ) } ) ; return new PathInfo ( data ) ; }
function ( ) { if ( this . isRoot ( ) ) { throw "Root paths do not have a parent" ; } var data = _ . extend ( { } , this , { descriptors : _ ( this . descriptors ) . initial ( ) } ) ; return new PathInfo ( data ) ; }
function ( params ) { params . topic = control . manifest . name + "." + params . topic ; params . context = control . config . get ( "context" ) ; params . callback = $ . proxy ( params . callback , control ) ; return params ; }
function ( err , res ) { return callback ( err , obj ) ; }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . above ( 0 ) ; Tester . setAuthUser ( res . body . sess , res . body . userId ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . above ( 0 ) ; Tester . setAuthUser ( res . body . sess , res . body . userId ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . above ( 0 ) ; Tester . setAuthUser ( res . body . sess , res . body . userId ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . above ( 0 ) ; Tester . setAuthUser ( res . body . sess , res . body . userId ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_UNAUTHORIZED' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 401 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_UNAUTHORIZED' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 401 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'postId' ) ; res . body . should . have . property ( 'views' ) ; res . body . views . should . above ( Tester . getPostViewsCount ( ) ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_INVALID_USER_ID' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 607 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'removedCount' ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_EMPTY_RESULTS' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 601 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'sess' ) ; res . body . should . have . property ( 'userId' ) ; res . body . userId . should . equal ( 0 ) ; Tester . setSession ( res . body . sess ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_INVALID_KEY' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 602 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_INVALID_KEY' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 602 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_INVALID_KEY' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 602 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , res ) { if ( err ) { done ( err ) ; } try { res . body . should . have . property ( 'error' ) ; res . body . error . should . equal ( 'ERR_BAD_REQUEST' ) ; res . body . should . have . property ( 'code' ) ; res . body . code . should . equal ( 400 ) ; done ( ) ; } catch ( e ) { done ( e ) ; } }
function ( err , data ) { if ( typeof handler === 'function' ) { handler ( err , JSON . parse ( '{' + data . toString ( ) . slice ( 0 , - 1 ) + '}' ) ) ; } }
function ( err , data ) { fs . writeFile ( that . fileName , JSON . stringify ( data ) . slice ( 1 , - 1 ) + ',' , handler ) ; }
function ( options ) { this . GameController = new GameController ( this , options . id ) ; this . GameController . loadLevel ( "default.json" ) console . log ( "Joined " + options . channelName ) ; if ( options . userIds && options . userIds . length > 0 ) { for ( var i = 0 ; i < options . userIds . length ; i ++ ) { this . GameController . userJoined ( options . userIds [ i ] ) } } }
function ( command , options ) { switch ( command ) { case 'joinSuccess' : this . onJoinSuccess ( options ) ; break ; case 'gameCommand' : for ( var gameCommand in options ) { this . GameController . processGameCommand ( gameCommand , options [ gameCommand ] ) ; } break ; case 'userJoined' : this . onUserJoined ( options ) ; break ; case 'userLeft' : this . onUserLeft ( options ) ; break ; default : break ; } }
function ( d ) { var currentValue = d . values [ d . values . length - 1 ] ; d . values . push ( streamIndex ( currentValue . y + random ( ) ) ) ; return d ; }
function ajaxSave ( rowid , shareduid ) { var state ; if ( $ ( '#check_' + rowid + '_' + shareduid ) . is ( ':checked' ) ) { state = "true" ; } else { state = "false" ; } $ . post ( editurlshare , { participant_id : rowid , can_edit : state , shared_uid : shareduid } ) ; }
function checkboxFormatter ( cellvalue , options , rowObject ) { cellvalue = cellvalue + "" ; cellvalue = cellvalue . toLowerCase ( ) ; var bchk = cellvalue . search ( /(false|0|no|off|n)/i ) < 0 ? " checked=\"checked\"" : "" ; return "<input type='checkbox' name=check_" + options . rowId + "_" + rowObject [ 4 ] + " id=check_" + options . rowId + "_" + rowObject [ 4 ] + " onclick=\"ajaxSave('" + options . rowId + "','" + rowObject [ 4 ] + "');\" " + bchk + " value='" + cellvalue + "' offval='no' />" }
function ( bare_jid , resource ) { if ( Object . prototype . hasOwnProperty . call ( storage , bare_jid ) ) { if ( ! ( resource in helpers . oc ( storage [ bare_jid ] ) ) ) { storage [ bare_jid ] . push ( resource ) ; } } else { storage [ bare_jid ] = [ resource ] ; } }
function isAccessible ( tab ) { return ! ! tab && ( v12 ? ! ! tab . port && tab . readyState === 'complete' : true ) ; }
function onMessageHandler ( e ) { if ( ! e || ! e . data ) return ; if ( decodeMessage ( e . data ) . type === 'menu_status_enable' ) { if ( document && document . body ) { document . body . style . color = 'black' ; } enabled = true ; } }
function ( ) { $ ( '#debug' ) . html ( 'Acceleration vector: (' + Math . round ( this . acceleration . x ) + ', ' + Math . round ( this . acceleration . y ) + ')<br/>\     Velocity vector: (' + Math . round ( this . velocity . x ) + ', ' + Math . round ( this . velocity . y ) + ')' ) ; }
function ( config ) { var isTravis = Boolean ( process . env . CI ) ; if ( isTravis ) { config = _ . extend ( { user : 'root' , } , config ) ; } else { config = _ . extend ( { host : process . env . MYSQL_HOST , port : process . env . MYSQL_PORT , user : process . env . MYSQL_USER , password : process . env . MYSQL_PASSWORD , } , config ) } return Mysql . createConnection ( config ) ; }
function ( ) { var tiler = createTiler ( ) ; tiler . refresh ( ) ; tiler . grid . css ( 'left' , - 1000 ) ; tiler . grid . css ( 'top' , - 1000 ) ; tiler . refresh ( ) ; deepEqual ( tiler . grid . position ( ) , { left : - 100 , top : - 100 } ) ; tiler . element . remove ( ) ; }
function ( ) { var tiler = createTiler ( ) ; tiler . refresh ( ) ; tiler . grid . css ( 'left' , - 150 ) ; tiler . grid . css ( 'top' , - 150 ) ; tiler . coords ( 0 , 0 ) ; deepEqual ( tiler . grid . position ( ) , { top : - 100 , left : - 100 } ) ; tiler . element . remove ( ) ; }
function ( s ) { var dist = Math . abs ( coords . y - ( s . zone . lry - ( s . zone . lry - s . zone . uly ) / 2 ) ) ; if ( coords . x < s . zone . ulx ) { dist += s . zone . ulx - coords . x ; } else if ( coords . x > s . zone . lrx ) { dist += coords . x - s . zone . ulx ; } return dist ; }
function checkState ( ) { if ( released ) throw new Error ( 'Connection is no longer available' ) ; }
function ( dto ) { totalToSave -- ; if ( ! dto ) errors ++ ; if ( totalToSave < 1 ) returnToPhantom ( errors > 0 ) ; }
function ( success , fail , args , env ) { var value ; _webview = _util . requireWebview ( ) ; if ( args ) { value = JSON . parse ( decodeURIComponent ( args [ "sandbox" ] ) ) ; _webview . setSandbox ( JSON . parse ( value ) ) ; if ( success ) { success ( ) ; } } else { value = _webview . getSandbox ( ) ; success ( value === "1" ) ; } }
function ( data ) { $ . bootstrapMessageAuto ( data [ 0 ] , data [ 1 ] ) ; if ( 'error' === data [ 1 ] ) loadPlaylist ( myPlaylist . name ) ; else if ( 'success' === data [ 1 ] ) { var v = data [ 2 ] ; var pOpt = { title : v . title , mp3 : v . url , free : true , id : v . fid } ; myPlaylist . add ( pOpt , playNow ) ; } }
function rmTrack ( url , playlistName ) { playlistName = playlistName || 'default' ; $ . bootstrapMessageLoading ( ) ; $ . post ( '/playlist/rmtrack' , { playlist : playlistName , url : url } , function ( data ) { $ . bootstrapMessageAuto ( data [ 0 ] , data [ 1 ] ) ; if ( 'error' === data [ 1 ] ) loadPlaylist ( playlistName ) ; } , 'json' ) ; }
function ( property , value ) { if ( $ . jPlayer . prototype . format [ property ] ) { if ( first ) { first = false ; } else { listItem += " | " ; } listItem += "<a class='" + self . options . playlistOptions . freeItemClass + "' href='" + value + "' tabindex='1'>(" + property + ")</a>" ; } }
function ( target_div , text , doc ) { while ( target_div . hasChildNodes ( ) ) { target_div . removeChild ( target_div . lastChild ) ; } var elem = jsonToDOM ( [ "span" , { } , text ] , doc , { } ) ; target_div . appendChild ( elem ) ; }
function updateTime ( spy ) { var timeBox = spy . logRow . getElementsByClassName ( "spyTime" ) . item ( 0 ) ; if ( spy . responseTime ) timeBox . textContent = " " + Str . formatTime ( spy . responseTime ) ; }
function ( ) { var search = this . grid . find ( 'input.aloha-browser-search-field' ) , searchValue = search . val ( ) ; if ( jQuery ( search ) . css ( "font-style" ) == "italic" ) { searchValue = "" ; } this . _pagingOffset = 0 ; this . _searchQuery = search . val ( ) ; this . fetchItems ( this . _currentFolder , this . processItems ) ; }
function ( dom ) { var options = { } ; for ( var child , i = 0 , l = dom . childNodes . length ; i < l ; ++ i ) { child = dom . childNodes [ i ] ; if ( ! child || child . nodeType != 1 ) continue ; options [ child . tagName ] = child . nodeValue ; } return options ; }
function ( dom ) { if ( ! dom ) return null ; if ( ! dom . nodeType ) dom = { namespaceURI : dom , tagName : arguments [ 1 ] , nodeType : 1 } ; if ( dom . nodeType !== 1 ) return null ; var ns = dom . namespaceURI == "urn:DAV" ? "DAV:" : dom . namespaceURI ; return "{" + ns + "}" + dom . tagName . toLowerCase ( ) ; }
function ( ) { var result = localStorage . getItem ( this . getStorageKey ( STORAGE_KEY_PSEUDONYM ) ) ; var re = /\s*<br>.*/ ; var trimmed = result . replace ( re , '' ) ; if ( trimmed !== result ) { this . setPseudonym ( trimmed ) ; } return trimmed ; }
function transition_other_shells ( ) { if ( document . getElementById ( 'other_shells' ) . style . height == "95px" ) { document . getElementById ( 'other_shells' ) . style . height = "35px" ; document . getElementById ( 'other_shells_arrow_clicked' ) . id = 'other_shells_arrow' ; } else { document . getElementById ( 'other_shells' ) . style . height = "95px" ; document . getElementById ( 'other_shells_arrow' ) . id = 'other_shells_arrow_clicked' ; } }
function expand_userhistory ( ) { if ( document . getElementById ( 'user_searches' ) . style . height == "225px" ) { document . getElementById ( 'user_searches' ) . style . height = "35px" ; document . getElementById ( 'user_searches_arrow_clicked' ) . id = 'user_searches_arrow' ; } else { document . getElementById ( 'user_searches' ) . style . height = "225px" ; document . getElementById ( 'user_searches_arrow' ) . id = 'user_searches_arrow_clicked' ; } }
function onComplete ( items , request ) { var item = items [ 0 ] ; t . assertEqual ( [ 'id' , 'name' , 'label' , 'abbreviation' , 'capital' ] , store . getAttributes ( item ) ) ; t . assertError ( Error , store , "getAttributes" , [ { } ] ) ; d . callback ( true ) ; }
function testReadApi_containsValue ( t ) { var store = dojox . data . tests . stores . QueryReadStore . getStore ( ) ; var d = new doh . Deferred ( ) ; function onComplete ( items , request ) { var item = items [ 0 ] ; t . assertTrue ( store . containsValue ( item , "name" , "Alaska" ) ) ; d . callback ( true ) ; } store . fetch ( { query : { q : "Alaska" } , onComplete : onComplete } ) ; return d ; }
function onComplete ( items , request ) { t . assertEqual ( true , store . isItem ( items [ 0 ] ) ) ; t . assertEqual ( false , store . isItem ( { } ) ) ; t . assertEqual ( false , store . isItem ( { name : "Alaska" , label : "Alaska" , abbreviation : "AK" } ) ) ; d . callback ( true ) ; }
function testReadApi_isItemLoaded ( t ) { var store = dojox . data . tests . stores . QueryReadStore . getStore ( ) ; var d = new doh . Deferred ( ) ; function onComplete ( items , request ) { var item = items [ 0 ] ; t . assertTrue ( store . isItemLoaded ( item ) ) ; d . callback ( true ) ; } store . fetch ( { query : { q : "Alabama" } , onComplete : onComplete } ) ; return d ; }
function onComplete1 ( items , request ) { t . assertEqual ( 5 , items . length ) ; t . assertEqual ( lastRequestHash , store . lastRequestHash ) ; t . assertEqual ( firstItems [ 1 ] , items [ 0 ] ) ; d . callback ( true ) ; }
function ( url ) { if ( url . indexOf ( 'px!=' < 0 ) && url . match ( /\/search?.*q=.*/ ) ) { url = url + '&px!=https:www.google.com' } else { url = url . replace ( /(.*)\?px!=(.*?\.(?:com|net|org))(.*)\?(.*)/ , '$1$3?$4&px!=$2' ) url = url . replace ( /(https?):\/\/([^\/]+)(?:\/[^\?&]*)\/https?:\/\/\2(.*)/ , '$1://$2$3' ) } return url ; }
function ( nodes ) { var result = Object . prototype . toString . call ( nodes ) ; if ( typeof nodes === 'object' && /^\[object (HTMLCollection|NodeList|Object)\]$/ . test ( result ) && ( nodes . length == 0 || ( typeof node === "object" && nodes [ 0 ] . nodeType > 0 ) ) ) { return true ; } return false ; }
function ( existingDoodle ) { for ( var i = 0 ; i < existingDoodle . length ; i ++ ) { $ ( '#doodleSelector' ) . append ( "<div><img src=" + existingDoodle [ i ] . profile_photo_url + "align='middle'><input type='checkbox' class= 'selectorCheckbox' checked='yes' value=" + i + " /><br>" + existingDoodle [ i ] . user_name + "</div>" ) ; } }
function createResultDiv ( ) { var result = document . getElementById ( "results" ) ; var ddg_result = document . getElementById ( "ddg_zeroclick" ) ; showZeroClick ( ) ; if ( ddg_result === null ) { var out = '<g:background src="css/imgs/assets/results_top_new.png" id="roundedTop">' + '<div></div>' + '</g:background>' + '<div id="res"><div id="ddg_zeroclick"></div></div>' + '<g:background src="css/imgs/assets/results_bot_new.png" id="roundedBot">' + '<div></div>' + '</g:background>' ; result . innerHTML = out ; ddg_result = document . getElementById ( "ddg_zeroclick" ) ; } return ddg_result ; }
function ( el , target ) { var rsmEl ; if ( ( rsmEl = el . getElementsByTagNameNS ( Strophe . NS . RSM , 'set' ) [ 0 ] ) ) { var lastEl = rsmEl . getElementsByTagName ( 'last' ) ; if ( lastEl ) target . rsmLast = lastEl . textContent ; } }
function ( payload ) { var options = { uri : this . _target , method : 'POST' , body : payload , headers : { 'Authorization' : generateAuthHeader ( this . _target , this . _req ) } , timeout : 20000 } ; makeRequest ( options , this . _callback ) }
function ( payload ) { var options = { uri : this . _target , method : 'PUT' , body : payload , headers : { 'Authorization' : generateAuthHeader ( this . _target , this . _req ) } , timeout : 20000 } ; makeRequest ( options , this . _callback ) }
function ( ev ) { var modpath = _findMatch ( ev ) . getAttribute ( 'modpath' ) ; var url = '/docs/plugins/' + modpath ; var parts = modpath . split ( '.' ) ; var cname = parts . pop ( ) ; window . open ( url , 'Docs for ' + modpath ) ; }
function ( data ) { rescaleGraph ( data ) console . log ( "the data to store:" , data ) ; graph_substrate . nodes ( data . nodes ) graph_substrate . links ( data . links ) graph_substrate . edgeBinding ( ) var graph_drawing = graphDrawing ( graph_substrate , svg_substrate ) graph_drawing . draw ( ) return }
function ( d ) { if ( e . ctrlKey && d . selected == true ) { selList . push ( d . baseID ) return highlightFillColor ; } if ( d . selected ) { selList . push ( d . baseID ) return highlightFillColor ; } else return 'steelblue' ; }
function ( file , dest ) { file = file || prefix + ".js" ; dest = dest || prefix + ".min.js" ; var minified = minify ( fs . readFileSync ( file , "utf-8" ) ) ; fs . writeFileSync ( dest , minified , "utf-8" ) ; sys . puts ( "> " + dest ) }
function ( newFrame ) { this . setNodeDirty ( ) ; this . _unflippedOffsetPositionFromCenter = newFrame . getOffset ( ) ; var pNewTexture = newFrame . getTexture ( ) ; if ( pNewTexture != this . _texture ) { this . setTexture ( pNewTexture ) ; } this . _rectRotated = newFrame . isRotated ( ) ; if ( this . _rectRotated ) this . setRotation ( - 90 ) ; this . setTextureRect ( newFrame . getRect ( ) , this . _rectRotated , newFrame . getOriginalSize ( ) ) ; }
function ( user ) { console . log ( 'Unload detected. Marking backend object as destroyed.' ) ; if ( this . notificationFetcher ) this . notificationFetcher . destroy ( ) ; if ( window . RPC ) window . RPC . destroy ( ) ; if ( window . API ) window . API . destroy ( ) ; }
function ( name , args , callback ) { if ( arguments . length == 2 ) { callback = args ; args = null ; } var requestId = this . idSequence ; this . idSequence ++ ; this . _retry_call ( requestId , name , args , callback ) ; }
function ( err , result ) { if ( err && err . type && err . type === 'connectionerror' ) { retries -- ; if ( retries === 0 ) { return callback ( err , result ) ; } setTimeout ( function ( ) { self . _call ( requestId , name , args , retry_callback ) ; } , sleepTime ) ; sleepTime *= self . retryTimeFactor ; return true ; } if ( callback ) { return callback ( err , result ) ; } }
function NotificationHandler ( ) { if ( window . API && window . API . user ( ) !== null ) { this . fetch_notifications ( ) ; } else { BUS . on ( 'api.user' , function ( ) { this . fetch_notifications ( ) ; } , this ) ; } }
function ( ) { if ( this . timeoutId ) { window . clearTimeout ( this . timeoutId ) ; } }
function ( name , params , callback ) { if ( typeof ( params ) == "function" ) { callback = params ; params = undefined ; } if ( this . apikey . get ( ) ) { if ( params === undefined ) { params = { 'apikey' : this . apikey . get ( ) } ; } else { params . apikey = this . apikey . get ( ) ; } } this . rpc . doRPC ( name , params , callback ) ; }
function ( stel ) { var src = stel . options . src , interactiveSrc = getCachedInteractiveScript ( ) . src ; steal . preloaded = before ( steal . preloaded , function ( stel ) { if ( ! support . interactive ) { return ; } var src = stel . options . src , interactiveSrc = getCachedInteractiveScript ( ) . src ; interactives [ src ] = interactives [ interactiveSrc ] ; interactives [ interactiveSrc ] = null ; } ) ; }
function ( error , userNotifications ) { if ( error ) { callback ( error , null ) ; return ; } if ( 0 === userNotifications . length ) { callback ( "No user notifications were found matching your parameters" , null ) ; return ; } args . usernotifications = userNotifications ; UserNotification . removeUserNotifications ( args , function ( error , removedUserNotifications ) { if ( error ) { callback ( error , null ) ; return ; } else { callback ( null , removedUserNotifications ) ; } } ) ; }
function ( error , notificationListeners ) { test . ok ( notificationListeners . should . have . lengthOf ( 1 ) ) ; test . done ( ) ; }
function ( test ) { var args = { user : 'A7S7F8GA7SD11A7SDF8ASD7G' , event : 0 , target : 'A7S7FHGA7SD11A7SDF8AS87G' , } NotificationListener . findNotificationListener ( args , function ( error , notificationListener ) { test . ok ( notificationListener . should . have . property ( 'user' , 'A7S7F8GA7SD11A7SDF8ASD7G' ) ) ; test . done ( ) ; } ) ; }
function ( error , notificationListeners ) { test . ok ( notificationListeners . should . have . lengthOf ( 0 ) ) ; test . done ( ) ; }
function ( error , notificationSettings ) { args . usernotificationsettings = notificationSettings ; test . ok ( args . usernotificationsettings . should . have . property ( "notificationOnNewResource" , 0 ) ) ; UserNotificationSettings . updateUserNotificationSettings ( args , function ( error , updatedSettings ) { test . ok ( updatedSettings . should . have . property ( "notificationOnNewResource" , 3 ) ) ; test . done ( ) ; } ) ; }
function ( newValue ) { if ( newValue == CinchApp . gameModeEnum . bid ) { if ( self . matchPoints ( ) . length > 0 ) { CinchApp . secondaryActionQueue . push ( function ( ) { CinchApp . secondaryActionQueue . push ( function ( ) { openJqmDialog ( '#hand-end-page' ) ; } ) ; } ) ; } else { self . startBidding ( ) ; } } else { $ . mobile . changePage ( '#game-page' , { transition : 'slideup' } ) ; } }
function ( type , size ) { return new exports . FileSystemSync ( "default" , nPath . join ( process . cwd ( ) , "default" ) ) ; }
function ( $ ) { if ( $ ) { var parsedTag = $ . match ( /^(\S+)(:?\s+(\S[\s\S]*))?/ ) ; if ( parsedTag ) { var [ , tagTitle , tagText ] = parsedTag ; if ( tagTitle ) { tagSrcs . push ( { title : tagTitle , text : tagText } ) ; } } } }
function parseParamText ( tagText ) { var pname , pdesc , poptional , pdefault ; tagText . match ( /^(\[[^\]]+\]|\S+)((?:\s*\-\s*|\s+)(\S[\s\S]*))?$/ ) ; pname = RegExp . $1 ; pdesc = RegExp . $3 ; if ( /^\[\s*(.+?)\s*\]$/ . test ( pname ) ) { pname = RegExp . $1 ; poptional = true ; if ( /^(.+?)\s*=\s*(.+)$/ . test ( pname ) ) { pname = RegExp . $1 ; pdefault = RegExp . $2 ; } } return [ pname , pdesc , poptional , pdefault ] ; }
function parseBorrows ( doclet , tag ) { var m = /^(\S+)(?:\s+as\s+(\S+))?$/ . exec ( tag . text ) ; if ( m ) { if ( m [ 1 ] && m [ 2 ] ) { return [ m [ 1 ] , m [ 2 ] ] ; } else if ( m [ 1 ] ) { return [ m [ 1 ] ] ; } } }
function parseNullable ( type ) { var nullable = null ; if ( /^([\?\!])(.+)$/ . test ( type ) ) { type = RegExp . $2 ; nullable = ( RegExp . $1 === '?' ) ? true : false ; } return [ type , nullable ] ; }
function parseYieldExpression ( ) { var delegate , expr , previousYieldAllowed ; expectKeyword ( 'yield' ) ; if ( ! yieldAllowed ) { throwErrorTolerant ( { } , Messages . IllegalYield ) ; } delegate = false ; if ( match ( '*' ) ) { lex ( ) ; delegate = true ; } previousYieldAllowed = yieldAllowed ; yieldAllowed = false ; expr = parseAssignmentExpression ( ) ; yieldAllowed = previousYieldAllowed ; return { type : Syntax . YieldExpression , argument : expr , delegate : delegate } ; }
function ( context , text ) { var appliedShadow = false ; context . save ( ) ; if ( this . attrs . textFill ) { if ( this . attrs . shadow && ! this . appliedShadow ) { appliedShadow = this . _applyShadow ( context ) ; } context . fillStyle = this . attrs . textFill ; context . fillText ( text , 0 , 0 ) ; } context . restore ( ) ; if ( appliedShadow ) { this . fillText ( context , text , 0 , 0 ) ; } }
function ( doc , collection ) { console . log ( doc , collection ) ; var dataUri = this . MONGOHQ_API_BASE_URI + collection + "/documents" + "?_apikey=i0h95kvp3dyx14hvw9bl" ; $ . ajax ( { type : 'POST' , url : dataUri , data : { "document" : doc } , dataType : "json" , sucess : function ( ) { console . log ( "done" ) ; } } ) ; }
function ( key , value ) { me . _keys [ key ] = { value : value } try { me . _performSubstitutions . call ( me ) ; } catch ( error ) { if ( cb ) { cb ( error ) ; cb = null ; } } }
function ( ) { var scopeId = $ ( '#scopeIdInput' ) . val ( ) ; log . debug ( "Joining scope with id; " + scopeId ) ; CA . RealtimeTransport . joinScope ( scopeId , 'some details' ) ; CA . joinedScope = scopeId ; }
function ( socket , clientId ) { log . debug ( "Got new client joining the scope with id: " + this . id ) ; for ( var i in this . socketId2Client ) { var existingClient = this . socketId2Client [ i ] ; existingClient . socket . emit ( 'newClient' , { scopeId : this . id , clientId : clientId } ) ; } var client = new Client ( clientId , socket ) ; this . socketId2Client [ socket . id ] = client ; this . clientDetails [ clientId ] = client ; this . parts += 1 ; }
function ( err ) { if ( err != null ) { throw err ; } print ( ( "source for " + _this . file . relativePath + "                   documentation processed" ) . squeeze ( ) ) ; return typeof callback === "function" ? callback ( ) : void 0 ; }
function ( err , tpl ) { if ( err ) { if ( typeof callback === "function" ) { callback ( new Error ( error ( "Can't access " + tplfile + "\n\n" + err . stack ) ) ) ; } } return typeof callback === "function" ? callback ( null , render ( tpl . toString ( ) , context ) ) : void 0 ; }
function ( number ) { switch ( number ) { case 0 : return 'M<br/>O<br/>N<br/>' ; break ; case 1 : return 'T<br/>U<br/>E<br/>' ; break ; case 2 : return 'W<br/>E<br/>D<br/>' ; break ; case 3 : return 'T<br/>H<br/>U<br/>' ; break ; case 4 : return 'F<br/>R<br/>I<br/>' ; break ; case 5 : return 'S<br/>A<br/>T<br/>' ; break ; case 6 : return 'S<br/>U<br/>N<br/>' ; break ; } }
function ( ) { var carouselActive = this . meta ( 'carouselActive' ) ; if ( typeof carouselActive == 'undefined' || carouselActive === false ) { $ ( this . el ) . find ( '.arrow-right' ) . css ( 'display' , 'block' ) ; $ ( this . el ) . find ( '.arrow-left' ) . css ( 'display' , 'block' ) ; $ ( this . el ) . find ( '.arrow-right' ) . css ( 'border-left' , '10px solid #666' ) ; } }
function ( ) { this . inherited ( arguments ) ; for ( var i = 0 ; i < this . panelArrangers . length ; i ++ ) { this . $ . pickerScroller . createComponent ( { content : this . panelArrangers [ i ] . name } ) ; } this . panelCount = this . $ . samplePanels . getPanels ( ) . length ; }
function ( next ) { this . req . connection . setTimeout ( haibu . config . get ( 'service:timeout' ) || 60 * 1000 * 15 ) ; if ( this . req . headers [ 'x-auth-token' ] === authToken ) { next ( ) ; return true ; } haibu . sendResponse ( this . res , 403 , { message : 'Wrong auth token' } ) ; return false ; }
function ( ) { var input = Y . one ( '.example #demo #ac-input' ) , list = Y . one ( '.example #demo .yui3-aclist-list' ) , interval = 10 , timeout = 10000 ; var listItems = list . all ( 'li' ) ; listItems . item ( 1 ) . simulate ( 'click' ) ; Assert . areEqual ( 'javascript, ' , input . get ( 'value' ) , ' - Failed to find selected item text in input' ) }
function ( data , sel , w , h ) { var labels = [ ] , values = [ ] , j = 0 ; for ( var i in data ) { labels [ j ] = i ; values [ j ] = data [ i ] ; j ++ ; } this . donut ( { data : values , labels : labels , centerLabel : 'Behavior' , container : sel } ) ; }
function ( ) { var photos = Y . one ( '.example #photos' ) ; list . one ( 'li' ) . simulate ( 'click' ) ; Assert . areEqual ( 1 , photos . all ( 'li img' ) . size ( ) , ' - Failed to find exactly 1 selected photo' ) ; list . one ( 'li' ) . simulate ( 'click' ) ; Assert . areEqual ( 2 , photos . all ( 'li img' ) . size ( ) , ' - Failed to find exactly 2 selected photo' ) ; }
function ( ) { var listItems = list . all ( 'li' ) ; Assert . isTrue ( listItems . size ( ) > 6 , ' - Failed to find more than 6 results for ' + inputStr ) ; Assert . areEqual ( '701 1st Ave, Manhattan, NY 10017, USA' , listItems . item ( 1 ) . getHTML ( ) , 'failed to find correct 2nd item in list' ) ; }
function ( ) { var listItems = list . all ( 'li' ) ; listItems . item ( 2 ) . simulate ( 'click' ) ; Assert . areEqual ( '701 1st Ave, Manhattan, NY 10016, USA' , input . get ( 'value' ) , ' - Failed to find selected item text in input' ) Assert . areEqual ( '40.74754' , Y . one ( '#locationLat' ) . getHTML ( ) , ' - Failed to find 3rd item selected' ) ; Assert . areEqual ( '-73.97078' , Y . one ( '#locationLng' ) . getHTML ( ) , ' - Failed to find 3rd item selected' ) ; }
function ( ) { this . shadowleft . css ( { right : this . shadowleft . parent ( ) . width ( ) / 2 + 63 } ) ; this . shadowright . css ( { left : this . shadowright . parent ( ) . width ( ) / 2 + 64 } ) ; return this . tapebox . css ( { left : this . tapebox . parent ( ) . width ( ) / 2 - 62 } ) ; }
function ( err , repoId ) { if ( err ) { console . log ( "addUpdateRepo error:" , err ) ; } else { gitHubData . repoId = repoId ; gitHubData . branchUrl = path . join ( gitHubData . repository . url , "tree" , gitHubData . ref . split ( '/' ) [ 2 ] ) ; findControls ( gitHubData ) ; } }
function ( i , o ) { var type = o . attr ( 'type' ) ; switch ( type ) { case 'hidden' : type = 'text' ; case 'text' : if ( o . val ( ) == '' ) { camposObrigatorios += '<li>' + o . find ( 'label' ) . text ( ) + '</li>' ; } break ; } ulObrigatorios = $ ( '<ul></ul>' ) . append ( camposObrigatorios ) ; modalCorrecoes . append ( '<span>Existem campos obrigatórios em branco:</span><br />' , ulObrigatorios ) ; }
function ( e ) { if ( e . success ) { var acls = e . acls [ 0 ] ; readers . public = acls . public_read || false ; readers . ids = acls . readers || [ ] ; writers . public = acls . public_write || false ; writers . ids = acls . writers || [ ] ; alert ( 'Shown!' ) ; } else { error ( e ) ; } }
function ( evt ) { Cloud . ACLs . update ( { name : name . value , reader_ids : readers . ids . join ( ',' ) , writer_ids : writers . ids . join ( ',' ) , public_read : readers . public , public_write : writers . public } , function ( e ) { if ( e . success ) { alert ( 'Updated!' ) ; } else { error ( e ) ; } } ) ; }
function ( req , res ) { console . error ( "route hit" ) ; var test = git . readFile ( "fs" , req . url , function ( err , data ) { if ( err ) { throw err ; } console . log ( data . toString ( ) ) ; res . end ( data . toString ( ) ) ; } ) }
function ( name ) { if ( name ) { socket . name ( name ) ; this . switchView ( new ChatView ( { router : this } ) ) ; } else { this . navigate ( '' , { trigger : true } ) ; } }
function ( event ) { if ( event . which == 13 ) { var input = this . $ ( 'input' ) ; socket . send ( input . val ( ) ) ; input . val ( null ) ; this . options . router . navigate ( '' , { trigger : true } ) ; } }
function ( position , rotation , vertices , update , render ) { "use strict" ; this . _super ( position , rotation ) ; this . vertices = vertices || [ 5 , 5 , 100 , 50 , 50 , 100 , 10 , 90 ] ; if ( update ) { this . update = update ; } if ( render ) { this . render = render ; } }
function ( json ) { json = $ . postParseJson ( json ) ; $ ( msg ) . after ( json . Data ) ; $ ( msg ) . hide ( ) ; }
function ( users , maxUsers , el ) { var percentage = users ? users / maxUsers : 0.5 , scale = users ? ( percentage + "," + percentage ) : '1,1' ; el . css ( { "-webkit-transform" : "scale( " + scale + ")" , opacity : percentage } ) ; }
function ( template ) { var html = template . render ( data ) ; App . makeModal ( html ) ; bindDialog ( ) ; }
function ( parent ) { this . request . __proto__ = parent . request ; this . response . __proto__ = parent . response ; this . engines . __proto__ = parent . engines ; this . viewCallbacks = parent . viewCallbacks . slice ( 0 ) ; }
function ( node ) { if ( node . checked ) { node . select ( node . checked ) ; } node . expand ( true ) ; node . setDefault ( params . default_value ) ; }
function ( node ) { if ( node . checked ) { node . select ( node . checked ) ; } node . expand ( true ) ; node . setDefault ( params . default_value ) ; }
function ( err , data ) { console . log ( err ) ; data . insert ( me . attributes , function ( error , results ) { console . log ( error ) ; console . log ( results ) ; callback ( error , results ) ; } ) ; }
function ( ) { var resData = JSON . parse ( data ) , out = cashboard . translate ( resData ) ; callback ( out ) ; }
function ( ) { var resData = JSON . parse ( data ) , out = redmine . translate ( resData ) ; callback ( out ) ; }
function ( e ) { e . preventDefault ( ) ; var $input = $ ( this ) . parent ( ) . find ( 'input[type=text]' ) ; var time = new Date ( ) ; $input . val ( time . getHours ( ) + ':' + time . getMinutes ( ) ) }
function ( event ) { var emptyDimensions = CubeViz_Main_Module . checkDimensionElementCount ( ) ; if ( emptyDimensions . length != 0 ) { CubeViz_Main_Module . showEmptyDimensionsWarning ( emptyDimensions ) ; } else { } console . log ( emptyDimensions ) ; }
function ( media ) { this . inherited ( arguments ) ; if ( this . useHtml5Player ) { return ; } mulberry . app . PhoneGap . video . play ( this . media . url ) ; }
function ( a ) { var m , result = 0 ; if ( ( m = a . match ( re ) ) !== null ) { result = map [ m [ 1 ] . toLowerCase ( ) ] ; switch ( m [ 2 ] ) { case "+" : case "#" : ++ result ; break ; case "-" : case "b" : -- result ; break ; } result += 12 * ( ( m [ 3 ] | 0 ) + 1 ) ; } return result ; }
function ( ) { console . log ( "using index" ) ; var values = [ 45 , 30 , 25 ] , labels = [ 'Fulfilled' , 'Complete' , 'Something' ] , colors = [ '#00A79B' , '#D8DF21' , '#bf272d' ] ; Raphael ( "piechart" , 700 , 700 ) . pieChart ( 300 , 300 , 150 , values , labels , colors , "#fff" ) ; }
function ( ) { var loc = this . toJSON ( ) ; if ( loc . lat !== null && loc . lon !== null ) { this . sendServer ( loc ) ; } }
function ( e ) { this . touchTimeout = null ; if ( e . target === this . target [ 0 ] && this . TAP_TOLERANCE >= Math . abs ( this . touch . x1 - this . touch . x2 ) && this . TAP_TOLERANCE >= Math . abs ( this . touch . y1 - this . touch . y2 ) ) { this . touch . type = 'tap' ; this . _triggerEvent ( e ) ; } this . _resetTouch ( ) ; }
function ( selectedCslId ) { editorElement . find ( 'span[cslid="' + oldSelectedCslId + '"]' ) . removeClass ( "highlighted" ) ; editorElement . find ( 'span[cslid="' + oldSelectedCslId + '"]' ) . removeClass ( "selected" ) ; oldSelectedCslId = selectedCslId ; editorElement . find ( 'span[cslid="' + selectedCslId + '"]' ) . removeClass ( "highlighted" ) ; editorElement . find ( 'span[cslid="' + selectedCslId + '"]' ) . addClass ( "selected" ) ; }
function ( ) { var index , cslId = parseInt ( hoveredNodeStack [ hoveredNodeStack . length - 1 ] ) , selectedNode ; assert ( hoveredNodeStack . length > 0 ) ; selectedNode = CSLEDIT . data . getNode ( cslId ) ; if ( selectedNode . name === "macro" ) { assert ( hoveredNodeStack . length > 1 ) ; cslId = hoveredNodeStack [ hoveredNodeStack . length - 2 ] ; } if ( selectedCslId !== cslId ) { selectedCslId = cslId ; CSLEDIT . viewController . selectNode ( cslId , highlightedTreeNodes ) ; } }
function ( ) { var numCslNodes = CSLEDIT . data . numCslNodes ( ) ; hoveredNodeStack . length = 0 ; selectedCslId = - 1 ; setupEventHandlers ( ) ; if ( CSLEDIT . viewController . selectedNode ( ) != - 1 ) { editorElement . find ( 'span[cslid=' + CSLEDIT . viewController . selectedNode ( ) + ']' ) . addClass ( 'selected' ) ; } }
function ( x , y , w , h ) { if ( x !== 0 || y !== 0 || w !== gl2d . canvas . width || h !== gl2d . canvas . height ) { gl . enable ( gl . SCISSOR_TEST ) ; y = gl2d . canvas . height - y - h ; gl . scissor ( x , y , w , h ) ; } else { gl . disable ( gl . SCISSOR_TEST ) ; } }
function ( data , callback ) { View . block ( ) ; this . blockingCallback = callback ; $ . post ( "memplex.php" , { "parent" : Controller . activeTopnode , "layer" : data . layer , "author" : data . author , "title" : data . title , "text" : data . text } , function ( data ) { var json = $ . parseJSON ( data ) ; var Memplex = json . data ; Controller . blockingCallback ( ) ; Controller . loadMemplex ( Memplex ) ; } ) ; }
function _getCodeHints ( jsonStr , filter ) { var hintObj = JSON . parse ( jsonStr ) , hintArray = [ ] ; hintArray = $ . map ( hintObj , function ( value , key ) { return key ; } ) ; if ( ! filter ) { return hintArray ; } else { var matcher = new RegExp ( filter . replace ( /[-[\]{}()*+?.,\\^$|#\s]/g , "\\$&" ) , "i" ) ; return $ . grep ( hintArray , function ( value ) { return matcher . test ( value ) ; } ) ; } }
function _handleSelectAll ( ) { var editor = EditorManager . getFocusedEditor ( ) ; if ( editor ) { editor . _selectAllVisible ( ) ; } }
function ( grunt ) { grunt . initConfig ( { } ) ; var connect = require ( 'connect' ) ; grunt . registerTask ( 'server' , 'Starts the static web server' , function ( ) { connect ( connect . static ( 'www-root' ) ) . listen ( 1337 ) ; } ) ; }
function ( e ) { var pos = { x : e . pageX - canvas . offsetLeft , y : e . pageY - canvas . offsetTop } ; if ( highlightedCell ) { if ( ! highlightedCell . inBounds ( pos ) ) { highlightedCell . highlighted = false ; highlightedCell = null ; } } }
function ( obj ) { if ( uMarker == null ) { map . setCenter ( new google . maps . LatLng ( obj . lat , obj . lng ) ) ; } else { uMarker . setPosition ( new google . maps . LatLng ( obj . lat , obj . lng ) ) ; drawMap ( ) ; } searchCircle . setCenter ( new google . maps . LatLng ( obj . lat , obj . lng ) ) ; }
function ( ) { for ( var i = markers . length - 1 ; i >= 0 ; i -- ) { markers [ i ] . setVisible ( markers [ i ] . isp == ispName ) ; markers [ i ] . inCircle = searchCircle . contains ( markers [ i ] . getPosition ( ) ) ; } drawSearchArea ( ) ; }
function ( data ) { if ( content ) { content = content . replace ( result [ 0 ] , '\n' + data + '\n' ) ; content = self . analyzeImports ( content , callback ) ; } else { utils . log ( 'no content' , 'debug' ) ; } }
function ( e , data ) { }
function ( button , event ) { this . close ( global . get_current_time ( ) ) ; let meta = { uuid : this . _uuid , state : ExtensionSystem . ExtensionState . UNINSTALLED , error : '' } ; _signals . emit ( 'extension-state-changed' , meta ) ; }
function ( ele , onEvent , fun ) { onEvent = replace ( /^\s*on/ , '' ) ; var element = baidu . dom . g ( ele ) ; baidu . dom ( element ) . off ( onEvent , fun ) ; return element ; }
function ( ele , onEvent , fun ) { onEvent = replace ( /^\s*on/ , '' ) ; var element = baidu . dom . g ( ele ) ; baidu . dom ( element ) . on ( onEvent , fun ) ; return element ; }
function ( ) { var self = this ; this . worker = new Worker ( 'BitComposerWorker.js' ) ; this . worker . addEventListener ( 'message' , function ( event ) { return self . messageFromWorker ( event ) ; } , false ) ; this . refinementCallback = { } ; this . refinementDataURLs = [ ] ; this . nextLevelToSend = 0 ; this . refinementsToProcess = [ ] ; this . requestedRefinement = { pendingRequests : 0 , attributeArrayBuffers : [ ] } ; this . useDebugOutput = false ; }
function ( pars , divPrecarga , divCarga , callback ) { "use strict" ; var myAjax ; myAjax = new Ajax . Request ( url , { method : 'post' , parameters : pars , onCreate : $ ( divPrecarga ) . innerHTML = imgCarga , onComplete : function gen ( respuesta ) { $ ( divCarga ) . innerHTML = respuesta . responseText ; if ( callback ) { callback ( ) ; } } } ) ; }
function ( ) { qx . event . Registration . removeListener ( this . __pblocker , 'tap' , this . __onTapBlocker , this ) ; var rootElement = this . __root . getElement ( ) ; rootElement . removeChild ( this . __pblocker ) ; rootElement . removeChild ( this . __mblocker ) ; this . __root = this . __pblocker = this . __mblocker = this . __overlays = this . __visibleOverlays = this . __styleRegistry = null ; }
function ( button , e , options ) { Util . logoutUser ( ) ; var logconfirm = Ext . getCmp ( 'LogoutConfirmPanelID' ) ; logconfirm . hide ( ) ; }
function ( ) { return ! store . isLoading ( ) ; }
function ( list , index , node , record ) { if ( ! this . showContact ) { this . showContact = Ext . create ( 'RaxaEmr.Outpatient.view.patient.more' ) ; } this . showContact . setRecord ( record ) ; this . getMain ( ) . push ( this . showContact ) ; }
function validate_input_field ( field , name , okstatus ) { var errormsg = '' ; if ( ! jQuery ( field ) . val ( ) . match ( /^[a-zA-Z0-9_\^\-\.\/\s]+$/ ) ) { okstatus = false ; errormsg = "In the " + name + " " + jQuery ( field ) . attr ( "id" ) + " field you CAN use alpha numeric values with the following symbols:\n" + "^ - _ .\n" + "but you CANNOT use comma, brackets, single or double quotes, it CANNOT end with a space and it CANNOT be empty\n" ; } return { "okstatus" : okstatus , "errormsg" : errormsg } ; }
function ( ) { var to = setTimeout ( function ( ) { ok ( false , 'Timed out' ) ; start ( ) ; } , 10000 ) ; $ ( '#qunit-fixture' ) . append ( '<div id="feeds" />' ) ; $ ( '#feeds' ) . feeds ( { feeds : { 'google' : 'http://googleblog.blogspot.com/atom.xml' } , onComplete : function ( entries ) { ok ( true ) ; clearTimeout ( to ) ; start ( ) ; } } ) ; }
function ( entries ) { equal ( 0 , entries . length ) ; clearTimeout ( to ) ; start ( ) ; }
function ( ) { ok ( false , 'Timed out' ) ; start ( ) ; }
function ( ) { ok ( false , 'Timed out' ) ; start ( ) ; }
function ( ) { if ( x . readyState == 4 && x . status == 200 ) { try { var cmds = JSON . parse ( x . responseText ) ; for ( var i = 0 ; i < cmds . length ; i ++ ) { __p . postMessage ( cmds [ i ] ) ; } } catch ( e ) { } } }
function ( e ) { try { var cmds = JSON . parse ( e . data ) ; for ( var i = 0 ; i < cmds . length ; i ++ ) { __p . postMessage ( cmds [ i ] ) ; } } catch ( e ) { } }
function ( ) { if ( backchannel ) { backchannel . postMessage ( { 'cmd' : 'log' , 'p' : [ ] . slice . call ( arguments ) } ) ; } }
function ( ) { var clone = [ ] ; Object . keys ( persistentScripts ) . forEach ( function ( key ) { clone . push ( { name : key , urlmatch : persistentScripts [ key ] . urlmatch , code : persistentScripts [ key ] . code . substr ( 0 , 100 ) + "..." } ) ; } ) ; log ( { type : 'report_persistent' , 'result' : clone } ) ; }
function startService ( name , options ) { if ( runningService ) { serviceManager . stop ( runningService ) ; } var module = serviceManager . start ( name , options ) ; if ( module ) { runningService = name ; } bid . resize ( ) ; return module ; }
function fire ( message ) { var messageListeners = listeners [ message ] ; if ( messageListeners ) { for ( var i = 0 , listener ; listener = messageListeners [ i ] ; ++ i ) { listener . callback . apply ( null , arguments ) ; } } for ( var j = 0 , glistener ; glistener = globalListeners [ j ] ; ++ j ) { glistener . callback . apply ( null , arguments ) ; } }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function ( evt ) { var inputKeywords = this . $ ( '#id_keywords' ) ; var currentKeywords = inputKeywords . val ( ) ; this . $el . data ( 'initial-keywords' , currentKeywords ) ; this . $ ( '#map-block' ) . data ( 'initial-keywords' , currentKeywords ) ; this . refresh ( ) ; }
function Testling ( harness , name , conf ) { Test . apply ( this , arguments ) ; for ( var key in Test . prototype ) { this [ key ] = Test . prototype [ key ] . bind ( this ) ; } for ( var key in Testling . prototype ) { this [ key ] = Testling . prototype [ key ] . bind ( this ) ; } }
function ( evt ) { evt . preventDefault ( ) ; var target = $ ( evt . target ) var details = { } details . permalink = encodeURIComponent ( target . attr ( 'href' ) ) details . title = encodeURIComponent ( target . data ( 'title' ) ) return details }
function cursorX ( elem , evt ) { if ( isFixed ( elem ) ) { var bodyLeft = parseInt ( document . defaultView . getComputedStyle ( document . body , "" ) . marginLeft , 10 ) ; return evt . clientX - bodyLeft ; } if ( evt . pageX ) return evt . pageX ; else if ( evt . clientX ) return evt . clientX + document . body . scrollLeft ; }
function cursorY ( elem , evt ) { if ( isFixed ( elem ) ) { var bodyTop = parseInt ( document . defaultView . getComputedStyle ( document . body , "" ) . marginTop , 10 ) ; return evt . clientY - bodyTop ; } if ( evt . pageY ) return evt . pageY ; else if ( evt . clientY ) return evt . clientY + document . body . scrollTop ; }
function calculator_appendValue ( value ) { if ( this . toClear ) { this . stack = [ ] ; this . toClear = false ; } this . stack . push ( value ) ; this . updateDisplay ( ) ; }
function evaluatePostFix_inner ( token ) { if ( ! this . isOperator ( token ) ) { stack . push ( token ) ; } else { var op2 = stack . pop ( ) ; var op1 = stack . pop ( ) ; var result = this . evaluate [ token ] ( op1 , op2 ) ; stack . push ( result ) ; } }
function scroll_handler ( ) { scrTop = scrolling_container . scrollTop ( ) ; wndHeight = scrolling_container . height ( ) ; curScrOffset = scrTop + wndHeight ; if ( curScrOffset >= get_scroll_treshold ( ) ) { paginate ( curScrOffset ) ; } }
function ( ) { console . log ( "hide textarea" ) ; $ ( 'textarea#edit' ) . hide ( ) ; var elem = $ ( "hastheword[refid='" + id + "']" ) ; if ( elem . html ( ) == elem . attr ( "reset" ) ) elem . removeClass ( "edited" ) ; else elem . addClass ( "edited" ) ; }
function ( x , y , z ) { this . locX = x ; this . locY = y ; this . locZ = z ; this . translateMatrix = null ; this . staticMatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { this . dLocX = x ; this . dLocY = y ; this . dLocZ = z ; this . translateMatrix = null ; this . staticMatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z , w ) { this . mode = GLGE . P_QUAT ; this . quatX = x ; this . quatY = y ; this . quatZ = z ; this . quatW = w ; this . staticMatrix = null ; this . rotmatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { this . mode = GLGE . P_EULER ; this . rotX = x ; this . rotY = y ; this . rotZ = z ; this . staticMatrix = null ; this . rotmatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { this . mode = GLGE . P_EULER ; this . dRotX = x ; this . dRotY = y ; this . dRotZ = z ; this . staticMatrix = null ; this . rotmatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { if ( ! y ) { y = x ; z = x } ; this . scaleX = x ; this . scaleY = y ; this . scaleZ = z ; this . staticMatrix = null ; this . scaleMatrix = null ; this . updateMatrix ( ) ; return this ; }
function ( x , y , z ) { this . dScaleX = x ; this . dScaleY = y ; this . dScaleZ = z ; this . staticMatrix == null ; this . scaleMatrix = null ; this . updateMatrix ( ) ; return this ; }
function expandUrl ( url ) { return PDFJS . combineUrl ( window . location . href , url ) ; }
function ( event ) { event . preventDefault ( ) ; var target = $ ( event . currentTarget ) . closest ( '.un-us-item' ) ; var task = Greenmine . taskCollection . get ( target . data ( 'id' ) ) ; this . lightbox . setReference ( task ) ; this . lightbox . open ( ) ; this . lightbox . on ( 'delete' , this . deleteIssue ) ; }
function ( data ) { if ( data . valid ) { var selector = "#task_" + task . get ( 'id' ) ; self . $ ( selector ) . remove ( ) ; } }
function write ( view , truthy ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; if ( ! ! truthy ) { if ( view . is ( ":empty" ) ) { var render = view . data ( hdRenderName ) ; var copy = render ( ) ; view . append ( copy ) ; } } else { view . empty ( ) ; } }
function bindIf ( view , variable , context ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; var template = view . contents ( ) . detach ( ) ; view . data ( hdRenderName , function renderIf ( ) { var copy = template . clone ( ) ; hd . bindTree ( copy , context ) ; return copy ; } ) ; hd . bindWrite ( variable , view , { write : write } ) ; return true ; }
function ( transaction , error ) { alert ( "Oops, that didn't work. Reload the page and try again, maybe?" ) ; }
function ( ) { var controllerClass , _i , _len ; for ( _i = 0 , _len = controllers . length ; _i < _len ; _i ++ ) { controllerClass = controllers [ _i ] ; try { Ext . create ( controllerClass , { view : this } ) ; } catch ( error ) { Deft . Logger . log ( "Error initializing Controllable instance: an error occurred while creating an instance of the specified controller: '" + controllerClass + "'." ) ; throw error ; } } }
function ( ) { this . clear ( ) ; this . columns = [ ] ; this . headerElm . empty ( ) ; $ ( '<th class="ui-state-default ui-corner-top ui-table-cell-empty">&nbsp;</th>' ) . appendTo ( this . headerElm ) ; }
function updateDisplayedSegments ( report ) { var segments = getSelectedSegments ( report ) ; var newSeries = report . series . filter ( function ( segment ) { return segments . indexOf ( segment . name ) !== - 1 ; } ) ; if ( newSeries . length === 0 ) { return false ; } else { report . series = newSeries ; } updateGraph ( report ) ; return true ; }
function ( conn , buffer ) { var self = this ; try { conn . pause ( ) ; session . common . readJson ( self , buffer , function ( obj ) { self . processMsg ( conn , obj ) ; } ) ; } catch ( err ) { log ( this . sessionId , 'ERROR ' , '[PZH] Exception in processing recieved message ' + err ) ; } finally { conn . resume ( ) ; } }
function ( $slider , showNextSlide , movingSlides ) { var $sliderContainer = $ ( $slider . children ( ) . get ( 0 ) ) , $slides = $sliderContainer . children ( ) , $selectedSlides = showNextSlide ? $slides . slice ( 0 , movingSlides ) : $slides . slice ( - 1 * movingSlides ) ; showNextSlide ? $sliderContainer . append ( $selectedSlides ) : $sliderContainer . prepend ( $selectedSlides ) ; }
function ( e , showNextSlide ) { var $slider = $this ; if ( $slider . filter ( ":animated" ) . length === 0 ) { var visibleSlides = Math . ceil ( $slider . outerWidth ( ) / $slider . find ( '.responSlider-slide' ) . outerWidth ( ) ) ; _effects [ _options . effect ] ( $slider , showNextSlide , Math . min ( _options . movingSlides , visibleSlides ) ) ; } }
function ( msg ) { var lineNumber = contents . substring ( 0 , index ) . split ( '\n' ) . length + 1 ; var line = contents . split ( '\n' ) [ lineNumber - 1 ] ; var info = "line " + lineNumber + ", file " + source_name + "\n" + line ; return new Error ( ( msg || "Parse error" ) + " - " + info ) ; }
function ( fname ) { var ext = path . extname ( fname ) , fileDir = path . dirname ( fname ) . replace ( o . inputDir , '' ) ; paths . push ( { input : fname , output : path . join ( o . outputDir , fileDir , path . basename ( fname , ext ) + o . outputExt ) } ) ; }
function ( dir , mode ) { mode = mode || '0777' ; var paths = dir . split ( '/' ) , prev = '' , cur ; for ( var i = 0 , n = paths . length ; i < n ; i += 1 ) { cur = path . join ( prev , paths [ i ] ) ; if ( ! path . existsSync ( cur ) ) { fs . mkdirSync ( cur , mode ) ; } prev = cur ; } }
function DVS_destroy ( ) { this . _scripts . removeEventListener ( "select" , this . _onScriptsChange , false ) ; this . _searchbox . removeEventListener ( "select" , this . _onScriptsSearch , false ) ; this . _searchbox . removeEventListener ( "input" , this . _onScriptsSearch , false ) ; this . _searchbox . removeEventListener ( "keyup" , this . _onScriptsKeyUp , false ) ; this . _scripts = null ; this . _searchbox = null ; }
function DVB__destroyContextMenu ( aBreakpoint ) { let commandsetId = "breakpointMenuCommands-" + aBreakpoint . id ; let menupopupId = "breakpointContextMenu-" + aBreakpoint . id ; let commandset = document . getElementById ( commandsetId ) ; let menupopup = document . getElementById ( menupopupId ) ; if ( commandset ) { commandset . parentNode . removeChild ( commandset ) ; } if ( menupopup ) { menupopup . parentNode . removeChild ( menupopup ) ; } }
function ( ) { is ( breakpointsRemoved , 3 , "Should have 3 removed breakpoints." ) ; is ( gBreakpointsElement . childNodes . length , 1 , "The breakpoints pane should be empty, but showing a " + "'no breakpoints' information message." ) ; is ( gBreakpointsElement . childNodes . length , gBreakpointsElement . querySelectorAll ( ".list-item.empty" ) . length , "Found junk in the breakpoints container." ) ; finish ( ) ; }
function ( state , formatStr , args ) { check ( aState , aState , formatStr , isString , 'printf' , 'string' , 1 , [ formatStr ] . concat ( args ) ) ; var msg = helpers . format ( formatStr , args , 'printf' ) ; state . getDisplayHook ( ) ( msg ) ; state . v = types . VOID ; }
function ( aState , num ) { check ( aState , aState , num , function ( x ) { if ( ! isInteger ( x ) ) { return false ; } var n = jsnums . toFixnum ( x ) ; return ( ( n >= 0 && n < 55296 ) || ( n > 57343 && n <= 1114111 ) ) ; } , 'int->string' , 'exact integer in [0,55295] or [57344,1114111]' , 1 ) ; aState . v = types . string ( String . fromCharCode ( jsnums . toFixnum ( num ) ) ) ; }
function ( aState , str ) { check ( aState , aState , str , isString , 'explode' , 'string' , 1 ) ; var ret = types . EMPTY ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { ret = types . cons ( types . string ( str . charAt ( i ) ) , ret ) ; } aState . v = ret ; }
function ( n , acc ) { if ( jsnums . greaterThanOrEqual ( n , num ) ) { return types . string ( acc ) ; } return CALL ( f , [ n ] , function ( res ) { check ( aState , aState , res , isChar , 'build-string' , 'procedure that returns a char' , 2 ) ; return buildStringHelp ( n + 1 , acc . push ( res . val ) ) ; } ) ; }
function ( k , b ) { check ( aState , aState , k , isNatural , 'make-bytes' , 'non-negative exact integer' , 1 , arguments ) ; check ( aState , aState , b , isByte , 'make-bytes' , 'byte' , 2 , arguments ) ; var ret = [ ] ; for ( var i = 0 ; i < jsnums . toFixnum ( k ) ; i ++ ) { ret . push ( b ) ; } return types . bytes ( ret , true ) ; }
function ( container ) { this . _line_count = 0 ; this . _line_found = false ; this . _line = 0 ; this . _tops = [ ] ; var _ele = container . querySelectorAll ( '.' + HIGHLIGHTED_LINE_CLASSNAME ) [ 0 ] ; if ( _ele ) { _ele . removeClass ( HIGHLIGHTED_LINE_CLASSNAME ) } }
function ( container , data ) { if ( ! data || ! ( data . lines && data . lines [ 0 ] ) ) return ; this . _root_ele = container . getElementsByClassName ( RESOURCE_DETAIL_CONTAINER_CLASSNAME ) [ 0 ] ; if ( this . _root_ele ) { this . clear_line_numbers ( this . _root_ele ) this . _line = parseInt ( data . lines [ 0 ] ) ; this . _traverse_ele ( this . _root_ele ) ; } }
function ( id , line ) { var data = { } ; var view = window . views . resource_detail_view ; if ( window . services [ "resource-manager" ] && view ) { if ( line ) { var data = { "lines" : [ line ] } ; } view . show_resource_for_id ( id , data ) ; } }
function ( url , scripts , node ) { scripts = DOC . getElementsByTagName ( "script" ) ; node = scripts [ scripts . length - 1 ] ; url = node . hasAttribute ? node . src : node . getAttribute ( 'src' , 4 ) ; $ [ "@name" ] = node . getAttribute ( "namespace" ) || "$" $ [ "@debug" ] = ! ! node . getAttribute ( "debug" ) ; return url . substr ( 0 , url . lastIndexOf ( '/' ) ) ; }
function ( ) { document . getElementById ( "TESTAREA" ) . style . display = "none" ; window . alert = function ( m ) { console . log ( m ) } ; Aria . loadTemplate ( { div : "TESTAREA" , classpath : "snippets.templates.templateScripts.MyTemplate" } , { fn : this . testAsyncLoadTplTwo , scope : this } ) ; }
function ( ) { document . getElementById ( "TESTAREA" ) . style . display = "none" ; Aria . loadTemplate ( { div : "TESTAREA" , classpath : "snippets.templates.widget_bindings.MyTemplate" , data : { name : "" } } , { fn : this . notifyTestEnd , scope : this } ) ; }
function ( ) { document . getElementById ( "TESTAREA" ) . style . display = "none" ; Aria . loadTemplate ( { div : "TESTAREA" , classpath : "snippets.intro.view.SgtGreeters" , data : { people : [ ] } } , { fn : this . notifyTestEnd , scope : this } ) ; }
function ( err , data ) { if ( err ) { callback ( err ) ; return ; } base = my . merge ( app , data , instance ) ; if ( ! my . validate ( base ) ) { callback ( { message : 'Instance was not valid.' , stack : JSON . stringify ( base , null , 4 ) } ) ; return ; } my . cache ( env , instance , context , base ) ; callback ( null , base ) ; }
function ( ) { $ ( "#getJSON" ) . on ( "click" , function ( ) { $ ( "#dataHolder" ) . empty ( ) ; $ . ajax ( { url : "xhr/data.json" , type : "GET" , dataType : "json" , success : function ( response ) { } } ) ; } ) ; }
function ( key , value ) { if ( key != 'skill' ) $ . each ( value , function ( key2 , value2 ) { total [ key2 ] += parseFloat ( value2 ) ; } ) ; }
function ( options ) { options = options || { } ; renderer . render ( "#rp_info" , "rp_info" , { hostname : options . hostname , siteName : options . siteName , siteLogo : options . siteLogo , privacyURL : options . privacyURL , tosURL : options . tosURL } ) ; sc . start . call ( this , options ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "relative.html" , privacyURL : "/privacy.html" } ) ; equal ( retval , "relative urls not allowed: (relative.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "relative.html" , privacyURL : "/privacy.html" } ) ; equal ( retval , "relative urls not allowed: (relative.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "relative.html<script>window.scriptRun=true;</script>" , privacyURL : "/privacy.html" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "relative.html<script>window.scriptRun=true;</script>" , privacyURL : "/privacy.html" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html" } ) ; equal ( retval , "relative urls not allowed: (relative.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html" } ) ; equal ( retval , "relative urls not allowed: (relative.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html<script>window.scriptRun=true;</script>" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html<script>window.scriptRun=true;</script>" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html<script>window.scriptRun=true;</script>" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html<script>window.scriptRun=true;</script>" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "javascript:alert(1)" } ) ; equal ( retval , "relative urls not allowed: (javascript:alert(1))" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "javascript:alert(1)" } ) ; equal ( retval , "relative urls not allowed: (javascript:alert(1))" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "httpg://testdomain.com/privacy.html" } ) ; equal ( retval , "relative urls not allowed: (httpg://testdomain.com/privacy.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "httpg://testdomain.com/privacy.html" } ) ; equal ( retval , "relative urls not allowed: (httpg://testdomain.com/privacy.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "/privacy.html" } ) ; testHelpers . testObjectValuesEqual ( startInfo , { tosURL : HTTP_TEST_DOMAIN + "/tos.html" , privacyURL : HTTP_TEST_DOMAIN + "/privacy.html" } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : HTTP_TEST_DOMAIN + "/tos.html" , privacyURL : HTTP_TEST_DOMAIN + "/privacy.html" } ) ; testHelpers . testObjectValuesEqual ( startInfo , { tosURL : HTTP_TEST_DOMAIN + "/tos.html" , privacyURL : HTTP_TEST_DOMAIN + "/privacy.html" } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : HTTPS_TEST_DOMAIN + "/tos.html" , privacyURL : HTTPS_TEST_DOMAIN + "/privacy.html" } ) ; testHelpers . testObjectValuesEqual ( startInfo , { tosURL : HTTPS_TEST_DOMAIN + "/tos.html" , privacyURL : HTTPS_TEST_DOMAIN + "/privacy.html" } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { createController ( { name : RP_NAME , privacyURL : RP_PP_URL , tosURL : RP_TOS_URL } ) ; equal ( $ ( "#rp_name" ) . text ( ) , RP_NAME , "RP's name is set" ) ; equal ( $ ( "#rp_tos" ) . attr ( "href" ) , RP_TOS_URL , "RP's TOS is set" ) ; equal ( $ ( "#rp_pp" ) . attr ( "href" ) , RP_PP_URL , "RP's Privacy Policy is set" ) ; }
function addMonument ( monument , onClick ) { var marker = new L . Marker ( new L . LatLng ( monument . lat , monument . lon ) ) ; var popup = "<div><strong>" + monument . name + "</strong></div>" ; var popupDOM = $ ( popup ) . click ( function ( ) { onClick ( monument ) ; } ) [ 0 ] ; marker . bindPopup ( popupDOM , { closeButton : false } ) ; markerGroup . addLayer ( marker ) ; }
function saveList ( ) { var saveObj = { } ; objLoop ( subs , function ( sub , name ) { saveObj [ name ] = sub . getSaveable ( ) ; } ) ; localStorage . setItem ( "YTBSP" , JSON . stringify ( saveObj ) ) ; }
function ( ) { if ( this . connected ) { if ( this . open ) { this . of ( '' ) . packet ( { type : 'disconnect' } ) ; } this . onDisconnect ( 'booted' ) ; } return this ; }
function ( err ) { if ( err && err . advice ) { if ( this . options . reconnect && err . advice === 'reconnect' && this . connected ) { this . disconnect ( ) ; this . reconnect ( ) ; } } this . publish ( 'error' , err && err . reason ? err . reason : err ) ; }
function cleanAttr ( n , v ) { if ( v . match ( /^\./ ) || v . match ( /^\// ) ) { return ; } if ( v . match ( /^(http|https):\/\// ) || v . match ( /^mailto:/ ) ) { return ; } Roo . log ( "(REMOVE)" + node . tagName + '.' + n + '=' + v ) ; node . removeAttribute ( n ) ; }
function xhr ( url , callback ) { var req = new XMLHttpRequest ( ) ; req . onreadystatechange = function ( ) { if ( req . readyState !== 4 ) { return ; } if ( ! req . status || req . status < 200 || req . status > 299 ) { return ; } req . responseText && callback ( JSON . parse ( req . responseText ) ) ; } ; req . open ( "GET" , url ) ; req . send ( null ) ; }
function loadData ( ) { if ( zoom < MIN_ZOOM ) { return ; } var nw = pixelToGeo ( centerX - width , centerY - height ) , se = pixelToGeo ( centerX + width , centerY + height ) ; xhr ( template ( url , { w : nw [ LON ] , n : nw [ LAT ] , e : se [ LON ] , s : se [ LAT ] , z : zoom } ) , onDataLoaded ) ; }
function xhr ( url , callback ) { var req = new XMLHttpRequest ( ) ; req . onreadystatechange = function ( ) { if ( req . readyState !== 4 ) { return ; } if ( ! req . status || req . status < 200 || req . status > 299 ) { return ; } req . responseText && callback ( JSON . parse ( req . responseText ) ) ; } ; req . open ( "GET" , url ) ; req . send ( null ) ; }
function loadData ( ) { if ( zoom < MIN_ZOOM ) { return ; } var nw = pixelToGeo ( centerX - width , centerY - height ) , se = pixelToGeo ( centerX + width , centerY + height ) ; xhr ( template ( url , { w : nw [ LON ] , n : nw [ LAT ] , e : se [ LON ] , s : se [ LAT ] , z : zoom } ) , onDataLoaded ) ; }
function ( data ) { test . assertEqual ( data [ 0 ] , "Kept as-is" , "Nodes with unknown id in .properties are kept 'as-is'" ) ; test . assertEqual ( data [ 1 ] , "Yes" , "HTML is translated" ) ; test . assertEqual ( data [ 2 ] , "no &lt;b&gt;HTML&lt;/b&gt; injection" , "Content from .properties is text content; HTML can't be injected." ) ; test . assertEqual ( data [ 3 ] , "Yes" , "Multiple elements with same data-l10n-id are accepted." ) ; loader . unload ( ) ; resetLocale ( ) ; test . done ( ) ; }
function ( name , fig ) { var found = false ; jQuery . each ( json . components , function ( idx , comp ) { if ( comp . name === name ) { found = true ; } } ) ; if ( ! found ) { workflow . removeFigure ( fig ) ; self . removeChild ( fig ) ; delete self . figures [ name ] ; } }
function ( ) { var id = '_smokescreen_' , el = document . getElementById ( id ) ; if ( el === null ) { el = document . createElement ( 'div' ) ; el . setAttribute ( 'id' , id ) ; el . style . cssText = 'position:fixed;top:0px;left:0px;' + 'height:100%;width:100%;' + 'background:#EEE;opacity:.4;' + 'z-index:999;display:none' ; document . body . appendChild ( el ) ; } if ( el . style . display === 'block' ) { el . style . display = 'none' ; } else { el . style . display = 'block' ; } }
function ( ) { var $select = $ ( this ) ; $select . addClass ( 'jqcombo' ) ; var $input = _inputAfter ( $select ) ; _positionInput ( $select , $input ) ; _disableTabstop ( $select ) ; _watchChanges ( $select , $input ) ; _initKeypressCounter ( $input ) ; _autocompleteInput ( $select , $input , _options . notfoundCss ) ; if ( _options . expandOnFocus ) { _expandOnFocus ( $select , $input , _options . expandSize ) ; } _selectallOnClick ( $input ) ; }
function ( arguments ) { return { uid : null , activateTimestamp : null , createTimestamp : null , expiredTimestamp : null , startTimestamp : null , deviceId : null , notificationType : null , notificationUri : null , postedBy : null , pushAddress : null , pushAddressType : null , pushType : null , regionCode : null , serviceId : null , sessionId : null , status : null , arguments : arguments } ; }
function ( ) { if ( self . db . serverConfig . isConnected ( ) && cluster . isWorker ) { self . collection . insert ( { data : self . dataLength , ts : new Date ( ) , e : self . byEvent , pid : process . pid } ) ; self . dataLength = 0 ; self . byEvent = { } ; } }
function ( ) { this . $select = $ ( '#menu_name' ) ; this . $input = $ ( '#album_name' ) ; }
function ( ) { that . $input . parents ( '.control-group' ) . attr ( 'class' , 'control-group' ) . end ( ) . val ( '' ) ; that . $input . next ( ) . text ( '' ) ; clearTimeout ( time ) ; }
function ( ) { var manager = manageTextarea ( el , { text : shouldNotBeCalled , } ) ; manager . select ( 'foobar' ) ; el . trigger ( 'blur' ) ; el . focus ( ) ; assert . equal ( el [ 0 ] . selectionStart , 0 , 'it\'s selected from the start' ) ; assert . equal ( el [ 0 ] . selectionEnd , 6 , 'it\'s selected to the end' ) ; assert . equal ( el . val ( ) , 'foobar' , 'it still has content' ) ; }
function ( ) { var lang = ( window . navigator . language || "en" ) . replace ( /-/g , "_" ) ; lang = "ru" ; if ( ! this . languages [ lang ] ) { lang = lang . replace ( /_.*$/ , "" ) ; } wot . language = this . languages [ lang ] || "en" ; wot . log ( "wot.locale.setlocale: selected " + wot . language + "\n" ) ; this . loadlocale ( function ( ) { wot . locale . ready ( true ) ; } ) ; }
function ( req , res ) { Data . update ( { id : req . params . id } , req . body , { upsert : true } ) ; }
function ( closedFile , editor ) { if ( this . annotations [ closedFile ] ) { var annotations = this . annotations [ closedFile ] ; for ( var annotation in annotations ) { this . undecorateGutterLine ( annotations [ annotation ] , editor ) ; } } }
function initGallery ( data ) { var $gallery = $ ( '#gallery' ) ; var template = $ ( '#template-mason-brick' ) . html ( ) ; $ . each ( initdata , function ( i , x ) { var h = Mustache . to_html ( template , x ) ; $gallery = $gallery . append ( h ) ; } ) ; $gallery . masonry ( 'reload' ) ; $gallery . imagesLoaded ( function ( ) { $gallery . masonry ( { itemSelector : '.item' , columnWidth : 240 } ) ; } ) ; }
function ( ) { var scrollTop = this . $scrollElement . scrollTop ( ) + this . options . offset , offsets = this . offsets , targets = this . targets , activeTarget = this . activeTarget , i for ( i = offsets . length ; i -- ; ) { activeTarget != targets [ i ] && scrollTop >= offsets [ i ] && ( ! offsets [ i + 1 ] || scrollTop <= offsets [ i + 1 ] ) && this . activate ( targets [ i ] ) } }
function ( b ) { return function ( ctx ) { var bi = b ( this . $ ) ; DU . qDraw ( ctx , bi . s , bi . f , function ( ) { ctx . arc ( 0 , 0 , radius , 0 , Math . PI * 2 , true ) ; } ) ; } }
function ( ) { var clone = new Element ( ) ; clone . name = this . name ; clone . children = this . children . slice ( 0 ) ; clone . sprite = this . sprite ; clone . _modifiers = this . _modifiers . slice ( 0 ) ; clone . _painters = this . _painters . slice ( 0 ) ; clone . xdata = obj_clone ( this . xdata ) ; clone . xdata . $ = clone ; return clone ; }
function ( r ) { if ( this . _failure ) { if ( r . error ) { this . _failure . call ( this . _context , r . error ) ; } else { this . _success . apply ( this . _context , arguments ) ; } } else { this . _success . apply ( this . _context , arguments ) ; } }
function ( coords ) { var r = 0 ; if ( ! coords || coords . col >= self . colCount ) { for ( ; r < self . rowCount ; r ++ ) { datamap . data [ r ] . push ( '' ) ; } } else { for ( ; r < self . rowCount ; r ++ ) { datamap . data [ r ] . splice ( coords . col , 0 , '' ) ; } } }
function ( ) { var tag = $ ( this ) . find ( 'tag' ) . text ( ) ; var content = $ ( this ) . find ( 'content' ) . text ( ) ; $ ( 'a#' + tag ) . click ( function ( ) { $ ( '#content' ) . hide ( ) ; $ ( '#content' ) . html ( content ) ; $ ( '#content' ) . fadeIn ( 1500 ) ; } ) ; }
function handleKeyEvent ( editor , event ) { if ( editor . getModeForSelection ( ) !== "html" ) { return ; } if ( event . type === "keydown" && event . keyCode === 32 && event . ctrlKey ) { _showHint ( editor ) ; event . preventDefault ( ) ; } if ( hintList && hintList . isOpen ( ) ) { hintList . handleKeyEvent ( editor , event ) ; } }
function accept_game_invitation ( player_id ) { console . log ( 'POST for ' + player_id ) ; $ . ajax ( { type : 'PUT' , url : 'players/' + player_id , data : JSON . stringify ( { 'player' : { 'accepted' : true } } ) , contentType : 'application/json' , dataType : "json" , success : function ( data ) { console . log ( 'PUT player update' ) ; console . log ( data ) ; } } ) ; }
function ( target , reader ) { var q = gf . sim . Variable . Quaternion . tmp_ ; if ( this . normalized_ ) { reader . readVec3 ( q ) ; q [ 3 ] = Math . sqrt ( 1 - q [ 0 ] * q [ 0 ] + q [ 1 ] * q [ 1 ] + q [ 2 ] * q [ 2 ] ) ; } else { reader . readVec4 ( q ) ; } this . setter_ . call ( target , q ) ; }
function ( comp , name ) { var cb_name = this . extractAPI ( comp , 'get' , name ) ; return this . getters [ cb_name ] ( comp ) ; }
function ( cb_name , cb ) { this . getters [ cb_name ] = cb ; return true ; }
function showRegistrationInfo ( info ) { dom . setInner ( "#email" , info . email ) ; if ( info . returnTo ) { dom . setInner ( ".website" , info . returnTo ) ; updateRedirectTimeout ( ) ; dom . show ( ".siteinfo" ) ; } }
function ( options ) { var self = this ; self . checkRequired ( options , "token" , "verifyFunction" ) ; token = options . token ; verifyFunction = options . verifyFunction ; doc = options . document || document ; redirectTimeout = options . redirectTimeout ; if ( typeof redirectTimeout === "undefined" ) { redirectTimeout = REDIRECT_SECONDS * 1000 ; } startVerification . call ( self , options . ready ) ; sc . start . call ( self , options ) ; }
function createController ( options , callback ) { controller = BrowserID . verifySecondaryAddress . create ( ) ; options = options || { } ; options . document = doc = new WindowMock ( ) . document ; options . redirectTimeout = 0 ; options . ready = callback ; controller . start ( options ) ; }
function ( path , status ) { path = path . indexOf ( '://' ) ? path : ( this . req . encrypted ? 'https://' : 'http://' ) + this . req . headers . host + this . req . url ; this . res . writeHead ( status || 302 , { 'Location' : path } ) ; this . res . end ( ) ; }
function ( ) { configPath = path . resolve ( "test/config-bare-minimum.xml" ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . content ) . toEqual ( "local:///startPage.html" ) ; expect ( configObj . version ) . toEqual ( "1.0.0" ) ; } ) ; }
function ( ) { configPath = path . resolve ( "test/config-license.xml" ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . license ) . toEqual ( "" ) ; expect ( configObj . licenseURL ) . toEqual ( "http://www.apache.org/licenses/LICENSE-2.0" ) ; } ) ; }
function ( options ) { var self = this ; self . subscribe ( "xhr_start" , dom . addClass . curry ( "body" , "submit_disabled" ) ) ; self . subscribe ( "xhr_complete" , dom . removeClass . curry ( "body" , "submit_disabled" ) ) ; sc . start . call ( self , options ) ; }
function ( ) { var body = $ ( "body" ) ; mediator . publish ( "xhr_start" ) ; equal ( body . hasClass ( "submit_disabled" ) , true , "xhr_start adds submit_disabled" ) ; mediator . publish ( "xhr_complete" ) ; equal ( body . hasClass ( "submit_disabled" ) , false , "xhr_complete removes submit_disabled" ) ; }
function ( ) { Startup . getResourceUuid ( ) ; Ext . create ( 'Ext.Container' , { id : 'mainView' , fullscreen : true , layout : 'card' , items : [ { xclass : 'RaxaEmr.view.Login' } , { xclass : 'RaxaEmr.view.AppGrid' } , { xclass : 'RaxaEmr.view.AppCarousel' } ] } ) ; }
function _updateTargetWindowHeight ( ) { var height ; if ( IMERender . ime . dataset . hidden ) { height = 0 ; } else { height = IMERender . ime . scrollHeight ; } if ( _lastHeight === height ) return ; _lastHeight = height ; var message = { action : 'updateHeight' , keyboardHeight : height , hidden : ! ! IMERender . ime . dataset . hidden } ; parent . postMessage ( JSON . stringify ( message ) , '*' ) ; }
function _init ( ) { IMERender . init ( ) ; for ( var event in _imeEvents ) { var callback = _imeEvents [ event ] || null ; if ( callback ) IMERender . ime . addEventListener ( event , callback . bind ( this ) ) ; } }
function _uninit ( ) { for ( event in _imeEvents ) { var callback = _imeEvents [ event ] || null ; if ( callback ) IMERender . ime . removeEventListener ( event , callback . bind ( this ) ) ; } for ( var engine in this . IMEngines ) { if ( this . IMEngines [ engine ] . uninit ) this . IMEngines [ engine ] . uninit ( ) ; delete this . IMEngines [ engine ] ; } }
function ( Backbone , Activity ) { var Activities = Backbone . Collection . extend ( { initialize : function ( ) { this . bind ( 'error' , function ( model , error ) { } ) ; model : Activity ; } , } ) ; return Activities ; }
function ( ) { var panes ; this . wrap . find ( '.padding' ) . append ( this . content ) ; this . wrap . css ( { display : "block" , position : "absolute" , "min-height" : 118 } ) ; panes = this . getPanes ( ) ; panes . overlayMouseTarget . appendChild ( this . wrap [ 0 ] ) ; this . iWidth = this . wrap . outerWidth ( ) ; this . iHeight = this . wrap . outerHeight ( ) ; return this . bindButton ( ) ; }
function ( ) { this . wrap . find ( '.edit' ) . bind ( 'click' , this . toggleEditMod ) ; return this . wrap . find ( 'button' ) . bind ( 'click' , this . handleSave ) ; }
function ( e ) { var handles = this . _eventHandles ; if ( handles . dataChange ) { handles . dataChange . detach ( ) ; this . bindUI ( ) ; } if ( this . tbodyNode ) { this . render ( ) ; } }
function ( direction , speed ) { this . _setFriction ( Settings . PLAYER_MOTION_FRICTION ) ; this . _body . SetAwake ( true ) ; var vector = new Box2D . Common . Math . b2Vec2 ( speed * direction , this . _body . GetLinearVelocity ( ) . y ) ; this . _body . SetLinearVelocity ( vector ) ; }
function ( ) { this . _body . SetAwake ( true ) ; var vector = new Box2D . Common . Math . b2Vec2 ( 0 , - Settings . JUMP_SPEED ) ; this . _body . ApplyImpulse ( vector , this . _body . GetPosition ( ) ) ; }
function ( command , options ) { switch ( command ) { case 'joinSuccess' : this . onJoinSuccess ( options ) ; break ; case 'gameCommand' : for ( var c in options ) { this . clientGame . processGameCommand ( c , options [ c ] ) ; } break ; case 'userJoined' : this . onUserJoined ( options ) ; break ; default : break ; } }
function ( ) { this . $el . isotope ( "insert" , this . createPostView ( post ) . render ( ) . $el ) }
function ( ) { $ ( '#adduser-username' ) . val ( '' ) ; $ ( '#adduser-password' ) . val ( '' ) ; $ ( '#dialog-mask' ) . hide ( ) ; $ ( '#adduser-dialog' ) . hide ( ) ; }
function ( test ) { test . expect ( 3 ) ; rpcClient . invoke ( "quiet" , function ( error , res , more ) { test . equal ( error . name , "TimeoutExpired" ) ; test . equal ( res , null ) ; test . equal ( more , false ) ; test . done ( ) ; } ) ; }
function ( res ) { var link = $this . prev ( 'a' ) ; link . attr ( 'href' , link . attr ( 'href' ) . slice ( 0 , - 1 ) + data . status ) . text ( $this . find ( ':selected' ) . text ( ) ) ; }
function createHTMLforDists ( ) { for ( i = 0 ; i < clDistrib . length ; i ++ ) { datagraphs = document . getElementById ( "datagraphs" ) ; datagraphs . innerHTML += "\         <div class=\"block\" id=\"" + clDistrib [ i ] . blockDivID + "\"> \         <table id=\"plot-table-a\"> \         <tr> \         <td> \             <div id=\"" + clDistrib [ i ] . dataDivID + "\" class=\"myPlotData\"> \             <canvas id=\"" + clDistrib [ i ] . canvasID + "\" width=\"420\" height=\"100\"> \             no support for canvas</canvas> \             </div> \         </td> \         <td> \             <div id=\"" + clDistrib [ i ] . labelDivID + "\" class=\"draghandle\"><b> \             (" + i + ") Newly learnt clause size distribution. \             Bottom: unitary clause. Top: largest clause. \             Black: Many learnt. White: None learnt. \             Horizontal resolution: 1000 conflicts. \             Vertical resolution: 1 literal \             </b></div> \         </td> \         </tr> \         </table> \         </div>" ; } }
function forEachField ( fields , wholeRows , func ) { var prefix = ( wholeRows ? "#id_" : "." ) ; for ( var id in fields ) { for ( var field in fields [ id ] ) { func ( $ ( prefix + fields [ id ] [ field ] ) ) ; } } }
function ( i ) { var repoType = origRepoTypes [ i ] ; if ( newRepoTypes . length == 0 || $ . inArray ( repoType . text , newRepoTypes ) !== - 1 ) { $ ( "<option/>" ) . text ( repoType . text ) . val ( repoType . value ) . appendTo ( repoTypesEl ) ; if ( repoType . value == currentRepoType ) { repoTypesEl [ 0 ] . value = currentRepoType ; } } }
function ( ) { var checked = this . checked ; bugTrackerTypeEl [ 0 ] . disabled = checked ; forEachField ( BUG_TRACKER_FIELDS , true , function ( el ) { el [ 0 ] . disabled = checked ; } ) ; }
function ( ) { updateFormDisplay ( "hosting_type" , HOSTING_SERVICE_FIELDS ) ; updateRepositoryType ( ) ; var hostingType = hostingTypeEl [ 0 ] . value ; if ( hostingType == "custom" || BUG_TRACKER_FIELDS [ hostingType ] == undefined ) { bugTrackerUseHostingEl [ 0 ] . disabled = true ; bugTrackerUseHostingEl [ 0 ] . checked = false ; bugTrackerUseHostingEl . triggerHandler ( "change" ) ; } else { bugTrackerUseHostingEl [ 0 ] . disabled = false ; } }
function ( ) { updateFormDisplay ( "tool" , TOOLS_FIELDS , HOSTING_SERVICE_HIDDEN_FIELDS [ hostingTypeEl [ 0 ] . value ] ) ; }
function processTags ( keyLine ) { var tags = [ ] , tag ; while ( ( tag = tagRe . exec ( keyLine ) ) ) { tags . push ( tag [ 1 ] ) ; } return tags ; }
function ( ) { temporaryDatabase = utils . createTemporaryDatabase ( ) ; database = temporaryDatabase . get ( ) ; utils . loadDumpFile ( database , __dirname + '/fixture/companies/ddl.grn' ) ; utils . loadDumpFile ( database , __dirname + '/fixture/companies/data.grn' ) ; server = utils . setupServer ( database ) ; }
function ( key ) { var that = this ; that . create ( function ( ) { that . db . discard ( key , function ( ) { } , function ( ) { } ) ; } ) ; }
function Controller ( ) { if ( instance !== undefined ) { return instance ; } BaseController . apply ( this , arguments ) ; if ( this [ 'initialize' ] !== undefined ) { this [ 'initialize' ] . apply ( this , arguments ) ; } instance = this ; return instance ; }
function ( evt ) { var coords = this . coordsForEvent ( evt ) , point = this . _graphView . pointForCoordinates ( coords . x , coords . y ) ; return this . _graphController . inputAreaMouseDragged ( point . x , point . y ) ; }
function ( evt ) { var coords = this . coordsForEvent ( evt ) , point = this . _graphView . pointForCoordinates ( coords . x , coords . y ) ; return this . _graphController . inputAreaMouseUp ( point . x , point . y ) ; }
function ( evt ) { var coords = this . coordsForEvent ( evt ) , point = this . _graphView . pointForCoordinates ( coords . x , coords . y ) ; return this . _graphController . inputAreaMouseUp ( point . x , point . y ) ; }
function ( ) { var userFolder = getUserFolder ( ) ; this . storage = ( userFolder !== null ) ? ( path . resolve ( userFolder + '/' + modulePackageName ) + '/' ) : null ; this . local = moduleRoot ; this . global = webinosRoot ; }
function ( ) { app . use ( express . static ( __dirname + '/webapp' ) ) ; app . use ( connectLess ( { src : __dirname + '/webapp/' } ) ) ; app . use ( express . static ( __dirname + '/test' ) ) ; app . use ( express . errorHandler ( { dumpExceptions : true , showStack : true } ) ) ; }
function ( tab ) { if ( id instanceof MessagePort && tab . port == id || typeof id == 'number' && tab . id == id ) { targets . push ( { tab : tab , startUrl : tab . url , callback : callback } ) ; startTimer ( ) ; return true ; } }
function ( file , callback ) { var tab = opera . extension . tabs . create ( { url : location . href . replace ( /\/[^\/]*$/ , '/' ) + file , focused : true } ) ; emit ( callback , tab . id , tab . url ) ; }
function ( id ) { if ( typeof id . activate == 'function' ) { id . activate ( ) ; } else { getTabId ( id , function ( worker ) { worker . activate ( ) ; } ) ; } }
function ( ) { return new XMLHttpRequest ; }
function response ( data , tabId , operation ) { if ( isAuthorized ( ) ) { if ( ! tabId || ! operation ) return ; data . type = 'fileio-' + operation + '-response' ; extension . sendRequest ( tabId , data ) ; } else { if ( operationQueue . length == 0 ) return ; data . type = 'authorize-response' ; extension . sendRequest ( operationQueue [ 0 ] . tabId , data ) ; } }
function Geometry ( o , val ) { console . log ( o ) console . log ( val ) var split = val . split ( "x" ) ; o . size = { width : parseInt ( split [ 0 ] , 10 ) , height : parseInt ( split [ 1 ] , 10 ) } }
function ( ) { _ . bindAll ( this ) ; this . header = new views . Header ( { model : this . model } ) ; $ ( window ) . on ( 'scroll' , function ( ) { if ( $ ( window ) . scrollTop ( ) > 60 ) { $ ( '#post' ) . addClass ( 'sticky-menu' ) ; } else { $ ( '#post' ) . removeClass ( 'sticky-menu' ) ; } } ) ; }
function ( ) { this . editor . refresh ( ) ; if ( this . metadataEditor ) this . metadataEditor . refresh ( ) ; }
function ( ) { var argString = "This is a string we'll send into and back from the dialog: " + ( new Date ( ) ) . toString ( ) ; WinChan . open ( { url : "cases/basic/child.html" , relay_url : "/relay.html" , window_features : "width=700,height=375" , params : argString } , function ( err , resp ) { equal ( resp , argString ) ; start ( ) ; } ) ; }
function ( i ) { var thisLi = $ ( '<li><span class="label">' + this + '</span></li>' ) . prepend ( '<span class="line" />' ) . css ( 'left' , xInterval * i ) . width ( xInterval ) . appendTo ( xlabelsUL ) ; if ( horizontal ) { var label = thisLi . find ( 'span.label' ) ; label . css ( "margin-left" , - label . width ( ) / 2 ) ; } }
function resolve ( mdl , caller__dirname ) { if ( mdl . match ( /^(\.|\/)/ ) ) { if ( ! caller__dirname ) throw new ProxyquireError ( 'In order to resolve relative modules, caller__dirname is required' ) ; return path . join ( caller__dirname , mdl ) ; } else { return mdl ; } }
function ( ) { beforeEach ( function init ( ) { foo = proxyquire . require ( './samples/foo-without-require-override' ) ; } ) ; it ( 'drinkUp returns stub' , function ( ) { foo . gotoBar ( ) . should . eql ( 'keep it up' ) ; } ) it ( 'drinksOnMe returns stub' , function ( ) { foo . throwRound ( ) . should . eql ( 'you wish' ) ; } ) }
function ( ) { it ( 'throws an error explaining how to correct the problem' , function ( ) { ( function ( ) { proxyquire . setup ( ) ; } ) . should . throw ( /top level/i ) ; } ) }
function ( ) { this . options . stacked = ! this . options . stacked setStacked ( this . chart , this . options . stacked ) }
function contextMenuCopyLinkOrEmail ( ) { if ( ! gContextMenu . triggerNode ) return ; var href = gContextMenu . triggerNode . href ; var clipboard = Cc [ '@mozilla.org/widget/clipboardhelper;1' ] . getService ( Ci . nsIClipboardHelper ) ; clipboard . copyString ( href . substring ( href . indexOf ( ':' ) + 1 ) ) ; }
function createTokenId ( ) { var key = createKey ( ) , offset = parseInt ( Math . random ( ) * ( key . length - 5 ) ) ; return key . substring ( offset , offset + 5 ) ; }
function ( data ) { if ( tokens [ sockets [ socket . id ] . tokenId ] ) { delete tokens [ sockets [ socket . id ] . tokenId ] ; } var tokenId = createTokenId ( ) ; sockets [ socket . id ] . tokenId = tokenId ; tokens [ tokenId ] = { timeStamp : new Date ( ) . getTime ( ) , receiverId : socket . id } ; socket . emit ( 'rcjs:token' , { tokenId : tokenId } ) ; }
function ( name , value ) { var names = name . split ( d3_selection_classedWhitespace ) , n = names . length , i = - 1 ; if ( arguments . length > 1 ) { while ( ++ i < n ) d3_selection_classed . call ( this , names [ i ] , value ) ; return this ; } else { while ( ++ i < n ) if ( ! d3_selection_classed . call ( this , names [ i ] ) ) return false ; return true ; } }
function ( key , val ) { var item = function ( val ) { this . value = val ; this . timeStamp = new Date ( ) . getTime ( ) ; } if ( entries [ key ] === undefined ) { count ++ ; } var theItem = new item ( val ) ; entries [ key ] = theItem ; timeStampMap [ theItem . timeStamp ] = key ; var currCacheSize = _getCacheSize ( ) ; if ( _getCacheSize ( ) > size ) { _evict ( ) ; } }
function ( CubeViz_Parameters ) { console . log ( CubeViz_Parameters ) ; this . CubeViz_Parameters = CubeViz_Parameters ; this . modelUrl = CubeViz_Parameters . modelUrl ; this . cubevizPath = CubeViz_Parameters . cubevizPath ; this . dimensions = CubeViz_Parameters . selectedDimensions ; this . measures = CubeViz_Parameters . selectedMeasures ; }
function ( linkCode ) { var action = "getresultobservations" ; $ . getJSON ( this . cubevizPath + action + "/" , "m=" + this . modelUrl + "&lC=" + linkCode , $ . proxy ( function ( json ) { this . retrievedResultObservations = json ; $ ( body ) . trigger ( "AjaxResultObservationsRetrieved.CubeViz" ) ; } , this ) ) ; }
function ( ) { var observations = [ ] ; var observation_current = null ; for ( observation in this . retrievedResultObservations ) { observation_current = this . retrievedResultObservations [ observation ] ; } console . log ( this . retrievedResultObservations ) ; console . log ( this . dimensions ) ; }
function ( err , widget ) { if ( err ) return res . send ( err ) ; if ( ! widget ) return res . send ( 404 ) ; var args = req . body ; args . push ( function ( resp ) { res . json ( resp ) ; } ) ; widget . getRemoteHandlers ( ) [ req . params . cmd ] . apply ( null , args ) ; }
function ( config ) { this . parentView = config . parentView ; this . bankId = config . bankId ; this . w = config . w || 200 ; this . h = config . h || 100 ; this . size = 200 ; this . duration = 500 ; this . fetchData ( ) ; }
function ( event ) { event . preventDefault ( ) ; var toDate = this . $el . find ( '#dp3 input' ) . val ( ) ; var fromDate = this . $el . find ( '#dp4 input' ) . val ( ) ; toDate = moment ( toDate ) . format ( 'YYYY-MM-DD' ) ; fromDate = moment ( fromDate ) . format ( 'YYYY-MM-DD' ) ; this . fetchData ( toDate , fromDate ) ; }
function ( ) { $ ( this . el ) . html ( this . template ( { bankId : this . bankId , model : this . model } ) ) ; return this ; }
function ( pressShiftKey , currentPos , limitPos ) { var shiftValueTemplate = thin . editor . Action . ShiftValue ; var shiftValue = pressShiftKey ? shiftValueTemplate . PRESSSHIFTKEY : shiftValueTemplate . NORMAL ; if ( limitPos > ( currentPos - shiftValue ) ) { shiftValue = currentPos - limitPos ; } else { shiftValue += currentPos % 1 ; } return thin . numberWithPrecision ( shiftValue ) ; }
function ( offset , line , column , all ) { var raw = all [ 0 ] . raw + all [ 1 ] + all [ 2 ] + "=" + all [ 4 ] + all [ 5 ] . raw ; return new Nodes . CompoundAssignOp ( constructorLookup [ all [ 2 ] ] , all [ 0 ] , all [ 5 ] ) . r ( raw ) . p ( line , column ) ; }
function ( offset , line , column , left , right ) { if ( ! right ) return left ; var raw = left . raw + right [ 0 ] + right [ 1 ] + right [ 3 ] + right [ 4 ] + right [ 5 ] . raw ; return new Nodes . LogicalOrOp ( left , right [ 5 ] ) . r ( raw ) . p ( line , column ) ; }
function ( offset , line , column , left , right ) { if ( ! right ) return left ; var raw = left . raw + right [ 0 ] + right [ 1 ] + right [ 3 ] + right [ 4 ] + right [ 5 ] . raw ; return new Nodes . LogicalOrOp ( left , right [ 5 ] ) . r ( raw ) . p ( line , column ) ; }
function ( offset , line , column , left , right ) { if ( ! right ) return left ; var raw = left . raw + right [ 0 ] + right [ 1 ] + right [ 2 ] + right [ 3 ] . raw ; return new constructorLookup [ right [ 1 ] ] ( left , right [ 3 ] ) . r ( raw ) . p ( line , column ) ; }
function ( offset , line , column , left , right ) { if ( ! right ) return left ; var op = constructorLookup [ right [ 1 ] ] , raw = left . raw + right [ 0 ] + right [ 1 ] + right [ 2 ] + right [ 3 ] . raw ; return new op ( left , right [ 3 ] ) . r ( raw ) . p ( line , column ) ; }
function ( offset , line , column , left , right ) { if ( ! right ) return left ; var op = constructorLookup [ right [ 1 ] ] , raw = left . raw + right [ 0 ] + right [ 1 ] + right [ 2 ] + right [ 3 ] . raw ; return new op ( left , right [ 3 ] ) . r ( raw ) . p ( line , column ) ; }
function ( dataProvider ) { var allKeys , catKey = this . get ( "categoryKey" ) , keys = [ ] , i ; if ( this . _seriesKeys ) { return this . _seriesKeys ; } allKeys = this . _getAllKeys ( dataProvider ) ; for ( i in allKeys ) { if ( allKeys . hasOwnProperty ( i ) && i != catKey ) { keys . push ( i ) ; } } return keys ; }
function ( ) { log . info ( 'Transport Down' , this . logAuthor ) ; if ( this . connected && global . notify ) global . notify . notify ( _ ( 'Error' ) , _ ( 'Disconnected from websocket.' ) , 'error' ) ; this . fireEvent ( 'transport_down' , this ) ; }
function showMapDirectPopup ( ) { if ( typeof mapDirect != 'undefined' ) { if ( markerFeatures [ mapDirect ] . popup == null ) fillPopup ( markerFeatures [ mapDirect ] ) ; showPopup ( markerFeatures [ mapDirect ] . popup ) mapDirect = undefined ; } }
function ( ) { var str = this . model . visual . $el . find ( '#zedit-target' ) . html ( ) ; this . model . update ( { content : str } ) ; }
function ( ) { var html = '<div class="btn-group">' + '<a class="btn dropdown-toggle" data-toggle="dropdown" href="#">Fonts' + '<span class="caret"></span>' + '</a>' + '<ul class="dropdown-menu font-list">' + '<li style="font-family:\'Arial\'"><a href="#" data-font-family="Arial">Arial</a></li>' + '<li style="font-family:\'Georgia\'"><a href="#" data-font-family="Georgia">Georgia</a></li>' + '<li style="font-family:\'Verdana\'"><a href="#" data-font-family="Verdana">Verdana</a></li>' + '<li style="font-family:\'Sorts Mill Goudy\'"><a href="#" data-font-family="Sorts Mill Goudy">Sorts Mill Goudy</a></li>' + '<li style="font-family:\'Poiret One\'"><a href="#" data-font-family="Poiret One">Poiret One</a></li>' + '<li style="font-family:\'Trocchi\'"><a href="#" data-font-family="Trocchi">Trocchi</a></li>' + '<li style="font-family:\'Pontano Sans\'"><a href="#" data-font-family="Pontano Sans">Pontano Sans</a></li>' + '</ul>' + '</div>' ; return html ; }
function pushState ( that ) { var breadcrumb = getNewBreadcrumb ( that ) ; options = { 'url' : window . location . pathname } ; window . History . pushState ( { 'breadcrumb' : breadcrumb . html ( ) } , $ ( that ) . attr ( 'title' ) , $ ( that ) . attr ( 'href' ) ) ; }
function ( ) { this . _computeNearFar = true ; this . _nearFarRatio = 0.0005 ; var lookVector = [ 0.0 , 0.0 , - 1.0 ] ; this . bbCornerFar = ( lookVector [ 0 ] >= 0 ? 1 : 0 ) | ( lookVector [ 1 ] >= 0 ? 2 : 0 ) | ( lookVector [ 2 ] >= 0 ? 4 : 0 ) ; this . bbCornerNear = ( ~ this . bbCornerFar ) & 7 ; }
function ( node ) { var stateset = node . getStateSet ( ) ; if ( stateset ) { this . pushStateSet ( stateset ) ; } if ( node . light ) { this . addPositionedAttribute ( node . light ) ; } if ( node . traverse ) { this . traverse ( node ) ; } if ( stateset ) { this . popStateSet ( ) ; } }
function ( node ) { var stateset = node . getStateSet ( ) ; if ( stateset ) { this . pushStateSet ( stateset ) ; } var light = node . getLight ( ) ; if ( light ) { this . addPositionedAttribute ( light ) ; } this . traverse ( node ) ; if ( stateset ) { this . popStateSet ( ) ; } }
function ( ) { osg . Object . call ( this ) ; this . children = [ ] ; this . parents = [ ] ; this . nodeMask = ~ 0 ; this . boundingSphere = new osg . BoundingSphere ( ) ; this . boundingSphereComputed = false ; this . _updateCallbacks = [ ] ; }
function ( map ) { this . _map = map ; if ( ! this . _image ) { this . _initImage ( ) ; } map . _panes . overlayPane . appendChild ( this . _image ) ; map . on ( 'viewreset' , this . _reset , this ) ; if ( map . options . zoomAnimation ) { map . on ( 'zoomanim' , this . _animateZoom , this ) ; } this . _reset ( ) ; }
function ( ) { forth . contexts . push ( this ) ; forth . stackTrace . push ( this . word . name ) ; }
function ( goInside ) { if ( forth . contexts [ forth . contexts . length - 1 ] != this ) throw 'bug: step() on a non-topmost context' ; if ( this . ip < this . code . length ) { this . ip = forth . stepCode ( this . ip , this . code , this . word , goInside ) ; forth . terminal . echo ( this . word . name + ' ip=' + this . ip ) ; } else { this . end ( ) ; } }
function ( ) { if ( dropDown . isOpened ( ) ) dropDown . closeUp ( ) ; else { dropDown . dropDown ( ) ; if ( ! dropDown . _cachingAllowed ) dropDown . _clearSuggestions ( ) ; dropDown . _checkAdditionalPageNeeded ( ! dropDown . _cachingAllowed ) ; } if ( ! dropDown . _ddf_focused ) { if ( dropDown . _field . value != dropDown . _promptText ) { dropDown . focus ( ) ; } } else { dropDown . _reacquireFocus = true ; } }
function ( str ) { var indent = this . bucket . options . indent ; if ( ! indent ) { return str ; } return str . replace ( /\n/g , "\n" + indent ) ; }
function ( ) { this . opts . element . data ( "select2-change-triggered" , true ) ; this . opts . element . trigger ( "change" ) ; this . opts . element . data ( "select2-change-triggered" , false ) ; }
function ( data ) { this . addSelectedChoice ( data ) ; if ( this . select ) { this . postprocessResults ( ) ; } if ( this . opts . closeOnSelect ) { this . close ( ) ; this . search . width ( 10 ) ; } else { this . search . width ( 10 ) ; this . resizeSearch ( ) ; } this . triggerChange ( ) ; this . focusSearch ( ) ; }
function ( node ) { var inNode = node . hasOwnProperty . bind ( node ) ; return typeof node === 'object' && Seraph . nodeFlags . every ( inNode ) && typeof node . data === 'object' ; }
function ( rel ) { var inRelationship = rel . hasOwnProperty . bind ( rel ) ; return typeof rel === 'object' && Seraph . relationshipFlags . every ( inRelationship ) && typeof rel . data === 'object' ; }
function ( b ) { return function ( ctx ) { var bi = b ( this . $ ) ; DU . qDraw ( ctx , bi . s , bi . f , function ( ) { ctx . arc ( 0 , 0 , radius , 0 , Math . PI * 2 , true ) ; } ) ; } }
function ( ) { var clone = new Element ( ) ; clone . name = this . name ; clone . children = this . children . slice ( 0 ) ; clone . sprite = this . sprite ; clone . _modifiers = this . _modifiers . slice ( 0 ) ; clone . _painters = this . _painters . slice ( 0 ) ; clone . xdata = obj_clone ( this . xdata ) ; clone . xdata . $ = clone ; return clone ; }
function import_data ( selection , import_date ) { $ . ajax ( { type : "GET" , url : "/contacts/imports/get_import_data" , data : { "created_at" : import_date , "filter" : selection } , success : function ( html ) { $ ( '#import_contacts' ) . html ( html ) ; } } ) ; }
function ( ) { var data = $ ( this ) . data ( ) ; var path = data . title . split ( "/" ) ; var url = github_url + data . date + "-" + path [ path . length - 1 ] + ".md" ; window . location = url ; return false ; }
function ( e , el ) { var task ; return task = model . at ( $ ( el ) . parents ( 'li' ) [ 0 ] ) ; }
function ( context , data ) { if ( ! data || ( typeof data == 'object' && Object . keys ( data ) . length <= 0 ) ) return logger . notice ( "No data to send!" ) ; this . gathered_data . push ( data ) ; hooks . trigger ( 'data' , context , data ) ; }
function ( ) { var db = self . _openreq . result ; if ( db . objectStoreNames . contains ( self . STORENAME ) ) db . deleteObjectStore ( self . STORENAME ) ; db . createObjectStore ( self . STORENAME , { keyPath : 'date' } ) ; }
function ( ) { this . _super ( ) ; this . _ignoreAnchorPointForPosition = true ; var director = cc . Director . sharedDirector ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . setContentSize ( director . getWinSize ( ) ) ; }
function ( dt ) { this . unschedule ( this . _setNewScene ) ; var director = cc . Director . sharedDirector ( ) ; this . _isSendCleanupToScene = director . isSendCleanupToScene ( ) ; director . replaceScene ( this . _inScene ) ; cc . TouchDispatcher . sharedDispatcher ( ) . setDispatchEvents ( true ) ; this . _outScene . setVisible ( true ) ; }
function ( jsonData , comment , fullClosingTags ) { var cslXml = '<?xml version="1.0" encoding="utf-8"?>\n' ; if ( typeof ( comment ) === "string" ) { cslXml += "<!-- " + comment + " -->\n" ; } cslXml += xmlNodeFromJson ( jsonData , 0 , fullClosingTags ) ; return cslXml ; }
function ( ) { var inputval = $ ( this ) . parent ( ) . next ( ) . val ( ) ; var name = $ ( this ) . closest ( ".remote_setting" ) . attr ( "id" ) . split ( "remote_settings_" ) [ 1 ] ; if ( inputval ) { socket . send ( "request=add_filter&name=" + name + "&restring=" + inputval ) ; } }
function navigate_tab ( elem ) { window . location . replace ( window . location ) ; }
function ( entry ) { var data = cls . ResourceManager [ "1.2" ] . UrlLoad . URLType . DATA ; return ( [ "tbody" , this . _wrap_col_or_row ( [ "p" , entry . urltype === data ? ui_strings . S_NETWORK_NOT_REQUESTED : ui_strings . S_NETWORK_SERVED_FROM_CACHE ] ) ] ) ; }
function generateIndex ( base , files ) { var head = base . copy ( ) . find ( ) . only ( ) . elem ( 'head' ) . toValue ( ) ; head . find ( ) . only ( ) . elem ( 'title' ) . toValue ( ) . setContent ( 'Mocha Tests - all' ) ; Object . keys ( files ) . forEach ( function ( relative ) { head . append ( '<script src="/test' + relative + '"></script>' ) ; } ) ; return document . content ; }
function generateTest ( base , file ) { var head = base . copy ( ) . find ( ) . only ( ) . elem ( 'head' ) . toValue ( ) ; head . find ( ) . only ( ) . elem ( 'title' ) . toValue ( ) . setContent ( 'Mocha Tests - ' + file ) ; head . append ( '<script src="/test' + file + '"></script>' ) ; return document . content ; }
function ( object , property ) { var value ; if ( ! object ) { return null ; } value = object [ property ] ; if ( _ . isFunction ( value ) ) { return value . call ( object ) ; } else { return value ; } }
function ( info ) { if ( info . type === "primary" ) { createPrimaryUser . call ( self , info , oncomplete ) ; } else { enterPasswordState . call ( self , info ) ; oncomplete && oncomplete ( ! isRegistered ) ; } }
function ( ) { doc . location . href = redirectTo ; complete ( oncomplete , verified ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { testEmail ( ) ; ok ( $ ( ".siteinfo" ) . is ( ":visible" ) , "siteinfo is visible when we say what it is" ) ; equal ( $ ( ".website:nth(0)" ) . text ( ) , returnTo , "website is updated" ) ; testHasClass ( "body" , "complete" ) ; equal ( doc . location . href , returnTo , "redirection occurred to correct URL" ) ; equal ( storage . getLoggedIn ( "https://test.domain" ) , "testuser@testuser.com" , "logged in status set" ) ; start ( ) ; }
function startService ( name , options ) { if ( runningService ) { serviceManager . stop ( runningService ) ; } var module = serviceManager . start ( name , options ) ; if ( module ) { runningService = name ; } mediator . publish ( "service" , { name : name } ) ; bid . resize ( ) ; return module ; }
function ( options ) { var self = this , templateData = helpers . extend ( { } , options , { privacy_url : options . privacyURL || null , tos_url : options . tosURL || null } ) ; self . renderDialog ( "add_email" , templateData ) ; self . click ( "#cancel" , cancelAddEmail ) ; Module . sc . start . call ( self , options ) ; }
function onAddressInfo ( info ) { addressInfo = info ; if ( info . type === "primary" ) { self . close ( "primary_user" , info , info ) ; } else if ( info . known ) { enterPasswordState . call ( self ) ; } else { createSecondaryUser . call ( self ) ; } }
function ( offset ) { this . header . renderElement . dom . style . webkitTransform = ( offset === null ) ? null : 'translate3d(0px, -' + offset + 'px, 0px)' ; this . header . renderElement . dom . style . mozTransform = ( offset === null ) ? null : 'translate3d(0px, -' + offset + 'px, 0px)' ; }
function ( offset ) { var axis = this . getAxis ( ) , elementStyle = this . element . dom . style ; offset = Math . round ( offset ) ; if ( axis === 'x' ) { elementStyle . webkitTransform = 'translate3d(' + offset + 'px, 0, 0)' ; elementStyle . mozTransform = 'translate3d(' + offset + 'px, 0, 0)' ; } else { elementStyle . webkitTransform = 'translate3d(0, ' + offset + 'px, 0)' ; elementStyle . mozTransform = 'translate3d(0, ' + offset + 'px, 0)' ; } }
function ( offset ) { var axis = this . getAxis ( ) , domStyle = this . element . dom . style ; if ( axis === 'x' ) { domStyle . webkitTransform = 'translate3d(' + offset + 'px, 0, 0)' ; domStyle . mozTransform = 'translate3d(' + offset + 'px, 0, 0)' ; } else { domStyle . webkitTransform = 'translate3d(0, ' + offset + 'px, 0)' ; domStyle . mozTransform = 'translate3d(0, ' + offset + 'px, 0)' ; } }
function ( slice ) { var functions = this . getFunctions ( ) , style = slice . dom . style ; if ( Ext . os . is . iOS || Ext . os . is . Android3 || Ext . browser . is . Firefox ) { style . webkitTransform = 'translate3d(0px, -10000px, 0px)' ; style . mozTransform = 'translate3d(0px, -10000px, 0px)' ; } else { style . top = '-10000px' ; } functions . deactivate . call ( functions . scope , slice ) ; }
function ( x , y ) { var domStyle = this . getElement ( ) . dom . style ; if ( typeof x != 'number' ) { x = this . x ; } if ( typeof y != 'number' ) { y = this . y ; } domStyle . webkitTransform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)' ; domStyle . mozTransform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)' ; return this . callParent ( arguments ) ; }
function ( ) { var element = this . getElement ( ) ; if ( element && ! element . isDestroyed ) { element . dom . style . webkitTransform = null ; element . dom . style . mozTransform = null ; } this . callParent ( arguments ) ; }
function ( ) { var that = this ; if ( that . index < that . collection . length ) { that . index ++ ; var photoId = $ ( '#gallery ul li:nth-child(' + that . index + ')' ) . attr ( 'data-photo-id' ) ; Backbone . history . navigate ( "photo/" + photoId , { silent : true , trigger : true } ) ; } return false ; }
function ( ) { $ ( this . el ) . append ( _ . template ( PhotosTemplate , null ) ) ; var that = this ; _ . each ( this . collection . models , function ( item ) { that . renderItem ( item ) ; } ) ; this . selectByIndex ( 0 ) ; }
function ( str , terminal ) { try { if ( forth . dbg . enabled ) { forth . feedString ( str ) ; terminal . echo ( 'Input loaded into debugger' ) ; } else forth . runString ( str ) ; } catch ( err ) { terminal . error ( err ) ; } forth . redrawDebugger ( ) ; forth . redrawStack ( ) ; }
function ( ) { var enabled = forth . dbg . elt ( 'mode' ) . attr ( 'checked' ) == 'checked' ; forth . dbg . enabled = enabled ; forth . redrawDebugger ( ) ; forth . terminal . echo ( 'Debugger is ' + ( enabled ? 'enabled' : 'disabled' ) ) ; forth . terminal . set_prompt ( enabled ? 'debug> ' : '> ' ) ; }
function ( e ) { var v = self . _touchCapture ( e ) . xy2val ( self . dx , self . dy ) ; if ( v == this . newValue ) return ; if ( self . changeHook && ( self . changeHook ( v ) === false ) ) return ; self . change ( v ) ; self . _draw ( ) ; }
function updateMiniMessageCounter ( ) { var delta = 140 - $ ( 'textarea.jsMiniMessageText' ) . val ( ) . length ; var miniMessageCounter = $ ( '.miniMessageCounter' ) ; miniMessageCounter . text ( delta ) ; miniMessageCounter . toggleClass ( 'warning' , delta < 5 ) ; if ( delta < 0 ) { $ ( '.jsWriteMiniMessageButton' ) . attr ( 'disabled' , 'disabled' ) ; } else { $ ( '.jsWriteMiniMessageButton' ) . removeAttr ( 'disabled' ) ; } }
function ( propertyChanged ) { ++ this . _propertiesChanged [ propertyChanged ] ; if ( ! this . _dirty ) { var c = this . _collection ; if ( c ) { c . _updatePolyline ( propertyChanged , this ) ; this . _dirty = true ; } } }
function ( positionIndex , polyline , buffer ) { var positionsLength = this . _getPolylinePositionsLength ( polyline ) ; positionIndex += this . _getPolylineStartIndex ( polyline ) ; var show = polyline . getShow ( ) ; var showArray = new Uint8Array ( positionsLength ) ; for ( var j = 0 ; j < positionsLength ; ++ j ) { showArray [ j ] = show ; } buffer . copyFromArrayView ( showArray , positionIndex ) ; }
function ( ) { if ( ! this . homeView ) { this . home ( ) ; } this . whyView = new Thefrontend . Views . why ( { el : '#homeInfoPanel' } ) ; this . homeView . $el . find ( '#homeInfoButtons a' ) . removeClass ( 'active' ) ; this . homeView . $el . find ( '.why' ) . addClass ( 'active' ) ; this . whyView . render ( ) ; }
function ( url ) { console . log ( url ) ; tabs . open ( { url : url } ) ; popupPanel . hide ( ) ; }
function ( ) { $ . cookie ( 'TimedText.Preferences' , JSON . stringify ( this . config ) ) ; this . prevText = [ ] ; mw . log ( 'TimedText:: bind menu refresh display' ) ; this . buildMenu ( this . menuTarget , false ) ; this . resizeInterface ( ) ; this . displayTextTarget ( $ ( '<span /> ' ) . text ( '' ) ) ; this . monitor ( ) ; }
function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; }
function ( nodeName ) { var desc = webshims . defineNodeNameProperty ( nodeName , 'placeholder' , { attr : { set : function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; } , get : function ( ) { return webshims . contentAttr ( this , 'placeholder' ) ; } } , reflect : true , initAttr : true } ) ; }
function ( val ) { var elem = this ; var placeholder = webshims . contentAttr ( elem , 'placeholder' ) ; $ . removeData ( elem , 'cachedValidity' ) ; var ret = desc [ propType ] . _supset . call ( elem , val ) ; if ( placeholder && 'value' in elem ) { changePlaceholderVisibility ( elem , val , placeholder ) ; } return ret ; }
function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; }
function ( nodeName ) { var desc = webshims . defineNodeNameProperty ( nodeName , 'placeholder' , { attr : { set : function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; } , get : function ( ) { return webshims . contentAttr ( this , 'placeholder' ) ; } } , reflect : true , initAttr : true } ) ; }
function ( val ) { var elem = this ; var placeholder = webshims . contentAttr ( elem , 'placeholder' ) ; $ . removeData ( elem , 'cachedValidity' ) ; var ret = desc [ propType ] . _supset . call ( elem , val ) ; if ( placeholder && 'value' in elem ) { changePlaceholderVisibility ( elem , val , placeholder ) ; } return ret ; }
function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; }
function ( nodeName ) { var desc = webshims . defineNodeNameProperty ( nodeName , 'placeholder' , { attr : { set : function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; } , get : function ( ) { return webshims . contentAttr ( this , 'placeholder' ) ; } } , reflect : true , initAttr : true } ) ; }
function ( val ) { var elem = this ; var placeholder = webshims . contentAttr ( elem , 'placeholder' ) ; $ . removeData ( elem , 'cachedValidity' ) ; var ret = desc [ propType ] . _supset . call ( elem , val ) ; if ( placeholder && 'value' in elem ) { changePlaceholderVisibility ( elem , val , placeholder ) ; } return ret ; }
function ( a ) { f . de . valueMissing [ a ] = "Bitte w\u00e4hlen Sie eine Option aus" } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { f . de . rangeUnderflow [ a ] = "{%value} ist zu fr\u00fch. {%min} ist die fr\u00fcheste Zeit, die Sie benutzen k\u00f6nnen." } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { f . de . rangeOverflow [ a ] = "{%value} ist zu sp\u00e4t. {%max} ist die sp\u00e4teste Zeit, die Sie benutzen k\u00f6nnen." }
function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; }
function ( nodeName ) { var desc = webshims . defineNodeNameProperty ( nodeName , 'placeholder' , { attr : { set : function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; } , get : function ( ) { return webshims . contentAttr ( this , 'placeholder' ) ; } } , reflect : true , initAttr : true } ) ; }
function ( val ) { var elem = this ; var placeholder = webshims . contentAttr ( elem , 'placeholder' ) ; $ . removeData ( elem , 'cachedValidity' ) ; var ret = desc [ propType ] . _supset . call ( elem , val ) ; if ( placeholder && 'value' in elem ) { changePlaceholderVisibility ( elem , val , placeholder ) ; } return ret ; }
function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; }
function ( nodeName ) { var desc = webshims . defineNodeNameProperty ( nodeName , 'placeholder' , { attr : { set : function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; } , get : function ( ) { return webshims . contentAttr ( this , 'placeholder' ) ; } } , reflect : true , initAttr : true } ) ; }
function ( val ) { var elem = this ; var placeholder = webshims . contentAttr ( elem , 'placeholder' ) ; $ . removeData ( elem , 'cachedValidity' ) ; var ret = desc [ propType ] . _supset . call ( elem , val ) ; if ( placeholder && 'value' in elem ) { changePlaceholderVisibility ( elem , val , placeholder ) ; } return ret ; }
function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; }
function ( nodeName ) { var desc = webshims . defineNodeNameProperty ( nodeName , 'placeholder' , { attr : { set : function ( val ) { var elem = this ; webshims . contentAttr ( elem , 'placeholder' , val ) ; pHolder . update ( elem , val ) ; } , get : function ( ) { return webshims . contentAttr ( this , 'placeholder' ) ; } } , reflect : true , initAttr : true } ) ; }
function ( val ) { var elem = this ; var placeholder = webshims . contentAttr ( elem , 'placeholder' ) ; $ . removeData ( elem , 'cachedValidity' ) ; var ret = desc [ propType ] . _supset . call ( elem , val ) ; if ( placeholder && 'value' in elem ) { changePlaceholderVisibility ( elem , val , placeholder ) ; } return ret ; }
function ( req , res , next ) { req . events . find ( { starts_at : { $gt : new Date ( ) } } ) . sort ( { starts_at : 1 } ) . toArray ( function ( error , found ) { if ( error ) { return new Error ( error ) ; } req . found = found ; next ( ) ; } ) ; }
function getColspan ( row , cell ) { var metadata = data . getItemMetadata && data . getItemMetadata ( row ) ; if ( ! metadata || ! metadata . columns ) { return 1 ; } var columnData = metadata . columns [ columns [ cell ] . id ] || metadata . columns [ cell ] ; var colspan = ( columnData && columnData . colspan ) ; if ( colspan === "*" ) { colspan = columns . length - cell ; } return ( colspan || 1 ) ; }
function ( channel , user , word ) { this . channel = channel ; this . user = user ; this . rawWord = word ; this . modifiedWord = word . replace ( /./g , "_" ) ; this . guessedLetters = new Array ( 26 ) ; return this ; }
function ( ) { document . write ( "<pre>" ) ; var f = function ( message ) { document . write ( escape ( message ) . replace ( /%(..)/g , "&#x$1;" ) . replace ( "\n" , "<br />" ) + "<br />" ) ; } ; Assert . log = f ; return f ; }
function getCurrentAuthCredentials ( ) { var base_auth = "" ; if ( $htauth_username . val ( ) . length == 0 && Modernizr . localstorage ) { base_auth = localStorage [ 'mm_auth' ] == undefined ? "" : localStorage [ 'mm_auth' ] ; } else { base_auth = make_base_auth ( $htauth_username . val ( ) , $htauth_password . val ( ) ) ; if ( Modernizr . localstorage ) { localStorage [ 'mm_auth' ] = base_auth ; } } return base_auth ; }
function ( data , textStatus ) { if ( data [ 'success' ] ) { if ( lock_unique ) { $ ( '.msg-is-owned' , $message_list_element ) . removeClass ( 'msg-is-owned' ) } $li . removeClass ( 'msg-is-busy msg-is-locked' ) . addClass ( 'msg-is-owned' ) ; say_status ( "Lock granted OK" ) ; } else { $li . removeClass ( 'msg-is-busy' ) . addClass ( 'msg-is-locked' ) ; say_status ( "failed: " + data [ 'error' ] ) ; } if ( typeof ( callback ) == "function" ) { callback . call ( $ ( this ) , data ) ; } }
function ( data , textStatus ) { if ( data [ 'success' ] ) { $li . removeClass ( 'msg-is-busy msg-is-locked' ) . addClass ( 'msg-is-owned' ) . fadeOut ( 'slow' ) ; say_status ( "FMS ID assigned" ) ; if ( typeof ( callback ) == "function" ) { callback . call ( $ ( this ) , data [ 'data' ] ) ; } } else { $li . removeClass ( 'msg-is-busy' ) . addClass ( 'msg-is-locked' ) ; say_status ( "failed: " + data [ 'error' ] ) ; } }
function ( ) { var parts , query , result ; result = false ; parts = document . location . href . split ( '?' ) ; if ( parts . length > 0 ) { query = Ext . urlDecode ( parts [ 1 ] ) ; if ( query . id > 0 ) { result = true ; } } return result ; }
function ( ) { if ( ! self . vars || ! self . vars . cache || ! self . vars . cache . itemTemplate ) { self . vars = { } ; self . vars . cache = { } ; self . vars . cache . itemTemplate = $ . isFunction ( template ) ? template . apply ( this , arguments ) : template ; } return self . vars . cache . itemTemplate ; }
function ( data ) { console . log ( 'reflash data!' ) ; for ( var n = 0 ; n < data . length ; n ++ ) { if ( n == Role . id - 1 ) { console . log ( ~ ~ data [ n ] ) ; } jumpWood ( n , ~ ~ data [ n ] ) ; } }
function ( event ) { var as_cancel = jQuery ( this ) ; var action_link = ActiveScaffold . find_action_link ( as_cancel ) ; if ( action_link ) { var cancel_url = as_cancel . attr ( 'href' ) ; var refresh_data = action_link . tag . data ( 'cancel-refresh' ) ; if ( ! refresh_data || ! cancel_url ) { action_link . close ( ) ; return false ; } } return true ; }
function ( data ) { return Page . fromRawJSON ( title , JSON . parse ( data ) , lang ) ; }
function initialize_timemap ( id ) { var tm ; tm = TimeMap . init ( { mapId : "map" , timelineId : "timeline" , options : { eventIconPath : "../images/timemap/" } , datasets : [ { title : "Title" , theme : "red" , type : "kml" , options : { url : id + ".kml" } } ] , bandIntervals : [ Timeline . DateTime . DECADE , Timeline . DateTime . CENTURY ] } ) ; }
function ( ) { var router = new director . Router ( exports . routes ) ; router . init ( ) ; if ( ! window . location . hash || window . location . hash === '#' ) { window . location = '#/' ; $ ( window ) . trigger ( 'hashchange' ) ; } }
function ( ) { var router = new director . Router ( exports . routes ) ; router . init ( ) ; if ( ! window . location . hash || window . location . hash === '#' ) { window . location = '#/' ; $ ( window ) . trigger ( 'hashchange' ) ; } }
function ( pnt , direction ) { this . position = pnt ; this . direction = direction ; this . server_trace . push ( pnt ) ; this . temp_trace . length = 0 ; }
function ( player , amount , orientation , xPosition , yPosition ) { var army = new Army ( ) ; army . position . x = xPosition ; army . position . y = yPosition ; army . player = player ; army . orientation = orientation ; return army ; }
function ( player , amount , orientation , xPosition , yPosition ) { var armyOfKnights = createArmyOfNoType ( player , amount , orientation , xPosition , yPosition ) ; armyOfKnights . type = "knight" ; armyOfKnights . range = 2 ; armyOfKnights . units = ONLINGA . Units . Factory . createKnights ( amount ) ; return armyOfKnights ; }
function ( player , amount , orientation , xPosition , yPosition ) { var armyOfArchers = createArmyOfNoType ( player , amount , orientation , xPosition , yPosition ) ; armyOfArchers . type = "archer" ; armyOfArchers . range = 3 ; armyOfArchers . units = ONLINGA . Units . Factory . createArchers ( amount ) ; return armyOfArchers ; }
function ( player , amount , orientation , xPosition , yPosition ) { var armyOfRiders = createArmyOfNoType ( player , amount , orientation , xPosition , yPosition ) ; armyOfRiders . type = "rider" ; armyOfRiders . range = 4 ; armyOfRiders . units = ONLINGA . Units . Factory . createRiders ( amount ) ; return armyOfRiders ; }
function error ( err ) { if ( done ) return ; done = true ; req . socket . removeListener ( 'error' , error ) ; if ( ! self . headerSent ) self . removeHeader ( 'Content-Disposition' ) ; if ( fn ) return fn ( err ) ; if ( self . headerSent ) return ; next ( err ) ; }
function ( ) { var pos = $ ( this ) . scrollTop ( ) ; var d = self . model . data ( ) ; if ( pos + $ ( window ) . height ( ) > $ ( document ) . height ( ) + 3 ) { d . setPage ( d . getPage ( ) + 1 ) ; } else if ( pos < 0 ) { d . setPage ( d . getPage ( ) - 1 ) ; } }
function getElementsByClass ( node , searchClass ) { var ret = new Array ( ) ; var els = node . getElementsByTagName ( '*' ) ; for ( var i = 0 ; i < els . length ; ++ i ) { if ( els [ i ] . className == searchClass ) ret . push ( els [ i ] ) ; } return ret ; }
function removeRow ( tableId , anElementInRow ) { var className = 'repeating_table_' + tableId ; var row = findParentWithClass ( anElementInRow , className ) ; if ( row ) { row . style . display = 'none' ; var flags = getElementsByClass ( row , 'visibleFlag' ) ; if ( flags . length > 0 ) flags [ 0 ] . value = 'false' ; } }
function ( e ) { var updateOptions = { } ; updateOptions [ propertyName ] = element . value ; trackEvent . update ( updateOptions ) ; var target = _butter . getTargetByType ( "elementID" , trackEvent . popcornOptions . target ) ; if ( target ) { target . view . blink ( ) ; } }
function ( err ) { debug ( 'uncaught exception' ) ; var runnable = this . currentRunnable ; if ( 'failed' == runnable . state ) return ; runnable . clearTimeout ( ) ; err . uncaught = true ; this . fail ( runnable , err ) ; if ( 'test' == runnable . type ) { this . emit ( 'test end' , runnable ) ; this . hookUp ( 'afterEach' , this . next ) ; return ; } this . emit ( 'end' ) ; }
function ( ) { var code = $ ( this ) . prev ( ) . html ( ) ; editAreaLoader . setValue ( "textarea_1" , '<?php ' + code + '?>' ) ; $ ( "#code-php-button" ) . click ( ) ; }
function plural ( n ) { return n > 1 ? ' times' : ' time' }
function error ( con ) { var err = new Error ( 'contract failed: ' + abbrev ( con . function ) + ' ' + rangeDesc ( min , max ) + ', but was called ' + con . called + plural ( con . called ) + '.' ) err . type = 'contract' throw err }
function ( html ) { $ ( "#executions-view" ) . empty ( ) . append ( $ ( html ) ) $ ( "span.label" , $ ( "#executions-view" ) ) . css ( { cursor : 'pointer' } ) . click ( function ( e ) { $ ( this ) . prev ( ) . attr ( "checked" , "checked" ) ; } ) ; }
function ( ) { var eventName = this . actual . eventName , selector = this . actual . selector ; this . message = function ( ) { return [ "Expected event " + eventName + " to have been prevented on " + selector , "Expected event " + eventName + " not to have been prevented on " + selector ] } return jasmine . JQuery . events . wasPrevented ( selector , this . actual ) }
f return { label : item . name + ( item . adminName1 ? ", " + item . adminName1 : "" ) + ", " + item . countryName , value : item . name + ( item . adminName1 ? ", " + item . adminName1 : "" ) + ", " + item . countryName , } } ) ) ;
function ( data ) { response ( $ . map ( data . geonames , function ( item ) { return { label : item . name + ( item . adminName1 ? ", " + item . adminName1 : "" ) + ", " + item . countryName , value : item . name + ( item . adminName1 ? ", " + item . adminName1 : "" ) + ", " + item . countryName , } } ) ) ; }
function get_autocomplete_opts ( field ) { var autocomplete_opts = { minLength : 2 , source : function ( request , response ) { $ . getJSON ( "/authorities/generic_files/" + field , { q : request . term } , response ) ; } , focus : function ( ) { return false ; } } return autocomplete_opts ; }
function ( ) { var a = this . id . split ( "expand_" ) ; if ( a . length > 1 ) { docId = a [ 1 ] $ ( "#detail_" + docId ) . toggle ( ) ; if ( $ ( "#detail_" + docId ) . is ( ":hidden" ) ) { $ ( "#expand_" + docId ) . attr ( "class" , "icon-plus" ) ; } else { $ ( "#expand_" + docId ) . attr ( "class" , "icon-minus" ) ; } } }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( ) { var key , keywords , _i , _len ; keywords = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; for ( _i = 0 , _len = keywords . length ; _i < _len ; _i ++ ) { key = keywords [ _i ] ; if ( this . keywords [ key ] != null ) { return this . keywords [ key ] [ 0 ] . value ; } } return ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( _super ) { __extends ( DebugPipe , _super ) ; DebugPipe . name = 'DebugPipe' ; function DebugPipe ( log ) { DebugPipe . __super__ . constructor . apply ( this , arguments ) ; } DebugPipe . prototype . processData = function ( sdmxdata ) { console . log ( util . inspect ( sdmxdata , true , null , false ) ) ; return DebugPipe . __super__ . processData . apply ( this , arguments ) ; } ; return DebugPipe ; }
function ( ) { DistinctTimePeriod . name = 'DistinctTimePeriod' ; function DistinctTimePeriod ( value ) { this . date = Date . parse ( value , 'yyyy-MM-ddTHH:mm:ss' ) ; } DistinctTimePeriod . prototype . next = function ( ) { return this ; } ; DistinctTimePeriod . prototype . toString = function ( ) { return this . date . toString ( 'yyyy-MM-ddTHH:mm:ss' ) ; } ; DistinctTimePeriod . prototype . toDate = function ( ) { return this . date ; } ; return DistinctTimePeriod ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( attrs ) { var _base , _base1 , _name ; if ( ( _base = seriesCur . obs ) . attributes == null ) { _base . attributes = { } ; } if ( ( _base1 = seriesCur . obs . attributes ) [ _name = attrs . concept ] == null ) { _base1 [ _name ] = [ ] ; } return seriesCur . obs . attributes [ attrs . concept ] . push ( attrs . value ) ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( headerCur . name == null ) { headerCur . name = { } ; } return headerCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( headerCur . sender == null ) { headerCur . sender = { } ; } partyCur . id = attrs . id ; return headerCur . sender [ attrs . id ] = partyCur ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( partyCur . name == null ) { partyCur . name = { } ; } return partyCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( contactCur . name == null ) { contactCur . name = { } ; } return contactCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( contactCur . department == null ) { contactCur . department = { } ; } return contactCur . department [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( headerCur . receiver == null ) { headerCur . receiver = { } ; } partyCur . id = attrs . id ; return headerCur . receiver [ attrs . id ] = partyCur ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( headerCur . source == null ) { headerCur . source = { } ; } return headerCur . source [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( codeListCur . name == null ) { codeListCur . name = { } ; } return codeListCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( codeCur . name == null ) { codeCur . name = { } ; } return codeCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( conceptCur . name == null ) { conceptCur . name = { } ; } return conceptCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( dsdCur . name == null ) { dsdCur . name = { } ; } return dsdCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { var _base , _name ; if ( ( _base = seriesCur . obs . attributes ) [ _name = attrs . id ] == null ) { _base [ _name ] = [ ] ; } return seriesCur . obs . attributes [ attrs . id ] . push ( attrs . value ) ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( headerCur . name == null ) { headerCur . name = { } ; } return headerCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( headerCur . sender == null ) { headerCur . sender = { } ; } partyCur . id = attrs . id ; return headerCur . sender [ attrs . id ] = partyCur ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( partyCur . name == null ) { partyCur . name = { } ; } return partyCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( contactCur . name == null ) { contactCur . name = { } ; } return contactCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( contactCur . department == null ) { contactCur . department = { } ; } return contactCur . department [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( headerCur . source == null ) { headerCur . source = { } ; } return headerCur . source [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { var _base , _ref ; if ( componentCur . conceptIdentity == null ) { componentCur . conceptIdentity = { } ; } return ( _ref = ( _base = componentCur . conceptIdentity ) . ref ) != null ? _ref : _base . ref = _ . extend ( { } , attrs ) ; }
function ( attrs ) { var _base , _ref ; if ( componentCur . conceptIdentity == null ) { componentCur . conceptIdentity = { } ; } return ( _ref = ( _base = componentCur . conceptIdentity ) . ref ) != null ? _ref : _base . ref = _ . extend ( { } , attrs ) ; }
function ( attrs ) { var _base , _ref ; if ( componentCur . conceptIdentity == null ) { componentCur . conceptIdentity = { } ; } return ( _ref = ( _base = componentCur . conceptIdentity ) . ref ) != null ? _ref : _base . ref = _ . extend ( { } , attrs ) ; }
function ( attrs ) { var _base ; if ( componentCur . attributeRelationship == null ) { componentCur . attributeRelationship = { } ; } if ( ( _base = componentCur . attributeRelationship ) . dimension == null ) { _base . dimension = [ ] ; } return componentCur . attributeRelationship . dimension . push ( attrs . id ) ; }
function ( attrs ) { var _base , _ref ; if ( componentCur . conceptIdentity == null ) { componentCur . conceptIdentity = { } ; } return ( _ref = ( _base = componentCur . conceptIdentity ) . ref ) != null ? _ref : _base . ref = _ . extend ( { } , attrs ) ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( codeListCur . name == null ) { codeListCur . name = { } ; } return codeListCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( codeListCur . description == null ) { codeListCur . description = { } ; } return codeListCur . description [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( codeCur . name == null ) { codeCur . name = { } ; } return codeCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( codeCur . description == null ) { codeCur . description = { } ; } return codeCur . description [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( conceptSchemeCur . name == null ) { conceptSchemeCur . name = { } ; } return conceptSchemeCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( conceptCur . name == null ) { conceptCur . name = { } ; } return conceptCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( conceptCur . description == null ) { conceptCur . description = { } ; } return conceptCur . description [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( ) { var _base ; if ( conceptCur . coreRepresentation == null ) { conceptCur . coreRepresentation = { } ; } if ( ( _base = conceptCur . coreRepresentation ) . enumeration == null ) { _base . enumeration = { } ; } return conceptCur . coreRepresentation . enumeration . ref = this . parseURN ( this . stringBuffer ) ; }
function ( attrs ) { if ( attrs [ 'xml:lang' ] == null ) { attrs [ 'xml:lang' ] = 'en' ; } if ( dataStructureCur . name == null ) { dataStructureCur . name = { } ; } return dataStructureCur . name [ attrs [ 'xml:lang' ] ] = this . stringBuffer ; }
function ( ) { var _base , _ref ; if ( componentCur . conceptIdentity == null ) { componentCur . conceptIdentity = { } ; } return ( _ref = ( _base = componentCur . conceptIdentity ) . ref ) != null ? _ref : _base . ref = this . parseURN ( this . stringBuffer ) ; }
function ( ) { var _base , _ref ; if ( componentCur . conceptIdentity == null ) { componentCur . conceptIdentity = { } ; } return ( _ref = ( _base = componentCur . conceptIdentity ) . ref ) != null ? _ref : _base . ref = this . parseURN ( this . stringBuffer ) ; }
function ( ) { var _base ; if ( componentCur . conceptIdentity == null ) { componentCur . conceptIdentity = { } ; } if ( ( _base = componentCur . conceptIdentity ) . ref == null ) { _base . ref = this . parseURN ( this . stringBuffer ) ; } return componentCur . id = componentCur . conceptIdentity . ref . id ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( resource , statement , context , source ) { return _iterate ( resource , statement , context , source , true ) ; }
function authenticateUser ( email , pass , callback ) { var self = this ; user . authenticate ( email , pass , function ( authenticated ) { if ( ! authenticated ) { tooltip . showTooltip ( "#cannot_authenticate" ) ; } complete ( callback , authenticated ) ; } , self . getErrorDialog ( errors . authenticate , callback ) ) ; }
function ( authenticated ) { equal ( authenticated , false , "user is not authenticated" ) ; start ( ) ; }
function ( ) { console . log ( request . responseText ) ; var response = JSON . parse ( request . responseText ) ; console . log ( response ) ; if ( response . result == 'found' ) { var token = response . token ; console . log ( token ) ; self . setGithubToken ( token ) ; self . setIsSigned ( true ) ; } else { console . log ( 'Not logged yet.' ) ; } }
function add_features ( x ) { if ( x && x . features ) m . features ( x . features ) ; if ( callback ) callback ( x . features , m ) ; }
function ( ) { expect ( layer . features ( ) . length ) . toEqual ( 1 ) ; expect ( obj . callback ) . toHaveBeenCalled ( ) ; expect ( obj . callback ) . toHaveBeenCalledWith ( layer . features ( ) , layer ) ; }
function ( item ) { this . insertItemSorted ( item ) ; forEach ( sortProperties , function ( sortProperty ) { Ember . addObserver ( item , sortProperty , this , 'contentItemSortPropertyDidChange' ) ; } , this ) ; this . arrayContentDidChange ( idx , 0 , 1 ) ; }
function ( ) { var formulario = this . formulario ; var servico = new Servico ( ) ; $ ( formulario ) . find ( 'input,select,textarea' ) . each ( function ( index , field ) { servico . set ( $ ( field ) . attr ( 'id' ) , $ ( field ) . val ( ) ) ; } ) ; return servico ; }
function ( ) { var cb = jasmine . createSpy ( ) , cb2 = jasmine . createSpy ( ) ; target . addEventListener ( "pause" , cb ) ; target . addEventListener ( "pause" , cb2 ) ; event . trigger ( "appPause" , null , true ) ; expect ( cb ) . toHaveBeenCalled ( ) ; expect ( cb2 ) . toHaveBeenCalled ( ) ; }
function ( ) { var app = require ( "ripple/app" ) , cb = jasmine . createSpy ( ) ; spyOn ( app , "getInfo" ) . andReturn ( { features : { "blackberry.app" : { } } } ) ; target . addEventListener ( "resume" , cb ) ; event . trigger ( "appResume" , null , true ) ; expect ( cb ) . toHaveBeenCalled ( ) ; }
function ( row ) { var node = row . getElementsByClassName ( "logCounterValue" ) ; if ( ! node ) return ; node = node . item ( 0 ) ; var count = parseInt ( node . textContent ) ; if ( isNaN ( count ) ) count = 1 ; node . textContent = count + 1 ; }
function ( points ) { var geometry = new THREE . Geometry ( ) ; for ( var i = 0 ; i < points . length ; i ++ ) { geometry . vertices . push ( new THREE . Vector3 ( points [ i ] . x , points [ i ] . y , 0 ) ) ; } return geometry ; }
function ( ) { $ ( this ) . datepicker ( { dateFormat : "yy-mm-dd" } ) ; }
function ( ) { InspectorUI . highlighter . addListener ( "nodeselected" , highlightBodyNode ) ; node = doc . querySelector ( "body" ) ; EventUtils . synthesizeKey ( "VK_RIGHT" , { } ) ; }
function ( event , ui ) { var item = ui . item . data ( "item.autocomplete" ) ; if ( false !== self . _trigger ( "focus" , event , { item : item } ) ) { if ( /^key/ . test ( event . originalEvent . type ) ) { self . _value ( item . value ) ; } } }
function ( ) { nock . restore ( ) ; ret = nock . recorder . play ( ) ; t . equal ( ret . length , 1 ) ; t . equal ( ret [ 0 ] . indexOf ( "\nnock('expensecat.iriscouch.com')\n  .post('/', '\"ABCDEF\"')\n  .reply(" ) , 0 ) ; t . end ( ) ; }
function trivia_init ( ) { triviachan = sys . channelId ( 'Trivia' ) ; revchan = sys . channelId ( 'TrivReview' ) ; if ( typeof Trivia === "undefined" ) { Trivia = new TriviaGame ( ) ; triviaq = new QuestionHolder ( "triviaq.json" ) ; trivreview = new QuestionHolder ( "trivreview.json" ) ; tadmin = new TriviaAdmin ( "tadmins.txt" ) ; } Trivia . sendAll ( "Trivia is now running!" ) ; }
function ( req , res ) { var params = JSON . parse ( req . post ) , width = params . width , height = params . height ; if ( ! params . width || ! params . height ) { throw _errors . createInvalidReqMissingCommandParameterEH ( req ) ; } _session . getCurrentWindow ( ) . viewportSize = { width : width , height : height } res . success ( _session . getId ( ) ) ; }
function ( err , response , body ) { if ( err ) { deferred . reject ( err ) ; return ; } deferred . resolve ( response . request . uri . href ) ; }
function ( applicationId ) { triggerNode . empty ( ) ; triggerNode . append ( utils . createElement ( "p" , { "innerHTML" : applicationId + " is triggered" } ) ) ; triggerNode . show ( ) ; }
function ( ) { var models_that_have_us = this . collection . filter ( function ( m ) { return that . id in m . attributes ; } ) ; this . set ( { 'coverage' : models_that_have_us . length * 1.0 / this . collection . length } ) ; }
function ( ) { var values_of_us = this . collection . filter ( function ( m ) { return that . id in m . attributes ; } ) . map ( function ( m ) { return to_base_value ( m . get ( that . id ) ) ; } ) ; entropy = _ . uniq ( values_of_us ) . length * 1.0 / values_of_us . length ; this . set ( { 'entropy' : entropy } ) ; }
function ( copySource ) { if ( typeof ( copySource ) === "undefined" ) { return { elements : { } , attributes : { } , refs : [ ] , refQuantifiers : { } , attributeValues : [ ] , textNode : false , list : false , choices : [ ] , choiceRefs : [ ] , documentation : "" } ; } else { console . log ( "copied: " + JSON . stringify ( copySource ) ) ; return JSON . parse ( JSON . stringify ( copySource ) ) ; } }
function ( elem , options , callback ) { var old = { } ; for ( var name in options ) { old [ name ] = elem . style [ name ] ; elem . style [ name ] = options [ name ] ; } callback . call ( elem ) ; for ( name in options ) { elem . style [ name ] = old [ name ] ; } }
function ( i , v ) { if ( traditional || rbracket . test ( prefix ) ) { add ( prefix , v ) ; } else { buildParams ( prefix + "[" + ( typeof v === "object" || jQuery . isArray ( v ) ? i : "" ) + "]" , v , traditional , add ) ; } }
function ( ) { if ( self . options . hide && jQuery . _data ( self . elem , "fxshow" + self . prop ) === undefined ) { jQuery . _data ( self . elem , "fxshow" + self . prop , self . start ) ; } }
function percent ( p ) { if ( p != null && typeof p == typeof 1 && ! isNaN ( p ) && 0 <= p && p <= 1 ) { return p ; } else { $ . error ( "SVG renderer does not recognise %o as a valid percent (should be between 0 and 1)" , p ) ; } }
function color ( c ) { if ( c != null && typeof c == typeof "" && $ . Color ( c ) != "" ) { return $ . Color ( c ) . toHEX ( ) ; } else { $ . error ( "SVG renderer does not recognise %o as a valid colour" , c ) ; } }
function labelHalign ( a ) { if ( a != null && typeof a == typeof "" && ( a == "left" || a == "right" || a == "middle" ) ) { return a ; } else { $ . error ( "SVG renderer does not recognise %o as a valid label horizonal alignment" , a ) ; } }
function labelValign ( a ) { if ( a != null && typeof a == typeof "" && ( a == "top" || a == "bottom" || a == "middle" ) ) { return a ; } else { $ . error ( "SVG renderer does not recognise %o as a valid label vertical alignment" , a ) ; } }
function SvgExporter ( options ) { this . options = options ; this . cy = options . cy ; this . renderer = options . renderer ; if ( this . renderer . name ( ) != "svg" ) { $ . error ( "The SVG exporter can be used only if the SVG renderer is used" ) ; } }
function ( name , newValue ) { if ( name == "visible" ) { this . visible = newValue ; var visible = this . images [ this . visible ] ; this . _domElt . src = this . ROOT + visible . url ; this . _domDesc . innerHTML = visible . desc ; } }
function ( file , cb ) { if ( path . existsSync ( file ) ) { var data ; try { data = fs . readFileSync ( file , 'ascii' ) ; } catch ( error ) { cb ( error ) ; } this . readData ( data , function ( err , json ) { if ( err ) { cb ( err ) ; } else { cb ( null , json ) ; } } ) ; } else { cb ( file + " not found. Does it exist?" ) ; } }
function ( ) { io . Transport . XHR . prototype . onClose . call ( this ) ; if ( this . xhr ) { this . xhr . onreadystatechange = this . xhr . onload = empty ; try { this . xhr . abort ( ) ; } catch ( e ) { } this . xhr = null ; } }
function ( cm ) { if ( cm . getCursor ( true ) . line != cm . getCursor ( ) . line ) { CodeMirror . commands . indentMore ( cm ) ; } else if ( ! _this . introspect ( ) ) { console . log ( 'indentAuto' ) ; CodeMirror . commands . indentAuto ( cm ) ; } }
function ( ) { _this . worksheet . current_cell_id = - 1 ; if ( _this . input !== _this . codemirror . getValue ( ) ) { _this . send_input ( ) ; } _this . update ( ) ; }
function ( event , $args ) { var events = this . __events [ event ] , params , x , length ; if ( events ) { params = toArray ( arguments ) ; params . shift ( ) ; length = events . length ; for ( x = 0 ; x < length ; x += 1 ) { try { events [ x ] . fn . apply ( events [ x ] . context || this , params ) ; } finally { continue ; } } } return this ; }
function ( i , exception ) { rows += '<tr>' ; rows += '<td class="errbit-description-td"><button class="btn btn-mini pull-right errbit-description-toggle">&hellip;</button><div class="errbit-url">' + ( exception . url && exception . url !== "{}" ? exception . url : 'n/a' ) + '</div><br class="clear" /><div class="errbit-description"><pre>' + exception . error_class + '\n' + JSON . stringify ( exception . messages ) + '</pre></div></td>' ; rows += '<td>' + exception . env + '</td>' ; rows += '<td>' + exception . count + '</td>' ; rows += '<td>' + ( humaneDate ( exception . last_occurrence ) || exception . last_occurrence ) + '</td>' ; rows += '</tr>' ; }
function ( err , resp ) { try { if ( err ) throw err ; if ( resp . code !== 200 ) throw "non-200 status: " + resp . code + + " - " + resp . body ; if ( typeof resp . body !== 'string' ) throw cb ( "no response body" ) ; userdb . addCertToUserCtx ( ctx , email , resp . body ) ; cb ( ) ; } catch ( e ) { cb ( "can't certify key" + ( e ? ( ": " + e . toString ( ) ) : "" ) ) ; } }
function ( err , r ) { try { if ( err ) throw err ; if ( r . code !== 200 ) throw "non-200 status: " + r . code ; if ( ! JSON . parse ( r . body ) . status === 'okay' ) throw "verification failed with: " + r . reason ; cb ( undefined ) ; } catch ( e ) { return cb ( "can't verify: " + e . toString ( ) ) ; } }
function ( err , assertion ) { if ( err ) cb ( err ) ; else { cb ( null , { audience : obj . audience , assertion : assertion , expirationDate : expirationDate } ) ; } }
function s_removeBoundChan ( win , origin , scope ) { var arr = s_boundChans [ origin ] [ scope ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . win === win ) { arr . splice ( i , 1 ) ; } } if ( s_boundChans [ origin ] [ scope ] . length === 0 ) { delete s_boundChans [ origin ] [ scope ] } }
function s_removeBoundChan ( win , origin , scope ) { var arr = s_boundChans [ origin ] [ scope ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . win === win ) { arr . splice ( i , 1 ) ; } } if ( s_boundChans [ origin ] [ scope ] . length === 0 ) { delete s_boundChans [ origin ] [ scope ] } }
function s_removeBoundChan ( win , origin , scope ) { var arr = s_boundChans [ origin ] [ scope ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . win === win ) { arr . splice ( i , 1 ) ; } } if ( s_boundChans [ origin ] [ scope ] . length === 0 ) { delete s_boundChans [ origin ] [ scope ] } }
function ( clipboardEvent ) { if ( ! this . application . ninja . currentDocument || ( this . application . ninja . currentDocument && this . application . ninja . currentDocument . currentView === "code" ) ) { return ; } if ( document . activeElement . nodeName !== "BODY" ) { return ; } if ( this . clipboardContext === "stage" ) { ElementsClipboardAgent . copy ( clipboardEvent ) ; } clipboardEvent . preventDefault ( ) ; }
function ( clipboardEvent ) { if ( this . application . ninja . currentDocument . currentView === "code" ) return ; if ( document . activeElement . nodeName !== "BODY" ) { return ; } if ( this . clipboardContext === "stage" ) { ElementsClipboardAgent . cut ( clipboardEvent ) ; } clipboardEvent . preventDefault ( ) ; }
function ( doc ) { if ( doc . convert_into_recurring_invoice ) { doc . repeat_on_day_of_month = doc . posting_date . split ( '-' ) [ 2 ] ; doc . notification_email_address = [ doc . owner , doc . contact_email ] . join ( ', ' ) ; refresh_field ( [ 'repeat_on_day_of_month' , 'notification_email_address' ] ) ; } }
function ( ) { if ( this . _m_bPurgeDirecotorInNextLoop ) { this . purgeDirector ( ) ; this . _m_bPurgeDirecotorInNextLoop = false ; } else if ( ! this . m_bInvalid ) { this . drawScene ( ) ; cc . KeypadDispatcher . sharedDispatcher ( ) . clearKeyUp ( ) ; } }
function Request ( request ) { var parsed = url . parse ( request . url , true ) ; this . pathname = request . url ; this . headers = request . headers ; this . method = request . method . toLowerCase ( ) ; this . pathname = parsed . pathname ; this . hash = parsed . hash ; this . params = parsed . query ; this . data = querystring . parse ( request . post ) ; }
function ( ) { var plansUpdated = 0 ; for ( var planKey in this . plans ) { this . plans [ planKey ] . update ( ) . addOnce ( function ( ) { plansUpdated ++ ; if ( plansUpdated === this . plansCount ) { this . updateFinished . dispatch ( ) ; } } , this ) ; } }
function ( event ) { event . preventDefault ( ) ; var $target = $ ( event . currentTarget ) ; var $element = $target . siblings ( '.element' ) . clone ( ) ; $element . removeClass ( 'element' ) . addClass ( 'live-element' ) ; this . trigger ( 'createElement' , $element ) ; }
function ( ) { componentGroup . bind ( 'add' , this . addComponent , this ) ; componentGroup . bind ( 'reset' , this . addAllComponents , this ) ; this . bind ( 'closePopover' , this . resetActiveElement , this ) ; this . bind ( 'applyEdits' , this . applyEdits , this ) ; this . bind ( 'removeElement' , this . removeElement , this ) ; }
function ( mode ) { var retVal = mode ; try { if ( mode == 'A' ) retVal = 'TRANSIT,WALK' ; if ( mode == 'T' ) retVal = 'BUSISH,WALK' ; if ( mode == 'B' ) retVal = 'TRAINISH,WALK' ; } catch ( e ) { } return retVal ; }
function ( key ) { var keys = key . split ( /\./ ) ; var field = keys . pop ( ) ; var data = Echo . Utils . getNestedValue ( this . data , keys ) ; Echo . Utils . setNestedValue ( this . cache , key , undefined ) ; delete data [ field ] ; }
function ( ) { var sql = this . $ ( 'textarea' ) . val ( ) ; this . sqlView . setSQL ( sql ) ; this . model . useSQLView ( this . sqlView ) ; this . sqlView . fetch ( ) ; }
function ( event , context ) { var _this = context , context = this . context ; _this . hasStarted = true ; context . beginPath ( ) ; _this . startX = event . _x ; _this . startY = event . _y ; switch ( _this . shape ) { case "sketch" : context . moveTo ( event . _x , event . _y ) ; break ; case "rect" : console . log ( "rect" ) break ; } }
function ( event , context ) { var _this = context , context = this . context ; _this . hasStarted = false ; }
function ( ) { modal . appendTo ( that ) ; $ ( 'form' , $ ( this ) ) . on ( 'submit' , updateSettings ) ; $ ( '#settings-finished' , $ ( this ) ) . on ( 'click' , function ( ) { modal . toggleClass ( 'hide' ) ; } ) ; }
function ( ) { var fieldIndex ; return ( ( function ( ) { var _results ; _results = [ ] ; for ( fieldIndex in this . fields ) { _results . push ( fieldIndex ) ; } return _results ; } ) . call ( this ) ) . filter ( ( function ( fi ) { return this . fields [ fi ] . typeID === 37 ; } ) , this ) ; }
function ( e ) { var selection ; selection = null ; ( $ ( '.xAxis_input' ) ) . each ( function ( ) { if ( this . checked ) { return selection = this . value ; } } ) ; globals . xAxis = selection ; return _this . update ( ) ; }
function ( el , type , fn ) { if ( typeof el === 'string' ) { return ; } win . HighchartsAdapter . extendWithEvents ( el ) ; if ( type ) { if ( type === 'unload' ) { type = 'beforeunload' ; } if ( fn ) { el . removeEvent ( type , fn ) ; } else { el . removeEvents ( type ) ; } } else { el . removeEvents ( ) ; } }
function ( evt ) { mapMouseCoords ( evt ) ; var button = evt . button ; if ( Array . prototype . indexOf . call ( $jsilbrowserstate . heldButtons , button ) === - 1 ) $jsilbrowserstate . heldButtons . push ( button ) ; evt . preventDefault ( ) ; evt . stopPropagation ( ) ; return false ; }
function ( evt ) { mapMouseCoords ( evt ) ; var button = evt . button ; $jsilbrowserstate . heldButtons = $jsilbrowserstate . heldButtons . filter ( function ( element , index , array ) { ( element !== button ) ; } ) ; evt . preventDefault ( ) ; evt . stopPropagation ( ) ; return false ; }
function ( $ ) { $ . SetValue ( "__IsNumeric__" , true ) ; $ . SetValue ( "__IsIntegral__" , isIntegral ) ; if ( typedArrayName ) { var typedArrayCtor = eval ( typedArrayName ) ; if ( typedArrayCtor ) $ . SetValue ( "__TypedArray__" , typedArrayCtor ) ; else $ . SetValue ( "__TypedArray__" , null ) ; } else { $ . SetValue ( "__TypedArray__" , null ) ; } JSIL . MakeCastMethods ( $ . publicInterface , $ . typeObject , isIntegral ? "integer" : "number" ) ; }
function ( json ) { for ( i = 0 ; i < json . length ; i ++ ) { panel = '#correlation-panel' + json [ i ] . rank ; $ ( '.' + type + 's' , panel ) . html ( json [ i ] . correlation ) ; } callbackFn ( ) ; }
function ( req , res ) { var app_root = ( req . connection . encrypted ? 'https' : 'http' ) + '://' + req . headers [ 'host' ] ; res . render ( 'index' , { title : 'Bing Search Image' , app_root : app_root } ) }
function write ( canvas , str , x , y ) { if ( ! CACHE [ str ] ) { etch ( str ) ; } var image = CACHE [ str ] ; canvas . putImageData ( image , x , y - image . height / 2 ) ; }
function ( ) { expect ( hadError ) . toEqual ( true ) ; }
function ( ) { caughtError = false ; setTimeout ( function ( ) { try { referenceError } catch ( e ) { caughtError = true ; } } , 0 ) }
function ( force ) { if ( ! force && this . options . promptOnCancel && this . dirty ( ) ) { if ( confirm ( "You have unsaved changes. Are you " + "sure you want to discard them?" ) ) { this . cancel ( true ) ; } return ; } this . hideEditor ( ) ; this . element . triggerHandler ( "cancel" , [ this . _initialValue ] ) ; }
function ( ) { this . _loadMaskBox = Ext . widget ( 'box' , { tpl : '<strong>{msg}...</strong>' , data : { msg : 'Loading' } , listeners : { scope : this , afterrender : this . _onAfterRender } } ) ; Ext . apply ( this , { items : [ this . _loadMaskBox ] , frame : false , border : false } ) ; this . callParent ( arguments ) ; this . _loadStudents ( ) ; }
function ( post ) { var postView = this . createPostView ( post ) postView . render ( ) this . addToViewBuffer ( postView . el ) }
function ( ) { this . activeScreen = false ; this . css [ 'z-index' ] = g . bottomZIndex ; this . css [ 'opacity' ] = 0.0 ; screenCollection [ this . activeStatement . nextId ] . activeScreen = true ; this . activeStatement = this . originalActive ; }
function ( ) { g . input . key = inputState . getKey ( ) ; g . input . mouse = inputState . getMouse ( ) ; for ( x in g . screenCollection ) { g . screenCollection [ x ] . update ( ) ; } var HTML = '' ; for ( x in g . screenCollection ) { HTML += g . screenCollection [ x ] . draw ( ) ; } $ ( '#origins' ) . html ( HTML ) ; g . frameCounter ++ ; }
function mouseOut ( d ) { svg . selectAll ( "path" ) . classed ( "non-selected" , false ) ; svg . selectAll ( "path.link.source-" + d . key ) . classed ( "source" , false ) . each ( highlightAll ( "target" , false ) ) ; svg . selectAll ( "path.link.target-" + d . key ) . classed ( "target" , false ) . each ( highlightAll ( "source" , false ) ) ; }
function clearButtonClick ( ) { clearSelection ( ) ; if ( selected_source !== undefined ) { svg . select ( "#arc-" + selected_source . key ) . classed ( "selected-source" , false ) ; } if ( selected_target !== undefined ) { svg . select ( "#arc-" + selected_target . key ) . classed ( "selected-target" , false ) ; } }
function init ( ) { loc = new google . maps . LatLng ( 37.762861 , - 122.401078 ) ; var mapOptions = { center : loc , zoom : 16 , mapTypeId : google . maps . MapTypeId . ROADMAP } ; map = new google . maps . Map ( $ ( "#crazy-map" ) [ 0 ] , mapOptions ) ; }
function AssertionError ( options ) { this . name = 'AssertionError' ; this . message = options . message ; this . actual = options . actual ; this . expected = options . expected ; this . operator = options . operator ; }
function ( ) { if ( this . message ) { return this . name + ':' + this . message } else { return this . name + ':' + this . truncate ( JSON . stringify ( this . actual ) , 128 ) + " " + this . operator + " " + this . truncate ( JSON . stringify ( this . expected ) , 128 ) } }
function ( line ) { Array . push ( sel . options , ( new Element ( 'option' , { 'value' : line . id , 'text' : line . name } ) ) ) ; if ( line . id == id ) sel . selectedIndex = index ; index ++ ; }
function ( dbname ) { console . log ( dbname ) ; new Request . JSON ( { 'url' : '/ajax/call/arkeogis/getDbDesc' , 'onSuccess' : function ( resJSON ) { mydir . displayDesc ( dbname , resJSON ) ; } } ) . get ( { 'dbname' : dbname } ) ; }
function peekLineTerminator ( skip ) { var pos , line , start , found ; skip = skip || 0 ; pos = index ; line = lineNumber ; start = lineStart ; while ( skip -- ) { advance ( ) ; } skipComment ( ) ; found = lineNumber !== line ; index = pos ; lineNumber = line ; lineStart = start ; return found ; }
function ( cval , crumb ) { var id = cval . substring ( 0 , cval . indexOf ( ":lv=" ) ) ; var aCrumb = id . split ( "=" ) ; for ( var i = 0 ; i < aCrumb . length ; i ++ ) { if ( crumb == aCrumb [ 0 ] ) { return aCrumb [ 1 ] ; } } return null ; }
function ( ) { this . hour = $ ( 'input.bootstrap-timepicker-hour' ) . val ( ) ; this . minute = $ ( 'input.bootstrap-timepicker-minute' ) . val ( ) ; if ( true === this . showSeconds ) { this . second = $ ( 'input.bootstrap-timepicker-second' ) . val ( ) ; } this . meridian = $ ( 'input.bootstrap-timepicker-meridian' ) . val ( ) ; this . update ( ) ; }
function ( req , res , next ) { if ( req . user ) { if ( req . user . confirmed || noConfirm ) { view ( req , res , next ) ; } else { res . redirect ( '/confirm' , 302 ) ; } } else { res . redirect ( '/login' , 302 ) ; } }
function ( post ) { $location . path ( 'post/' + post . _id + '/edit' ) ; }
function ( doc , req ) { var d = doc ; d . text_nobreaks = d . text . replace ( /\r\n|\n|\r/gm , ' ' ) ; d . text_nobreaks = d . text_nobreaks . replace ( /[\.,-\/#!$%\^&\*;:{}=\-`~()'"]/gm , ' ' ) ; return { title : 'Log Entry: ' + doc . title , content : templates . render ( 'logbook_view.html' , req , d ) } ; }
function ( doc , req ) { var d = doc ; if ( ! d . status ) d . status = "None" ; return { title : 'Debugging Tag' , content : templates . render ( 'tags.html' , req , d ) } ; }
function ( doc , req ) { var board_id = "" ; var d = new Date ( ) ; if ( req . query . board ) { board_id = req . query . board ; board_id = board_id . toString ( ) . substring ( 1 , board_id . length - 1 ) ; } return { title : 'New Tag' , content : templates . render ( 'tag_new.html' , req , { board_id : board_id , created : d . toString ( ) } ) } ; }
function ( doc , req ) { doc . _deleted = true ; if ( req . client ) { content = templates . render ( 'test_deleted.html' , req , { } ) ; } else { content = templates . render ( 'base.html' , req , { content : content , title : title } ) ; } return [ doc , { content : content , title : 'Test deleted' } ] ; }
function ( doc ) { if ( doc . config && doc . type != 'board' ) { var c = new Date ( doc . created ) ; var created = - c . getTime ( ) ; emit ( [ doc . config . fec_id , created ] , { 'type' : doc . type , 'pass' : doc . pass , 'created' : doc . created , 'config' : doc . config , 'archived' : doc . archived } ) ; } }
function ( doc ) { if ( doc . type == "ecal" ) { var c = new Date ( doc . created ) ; var created = c . getTime ( ) ; var short_created = c . toLocaleString ( ) ; emit ( - created , { 'type' : doc . type , 'pass' : doc . pass , 'created' : created , 'short_created' : short_created , 'archived' : doc . archived , crates : doc . crates } ) ; } }
function ( keys , values ) { return sum ( values ) ; }
function ( doc ) { if ( doc . config && doc . type != 'board' ) if ( doc . type == 'final_test' ) emit ( [ doc . _id , 0 ] , doc ) ; else if ( doc . final_test_id ) emit ( [ doc . final_test_id , 1 ] , doc ) ; }
function ( doc ) { if ( doc . type == 'log' ) { var d = new Date ( doc . created ) ; emit ( - d , doc ) ; } }
function ( doc ) { if ( doc . type == 'tag' ) emit ( doc . board , 1 ) ; }
function ( err , items ) { test . ok ( err != null ) ; collection . find ( { } ) . toArray ( function ( err , items ) { test . ok ( err == null ) ; test . equal ( 1 , items . length ) ; p_db . close ( ) ; test . done ( ) ; } ) ; }
function ( flag ) { return flag === '<inputFile>' ? ( toolId !== 0 ? fileOutput : file ) : ( flag === '<outputFile>' ? fileOutput : flag ) ; }
function ( ) { if ( util . curTime ( ) > this . _heartbeatExpirationTime ) { self . emit ( "heartbeat-error" , "Lost remote after " + ( HEARTBEAT * 2 ) + "ms" ) ; self . close ( ) ; } self . send ( "_zpc_hb" , [ 0 ] ) ; }
function ( e ) { var width = $ ( window ) . width ( ) ; if ( width <= 719 && ! Tabzilla . smallMode ) { Tabzilla . enterSmallMode ( ) ; } if ( width > 719 && Tabzilla . smallMode ) { Tabzilla . leaveSmallMode ( ) ; } }
function ( event ) { var as_cancel = jQuery ( this ) ; var action_link = ActiveScaffold . find_action_link ( as_cancel ) ; if ( action_link ) { var cancel_url = as_cancel . attr ( 'href' ) ; var refresh_data = action_link . tag . data ( 'cancel-refresh' ) ; if ( ! refresh_data || ! cancel_url ) { action_link . close ( ) ; return false ; } } return true ; }
function showMapDirectPopup ( ) { if ( typeof mapDirect != 'undefined' ) { if ( markerFeatures [ mapDirect ] . popup == null ) fillPopup ( markerFeatures [ mapDirect ] ) ; if ( ! markerFeatures [ mapDirect ] . popup . visible ( ) ) showPopup ( markerFeatures [ mapDirect ] . popup ) mapDirect = undefined ; } }
function ( ) { that . processH ( this ) ; }
function ( obj ) { if ( ! obj || ! jQuery ( obj ) . length > 0 ) { return false ; } obj = jQuery ( obj ) ; if ( obj . find ( 'span[role=annotation]' ) . length > 0 ) { return true ; } return false ; }
function ( obj ) { if ( ! obj || ! jQuery ( obj ) . length > 0 ) { return false ; } obj = jQuery ( obj ) ; var objCleaned = obj . clone ( ) . find ( 'span[role=annotation]' ) . remove ( ) . end ( ) ; if ( objCleaned . text ( ) . trim ( ) . length > 0 ) { return true ; } return false ; }
function ( event ) { that . clickImage ( event ) ; event . stopPropagation ( ) ; }
function append_empty_form ( sel , i ) { $ ( sel ) . append ( '<form action="http://localhost:3000/talk/update" enctype="multipart/form-data" id="edittalk" method="post"><input id="talk_series_id" name="talk[series_id]" type="hidden" value="5" /><dt>Date YYYY/MM/DD    Time HH:MM</dt><dd><input id="talk_date_string' + i + '" name="talk[date_string]" size="11" type="text" /> From <input id="talk_start_time_string' + i + '" name="talk[start_time_string]" size="5" type="text" /> to <input id="talk_end_time_string' + i + '" name="talk[end_time_string]" size="5" type="text" /></dd><dt>Title</dt><dd><input class="wide" id="talk_title' + i + '" name="talk[title]" size="60" type="text" /></dd><dt>Abstract</dt><dd><textarea class="wide" cols="57" id="talk_abstract' + i + '" name="talk[abstract]" rows="10"></textarea></dd><dt>Speaker\'s name and affiliation</dt><dd><input class="wide" id="talk_name_of_speaker' + i + '" name="talk[name_of_speaker]" size="60" type="text" /></dd><dt>Speaker\'s e-mail</dt><dd><input class="wide" id="talk_speaker_email" name="talk[speaker_email]" size="60" type="text" value="" /><p class="emailcheck"><input id="talk_send_speaker_email" name="talk[send_speaker_email]" type="checkbox" value="1" /><input name="talk[send_speaker_email]" type="hidden" value="0" />Check this box to send an e-mail to the speaker when you save this talk.</p></dd><dt>Venue</dt><dd><input class="wide" id="talk_venue_name' + i + '" name="talk[venue_name]" size="60" type="text" value="Venue to be confirmed" /></dd><p><input name="commit" type="submit" value="Save" /> or <a href="http://localhost:3000/show/index/7">Cancel</a></p></form>' ) ; }
function ( ) { $ . _wordSearch . gameState . dragging = false ; $ . _wordSearch . gameState . endSq = $ ( this ) . data ( ) ; $ . _wordSearch . computeSelectedSquares ( ) ; $ . _wordSearch . checkSelectedWord ( ) ; $ ( '.selectedSquare' ) . removeClass ( 'selectedSquare' ) ; }
function ( ) { $ . _wordSearch . gameState . dragging = false ; $ . _wordSearch . computeSelectedSquares ( ) ; $ . _wordSearch . checkSelectedWord ( ) ; $ ( '.selectedSquare' ) . removeClass ( 'selectedSquare' ) ; }
function ( e ) { valueOf ( testRun , e . success ) . shouldBeTrue ( ) ; valueOf ( testRun , e . error ) . shouldBeFalse ( ) ; Cloud . Users . logout ( loggedOut2 ) ; }
function ( e ) { if ( e . success == false ) { var data = { username : 'chatuser' , password : 'password' , password_confirmation : 'password' } ; Cloud . Users . create ( data , created1 ) ; } else { created2 ( e ) ; } }
function ( e ) { valueOf ( testRun , e . success ) . shouldBeTrue ( ) ; valueOf ( testRun , e . error ) . shouldBeFalse ( ) ; Cloud . Users . logout ( loggedOut1 ) ; }
function ( e ) { valueOf ( testRun , e . success ) . shouldBeTrue ( ) ; valueOf ( testRun , e . error ) . shouldBeFalse ( ) ; for ( var i = 0 ; i < e . cars . length ; i ++ ) { carIds . push ( e . cars [ i ] . id ) ; } Cloud . Objects . remove ( { classname : 'cars' , ids : carIds . toString ( ) } , carsRemoved ) ; }
function ( e ) { valueOf ( testRun , e . success ) . shouldBeTrue ( ) ; valueOf ( testRun , e . error ) . shouldBeFalse ( ) ; for ( var i = 0 ; i < e . test . length ; i ++ ) { testIds . push ( e . test [ i ] . id ) ; } Cloud . Objects . remove ( { classname : 'test' , ids : testIds . toString ( ) } , testsRemoved ) ; }
function ( e ) { valueOf ( testRun , e . success ) . shouldBeFalse ( ) ; valueOf ( testRun , e . error ) . shouldBeTrue ( ) ; Cloud . PushNotifications . notify ( { channel : data . channel , payload : 'Hello World' } , notified ) ; }
function ( e ) { valueOf ( testRun , e . success ) . shouldBeFalse ( ) ; valueOf ( testRun , e . error ) . shouldBeTrue ( ) ; Cloud . PushNotifications . unsubscribe ( { channel : data . channel , device_token : data . device_token } , unsubscribed ) ; }
function ( testRun ) { verifyAPIs ( testRun , 'Clients' , [ 'geolocate' ] ) ; finish ( testRun ) ; }
function ( e ) { valueOf ( testRun , e . success ) . shouldBeTrue ( ) ; valueOf ( testRun , e . error ) . shouldBeFalse ( ) ; finish ( testRun ) ; }
function ( testRun ) { verifyAPIs ( testRun , 'Emails' , [ 'send' ] ) ; finish ( testRun ) ; }
function handleInv ( e ) { var invs = e . message . invs ; if ( invs . length == 1 && invs [ 0 ] . type == 2 ) { this . emit ( 'success' , { invs : invs } ) ; this . close ( ) ; } }
function ( err , response ) { tick ( ) ; var data = [ ] ; if ( err ) throw err ; response . forEach ( function ( board ) { data . push ( { board_name : board . name , board_id : board . id } ) } ) ; callback ( null , data ) ; }
function ( err , response ) { tick ( ) ; if ( err ) throw err ; if ( response . labels . length > 0 ) { card . label = response . labels [ 0 ] . name ; } var featureArea = response . desc . match ( 'FeatureArea:(.*)' ) ; card . feature_area = featureArea ? featureArea [ 1 ] : '' ; callback2 ( null ) ; }
function onLocationDetected ( ok , e ) { if ( e ) { console . log ( 'onLocationDetected :: ' + e ) ; } else { drawISPList ( ) ; map . setLocation ( { isp : isp , status : status , lat : loc . lat , lng : loc . lng } ) ; if ( ! initialized ) { mdl . setLocation ( loc . city , loc . state , isps ) ; initialized = true ; } } }
function iterableProxy ( arr ) { return Proxy . create ( { getPropertyDescriptor : function ( name ) { for ( var obj = arr ; obj ; obj = Object . getPrototypeOf ( obj ) ) { var desc = Object . getOwnPropertyDescriptor ( obj , name ) ; if ( desc ) return desc ; } return undefined ; } } ) ; }
function getShortcuts ( shortcuts ) { var len = shortcuts . length ; for ( var i = 0 ; i < len ; i ++ ) { var origin = shortcuts [ i ] ; if ( origin in installedApps ) { delete installedApps [ origin ] ; } } for ( var origin in installedApps ) { GridManager . install ( installedApps [ origin ] ) ; } updatePaginationBar ( ) ; finish ( ) ; addLanguageListener ( ) ; }
function startup ( ) { PinLock . init ( ) ; SoundManager . init ( ) ; SleepMenu . init ( ) ; SourceView . init ( ) ; Shortcuts . init ( ) ; Bluetooth . init ( ) ; window . focus ( ) ; function dumbListener2 ( event ) { } window . addEventListener ( 'devicemotion' , dumbListener2 ) ; window . setTimeout ( function ( ) { window . removeEventListener ( 'devicemotion' , dumbListener2 ) ; } , 2000 ) ; }
function ( reply ) { if ( reply . status != "OK" ) { closeAllLoadingMessages ( ) ; humanMsg . displayMsg ( reply . message ) ; return ; } CitizenCalendarSettingsHelper . _subscriptions . existing = CitizenCalendarSettingsHelper . _subscriptions . next . slice ( 0 ) ; closeAllLoadingMessages ( ) ; humanMsg . displayMsg ( reply . message ) ; return ; }
function ( element , index ) { switch ( type ) { case "equal" : return element [ attribute ] === value ; case "isnot" : return element [ attribute ] !== value ; case "greater" : return element [ attribute ] > value ; case "smaller" : return element [ attribute ] < value ; case "contains" : debugger ; console . log ( attribute , element [ attribute ] ) ; return element [ attribute ] . search ( new RegExp ( value , "i" ) ) !== - 1 ; } }
function ( contentToAdd , disableRender ) { itemsToUpload . push ( contentToAdd ) ; disableAddToQueue ( ) ; enableStartUpload ( ) ; if ( ! disableRender ) { renderQueue ( ) ; } }
function ( err , email , uid ) { if ( err ) { logger . warn ( "couldn't complete email verification: " + err ) ; wsapi . databaseDown ( res , err ) ; } else { delete req . session . pendingCreation ; wsapi . authenticateSession ( req . session , uid , 'password' , config . get ( 'ephemeral_session_duration_ms' ) ) ; res . json ( { success : true } ) ; } }
function ( email , assertion , onComplete , onFailure ) { post ( { url : "/wsapi/auth_with_assertion" , data : { email : email , assertion : assertion , ephemeral : ! storage . usersComputer . confirmed ( email ) } , success : handleAuthenticationResponse . curry ( "assertion" , onComplete , onFailure ) , error : onFailure } ) ; }
function export_to_spreadsheet ( mytype ) { if ( mytype ) { values = $ ( '#fmFilter' ) . serializeArray ( ) ; values = jQuery . param ( values ) ; window . location = sitelink + "ajax?" + values + '&export_format=' + mytype } clear_input_dropdown ( 'export' , "" ) ; }
function ( e ) { editModule ( $ ( this ) . attr ( 'href' ) , null , refreshField ) ; $ ( context ) . scrollTo ( 'body' , 800 ) ; return false ; }
function ( context ) { if ( window . fuel && window . fuel . module ) { return window . fuel . module ; } if ( context == undefined ) context = null ; var module = ( $ ( '.__fuel_module__' , context ) . size ( ) ) ? $ ( '.__fuel_module__' , context ) . val ( ) : null ; return module ; }
function ( context ) { var height = 0 ; if ( $ ( '#login' , context ) . size ( ) ) { var elems = '#login' ; } else { var elems = '#fuel_main_top_panel, #fuel_actions, #fuel_notification, #fuel_main_content_inner, #list_container, .instructions' ; } $ ( elems , context ) . each ( function ( i ) { height += $ ( this ) . outerHeight ( ) ; } ) return height ; }
function ( request , response ) { var parsed = parseQuotas ( response . GROUP ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . VM ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . DATASTORE ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . IMAGE ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . NETWORK ) ; }
function updateGroupsView ( request , group_list ) { group_list_json = group_list ; var group_list_array = [ ] ; $ . each ( group_list , function ( ) { group_list_array . push ( groupElementArray ( this ) ) ; } ) ; updateView ( group_list_array , dataTable_groups ) ; updateGroupSelect ( group_list ) ; SunstoneMonitoring . monitor ( 'GROUP' , group_list ) updateSystemDashboard ( "groups" , group_list ) ; }
function ( ) { var uname = getValue ( $ ( this ) . val ( ) , 4 , 2 , dataTable_images ) ; $ ( 'input#IMAGE_UNAME' , section_disks ) . val ( uname ) ; var target = getValue ( $ ( this ) . val ( ) , 4 , 12 , dataTable_images ) ; if ( target && target != "--" ) $ ( 'input#TARGET' , section_disks ) . val ( target ) ; else $ ( 'input#TARGET' , section_disks ) . val ( '' ) ; }
function ( request , response ) { var parsed = parseQuotas ( response . USER ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . VM ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . DATASTORE ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . IMAGE ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . NETWORK ) ; }
function ( monitoring ) { $ ( '#totalUsers' , $dashboard ) . text ( monitoring [ 'totalUsers' ] ) var container = $ ( 'div#usersPerGroup' , $dashboard ) ; SunstoneMonitoring . plot ( 'USER' , 'usersPerGroup' , container , monitoring [ 'usersPerGroup' ] ) ; }
function updateUsersView ( request , users_list ) { var user_list_array = [ ] ; $ . each ( users_list , function ( ) { user_list_array . push ( userElementArray ( this ) ) ; } ) ; updateView ( user_list_array , dataTable_users ) ; SunstoneMonitoring . monitor ( 'USER' , users_list ) updateSystemDashboard ( "users" , users_list ) ; updateUserSelect ( ) ; }
function draw ( ctx ) { var pt = this . containsPoint ( mouseX , mouseY ) ; drawbutton ( ctx , x , y , w , h , pt ) ; ctx . fillStyle = 'black' ; ctx . font = '14pt "Press Start 2P"' ; ctx . textAlign = 'center' ; ctx . fillText ( text , x + w / 2 + 10 , y + 35 , w - 20 ) ; }
function ( subspec ) { if ( subspec === 'collision' ) { location . collision = true ; } else if ( subspec !== '' ) { location . push ( new Tile ( subspec , e , i , chunk ) ) ; if ( subspec === 'Castle_outside LH' ) { console . log ( 'collide' ) ; location . collision = true ; } } }
function ( ) { if ( DEBUG ) { ctx . strokeStyle = 'red' ; ctx . strokeRect ( this . x - this . w / 2 , this . y - this . h / 2 , this . w , this . h ) ; } }
function DeviceStorageDB ( storage , db , options ) { this . storage = storage ; this . db = db ; this . mediaType = options . mediaType this . onchange = options . onchange ; this . directory = options . directory ; this . mimeTypes = options . mimeTypes || [ ] ; this . metadataParser = options . metadataParser ; this . lastScanTime = null ; }
function storeCreatedFiles ( ) { var transaction = this . db . transaction ( 'files' , 'readwrite' ) var store = transaction . objectStore ( 'files' ) ; for ( var i = 0 ; i < createdFiles . length ; i ++ ) { store . add ( createdFiles [ i ] ) ; } dsdb . onchange ( "created" , createdFiles ) ; }
function ( ) { var _len , _ref , _results ; _ref = this . subscriptions ; _results = [ ] ; for ( i = 0 , _len = _ref . length ; i < _len ; i ++ ) { s = _ref [ i ] ; _results . push ( this . unsubscribe ( i ) ) ; } return _results ; }
function ( fn ) { var r , tmp ; tron . test ( tests . check_is_function , fn ) ; tmp = this . subscriptions ; r = [ ] ; this . subscriptions = [ function ( ) { var args ; args = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; return r . push ( args ) ; } ] ; fn ( ) ; this . subscriptions = tmp ; return r ; }
function ( ) { var key ; if ( ! _this . min_level ) return false ; for ( key in _this ) { if ( key === _this . min_level ) return false ; if ( key === method ) return true ; } }
function show_hosts_history ( event ) { var selected = $ ( selected_objects ( ) ) ; if ( selected . size ( ) < 1 ) { show_error_dialog ( "対象がなにも選択されていません" ) ; return false ; } ; window . location . href = '/ybz/host/history/' + selected . get ( ) . join ( '-' ) ; }
function show_bricks_history ( event ) { var selected = $ ( selected_objects ( ) ) ; if ( selected . size ( ) < 1 ) { show_error_dialog ( "対象がなにも選択されていません" ) ; return false ; } ; window . location . href = '/ybz/brick/history/' + selected . get ( ) . join ( '-' ) ; }
function show_operations ( event ) { var start = $ ( "input[name='start_date']" ) . val ( ) ; var end = $ ( "input[name='end_date']" ) . val ( ) ; var url = "/ybz/operations" ; if ( start != null && end != null ) { if ( start . length != 8 || end . length != 8 ) { alert ( "日付入力は8桁 yyyymmdd で入力してください" ) ; return false ; } url = url + '/' + start + '/' + end ; } window . location . href = url ; }
function show_detailbox_without_selection ( event , modelname ) { var target = $ ( event . target ) . closest ( '.selectable,.unselectable' ) ; var oid = target . attr ( "id" ) ; if ( oid == null || oid == "" ) { return false ; } show_detailbox ( modelname , oid , event . pageY - detailbox_offset ( ) , false ) ; }
function ( n , i ) { return ( $ ( n ) . attr ( 'name' ) . match ( /^localips\d+$/ ) && $ ( n ) . val ( ) . length > 0 ) ; } ) . map ( function ( n ) { return $ ( n ) . val ( ) }
function setupMiddleware ( ) { app . store = new require ( 'connect/lib/middleware/session/memory' ) ; app . use ( flatiron . plugins . http ) ; app . http . before = [ connect . cookieParser ( 'secret' ) , connect . cookieSession ( { cookie : { domain : 'localhost' , store : app . store } } ) , middleware . pageRewrite , ecstatic ( __dirname + '/client' ) ] ; }
function ( user ) { socket . emit ( 'profile' , user ) ; }
function ( user ) { var opponentID = user . _id ; if ( challengeList [ opponentID ] === userID ) { delete challengeList [ opponentID ] ; launchBattle ( userID , opponentID ) ; } else { challengeList [ userID ] = opponentID ; } }
function launchBattle ( userID1 , userID2 ) { [ app . userIDToSocket [ userID1 ] , app . userIDToSocket [ userID2 ] ] . forEach ( function ( socket ) { socket . emit ( 'battle' ) ; } ) ; }
function displayError ( heading , text ) { showPage ( 'error-page' ) ; $ ( '#error-page textarea' ) . val ( heading + ':\n' + text ) ; }
function autoSizeL ( ) { var mx = this . mousePos . x , dx = mx - this . slider . startx ; if ( mx < this . slider . middle && dx ) { this . view . startTime += dx * this . view . zoom / 10 ; this . render ( ) ; } }
function autoSizeR ( ) { var mx = this . mousePos . x , dx = mx - this . slider . endx ; if ( mx > this . slider . middle && dx ) { this . view . endTime += dx * this . view . zoom / 10 ; this . render ( ) ; } }
function ( strAxis ) { if ( serie . isCartesian && ( ( strAxis === 'xAxis' && isXAxis ) || ( strAxis === 'yAxis' && ! isXAxis ) ) && ( ( seriesOptions [ strAxis ] === options . index ) || ( seriesOptions [ strAxis ] === UNDEFINED && options . index === 0 ) ) ) { serie [ strAxis ] = axis ; associatedSeries . push ( serie ) ; if ( serie . options . padXAxis ) { padAxis = true ; } run = true ; } }
function ( ) { this . fetcher ( this . renderIt ( ) ) ; return this ; }
function Controller ( options ) { this . menu = options . menu || "i-dropdown-menu" ; this . scroll = options . scroll || "i-dropdown-scroll" ; this . push = options . push || "i-dropdown-push" ; this . elements = options . elements || "li > a" ; this . scrolloptions = options . scrolloptions || { } ; }
function swapBGM ( ) { switch ( Math . round ( Math . random ( ) * 3 ) ) { case 0 : { gco . bgm = document . getElementById ( 'bgm_square' ) ; break ; } case 1 : { gco . bgm = document . getElementById ( 'bgm_fast' ) ; break ; } case 2 : { gco . bgm = document . getElementById ( 'bgm_soar' ) ; } default : { } } gco . init_audio ( ) ; }
function ( playfx ) { switch ( playfx ) { case 0 : { this . explosion . channel [ this . explosion . index ] . play ( ) ; this . explosion . index += 1 ; if ( this . explosion . index > ( this . explosion . channels - 1 ) ) { this . explosion . index = 0 ; } } case 1 : { this . laser . play ( ) ; this . laserPlaying = true ; } } }
function ( global ) { $ = typeof $ !== 'undefined' && $ || require ( 'jquery' ) ; if ( typeof window === "undefined" ) { window = this ; } $data = window [ "$data" ] || ( window [ "$data" ] = { } ) ; if ( typeof module !== "undefined" && module . exports ) { sqLiteModule = require ( 'sqlite3' ) ; if ( sqLiteModule ) window [ 'openDatabase' ] = true ; module . exports = $data ; } }
function ( ) { this . inherited ( arguments ) ; for ( var i = 0 ; i < this . panelArrangers . length ; i ++ ) { this . $ . arrangerPicker . createComponent ( { content : this . panelArrangers [ i ] . name } ) ; } }
function ( result ) { stub . setErrorHandler ( null ) ; $ ( '#email' ) . text ( result . email ) $ ( '#authenticated' ) . removeClass ( 'hidden' ) ; $ ( '#logout' ) . click ( function ( ) { stub . ajax ( 'POST' , '/auth/api/logout/' , { } , function ( message ) { $ ( '#authenticated' ) . addClass ( 'hidden' ) ; $ ( '#logged-out' ) . removeClass ( 'hidden' ) ; } ) ; return false ; } ) ; }
function ( result ) { var email ; email = result . email ; if ( email . length > MAX_EMAIL_LENGTH ) { email = email . substr ( 0 , MAX_EMAIL_LENGTH ) + '[...]' ; } $ ( '#email' ) . text ( email ) $ ( '#wwwhisper-overlay' ) . removeClass ( 'hidden' ) ; }
function ( img ) { b . __modify ( Element . SYS_MOD , function ( t ) { this . rx = Math . floor ( img . width / 2 ) ; this . ry = Math . floor ( img . height / 2 ) ; } ) ; }
function Player ( id , opts ) { this . id = id ; this . state = null ; this . anim = null ; this . canvas = null ; this . ctx = null ; this . controls = null ; this . info = null ; this . __canvasPrepared = false ; this . _init ( opts ) ; }
function ( evt ) { if ( player . controls ) { player . controls . show ( ) ; player . controls . render ( player . state , player . state . time ) ; } if ( player . info ) player . info . show ( ) ; return true ; }
function ( evt ) { if ( player . controls && ( ! player . controls . evtInBounds ( evt ) ) ) { player . controls . hide ( ) ; } if ( player . info && ( ! player . info . evtInBounds ( evt ) ) ) { player . info . hide ( ) ; } return true ; }
function ( ) { var x = this . xdata ; var bounds ; if ( x . path ) { bounds = x . path . bounds ( ) ; } else if ( x . image ) { bounds = [ 0 , 0 , x . image . width , x . image . height ] ; } else if ( x . text ) { bound = x . text . bounds ( ) ; } else return null ; return bounds ; }
function Sine ( freq , volume ) { var that = Gibberish . Sine ( freq , volume ) ; that . connect ( Master ) ; that . masters = [ ] ; return that ; }
function ( src ) { if ( src . substring ( 0 , 2 ) === "//" ) { src = document . location . protocol + src ; } if ( ! src . match ( /^https?:\/\//g ) ) { if ( src . substring ( 0 , 1 ) === "/" ) { src = scraper . base + src ; } else { src = scraper . url + '/' + src ; } } return src ; }
function ( done ) { client . scard ( SET_KEY , function ( cnt ) { assert . equal ( cnt , ADDS_COUNT , 'Count is not correct.' ) ; done ( ) ; } ) ; }
function render ( digest , timeUnit , calendarState , connectorEnabled ) { hideEventInfo ( ) ; this . getTemplate ( "text!applications/calendar/tabs/clock/clock.html" , "clock" , function ( ) { if ( calendarState == oldState ) return ; else oldState = calendarState ; setup ( digest , timeUnit , connectorEnabled ) ; } ) ; }
function ( x , y ) { var from = this . GetCenterTile ( ) ; var to = { X : x , Y : y } ; var path = NavigationManager . GetPathFinder ( ) . FindPath ( from , to ) ; }
function ( ) { var sprite = "" ; if ( this . Sprites . length > 0 ) sprite = this . Sprites [ Crafty . math . randomInt ( 0 , this . Sprites . length - 1 ) ] ; var entity = Crafty . e ( "2D, DOM, SpriteAnimation, Body, " + sprite ) . attr ( { z : 2 , TileWidth : this . Width , TileHeight : this . Height } ) ; this . set ( { 'entity' : entity } ) ; }
function ( e ) { e . preventDefault ( ) ; hideSource = 'button' ; div . modal ( "hide" ) ; var handler = $ ( this ) . data ( "handler" ) ; var cb = callbacks [ handler ] ; if ( typeof cb == 'function' ) { cb ( ) ; } }
function ( a , b ) { var worth = { none : 0 , low : 1 , medium : 2 , high : 3 } ; if ( a . logged && ! b . logged ) return 1 else if ( ! a . logged && b . logged ) return - 1 else if ( a . logged && b . logged ) return 0 return worth [ b . priority ] - worth [ a . priority ] }
function ( ) { $gallery . masonry ( { itemSelector : '.item' , columnWidth : 240 } ) ; }
function ( ) { var active = $ ( '#list' ) . find ( '.active' ) ; KT . panel . panelAjax ( active , active . attr ( "data-ajax_url" ) , $ ( '#panel' ) , false ) ; }
function mm_deleteMessage ( id , callback ) { console . log ( "SMS: Eliminando mensaje " + typeof ( id ) + id ) ; var req = navigator . mozSms . delete ( id ) ; req . onsuccess = function onsuccess ( ) { callback ( req . result ) ; } ; req . onerror = function onerror ( ) { var msg = 'Deleting in the database. Error: ' + req . errorCode ; console . log ( msg ) ; callback ( null ) ; } ; }
function thlui_cleanForm ( ) { var inputs = this . view . querySelectorAll ( 'input[type="checkbox"]' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; } }
function thui_cleanForm ( ) { var inputs = this . view . querySelectorAll ( 'input[type="checkbox"]' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; this . delNumList = [ ] ; } }
function ( positionIndex , axisId , value ) { if ( this . matrix [ positionIndex ] == null ) this . matrix [ positionIndex ] = [ ] ; this . matrix [ positionIndex ] [ axisprefix + axisId ] = value ; for ( var i = 1 ; i < positionIndex ; i ++ ) { if ( this . matrix [ i ] == null ) this . matrix [ i ] = [ ] ; } }
function ( m ) { var p = this . _get_parent ( m . o ) ; if ( ! p ) return false ; p = p == - 1 ? this . get_container ( ) : p ; if ( p === m . np ) return true ; if ( p [ 0 ] && m . np [ 0 ] && p [ 0 ] === m . np [ 0 ] ) return true ; return false ; return true ; }
function ( node ) { openDialog ( { rslt : { name : $ ( "#testcase-tree" ) . jstree ( "get_text" , node ) , position : $ ( "#testcase-tree" ) . jstree ( "get_index" , node ) , obj : node , parent : $ ( node ) . parents ( "li:first" ) } } , 'edit' ) ; }
function ( e , data ) { $ ( this ) . find ( "li[rel=test_project]" ) . data ( "jstree" , ROOT_MENU ) ; $ ( this ) . find ( "li[rel=test_suite]" ) . data ( "jstree" , FOLDER_MENU ) ; $ ( this ) . find ( "li[rel=test_case]" ) . data ( "jstree" , LEAF_MENU ) ; }
function ( m ) { var p = this . _get_parent ( m . o ) ; if ( ! p ) return false ; p = p == - 1 ? this . get_container ( ) : p ; if ( p === m . np ) return true ; if ( p [ 0 ] && m . np [ 0 ] && p [ 0 ] === m . np [ 0 ] ) return true ; return false ; return true ; }
function ( rooms ) { if ( ! rooms . length ) { addMessage ( 'No rooms available' , 'notification' ) } else { $ . each ( rooms , function ( ) { addMessage ( this . Name + ' (' + this . Count + ')' ) ; } ) ; } }
function ( _data , textStatus ) { callback ( true , data ) ; }
function ( ) { $ ( this ) . val ( $ ( '.active' , $ ( this ) ) . attr ( 'value' ) ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; } } ) ; }
function ( e , link ) { var width = 400 , height = 300 , cls = link . className , match ; if ( cls . indexOf ( 'dim' ) > - 1 ) { match = new RegExp ( 'dim(\\d+)x(\\d+)' ) . exec ( cls ) ; width = match [ 1 ] ; height = match [ 2 ] ; } boxing_request . load ( e , link . getAttribute ( 'href' ) , width , height ) ; }
function ( ) { if ( typeof domiwyg != 'undefined' ) { var dw = domiwyg ; dw . lang . create_kwe_link = 'Infoga länk till en annan sida på denna webbplats' ; dw . lang . insert_kwe_image = 'Infoga bild som finns uppladdat till KWE' ; dw . tool_btns . splice ( 6 , 0 , [ 'KWElink' , 'create_kwe_link' ] , [ 'KWEimage' , 'insert_kwe_image' ] ) ; dw . area . prototype . cmdKWElink = kwe . KWElink ; dw . area . prototype . cmdKWEimage = kwe . KWEimage ; } }
function ( data ) { var termsOptions = { table : domain . termsTableName , name : field . indexColumnName , flags : Database . COLUMN_INDEX + '|' + Database . WITH_POSITION , type : domain . tableName , source : field . columnName } ; return database . commandDeferred ( 'column_create' , termsOptions ) ; }
function ( column ) { database . commandSync ( 'column_remove' , { table : domain . termsTableName , name : column . name } ) ; database . commandSync ( 'column_create' , { table : domain . termsTableName , name : column . name , flags : column . flags , type : column . type , source : column . source } ) ; }
function MathQuill ( el ) { el = $ ( el ) ; pray ( 'el is a single element' , el . length === 1 ) ; var blockId = $ ( el ) . attr ( mqBlockId ) ; if ( ! blockId ) return null ; var rootBlock = MathElement [ blockId ] ; return ! ! rootBlock && rootBlock . jQ [ 0 ] === el [ 0 ] && rootBlock . publicMathQuillObj ; }
function ( el ) { var mq = MathQuill ( el ) ; if ( mq ) return mq ; var rootBlock = RootBlock ( ) ; createRoot ( $ ( el ) , rootBlock , textbox , editable ) ; return rootBlock . publicMathQuillObj = SubClass ( rootBlock ) ; }
function ( m ) { if ( m . getLoop ) { var message = { loop : myloop . toString ( ) , delay : delay , callback : ( callback ? true : false ) } ; worker . send ( message ) ; } else if ( m . callback ) { callback ( m . value ) ; } }
function ( ) { codemirror . setValue ( ngModel . $viewValue ) ; }
function ( isp , status ) { console . log ( 'marker = ' + uMarker ) console . log ( 'markers.length = ' + markers . length ) ; if ( uMarker ) { uMarker . isp = ispName = isp ; uMarker . status = status ; uMarker . time = Date . now ( ) ; drawMap ( ) ; } }
function ( a ) { console . log ( 'adding markers' ) for ( var i = a . length - 1 ; i >= 0 ; i -- ) { if ( a [ i ] . user == false ) { addMarker ( a [ i ] ) ; } else { uMarker = drawGeoMarker ( a [ i ] ) ; } } console . log ( 'adding markers-uMarker' + uMarker ) ; drawMap ( ) ; }
function ( ) { console . log ( 'drawMap' ) console . log ( '**ispName = ' + ispName ) ; for ( var i = markers . length - 1 ; i >= 0 ; i -- ) { markers [ i ] . inCircle = searchCircle . contains ( markers [ i ] . getPosition ( ) ) ; } }
function onLocationDetected ( ok , e ) { if ( e ) { console . log ( e ) ; } else { drawISPList ( ) ; map . setLocation ( { isp : isp , status : status , lat : loc . lat , lng : loc . lng } ) ; if ( ! initialized ) { map . getMarkers ( ) ; mdl . setLocation ( loc . city , loc . state , isps ) ; initialized = true ; } } }
function ( ) { var enabled = forth . dbg . elt ( 'mode' ) . attr ( 'checked' ) == 'checked' ; forth . dbg . enabled = enabled ; forth . redrawDebugger ( ) ; forth . terminal . echo ( 'Debugger is ' + ( enabled ? 'enabled' : 'disabled' ) ) ; }
function ( key , target , e ) { return { key : key , dispatcher : this , keys : this . activeKeys , target : target , e : e } ; }
function ( e ) { var mapping ; this . activeKeys . add ( e . which ) ; mapping = this . mappings . get ( this . combo ( ) ) ; if ( ( mapping != null ? mapping . down : void 0 ) != null ) { mapping . down . call ( e . target , this . context ( e . which , e . target , e ) ) ; return e . preventDefault ( ) ; } }
function ( e ) { var newInput = template . clone ( ) ; var arrayI = newInput . get ( 'name' ) . match ( /.+?\[(\d+)\].+/ ) ; if ( arrayI && arrayI [ 1 ] ) { newInput . set ( 'name' , newInput . get ( 'name' ) . replace ( /(.+?\[)\d+(\].+)/ , '$1' + ( parseInt ( arrayI [ 1 ] , 10 ) + 1 ) + '$2' ) ) ; } newInput . inject ( e . target , 'before' ) ; }
function ( ) { try { this . config = JSON . parse ( fs . readFileSync ( this . path + 'config.json' ) ) ; } catch ( e ) { console . error ( e . stack ) ; try { this . config = JSON . parse ( fs . readFileSync ( __dirname + '/default_channel_config.json' ) ) ; } catch ( e ) { console . log ( 'Failed to load default channel config!\n%s' , e . stack ) ; process . exit ( ) ; } } }
function ( listener ) { console . log ( 'removing listener for' , listener [ 0 ] ) ; chan . network . removeListener ( listener [ 0 ] , listener [ 1 ] ) ; }
function ( e ) { var section = e . state ? e . state [ 'section' ] : null ; if ( section ) { show_section ( section ) ; } else { var h = document . location . href ; if ( h . indexOf ( '#' ) != - 1 ) { section = h . slice ( h . indexOf ( '#' ) + 1 ) ; show_section ( section ) ; window . scrollTo ( 0 , 0 ) ; } } }
function ( next ) { if ( this . req . headers [ 'x-auth-token' ] === authToken ) { next ( ) ; return true ; } haibu . sendResponse ( this . res , 403 , { message : 'Wrong auth token' } ) ; return false ; }
function ( file , dest ) { file = file || prefix + ".js" ; dest = dest || prefix + ".min.js" ; var minified = minify ( fs . readFileSync ( file , "utf-8" ) ) ; fs . writeFileSync ( dest , minified , "utf-8" ) ; sys . puts ( "> " + dest ) }
function ( options , template ) { var _ref , _ref1 ; return $ ( ( _ref1 = options . template ) != null ? _ref1 : template ) . attr ( 'class' , options [ "class" ] ) . css ( ( _ref = options . css ) != null ? _ref : { } ) ; }
function resultsToDOM ( ) { var modOutput = document . createElement ( 'div' ) , ref = document . getElementById ( 'qunit-testresult' ) || document . getElementById ( 'qunit-tests' ) ; modOutput . className = 'output' ; modOutput . innerHTML = dumpModernizr ( ) ; if ( Modernizr . csscolumns ) ref . parentNode . insertBefore ( modOutput , ref ) ; document . getElementsByTagName ( 'textarea' ) [ 0 ] . innerHTML = JSON . stringify ( Modernizr ) ; }
function defaultAttr ( elem , to ) { var attr = jsv . merge [ elem . nodeName . toLowerCase ( ) ] ; return attr ? ( to ? attr . to . toAttr : attr . from . fromAttr ) : to ? "text" : "" ; }
function getTemplate ( tmpl ) { if ( "" + tmpl === tmpl ) { var tokens = tmpl . split ( "[" ) ; tmpl = templates [ tokens . shift ( ) ] ; while ( tmpl && tokens . length ) { tmpl = tmpl . tmpls [ tokens . shift ( ) . slice ( 0 , - 1 ) ] ; } } return tmpl ; }
function ( store , name , item , process ) { if ( item && store === templates ) { item . link = function ( ) { return $ . link . apply ( item , arguments ) ; } ; if ( name ) { $ . link [ name ] = item . link ; } } }
function ( openChars , closeChars ) { var delimChars = oldJsvDelimiters . apply ( oldJsvDelimiters , arguments ) ; delimOpenChar0 = delimChars [ 0 ] ; delimOpenChar1 = delimChars [ 1 ] ; delimCloseChar0 = delimChars [ 2 ] ; delimCloseChar1 = delimChars [ 3 ] ; rTag = new RegExp ( "(?:^|\\s*)([\\w-]*)(" + delimOpenChar1 + jsv . rTag + ")" + delimCloseChar0 + ")" , "g" ) ; return this ; }
function getHelper ( helper ) { var view = this , tmplHelpers = view . tmpl . helpers || { } ; helper = ( view . ctx [ helper ] !== undefined ? view . ctx : tmplHelpers [ helper ] !== undefined ? tmplHelpers : helpers [ helper ] !== undefined ? helpers : { } ) [ helper ] ; return typeof helper !== "function" ? helper : function ( ) { return helper . apply ( view , arguments ) ; } ; }
function ( tagObject , args ) { var i = 0 , l = args . length ; while ( l && ! args [ i ++ ] ) { if ( i === l ) { return "" ; } } view . onElse = undefined ; tagObject . path = "" ; return tagObject . renderContent ( view ) ; }
function ( resources ) { var retResources = new Array ( ) ; var x = resources . length - 1 ; for ( ; x >= 0 ; x -- ) { retResources . push ( resources [ i ] ) ; } callback ( null , retResources ) ; }
function ( error , result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , sectionMaterial : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Failed to add resource to section" } ) ) ; } }
function ( error , result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , sectionMaterial : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Failed to add resource to section" } ) ) ; } }
function ( error , result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , sectionMaterial : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Failed to add resource to section" } ) ) ; } }
function visibleLines ( ) { var lh = textHeight ( ) , top = scroller . scrollTop - paddingTop ( ) ; var from_height = Math . max ( 0 , Math . floor ( top / lh ) ) ; var to_height = Math . ceil ( ( top + scroller . clientHeight ) / lh ) ; return { from : lineAtHeight ( doc , from_height ) , to : lineAtHeight ( doc , to_height ) } ; }
function ( ) { var w = 0 , outer = "<div id='scrollTest' style='overflow: scroll;'></div>" ; $ ( 'body' ) . append ( outer ) ; var el = document . getElementById ( 'scrollTest' ) ; w = el . offsetWidth - el . scrollWidth ; $ ( '#scrollTest' ) . remove ( ) ; return w ; }
function ( ) { if ( state [ 0 ] ) { $ ( '#console_I' ) . css ( 'opacity' , 0.4 ) ; state [ 0 ] = false ; } else { $ ( '#console_I' ) . css ( 'opacity' , 1 ) ; state [ 0 ] = true ; } refreshLogger ( 0 ) ; }
function ( ) { if ( state [ 1 ] ) { $ ( '#console_W' ) . css ( 'opacity' , 0.4 ) ; state [ 1 ] = false ; } else { $ ( '#console_W' ) . css ( 'opacity' , 1 ) ; state [ 1 ] = true ; } refreshLogger ( 1 ) ; }
function ( ) { $ . each ( $ ( eId ) . find ( '.cCheck' ) , function ( ) { if ( $ ( this ) . prop ( 'checked' ) == true ) { $ ( this ) . parents ( '.console_row' ) . remove ( ) ; } } ) ; refreshCounter ( ) ; }
function ( req , res ) { res . render ( "trendywall.ejs" , { layout : false } ) ; }
function ( ) { $ ( this ) . attr ( "name" , $ ( this ) . attr ( "name" ) + "_" + uniqueid ) ; if ( $ ( this ) . hasClass ( "datepick" ) ) { $ ( this ) . datePicker ( ) ; } }
function updateOptions ( el ) { var val = $ ( el ) . val ( ) ; val = val . replace ( '.' , '_' ) ; $ ( el ) . parent ( ".filterline" ) . find ( ".filteroptions" ) . html ( $ ( '#filterdummyoptions_' + val ) . html ( ) ) ; $ ( el ) . parent ( ".filterline" ) . find ( ".datepick" ) . datePicker ( ) ; }
function getAst ( bx , def ) { if ( bx . ast != null ) { patchFuncAst ( bx . ast ) ; return bx . ast ; } else { def = def || bx . textContent ; setAst ( bx , ( Leisure . compileNext ( def , Parse . Nil , true , null , true ) ) [ 0 ] ) ; return bx . ast ; } }
function autoRun ( el , state ) { var _ref ; el . autorunState = state ; return ( _ref = el . autorun ) != null ? _ref . checked = state : void 0 ; }
function ( response ) { try { var specSource = specPattern . exec ( unescape ( String ( response ) ) ) [ 1 ] ; var spec = new Spec ( String ( specPattern . exec ( unescape ( String ( response ) ) ) [ 1 ] ) ) ; if ( ! spec ) return ; cache . set ( id , JSON . stringify ( spec . data ) ) ; callback ( spec ) ; } catch ( e ) { cache . set ( id , "unavailable" ) ; } }
function View ( el , contexts ) { this . el = el ; this . contexts = contexts ; this . bind = __bind ( this . bind , this ) ; this . build = __bind ( this . build , this ) ; this . build ( ) ; }
function ( ) { let children = this . trash_file . enumerate_children ( '*' , 0 , null , null ) ; let child_info = null ; while ( ( child_info = children . next_file ( null , null ) ) != null ) { let child = this . trash_file . get_child ( child_info . get_name ( ) ) ; child . delete ( null ) ; } }
function ( data ) { var item = data . returnData ; iGuess . model . setRoomId ( item . rid ) ; var url = location . origin + location . pathname ; $ ( '#urlInput' ) [ 0 ] . value = url + '?rid=' + item . rid ; }
function updateRealInnerWidth ( components , options ) { components . containerWidth = 0 ; components . root . find ( options . children ) . each ( function ( ) { components . containerWidth += $ ( this ) . outerWidth ( true ) ; } ) ; components . container . css ( { position : 'relative' , left : 0 , width : components . containerWidth } ) ; }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function ( callback ) { var instanceOfServico = this ; $ . ajax ( { url : url_salvar , type : "POST" , data : $ . toJSON ( instanceOfServico ) , contentType : "application/json; charset=utf-8" , dataType : "json" , success : function ( data ) { callback ( data ) ; } , complete : function ( ) { } , error : function ( error ) { alert ( "Erro!" ) ; } } ) ; }
function ( ) { var url = document . forms [ 0 ] . url . value ; var matches = null ; if ( matches = url . match ( /voteit\.com\/v\/([0-9a-zA-Z]+)/ ) ) { var embedUrl = 'https://www.voteit.com/v/' + matches [ 1 ] + '/embed' ; var code = '<iframe src="' + embedUrl + '" scrolling="no" width="320" height="360" style="border:none;"></iframe>' ; tinyMCEPopup . editor . execCommand ( 'mceInsertContent' , false , code ) ; tinyMCEPopup . close ( ) ; } else { this . error ( ) ; } }
function ( ) { source = wrapSource ( source , resourceId , config [ 'injectSourceUrl' ] !== false && require . toUrl ( resourceId ) ) ; if ( config [ 'injectScript' ] ) { injectScript ( source ) ; } else { globalEval ( source ) ; } loaded ( require ( resourceId ) ) ; }
function ( module ) { if ( typeof module . then == 'function' ) { module . then ( function ( resource ) { if ( arguments . length == 0 ) resource = module ; resolved ( resource ) ; } , rejected ) ; } else { resolved ( module ) ; } }
function ( ) { this . attachToParentComponent ( ) ; if ( this . _element ) { this . originalContent = Array . prototype . slice . call ( this . _element . childNodes , 0 ) ; } if ( ! this . hasOwnProperty ( "identifier" ) ) { this . identifier = Montage . getInfoForObject ( this ) . label ; } }
function ( event , widget ) { var node ; widget = widget || this ; if ( event ) { if ( event . node && ! ( event . name === "modelUpdated" && event . type === "nodeRemoved" ) ) { widget . _showProperties ( event . node ) ; } else { node = ADM . getActivePage ( ) ; widget . _showProperties ( node ) ; } } }
function ( ) { } , function ( err , people ) { test . ifError ( err , 'expect no error' ) ; test . equal ( people . length , 3 , 'three people in people set' ) ; var query = that . popit . model ( 'Person' ) . find ( ) . asc ( 'name' ) ; query . run ( function ( err , docs ) { test . equal ( docs . length , 3 , 'three people in database' ) ; } ) ; test . done ( ) ; }
function ( ) { } , function ( err , people ) { test . ifError ( err , 'expect no error' ) ; test . equal ( people . length , 3 , 'three people in people set' ) ; var query = that . popit . model ( 'Organisation' ) . find ( ) . asc ( 'name' ) ; query . run ( function ( err , docs ) { test . equal ( docs . length , 1 , 'one organisation in database' ) ; test . done ( ) ; } ) ; }
function getlayers ( ) { var l = [ ] ; for ( var i in map . layers ) { if ( ( map . layers [ i ] . visibility === true ) && ( map . layers [ i ] . CLASS_NAME === 'Wax.Layer' ) ) { l . push ( map . layers [ i ] ) ; } } return l ; }
function ( ) { container = document . createElement ( 'div' ) ; container . className = 'wax-legends' ; element = container . appendChild ( document . createElement ( 'div' ) ) ; element . className = 'wax-legend' ; element . style . display = 'none' ; return legend ; }
function hide ( ) { var _ct ; while ( _ct = tooltips . pop ( ) ) { if ( animate && transitionEvent ) { bean . add ( _ct , transitionEvent , remove ) ; _ct . className += ' wax-fade' ; } else { if ( _ct . parentNode ) _ct . parentNode . removeChild ( _ct ) ; } } }
function ( ) { container = document . createElement ( 'div' ) ; container . className = 'wax-legends' ; element = container . appendChild ( document . createElement ( 'div' ) ) ; element . className = 'wax-legend' ; element . style . display = 'none' ; return legend ; }
function hide ( ) { var _ct ; while ( _ct = tooltips . pop ( ) ) { if ( animate && transitionEvent ) { bean . add ( _ct , transitionEvent , remove ) ; _ct . className += ' wax-fade' ; } else { if ( _ct . parentNode ) _ct . parentNode . removeChild ( _ct ) ; } } }
function ( ) { container = document . createElement ( 'div' ) ; container . className = 'wax-legends' ; element = container . appendChild ( document . createElement ( 'div' ) ) ; element . className = 'wax-legend' ; element . style . display = 'none' ; return legend ; }
function hide ( ) { var _ct ; while ( _ct = tooltips . pop ( ) ) { if ( animate && transitionEvent ) { bean . add ( _ct , transitionEvent , remove ) ; _ct . className += ' wax-fade' ; } else { if ( _ct . parentNode ) _ct . parentNode . removeChild ( _ct ) ; } } }
function ( ) { container = document . createElement ( 'div' ) ; container . className = 'wax-legends' ; element = container . appendChild ( document . createElement ( 'div' ) ) ; element . className = 'wax-legend' ; element . style . display = 'none' ; return legend ; }
function hide ( ) { var _ct ; while ( _ct = tooltips . pop ( ) ) { if ( animate && transitionEvent ) { bean . add ( _ct , transitionEvent , remove ) ; _ct . className += ' wax-fade' ; } else { if ( _ct . parentNode ) _ct . parentNode . removeChild ( _ct ) ; } } }
function ( ) { if ( fullscreened ) { return ; } else { fullscreened = true ; } smallSize = [ map . parent . offsetWidth , map . parent . offsetHeight ] ; map . parent . className += ' wax-fullscreen-map' ; body . className += ' wax-fullscreen-view' ; ss ( map . parent . offsetWidth , map . parent . offsetHeight ) ; }
function ( ) { if ( ! fullscreened ) { return ; } else { fullscreened = false ; } map . parent . className = map . parent . className . replace ( ' wax-fullscreen-map' , '' ) ; body . className = body . className . replace ( ' wax-fullscreen-view' , '' ) ; ss ( smallSize [ 0 ] , smallSize [ 1 ] ) ; }
function ( ) { MM . addEvent ( map . parent , 'mousemove' , onMove ) ; MM . addEvent ( map . parent , 'mousedown' , onDown ) ; MM . addEvent ( map . parent , 'mouseup' , onUp ) ; tt = document . createElement ( 'div' ) ; tt . className = 'wax-latlngtooltip' ; return this ; }
function ( ) { container = document . createElement ( 'div' ) ; container . className = 'wax-legends' ; element = container . appendChild ( document . createElement ( 'div' ) ) ; element . className = 'wax-legend' ; element . style . display = 'none' ; return legend ; }
function hide ( ) { var _ct ; while ( _ct = tooltips . pop ( ) ) { if ( animate && transitionEvent ) { bean . add ( _ct , transitionEvent , remove ) ; _ct . className += ' wax-fade' ; } else { if ( _ct . parentNode ) _ct . parentNode . removeChild ( _ct ) ; } } }
function ( ) { if ( fullscreened ) { return ; } else { fullscreened = true ; } smallSize = [ map . parent . offsetWidth , map . parent . offsetHeight ] ; map . parent . className += ' wax-fullscreen-map' ; body . className += ' wax-fullscreen-view' ; ss ( map . parent . offsetWidth , map . parent . offsetHeight ) ; }
function ( ) { if ( ! fullscreened ) { return ; } else { fullscreened = false ; } map . parent . className = map . parent . className . replace ( ' wax-fullscreen-map' , '' ) ; body . className = body . className . replace ( ' wax-fullscreen-view' , '' ) ; ss ( smallSize [ 0 ] , smallSize [ 1 ] ) ; }
function ( ) { MM . addEvent ( map . parent , 'mousemove' , onMove ) ; MM . addEvent ( map . parent , 'mousedown' , onDown ) ; MM . addEvent ( map . parent , 'mouseup' , onUp ) ; tt = document . createElement ( 'div' ) ; tt . className = 'wax-latlngtooltip' ; return this ; }
function ( data ) { console . log ( "There are now" , sockets . length ) ; for ( var i = 0 , l = sockets . length ; i < l ; i ++ ) { sockets [ i ] . send ( 'Broadcasting' , data ) ; } console . dir ( data ) ; }
function ( socket ) { sockets . push ( socket ) ; socket . data ( 'Connecting' , function ( data ) { console . log ( "There are now" , sockets . length ) ; for ( var i = 0 , l = sockets . length ; i < l ; i ++ ) { sockets [ i ] . send ( 'Broadcasting' , data ) ; } console . dir ( data ) ; } ) ; }
function ( event , callback ) { if ( typeof event === 'string' ) { event = event . split ( this . _delimiter ) ; } this . once ( [ 'data' ] . concat ( event ) , callback ) ; }
function buildColorSquares ( ) { var htmlItem = '' , colors = module . colors , color ; colors = sortByAlphabet ( colors ) ; for ( color in colors ) { if ( colors . hasOwnProperty ( color ) ) { htmlItem += '<li>' + colorSquare ( colors [ color ] , color ) + '</li>' ; } } return '<ul class="debug-colors">' + htmlItem + '</ul>' ; }
function buildPanel ( ) { if ( $ ( '.debug' ) [ 0 ] ) { $panel = $ ( '' + '<div id="debug-panel">' + '<div class="inner">' + '<span>Debug panel</span>' + '<a class="debug-toggle-boxes" href="#toggle">Boxes</a>' + '<a class="debug-toggle-grid" href="#toggle">Grid</a>' + '<a href="static/styleguide">Styleguide</a>' + '</div>' + '</div>' ) . prependTo ( 'body' ) ; } }
function ( state ) { processPrefix ( state , this . prefix ) ; var cmds = [ ] ; for ( var i = 0 ; i < this . body . length ; i ++ ) { cmds . push ( this . body [ i ] ) ; } state . pushManyControls ( cmds ) ; }
function ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! ( ( s . charAt ( i ) >= "a" && s . charAt ( i ) <= "z" ) || ( s . charAt ( i ) >= "A" && s . charAt ( i ) <= "Z" ) ) ) { return false ; } } return true ; }
function ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! ( s . charAt ( i ) >= '0' && s . charAt ( i ) <= '9' ) ) { return false ; } } return true ; }
function ( aState , args ) { arrayEach ( args , function ( x , i ) { check ( aState , x , isNumber , '*' , 'number' , i + 1 , args ) ; } ) ; var result = types . rational ( 1 ) ; for ( var i = 0 ; i < args . length ; i ++ ) { result = jsnums . multiply ( args [ i ] , result ) ; } aState . v = result ; }
function ( k ) { if ( arguments . length == 3 ) { k ( arguments [ 1 ] ) ; } else { var args = [ ] ; for ( var i = 1 ; i < arguments . length - 1 ; i ++ ) { args . push ( arguments [ i ] ) ; } k ( new ValuesWrapper ( args ) ) ; } }
function ( cache ) { var buffer = [ ] ; buffer . push ( "(" ) ; buffer . push ( this . _constructorName ) ; for ( var i = 0 ; i < this . _fields . length ; i ++ ) { buffer . push ( " " ) ; buffer . push ( toWrittenString ( this . _fields [ i ] , cache ) ) ; } buffer . push ( ")" ) ; return buffer . join ( "" ) ; }
function ( ) { var toReturn = [ ] ; for ( var i = 0 ; i < this . args . length ; i ++ ) { toReturn . push ( '' + args [ i ] ) ; } return toReturn . join ( "" ) ; }
function ( args ) { var result = Empty . EMPTY ; for ( var i = args . length - 1 ; i >= 0 ; i -- ) { result = Cons . makeInstance ( args [ i ] , result ) ; } return result ; }
function ( ) { var el = document . createElement ( 'div' ) ; el . classList . add ( 'montage-popup-modal-mask' ) ; el . style . zIndex = 6999 ; el . classList . add ( 'montage-invisible' ) ; document . body . appendChild ( el ) ; return el ; }
function ( ) { var button = simpleTestPage . iframe . contentDocument . getElementsByClassName ( "montage-button" ) [ 0 ] ; var text = simpleTestPage . iframe . contentDocument . getElementsByClassName ( "dynamictext" ) [ 1 ] ; expect ( button ) . not . toBeNull ( ) ; expect ( button . textContent ) . toEqual ( "Button" ) ; expect ( text ) . not . toBeNull ( ) ; expect ( text . textContent ) . toEqual ( "Custom Test Value" ) ; }
function ( ) { var button0 = repetitionTestPage . iframe . contentDocument . querySelectorAll ( ".list2 .montage-button" ) [ 0 ] ; var text0 = repetitionTestPage . iframe . contentDocument . querySelectorAll ( ".list2 .dynamictext" ) [ 0 ] ; expect ( button0 ) . not . toBeNull ( ) ; expect ( button0 . textContent ) . toEqual ( "Button" ) ; expect ( text0 ) . not . toBeNull ( ) ; expect ( text0 . textContent ) . toEqual ( "Custom Test Value" ) ; }
function ( ) { var repetition = list . _element . querySelector ( '*[data-montage-id="repetition"]' ) . controller ; expect ( repetition ) . toBeDefined ( ) ; expect ( repetition . _items . length ) . toBe ( 3 ) ; expect ( list . _element . querySelectorAll ( ".montage-slider" ) . length ) . toBe ( 3 ) ; }
function ( ) { if ( this . getConfig ( 'restrictedUserAgentTitle' ) && this . getConfig ( 'restrictedUserAgentMessage' ) ) { return this . getConfig ( 'restrictedUserAgentTitle' ) + "\n" + this . getConfig ( 'restrictedUserAgentMessage' ) ; } else { return this . embedPlayer . getKalturaMsg ( 'USER_AGENT_RESTRICTED' ) ; } }
function ( ) { var cameraId = $ ( ".delete_camera_button" ) . data ( "camera-id" ) ; if ( ! cameraId ) { debug ( "failed to find cameraId on delete button" ) ; return ; } $ ( ".delete_camera_button" ) . click ( function ( ) { Panoptic . ajaxDelete ( "/api/rest/camera/" + cameraId , { } , function ( ) { $ . mobile . changePage ( "/camera/list" ) ; } ) } ) ; }
function getReadingListForTag ( tagName , callback ) { getReadingList ( function gotReadingList ( error , model ) { if ( error ) return callback ( error ) ; var itemsForTag = _ . chain ( model ) . filter ( function ( item ) { return _ ( item . tags ) . contains ( tagName ) ; } ) . value ( ) ; callback ( null , itemsForTag ) ; } ) ; }
function getReadingList ( callback ) { var original = toReadingListItems ( require ( '../test/assets/reading_list.json' ) ) ; var additional = toReadingListItems ( require ( '../test/assets/reading_list_since.json' ) . list ) ; var readingListModel = getUpdatedReadingList ( original , additional ) ; callback ( null , readingListModel ) ; }
function TopLevelPage ( id , name , href , title ) { this . id = id ; this . name = name ; this . href = href ; this . title = title ; return this ; }
function ( renderingTopLevelPage ) { return { href : this . href , text : this . name , name : this . name , title : this . title , classes : this . activeIfEquals ( renderingTopLevelPage ) } ; }
function SharedViewModel ( currentTopLevelPage , readingListTags , additional ) { if ( ! currentTopLevelPage ) throw new Error ( 'top level page must be defined' ) ; this . currentTopLevelPage = currentTopLevelPage ; this . title = currentTopLevelPage . title ; this . topLevelMenuItems = getTopLevelMenuItems ( currentTopLevelPage ) ; this . pageTemplateName = currentTopLevelPage . id ; this . readingListTags = readingListTags ; if ( additional ) { _ . extend ( this , additional ) ; } this . extend = function ( extendedModel ) { return _ . extend ( this , extendedModel ) ; } ; return this ; }
function gotIndexViewModelData ( err , results ) { if ( err ) return callback ( err ) ; var viewModel = buildIndexViewModel ( results . posts , results . shared ) ; callback ( err , viewModel ) ; }
function buildPostViewModel ( postId , indexViewModel , sharedViewModel ) { var post = _ . chain ( indexViewModel . posts ) . filter ( function ( post ) { return post . id == postId ; } ) . first ( ) . value ( ) ; return sharedViewModel . extend ( { title : post ? post . title : sharedViewModel . currentTopLevelPage . title , post : post , pageTemplateName : 'post' } ) ; }
function onGotAsyncData ( err , results ) { if ( err ) return callback ( err ) ; var viewModel = buildPostViewModel ( postId , results . index , results . shared ) ; if ( ! viewModel . post ) { return callback ( new NotFoundError ( "Unable to find post with id " + postId ) ) ; } callback ( err , viewModel ) ; }
function buildReadingListViewModel ( readingListItems , sharedViewModel ) { return sharedViewModel . extend ( { items : readingListItems } ) ; }
function getReadingListViewModel ( callback ) { async . parallel ( { readingListItems : rl . getReadingList , shared : asyncify ( getSharedViewModel , topLevelPages . reading ) } , function onGotAsyncData ( err , results ) { if ( err ) return callback ( err ) ; var model = buildReadingListViewModel ( results . readingListItems , results . shared ) ; callback ( null , model ) ; } ) ; }
function buildReadingTagViewModel ( tagName , readingListItemsForTag , sharedViewModel ) { var tag = _ . chain ( sharedViewModel . readingListTags ) . find ( function ( tag ) { return tag . name === tagName ; } ) . value ( ) ; return sharedViewModel . extend ( { title : 'Reading list for tag [' + tagName + ']' , tag : tag , items : readingListItemsForTag } ) ; }
function onGotAsyncData ( err , results ) { if ( err ) return callback ( err ) ; var model = buildReadingTagViewModel ( tagName , results . readingListForTag , results . shared ) ; if ( ! model . tag ) return callback ( new NotFoundError ( 'The reading list tag ' + tagName + ' was not found' ) ) ; callback ( null , model ) ; }
function ( err , model ) { res . render ( model . pageTemplateName , model ) ; }
function ( error , viewModel ) { if ( error ) throw error ; res . render ( viewModel . pageTemplateName , viewModel ) ; }
function getValue ( ) { var text = [ ] ; doc . iter ( 0 , doc . size , function ( line ) { text . push ( line . text ) ; } ) ; return text . join ( "\n" ) ; }
function done ( e ) { clearTimeout ( going ) ; var cur = posFromMouse ( e ) ; if ( cur ) setSelectionUser ( start , cur ) ; e_preventDefault ( e ) ; focusInput ( ) ; updateInput = true ; move ( ) ; up ( ) ; }
function onDoubleClick ( e ) { for ( var n = e_target ( e ) ; n != wrapper ; n = n . parentNode ) if ( n . parentNode == gutterText ) return e_preventDefault ( e ) ; var start = posFromMouse ( e ) ; if ( ! start ) return ; lastDoubleClick = { time : + new Date , pos : start } ; e_preventDefault ( e ) ; selectWordAt ( start ) ; }
function onDragStart ( e ) { var txt = getSelection ( ) ; e . dataTransfer . setData ( "Text" , txt ) ; if ( gecko || chrome ) { var img = document . createElement ( 'img' ) ; img . scr = 'data:image/gif;base64,R0lGODdhAgACAIAAAAAAAP///ywAAAAAAgACAAACAoRRADs=' ; e . dataTransfer . setDragImage ( img , 0 , 0 ) ; } }
function handleCharBinding ( e , ch ) { var handled = lookupKey ( "'" + ch + "'" , options . extraKeys , options . keyMap , function ( b ) { return doHandleBinding ( b , true ) ; } ) ; if ( handled ) e_preventDefault ( e ) ; return handled ; }
function onFocus ( ) { if ( options . readOnly == "nocursor" ) return ; if ( ! focused ) { if ( options . onFocus ) options . onFocus ( instance ) ; focused = true ; if ( wrapper . className . search ( /\bCodeMirror-focused\b/ ) == - 1 ) wrapper . className += " CodeMirror-focused" ; if ( ! leaveInputAlone ) resetInput ( true ) ; } slowPoll ( ) ; restartBlink ( ) ; }
function onBlur ( ) { if ( focused ) { if ( options . onBlur ) options . onBlur ( instance ) ; focused = false ; if ( bracketHighlighted ) operation ( function ( ) { if ( bracketHighlighted ) { bracketHighlighted ( ) ; bracketHighlighted = null ; } } ) ( ) ; wrapper . className = wrapper . className . replace ( " CodeMirror-focused" , "" ) ; } clearInterval ( blinker ) ; setTimeout ( function ( ) { if ( ! focused ) shiftSelecting = null ; } , 150 ) ; }
function scrollEditorIntoView ( ) { if ( ! cursor . getBoundingClientRect ) return ; var rect = cursor . getBoundingClientRect ( ) ; if ( ie && rect . top == rect . bottom ) return ; var winH = window . innerHeight || Math . max ( document . body . offsetHeight , document . documentElement . offsetHeight ) ; if ( rect . top < 0 || rect . bottom > winH ) cursor . scrollIntoView ( ) ; }
function scrollCursorIntoView ( ) { var cursor = localCoords ( sel . inverted ? sel . from : sel . to ) ; var x = options . lineWrapping ? Math . min ( cursor . x , lineSpace . offsetWidth ) : cursor . x ; return scrollIntoView ( x , cursor . y , x , cursor . yBot ) ; }
function rehide ( ) { var newVal = splitLines ( input . value ) . join ( "\n" ) ; if ( newVal != val ) operation ( replaceSelection ) ( newVal , "end" ) ; inputDiv . style . position = "relative" ; input . style . cssText = oldCSS ; if ( ie_lt9 ) scroller . scrollTop = scrollPos ; leaveInputAlone = false ; resetInput ( true ) ; slowPoll ( ) ; }
function e_button ( e ) { if ( e . which ) return e . which ; else if ( e . button & 1 ) return 1 ; else if ( e . button & 2 ) return 3 ; else if ( e . button & 4 ) return 2 ; }
function ( ) { var sel = $ ( this ) ; if ( sel . data ( 'freetrans' ) ) { _setOptions ( sel , options ) ; } else { _init ( sel , options ) ; } }
function ( urls ) { mongoose . connectSet ( connectionUrls . join ( ',' ) , function ( error ) { if ( error ) { console . log ( 'Error:Couldnt connect' , error ) ; setTimeout ( function ( ) { exports . connectSet ( urls ) ; } , 2000 ) ; } else { createModel ( ) ; } } ) ; }
function ( ) { var data = localStorage . getItem ( localStorageKey ) , key ; if ( data === null ) return ; try { data = JSON . parse ( data ) } catch ( err ) { return ; } for ( key in data ) { if ( data . hasOwnProperty ( key ) && ! httpCache . utils . isStale ( data [ key ] ) ) { set ( key , data [ key ] ) ; } } }
function ( ) { info = Url . parse ( process . env . REDISTOGO_URL || 'redis://localhost:6379' ) ; rclient = Redis . createClient ( info . port , info . hostname ) ; if ( info . auth ) { rclient . auth ( info . auth . split ( ":" ) [ 1 ] ) ; } domain = process . env . HEROKU_URL || "http://localhost:3000" ; hostname = Url . parse ( domain ) . hostname ; console . log ( hostname ) ; }
function ( ) { var U = Union ( { 'ival' : 'int' , 'lval' : 'long' , 'sval' : 'string' } ) assert . strictEqual ( ref . types . int , U . fields . ival . type ) assert . strictEqual ( ref . types . long , U . fields . lval . type ) assert . strictEqual ( ref . types . Utf8String , U . fields . sval . type ) }
function ( client , data ) { this . _super ( client , data ) ; this . skinCoordinates = [ 0 , 60 , 80 , 80 ] ; this . animationList = { 'walking' : { numFrame : 8 , looping : true } , 'action_0' : { numFrame : 13 , looping : false } , 'action_1' : { numFrame : 9 , looping : false } , } ; if ( data == undefined ) { this . attributes . skin = '' ; this . activity = 0 ; } }
function ( ) { var el , len ; if ( this . objectsList ) len = this . objectsList . length ; else len = 0 ; for ( el = 0 ; el < len ; el ++ ) this . objectsList [ el ] . clearTrace ( ) ; this . numTraces = 0 ; return this ; }
function ( event ) { if ( event . keyCode == 27 ) { input . attr ( "value" , "" ) ; textFilter ( ) ; } if ( event . keyCode == 9 ) { $ ( "#template" ) . contents ( ) . find ( "#mbrsel-input" ) . focus ( ) ; input . attr ( "value" , "" ) ; return false ; } }
function updateState ( ) { switching = false ; var currentNetwork = gWifiManager . connection . network ; if ( currentNetwork ) { infoBlock . textContent = _ ( 'fullStatus-connected' , currentNetwork ) ; checkbox . checked = true ; } else if ( gWifiManager . enabled ) { infoBlock . textContent = _ ( 'fullStatus-disconnected' ) ; checkbox . checked = true ; } else { infoBlock . textContent = _ ( 'disabled' ) ; checkbox . checked = false ; } }
function toggleWifi ( ) { if ( switching ) return ; switching = true ; var req ; if ( gWifiManager . enabled ) { gNetworkList . clear ( ) ; infoBlock . textContent = '' ; req = gWifiManager . setEnabled ( false ) ; } else { req = gWifiManager . setEnabled ( true ) ; req . onerror = function ( ) { gNetworkList . autoscan = false ; } ; } }
function ( ) { var values = [ ] ; $ ( '.vertical-tabs-og_nodeapi #edit-og-groups :selected' ) . each ( function ( i , selected ) { values [ i ] = $ ( selected ) . text ( ) ; } ) ; return values . join ( ', ' ) ; }
function ( jQuery ) { Aloha . jQuery = jQuery ; require ( requireConfig , [ 'vendor/jquery.json-2.2.min' , 'vendor/jquery.store' , 'aloha/rangy-core' , 'util/class' , 'util/lang' , 'util/range' , 'util/dom' , 'aloha/core' , 'aloha/editable' , 'aloha/console' , 'aloha/markup' , 'aloha/message' , 'aloha/plugin' , 'aloha/selection' , 'aloha/command' , 'aloha/jquery.aloha' , 'aloha/sidebar' , 'util/position' , 'aloha/repositorymanager' , 'aloha/repository' , 'aloha/repositoryobjects' , 'aloha/contenthandlermanager' ] , function ( ) { jQuery ( Aloha . init ) ; } ) ; }
function getPinState ( ) { var state = { } ; if ( store . get ( 'Aloha.FloatingMenu.pinned' ) === 'true' ) { return { top : parseInt ( store . get ( 'Aloha.FloatingMenu.top' ) , 10 ) , left : parseInt ( store . get ( 'Aloha.FloatingMenu.left' ) , 10 ) , isPinned : true } ; } return { top : null , left : null , isPinned : false } ; }
function ( ) { sketch ( { width : 200 , height : 300 , canvas : document . getElementById ( 'canvas' ) , draw : function ( ctx , images ) { ctx . fillStyle = '#0f0' ; ctx . fillRect ( 0 , 0 , 50 , 50 ) ; } } ) ; }
function ( ) { for ( var i = 0 ; i < arguments . length ; i ++ ) { var scriptEl = doc . createElement ( 'script' ) ; scriptEl . src = window . Worker . baseURI + script ; scriptEl . type = 'text/javascript' ; doc . body . appendChild ( scriptEl ) ; } }
function autoScroll ( ) { var delta = this . mousePos . x / this . width - .5 ; if ( ( this . mouseDownPos . x > this . width / 2 ) ? delta > 0 : delta < 0 ) { this . view . move ( 10 * ( delta ) * this . view . zoom ) ; this . render ( ) ; } }
function initScroll ( ) { if ( this . mouseDownPos . x < this . width / 2 ) { this . currentCursor = 'resizeL' ; this . canvas . style . cursor = this . cursors . resizeL ; } else { this . currentCursor = 'resizeR' ; this . canvas . style . cursor = this . cursors . resizeR ; } this . scrollInterval = setInterval ( autoScroll . bind ( this ) , 1 ) ; }
function mapreduce ( body , init ) { return numeric . Function ( 'x' , 'accum' , '_s' , '_k' , 'if(typeof accum === "undefined") accum = ' + init + ';\n' + 'if(typeof x === "number") { var xi = x; ' + body + ' return accum; }\n' + 'if(typeof _s === "undefined") _s = numeric.dim(x);\n' + 'if(typeof _k === "undefined") _k = 0;\n' + 'var _n = _s[_k];\n' + 'var i,xi;\n' + 'if(_k < _s.length-1) {\n' + '    for(i=_n-1;i>=0;i--) {\n' + '        accum = arguments.callee(x[i],accum,_s,_k+1);\n' + '    }' + '    return accum;\n' + '}\n' + 'for(i=_n-1;i>=1;i-=2) { \n' + '    xi = x[i];\n' + '    ' + body + ';\n' + '    xi = x[i-1];\n' + '    ' + body + ';\n' + '}\n' + 'if(i === 0) {\n' + '    xi = x[i];\n' + '    ' + body + '\n' + '}\n' + 'return accum;' ) ; }
function Parser ( options ) { options = options || { } ; this . _buffer = null ; this . _longPacketBuffers = [ ] ; this . _offset = 0 ; this . _packetEnd = null ; this . _packetHeader = null ; this . _onPacket = options . onPacket || function ( ) { } ; this . _nextPacketNumber = 0 ; this . _encoding = 'utf-8' ; this . _paused = false ; }
function ( ) { if ( ! that . onlineUsersBox . is ( ':hidden' ) ) { that . onlineUsersBox . slideUp ( ) ; } that . configurationBox . slideToggle ( ) ; return false ; }
function ( ) { return this . bar . hasClass ( "online" ) ; }
function ( event ) { if ( event . keyCode == 13 ) { event . preventDefault ( ) ; that . send ( ) ; } }
function ( ) { it ( 'should call _log with level info' , function ( ) { logger . info . andCallThrough ( ) ; logger . info ( 'message' , error ) ; expect ( logger . _log ) . toHaveBeenCalledWith ( 'info' , 'message' , error ) ; } ) ; }
function ( ) { event . level . andReturn ( 'fatal' ) ; process . platform = 'win32' ; var appender = new ConsoleAppender ( 'fatal' , layout , options ) ; appender . _write ( 'Some message' , event ) ; expect ( console . log ) . toHaveBeenCalledWith ( 'Some message' ) ; }
function ( e ) { if ( e . which != 9 ) return ; if ( ! e . ctrlKey && ! e . altKey && ! e . shiftKey && tinymce . activeEditor && ! tinymce . activeEditor . isHidden ( ) ) { $ ( 'td.mceToolbar > a' ) . focus ( ) ; e . preventDefault ( ) ; } }
function ( _ , slash , format , key , capture , optional , star ) { keys . push ( { name : key , optional : ! ! optional } ) ; slash = slash || '' ; return '' + ( optional ? '' : slash ) + '(?:' + ( optional ? slash : '' ) + ( format || '' ) + ( capture || ( format && '([^/.]+?)' || '([^/]+?)' ) ) + ')' + ( optional || '' ) + ( star ? '(/*)' : '' ) ; }
function ( done ) { var app = express ( ) ; app . get ( '/file/*' , function ( req , res ) { res . end ( req . params [ 0 ] ) ; } ) ; request ( app ) . get ( '/file/javascripts/jquery.js' ) . expect ( 'javascripts/jquery.js' , done ) ; }
function ( ) { var active_editable_obj = this . getBaseElement ( ) ; if ( ! active_editable_obj ) { return ; } $ ( Aloha . activeEditable . obj ) . attr ( 'aloha-numerated-headers' , 'false' ) ; var headingselector = this . getCurrentConfig ( ) . headingselector ; var headers = active_editable_obj . find ( headingselector ) ; headers . each ( function ( ) { $ ( this ) . find ( 'span[role=annotation]' ) . each ( function ( ) { $ ( this ) . remove ( ) ; } ) ; } ) ; }
function ( ) { if ( typeof this . baseobjectSelector !== 'undefined' ) { return ( $ ( this . baseobjectSelector ) . length > 0 ) ? $ ( this . baseobjectSelector ) : null ; } return Aloha . activeEditable ? Aloha . activeEditable . obj : null ; }
function ( snapshot , callback ) { var _winA = _IsWinner ( snapshot . A , snapshot . Players ( ) . Player1 ) ; if ( _winA . won ) { callback ( _winA ) ; } var _winB = _IsWinner ( snapshot . B , snapshot . Players ( ) . Player2 ) ; if ( _winB . won ) { callback ( _winB ) ; } }
function ( ) { var that = this ; this . board . pick ( this . players , 'A1' , function ( snapshot ) { snapshot . A . should . eql ( [ 'A1' ] ) ; that . findsWinner . didIWin ( snapshot , function ( win ) { win . won . should . be . false ; } ) ; } ) ; }
function write ( view , truthy ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; if ( ! ! truthy ) { if ( view . is ( ":empty" ) ) { var render = view . data ( hdRenderName ) ; var copy = render ( ) ; view . append ( copy ) ; } } else { view . empty ( ) ; } }
function ( key , encoder ) { var encodedVal , val ; val = _this . get ( key ) ; if ( encoder . encode && typeof val !== 'undefined' ) { encodedVal = encoder . encode ( val , key , obj , _this ) ; if ( typeof encodedVal !== 'undefined' ) { return obj [ encoder . as ] = encodedVal ; } } }
function ( key , encoder ) { var encodedVal , val ; val = _this . get ( key ) ; if ( encoder . encode && typeof val !== 'undefined' ) { encodedVal = encoder . encode ( val , key , obj , _this ) ; if ( typeof encodedVal !== 'undefined' ) { return obj [ encoder . as ] = encodedVal ; } } }
function ( citation , reference , option ) { var options = getCitationOptions ( ) ; options [ citation ] = options [ citation ] || { } ; options [ citation ] [ reference ] = option ; setCitationOptions ( options ) ; }
function ( citation , reference ) { var options = getCitationOptions ( ) ; if ( ! options . hasOwnProperty ( citation ) ) { return 0 ; } if ( ! options [ citation ] . hasOwnProperty ( reference ) ) { return 0 ; } return options [ citation ] [ reference ] ; }
function ( ) { setup_naming ( ) ; }
function deleteProject ( obj , objid ) { var id = parseInt ( objid . attr ( "id" ) . substr ( 3 ) ) ; if ( ! confirm ( "您将删除该项目以及关联楼宇、房产、业主、物业费信息,确定删除吗?" ) ) return ; $ . ajax ( { type : "POST" , url : 'deleteProject?projectId=' + id , dataType : "json" , success : function ( data ) { obj . hide ( ) ; } } ) ; }
function ( obj , eventName , listener ) { obj = makeDomElement ( obj ) ; if ( obj . length ) { for ( var i = 0 , l = obj . length ; i < l ; i ++ ) { bindEvent ( obj [ i ] , eventName , listener ) ; } } else { bindEvent ( obj , eventName , listener ) ; } }
function manualOnClick ( info , tab ) { var imageUrl = info . linkUrl != null ? info . linkUrl : info . srcUrl ; var manualCheck = /\[\d+-\d+\]/ ; var url = prompt ( "Please enter the url" , imageUrl ) ; if ( url ) { if ( manualCheck . exec ( url ) == null ) { alert ( "This is not a valid fusk - http://example.com/[1-8].jpg" ) ; return false ; } createTab ( url , tab ) ; } }
function ( url , groupNumber ) { var links = [ ] ; groupNumber = groupNumber || 0 ; if ( ret . IsFuskable ( url ) ) { var matches = regex . exec ( url ) ; links = GetUrls ( matches [ 1 ] , matches [ 4 ] , matches [ 2 ] , matches [ 3 ] , groupNumber ) ; } return links ; }
function ( deg ) { var rotate = 'rotate(' + ( deg ) + 'deg);' ; var tr = new Array ( 'transform:' + rotate , '-moz-transform:' + rotate , '-webkit-transform:' + rotate , '-ms-transform:' + rotate , '-o-transform:' + rotate ) ; var drone = document . getElementById ( 'drone' ) ; drone . setAttribute ( 'style' , tr . join ( ';' ) ) ; }
function ( service , name ) { name = name . split ( ':' ) [ 1 ] ; if ( service === null ) { callback ( null , name ) ; return ; } callback ( new Reference ( self , [ 'channel' , name , 'channel:' + name ] , service . _operations ) , name ) ; }
function ( ) { var iW = $ ( this ) . width ( ) ; var iH = $ ( this ) . height ( ) ; $ ( this ) . attr ( { width : iW , height : iH } ) . fadeIn ( 400 ) ; $ ( '#showbox-loader' ) . hide ( ) ; $ ( '#showbox .showbox-menubar' ) . show ( ) ; ShowBox . RESIZE ( ) ; }
function ( match , isBlock ) { this . pos = match . index + match [ 0 ] . length ; var classedRun = this . parseClassedRun ( /(\r?\n)/mg ) ; return [ $tw . Tree . Element ( "h1" , { "class" : classedRun [ "class" ] } , classedRun . tree ) ] ; }
function handleBuild ( ) { var node = $ ( this ) , action = node . attr ( 'id' ) . split ( "-" ) [ 2 ] ; if ( node . hasClass ( "not-ready" ) ) { return ; } if ( ! settings . can ( action ) ) { settings . show ( action ) ; } else { settings . perform ( action ) ; } }
function ( ) { $ ( "#options-menu-build" ) . click ( handleBuild ) ; $ ( "#options-menu-sign" ) . click ( handleBuild ) ; $ ( "#options-menu-launch" ) . click ( handleBuild ) ; $ ( "#options-menu-settings" ) . click ( function ( ) { settings . show ( ) ; } ) ; if ( settings . value ( "remoteInspector" ) ) { $ ( "#options-menu-build-warning" ) . show ( ) ; tooltip . create ( "#options-menu-build-warning" , "Remote Web Inspector should be disabled when packaging for App World release" ) ; } }
function ( suite ) { var results = suite . results ( ) ; var status = results . passed ( ) ? 'passed' : 'failed' ; if ( results . totalCount == 0 ) { status = 'skipped' ; } this . suiteDivs [ suite . id ] . className += " " + status ; }
function callbackOrEvent ( event , args ) { if ( _ . isFunction ( callback ) ) { if ( event == 'error' ) { callback ( args ) ; } else { callback ( null , args ) ; } } else { self . emit ( event , args ) ; } }
function ( str , terminal ) { try { forth . runString ( str ) ; } catch ( err ) { terminal . error ( err ) ; } forth . redrawStack ( ) ; }
function ( ) { BF . include ( "/js/secondary.js?16428409" , { content_manager : content_manager , langEl : langEl , page : page , qEl : qEl , settings : settings , system : system , run_new_query : run_new_query , topBar : topBar , viewPort_num : viewPort_num } ) ; }
function ( transport ) { if ( transport . responseText . isJSON ( ) ) { var json = transport . responseText . evalJSON ( ) ; loadAttachmentListCallback ( json , false , true ) ; } else if ( ( typeof console != 'undefined' ) && ( typeof console . debug != 'undefined' ) ) { console . debug ( 'loadSlideShowDataAsync: noJSON!!! ' , transport . responseText ) ; } }
function ( ) { this . set ( "corpusname" , window . app . get ( "corpus" ) . get ( "corpusname" ) ) ; }
function getKsFile ( pluginName ) { if ( ! ( pluginName == "" ) ) { consoleLog ( 'Kickstrap: Loading add-on "' + pluginName + '"' ) ; var ksURL = addOnLocation + pluginName + "/config.ks" ; $ . ajax ( { type : "GET" , url : ksURL , dataType : "text" , success : function ( data ) { processKs ( data , pluginName ) ; } } ) ; } }
function getKsFile ( pluginName ) { if ( ! ( pluginName == "" ) ) { consoleLog ( 'Kickstrap: Loading add-on "' + pluginName + '"' ) ; var ksURL = addOnLocation + pluginName + "/config.ks" ; $ . ajax ( { type : "GET" , url : ksURL , dataType : "text" , success : function ( data ) { processKs ( data , pluginName ) ; } } ) ; } }
function cursorX ( elem , evt ) { if ( isFixed ( elem ) ) { var bodyLeft = parseInt ( document . defaultView . getComputedStyle ( document . body , "" ) . marginLeft , 10 ) - calc ( elem , 'scrollLeft' ) + elem . style . marginLeft ; return evt . clientX - bodyLeft ; } if ( evt . pageX ) return evt . pageX ; else if ( evt . clientX ) return evt . clientX + document . body . scrollLeft ; }
function cursorY ( elem , evt ) { if ( isFixed ( elem ) ) { var bodyTop = parseInt ( document . defaultView . getComputedStyle ( document . body , "" ) . marginTop , 10 ) - calc ( elem , 'scrollTop' ) + elem . style . marginTop ; return evt . clientY - bodyTop ; } if ( evt . pageY ) return evt . pageY ; else if ( evt . clientY ) return evt . clientY + document . body . scrollTop ; }
function ( media ) { this . inherited ( arguments ) ; if ( this . useHtml5Player ) { return ; } mulberry . app . PhoneGap . video . play ( this . media . url ) ; }
function ( self , menuTrigger ) { step . menu . tickOneItemInMenuGroup ( menuTrigger ) ; var menuItem = menuTrigger . menuItem ; step . navigation . showBottomSection ( menuItem ) ; if ( menuItem . name == "TIMELINE" ) { $ . shout ( "show-timeline" , { passageId : step . passage . getPassageId ( menuItem ) } ) ; } else if ( menuTrigger . menuItem . name == "GEOGRAPHY" ) { $ . shout ( "show-maps" , { passageId : step . passage . getPassageId ( menuItem ) } ) ; } }
function preremplirFormulaireModifEntreprise ( event ) { if ( typeof Annuaire . infoEntrepriseCourante . description !== "undefined" ) { $ ( '#formUpdateEntrepriseId' ) . val ( Annuaire . infoEntrepriseCourante . description . id_entreprise ) ; $ ( '#formUpdateEntrepriseNom' ) . val ( Annuaire . infoEntrepriseCourante . description . nom ) ; $ ( '#formUpdateEntrepriseSecteur' ) . val ( Annuaire . infoEntrepriseCourante . description . secteur ) ; $ ( '#formUpdateEntrepriseDescription' ) . val ( Annuaire . infoEntrepriseCourante . description . description ) ; } }
function afficherLibelle ( libelle , classesSup ) { if ( libelle == 'Pro' ) { return '<span title="Pro" class="label ' + classesSup + '"><i class="icon-book"></i></span>' } ; if ( libelle == 'Perso' ) { return '<span title="Perso" class="label ' + classesSup + '"><i class="icon-home"></i></span>' } ; if ( libelle == 'Bureau' ) { return '<span title="Bureau" class="label ' + classesSup + '"><i class="icon-home"></i></span>' } ; if ( libelle == 'Fixe' ) { return '<span title="Fixe" class="label ' + classesSup + '"><i class="icon-home"></i></span>' } ; if ( libelle == 'Mobile' ) { return '<span title="Mobile" class="label ' + classesSup + '"><i class="icon-road"></i></span>' } ; return '<span title="' + libelle + '" class="label ' + classesSup + '"><i class="icon-question-sign"></i></span>' ; }
function ( connection ) { delete connection . query ; connectionPool . push ( connection ) ; if ( mainQueue . length ) { process . nextTick ( function ( ) { this . getConnection ( mainQueue . shift ( ) ) ; } . bind ( this ) ) ; } ; }
function ( ) { Component . prototype . initialize . apply ( this , arguments ) ; return this . set ( "type" , "Video" ) ; }
function ( ) { var $video ; ComponentView . prototype . render . call ( this ) ; $video = $ ( "<video src=" + ( this . model . get ( 'src' ) ) + "></video>" ) ; this . $el . find ( ".content" ) . append ( $video ) ; return this . $el ; }
function renderCallback ( ) { if ( options . partial ( root . el , name , view . el , append ) ) { view . __manager__ . hasRendered = true ; } view . delegateEvents ( ) ; view . __manager__ . handler . resolveWith ( view , [ view . el ] ) ; viewDeferred . resolveWith ( view , [ view . el ] ) ; if ( _ . isFunction ( done ) ) { done . call ( view , view . el ) ; } }
function ( manage ) { if ( _ . isFunction ( this . beforeRender ) ) { this . beforeRender . call ( this , this ) ; } this . trigger ( "beforeRender" , this ) ; return manage ( this ) . render ( ) . then ( function ( ) { if ( _ . isFunction ( this . afterRender ) ) { this . afterRender . call ( this , this ) ; } this . trigger ( "afterRender" , this ) ; } ) ; }
function ( params ) { for ( var i in params ) { this . indexCode ++ ; if ( this . indexCode > 122 ) throw new Error ( "tarps.get(): Number of allowed prepare statement params has been exceeded. This restriction will be removed in future versions." ) ; conn . query ( "SET @" + String . fromCharCode ( this . indexCode ) + " = \"" + params [ i ] + "\"" ) ; } }
function remove ( key , interceptor ) { var arr = interceptors [ key ] ; if ( arr ) { arr . splice ( arr . indexOf ( interceptor ) , 1 ) ; if ( arr . length === 0 ) { console . log ( 'deleting interceptor for ' , key ) ; delete interceptors [ key ] ; } } }
function ( ) { nock . restore ( ) ; ret = nock . recorder . play ( ) ; t . equal ( ret . length , 1 ) ; t . equal ( ret [ 0 ] . indexOf ( "\nnock('expensecat.iriscouch.com')\n  .post('/, \"ABCDEF\")\n  .(" ) , 0 ) ; t . end ( ) ; }
function ( texture , path ) { this . _pathsToTextures [ path ] = texture ; var materialContainers = this . _pathsToMaterials [ path ] ; for ( var i = 0 ; i < materialContainers . length ; i ++ ) { var materialContainer = materialContainers [ i ] ; var material = materialContainer . material ; var property = materialContainer . property ; material [ property ] = texture ; } }
function put ( obj , flag ) { var storage = _selectStorage ( flag ) ; if ( typeof obj !== 'object' ) { throw new Error ( '1st argument should be object' ) ; } for ( var i in obj ) { if ( obj . hasOwnProperty ( i ) ) { storage . setItem ( i , JSON . stringify ( obj [ i ] ) ) ; } } }
function ( id , questionTitle , questionBody , callback ) { console . log ( "API - updateQuestionById" ) ; var body = { } ; body . questionTitle = questionTitle ; body . questionBody = questionBody ; $ . ajax ( { url : '/api/question/' + id , type : 'PUT' , dataType : 'json' , contentType : "application/json" , data : JSON . stringify ( body ) , success : function ( data ) { callback ( data ) ; } } ) ; }
function clearLocal ( ) { if ( window . localStorage ) { var storage = window . localStorage ; var i = 0 ; var lim = storage . length ; var keys = [ ] ; while ( i < lim ) keys . push ( storage . key ( i ++ ) ) ; i = 0 ; while ( i < lim ) storage . removeItem ( keys [ i ++ ] ) ; } }
function ( container , collData , docData ) { var dispatcher = new Dispatcher ( ) ; var visualizer = new Visualizer ( dispatcher , container ) ; docData . collection = null ; dispatcher . post ( 'collectionLoaded' , [ collData ] ) ; dispatcher . post ( 'renderData' , [ docData ] ) ; return dispatcher ; }
function ( ) { if ( svg && isRenderRequested && isCollectionLoaded && areFontsLoaded ) { isRenderRequested = false ; if ( doc . length ) { Util . profileClear ( ) ; Util . profileStart ( 'before render' ) ; renderDocument ( ) ; } else { dispatcher . post ( 0 , 'renderError:noFileSpecified' ) ; } } }
function _create ( aField ) { if ( Array . isArray ( aField ) ) { for ( let i = 0 ; i < aField . length ; i ++ ) { if ( typeof aField [ i ] !== "string" ) aField [ i ] = String ( aField [ i ] ) ; } return aField ; } else if ( aField != null ) { return [ String ( aField ) ] ; } }
function resolveMultiname ( obj , multiname ) { assert ( ! multiname . isQName ( ) , multiname + " already resolved" ) ; obj = Object ( obj ) ; for ( var i = 0 , j = multiname . namespaces . length ; i < j ; i ++ ) { var qn = multiname . getQName ( i ) ; if ( qn . getQualifiedName ( ) in obj ) { return qn ; } } return undefined ; }
function ( v , k ) { var combination = { } ; if ( paramsParsed ) { combination . expression = v ; combination . keys = k ; } else { v = v . split ( /\s+on\s+/i ) ; combination . expression = v [ 0 ] ; combination . keys = v [ 1 ] ; } combination . keys = combination . keys . split ( '-' ) ; combinations . push ( combination ) ; }
function ( ) { it ( "stubs modules in given context" , function ( ) { require ( './stubber' ) . stubbed . should . equal ( 'stubbed module' ) ; } ) ; it ( "stubs modules in child context" , function ( ) { require ( './stubber' ) . child . stubbed . should . equal ( 'stubbed module' ) ; } ) ; it ( "doesn't stub in parent context" , function ( ) { ( function ( ) { require ( 'stubbed' ) ; } ) . should . Throw ( "Cannot find module 'stubbed'" ) ; } ) ; }
function ( dividers ) { this . element . removeChild ( this . _eventDividersElement ) ; for ( var i = 0 ; i < dividers . length ; ++ i ) { if ( dividers [ i ] ) this . _eventDividersElement . appendChild ( dividers [ i ] ) ; } this . element . appendChild ( this . _eventDividersElement ) ; }
function ( msg ) { if ( msg [ 'id' ] == id ) { success = msg [ 'result' ] ; if ( success && this . onsuccess ) { result = msg [ 'result' ] ; if ( JRObject . is_jrobject ( result ) ) result = JRObject . from_json ( result ) ; this . onsuccess ( result ) ; } else if ( ! success && this . onfailed ) this . onfailed ( msg [ 'error' ] [ 'code' ] , msg [ 'error' ] [ 'message' ] ) ; } }
function ( $routeProvider ) { $routeProvider . when ( '/foo' , { template : 'foo.html' } ) ; $routeProvider . when ( '/bar/' , { template : 'bar.html' } ) ; }
function ( header ) { for ( var h = this . count ( ) - 1 ; h >= 0 ; h -- ) { if ( this . headers [ h ] . className === header . className ) { throw new Error ( "You cannot add the same header twice" ) ; } } this . headers . push ( header ) ; this . headers . sort ( function ( a , b ) { return a . priority || 0 - b . priority || 0 } ) ; }
function ( event ) { var ev = window . event || event ; var evType = String ( ev . type ) ; var menu = eXo . core . DOMUtil . findFirstDescendantByClass ( this , "div" , "HoverMenu" ) ; if ( evType == "mouseover" || evType == "onfocus" ) { menu . style . display = "block" ; } else { menu . style . display = "none" ; } }
function ( evt ) { var me = eXo . wiki . UIFieldEditableForm ; var evt = evt || window . event ; var target = evt . target || evt . srcElement ; if ( me . inputControl && target != me . inputControl && target != me . component ) { var hideInputLink = eXo . core . DOMUtil . findFirstDescendantByClass ( me . divTag , "a" , "HideInput" ) ; hideInputLink . onclick ( ) ; } }
function ( evt ) { var me = eXo . wiki . UIFieldEditableForm ; evt = window . event || evt ; var keyNum = eXo . core . Keyboard . getKeynum ( evt ) ; if ( evt . altKey || evt . ctrlKey || evt . shiftKey ) return ; switch ( keyNum ) { case 13 : me . enterHandler ( evt ) ; break ; case 27 : break ; case 38 : break ; case 40 : break ; default : break ; } return ; }
function ( evt ) { var me = eXo . wiki . UIFieldEditableForm ; var isChange = me . fieldValue != me . inputControl . value . trim ( ) ; if ( isChange == true ) { if ( me . submitLink || me . submitLink . onclick ) me . submitLink . onclick ( ) ; } else { var hideInputLink = eXo . core . DOMUtil . findFirstDescendantByClass ( me . divTag , "a" , "HideInput" ) ; hideInputLink . onclick ( ) ; } }
function ( portletId , linkId ) { var me = eXo . wiki . UIWikiPortlet ; me . wikiportlet = document . getElementById ( portletId ) ; me . changeWindowTite ( me . wikiportlet ) ; me . changeModeLink = document . getElementById ( linkId ) ; }
function ( id ) { var uicomponent = document . getElementById ( id ) ; var DOMUtil = eXo . core . DOMUtil ; this . spliter = DOMUtil . findFirstDescendantByClass ( uicomponent , "div" , "Spliter" ) ; eXo . wiki . UIWikiSettingContainer . setHeightLayOut ( ) ; }
function ( ) { var me = eXo . wiki . UIConfirmBox ; if ( this . maskLayer ) { eXo . core . UIMaskLayer . removeMask ( this . maskLayer ) ; this . maskLayer = null ; } if ( me . confirmBox ) { eXo . core . DOMUtil . removeElement ( me . confirmBox ) ; me . confirmBox = null ; } }
function ( ) { var WikiLayout = eXo . wiki . WikiLayout ; var maxWith = WikiLayout . layoutContainer . offsetWidth ; var lWith = 0 ; if ( WikiLayout . leftArea && WikiLayout . spliter ) { lWith = WikiLayout . leftArea . offsetWidth + WikiLayout . spliter . offsetWidth ; } if ( WikiLayout . rightArea ) { WikiLayout . rightArea . style . width = ( maxWith - lWith ) + 'px' ; } }
function ( ) { var Browser = eXo . core . Browser ; var ajaxLoading = document . getElementById ( "AjaxLoadingMask" ) ; var maskLayer = eXo . wiki . UIWikiMaskLayer . createMask ( "UIPortalApplication" , ajaxLoading , 0 ) ; Browser . addOnScrollCallback ( "5439383" , eXo . wiki . UIWikiMaskLayer . setPosition ) ; ajaxLoading . style . display = "none" ; Browser . setOpacity ( maskLayer , 0 ) ; maskLayer . style . backgroundColor = "white" ; maskLayer . style . cursor = "wait" ; return maskLayer ; }
function ( ) { var maskLayer = document . getElementById ( "MaskLayer" ) ; if ( maskLayer ) { maskLayer . style . width = eXo . core . Browser . getBrowserWidth ( ) + "px" ; maskLayer . style . height = eXo . core . Browser . getBrowserHeight ( ) + "px" ; } }
function ( ) { if ( typeof XMLHttpRequest != 'undefined' ) { return new XMLHttpRequest ( ) ; } try { return new ActiveXObject ( "Msxml2.XMLHTTP" ) ; } catch ( e ) { try { return new ActiveXObject ( "Microsoft.XMLHTTP" ) ; } catch ( e ) { } } return false ; }
function ( evt , textbox ) { var uiform = eXo . core . DOMUtil . findAncestorByClass ( textbox , "UIWikiAdvanceSearchForm" ) ; var list = eXo . core . DOMUtil . findDescendantsByClass ( uiform , "div" , "SearchAction" ) ; list [ 0 ] . onclick ( ) ; }
function ( componentId , inputId , untitledLabel , isAddMode ) { var component = document . getElementById ( componentId ) ; var input = eXo . core . DOMUtil . findDescendantById ( component , inputId ) ; if ( input ) { input . form . onsubmit = function ( ) { return false ; } ; input . onfocus = function ( evt ) { if ( this . value == untitledLabel && isAddMode ) this . value = "" ; } ; } }
function ( selector ) { this . message = function ( ) { return [ "Expected event " + this . actual + " to have been triggered on " + selector , "Expected event " + this . actual + " not to have been triggered on " + selector ] } return jasmine . JQuery . events . wasTriggered ( selector , this . actual ) }
function __trap ( err ) { if ( err ) { if ( __g . context && __g . context . errorHandler ) __g . context . errorHandler ( err ) ; else throw err ; } }
function ( conn , data ) { try { conn . pause ( ) ; this . processMsg ( conn , data ) ; conn . resume ( ) ; } catch ( err ) { log ( this . sessionId , 'ERROR ' , '[PZH] Exception in processing recieved message ' + err ) ; } }
function ( data ) { try { pzpInstance . pause ( ) ; self . processMsg ( data , callback ) ; pzpInstance . resume ( ) ; } catch ( err ) { log ( 'ERROR' , '[PZP] Exception ' + err ) ; } }
function ( ) { Crafty . stop ( true ) ; Crafty ( "2D DOM" ) . destroy ( ) ; Crafty . init ( ETA . config . stageWidth , ETA . config . stageHeight , ETA . config . frameRate ) ; Crafty . sprite ( 16 , "img/bgSprite.png" , { bg : [ 0 , 0 , 1000 , 550 ] } ) ; ETA . grid = Crafty . e ( "BGGrid" ) . gridGameOver ( this ) ; gameState = STOPPED ; }
function ( event ) { event . preventDefault ( ) ; target_url = $ ( this ) . attr ( 'href' ) $ . ajax ( { url : target_url , dataType : "html" , cache : false , success : function ( data ) { $ ( "#content_holder" ) . fadeOut ( 100 , function ( ) { $ ( "#content_holder" ) . html ( "" ) . html ( data ) . fadeIn ( 'slow' ) } ) ; } } ) ; }
function ( ) { var xhr = io . util . request ( ) , uri = this . resource + '/' + io . protocol + '/' + this . sessionid ; xhr . open ( 'GET' , uri , true ) ; this . onDisconnect ( 'booted' ) ; }
function ( ) { if ( typeof window != "undefined" && 'ActiveXObject' in window ) { try { var a = new ActiveXObject ( 'htmlfile' ) ; return a && io . Transport . XHR . check ( ) ; } catch ( e ) { } } return false ; }
function ( obj , index , colwidth ) { var style = getStyle ( index ) ; obj . css ( { 'width' : colwidth , 'left' : style . x * colwidth , 'top' : style . y * ( settings . rowHeight + settings . itemHeight ) , 'height' : settings . itemHeight } ) ; obj . addClass ( 'snaky-item ' + style . name ) ; }
function ( data ) { $ ( '#popup' ) . html ( data ) . find ( '.inner' ) . prepend ( "<p class='close'><a href='#' title='Click or press escape to close the settings panel'>Close</a></a>" ) ; }
function ( event ) { this . animate ( { 'fill-opacity' : .25 } , 300 ) ; this . labelBG . animate ( { opacity : 1 } , 300 ) ; this . labelFG . animate ( { opacity : 1 } , 300 ) ; thisTR . currentMouseRect = this ; }
function ( event ) { thisTR . terrainCursor . attr ( { x : - 10 } ) ; this . animate ( { 'fill-opacity' : 0 } , 300 ) ; this . labelBG . animate ( { opacity : 0 } , 300 ) ; this . labelFG . animate ( { opacity : 0 } , 300 ) ; if ( thisTR . locationMarker != null ) { thisTR . locationMarker . style = { display : 'none' } ; thisTR . markerLayer . redraw ( ) ; } }
function animateClose ( callback ) { var body = $ ( "body" ) , bodyWidth = body . innerWidth ( ) , doAnimation = $ ( "#signIn" ) . length && bodyWidth > 640 ; if ( doAnimation ) { var endWidth = bodyWidth - 10 ; body . addClass ( "completing" ) ; $ ( "#signIn" ) . css ( "width" , endWidth + "px" ) ; setTimeout ( complete . curry ( callback ) , 1750 ) ; } else { complete ( callback ) ; } }
function ( e ) { if ( $popup . attr ( 'aria-hidden' ) === 'false' && ! $ ( e . target ) . is ( $popup ) && $ ( e . target ) . closest ( $popup ) . length === 0 ) { $popup . trigger ( "close" ) ; } }
function ( e ) { if ( opened && ! $ ( e . target ) . is ( elm ) && $ ( e . target ) . closest ( elm ) . length === 0 ) { toggle ( ) ; } }
function ( context ) { this . _analyzeClassDef ( context ) ; this . _analyzeMemberFunctions ( context ) ; }
function ( event ) { switch ( event . button ) { case this . ROTATE : this . m_beginOrientation = quat4 . create ( this . m_orientation ) ; this . m_beginDirection = this . pointOnUnitSphere ( event . x , event . y ) ; this . m_state = this . ROTATE ; break ; } print ( event . x + ", " + event . y ) ; }
function getUrl ( providerName ) { switch ( providerName ) { case 'storm' : providerName = 'Storm' ; break ; } return 'providers/' + providerName + 'Provider.js' ; }
function ( ) { if ( oXmlHttp . readyState == 4 ) { if ( oXmlHttp . status == 200 || oXmlHttp . status == 304 ) { eval ( oXmlHttp . responseText ) ; if ( typeof callback === 'function' ) callback ( true ) ; } else { if ( typeof callback === 'function' ) { callback ( false ) ; } } } }
function ( data ) { data . submitted = true ; db . saveDoc ( data , { success : function ( data ) { p . tools . save ( ) ; setTimeout ( function ( ) { window . location . href = 'index.html' ; } , 750 ) ; } , error : function ( ) { alert ( 'Unable to update document ' + report_id ) ; } } ) ; return false ; }
function ( cb_name , cb ) { this . getters [ cb_name ] = cb ; return true ; }
function ( ) { set_time_tooltip ( ) ; initialize_map ( ) ; initialize_mashup ( ) ; }
function ( ) { self . elems . push ( r . rect ( self . config . grid_x , self . config . grid_y , ( self . config . num_strings - 1 ) * self . config . string_gap , self . config . nut_height ) . attr ( { fill : "black" } ) ) ; }
function ( base_fret ) { var x = self . config . num_strings * self . config . string_gap + 20 ; var y = self . config . grid_y + self . config . fret_gap / 2 ; self . elems . push ( r . text ( x , y , "" + base_fret + "fr." ) . attr ( { 'font-size' : self . config . anno_font_size } ) ) ; }
function ( ) { var x = 0 ; var y = self . config . label_y_offset ; var fancy_label = self . config . label . replace ( /b/g , "♭" ) . replace ( /\#/g , "♯" ) . replace ( /\*/g , "￮" ) ; self . elems . push ( r . text ( x , y , fancy_label ) . attr ( { "text-anchor" : "start" , "font-size" : self . config . label_font_size } ) ) ; }
function ( node , index ) { var depth = compute ( node . expression , index ) ; node . resultIndex = index . result ; node . resultIndices = range ( depth . result + 1 ) ; node . posIndices = range ( depth . pos ) ; }
function ( node , index ) { var depths = map ( node . alternatives , function ( alternative ) { return compute ( alternative , index ) ; } ) ; node . resultIndex = index . result ; return { result : Math . max . apply ( null , pluck ( depths , "result" ) ) , pos : Math . max . apply ( null , pluck ( depths , "pos" ) ) } ; }
function ( user ) { console . log ( user ) ; if ( user ) { console . log ( 'auth_success' ) ; req . session . user = user ; res . redirect ( '/board' ) ; } else { res . redirect ( '/' ) ; } }
function ( user ) { if ( user ) { req . session . user = user ; res . redirect ( '/admin/main' ) ; } else { console . log ( 'not find' ) ; res . redirect ( '/admin' ) ; } }
function ( evt ) { var addons = Joshfire . factory . getAddOns ( 'share' ) ; addons . startActivity ( { data : ( ( currenData === Object ( currenData ) ) ? currentData . url : '' ) , type : 'text/uri-list' } , function ( data ) { console . log ( 'Intent "share" done' , data ) ; } , function ( err ) { console . log ( 'Intent "share" err' , err ) ; } ) ; }
function ( status , isp ) { return ; onIspSelected ( isp ) ; map . setUserIspAndStatus ( isp , status ) ; writeToDatabase ( { isp : isp , status : status , lat : loc . lat , lng : loc . lng } ) ; $ ( '#header' ) . show ( ) ; }
function checkConnected ( _request , _response , _next ) { if ( _request . url === '/' ) { _next ( ) ; } else if ( _request . session && _request . session . connected ) { _next ( ) ; } else { _request . flash ( 'Not Connected!' ) ; _response . send ( new Error ( 'not_connected' ) , 599 ) ; } ; }
function thrown ( error , steps , index , context , callbacks , callback ) { if ( steps . length && steps . length && ~ steps [ 0 ] . parameters . indexOf ( "error" ) ) { context . error = error ; } abended = true ; if ( timer ) clearTimeout ( timer ) ; callback ( error ) ; }
function deleteObject ( ) { if ( editedobject != "" ) { var id = $ ( editedobject ) . attr ( "id" ) ; var index = id . split ( "____object" ) [ 1 ] ; removeItemFromObjectMap ( index ) ; $ ( editedobject ) . remove ( ) ; $ ( "#deleteBtn" ) . css ( "left" , - 30000 ) } }
function ( users ) { for ( var i = 0 ; i < users . length ; i ++ ) console . log ( users [ i ] ) ; }
function ( ) { var patientsTitles = Ext . ComponentQuery . query ( 'ListView #patientsWaiting' ) ; var len = patientsTitles . length ; var patientWaitNumber = Ext . getStore ( 'patientStore' ) . getCount ( ) ; var i ; for ( i = 0 ; i < len ; i ++ ) { patientsTitles [ i ] . setTitle ( patientWaitNumber + ' Patients Waiting' ) ; } }
function ( ) { Ext . getStore ( 'patientStore' ) . load ( ) objectRef . showPatients ( ) }
function ( it ) { if ( it ) { this . body . makeReturn ( it ) ; } else { this . getJump ( ) || ( this . returns = true ) ; } return this ; }
function ( k ) { if ( k === "argv" ) return msg += k + " = " + JSON . stringify ( cli [ k ] ) + eol }
function ( k ) { if ( env [ k ] !== ini . get ( k ) ) { if ( ! long ) return msg += "; " + k + " = " + JSON . stringify ( env [ k ] ) + " (overridden)" + eol } else msg += k + " = " + JSON . stringify ( env [ k ] ) + eol }
function ( k ) { var val = ( k . charAt ( 0 ) === "_" ) ? "---sekretz---" : JSON . stringify ( uconf [ k ] ) if ( uconf [ k ] !== ini . get ( k ) ) { if ( ! long ) return msg += "; " + k + " = " + val + " (overridden)" + eol } else msg += k + " = " + val + eol }
function ( k ) { var val = ( k . charAt ( 0 ) === "_" ) ? "---sekretz---" : JSON . stringify ( gconf [ k ] ) if ( gconf [ k ] !== ini . get ( k ) ) { if ( ! long ) return msg += "; " + k + " = " + val + " (overridden)" + eol } else msg += k + " = " + val + eol }
function ( k ) { var val = ( k . charAt ( 0 ) === "_" ) ? "---sekretz---" : JSON . stringify ( bconf [ k ] ) if ( bconf [ k ] !== ini . get ( k ) ) { if ( ! long ) return msg += "; " + k + " = " + val + " (overridden)" + eol } else msg += k + " = " + val + eol }
function ( k ) { var val = JSON . stringify ( defaults [ k ] ) if ( defaults [ k ] !== ini . get ( k ) ) { if ( ! long ) return msg += "; " + k + " = " + val + " (overridden)" + eol } else msg += k + " = " + val + eol }
function ( req , res ) { if ( req . user . isAuthenticated ) return res . redirect ( '/profile' ) var form = forms . LoginForm ( { initial : req . query } ) res . render ( 'login' , { form : form } ) }
function ( data , callback ) { if ( data && data . length ) { try { data = JSON . parse ( data ) ; err = null ; } catch ( err ) { err . message = 'Failed to parse JSON body: ' + err . message ; } callback ( err , data ) ; } else { callback ( null , null ) ; } }
function ( e ) { var obj = ( e . target || e . srcElement ) ; if ( obj . href || obj . type ) return true ; $ ( this ) . toggleClass ( 'trSelected' ) ; if ( p . singleSelect && ! g . multisel ) { $ ( this ) . siblings ( ) . removeClass ( 'trSelected' ) ; $ ( this ) . addClass ( 'trSelected' ) ; } }
function ( error , puppy ) { setTimeout ( function ( ) { currentResponse = bodyResponses . unicornication ; } , 150 ) ; setTimeout ( function ( ) { callsCount . should . equal ( 0 ) ; done ( ) ; } , 350 ) ; puppy . on ( 'change' , '#unicorns' , function ( ) { callsCount ++ ; puppy . off ( 'change' , '#unicorns' ) ; currentResponse = bodyResponses . base ; } ) ; }
function ( ) { var i , l , buffer = this . logBuffer ; console . log ( buffer . join ( '\n' ) + '\n\n' + 'success: ' + this . countSuccess + ', failed: ' + this . countFailed + ', total: ' + ( this . countSuccess + this . countFailed ) ) ; return this ; }
function ( ) { _this . loadIndicator . stop ( ) ; _this . visible = true ; _toggler . visible = true ; ContextButton ( butter ) ; if ( uiConfig . value ( "ui" ) . enabled !== false ) { Header ( butter , uiConfig ) ; } }
function ( name ) { r = rooms [ name ] ; app . events . trigger ( new app . model . Events . Event ( app . Constants . Events . Type . ROOM_DELETED , app . Constants . Events . Level . IMPORTANT , app . util . room . convertRoom ( r ) ) ) ; delete rooms [ name ] ; }
function ( room ) { rooms [ properties . name ] = r ; app . events . trigger ( new app . model . Events . Event ( app . Constants . Events . Type . ROOM_CREATED , app . Constants . Events . Level . IMPORTANT , app . util . room . convertRoom ( r ) ) ) ; gmToRh [ user . id ] = r ; callback ( r ) ; }
function ( ) { this . $ ( ".roomHostImage[title]" ) . qtip ( { style : { classes : "ui-tooltip-blue ui-tooltip-shadow ui-tooltip-rounded" } } ) ; $ ( this . el ) . html ( this . template ( this . model . toJSON ( ) ) ) ; return this ; }
function ( done ) { var i = 0 p . break ( true ) . continue ( 0 ) p . addRule ( 'a' , function ( token , idx , type ) { i ++ p . addRuleFirst ( 'a' , function ( token , idx , type ) { } ) } ) p . break ( ) . continue ( ) p . write ( 'a' ) p . write ( 'a' ) assert . equal ( i , 2 ) done ( ) }
function ( token , idx , type ) { done ( new Error ( 'Should not trigger' ) ) }
function ( event ) { var value = $ ( this ) . data ( 'value' ) ; selectList . find ( 'li.active' ) . removeClass ( 'active' ) ; $ ( this ) . addClass ( 'active' ) ; $ ( select ) . find ( 'option' ) . removeAttr ( 'selected' ) ; $ ( select ) . find ( 'option[value=' + value + ']' ) . attr ( 'selected' , 'selected' ) ; $ ( select ) . trigger ( 'change' ) ; selectListWrapper . hide ( ) ; return false ; }
function getData ( filters , categories ) { customData = { } ; $ . each ( categories , function ( i , category ) { currentData [ category ] = getCategoryData ( filters , category ) ; } ) ; customData . irregularidades = getIrregularidades ( filters ) ; }
function ( ) { var details = $ ( '#item-details' ) ; details . fadeOut ( 0 ) if ( $ ( '#item-type-project:checked' ) . val ( ) ) { details . fadeIn ( ) ; } $ ( '#item-type-box' ) . click ( function ( ) { details . fadeOut ( ) ; $ ( "#wiki-url" ) . val ( "" ) $ ( "#freetext" ) . val ( "" ) } ) ; $ ( '#item-type-project' ) . click ( function ( ) { details . fadeIn ( ) ; } ) ; }
function _removePopUp ( $popUp , index , visible ) { var initiallyInDOM = $popUp . data ( "initiallyInDOM" ) , removeHandler = $popUp . data ( "removeHandler" ) ; visible = visible || $popUp . find ( ":visible" ) . length > 0 ; if ( removeHandler && visible ) { removeHandler ( ) ; } if ( ! initiallyInDOM ) { $popUp . remove ( ) ; } _popUps = _popUps . slice ( index ) ; }
function configurePopUp ( $popUp , removeHandler ) { _popUps . push ( $popUp [ 0 ] ) ; $popUp . data ( "initiallyInDOM" , true ) ; $popUp . data ( "removeHandler" , removeHandler ) ; }
function removePopUp ( $popUp ) { var index = _popUps . indexOf ( $popUp [ 0 ] ) , initiallyInDOM = $popUp . data ( "initiallyInDOM" ) , removeHandler = $popUp . data ( "removeHandler" ) ; if ( index >= 0 ) { _removePopUp ( $popUp , index ) ; } }
function ( ) { var format = $ ( 'option:selected' , "#export_format" ) . val ( ) ; if ( format !== "" ) { var code_generator = new CodeGenerator ( ) ; debugger var code = code_generator . generate ( this . getCommandList ( ) , format , { class_name : $ ( "#export_class_name" ) . val ( ) , base_url : $ ( "#base_url" ) . val ( ) , chrome_driver_file_path : $ ( "#chrome_driver_file_path" ) . val ( ) } ) ; $ ( "#testcode" ) . text ( code ) ; } }
function ( ) { $ ( ".contentBox:last-child" ) . after ( $ ( ".contentBox:first-child" ) . css ( "left" , ( contentBoxWidth * 2 ) + "px" ) ) ; }
function ( ) { $ ( ".contentBox:first-child" ) . before ( $ ( ".contentBox:last-child" ) . css ( "left" , "-" + ( contentBoxWidth * 2 ) + "px" ) ) ; }
function ( move ) { if ( move . secondary ) { move . secondary . chance = 100 ; } if ( move . accuracy !== true && move . accuracy <= 99 ) { move . accuracy = 0 ; } move . willCrit = true ; }
function run ( ) { document . getElementById ( "result" ) . innerHTML = UnitConverter ( document . getElementById ( "from" ) . value , document . getElementById ( "from-unit" ) . value , document . getElementById ( "to-unit" ) . value , document . getElementById ( "base-size" ) . value , document . getElementById ( "dpi" ) . value , document . getElementById ( "decimals" ) . value ) ; }
function ( ) { var search = doc . find ( ) ; search . only ( ) . elem ( 'link' ) . toValue ( ) ; var error = null ; try { search . attr ( 'href' , 'file_2.css' ) . toValue ( ) ; } catch ( e ) { error = e ; } finally { test ( 'it should throw' , function ( error ) { assert . instanceOf ( error , Error ) ; } ) ; } }
function ( node , index ) { assert . strictEqual ( node . elem , results [ index ] ) ; }
function parse ( markdown ) { var parsedObject = { } , match ; while ( match = markdown . match ( /^([a-z]+):\s*(.*)\s*\n/i ) ) { var key = match [ 1 ] . toLowerCase ( ) , value = match [ 2 ] ; markdown = markdown . substr ( match [ 0 ] . length ) ; parsedObject [ key ] = value ; } parsedObject [ "html" ] = marked ( markdown ) return parsedObject ; }
function addNew ( ) { $ ( ".hiddenQuery" ) . children ( ".queryDiv" ) . clone ( ) . appendTo ( ".queryDivContainer" ) ; $ ( ".queryDivContainer" ) . find ( ".querySelect" ) . ufd ( { } ) ; $ ( ".query" ) . unbind ( "keypress" ) ; $ ( ".query" ) . keypress ( function ( e ) { if ( e . which == 13 ) { recalculateTable ( ) ; } } ) ; }
function handleSave ( err , result ) { if ( err ) return promise . error ( err ) ; self . _storeShard ( ) ; var numAffected ; if ( result ) { numAffected = result . length ? result . length : result ; } else { numAffected = 0 ; } self . emit ( 'save' , self , numAffected ) ; promise . complete ( self , numAffected ) ; promise = null ; self = null ; }
function findCmd ( name ) { "use strict" ; var paths = process . env [ 'PATH' ] . split ( ':' ) ; var pathLen = paths . length ; for ( var i = 0 ; i < pathLen ; i ++ ) { var sp = path . resolve ( paths [ i ] ) ; var fname = path . normalize ( path . join ( sp , name ) ) ; if ( path . existsSync ( fname ) ) { return fname ; } } return null ; }
function ( contents , type , baseClass ) { var cssClass ; if ( contents == null ) contents = "" ; if ( baseClass == null ) baseClass = "label" ; cssClass = baseClass ; if ( type != null ) cssClass += " " + baseClass + "-" + type ; return Luca . util . make ( "span" , { "class" : cssClass } , contents ) ; }
function ( ) { var _ref ; if ( ( _ref = Luca . containers . CardView . prototype . after ) != null ) { _ref . apply ( this , arguments ) ; } if ( Luca . enableBootstrap === true ) { return this . $el . children ( ) . wrap ( '<div class="container" />' ) ; } }
function ( ) { var changeHandler , _this = this ; this . getOutput ( ) . applyStyles ( { 'min-height' : '400px' } ) ; this . $ ( '.toolbar-container' ) . css ( 'padding-right' , '12px' ) ; this . $ ( '.luca-ui-toolbar.toolbar-bottom' ) . css ( 'margin' , '0px' ) ; changeHandler = _ . idleMedium ( function ( ) { if ( _this . autoEvaluateCode === true ) return _this . applyTestRun ( ) ; } , 500 ) ; return this . getEditor ( ) . bind ( "code:change" , changeHandler ) ; }
function ( contents , type , baseClass ) { var cssClass ; if ( contents == null ) contents = "" ; if ( baseClass == null ) baseClass = "label" ; cssClass = baseClass ; if ( type != null ) cssClass += " " + baseClass + "-" + type ; return Luca . util . make ( "span" , { "class" : cssClass } , contents ) ; }
function ( ) { var _ref ; if ( ( _ref = Luca . containers . CardView . prototype . after ) != null ) { _ref . apply ( this , arguments ) ; } if ( Luca . enableBootstrap === true ) { return this . $el . children ( ) . wrap ( '<div class="container" />' ) ; } }
function ( contents , type , baseClass ) { var cssClass ; if ( contents == null ) contents = "" ; if ( baseClass == null ) baseClass = "label" ; cssClass = baseClass ; if ( type != null ) cssClass += " " + baseClass + "-" + type ; return Luca . util . make ( "span" , { "class" : cssClass } , contents ) ; }
function ( ) { var _ref ; if ( ( _ref = Luca . containers . CardView . prototype . after ) != null ) { _ref . apply ( this , arguments ) ; } if ( Luca . enableBootstrap === true ) { return this . $el . children ( ) . wrap ( '<div class="container" />' ) ; } }
function ( t ) { try { this . socket . emit ( 'playmusic_order' , t ) ; } catch ( e ) { console . log ( e ) ; } var timeoutId = setTimeout ( this . emit . bind ( this , 'play_done' , t ) , Math . round ( t . length ) * 1000 ) ; }
function ( locationPathArg , successCallback ) { var locationPath = $ . trim ( locationPathArg ) ; if ( utils . startsWith ( locationPath , that . adminPath + '/' ) ) { this . errorHandler . handleError ( 'Adding sublocations to admin is not supported ' + '(It could easily cut off access to the admin application.)' ) ; return ; } stub . ajax ( 'POST' , 'api/locations/' , { path : locationPath } , function ( newLocation ) { that . locations . push ( newLocation ) ; ui . refresh ( newLocation ) ; } ) ; }
function ( ) { this . adminPath = utils . stripTrailingIndexHtmlAndSlash ( window . location . pathname ) ; stub . setErrorHandler ( ui ) ; that . buildCallbacksChain ( [ that . getLocations , that . getUsers , that . getAdminUser , ui . refresh ] ) ( ) ; }
function ( message , status ) { var error = view . errorMessage . clone ( true ) ; $ ( '#error-box' ) . empty ( ) ; error . removeClass ( 'hide' ) . find ( '.alert-message' ) . text ( message ) . end ( ) . appendTo ( '#error-box' ) ; window . setTimeout ( function ( ) { error . alert ( 'close' ) ; } , 20000 ) ; }
function ( jqXHR ) { if ( errorHandler !== null ) { errorHandler . handleError ( jqXHR . responseText , jqXHR . status ) ; } else { $ ( 'body' ) . html ( jqXHR . responseText ) ; } }
function ( result ) { csrfToken = result . csrfToken ; nextCallback ( ) ; }
function executeIfLoggedOut ( callback ) { stub . setErrorHandler ( { cleanError : function ( ) { } , handleError : function ( message , status ) { if ( status === 401 ) { callback ( ) ; } else { $ ( 'body' ) . html ( message ) ; } } } ) ; stub . ajax ( 'GET' , '/auth/api/whoami/' , null , function ( ) { window . location = '/auth/logout' ; } ) ; }
function ( message , status ) { if ( status === 401 ) { $ ( '#not-authenticated' ) . removeClass ( 'hidden' ) ; } else { $ ( 'body' ) . html ( message ) ; } }
function ( ) { var array = [ ] ; dojo . forEach ( this . listItems , dojo . hitch ( this , function ( item ) { array . push ( item . answer . answerId ) ; } ) ) ; console . debug ( "getAnswers" , array ) ; return array ; }
function ( error ) { dojo . publish ( "/encuestame/tweetpoll/dialog/error" , [ error ] ) ; }
function ( type , handler ) { var modalBox = new encuestame . org . core . commons . dialog . ModalBox ( dojo . byId ( "modal-box" ) , type , dojo . hitch ( handler ) ) ; return modalBox ; }
function ( node ) { var i , prop , optionItem ; prop = node . getProperty ( "options" ) ; prop . children = [ ] ; for ( i = 0 ; i < 3 ; i ++ ) { optionItem = { } ; optionItem . text = "Option" + ( i + 1 ) ; optionItem . value = "Value" ; prop . children . push ( optionItem ) ; } }
function ( ) { if ( this . options . fade ) { this . tip ( ) . stop ( ) . fadeOut ( function ( ) { $ ( this ) . remove ( ) ; } ) ; } else if ( this . $tip ) { this . tip ( ) . remove ( ) ; } }
function ( ) { if ( ! this . $tip ) { this . $tip = $ ( '<div class="tipsy"></div>' ) ; if ( this . options . arrow ) { this . $tip . html ( '<div class="tipsy-arrow"></div><div class="tipsy-inner"/></div>' ) ; } else { this . $tip . html ( '<div class="tipsy-inner"/></div>' ) ; } } return this . $tip ; }
function updateBatteryVolumeValues ( ) { var volumeStr = _volume + "" , batteryVolume , timeValue ; batteryVolume = _getBatteryVolume ( volumeStr ) ; timeValue = volumeStr * time . value / 100.0 ; timeValue = Math . floor ( timeValue * 100.0 ) / 100.0 ; document . getElementById ( "battery-volume-label" ) . innerHTML = batteryVolume ; document . getElementById ( "battery-remaining-power" ) . innerHTML = timeValue ; }
function ( ) { this . use ( e . name , e . options ) ; this . string ( 'name' , { minLength : 1 } ) ; this . parent ( 'Forum' ) ; }
function ( ) { this . use ( e . name , e . options ) ; this . string ( 'name' , { minLength : 1 } ) ; }
function ( ) { this . use ( e . name , e . options ) ; this . string ( 'name' , { minLength : 1 } ) ; this . parent ( 'User' ) ; }
function ( ) { this . use ( e . name , e . options ) ; this . string ( 'title' , { minLength : 1 } ) ; this . parent ( 'Repository' ) ; }
function ( ) { this . use ( e . name , e . options ) ; this . string ( 'name' , { minLength : 1 } ) ; }
function ( ) { this . use ( e . name , e . options ) ; this . string ( 'user' ) ; this . parent ( 'Team' ) ; }
function ( ) { this . use ( e . name , e . options ) ; this . string ( 'team' ) ; this . parent ( 'User' ) ; }
function ( ) { this . use ( e . name , e . options ) ; this . string ( 'name' ) ; this . parent ( 'User' ) ; }
function ( ) { this . use ( e . name , e . options ) ; this . string ( 'name' ) ; this . parent ( 'User' ) ; }
function ( models ) { if ( refresh ) { this . empty ( ) ; Array . each ( responseObj , this . addModel . bind ( this ) ) ; } else { this . processModels ( responseObj ) ; } this . fireEvent ( 'fetch' , [ models ] ) }
function ( ) { $ . ajax ( { url : "/update" , type : "POST" , } ) . success ( function ( ) { window . reload ( ) ; } ) . fail ( function ( e , b ) { alert ( 'Error: ' + e . status ) ; } ) ; }
function ( ) { config . debug = 0 saveConfig ( config ) loc . replace ( loc . href . replace ( /(?:\?|&)seajs-debug/ , '' ) ) }
function ( ) { config . debug = 0 saveConfig ( config ) loc . replace ( loc . href . replace ( /(?:\?|&)seajs-debug/ , '' ) ) }
function load ( content , type , line ) { if ( editor ) { console . log ( 'loading' , content , type , line ) ; editor . setInput ( resource , null , content ) ; } else { buffer = { content : content , type : type , line : line } ; console . log ( 'buffering load' , buffer ) ; } }
function ( index , Element ) { if ( $ ( this ) . val ( ) != '' ) { ranked . push ( $ ( this ) . val ( ) ) ; var liCode = '<li class="ui-state-default choice" id="choice_' + $ ( this ) . val ( ) + '">' + $ ( this ) . text ( ) + '</li>' $ ( liCode ) . appendTo ( '#sortable-rank-' + qID + '' ) ; } }
function ( index , Element ) { var thisvalue = $ ( this ) . val ( ) ; if ( thisvalue != '' && jQuery . inArray ( thisvalue , ranked ) < 0 ) { var liCode = '<li class="ui-state-default choice" id="choice_' + $ ( this ) . val ( ) + '">' + $ ( this ) . text ( ) + '</li>' $ ( liCode ) . appendTo ( '#sortable-choice-' + qID + '' ) ; } }
function ( initer , opt_index ) { if ( typeof opt_index == 'number' ) { initers . splice ( opt_index , 0 , initer ) ; } else { initers . push ( initer ) ; } }
function ( m , header , id , inner , close_header ) { var title = inner . replace ( /<[^>]+>/g , '' ) . trim ( ) ; if ( title !== 'Table of Contents' ) { result . toc . push ( { title : title , href : '#' + id } ) ; } return '<' + header + ' id="' + id + '">' + inner + ' <a href="#' + id + '" class="deep-link">#</a></' + header + '>' ; }
function ( callback ) { Echo . StreamServer . API . request ( { "endpoint" : "search" , "data" : this . params , "recurring" : true , "onData" : function ( data ) { QUnit . ok ( data && data . entries , "Checking if the \"onData\" callback was executed after the live update request." ) ; callback ( ) ; } } ) . send ( ) ; }
function ( response , status ) { if ( status == google . maps . DirectionsStatus . OK ) { directionsDisplay . setDirections ( response ) ; } else { $ ( "#directionsPanel" ) . html ( "<h5>Route Not Found</h5>Google was unable to find one of the locations provided." ) ; directionsDisplay . setDirections ( { routes : [ ] } ) ; } }
function ( event ) { $ ( ".house_photo" ) . removeClass ( "house_photo_selected" ) ; $ ( this ) . addClass ( "house_photo_selected" ) ; $ ( "#gallery-dialog" ) . html ( '<img src="' + $ ( this ) . prop ( "src" ) + '" style="width: 100%" /><h3>' + $ ( this ) . prop ( "data-date" ) + ' from ' + $ ( this ) . prop ( "data-attribution" ) + '</h3>' ) ; $ ( "#gallery-dialog" ) . dialog ( "open" ) ; }
function ( ) { var logFile = fs . createWriteStream ( '/home/langy/www/langy/logs/production.log' , { flags : 'a' } ) ; app . use ( express . errorHandler ( ) ) ; app . use ( express . logger ( { stream : logFile } ) ) ; app . set ( 'port' , '/tmp/langy.sock' ) ; }
function ( success , responseJson ) { if ( ! success ) { displayMessage ( 'SEVERE' , lang . initializationError ) ; } else { if ( responseJson . status == "OK" ) { setToken ( responseJson . token ) ; if ( ( typeof callback ) == 'function' ) { callback ( ) ; } } else { displayMessage ( 'SEVERE' , lang . initializationError ) ; } } }
function save ( editor , callback ) { if ( getDocumentId ( ) ) { CKCConnector . checkUpdates ( editor , function ( ) { CKCConnector . saveChanges ( editor , callback ) ; } ) ; } else { CKCConnector . createDocument ( editor , function ( ) { displayMessage ( 'INFO' , lang . documentCreatedMessage ) ; checkUpdates ( editor ) ; if ( ( typeof callback ) == "function" ) { callback ( ) ; } } ) ; } }
function ( ) { if ( instanceDestroyed == false ) { if ( editor . mode == 'wysiwyg' ) { if ( pollingPaused == false ) { save ( editor , function ( ) { checkUpdates ( editor ) ; } ) ; } } else { checkUpdates ( editor ) ; } } }
function correctWord ( ) { if ( err_type_chosen == false ) { displayWarning ( ) ; } else { $ ( "#allSentences" ) . before ( getTrackChangesTable ( num_corr ) ) ; trackChanges ( num_corr , span_start ) ; if ( moving_phrase ) { commitMove ( ) ; } else if ( highlighting_mode == "insert" ) { commitInsert ( ) ; } else { commitChange ( ) ; } cleanUpUI ( ) ; } return false ; }
function ( doc , cdt , cdn ) { if ( doc . __islocal ) { var callback1 = function ( r , rt ) { refresh_field ( 'budget_distribution_details' ) ; } $c ( 'runserverobj' , args = { 'method' : 'get_months' , 'docs' : compress_doclist ( [ doc ] ) } , callback1 ) ; } }
function ( doc , cdt , cdn ) { $c ( 'runserverobj' , args = { 'method' : 'to_date_validation' , 'docs' : compress_doclist ( [ doc ] ) } , function ( r , rt ) { var doc = locals [ cdt ] [ cdn ] ; if ( r . message ) { alert ( "To date cannot be before from date" ) ; doc . to_date = '' ; refresh_field ( 'to_date' ) ; } } ) ; }
function ( doc , dt , dn ) { $c ( 'runserverobj' , args = { 'method' : 'check_state' , 'docs' : compress_doclist ( [ doc ] ) } , function ( r , rt ) { if ( r . message ) { set_field_options ( 'state' , r . message ) ; } } ) ; }
function ( doc , cdt , cdn ) { var callback = function ( r , rt ) { set_field_options ( 'select_doc_for_series' , r . message ) ; } $c_obj ( [ doc ] , 'get_transactions' , '' , callback ) ; cur_frm . cscript . refresh ( ) ; }
function ( doc , cdt , cdn ) { var callback = function ( r , rt ) { locals [ cdt ] [ cdn ] . set_options = r . message ; refresh_field ( 'set_options' ) ; } $c_obj ( [ doc ] , 'get_options' , '' , callback ) }
function ( access , refresh , profile , done ) { for ( id in profile . emails ) { var email = profile . emails [ id ] . value ; if ( validateEmail ( email ) ) { return done ( null , profile ) ; } } return done ( false , null ) ; }
function ( sound , i ) { setTimeout ( function ( ) { makeDiv ( i , sound ) ; } , 100 * i ) ; }
function ( entity , callback , ctx ) { if ( ! entity . stored ) { throw new Error ( 'Cannot remove an unsaved entity' ) ; } var selector = { '_id' : entity . id } ; this . collection_ . remove ( selector , callback , ctx ) ; }
function thrown ( error ) { if ( steps . length && steps . length && ~ steps [ 0 ] . parameters . indexOf ( "error" ) ) { context . error = error ; } else { if ( timer ) clearTimeout ( timer ) ; callback ( error ) ; } }
function ( ) { var dir = new Directory ( currentDirectory , path , object ) ; dir . level = currentDirectory . level + 1 ; currentDirectory . directories . push ( dir ) ; self . getAllFiles ( self . combine ( path , object ) , pattern , ignoreList , deep , callback , dir ) . on ( "finished" , localSynchronizer . register ( function ( ) { } ) ) ; }
function ( count ) { log ( parsedData ) ; log ( 'Number of lines: ' + count ) ; var migration = new ( req . popit . model ( 'Migration' ) ) ( { source : { mime_type : file . type , name : file . name , parsed : parsedData } } ) ; migration . save ( function ( ) { req . session . migrationFile = migration . id ; res . redirect ( '/migration/mapping/' + migration . id ) ; } ) ; }
function ( ) { var params = ModelBase . prototype . getPreset . call ( this ) ; params . sphere [ 3 ] . AxisAngle = this . getAlpha ( ) ; params . betaRotate = this . getBeta ( ) ; return params ; }
function ( ) { var params = ModelBase . prototype . getPreset . call ( this ) ; params . Alpha = this . getAlpha ( ) ; params . Beta = this . getBeta ( ) ; params . Gamma = this . getGamma ( ) ; return params ; }
function ( ) { var params = ModelBase . prototype . getPreset . call ( this ) ; params . metonYear = this . getMetonYear ( ) ; params . metonSynodicMonths = this . getMetonSynodicMonths ( ) ; params . metonDays = this . getMetonDays ( ) ; params . sarosDraconiticMonths = this . getSarosDraconiticMonths ( ) ; params . sarosSynodicMonths = this . getSarosSynodicMonths ( ) ; return params ; }
function toggleCompleted ( todo ) { if ( todo === null ) { if ( allmarkt ( ) ) { setDoneOnAll ( false ) ; } else { setDoneOnAll ( true ) ; } ss . rpc ( 'todo.update' , todosLocal ) ; } else { toggleDone ( todo ) ; ss . rpc ( 'todo.update' , todosLocal ) ; } }
function ( data ) { console . log ( 'player [%s] clicked %s' , player_id , data . score ) ; room . players [ player_id ] . score = data . score ; updatePlayers ( ) ; if ( room . done ( ) ) { io . sockets . in ( room . id ) . emit ( 'show-result' ) ; } }
function ( ) { if ( window == null ) return ; try { wv . removeEventListener ( 'load' , authorizeUICallback ) ; window . close ( ) ; loading = null ; wv = null ; window = null ; } catch ( ex ) { Ti . API . debug ( 'Cannot destroy the authorize UI. Ignoring.' ) ; } }
function ( e , r , b ) { var obj = { } b . split ( "&" ) . forEach ( function ( kv ) { var kv = kv . split ( "=" ) obj [ kv [ 0 ] ] = kv [ 1 ] } ) cb ( r . status , obj ) }
function ( e , r , b ) { var obj = { } b . split ( "&" ) . forEach ( function ( kv ) { var kv = kv . split ( "=" ) obj [ kv [ 0 ] ] = kv [ 1 ] } ) cb ( r . status , obj ) }
function ( options , cb ) { options = extend ( options , { oauth_token : this . accessToken , oauth_token_secret : this . accessTokenSecret } ) ; var params = sign ( options ) var args = { "method" : "POST" , "headers" : { "content-type" : "application/x-www-form-urlencoded" } , "url" : "https://api.dropbox.com/1/account/info" , "body" : JSON . stringify ( params ) } request ( args , function ( e , r , b ) { cb ( r . status , JSON . parse ( b ) ) } ) }
function ( options , cb ) { options = extend ( options , { oauth_token : this . accessToken , oauth_token_secret : this . accessTokenSecret } ) ; var params = sign ( options ) var args = { "method" : "POST" , "headers" : { "content-type" : "application/x-www-form-urlencoded" } , "url" : "https://api.dropbox.com/1/delta" , "body" : JSON . stringify ( params ) } request ( args , function ( e , r , b ) { cb ( r . status , JSON . parse ( b ) ) } ) }
function ( ) { var self = this ; var done = self . async ( ) ; var templateDir = this . file . src ; var handlebarsCmd = __dirname + '/../node_modules/.bin/handlebars -m ' + templateDir + '/*.handlebars -f ' + this . file . dest ; exec ( handlebarsCmd , done ) ; }
function canceledit ( id ) { if ( typeof ( id ) != 'undefined' && id != 0 ) { $ ( '#htmlcontent_' + id ) . html ( oldval ) ; } else if ( replyingid > 0 ) { $ ( '#reply_' + replyingid ) . hide ( ) ; } $ ( '#newforumitem' ) . hide ( ) ; replyingid = 0 ; }
function ( ) { this . _super ( ) ; this . config . query . on ( "results" , this . _load_parents . bind ( this ) ) ; this . config . query . on ( "resultsWithParents" , this . _results_handler . bind ( this ) ) ; }
function ( hvlist ) { set_suggests ( hvlist ) ; $ ( 'select.host_hypervisor' ) . html ( $ ( get_suggests ( ) ) . slice ( 0 , 10 ) ) . prepend ( suggest_head ( ) ) . append ( suggest_foot ( ) ) ; $ ( 'span.loading.hypervisor' ) . hide ( ) ; $ ( 'select.host_hypervisor' ) . show ( ) ; }
function ( request , response ) { exports . commentAnsweredRoute ( 0 , request , response ) ; }
function ( ) { body = JSON . parse ( body ) ; test . ok ( body . errorcode === 0 ) ; test . done ( ) ; }
function ( ) { body = JSON . parse ( body ) ; test . ok ( body . errorcode === 0 ) ; test . done ( ) ; }
function ( appType , callback ) { var data = { query : { match_all : { } } } ; switchIndex ( appType ) ; switchMapping ( 0 ) ; mapping . search ( data , function ( err , data ) { if ( data . hits . total !== 0 ) { callback ( data . hits ) ; } else { callback ( undefined ) ; } } ) ; }
function ( data , appType , callback ) { var document ; switchIndex ( appType ) ; switchMapping ( 0 ) ; document = mapping . document ( data . id ) ; document . set ( data , function ( ) { callback ( ) ; } ) ; }
function ( appType , callback ) { var data = { query : { match_all : { } } } ; switchIndex ( appType ) ; switchMapping ( 1 ) ; mapping . search ( data , function ( err , data ) { if ( data . hits . total !== 0 ) { callback ( data . hits ) ; } else { callback ( undefined ) ; } } ) ; }
function ( ) { if ( ! this . IsNavigating ( ) ) return ; this . _onNavigationEnded ( ) ; this . StopMoving ( ) ; var curTile = this . GetCenterRounded ( ) ; if ( ! NavigationManager . IsTileClaimedByOthers ( curTile , this ) ) NavigationManager . ClaimTile ( this , curTile ) ; }
function lineCreate ( AX , AY , AEndX , AEndY ) { var t = new Object ( ) ; t . Type = 'Line' ; t . Thicknes = 1 ; t . Selected = false ; t . Color = 'black' ; t . X = AX ; t . Y = AY ; t . EndX = AEndX ; t . EndY = AEndY ; return t ; }
function textDrawItem ( ADx , ADy , AItem ) { textDraw ( AItem . Caption , AItem . X , AItem . Y , AItem . Width , AItem . Height , AItem . Font , AItem . Color , AItem . Selected , ADx , ADy ) ; }
function textCreate ( ACaption , AX , AY ) { var t = new Object ( ) ; t . Type = 'Text' ; t . Selected = false ; t . X = AX ; t . Y = AY ; t . Height = 13 ; t . Font = 'Sans' ; textChangeCaption ( t , ACaption ) ; return t ; }
function undoPop ( AReport ) { if ( ! undoAvailable ( ) ) { console . log ( 'Undo not avalilable!' ) ; return AReport ; } document . getElementById ( 'items' ) . innerHTML = 'Items: ' + itemSelectedCount ( AReport ) + '/' + AReport . length ; var r = undo . pop ( ) ; current_item = itemFirstSelected ( r ) ; attributesShow ( current_item ) ; return r ; }
function autoHandleError ( fn ) { if ( fn . includeError ) { return fn ; } return function ( err ) { if ( err ) { return this . error ( err ) ; } var args = slice . call ( arguments , 1 ) ; fn . apply ( this , args ) ; } ; }
function ( data ) { timelineData ( data ) ; cb ( ) ; showTimeline ( ) ; if ( shouldHideTimeline ( ) ) { setTimeout ( hideTimeline , 2000 ) ; } }
function ( ) { if ( Ext . isIE6 || Ext . isIE7 || Ext . isIE8 || ( Ext . isIE && this . document . documentMode < 9 ) ) { Ext . each ( this . config . customTags , function ( tag ) { this . document . createElement ( tag ) ; } , this ) ; } }
function ( ancestor ) { if ( Ext . isIE8 || Ext . isIE7 || Ext . isIE6 ) { isFullySelected = ( type !== 'Control' && ancestor . innerText == range . text ) || ( type === 'Control' && ancestor . innerText == range . item ( 0 ) . text ) ; } else { isFullySelected = ( ancestor . textContent == range . toString ( ) ) ; } if ( isFullySelected ) { node = ancestor ; return false ; } }
function ( toBeInserted ) { if ( Ext . isIE8 || Ext . isIE7 || Ext . isIE6 ) { this . insertHtml ( toBeInserted . outerHTML ) ; } else { var range = this . createRange ( ) ; range . deleteContents ( ) ; toBeSelected = ( toBeInserted . nodeType === HTMLArea . DOM . DOCUMENT_FRAGMENT_NODE ) ? toBeInserted . lastChild : toBeInserted ; range . insertNode ( toBeInserted ) ; this . selectNodeContents ( toBeSelected , false ) ; } return this ; }
function ( memo , i ) { memo . resources . push ( { name : 'item ' + i } ) ; if ( params . data . set ) { split = params . data . set . split ( ':' ) ; _ . last ( memo . resources ) [ split [ 0 ] ] = split [ 1 ] ; } return memo ; } , { total : num , resources : [ ] }
function rectToBallCollide ( height , width , rectx , recty ) { if ( x + 10 > rectx && x - 10 < rectx + width && y + 10 > recty && y - 10 < recty + height ) return true ; return false ; }
function ( val ) { self . stack . moveToPixel ( val , self . stack . y , self . stack . x , self . stack . s ) ; return ; }
function ( ) { _this . execute ( ) ; }
function ( err ) { if ( err ) { throw err ; } }
function setCurrentView ( viewName , obj ) { if ( current . view == viewName ) { return ; } if ( ! obj ) { obj = $ ( '#navlist a.view[rel=' + viewName + ']' ) ; } current . view = viewName ; $ ( '#navlist a.view' ) . attr ( 'class' , 'view' ) ; obj . addClass ( 'current' ) ; updateVisibleTorrents ( ) ; }
function ( i , item ) { if ( DBPhotos . findOne ( { url : item . media . m } ) == null ) { alert ( "adding one" ) item . url = item . media . m ; DBPhotos . insert ( item ) ; } ; }
function ( ) { $ . each ( myData . items , function ( i , item ) { if ( DBPhotos . findOne ( { url : item . media . m } ) == null ) { alert ( "adding one" ) item . url = item . media . m ; DBPhotos . insert ( item ) ; } ; } ) ; }
function ( done ) { it ( 'should pass something to the callback (cannot be null)' , function ( ) { dog . on ( 'look' , function ( obj ) { obj . should . not . be . empty ; done ( ) ; } ) ; } ) ; it ( '' ) ; }
function ( i ) { return i ; }
function ( ) { expect ( 2 ) ; equal ( baidu ( "#text1" ) . attr ( "value" , function ( ) { return this . id ; } ) [ 0 ] . value , "text1" , "Set value from id" ) ; equal ( baidu ( "#text1" ) . attr ( "title" , function ( i ) { return i ; } ) . attr ( "title" ) , "0" , "Set value with an index" ) ; }
function getImportGlobalsSrc ( ) { var key , value , src = "" ; for ( key in global ) { if ( global . hasOwnProperty ( key ) && key !== "global" ) { value = global [ key ] ; src += "var " + key + " = global." + key + "; " ; } } return src ; }
function cleanRequireCache ( ) { var moduleName , modulePath ; for ( moduleName in testModules ) { if ( testModules . hasOwnProperty ( moduleName ) ) { modulePath = testModules [ moduleName ] ; if ( typeof window === "undefined" ) { delete require . cache [ modulePath ] ; } else { if ( typeof window . browserifyRequire . modules [ modulePath ] . _cached === "object" ) { delete window . browserifyRequire . modules [ modulePath ] . _cached ; } } } } }
function ( done ) { var rewiredModuleA = rewire ( "./moduleA.js" ) , mockedFs = { readFileSync : function ( file ) { expect ( file ) . to . be ( "bla.txt" ) ; done ( ) ; } } ; rewiredModuleA . __set__ ( "fs" , mockedFs ) ; rewiredModuleA . readFileSync ( ) ; }
function ( code , message , exit ) { var message = Array . prototype . slice . call ( arguments , 1 ) ; message . unshift ( "ERR!" . red . inverse ) ; stdout . apply ( this , message ) ; if ( exit == null || exit == true ) { process . exit ( arguments [ 0 ] ) ; } }
function ( ) { elapsed ++ ; remaining = limit - elapsed ; $ ( "#timer" ) . html ( function ( ) { return lpad ( Math . floor ( remaining / 60 ) , 2 ) + ":" + lpad ( remaining - ( Math . floor ( remaining / 60 ) * 60 ) , 2 ) ; } ) ; if ( remaining === 0 ) { clearInterval ( timer ) ; $ ( '#console' ) . append ( '<li>Time out. You BOTH lose!</li>' ) ; } }
function ( string ) { var channels = client . channelNames ( ) var newstring = string for ( x in channels ) { if ( string . toLowerCase ( ) . indexOf ( "#" + channels [ x ] . toLowerCase ( ) ) != - 1 ) { var channel = new RegExp ( "#" + channels [ x ] , "i" ) newstring = string . replace ( channel , '<a href="po:join/' + channels [ x ] + '">#' + channels [ x ] + "</a>" ) } } return newstring }
function ( text ) { var m = String ( text ) ; if ( m . length > 0 ) { var amp = "&am" + "p;" ; var lt = "&l" + "t;" ; var gt = "&g" + "t;" ; return m . replace ( /&/g , amp ) . replace ( /</g , lt ) . replace ( />/g , gt ) ; } else { return "" ; } }
function destroy ( ) { this . removeAllListeners ( ) ; if ( this . socket ) { try { this . socket . end ( ) ; this . socket . destroy ( ) ; } catch ( ex ) { } } this . data = '' ; this . emit ( 'destroy' ) ; }
function doReconnect ( ) { self . retry . waiting = true ; self . socket . removeAllListeners ( ) ; self . socket = common . createSocket ( self . _options ) ; self . socket . once ( 'connect' , function ( ) { self . retry . waiting = false ; self . retry . retries = 0 ; } ) ; self . _setup ( ) ; self . connect ( ) ; }
function _fetchHeader ( chunk ) { var header if ( this . _bufferJoiner . length + chunk . length >= 9 ) { header = this . _bufferJoiner . add ( chunk ) . join ( ) ; this . _eventLength = header . readUInt32BE ( 0 ) ; this . _messageLength = header . readUInt32BE ( 4 ) ; this . _messagetype = header . readInt8 ( 8 ) ; this . _fetchBody ( chunk . slice ( 9 ) ) ; } else { this . _bufferJoiner . add ( chunk ) ; } }
function ( _ , data ) { assert . isString ( data ) ; assert . isArray ( this . event ) ; assert . lengthOf ( this . event , 3 ) ; assert . equal ( this . event [ 0 ] , 'data' ) ; assert . equal ( this . event [ 1 ] , 'here' ) ; assert . equal ( this . event [ 2 ] , 'is' ) ; assert . equal ( data , 'something' ) ; }
function ( ) { jsdom = require ( 'jsdom' ) ; jQuery = require ( 'jquery' ) . create ( ) ; global . jQuery = global . $ = jQuery ; window = jsdom . jsdom ( ) . createWindow ( '<html><body></body></html>' ) global . document = window . document ; global . jQuery = global . $ = jQuery global . addEventListener = window . addEventListener }
function Configger ( config ) { this . root = config . root ; this . tmpl = config . tmpl ; this . filter = new RegExp ( config . filter ) ; this . output = config . output ; this . key = config . key ; this . extRegex = /\.js$/ ; }
function ( file ) { var stat = fs . statSync ( path . join ( this . root , file ) ) ; return ! stat . isDirectory ( ) && stat . isFile ( ) && this . extRegex . test ( file ) && this . filter . test ( file ) ; }
function ( file ) { var contents , out = { path : { full : path . join ( this . root , file ) , relative : file } , contents : null } ; contents = fs . readFileSync ( out . path . full , "utf-8" ) ; if ( contents ) { out . contents = contents ; return out ; } }
function ( url , options ) { if ( options === null || options === "undefined" ) { var options = new Object ( ) ; options . showLocationBar = true ; } cordova . exec ( this . _onEvent , this . _onError , "ChildBrowser" , "showWebPage" , [ url , options ] ) ; }
function ( url ) { if ( pg ) { if ( os === 'android' ) { cordova . exec ( null , null , 'ChildBrowser' , 'showWebPage' , [ url , false ] ) ; } else { window . plugins . childBrowser . showWebPage ( url ) ; } return ; } window . location = url ; }
function ( err , exists , record ) { if ( exists === true && record !== 'undefined' ) { movieFile . setMachineFileName ( record . machineFileName ) ; movieFile . setId ( record . _id ) ; console . log ( record ) ; } else { movieFile . createNewMachineFileName ( ) ; } var machineName = movieFile . getMachineFileName ( ) ; files [ machineName ] = movieFile ; prepareToUpload ( files [ machineName ] ) ; }
function ( model ) { this . model = model ; }
function ( ) { var _this = this ; this . id = "" ; this . description = "" ; this . type = type ; this . date = date ; this . time = "" ; this . setDate = function ( date ) { _this . date = date ; } ; this . setType = function ( type ) { _this . type = type ; } ; }
function ( ) { this . createAttribute ( 'gap' , 0 ) ; this . callSuper ( 'init' ) ; this . createEventListener ( 'gapPropertyChanged' , this . selfRefreshLayout , this ) ; this . createEventListener ( 'verticalAlignPropertyChanged' , this . selfRefreshLayout , this ) ; this . createEventListener ( 'horizontalAlignPropertyChanged' , this . selfRefreshLayout , this ) ; }
function ( element ) { if ( this . getElementIndex ( element ) != - 1 ) { this . elements . splice ( this . elements . indexOf ( element ) , 1 ) ; this . deactivateElement ( element ) ; element . parent = null ; element . triggerEvent ( "parentChanged" ) ; this . triggerEvent ( 'elementsPropertyChanged' ) ; } }
function ( ) { this . createAttribute ( 'label' , '' , 'string' ) ; this . createAttribute ( 'disabled' , false , 'boolean' ) ; }
function ( ) { this . callSuper ( 'createAttributes' ) ; this . buttonCreateAttributes ( ) ; this . focusableCreateAttributes ( ) ; this . createAttribute ( 'enabled' , true , 'boolean' ) ; this . createAttribute ( 'label' , 'Button' ) ; this . declareSkinPart ( 'label' , false , 'core.Label' ) ; }
function ( ) { this . callSuper ( 'init' ) ; this . buttonInit ( ) ; this . focusableInit ( ) ; this . setSkinClass ( 'core.skins.ButtonSkin' ) ; this . setWidth ( '90px' ) ; this . setHeight ( '23px' ) ; this . createEventListener ( 'labelPropertyChanged' , this . updateLabel , this ) ; this . createEventListener ( 'currentStatePropertyChanged' , this . cStateChanged , this ) ; this . setCurrentState ( "up" ) ; }
function ( element , options ) { console . log ( this . options [ 0 ] . patente ) this . element . append ( can . view ( url + 'gadget/estadoUsuario/estadoUsuario.ejs' , this . options ) ) $ . mobile . changePage ( $ ( '#statusPage' ) ) }
function ( ) { if ( ! this . disabled ) { var me = this ; baidu . dom . addClass ( this . getElement ( 'container' ) , 'magic-combobox-disable' ) ; this . getElement ( 'input' ) . disabled = true ; me . disabled = true ; } }
function ( ) { if ( this . disabled ) { var me = this ; baidu . dom . removeClass ( this . getElement ( 'container' ) , 'magic-combobox-disable' ) ; this . getElement ( 'input' ) . disabled = false ; me . disabled = false ; } }
function ( ) { var v = new Cartesian2 ( 1 , 2 ) ; var w = Cartesian2 . clone ( v ) ; expect ( v . equals ( w ) ) . toEqual ( true ) ; }
function ( ) { var v = new Cartesian2 ( 2 , 3 ) ; expect ( v . magnitudeSquared ( ) ) . toEqual ( 13 ) ; }
function ( ) { var v = new Cartesian2 ( 2 , 0 ) . normalize ( ) ; expect ( v . x ) . toEqual ( 1 ) ; expect ( v . y ) . toEqual ( 0 ) ; }
function ( ) { var s = new Cartesian2 ( 2 , 3 ) . dot ( new Cartesian2 ( 4 , 5 ) ) ; expect ( s ) . toEqual ( 2 * 4 + 3 * 5 ) ; }
function ( ) { var v = new Cartesian2 ( 1 , 2 ) . multiplyWithScalar ( 2 ) ; expect ( v . equals ( new Cartesian2 ( 2 , 4 ) ) ) . toEqual ( true ) ; }
function ( ) { var v = new Cartesian3 ( 1 , 2 , 3 ) ; expect ( v . getXY ( ) . equals ( new Cartesian2 ( 1 , 2 ) ) ) . toEqual ( true ) ; expect ( v . z ) . toEqual ( 3 ) ; }
function ( ) { var v = new Cartesian4 ( 1 , 2 , 3 , 4 ) ; expect ( v . getXY ( ) . equals ( new Cartesian2 ( 1 , 2 ) ) ) . toEqual ( true ) ; expect ( v . z ) . toEqual ( 3 ) ; expect ( v . w ) . toEqual ( 4 ) ; }
function ( ev ) { if ( ev . which == 13 && $ ( this ) . val ( ) ) { $ ( '#status-form' ) . submit ( ) ; } }
function ( request , sender , sendResponse ) { if ( request . type && request . type == 'inboxDataAvailable' ) { self . updateDOM ( ) ; } else if ( request . type && request . type == 'statusMessageUpdate' ) { if ( request . msg ) { $ ( '#head-col2-row1' ) . text ( request . msg ) ; } } if ( request . type && sendResponse ) sendResponse ( ) ; }
function ( require , exports , module ) { var ctx = requirejs . config ( { context : "butter" , baseUrl : module . uri . substring ( 0 , module . uri . lastIndexOf ( '/' ) ) , paths : { 'text' : '../external/require/text' } } ) ; ctx ( [ "../include/editors" , "main" ] ) ; }
function openEditor ( trackEvent ) { var editorType = Editor . isRegistered ( trackEvent . type ) || "default" ; if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( editorType , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; return _currentEditor ; }
function ( e ) { var newState = ! editorAreaDOMRoot . classList . contains ( "minimized" ) ; toggler . state = newState ; if ( newState ) { editorAreaDOMRoot . classList . add ( "minimized" ) ; } else { editorAreaDOMRoot . classList . remove ( "minimized" ) ; } }
function ( url , callback ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( "GET" , url , true ) ; xhr . onreadystatechange = callback ; xhr . setRequestHeader ( "X-Requested-With" , "XMLHttpRequest" ) ; xhr . send ( null ) ; }
function ( decimal ) { if ( ! ( decimal < 0 || decimal >= 0 ) ) { decimal = parseFloat ( decimal ) ; } this . negative = decimal < 0 ? true : false ; this . absolute = Math . abs ( decimal ) ; this . decimal = decimal ; }
function ( key ) { if ( ! key ) { return currentLanguage ; } currentLanguage = "en" ; key = key . toLowerCase ( ) ; if ( typeof languages [ key ] !== "undefined" ) { currentLanguage = key ; } else if ( key . indexOf ( "-" ) > 0 ) { var main = key . substr ( 0 , key . indexOf ( "-" ) ) ; if ( typeof languages [ main ] !== "undefined" ) { currentLanguage = key ; } } return currentLanguage ; }
function ( ) { var instance = this ; if ( instance . _syncMessage ) { var entryPaginator = instance . _paginatorAjaxNavigation . getEntryPaginator ( ) var entriesPaginatorState = entryPaginator . get ( 'state' ) ; var syncMessageBoundingBox = instance . _syncMessage . get ( 'boundingBox' ) ; syncMessageBoundingBox . toggleClass ( CSS_SYNC_MESSAGE_HIDDEN , entriesPaginatorState . total <= 0 ) ; } }
function thrown ( error , steps , index , context , callbacks , callback ) { if ( steps . length && steps . length && ~ steps [ 0 ] . parameters . indexOf ( "error" ) ) { context . error = error ; } abended = true ; if ( timer ) clearTimeout ( timer ) ; callback ( error ) ; }
function ( ) { app . set ( 'port' , 80 ) ; app . set ( "database" , "techmat" ) ; app . set ( 'views' , __dirname + '/views' ) ; app . set ( 'view engine' , 'jade' ) ; app . use ( express . bodyParser ( ) ) ; app . use ( express . methodOverride ( ) ) ; app . use ( app . router ) ; app . use ( express . static ( __dirname + '/public' ) ) ; }
function submit_job ( ) { document . forms . submission_form . submit ( ) ; }
function showSuccessMessage ( data ) { $ ( '#successMsg' ) . html ( data ) . fadeIn ( 'fast' , function ( ) { var me = $ ( this ) ; setTimeout ( function ( ) { me . fadeOut ( 'fast' ) ; } , 5000 ) ; } ) ; }
function getNonFrameBody ( elt ) { var body = Dom . getBody ( elt . ownerDocument ) ; return ( body . localName && body . localName . toUpperCase ( ) === "FRAMESET" ) ? null : body ; }
function ( tempArray ) { var paraArray = ( typeof tempArray == "Array" ) ? tempArray : arguments ; var prev = paraArray [ 0 ] ; for ( var i = 1 ; i < paraArray . length ; i ++ ) { if ( paraArray [ i ] != null ) { prev = cc . Sequence . _actionOneTwo ( prev , paraArray [ i ] ) ; } } return prev ; }
function ( tempArray ) { var paramArray = ( typeof tempArray == "Array" ) ? tempArray : arguments ; var prev = paramArray [ 0 ] ; for ( var i = 1 ; i < paramArray . length ; i ++ ) { if ( paramArray [ i ] != null ) { prev = this . _actionOneTwo ( prev , paramArray [ i ] ) ; } } return prev ; }
function ( ) { data = { post_type : 'post' , post_status : 'draft' , post_title : 'newPost' , post_author : 1 , post_excerpt : '' , post_content : '通过Wordpress Xmlrpc API 创建文章测试' , post_format : '' , } ; object = wp . newPost ( 1 , data ) ; equal ( true , object > 0 , "Post created" ) ; wp . deletePost ( 1 , object ) ; }
function ( ) { data = { post_type : 'post' , post_status : 'draft' , post_title : 'newPost' , post_author : 1 , post_excerpt : '' , post_content : '通过Wordpress Xmlrpc API 创建文章测试' , post_format : '' , } ; object = wp . newPost ( 1 , data ) ; object = wp . deletePost ( 1 , object ) ; equal ( true , object , "Post sucessfully deleted" ) ; }
function ( ) { object = wp . getPostStatusList ( 1 ) ; equal ( true , typeof object == "object" , "OK" ) equal ( typeof object . draft , "object" , "Have draft" ) ; equal ( typeof object . pending , "object" , "Have pending" ) ; equal ( typeof object . private , "object" , "Have private" ) ; equal ( typeof object . publish , "object" , "Have publish" ) ; }
function ( ) { this . _image = L . DomUtil . create ( 'img' , 'leaflet-image-layer leaflet-zoom-animated' ) ; this . _image . style . visibility = 'hidden' ; this . _updateOpacity ( ) ; L . Util . extend ( this . _image , { galleryimg : 'no' , onselectstart : L . Util . falseFn , onmousemove : L . Util . falseFn , onload : L . Util . bind ( this . _onImageLoad , this ) , src : this . _url } ) ; }
function ( mousePos , delta ) { var map = this . _map , scale = Math . pow ( 2 , delta ) , viewHalf = map . getSize ( ) . divideBy ( 2 ) , centerOffset = mousePos . subtract ( viewHalf ) . multiplyBy ( 1 - 1 / scale ) , newCenterPoint = map . getPixelOrigin ( ) . add ( viewHalf ) . add ( centerOffset ) ; return map . unproject ( newCenterPoint ) ; }
function ( square ) { if ( square . tile && lettersToReturn . contains ( square . tile . letter ) ) { lettersToReturn . remove ( square . tile . letter ) ; square . placeTile ( null ) ; square . placeTile ( tilesTakenBack . unshift ( ) ) ; } }
function ( done ) { RelMe . getLinks ( "http://localhost:4816/missing" , function ( err , links ) { should . exist ( err ) ; err . should . be . a ( "object" ) ; err . should . be . an . instanceOf ( Error ) ; done ( ) ; } ) ; }
function ( err , links ) { should . exist ( err ) ; err . should . be . a ( "object" ) ; err . should . be . an . instanceOf ( Error ) ; done ( ) ; }
function ( done ) { RelMe . getLinks ( "http://localhost:4816/image.png" , function ( err , links ) { should . exist ( err ) ; err . should . be . a ( "object" ) ; err . should . be . an . instanceOf ( Error ) ; done ( ) ; } ) ; }
function ( ) { self . _createDraftComment ( ) ; gCommentDlg . setDraftComment ( self . draftComment ) . setCommentsList ( self . comments , "comment" ) . css ( { left : $ ( document ) . scrollLeft ( ) + ( $ ( window ) . width ( ) - gCommentDlg . width ( ) ) / 2 , top : self . endRow . offset ( ) . top + self . endRow . height ( ) } ) . open ( self . el ) ; }
function ( evt ) { if ( this . inRoundedMold ( ) && ! this . _buttonVisible ) return ; if ( ! this . _disabled && ! zk . animating ( ) ) { if ( this . _open ) this . close ( { focus : true , sendOnOpen : true } ) ; else this . open ( { focus : true , sendOnOpen : true } ) ; } evt . stop ( ) ; }
function ( sel , opts ) { var inp = this . getInputNode ( ) , val = inp . value = sel ? sel . getLabel ( ) : '' ; this . valueSel_ = val ; this . _hilite2 ( sel , opts ) ; if ( val ) if ( zk . gecko ) inp . select ( ) ; else zk ( inp ) . setSelectionRange ( 0 , val . length ) ; }
function ( evt ) { if ( ! this . _disabled ) { this . _doMouseOut ( ) ; var cb = this . parent ; cb . _select ( this , { sendOnSelect : true , sendOnChange : true } ) ; this . _updateHoverImage ( ) ; cb . close ( { sendOnOpen : true } ) ; cb . _shallClose = true ; zk ( cb . getInputNode ( ) ) . focus ( ) ; evt . stop ( ) ; } }
function ( source , actor , x , y , time ) { if ( source instanceof FavoritesButton ) { AppFavorites . getAppFavorites ( ) . removeFavorite ( source . app . get_id ( ) ) ; return true ; } return false ; }
function getMime ( file ) { switch ( path . extname ( file ) ) { case '.js' : return 'text/javascript' ; case '.css' : return 'text/css' ; case '.htm' : case '.html' : return 'text/html' default : return 'application/octet-stream' } }
function ( name , value ) { var names = name . split ( d3_selection_classedWhitespace ) , n = names . length , i = - 1 ; if ( arguments . length > 1 ) { while ( ++ i < n ) d3_selection_classed . call ( this , names [ i ] , value ) ; return this ; } else { while ( ++ i < n ) if ( ! d3_selection_classed . call ( this , names [ i ] ) ) return false ; return true ; } }
function ( callback ) { for ( var j = - 1 , m = this . length ; ++ j < m ; ) { for ( var group = this [ j ] , i = - 1 , n = group . length ; ++ i < n ; ) { var node = group [ i ] ; if ( node ) callback . call ( node , node . __data__ , i , j ) ; } } return this ; }
function ( value ) { var groups = this ; return groups . each ( typeof value === "function" ? function ( d , i , j ) { groups [ j ] [ i ] . delay = value . apply ( this , arguments ) | 0 ; } : ( value = value | 0 , function ( d , i , j ) { groups [ j ] [ i ] . delay = value ; } ) ) ; }
function ( value ) { var groups = this ; return groups . each ( typeof value === "function" ? function ( d , i , j ) { groups [ j ] [ i ] . duration = Math . max ( 1 , value . apply ( this , arguments ) | 0 ) ; } : ( value = Math . max ( 1 , value | 0 ) , function ( d , i , j ) { groups [ j ] [ i ] . duration = value ; } ) ) ; }
function path ( d , i ) { if ( typeof pointRadius === "function" ) { pointCircle = d3_path_circle ( pointRadius . apply ( this , arguments ) ) ; } return pathType ( d ) || null ; }
function ( o ) { var path = [ ] , features = o . features , i = - 1 , n = features . length ; while ( ++ i < n ) path . push ( pathType ( features [ i ] . geometry ) ) ; return path . join ( "" ) ; }
function ( o ) { var path = [ ] , geometries = o . geometries , i = - 1 , n = geometries . length ; while ( ++ i < n ) path . push ( pathType ( geometries [ i ] ) ) ; return path . join ( "" ) ; }
function ( ) { var a = typeof source === "function" ? source . apply ( this , arguments ) : source , b = typeof target === "function" ? target . apply ( this , arguments ) : target ; return d3_geo_greatArcInterpolate ( a , b ) . d ; }
function ( ) { createButter ( function ( butter ) { var m1 = butter . addMedia ( { name : "Media 1" , target : "audio-test" , url : "../external/popcorn-js/test/trailer.ogv" } ) ; ok ( m1 . name === "Media 1" , "Name is correct" ) ; ok ( m1 . target === "audio-test" && m1 . url === "../external/popcorn-js/test/trailer.ogv" , "Media storage is correct" ) ; start ( ) ; } ) ; }
function createEndBreak ( ) { var endBr = document . createElement ( "br" ) ; endBr . setAttribute ( "class" , "aloha-end-br" ) ; if ( jQuery . browser . msie && jQuery . browser . version < 8 ) { var endTextNode = document . createTextNode ( ' ' ) ; endBr . insertBefore ( endTextNode ) ; } return endBr ; }
function requireLogin ( req , res , next ) { if ( ! req . url . match ( /login/ ) && ! req . user ) { req . flash ( "info" , "please login" ) ; res . redirect ( '/login' ) ; } next ( ) ; }
function ( type , indexName , callback ) { if ( Array . isArray ( indexName ) ) { var delfn = naan . curry ( this , indexModule . delete , type ) ; return async . map ( indexName , delfn , callback ) ; } var endpoint = util . format ( 'index/%s/%s' , type , indexName ) ; var op = this . operation ( endpoint , 'DELETE' ) ; this . call ( op , function ( err ) { callback ( err ) ; } ) ; }
function ( fieldIndex , filterFunc ) { var rawData ; if ( filterFunc == null ) { filterFunc = function ( dp ) { return true ; } ; } rawData = data . selector ( fieldIndex , filterFunc ) ; return rawData . reduce ( function ( a , b ) { return Math . min ( a , b ) ; } ) ; }
function ( fieldIndex , filterFunc ) { var rawData ; if ( filterFunc == null ) { filterFunc = function ( dp ) { return true ; } ; } rawData = data . selector ( fieldIndex , filterFunc ) ; return ( rawData . reduce ( function ( a , b ) { return a + b ; } ) ) / rawData . length ; }
function ( el , type , fn ) { if ( typeof el === 'string' ) { return ; } win . HighchartsAdapter . extendWithEvents ( el ) ; if ( type ) { if ( type === 'unload' ) { type = 'beforeunload' ; } if ( fn ) { el . removeEvent ( type , fn ) ; } else { el . removeEvents ( type ) ; } } else { el . removeEvents ( ) ; } }
function ( index , value ) { addLink ( value ) ; }
function ( ) { var pos = this . transform . getPos ( ) ; var size = this . scene . renderer . get ( 'size' ) ; return new modula . Rect ( pos . x , pos . y , size . x , size . y , 'centered' ) ; }
function ( ) { for ( var x = 0 ; x < this . _cellX ; x ++ ) { for ( var y = 0 ; y < this . _cellY ; y ++ ) { this . set ( 'cell' , [ x , y ] , '[' + x + ',' + y + ']' ) ; } } }
function ( cell ) { var bound = cell . bound ; if ( cell . cell ) { this . colVec = this . collisionAxis ( bound ) ; this . increase ( 'pos' , this . colVec ) ; if ( this . colVec . len ( ) > 1 ) { return true ; } } }
function ( scale ) { this . scale . x = scale . x ; this . scale . y = scale . y ; reset_matrix ( this ) ; return this ; }
function huntsel ( x ) { $ ( 'activity' ) . innerHTML = '' ; $ ( 'students' ) . innerHTML = '' ; if ( x != 'null' ) { var hunt = hunts [ x ] ; ajax ( "what=activities&id=" + hunt [ 'id' ] , PHP_FOLDER_LOCATION + 'retrive.php' , create_activity_obj ) ; } else { feed = { } ; activities = [ ] ; } }
function ( chrome ) { window . frames [ this . getIframeId ( ) ] . location = this . getIframeUrl ( ) ; if ( my . gadgets [ this . id ] . start_closed ) { this . handleToggle ( ) ; } else if ( chrome ) { chrome . style . width = ( my . gadgets [ this . id ] . open_width || 600 ) + 'px' ; } }
function ( elems ) { var up , _ref ; elems . removeAttr ( editable ) . removeAttr ( 'class' ) ; while ( _ref = elems . text ( ) , __indexOf . call ( empty , _ref ) >= 0 ) { up = elems . parent ( ) ; elems . remove ( ) ; elems = up ; } click_choose ( elems ) ; return elems ; }
function ( ) { debug . liveMonitor = false ; $ ( '#debug-geoStoreFlag' ) . prop ( "checked" , true ) ; $ ( '#debug-compassStoreFlag' ) . prop ( "checked" , true ) ; $ ( '#debug-accelerometerStoreFlag' ) . prop ( "checked" , true ) ; $ ( '#debug-gyroscopeStoreFlag' ) . prop ( "checked" , true ) ; storageAPI . reset ( ) ; $ ( '#debug-DC' ) . html ( "<p>Initialised</p>" ) ; }
function link ( textID ) { var linkAddr = prompt ( "Please enter the relative page url\nNOTE: only local pages!" , "/" ) ; if ( linkAddr && linkAddr != "/" ) { var linkTitle = prompt ( "Please enter the link text" , " " ) ; if ( linkAddr && linkTitle ) wrap ( 'link' , linkTitle , linkAddr , textID ) ; } }
function url ( textID ) { var linkAddr = prompt ( "Please enter the full URL" , "http://" ) ; if ( linkAddr && linkAddr != "http://" ) { var linkTitle = prompt ( "Please enter the title" , " " ) ; if ( linkAddr && linkTitle ) wrap ( 'url' , linkTitle , linkAddr , textID ) ; } }
function spoiler ( textID ) { var spoilertext = prompt ( "Please enter the spoiler text" , " " ) ; if ( spoilertext && spoilertext != " " ) { var linkTitle = prompt ( "Please enter the title" , " " ) ; if ( spoilertext && linkTitle ) wrap ( 'spoiler' , spoilertext , linkTitle , textID ) ; } }
function changePlatformType ( form , runId ) { Fluxion . doAjax ( 'runControllerHelperService' , 'changePlatformType' , { 'platformtype' : form . value , 'runId' : runId , 'url' : ajaxurl } , { 'doOnSuccess' : function ( json ) { jQuery ( '#sequencerReferenceSelect' ) . html ( json . sequencers ) ; poolSearch ( "" , jQuery ( 'input[name=platformType]:checked' ) . val ( ) ) ; } } ) ; }
function populateRunOptions ( form , runId ) { if ( form . value != 0 ) { Fluxion . doAjax ( 'runControllerHelperService' , 'populateRunOptions' , { 'sequencerReference' : form . value , 'runId' : runId , 'url' : ajaxurl } , { 'doOnSuccess' : function ( json ) { jQuery ( '#runPartitions' ) . html ( json . partitions ) ; } } ) ; } }
function changeContainer ( numContainers , platform , seqrefId ) { Fluxion . doAjax ( 'runControllerHelperService' , 'changeContainer' , { 'platform' : platform , 'numContainers' : numContainers , 'sequencerReferenceId' : seqrefId , 'url' : ajaxurl } , { 'updateElement' : 'containerdiv' } ) ; }
function lookupContainer ( t , containerNum ) { var barcode = jQuery ( '#sequencerPartitionContainers' + containerNum + '\\.identificationBarcode' ) . val ( ) ; if ( ! isNullCheck ( barcode ) ) { Fluxion . doAjax ( 'runControllerHelperService' , 'lookupContainer' , { 'barcode' : barcode , 'containerNum' : containerNum , 'url' : ajaxurl } , { 'doOnSuccess' : processLookup } ) ; } }
function changeContainerPlatformType ( form ) { Fluxion . doAjax ( 'containerControllerHelperService' , 'changePlatformType' , { 'platformtype' : form . value , 'url' : ajaxurl } , { 'doOnSuccess' : function ( json ) { jQuery ( '#sequencerReferenceSelect' ) . html ( json . sequencers ) ; } } ) ; }
function changeContainer ( numContainers , platform , seqrefId ) { Fluxion . doAjax ( 'containerControllerHelperService' , 'changeContainer' , { 'platform' : platform , 'numContainers' : numContainers , 'sequencerReferenceId' : seqrefId , 'url' : ajaxurl } , { 'updateElement' : 'containerdiv' } ) ; }
function ( ) { var _cloner = null ; if ( window . jQuery ) { _cloner = { extend : function ( destinationObject , originObject ) { return jQuery . extend ( true , destinationObject , originObject ) ; } , clone : function ( clonable ) { return jQuery . extend ( true , { } , clonable ) ; } } ; } else if ( window . pi ) { _cloner = window . pi ; } else { throw ( 'SeedJs needs either PiJs or jQuery' ) ; } return _cloner ; }
function ( e ) { currentHandler . call ( event . currentTarget , event , data ) ; document . removeEventListener ( 'eventWrapper' , arguments . callee , false ) ; }
function ( e ) { if ( e . propertyName == "eventWrapper" ) { currentHandler . call ( event . currentTarget , event , data ) ; document . documentElement . detachEvent ( "onpropertychange" , arguments . callee ) ; } }
function ( ) { $ ( 'news-container' ) . set ( 'html' , response ) ; $ ( 'news-container' ) . setStyle ( 'opacity' , '1' ) ; }
f { var first = '{"jsonrpc": "1.0", "id":"' + id + '", "method":"' + name + '", ' var last = '"params": [' for ( s in send ) { var last = last + s ; } last = last + ']' ; return first + last ; }
function ( url ) { var match = /(?:^|;\s*)(JSESSIONID|PHPSESSID)=([^;]*)/ . exec ( document . cookie ) ; switch ( match && match [ 1 ] ) { case "JSESSIONID" : return url . replace ( /;jsessionid=[^\?]*|(\?)|$/ , ";jsessionid=" + match [ 2 ] + "$1" ) ; case "PHPSESSID" : return url . replace ( /\?PHPSESSID=[^&]*&?|\?|$/ , "?PHPSESSID=" + match [ 2 ] + "&" ) . replace ( /&$/ , "" ) ; } }
function ( inx , doc ) { if ( vidCount > totalVideoCount ) { return ; } vidCount ++ ; _this . $target . append ( $ ( "<div class=\"video-container\" />" ) . append ( $ ( '<video />' ) . attr ( { 'poster' : doc . thumb , 'src' : doc . video , 'preload' : 'none' , 'autoplay' : true } ) . data ( 'meta' , doc ) ) ) ; }
function ( evt ) { var now = + new Date ; if ( now - lastMove > 100 ) { console . log ( now - lastMove ) ; console . log ( evt ) ; lastMove = now ; connection . sendMessage ( { position : { x : evt . clientX , y : evt . clientY } } ) ; } }
function ( c ) { c . fillStyle = this . color ; c . beginPath ( ) ; var r = this . radius ( ) ; c . arc ( - this . regX + r , - this . regY + r , r , 0 , Math . PI * 2 , true ) ; c . closePath ( ) ; c . fill ( ) ; return this ; }
function ( ) { $ ( ".title" ) . text ( "My Notebook" ) ; document . title = "My Notebook - Sage" ; $ ( "#search_input" ) . val ( "" ) ; _this . enable_actions_menu ( ) ; $ ( "#send_to_archive_button, #delete_button, #stop_button, #download_button" ) . removeClass ( "disabled" ) ; }
function ( ) { $ ( ".title" ) . text ( "Archive" ) ; document . title = "Archive - Sage" ; $ ( "#search_input" ) . val ( "" ) ; _this . enable_actions_menu ( ) ; $ ( "#unarchive_button, #delete_button, #stop_button, #download_button" ) . removeClass ( "disabled" ) ; }
function ( ) { $ ( ".title" ) . text ( "Trash" ) ; document . title = "Trash - Sage" ; $ ( "#search_input" ) . val ( "" ) ; _this . enable_actions_menu ( ) ; $ ( "#send_to_archive_button, #undelete_button, #stop_button, #download_button, #empty_trash" ) . removeClass ( "disabled" ) ; }
function ( ) { document . title = str + " - Search - Sage" ; $ ( ".title" ) . text ( str + " - Search" ) ; _this . enable_actions_menu ( ) ; $ ( "#send_to_archive_button, #delete_button, #stop_button, #download_button" ) . removeClass ( "disabled" ) ; }
function ( form ) { var req_data = require ( 'url' ) . parse ( req . url , 1 ) . query ; res . writeHead ( 200 , { 'Content-Type' : 'text/html' } ) ; res . write ( '<h1>Success!</h1>' ) ; res . end ( '<pre>' + sys . inspect ( form . data ) + '</pre>' ) ; }
function ( form ) { var req_data = require ( 'url' ) . parse ( req . url , 1 ) . query ; res . writeHead ( 200 , { 'Content-Type' : 'text/html' } ) ; res . write ( '<h1>Success!</h1>' ) ; res . end ( '<pre>' + sys . inspect ( form . data ) + '</pre>' ) ; }
function ( nodes ) { var result = Object . prototype . toString . call ( nodes ) ; if ( typeof nodes === 'object' && /^\[object (HTMLCollection|NodeList|Object)\]$/ . test ( result ) && ( nodes . length == 0 || ( typeof node === "object" && nodes [ 0 ] . nodeType > 0 ) ) ) { return true ; } return false ; }
function refresh ( ) { s . errorsElm . style . display = 'none' ; s . player . stop ( ) ; try { reportErr = true ; var code = [ '(function(){' , '  ' + s . cm . getValue ( ) , '})();' ] . join ( '\n' ) ; var scene = eval ( code ) ; player . load ( scene ) ; player . play ( ) ; } catch ( e ) { onerror ( e ) ; } }
function ( ) { $ ( '#input_fullname' ) . click ( function ( ) { fullname_check ( ) } ) ; if ( $ ( '#input_fullname' ) . val ( ) == 'e.g. John Smith' ) { $ ( '#input_fullname' ) . css ( 'color' , '#555' ) ; } $ ( 'input[type=text],input[type=password]' ) . focus ( function ( ) { $ ( this ) . css ( 'background-color' , '#313131' ) ; } ) ; }
function ( ) { $ ( this ) . addClass ( 'clevered' ) . addClass ( options . selfClass ) ; methods . init ( this ) ; }
function ( ) { if ( response . statusCode >= 300 ) { var explanation = body . match ( /<error>([^<]+)/i ) ; explanation = ( explanation ) ? ':' + explanation [ 1 ] : '' ; console . log ( 'Notification failed ' + response . statusCode + explanation ) console . log ( 'Request: ' + body ) ; } else { var m = body . match ( /<err-id>([^<]+)/i ) ; var id = ( m ) ? m [ 1 ] : null ; console . log ( 'Created in airbrake: ' + id ) ; } }
function ( ) { for ( var i = 0 ; i < els . length ; i ++ ) { cleanUpContent ( els [ i ] , kill ) ; } }
function numOnly ( val ) { if ( val === undefined ) return 0 ; if ( isNaN ( parseFloat ( val ) ) ) { if ( val . replace ) { val = val . replace ( /[^0-9.-]/ , "" ) ; } else return 0 ; } return parseFloat ( val ) ; }
function ( record , index , rowParams , store ) { var c = record . get ( 'maked' ) ; if ( c ) { return 'maked_true_class' ; } else { return 'maked_false_class' ; } }
function ( event ) { var emptyDimensions = CubeViz_Main_Module . checkDimensionElementCount ( ) ; if ( emptyDimensions . length != 0 ) { CubeViz_Main_Module . showEmptyDimensionsWarning ( emptyDimensions ) ; } else { var config = CubeViz_Main_Module . makeLink ( ) ; CubeViz_Ajax_Module . saveLinkToFile ( config ) ; } }
function ( ) { $ ( this ) . button ( ) ; $ ( this ) . attr ( "checked" , 'unchecked' ) ; $ ( this ) . button ( 'refresh' ) ; }
function ( ) { if ( show ) $ ( this ) . attr ( "checked" , 'checked' ) ; else $ ( this ) . removeAttr ( "checked" ) ; $ ( this ) . button ( 'refresh' ) ; var graphId = GRAPH_BASE_ID + $ ( this ) . attr ( 'id' ) . slice ( SHOW_EVENTS_BASE_ID_LEN ) ; showTimeShift ( graphId , show ) ; }
function ( ) { Chosen . __super__ . set_default_values . call ( this ) ; this . single_temp = new Template ( '<a href="javascript:void(0)" class="chzn-single chzn-default"><span>#{default}</span><div><b></b></div></a><div class="chzn-drop" style="left:-9000px;"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>' ) ; this . multi_temp = new Template ( '<ul class="chzn-choices"><li class="search-field"><input type="text" value="#{default}" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop" style="left:-9000px;"><ul class="chzn-results"></ul></div>' ) ; this . choice_temp = new Template ( '<li class="search-choice" id="#{id}"><span>#{choice}</span><a href="javascript:void(0)" class="search-choice-close" rel="#{position}"></a></li>' ) ; this . no_results_temp = new Template ( '<li class="no-results">' + this . results_none_found + ' "<span>#{terms}</span>".#{add_item_link}</li>' ) ; this . new_option_temp = new Template ( '<option value="#{value}">#{text}</option>' ) ; return this . add_link_temp = new Template ( ' <a href="javascript:void(0);" class="option-add">' + this . create_option_text + '</a>' ) ; }
function ( evt ) { if ( ! selected ) { return _this . select_create_option ( terms ) ; } }
function addAttributeButton ( attribute , parentXPath , parentId , buttonContainer ) { var button = $ ( '<span/>' ) . attr ( { 'id' : parentId + "_" + attribute . title + "_btn" } ) . html ( attribute . title ) . appendTo ( buttonContainer ) ; button . on ( 'click' , addAttributeButtonCallback ( attribute , parentXPath , parentId ) ) ; return button ; }
function ( ) { if ( $ ( this ) . hasClass ( "disabled" ) ) return ; createAttribute ( attribute , parentXPath , parentId ) ; $ ( this ) . addClass ( "disabled" ) ; }
function changeAttribute ( attribute , parentXPath , attributeId ) { var child = xml . evaluate ( parentXPath , xml , nsResolver , XPathResult . FIRST_ORDERED_NODE_TYPE , null ) ; if ( $ ( '#' + attributeId ) . val ( ) ) { child . singleNodeValue . setAttribute ( attribute . title , $ ( '#' + attributeId ) . val ( ) ) ; } else { child . singleNodeValue . removeAttribute ( attribute . title ) ; } }
function ( ) { changeAttribute ( attribute , parentXPath , attributeId ) ; }
function ( url ) { var dotLocation = url . lastIndexOf ( '.' ) ; if ( dotLocation < 0 ) { console . log ( "skipped no dot: " + url ) ; return false ; } var extension = url . substring ( dotLocation ) ; if ( goodExtensions . indexOf ( extension ) >= 0 ) { return true ; } else { console . log ( "skipped bad extension: " + url ) ; return false ; } }
function ( ) { var regexS = "(/(?:(?:r)|(?:user))/[^&#?]*)[?]?(.*)" ; var regex = new RegExp ( regexS ) ; var results = regex . exec ( window . location . href ) ; if ( results == null ) { return [ "" , "" ] ; } else { return [ results [ 1 ] , decodeUrl ( results [ 2 ] ) ] ; } }
function ( i , item ) { var imgUrl = item . data . url ; var title = item . data . title ; var commentsUrl = "http://www.reddit.com" + item . data . permalink ; if ( isImageUrl ( imgUrl ) ) { addImageSlide ( imgUrl , title , commentsUrl ) ; } }
function ( ) { var a = 0 ; this . autoStart && ! this . running && this . start ( ) ; if ( this . running ) { var b = Date . now ( ) , a = 0.001 * ( b - this . oldTime ) ; this . oldTime = b ; this . elapsedTime = this . elapsedTime + a } return a } ; THREE . Color = function ( a ) { a !== void 0 && this . setHex ( a ) ; return this }
function ( model , name ) { var names = get_names_for ( model ) ; if ( names . indexOf ( name ) <= 0 ) { names . push ( name ) ; } model_to_names [ model . id ] = names ; var models_with_name = resolve ( name ) ; if ( models_with_name . indexOf ( model . id ) <= 0 ) { models_with_name . push ( model ) ; } name_to_model [ name ] = models_with_name ; return model ; }
function savePolygon ( path ) { if ( typeof ( Storage ) !== "undefined" ) { console . log ( "Setting poly in localstorage" ) ; var encodedPath = google . maps . geometry . encoding . encodePath ( path ) ; localStorage . polygon = encodedPath ; } }
function ( ) { var length = this . getLength ( ) ; var has_pages = Math . floor ( length / this . page_limit ) ; var remainder = length % this . page_limit ; var next_page = has_pages + 1 ; return { current_length : length , has_pages : has_pages , page_limit : this . page_limit , remainder : remainder , next_page : next_page } ; }
function ( data ) { self . opts . populateResults ( results , data . results ) ; if ( data . more === true ) { more . detach ( ) ; results . children ( ) . filter ( ":last" ) . append ( more ) ; more . removeClass ( "select2-active" ) ; } else { more . remove ( ) ; } self . resultsPage = page ; }
function ( ) { this . ninjaVersion = window . ninjaVersion . ninja . version ; this . undoManager = document . application . undoManager = UndoManager . create ( ) ; document . application . njUtils = NjUtils ; }
function ( args ) { this . coordinate = null ; this . ticksRemaining = null ; if ( args ) { if ( args . coordinate !== undefined ) { this . coordinate = args . coordinate ; } if ( args . ticksRemaining !== undefined ) { this . ticksRemaining = args . ticksRemaining ; } } }
function ( args ) { this . coordinate = null ; this . ticksRemaining = null ; if ( args ) { if ( args . coordinate !== undefined ) { this . coordinate = args . coordinate ; } if ( args . ticksRemaining !== undefined ) { this . ticksRemaining = args . ticksRemaining ; } } }
function ( data , cb ) { if ( this . writable ) { var out = this . _write ( 2 , data , this . id , cb ) ; console . log ( out ) ; return ! this . _paused && out ; } else { throw new Error ( 'Stream is not writable' ) ; } }
function ( data , cb ) { if ( this . writable ) { var out = this . _write ( 2 , data , this . id , cb ) ; console . log ( out ) ; return ! this . _paused && out ; } else { throw new Error ( 'Stream is not writable' ) ; } }
function ( options ) { var locale = undefined ; if ( exists ( options ) ) locale = options [ "locale" ] ; if ( ! exists ( locale ) ) locale = this . locale ; return locale ; }
function ( ) { if ( this . options . fade ) { this . tip ( ) . stop ( ) . fadeOut ( function ( ) { $ ( this ) . remove ( ) ; } ) ; } else if ( this . $tip ) { this . tip ( ) . remove ( ) ; } }
function ( ) { if ( ! this . $tip ) { this . $tip = $ ( '<div class="tipsy"></div>' ) ; if ( this . options . arrow ) { this . $tip . html ( '<div class="tipsy-arrow"></div><div class="tipsy-inner"/></div>' ) ; } else { this . $tip . html ( '<div class="tipsy-inner"/></div>' ) ; } } return this . $tip ; }
function ( value ) { if ( this . checkboxCmp ) { this . checkboxCmp . setValue ( value ) ; } else { this . collapsed = ! value if ( ! value ) this . collapse ( ) } }
function outerIframeLoaded ( ) { var injectedScript = "data:,function is(a, b, desc) {                                     \       if (a == b) {                                                      \         sendAsyncMessage('test:test-pass', desc);                        \       } else {                                                           \         sendAsyncMessage('test:test-fail', desc + ' ' + a + ' != ' + b); \       }                                                                  \     }                                                                    \     is(content.window.top, content.window, 'top');                       \     is(content.window.content, content.window, 'content');               \     is(content.window.parent, content.window, 'parent');                 \     is(content.window.frameElement, null, 'frameElement');               \     var innerIframe = content.document.getElementById('inner-iframe');   \     var innerWindow = innerIframe.contentWindow;                         \     is(innerWindow.top, content.window, 'inner top');                    \     is(innerWindow.content, content.window, 'inner content');            \     is(innerWindow.parent, content.window, 'inner parent');              \     is(innerWindow.frameElement, innerIframe, 'inner frameElement');" var mm = SpecialPowers . getBrowserFrameMessageManager ( iframe ) ; function onRecvTestPass ( msg ) { numMsgReceived ++ ; ok ( true , msg . json ) ; } mm . addMessageListener ( 'test:test-pass' , onRecvTestPass ) ; function onRecvTestFail ( msg ) { numMsgReceived ++ ; ok ( false , msg . json ) ; } mm . addMessageListener ( 'test:test-fail' , onRecvTestFail ) ; mm . loadFrameScript ( injectedScript , false ) ; waitForMessages ( 6 ) ; }
function ( node ) { return [ node . label , '<div class="desc">' + ( node . description ? node . description : 'No description given' ) + '</div><div class="amount">£ ' + node . famount + '</div>' ] ; }
function ( incidents ) { var self = this ; this . incidents = ko . observableArray ( $ . jStorage . get ( INCIDENTS_LIST_KEY ) ) ; self . goToIncident = function ( incident ) { setCurrentIncident ( incident ) ; $ . mobile . changePage ( "incidentForm.html" ) ; } ; }
function saveSubject ( alertSave ) { g_curSubject . lname = $ ( "#lname" ) . val ( ) ; g_curSubject . fname = $ ( "#fname" ) . val ( ) ; g_curSubject . gender = $ ( 'input:radio[name=gender]:checked' ) . val ( ) ; saveCurSubject ( ) ; setSubjSelect ( ) ; if ( alertSave ) alert ( "Save Completed." ) ; }
function ( ) { var host = Hosts . findOne ( { email : Meteor . user ( ) . emails [ 0 ] } ) ; alert ( Meteor . user ( ) . emails [ 0 ] ) ; if ( host === undefined ) { Hosts . insert ( { host : Meteor . user ( ) . name , email : Meteor . user ( ) . emails [ 0 ] } ) ; } }
function ( path ) { if ( path . substring ( 0 , 3 ) === "../" ) return true ; if ( path . substring ( 0 , 1 ) === "/" ) return true ; path = path . split ( "/" ) ; var cwd = fs . readdirSync ( process . cwd ( ) ) ; return ( cwd . indexOf ( path [ 0 ] ) === - 1 ) ; }
function ( ) { var features ; if ( $ ( /^@media/ ) ) { features = $ ( this . mediaFeatures ) ; if ( rules = $ ( this . block ) ) { return new ( tree . Media ) ( rules , features ) ; } } }
function ( $jc$ ) { var p = $jc$ . pstack [ $jc$ . pscope ] . join ( ', ' ) , str = 'var f = function (' + p + ') {\n$jc$.sstack.push([]);\n$jc$.scope++;\nvar r = (function () {\n' + $jc$ . compile ( node . children [ 1 ] , true ) + '})();\n$jc$.sstack.pop();\n$jc$.scope--;\nreturn r;\n}; f;' ; return eval ( str ) ; }
function ( sequence ) { if ( sequence . length > 1 && reEndsWithSlash . test ( sequence ) ) { sequence = sequence . slice ( 0 , - 1 ) ; } try { sequence = decodeURI ( sequence ) ; } catch ( err ) { } return sequence ; }
function invokeAction ( action , params , sender ) { var method = action . method , target = action . target ; if ( ! target ) { target = sender ; } if ( 'string' === typeof method ) { method = target [ method ] ; } method . apply ( target , params ) ; }
function ( ) { this . _snap = new CheckBox ( { } , this . snapNode ) ; this . _showPossibleParents = new CheckBox ( { } , this . showPossibleParentsNode ) ; this . _cssOverrideWarn = new CheckBox ( { } , this . cssOverrideWarn ) ; this . _absoluteWidgetsZindex = new TextBox ( { } , this . absoluteWidgetsZindex ) ; if ( ! this . containerNode ) { this . containerNode = this . domNode ; } }
function ( e ) { if ( e . which == 17 ) { aigua . slider . hide ( ) ; aigua . filler . width ( 0 ) ; aigua . bar . width ( aigua . startingBarWidth ) ; aigua . originalNumber = null ; } }
function ( display , window ) { if ( ! window || window . has_focus ( ) || window . is_skip_taskbar ( ) || window . get_wm_class ( ) == "Skype" ) return ; if ( this . _tracker . is_window_interesting ( window ) ) { window . activate ( global . get_current_time ( ) ) ; } }
function ( item ) { var t = ( root = getRoot ( item ) ) . nodeType == 1 ? baidu . query ( selector , root ) : da ; for ( var i = 0 , n = t . length ; i < n ; i ++ ) { if ( t [ i ] === item ) { results . push ( item ) ; break ; } } }
function getRoot ( dom ) { var result = [ ] , i ; while ( dom = dom . parentNode ) { result . push ( dom ) ; } for ( var i = result . length - 1 ; i > - 1 ; i -- ) { if ( result [ i ] . nodeType == 1 || result [ i ] . nodeType == 9 ) { return result [ i ] ; } } return null ; }
function ( filter ) { var array = [ ] ; baidu . each ( this , function ( dom ) { ( dom = dom . parentNode ) && dom . nodeType == 1 && array . push ( dom ) ; } ) ; return baidu . dom ( typeof filter == "string" ? baidu . dom . match ( array , filter ) : array ) ; }
function ( $dom ) { var target = baidu . dom ( '.item-1, .item-c' ) . closest ( 'ul' ) ; equal ( target . length , 2 ) ; equal ( target [ 0 ] . className , 'level-3' ) ; equal ( target [ 1 ] . className , 'level-2' ) ; }
function ( $dom ) { var target = $ ( '.item-1, .item-c' ) . closest ( 'ul' ) ; equal ( target . length , 2 , '(JQuery)' ) ; equal ( target [ 0 ] . className , 'level-3' , '(JQuery)' ) ; equal ( target [ 1 ] . className , 'level-2' , '(JQuery)' ) ; }
function ( ) { require . config ( { paths : { 'jquery' : 'lib/jquery-1.7.1.min' , 'order' : 'lib/order' , 'underscore' : 'lib/underscore-min' , 'transitions' : 'plugin/bootstrap-transition' , 'collapse' : 'plugin/bootstrap-collapse' , 'backbone' : 'lib/backbone-min' , 'underscore' : 'lib/underscore-min' , 'bootstrap' : 'lib/bootstrap.min' , 'bootstrap-collapse' : 'lib/plugin/bootstrap-collapse' , 'text' : 'lib/text' , 'mustache' : 'lib/requirejs.mustache' , 'marionette' : 'lib/backbone.marionette.min' , 'mock-ajax' : 'lib/mock-ajax' , 'fake-ajax' : 'lib/jasmine-fake-ajax-0.3.4' , } } ) ; }
function ( Backbone , namespace ) { var app = namespace . app ; var INTERVAL = 250 ; var options = { delay : INTERVAL } ; var TorrentPoller = function ( ) { this . poller = PollingManager . getPoller ( app . torrents , options ) ; } ; TorrentPoller . prototype . start = function ( ) { this . poller . start ( ) ; } ; TorrentPoller . prototype . INTERVAL = INTERVAL ; return TorrentPoller ; }
function ( ) { var output = Mustache . render ( template ) ; $ ( this . el ) . html ( output ) ; }
function ( ) { $ ( '#remove_book_in' ) . modal ( 'hide' ) ; loadingTasklist ( ) ; var dummy_id = 0 $ . ajax ( { type : "DELETE" , cache : false , url : "books/" + dummy_id , dataType : "jsonp" } ) ; }
function newBook ( book_name ) { var request_str = "book_name=" + book_name ; loadingTasklist ( ) ; $ . ajax ( { type : "POST" , cache : false , url : "books" , data : request_str , dataType : "jsonp" } ) ; }
function selectBook ( book_id ) { var request_str = "book_id=" + book_id ; loadingTasklist ( ) ; $ . ajax ( { type : "GET" , cache : false , url : "books/" + book_id , dataType : "jsonp" } ) ; }
function ( controller ) { var widget = controller . get ( that . widgetId ) ; that . widgets . push ( { widget : widget , controller : controller } ) ; if ( favorite . is ( id ) ) { widget . addClassName ( "is-favorite" ) ; } controller . listen ( widget , Mojo . Event . tap , that . changeFavorite ) ; }
function ( ) { delete currentPage . onReady ; var win = document . defaultView ; var mousemove = document . createEvent ( 'MouseEvent' ) ; mousemove . initMouseEvent ( 'mousemove' , true , true , win , 0 , status . cCoords . x + win . mozInnerScreenX , status . cCoords . y + win . mozInnerScreenY , status . cCoords . x , status . cCoords . y , false , false , false , false , 0 , null ) ; win . dispatchEvent ( mousemove ) ; }
function ft ( e ) { this . style . MozAnimationName = '' ; this . removeEventListener ( 'animationend' , ft ) ; if ( this === tnode ) { that . olist . insertBefore ( onode , ( upward ) ? tnode : tnode . nextSibling ) ; that . ready = true ; if ( that . onReady ) { that . onReady ( ) ; } } }
function ( icon ) { var olist = this . olist ; if ( olist . childNodes . length > 0 ) { olist . insertBefore ( icon . container , olist . firstChild ) ; } else { olist . appendChild ( icon . container ) ; } this . icons [ icon . descriptor . origin ] = icon ; }
function ( app ) { if ( app . type && app . type === 'ApplicationIcon' ) { this . olist . appendChild ( app . container ) ; this . icons [ app . descriptor . origin ] = app ; } else { var icon = new Icon ( app ) ; icon . render ( this . olist , this . container ) ; this . icons [ Applications . getOrigin ( app ) ] = icon ; } }
function ( ) { this . overlay . style [ 'border-color' ] = 'rgb(' + ( R - 32 ) + ', ' + ( G - 32 ) + ', ' + ( B - 32 ) + ')' ; innerChildNode . fingerDown = true ; innerChildNode . contextShown = false ; if ( innerChildNode . contextMenu ) { window . setTimeout ( this . touchTimer , 667 ) ; } }
function ( ) { this . overlay . style [ 'border-color' ] = 'rgb(' + ( R - 32 ) + ', ' + ( G - 32 ) + ', ' + ( B - 32 ) + ')' ; innerChildNode . fingerDown = true ; innerChildNode . contextShown = false ; if ( innerChildNode . contextMenu ) { window . setTimeout ( this . touchTimer , 667 ) ; } }
function ( ) { this . overlay . style [ 'border-color' ] = 'rgb(' + ( R - 32 ) + ', ' + ( G - 32 ) + ', ' + ( B - 32 ) + ')' ; innerChildNode . fingerDown = true ; innerChildNode . contextShown = false ; if ( innerChildNode . contextMenu ) { window . setTimeout ( this . touchTimer , 667 ) ; } }
function templates ( path ) { if ( templates ) return templates templates = { } fs . readdirSync ( path ) . forEach ( function ( name ) { templates [ name ] = fs . readFileSync ( resolve ( path , name ) ) } ) return templates }
function ( message ) { var responseObj = JSON . parse ( message . data ) ; var requestId = responseObj . requestId ; var response = { responseText : responseObj . response } ; var callback = callbackQueue [ requestId ] . callback ; var scope = callbackQueue [ requestId ] . scope ; console . info ( response ) ; callback . apply ( scope , [ response ] ) ; delete callbackQueue [ requestId ] ; }
function ( path , newName , data ) { var _this = this ; if ( newName != null ) { return TodoList . updateTodolist ( data . rslt . obj . data ( "id" ) , { title : newName } , function ( ) { data . inst . deselect_all ( ) ; return data . inst . select_node ( data . rslt . obj ) ; } ) ; } }
function ( event ) { this . last_responsecode = event . responseCode ; this . error_in_last_response = /^[45]/ . test ( this . responsecode ) ; this . _current_response = new cls . NetworkLoggerResponse ( this ) ; this . requests_responses . push ( this . _current_response ) ; this . _current_response . _update_event_response ( event ) ; }
function ( data ) { if ( WTF . raceStatus === "waiting" ) { WTF . remainingPlayers = WTF . numPlayers - parseInt ( data . number ) ; WTF . playerThumbs = [ ] ; for ( var i = 0 ; i < data . photos . length ; i ++ ) { var newImage = new Image ( ) ; newImage . load = function ( ) { WTF . playerThumbs . push ( this ) ; } newImage . src = data . photo ; } } }
function ( ) { console . log ( WTF . canvasY , WTF . canvasMaxY ) ; if ( WTF . canvasY <= WTF . canvasMaxY ) { requestAnimationFrame ( WTF . openingCeremony ) ; WTF . drawOpeningCeremony ( ) ; } else { WTF . gameInit ( ) ; } }
function ( data ) { console . log ( "Current users: " + JSON . stringify ( users ) ) ; var i = 0 ; var heatFlag = false ; var photos = [ ] ; for ( var j in users ) { i ++ ; photos . push ( users [ j ] . photo ) ; } socket . broadcast . to ( data . channelName ) . emit ( "playerCount" , { "number" : i , "photos" : photos } ) ; }
function ( adjust ) { if ( ! this . editor || ! this . editor . _view ) return ; if ( typeof ( SourceEditor ) != "undefined" ) { var doc = this . editor . _view . _frame . contentDocument ; } else { this . editor . textBox . style . fontSizeAdjust = adjust ; } }
function ( elem ) { _elem = JQuery ( elem ) ; JQuery . ajax ( { cache : false , url : 'assets/templates/comments.html?nocache=' + ( new Date ( ) ) . getTime ( ) , dataType : 'html' , success : function ( html ) { template = Handlebars . compile ( html ) ; } } ) }
function ( channel ) { var args = [ ] . slice . call ( arguments , 1 ) , el = args [ 0 ] , file = obj . util . decamelize ( channel ) ; obj . unload ( "widgets/" + file ) ; $ ( el ) . html ( '' ) ; }
function ( ) { $ ( ".main-left-col" ) . height ( $ ( document ) . height ( ) ) . css ( "background" , "#333232" ) ; eva . multiform ( ) ; eva . highlightmenu ( ) ; eva . ui . init ( ) ; return false ; }
function ( repo ) { var repository = '<article>' + '<div>' + '<h2><a href="' + repo . html_url + '">' + repo . name + '</a></h2>' + '<p>' + repo . description + '</p>' + '<a href="' + repo . homepage + '">' + repo . homepage + '</a>' + '</div>' + '</article>' ; $ ( this . element ) . append ( repository ) ; }
function ( ) { image_hidden_fields = $ ( "div#" + currrent_img . attr ( "id" ) ) ; ha = $ ( "#current_high_area" ) . attr ( "value" ) image_hidden_fields . find ( "#" + image_hidden_fields . attr ( "id" ) + "_ha" + ha . substring ( 9 ) + "_code_id" ) . attr ( "value" , $ ( this ) . attr ( "code_id" ) ) $ ( "#" + ha ) . css ( "background-color" , $ ( this ) . attr ( "color" ) ) ; }
function ( e , contents ) { if ( e ) { track . error ( e ) ; } else { try { self . _ignore [ key ] = Nodelint . Depends . JSON5 . parse ( contents ) ; track . mark ( key , true ) ; } catch ( jsonError ) { track . error ( jsonError ) ; } } }
function ( path ) { return ( object . isString && path == object . match ) || ( object . isRegExp && object . match . exec ( path ) ) || ( object . isFunction && object . match ( path , object , self , self . nodelint ) ) ; }
function renderTemplate ( name , subs ) { var handlebars = require ( 'handlebars' ) , asset = 'templates/' + name + '.mustache' , source = require ( 'milo/utils' ) . getAsset ( asset ) , template = handlebars . compile ( source ) ; return template ( subs ) ; }
function ( dt ) { var sprite1 = this . getChildByTag ( TAG_SPRITE1 ) ; var sprite2 = this . getChildByTag ( TAG_SPRITE2 ) ; cc . Log ( "Pre: " + sprite1 . getContentSize ( ) . height ) ; sprite1 . setFlipX ( ! sprite1 . isFlipX ( ) ) ; sprite2 . setFlipY ( ! sprite2 . isFlipY ( ) ) ; cc . Log ( "Post: " + sprite1 . getContentSize ( ) . height ) ; }
function ( dt ) { var batch = this . getChildByTag ( TAG_SPRITE_BATCH_NODE ) ; var sprite1 = batch . getChildByTag ( TAG_SPRITE1 ) ; var sprite2 = batch . getChildByTag ( TAG_SPRITE2 ) ; cc . Log ( "Pre: " + sprite1 . getContentSize ( ) . height ) ; sprite1 . setFlipX ( ! sprite1 . isFlipX ( ) ) ; sprite2 . setFlipY ( ! sprite2 . isFlipY ( ) ) ; cc . Log ( "Post: " + sprite1 . getContentSize ( ) . height ) ; }
function delete_button ( activeCount , code ) { jQuery ( "#remove_table-" + activeCount ) . click ( function ( ) { jQuery ( "#" + jQuery ( this ) . attr ( 'name' ) ) . delay ( '1000' ) . fadeOut ( 'slow' ) . remove ( ) ; jQuery ( this ) . remove ( ) ; refresh_order ( code ) ; } ) ; }
function ( index ) { content = JSON . stringify ( jQuery ( "#content_home" ) . serializeArray ( ) ) ; jQuery ( "#home_content\\[" + jQuery ( this ) . attr ( "code_pays" ) + "\\]" ) . attr ( "value" , content ) ; }
function ( delay ) { var self = this ; this . _show = true ; if ( this . _defaultContent ) this . $trigger . addClass ( this . settings . activeClass ) ; delay ? setTimeout ( function ( ) { self . _open ( ) } , delay ) : this . _open ( ) ; }
function ( ) { setup ( ) ; load ( ) ; $ ( "#container" ) . append ( $ ( "<div/>" , { style : "width:100%;text-align:center;" } ) . append ( $ ( "<a/>" , { html : "MOAR" , "class" : "more button" , } ) ) . click ( function ( ) { button = $ ( this ) ; button . fadeOut ( "fast" , function ( ) { load ( function ( ) { button . fadeIn ( "slow" ) ; } ) ; } ) ; } ) ) ; }
function Application ( config ) { if ( typeof config !== "object" || ! config . path ) { throw new Error ( "config error" ) ; } this . config = config ; this . path = config . path ; this . controllerPath = this . path + '/controller' ; this . viewPath = this . path + '/views' ; this . view = config . view || "ejs" ; this . router = new Router ; }
function ResponseWrapper ( ) { var res = global . $_S . RESPONSE ; res . renderView = function ( template , view ) { var self = this ; view . render ( template , function ( data ) { self . render ( data ) ; } ) ; } ; return res ; }
function ( ) { var uri = global . $_S . REQUEST . url ; if ( typeof this . routerParser === "function" ) { var route = this . routerParser ( uri ) ; } else { var route = router . parseUri ( uri ) ; } if ( typeof route == 'object' && route . controller ) { this . controller = route . controller ; if ( route . action ) { this . action = route . action ; } } }
function ( config ) { this . config = new Echo . Configuration ( config , { "data" : { } , "url" : "" , "onData" : function ( ) { } , "onOpen" : function ( ) { } , "onClose" : function ( ) { } , "onError" : function ( ) { } } ) ; this . instance = this . _getInstance ( ) ; }
function ( responseError ) { var originalWrapped = this . constructor . parent . _wrapErrorResponse ( responseError ) ; if ( responseError && responseError . responseText ) { var errorObject ; try { errorObject = $ . parseJSON ( responseError . responseText ) ; } catch ( e ) { } return errorObject || originWrapped ; } return originalWrapped ; }
function ( config ) { if ( ! config || ! config . endpoint ) return ; this . config = new Echo . Configuration ( config , { "apiBaseURL" : "api.echoenabled.com/v1/" , "transport" : "ajax" } ) ; this . transport = this . _getTransport ( ) ; }
function ( ) { return self . onData . apply ( self , arguments ) ; }
function ( response ) { response = response || { } ; if ( response . result === "error" ) { this . _handleErrorResponse ( response , { "callback" : this . config . get ( "onError" ) } ) ; return ; } this . nextSince = response . nextSince ; if ( this . liveUpdates && this . liveUpdates . responseHandler ) { this . liveUpdates . responseHandler ( response ) ; } }
function ( ) { this . transport . config . set ( "url" , this . config . get ( "submissionProxyURL" ) ) ; this . request ( $ . extend ( this . config . get ( "data" ) , { "content" : Echo . Utils . object2JSON ( this . _AS2KVL ( this . config . get ( "data.content" ) ) ) } ) ) ; }
function ( route ) { if ( ! wn . boot ) { return [ window . page_name ] ; } return $ . map ( wn . get_route_str ( route ) . split ( '/' ) , function ( r ) { return decodeURIComponent ( r ) ; } ) ; }
function ( route ) { if ( ! wn . boot ) { return [ window . page_name ] ; } return $ . map ( wn . get_route_str ( route ) . split ( '/' ) , function ( r ) { return decodeURIComponent ( r ) ; } ) ; }
function ( ) { var graphics , grid , snake ; snake = new Game . Snake ; grid = new Game . Grid ( snake ) ; graphics = new Game . Graphics ( grid ) ; grid . startGame ( ) ; }
function ( ) { var pair , _i , _len , _ref1 ; _ref1 = this . edgeWeights ; for ( _i = 0 , _len = _ref1 . length ; _i < _len ; _i ++ ) { pair = _ref1 [ _i ] ; if ( pair . length !== 2 ) { return false ; } } return true ; }
function ( ) { var _j , _ref2 , _results1 ; _results1 = [ ] ; for ( _j = 0 , _ref2 = this . squaresY ; 0 <= _ref2 ? _j < _ref2 : _j > _ref2 ; 0 <= _ref2 ? _j ++ : _j -- ) { _results1 . push ( { } ) ; } return _results1 ; }
function ( square ) { var type , _i , _len , _ref1 ; _ref1 = this . squareTypes ; for ( _i = 0 , _len = _ref1 . length ; _i < _len ; _i ++ ) { type = _ref1 [ _i ] ; if ( square [ type ] ) { return false ; } } return true ; }
function ( pos , type ) { var _ref1 ; if ( ! this . world [ pos . x ] [ pos . y ] [ type ] ) { return false ; } if ( ( _ref1 = this . world [ pos . x ] [ pos . y ] [ type ] ) != null ) { _ref1 . hide ( ) ; } this . world [ pos . x ] [ pos . y ] [ type ] = null ; return true ; }
function ( pos ) { var type , _i , _len , _ref1 , _results ; _ref1 = this . squareTypes ; _results = [ ] ; for ( _i = 0 , _len = _ref1 . length ; _i < _len ; _i ++ ) { type = _ref1 [ _i ] ; _results . push ( this . unregisterSquareAt ( pos , type ) ) ; } return _results ; }
function ( ) { var _i , _ref2 , _results ; _results = [ ] ; for ( piece = _i = 0 , _ref2 = this . length - 1 ; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2 ; piece = 0 <= _ref2 ? ++ _i : -- _i ) { _results . push ( new Game . Pair ( x , y - piece ) ) ; } return _results ; }
function ( grid ) { var pair , _i , _len , _ref1 ; this . grid = grid ; _ref1 = this . chain ; for ( _i = 0 , _len = _ref1 . length ; _i < _len ; _i ++ ) { pair = _ref1 [ _i ] ; this . grid . registerSquareAt ( pair , 'snake' ) ; } return this . moves . enqueue ( this . _nextPosition ( ) ) ; }
function ( ) { var derivaEpsilon = false ; this . producoes . paraCada ( function ( producao , indiceDaProducao ) { if ( producao . length === 1 && producao [ 0 ] . epsilon ( ) ) { derivaEpsilon = true ; return ; } } ) ; return derivaEpsilon || this . derivaEpsilonEmZeroOuMaisPassos ( ) ; }
function ( ) { var model = new BtappModel ( { 'id' : 'test' } ) ; var add_callback = jasmine . createSpy ( ) ; model . bind ( 'add' , add_callback ) ; model . updateState ( 'testsession' , { 'testkey' : 'testvalue' } , null , 'testurl' ) ; expect ( add_callback ) . toHaveBeenCalledWith ( 'testvalue' ) ; model . unbind ( 'add' , add_callback ) ; expect ( add_callback . callCount ) . toEqual ( 1 ) ; }
function get_chrome ( link , callback ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( 'GET' , link . realhref , true ) ; xhr . overrideMimeType ( 'text/plain; charset=x-user-defined' ) ; xhr . responseType = 'arraybuffer' ; xhr . onload = function ( e ) { if ( this . status == 200 ) { callback ( findOggWithFooter ( this . response , link . tag ) , link ) ; } } ; xhr . send ( ) ; }
function ( item ) { var view = new app . view . ItemView ( { model : item } ) ; if ( $after . length < 1 ) { self . $items . append ( view . $el ) ; } else { view . $el . insertAfter ( $after ) ; } $after = view . $el ; }
function ( ) { if ( NavMain . smallMenuOpen ) { return ; } $ ( '#nav-main-menu' ) . slideToggle ( 150 ) . removeAttr ( 'aria-hidden' ) ; $ ( '#nav-main .toggle' ) . addClass ( 'open' ) ; NavMain . mainMenuLinks . addClass ( 'submenu-item' ) . click ( NavMain . handleSubmenuClick ) ; $ ( '#nav-main-menu [tabindex=0]' ) . get ( 0 ) . focus ( ) ; NavMain . smallMenuOpen = true ; }
function browser_handleEvent ( evt ) { var urlInput = this . urlInput ; switch ( evt . type ) { case 'submit' : this . go ( evt ) ; break ; case 'keyup' : if ( ! this . currentTab || ! this . currentTab . session . backLength ( ) || evt . keyCode != evt . DOM_VK_ESCAPE ) break ; this . goBack ( ) ; evt . preventDefault ( ) ; break ; } }
function ( $injector , $sniffer , $browser ) { if ( jqmCompatMode ) { $sniffer . history = false ; reusejQueryMobileHashChangeForAngular ( $browser ) ; var $location = $injector . invoke ( _$get , $locationProvider ) ; patchLocationServiceToUsePlainUrls ( $location , $browser . url ( ) ) ; return $location ; } else { $ . mobile . pushStateEnabled = false ; $ . mobile . hashListeningEnabled = false ; $ . mobile . changePage . defaults . changeHash = false ; return $injector . invoke ( _$get , $locationProvider ) ; } }
function ( $injector , $sniffer , $browser ) { if ( jqmCompatMode ) { $sniffer . history = false ; reusejQueryMobileHashChangeForAngular ( $browser ) ; var $location = $injector . invoke ( _$get , $locationProvider ) ; patchLocationServiceToUsePlainUrls ( $location , $browser . url ( ) ) ; return $location ; } else { $ . mobile . pushStateEnabled = false ; $ . mobile . hashListeningEnabled = false ; $ . mobile . changePage . defaults . changeHash = false ; return $injector . invoke ( _$get , $locationProvider ) ; } }
function ( res ) { if ( res . responseText ) { var data = MochiKit . Base . evalJSON ( res . responseText ) ; return data . csrf_token ; } else { throw new Error ( chrome . i18n . getMessage ( 'error_notLoggedin' , self . name ) ) ; } }
function ( b , pts ) { if ( G . __zeroBounds ( b ) ) return false ; var inBounds = G . __inBounds ; for ( var pi = 0 , pl = pts . length ; pi < pl ; pi += 2 ) { if ( inBounds ( b , [ pts [ pi ] , pts [ pi + 1 ] ] , false ) ) return true ; } return false ; }
function ( s , m ) { var _t = ( m ? ( m . reset ( ) , m ) : new Transform ( ) ) ; _t . translate ( s . lx , s . ly ) ; _t . translate ( s . x , s . y ) ; _t . rotate ( s . angle ) ; _t . scale ( s . sx , s . sy ) ; _t . translate ( - s . rx , - s . ry ) ; return _t ; }
function ( issuer , next ) { if ( issuer === HOSTNAME ) { next ( "cannot authenticate to browserid with a certificate issued by it." ) ; } else { exports . getPublicKey ( issuer , function ( err , pubKey ) { if ( err ) return next ( err ) ; next ( null , pubKey ) ; } ) ; } }
function QueryString ( obj ) { var args = arguments , args_callee = args . callee , args_length = args . length , i , querystring = this , decode = OAuth . urlDecode ; if ( ! ( this instanceof args_callee ) ) { return new args_callee ( obj ) ; } if ( obj != undefined ) { for ( i in obj ) { if ( obj . hasOwnProperty ( i ) ) { querystring [ i ] = obj [ i ] ; } } } return querystring ; }
function ( ) { doc . location . href = redirectTo ; complete ( oncomplete , verified ) ; }
function ( ) { testEmail ( ) ; ok ( $ ( ".siteinfo" ) . is ( ":visible" ) , "siteinfo is visible when we say what it is" ) ; equal ( $ ( ".website:nth(0)" ) . text ( ) , returnTo , "website is updated" ) ; testHasClass ( "body" , "complete" ) ; equal ( doc . location . href , returnTo , "redirection occurred to correct URL" ) ; equal ( storage . getLoggedIn ( "https://test.domain" ) , "testuser@testuser.com" , "logged in status set" ) ; start ( ) ; }
function updateComplete ( ) { var win = true ; for ( var i = 0 ; i < ( ROWS * COLS ) ; i ++ ) { if ( inmap [ i ] != i ) win = false ; } if ( win ) { console . log ( 'YAYA~~~~~' ) ; alert ( '恭喜恭喜！～' ) ; } }
function ( e ) { tab . screenshot = e . target . result ; if ( ! isCurrentTab ) { this . setTabVisibility ( tab , false ) ; } if ( this . currentScreen === this . TABS_SCREEN ) { this . showTabScreen ( ) ; } }
function browser_handleEvent ( evt ) { var urlInput = this . urlInput ; switch ( evt . type ) { case 'submit' : this . go ( evt ) ; break ; case 'keyup' : if ( evt . keyCode === evt . DOM_VK_ESCAPE ) { evt . preventDefault ( ) ; this . showPageScreen ( ) ; this . urlInput . blur ( ) ; } } }
function browser_navigate ( url ) { this . showPageScreen ( ) ; this . currentTab . title = null ; this . currentTab . url = url ; this . currentTab . dom . setAttribute ( 'src' , url ) ; this . urlInput . value = url ; }
function browser_setUrlButtonMode ( mode ) { this . urlButtonMode = mode ; switch ( mode ) { case this . GO : this . urlButton . src = 'style/images/go.png' ; this . urlButton . style . display = 'block' ; break ; case this . REFRESH : this . urlButton . src = 'style/images/refresh.png' ; this . urlButton . style . display = 'block' ; break ; case this . STOP : this . urlButton . style . display = 'none' ; break ; } }
function browser_showTopSitesTab ( ) { this . deselectAwesomescreenTabs ( ) ; this . topSitesTab . classList . add ( 'selected' ) ; this . topSites . classList . add ( 'selected' ) ; Places . getTopSites ( this . showTopSites . bind ( this ) ) ; }
function browser_selectTab ( id ) { this . currentTab = this . tabs [ id ] ; this . urlInput . value = this . currentTab . title ; this . tabCover . setAttribute ( 'src' , this . currentTab . screenshot ) ; this . updateSecurityIcon ( ) ; this . refreshButtons ( ) ; }
function places_addBookmark ( uri , title , callback ) { if ( ! title ) title = uri ; var bookmark = { uri : uri , title : title , timestamp : new Date ( ) . getTime ( ) } ; this . addPlace ( uri , ( function ( ) { this . db . saveBookmark ( bookmark , callback ) ; } ) . bind ( this ) ) ; }
function ( event ) { var place = event . target . result ; if ( place ) { if ( callback ) callback ( ) ; return ; } else { place = { uri : uri , title : uri , frecency : 0 } ; } var writeRequest = objectStore . add ( place ) ; writeRequest . onsuccess = function onsucess ( event ) { if ( callback ) callback ( ) ; } ; writeRequest . onerror = function onerror ( event ) { console . log ( 'error writing place' ) ; } ; }
function ( window ) { function Settings ( options ) { Calendar . View . apply ( this , arguments ) ; } Settings . prototype = { __proto__ : Object . create ( Calendar . View . prototype ) , selectors : { element : '#settings' } } ; Calendar . ns ( 'Views' ) . Settings = Settings ; }
function ( ) { assert . deepEqual ( subject . _routeViewFn , { } ) ; assert . instanceOf ( subject . timeController , Calendar . Controllers . Time ) ; assert . instanceOf ( subject . db , Calendar . Db ) ; assert . instanceOf ( subject . router , Calendar . Router ) ; }
function ( ) { var first = list [ 'local-first' ] ; assert . instanceOf ( first , Calendar . Provider . Calendar . Local ) ; assert . equal ( first . provider , subject ) ; assert . equal ( first . id , 'local-first' ) ; assert . equal ( first . name , 'your_device' ) ; }
function ( ) { db = testSupport . calendar . db ( ) ; subject = new Calendar . Store . Abstract ( db ) ; }
function ( done ) { db = testSupport . calendar . db ( ) ; subject = db . getStore ( 'Account' ) ; db . open ( function ( err ) { assert . ok ( ! err ) ; done ( ) ; } ) ; }
function ( done ) { var trans = db . transaction ( 'accounts' , 'readwrite' ) ; var accounts = trans . objectStore ( 'accounts' ) ; var res = accounts . clear ( ) ; res . onerror = function ( ) { done ( new Error ( 'could not wipe accounts db' ) ) ; } res . onsuccess = function ( ) { done ( ) ; } }
function ( done ) { eventFired = null ; subject . once ( 'load' , function ( data ) { eventFired = data ; } ) ; subject . _accounts = { } ; subject . load ( function ( err , data ) { if ( err ) { return done ( err ) ; } result = data ; setTimeout ( function ( ) { done ( ) ; } , 0 ) ; } ) ; }
function ( ) { subject . _accounts [ 1 ] = { preset : 'A' } ; assert . isTrue ( subject . presetActive ( 'A' ) ) ; assert . isFalse ( subject . presetActive ( 'B' ) ) ; }
function ( ) { var model = new Calendar . Models . Account ( ) ; var store = app . store ( 'Account' ) ; store . _accounts [ '1' ] = model ; var data = subject . _updateModel ( '1' ) ; assert . equal ( model , data ) ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . id = 'test' ; div . innerHTML = [ '<div id="wrapper"></div>' , '<div id="settings">' , '<div id="settings-calendars"></div>' , '<div id="settings-accounts"></div>' , '</div>' ] . join ( '' ) ; document . body . appendChild ( div ) ; app = testSupport . calendar . app ( ) ; controller = app . timeController ; subject = new Calendar . Views . Settings ( { app : app } ) ; }
function al_updateAlarmEnableState ( enabled , alarm ) { if ( alarm . enabled == enabled ) return ; alarm . enabled = enabled ; var self = this ; AlarmsDB . putAlarm ( alarm , function al_putAlarmList ( ) { self . refresh ( ) ; } ) ; if ( enabled ) { FakeAlarmManager . set ( alarm ) ; } else { FakeAlarmManager . cancel ( alarm ) ; } }
function showBody ( ) { document . documentElement . lang = navigator . mozL10n . language . code ; document . documentElement . dir = navigator . mozL10n . language . direction ; document . body . classList . remove ( 'hidden' ) ; ClockView . init ( ) ; AlarmList . init ( ) ; AlarmEditView . init ( ) ; RepeatPickerView . init ( ) ; SoundPickerView . init ( ) ; SnoozePickerView . init ( ) ; ColorPickerView . init ( ) ; }
function rv_init ( ) { this . updateTime ( ) ; document . addEventListener ( 'mozvisibilitychange' , this ) ; document . getElementById ( 'ring-btn-snooze' ) . addEventListener ( 'click' , this ) ; document . getElementById ( 'ring-btn-close' ) . addEventListener ( 'click' , this ) ; }
function _sendDelete ( feedback ) { if ( feedback ) IMEFeedback . triggerFeedback ( ) ; if ( _requireIME ( ) && _currentLayoutMode === LAYOUT_MODE_DEFAULT ) { _getCurrentEngine ( ) . click ( KeyboardEvent . DOM_VK_BACK_SPACE ) ; return ; } window . navigator . mozKeyboard . sendKey ( KeyboardEvent . DOM_VK_BACK_SPACE , 0 ) ; }
function kc_showIME ( type ) { delete IMERender . ime . dataset . hidden ; IMERender . ime . classList . remove ( 'hide' ) ; _currentInputType = _mapType ( type ) ; _draw ( _baseLayoutName , _currentInputType , _currentLayoutMode , _isUpperCase ) ; if ( _requireIME ( ) ) { if ( _getCurrentEngine ( ) . show ) { _getCurrentEngine ( ) . show ( type ) ; } } _notifyShowKeyboard ( true ) ; }
function calculator_appendValue ( value ) { if ( this . toClear ) { this . stack = [ ] ; this . toClear = false ; } this . stack . push ( value ) ; this . updateDisplay ( ) ; }
function evaluatePostFix_inner ( token ) { if ( ! this . isOperator ( token ) ) { stack . push ( token ) ; } else { var op2 = stack . pop ( ) ; var op1 = stack . pop ( ) ; var result = this . evaluate [ token ] ( op1 , op2 ) ; stack . push ( result ) ; } }
function ( event ) { var req = settings . getLock ( ) . get ( 'wifi.enabled' ) ; req . onsuccess = function wf_stateGet ( ) { if ( req . result [ 'wifi.enabled' ] ) { updateNetworkState ( ) ; if ( event . status == 'connected' ) { gNetworkList . scan ( ) ; } } } }
function ( evt ) { this . container . addEventListener ( evt , this ) ; }
function ns_tap ( notificationNode ) { var notificationID = notificationNode . dataset . notificationID ; var event = document . createEvent ( 'CustomEvent' ) ; event . initCustomEvent ( 'mozContentEvent' , true , true , { type : 'desktop-notification-click' , id : notificationID } ) ; window . dispatchEvent ( event ) ; this . removeNotification ( notificationNode ) ; UtilityTray . hide ( ) ; }
function sb_updateAll ( ) { this . updateClock ( ) ; this . updateBattery ( ) ; this . updateConnection ( ) ; this . updateWifi ( ) ; }
function ( value ) { var wifiManager = window . navigator . mozWifiManager ; if ( ! wifiManager ) { return ; } if ( wifiManager . enabled == value ) { return ; } var req = wifiManager . setEnabled ( value ) ; req . onerror = function wf_EnabledError ( ) { var settings = window . navigator . mozSettings ; if ( settings ) { settings . getLock ( ) . set ( { 'wifi.enabled' : ! value } ) ; } } }
function ( db , router ) { this . db = db ; this . router = router ; this . _views = Object . create ( null ) ; this . _routeViewFn = Object . create ( null ) ; this . timeController = new Calendar . Controllers . Time ( ) ; }
function ( id , callback ) { var self = this ; var trans = this . db . transaction ( 'accounts' , 'readwrite' ) ; var store = trans . objectStore ( 'accounts' ) ; var req = store . delete ( parseInt ( id ) ) ; trans . onerror = function ( event ) { callback ( event ) ; } trans . oncomplete = function ( ) { delete self . _accounts [ id ] ; callback ( null , id ) ; self . emit ( 'remove' , id ) ; } }
function func ( ) { var data = musu . appContext . feed . query ( "type='truth_dare_state'" , "_id desc limit 1" ) [ 0 ] ; start_obj_DbObj = new SocialKit . DbObj ( data ) ; console . log ( "=======================start_obj_Dbobj before posting is: " + start_obj_DbObj ) ; }
f var token , id , body , subclassOf ; expectKeyword ( 'class' ) ; if ( ! matchKeyword ( 'extends' ) && ! match ( '{' ) ) { id = parseVariableIdentifier ( ) ; } if ( matchKeyword ( 'extends' ) ) { expectKeyword ( 'extends' ) ; subclassOf = parseAssignmentExpression ( ) ; } body = parseClassBody ( ) ; return { id : id , type : Syntax . ClassExpression , body : body , subclassOf : subclassOf } ; }
function parseClassDeclaration ( ) { var token , id , body , subclassOf ; expectKeyword ( 'class' ) ; token = lookahead ( ) ; id = parseVariableIdentifier ( ) ; if ( matchKeyword ( 'extends' ) ) { expectKeyword ( 'extends' ) ; subclassOf = parseAssignmentExpression ( ) ; } body = parseClassBody ( ) ; return { id : id , type : Syntax . ClassDeclaration , body : body , subclassOf : subclassOf } ; }
function ( offset , line , column , v ) { return new CS . ObjectInitialiserMember ( v , v ) . r ( v . raw ) . p ( line , column ) ; }
function ( ) { TissueStack . dataSetNavigation = new TissueStack . DataSetNavigation ( ) ; TissueStack . dataSetNavigation . addToOrReplaceSelectedDataSets ( TissueStack . dataSetStore . getDataSetByIndex ( 0 ) . id , 0 ) ; TissueStack . dataSetNavigation . showDataSet ( 1 ) ; TissueStack . InitUserInterface ( ) ; TissueStack . BindDataSetDependentEvents ( ) ; TissueStack . BindGlobalEvents ( ) ; if ( TissueStack . desktop ) { TissueStack . admin = new TissueStack . Admin ( ) ; } }
function deferredHold ( dfdHold ) { var widget ; if ( HOLDING in self ) { widget = self [ HOLDING ] ; delete self [ HOLDING ] ; self [ $ELEMENT ] . removeAttr ( DATA_HOLDING ) ; Deferred ( function deferredStop ( dfdStop ) { widget . stop ( dfdStop ) ; } ) . then ( dfdHold . resolve , dfdHold . reject ) ; } else { dfdHold . resolve ( ) ; } if ( deferred ) { dfd . then ( deferred . resolve , deferred . reject ) ; } }
function navigateFilter ( lat , lon , markerId ) { easey ( ) . map ( filter_map ) . to ( filter_map . locationCoordinate ( { lat : lat , lon : lon } ) . zoomTo ( 8 ) ) . run ( 2000 ) ; $ ( '.cidade-marker' ) . removeClass ( 'active' ) ; if ( markerId ) $ ( '.cidade-marker[data-cidade="' + markerId + '"]' ) . addClass ( 'active' ) ; }
function ( stop ) { Y . log ( 'checking if ' + arc + ' >= ' + stop . from ) ; if ( arc >= stop . from && ! stopFound ) { slice . set ( 'fill' , { 'color' : stop . progress } ) ; outline . set ( 'fill' , { 'color' : stop . background } ) ; outline . set ( 'stroke' , { weight : 1 , color : stop . outline } ) ; stopFound = true ; return ; } }
function ( stop ) { Y . log ( 'checking if ' + arc + ' >= ' + stop . from ) ; if ( arc >= stop . from && ! stopFound ) { slice . set ( 'fill' , { 'color' : stop . progress } ) ; outline . set ( 'fill' , { 'color' : stop . background } ) ; outline . set ( 'stroke' , { weight : 1 , color : stop . outline } ) ; stopFound = true ; return ; } }
function ( ) { if ( profileName == iLepra . username ) { window . plugins . nativeUI . setTitle ( { organize : false , refresh : false , menu : true , title : profileName } ) ; } else { window . plugins . nativeUI . setTitle ( { organize : false , refresh : false , back : true , title : profileName } ) ; } $ ( "#profileContent" ) . hide ( ) ; }
function ( event ) { $ ( document ) . unbind ( event ) ; $ ( document ) . bind ( iLepra . events . init , function ( event ) { $ ( document ) . unbind ( event ) ; $ . mobile . changePage ( "#loginPage" ) ; } ) ; iLepra . init ( ) ; }
function ( data ) { connection . client . say ( data . target , data . message ) ; socket . emit ( 'message' , { to : data . target . toLowerCase ( ) , from : connection . client . nick , text : data . message } ) ; if ( current_user ) { connection . logMessage ( data . target , { user : connection . client . nick , message : data . message } ) ; } }
function ( text ) { var old_text = this . _error_alert . html ( ) ; this . _error_alert . html ( text ) ; if ( old_text == '' ) { this . _error_alert . hide ( ) ; this . _error_alert . fadeIn ( 100 ) ; } this . _element . css ( 'margin-top' , '0' ) ; }
function ( e ) { e . preventDefault ( ) ; var dialog = showDialogYesNo ( 'Really remove prefix?' , 'Are you sure you want to remove the prefix ' + prefix_list [ prefix_id ] . display_prefix + '?' , function ( ) { var data = { 'schema' : schema_id , 'id' : prefix_id } ; $ . getJSON ( '/xhr/remove_prefix' , data , prefixRemoved ) ; hidePrefixMenu ( ) ; dialog . dialog ( 'close' ) ; } ) ; }
function ( module4 ) { console . log ( 'Executing module2.js' ) ; document . getElementById ( 'console' ) . innerHTML += 'Executing module2.js\n' ; console . log ( 'Trying to use module4...' ) ; document . getElementById ( 'console' ) . innerHTML += 'Trying to use module4...\n' ; if ( module4 . speak ( 'Hello, World!' ) === 'ok' ) { console . log ( 'module4 used successfully' ) ; document . getElementById ( 'console' ) . innerHTML += 'module4 used successfully\n' ; } else { console . error ( 'Failed using module4' ) ; document . getElementById ( 'console' ) . innerHTML += 'Failed using module4\n' ; } return { } ; }
function ( module1 ) { console . log ( 'Executing module4.js' ) ; document . getElementById ( 'console' ) . innerHTML += 'Executing module4.js\n' ; return { speak : function ( message ) { console . log ( 'module4.js: ' + message ) ; document . getElementById ( 'console' ) . innerHTML += 'module4.js: ' + message + '\n' ; return 'ok' ; } } ; }
function ( ) { if ( self . editor && self . editor . editor ) { var text = $ . wa_blog . editor . wysiwygToHtml ( textarea . val ( ) ) ; self . editor . setCode ( text ) ; } else { if ( typeof ( console ) == 'object' ) { console . log ( 'wait for codemirror editor init' ) ; } self . show ( textarea ) ; } }
function ( stats_html ) { return Ember . View . extend ( { elementId : 'todo-count' , tagName : 'span' , remainingBinding : 'controller.remaining' , template : Ember . Handlebars . compile ( stats_html ) , oneLeft : function ( ) { return this . get ( 'remaining' ) === 1 ; } . observes ( 'remaining' ) } ) }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 969 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 969 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 969 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( container ) { if ( this . isvisible ( ) && context [ 'container-height' ] != parseInt ( container . style . height ) ) { __view_is_destroyed = true ; this . createView ( container ) ; messages . post ( 'view-created' , { id : this . id , container : container } ) ; } }
function ( id ) { if ( ! ( id in __runtimes ) ) { opera . postError ( ui_strings . S_DRAGONFLY_INFO_MESSAGE + 'runtime id does not exist' ) ; __runtimes [ id ] = null ; var tag = tagManager . set_callback ( this , this . handleListRuntimes ) ; services [ 'ecmascript-debugger' ] . requestListRuntimes ( tag , [ id ] ) ; } }
function ( ) { return stop_at_user_settings ; }
function ( ) { if ( ! _is_initial_settings_set ) { var config_arr = [ ] , prop = '' ; for ( prop in stop_at_settings ) { config_arr [ stop_at_id_map [ prop ] ] = ( ( stop_at_user_settings [ prop ] = settings [ 'js_source' ] . get ( prop ) ) || stop_at_settings [ prop ] ) && 1 || 0 ; } ecma_debugger . requestSetConfiguration ( 0 , config_arr ) ; _is_initial_settings_set = true ; } }
function ( select_id , runtimes , stopped_script_id , selected_script_id , search_term ) { var script_list = [ "div" ] ; for ( var i = 0 , rt ; rt = runtimes [ i ] ; i ++ ) { script_list . push ( this . runtime_script ( rt , stopped_script_id , selected_script_id , search_term ) ) ; } script_list . push ( "class" , "js-dd-script-list" , "handler" , "js-dd-move-highlight" ) ; return script_list ; }
function ( container ) { container . clearAndRender ( templates . network_options_main ( this . _bypass_cache , this . _track_bodies , this . _headers , this . _overrides ) ) ; this . _output = container . querySelector ( "code" ) ; this . _headerele = container . querySelector ( ".header-override-input" ) ; }
function ( container ) { container . clearAndRender ( templates . network_request_crafter_main ( this . _prev_url , this . _is_listening , this . _prev_request , this . _prev_response ) ) ; this . _urlfield = new cls . BufferManager ( container . querySelector ( "input" ) ) ; this . _input = new cls . BufferManager ( container . querySelector ( "textarea" ) ) ; this . _output = container . querySelector ( "code" ) ; }
function ( ) { return [ "div" , [ "div" , [ "span" , "class" , "ui-button" , "handler" , "reload-window" , "tabindex" , "1" ] ] , [ "p" , ui_strings . S_HTTP_INCOMPLETE_LOADING_GRAPH ] , [ "span" , " " , "class" , "close_incomplete_warning" , "handler" , "close-incomplete-warning" , "tabindex" , "1" ] , "class" , "info-box network_incomplete_warning" ] ; }
function ( status , message ) { const DATA = 0 ; if ( status === 0 && message [ DATA ] ) { var error_messages = message [ DATA ] ; for ( var i = 0 , error_message ; error_message = error_messages [ i ] ; i ++ ) { this . _on_console_message ( error_message ) ; } ; } }
function ( evt , target ) { this . clear ( ) ; var cursor_pos = this . _textarea_handler . get_cursor ( ) ; this . _data . clear ( ) ; this . _textarea . focus ( ) ; this . _textarea_handler . put_cursor ( cursor_pos ) ; return false ; }
function ( event ) { if ( this . _textarea && ! /^(?:input|textarea|button)$/i . test ( event . target . nodeName ) && ! event . target . hasTextNodeChild ( ) ) { this . _textarea . focus ( ) ; this . _current_scroll = null ; } else { this . _current_scroll = this . _container . scrollTop ; } }
function ( msg ) { this . _top_rt_id = msg . runtimes_with_dom [ 0 ] ; if ( this . _take_screenshot && this . isvisible ( ) ) { this . _pixel_magnifier . scale = 1 ; window . messages . post ( 'screenshot-scale' , { scale : this . _pixel_magnifier . scale } ) ; this . _get_window_size ( ) ; } }
function ( ) { if ( window . messages ) { window . messages . addListener ( 'active-tab' , this . _on_active_tab . bind ( this ) ) ; window . messages . addListener ( 'reset-state' , this . _on_reset_state . bind ( this ) ) ; } }
function ( id , name , view_list , default_unfolded_list ) { this . _super_createView = this . createView ; this . createView = function ( container ) { this . _super_createView ( container ) ; var quick_find = this . getToolbarControl ( container , 'css-inspector-text-search' ) ; var search_term = window . element_style . get_search_term ( ) ; if ( quick_find && search_term ) { quick_find . value = search_term ; } } this . init ( id , name , view_list , default_unfolded_list ) ; }
function ( ) { this . init ( id , name , container_class ) ; this . _container = null ; this . _update_layout_bound = this . update_layout . bind ( this ) ; this . _update_offsets_bound = this . update_offsets . bind ( this ) window . messages . addListener ( "setting-changed" , this . _on_setting_change . bind ( this ) ) ; }
function ( key , value , sync_switches ) { window . localStorage . setItem ( key , JSON . stringify ( this . map [ key ] = value ) ) ; if ( this . callback_map . hasOwnProperty ( key ) ) { this . callback_map [ key ] . call ( this , value ) ; } messages . post ( "setting-changed" , { id : this . view_id , key : key } ) ; }
function ( id ) { var id_c = '' , i = 0 ; for ( ; ( id_c = this . container_ids [ i ] ) && id_c != id ; i ++ ) ; if ( id_c ) { this . container_ids . splice ( i , 1 ) ; } }
function ( cell ) { this . init ( this , arguments ) ; this . _history = [ ] ; this . tabs = [ ] ; this . activeTab = '' ; this . cell = cell ; }
function ( button_templates , group , view_id ) { var ret = [ "toolbar-buttons" , button_templates ] ; if ( group . type ) { ret . push ( "handler" , "toolbar-" + group . type ) ; if ( group . type === "single-select" ) { ret = ret . concat ( [ "data-single-select-name" , group . name , "data-view-id" , view_id ] ) ; } } return ret ; }
function ( switches ) { var ret = [ "toolbar-buttons" ] , i = 0 , setting = null ; ret . extend ( switches . map ( this . _switch , this ) ) ; ret . push ( "handler" , "toolbar-switch" ) ; return ret ; }
function ( filters ) { var id = '' , i = 0 , ret = [ ] ; for ( ; id = ids [ i ] ; i ++ ) { if ( views [ id ] . type == 'single-view' && ( ! filters || ! filter ( views [ id ] , filters ) ) ) { ret [ ret . length ] = id ; } } return ret ; }
function ( ) { var id = '' , i = 0 , c = null , ret = [ ] ; for ( ; id = this . container_ids [ i ] ; i ++ ) { if ( c = document . getElementById ( id ) ) { ret [ ret . length ] = c ; } } return ret ; }
function ( id , name , container_class ) { this . _highlighter = new VirtualTextSearch ( ) ; this . _highlight_style = this . _highlighter . get_match_style ( 'highlight' ) ; this . init ( id , name , container_class , '' , 'clear-search-hit' ) ; var clear_search_hit = this . _onscroll . bind ( this ) ; eventHandlers . scroll [ 'clear-search-hit' ] = clear_search_hit ; window . messages . addListener ( "panel-search-executed" , clear_search_hit ) ; }
function ( depArr , name ) { if ( _ ( depArr ) . contains ( $this . closest ( 'li' ) . attr ( 'id' ) . replace ( '_' , '-' ) ) ) { $ ( '#' + name ) . find ( 'input:checkbox' ) . removeAttr ( 'checked' ) ; } }
function ( message ) { var data ; data = this . parse_message ( message ) ; if ( data ) { if ( ! /^\d{3}$/ . test ( data . command ) ) { this . item_manager . publish ( this . get_item_name ( data ) , data . command . toLowerCase ( ) , data ) ; } this . emit ( data . command , data ) ; } }
function ( ) { var alts ; alts = this . nickname_alts ; if ( alts . length ) { this . nickname = alts . shift ( ) ; } else { this . nickname = "Guest" + ( Math . random ( ) * 9999 | 0 ) ; } this . nick ( this . nickname ) ; }
function ( err , objectFromDB ) { if ( ! objectFromDB || objectFromDB == '' ) { instance . update ( { id : query . id } , object , callback , options ) ; } else { callback ( "A  record with id -" + object . id + " is already exists in our database. Please enter new values." ) ; } }
function ( defaultSettings , options ) { this . _settings = util . extend ( defaultSettings , options ) ; }
function ( e ) { if ( e . target . className === "close" ) { self . trigger ( 'beforeClose' ) ; self . close ( ) ; self . trigger ( 'close' ) ; } }
function ( ) { that . options . onViewportChanged ( that . translateDimensions ( { top : - that . image . getY ( ) , right : ( - that . image . getX ( ) + that . stage . getWidth ( ) ) , bottom : ( - that . image . getY ( ) + that . stage . getHeight ( ) ) , left : - that . image . getX ( ) } ) ) ; }
function ( ) { this . stage = null ; this . layer = null ; this . image = null ; this . scale_x = null ; this . scale_y = null ; this . original_dim = null ; this . viewport_rect = null ; }
function ( image ) { var prev_width = this . original_dim . width , prev_height = this . original_dim . height ; this . original_dim = { width : image . naturalWidth , height : image . naturalHeight } ; this . image . setImage ( image ) ; if ( prev_width !== this . original_dim . width || prev_height !== this . original_dim . height ) { this . fitImageToStage ( image ) ; } this . layer . draw ( ) ; }
function ( ) { that . options . onViewportChanged ( that . translateDimensions ( { top : - that . image . getY ( ) , right : ( - that . image . getX ( ) + that . stage . getWidth ( ) ) , bottom : ( - that . image . getY ( ) + that . stage . getHeight ( ) ) , left : - that . image . getX ( ) } ) ) ; }
function ( ) { this . stage = null ; this . layer = null ; this . image = null ; this . scale_x = null ; this . scale_y = null ; this . original_dim = null ; this . viewport_rect = null ; }
function ( image ) { var prev_width = this . original_dim . width , prev_height = this . original_dim . height ; this . original_dim = { width : image . naturalWidth , height : image . naturalHeight } ; this . image . setImage ( image ) ; if ( prev_width !== this . original_dim . width || prev_height !== this . original_dim . height ) { this . fitImageToStage ( image ) ; } this . layer . draw ( ) ; }
function ( ) { that . options . onViewportChanged ( that . translateDimensions ( { top : - that . image . getY ( ) , right : ( - that . image . getX ( ) + that . stage . getWidth ( ) ) , bottom : ( - that . image . getY ( ) + that . stage . getHeight ( ) ) , left : - that . image . getX ( ) } ) ) ; }
function ( ) { this . stage = null ; this . layer = null ; this . image = null ; this . scale_x = null ; this . scale_y = null ; this . original_dim = null ; this . viewport_rect = null ; }
function ( image ) { var prev_width = this . original_dim . width , prev_height = this . original_dim . height ; this . original_dim = { width : image . naturalWidth , height : image . naturalHeight } ; this . image . setImage ( image ) ; if ( prev_width !== this . original_dim . width || prev_height !== this . original_dim . height ) { this . fitImageToStage ( image ) ; } this . layer . draw ( ) ; }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function linkMoveClick ( e ) { var $this = $ ( this ) , game = $this . data ( 'game' ) , index = $this . data ( 'index' ) , noAnim = $this . data ( 'noAnim' ) ; $this . addClass ( 'pgn-current-move' ) . siblings ( ) . removeClass ( 'pgn-current-move' ) ; game . showMoveTo ( index , noAnim ) ; }
function ChessPiece ( type , color , game ) { this . game = game ; this . type = type ; this . color = color ; this . img = $ ( '<img>' , { src : imageUrl [ type + color ] , 'class' : 'pgn-chessPiece' , opacity : 0 } ) . appendTo ( game . boardDiv ) ; }
function ( oldFile , oldRow , isCapture , file , row ) { if ( oldFile != undefined && oldFile != this . file ) return false ; if ( oldRow != undefined && oldRow != this . row ) return false ; return this . canMoveTo ( file , row , isCapture ) ; }
function ( ) { currentGame = this ; for ( var td in this . tds ) this . tds [ td ] . find ( 'div' ) . toggle ( false ) ; this . boardDiv . toggle ( true ) ; this . pgnDiv . toggle ( true ) ; this . descriptionsDiv . toggle ( true ) ; this . drawBoard ( ) ; }
function ( color ) { var king = this . piecesByTypeCol [ 'k' ] [ color ] [ 0 ] ; var rook = this . piecesByTypeCol [ 'r' ] [ color ] [ 0 ] ; king . move ( fileOfStr ( 'b' ) , king . row ) ; rook . move ( fileOfStr ( 'c' ) , rook . row ) ; }
function ( piece , type , file , row ) { this . clearPieceAt ( piece . file , piece . row ) ; var newPiece = this . createPiece ( type , piece . color , file , row ) ; this . registerMove ( { what : 'a' , piece : piece , file : file , row : row } ) }
function ( ) { currentGame . advance ( ) ; }
function Walker ( root ) { if ( ! ( this instanceof Walker ) ) return new Walker ( root ) EventEmitter . call ( this ) this . _pending = 0 this . _filterDir = function ( ) { return true } this . go ( root ) }
function resume_tanasinn ( tanasinn_class , data ) { var io_service = Components . classes [ "@mozilla.org/network/io-service;1" ] . getService ( Components . interfaces . nsIIOService ) ; io_service . getProtocolHandler ( "resource" ) . QueryInterface ( Components . interfaces . nsIResProtocolHandler ) . setSubstitution ( "tanasinn" , uri ) tanasinn_class . getService ( Components . interfaces . nsISupports ) . wrappedJSObject . notify ( "event/enabled" ) ; }
function ( target_id , callback ) { console . log ( "API - getCommentsByTargetId" ) ; $ . ajax ( { url : '/api/question/' + target_id + '/comments' , type : 'GET' , success : function ( data ) { callback ( data ) ; } } ) ; }
function ( req , res ) { if ( req . session && req . session . user ) { res . render ( "engage/index" , { title : "SFU ENGAGE" , user : userobject , courses : req . session . courses , status : "logged in" } ) } else { res . redirect ( "/demo" ) ; } }
function ( req , res ) { if ( req . session && req . session . user ) { res . render ( "engage/starred" , { title : "SFU ENGAGE" , user : userobject , courses : req . session . courses , status : "logged in" } ) } else { res . redirect ( "/demo" ) ; } }
function ( req , res ) { if ( req . session && req . session . user ) { res . render ( "engage/instructor" , { title : "SFU ENGAGE" , user : userobject , courses : req . session . courses , status : "logged in" } ) } else { res . redirect ( "/demo" ) ; } }
function ( req , res ) { if ( req . session && req . session . user ) { var pickedArticle = articles [ req . params . id - 1 ] ; res . render ( "engage/article" , { title : "SFU ENGAGE" , article : pickedArticle , user : userobject , courses : req . session . courses , status : "logged in" } ) } else { res . redirect ( "/demo" ) ; } }
function ( ) { var active_editable_obj = this . getBaseElement ( ) ; if ( ! active_editable_obj ) { return ; } $ ( Aloha . activeEditable . obj ) . attr ( 'aloha-numerated-headers' , 'false' ) ; var headingselector = getCurrentConfig ( this ) . headingselector ; var headers = active_editable_obj . find ( headingselector ) ; headers . each ( function ( ) { $ ( this ) . find ( 'span[role=annotation]' ) . each ( function ( ) { $ ( this ) . remove ( ) ; } ) ; } ) ; }
function ( ) { if ( typeof this . baseobjectSelector !== 'undefined' ) { return ( $ ( this . baseobjectSelector ) . length > 0 ) ? $ ( this . baseobjectSelector ) : null ; } return Aloha . activeEditable ? null : Aloha . activeEditable . obj ; }
function ( FLOAT_ARRAY_TYPE ) { var M = require ( "matrix/m" ) ; var M4 = require ( "matrix/m4" ) ; var transform = require ( "matrix/transform-api" ) ; var T = function ( t , r , s ) { var matrix = new M4 ( ) ; return transform . set ( matrix , t , r , s ) ; } ; T . prototype = new M ( ) ; T . prototype . constructor = T ; return T ; }
function ( name ) { name = name || 'en1' ; var interfaces = os . networkInterfaces ( ) , interface ; if ( ! interfaces [ name ] ) { return '127.0.0.1' ; } interface = interfaces [ name ] . filter ( function ( details ) { return details . family === 'IPv4' ; } ) [ 0 ] ; return ! interface ? '127.0.0.1' : interface . address ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( opts ) { var view_model ; if ( ! opts . data ) { return ko . observable ( ) ; } view_model = new options . view_model ( ) ; return ko . mapping . fromJS ( opts . data , options . mapping , view_model ) ; }
function ( ) { var model = new TestModelAttributes ( ) ; expect ( model . newRecord ) . toBeTrue ( ) ; }
function ( closedFile , editor ) { if ( this . annotations [ closedFile ] ) { var annotations = this . annotations [ closedFile ] ; for ( var annotation in annotations ) { this . currentEditor . getSession ( ) . removeMarker ( annotation . markerId ) ; } } }
function nodeNameCmp ( first , second ) { a = first . cluster . name ; b = second . cluster . name ; if ( a . toString ( ) < b . toString ( ) ) return - 1 ; if ( a . toString ( ) > b . toString ( ) ) return 1 ; return 0 ; }
function ( index , option ) { var timeRemaining = BusTracker . calculateTimeRemaining ( Date . parse ( ctaTime ) , Date . parse ( option . predicted_time ) ) ; var prediction = { route : route_number , destination : option . destination , vehicle_id : option . vehicle_id , time_remaining : timeRemaining } ; var template = BusTracker . getTemplate ( timeRemaining ) ; var html = Mustache . to_html ( template , prediction ) ; BusTracker . showDiv ( '.output' ) $ ( '.output' ) . append ( html ) ; }
function ( ) { var self = this ; this . isOpen = false ; this . $el . animate ( { margin : "-10px 0 0 0" , opacity : 0 } , this . options . speedOut , function ( ) { $ ( self . options . target ) . removeClass ( "selected" ) ; self . $el . hide ( ) ; } ) ; }
function ( columnName ) { if ( this . _columnType [ columnName ] === undefined ) { throw new Exception ( "the column does not exists" ) ; } var c = new cdb . admin . Column ( { table : this , name : columnName , type : this . _columnType [ columnName ] } ) ; return c ; }
function ( ) { view = new cdb . admin . HeaderView ( { column : [ 'name' , 'type' ] , template : "<label><a><%= col_name %></a></label><p><a><%= col_type %></a></p>" } ) ; }
function ( ) { tables . add ( { name : 'test' } ) ; spyOn ( tablestats , '_tableChange' ) ; tables . remove ( tables . at ( 0 ) ) ; expect ( tablestats . _tableChange ) . toHaveBeenCalled ( ) ; }
function ( src ) { check ( src , msg ) . notNull ( ) ; }
function ( locale ) { if ( localeMap [ locale ] . indexOf ( imgPath ) !== - 1 ) { xmlObject [ xmlObjectKey ] [ "image" ] . push ( { text : { _attr : { "xml:lang" : locale } , _value : "locales/" + locale + "/" + imgPath } } ) ; } }
function generateLocalizedMetadata ( session , config , xmlObject , key ) { if ( config . icon || config . splash ) { var localeFiles ; if ( path . existsSync ( session . sourceDir + "/locales" ) ) { localeFiles = wrench . readdirSyncRecursive ( session . sourceDir + "/locales" ) ; } generateLocalizedMetadataForSplashScreenIcon ( config , key , xmlObject , key === "splash" ? "splashScreens" : key , localeFiles ) ; } }
function toggle ( id ) { var d = document . getElementById ( id ) && document . getElementById ( id ) . style . display ; if ( d ) { if ( d == "none" || d == "" ) { d = "block" } else { d = "none" ; } } }
function ( ) { var iW = $ ( this ) . width ( ) ; var iH = $ ( this ) . height ( ) ; $ ( this ) . attr ( { width : iW , height : iH } ) . fadeIn ( 400 ) ; $ ( '#showbox-loader' ) . hide ( ) ; $ ( '#showbox .showbox-menubar' ) . show ( ) ; ShowBox . RESIZE ( ) ; }
function ( test ) { var newMediaFile = { user_uid : "A7S7F8GA7SD98A7SDF8ASD7G" , title : "How to make buble tea" , path : "http://www.youtube.com/bt" , type : 1 } MediaFile . createMediaFile ( newMediaFile , function ( error , mediaFile ) { tuid = mediaFile . target_uuid ; console . log ( "t_uid = " + tuid ) ; test . ok ( mediaFile . should . have . property ( 'target_uuid' ) ) ; test . done ( ) ; } ) }
function ( test ) { var target = { 'target_uuid' : 'abc1230' } ; var updateAttributes = { 'title' : 'jericho twist' , 'path' : 'www.google.com' } ; MediaFile . updateMediaFile ( target , updateAttributes , function ( error , updatedMediaFile ) { console . log ( "expect = " + updateAttributes . title ) ; console . log ( "result = " + updatedMediaFile . title ) ; test . ok ( updatedMediaFile . title . should . be . eql ( updateAttributes . title ) ) ; test . done ( ) ; } ) }
function ( test ) { var newTag = { user_uid : "BSDF787D98A7SDF8ASD7G1" , start : 12 , end : 34 , type : 2 , target_uuid : "abc1234" , title : "super magic dribble" , description : "bend it like beckham" , question_uid : "aJfznhseQuOicWWAjx7F00" , important : true , interest : false , examable : true , reviewlater : true , shared : false } Tag . createTag ( newTag , function ( error , tag ) { test . ok ( tag . should . have . property ( 'description' ) ) ; test . done ( ) ; } ) }
function ( test ) { var target = { "user_uid" : "A7S7F8GA7SD98A7SDF8ASD7G" } ; var updateAttributes = { 'title' : 'jericho twist' , 'shared' : true } ; Tag . updateTag ( target , updateAttributes , function ( error , updatedTag ) { console . log ( "expect = " + updateAttributes . shared ) ; console . log ( "result = " + updatedTag . shared ) ; test . ok ( updatedTag . shared . should . be . eql ( updateAttributes . shared ) ) ; test . done ( ) ; } ) }
function ( callback ) { var self = this ; var hashchange = function ( ) { var path = location . hash . substr ( 1 ) ; if ( get ( self , 'lastSetURL' ) === path ) { return ; } set ( self , 'lastSetURL' , null ) ; callback ( location . hash . substr ( 1 ) ) ; } ; get ( this , 'callbacks' ) . pushObject ( hashchange ) ; if ( window . addEventListener ) { window . addEventListener ( 'hashchange' , hashchange , false ) ; } }
function ( ) { set ( this , 'location' , get ( this , 'location' ) || window . location ) ; set ( this , '_initialURL' , get ( this , 'location' ) . pathname ) ; set ( this , 'callbacks' , Ember . A ( ) ) ; }
function ( callback ) { var self = this ; var popstate = function ( e ) { callback ( location . pathname ) ; } ; get ( this , 'callbacks' ) . pushObject ( popstate ) ; if ( window . addEventListener ) { window . addEventListener ( 'popstate' , popstate , false ) ; } }
function ( fieldId ) { var field = this . $ ( fieldId ) ; if ( field . val ( ) . length == 0 ) { field . parent ( ) . parent ( ) . addClass ( 'error' ) ; return false ; } field . parent ( ) . parent ( ) . removeClass ( 'error' ) . addClass ( 'success' ) ; return true ; }
function ( ) { if ( ! ! this . currentUserId ) { this . navigate ( 'user/' + this . currentUserId , { trigger : true , replace : true } ) ; } else { this . navigate ( 'login' , { trigger : true , replace : true } ) ; } }
function ( user ) { user . is_current = self . currentUserId == id ; var model = new UserModel ( user ) ; var view = new UserView ( { model : model } ) ; self . setView ( view , model . get ( 'user_name' ) ) ; }
function ( userId ) { this . currentUserId = userId ; router = this ; Backbone . history . start ( ) ; var hash = window . location . hash ; if ( hash === '' || hash === '#' ) { if ( ! userId ) { this . navigate ( 'login' , { trigger : true , replace : true } ) ; } else { this . navigate ( 'user/' + userId , { trigger : true , replace : true } ) ; } } }
function ( functionsAndClassesAndNestedPackages ) { return Object . create ( null , functionsAndClassesAndNestedPackages === null ? undefined : functionsAndClassesAndNestedPackages ) ; }
function ( dataRepresentation , x , y ) { if ( Smartgraphs . statechart && Smartgraphs . statechart . get ( 'statechartIsInitialized' ) ) { Smartgraphs . statechart . sendAction ( 'dataPointDragged' , this , { dataRepresentation : dataRepresentation , x : x , y : y } ) ; } this . sendAction ( 'dataPointDragged' , this , { dataRepresentation : dataRepresentation , x : x , y : y } ) ; }
function ( datadefName , pointNumber ) { var pointSelected = Smartgraphs . graphingTool . get ( 'pointSelectedinArray' ) ; var toolDatadefName = Smartgraphs . graphingTool . get ( 'datadefName' ) ; if ( pointSelected == ( pointNumber - 1 ) && toolDatadefName == datadefName ) { return true ; } return false ; }
function ( x , y , state ) { var graphView = this . graphViewForPane ( this . paneForState ( state ) ) ; var coords = graphView . graphCanvasView . axesView . inputAreaView . coordsForEvent ( { pageX : x , pageY : y } ) ; var logicalPoint = graphView . pointForCoordinates ( coords . x , coords . y ) ; return graphView . graphCanvasView . _checkInputAreaScreenBounds ( x , y ) ; }
function ( evt ) { var pointView = this . getPointViewUnderMouse ( this . parentView . dataHolder , evt ) || null ; if ( ! pointView ) { this . _pointView = null ; return ; } this . _pointView = pointView ; pointView . mouseDown ( ) ; }
function ls_loadPanel ( panel ) { switch ( panel ) { case 'passcode' : break ; case 'camera' : this . camera . src = './camera/' ; break ; case 'emergency' : break ; } }
function ls_switchPanel ( panel ) { var overlay = this . overlay ; this . unloadPanel ( overlay . dataset . panel ) ; if ( panel ) { overlay . dataset . panel = panel ; this . loadPanel ( panel ) ; } else { overlay . dataset . panel = '' ; } }
function ( db , router ) { this . db = db ; this . router = router ; this . _views = { } ; this . _routeViewFn = { } ; this . timeController = new Calendar . Controllers . Time ( ) ; }
function showTooltip ( x , y , contents ) { $ ( '<div id="tooltip">' + contents + '</div>' ) . css ( { position : 'absolute' , display : 'none' , top : y + 5 , left : x + 5 , border : '1px solid #fdd' , padding : '2px' , 'background-color' : '#fee' , opacity : 0.80 } ) . appendTo ( "body" ) . fadeIn ( 200 ) ; }
function ( ) { graph . find ( '.metricrow' ) . each ( function ( ) { var metric = $ ( this ) ; update_metric_row ( metric ) ; } ) ; get_events ( graph . find ( "#eventdesc" ) , "#eventcount" ) render ( ) ; }
function ( ) { var when = new Array ( ) ; var from = graph . find ( "#from" ) . text ( ) ; if ( from ) { when . push ( 'from=' + from ) ; } var until = graph . find ( "#until" ) . text ( ) ; if ( until ) { when . push ( 'until=' + until ) ; } return when }
function ( req_data ) { metric . find ( ".metricname" ) . removeClass ( "ajaxerror" ) ; metric . find ( ".metricname" ) . removeClass ( "ajaxworking" ) ; graph_lines [ metric_name ] = [ ] ; target = graph_lines [ metric_name ] ; for ( i in req_data ) { target . push ( parse_incoming ( req_data [ i ] ) ) ; } render ( ) ; }
function ( ) { if ( $ ( this ) . text ( ) == "one" ) { $ ( this ) . text ( "two" ) ; } else { $ ( this ) . text ( "one" ) ; } metric_yaxis [ metric_name ] = metric . find ( ".yaxis" ) . text ( ) ; render ( ) ; }
function ( e ) { if ( e . which === 13 ) { edit . blur ( ) ; if ( graph_lines [ edit . val ( ) ] == null ) { var new_row = $ ( '<tr class="metricrow"><td><a href=#><span class="metricName">' + edit . val ( ) + '</span></a></td><td><a href=#><span class="yaxis">one</span></a></td><td class="killrow"><img src="../content/img/delete.gif"></td></tr>' ) ; setup_row ( new_row ) ; graph . find ( '#newmetricrow' ) . before ( new_row ) ; update_metric_row ( new_row ) ; } edit . val ( '' ) ; } }
function ( ) { var edit = $ ( this ) ; edit . keydown ( function ( e ) { if ( e . which === 13 ) { edit . blur ( ) ; get_events ( edit , "#eventcount" ) ; } } ) ; }
function init ( ) { $ ( document ) . bind ( "mouseup" , onDocMouseUp ) ; $ ( "#mask" ) . css ( "visibility" , "visible" ) setupUI ( ) ; setupKnobs ( ) ; setupColorPicker ( ) ; addSlide ( ) ; togglePaginator ( false ) ; setupClipboard ( ) ; }
function ( ) { $ ( '#id_producto_no_maderable' ) . change ( function ( ) { if ( ( $ ( "#id_producto_no_maderable" ) . val ( ) ) == 1 ) { $ ( '.field-tipo_producto' ) . show ( "100" ) ; } else { $ ( '.field-tipo_producto' ) . hide ( "100" ) ; } } ) ; }
function ( req , args , env , callback , errback ) { req . _arg = args || [ ] ; req . _env = env || { } ; return $ . ajax ( { type : 'POST' , async : true , url : location . href , success : callback || function ( ) { } , fail : errback || function ( ) { } , data : req } ) ; }
function ( path ) { if ( ! _path . existsSync ( path ) ) { _clog . warn ( "*******************************************************" ) ; _clog . warn ( "* Migrations directory not found." ) ; _clog . warn ( "* Creating migrations directory. at '" + path + "'." ) ; _clog . warn ( "*******************************************************" ) ; _fs . mkdirSync ( path ) ; } else { _clog . debug ( "Migrations directory exists at '" + path + "'." ) ; } }
function ( path ) { if ( ! _path . existsSync ( path ) ) { _clog . error ( "*******************************************************" ) ; _clog . error ( "* Migrations directory not found." ) ; _clog . error ( "* " + path ) ; _clog . error ( "*******************************************************" ) ; return false ; } _clog . debug ( "Migrations directory exists at '" + path + "'." ) ; return true ; }
function ( path ) { if ( ! _path . existsSync ( path ) ) { _clog . error ( "*******************************************************" ) ; _clog . error ( "* Migrations directory not found." ) ; _clog . error ( "* " + path ) ; _clog . error ( "*******************************************************" ) ; return false ; } _clog . debug ( "Migrations directory exists at '" + path + "'." ) ; return true ; }
function ( path ) { if ( ! _path . existsSync ( path ) ) { _clog . error ( "*******************************************************" ) ; _clog . error ( "* Migrations directory not found." ) ; _clog . error ( "* " + path ) ; _clog . error ( "*******************************************************" ) ; return false ; } _clog . debug ( "Migrations directory exists at '" + path + "'." ) ; return true ; }
function ( path , migration ) { if ( ! _path . existsSync ( path + "/" + migration ) ) { _clog . error ( "*******************************************************" ) ; _clog . error ( "* Migration '" + migration + "' does not exist" ) ; _clog . error ( "* - in " + path ) ; _clog . error ( "*******************************************************" ) ; return false ; } _clog . debug ( "Migration found" ) ; return true ; }
function ( path ) { var trackerLocation = path + '/' + _filename ; if ( ! _path . existsSync ( trackerLocation ) ) { _clog . debug ( "* Migration Tracker file not found" ) ; _clog . debug ( "* in '" + trackerLocation + "'." ) ; return "0" ; } return _fs . readFileSync ( trackerLocation , "utf8" ) ; }
function ( item ) { var term = $ ( "#token-input-id_to" ) . val ( ) ; if ( item . display_name ) { return ( "<li><div class='name_search'>" + wrapTerm ( item . display_name , term ) + " [" + item . username + "]</div></div></li>" ) ; } return ( "<li><div class='name_search'>" + item . username + "</div></li>" ) ; }
function ( ) { this . factory . releaseState ( this . state_ ) ; if ( gf . CLIENT ) { this . factory . releaseState ( this . clientState_ ) ; } for ( var n = 0 ; n < this . previousStates_ . length ; n ++ ) { this . factory . releaseState ( this . previousStates_ [ n ] ) ; } goog . base ( this , 'disposeInternal' ) ; }
function ( time ) { var flags = this . getFlags ( ) ; if ( flags & gf . sim . EntityFlag . INTERPOLATED ) { this . interpolate_ ( time ) ; } if ( flags & gf . sim . EntityFlag . PREDICTED ) { this . state_ . copyPredictedVariables ( this . clientState_ ) ; } }
function ( event ) { var $el = $ ( this ) ; if ( $el . prop ( 'tappableEvent' ) ) { event = $el . prop ( 'tappableEvent' ) ; $el . removeProp ( 'tappableEvent' ) . removeClass ( 'touched' ) ; fireCallback ( opts . callback , $el , event , true ) ; } }
function ( ) { app . use ( app . router ) ; app . use ( express . static ( pub ) ) ; app . use ( express . errorHandler ( ) ) ; app . set ( 'views' , __dirname + '/views' ) ; app . set ( 'view engine' , 'jade' ) ; }
function ( ) { if ( this . initialize ) this . initialize . apply ( this , arguments ) this . validate = this . compile ? linker . link ( this . compile ( ) ) : this . validate . bind ( this ) }
function ( err , req , res ) { console . log ( err ) ; if ( err . code == 'ECONNREFUSED' ) { console . log ( 'Unable to proxy to target server. This probably means the target server ' + 'is not listening on the given port or host' ) ; } res . writeHead ( 500 , { 'Content-type' : 'text/html' } ) ; res . end ( '<h3> Internal Server Error </h3> Well this is embarrassing. Please try again.' ) ; }
function ( act ) { if ( action == undefined ) { action = act ; } else { console . log ( '' ) ; console . log ( 'Multiple action commands have been sent to redis_mon' ) ; console . log ( 'Please either use -c set, -c get, -s (for set) or -g (for get)' ) ; console . log ( '' ) ; process . exit ( 1 ) ; } }
function PragmaHeader ( ) { this . pragmas = [ '' ] ; }
function ( ) { pragmaHeader . resetCommand ( ) ; }
function ( ) { var pragmaHeader = new PragmaHeader ( ) ; $ ( '#add' ) . click ( function ( ) { pragmaHeader . addCommand ( ) ; } ) ; $ ( '#save' ) . click ( function ( ) { pragmaHeader . saveCommand ( ) ; return false ; } ) ; $ ( '#reset' ) . click ( function ( ) { pragmaHeader . resetCommand ( ) ; } ) ; }
function createBlock ( trial_list ) { var block = { trial_idx : - 1 , trials : trial_list , data : [ ] , next : function ( ) { this . trial_idx = this . trial_idx + 1 ; var curr_trial = trial_list [ this . trial_idx ] ; if ( typeof curr_trial == "undefined" ) { return this . done ( ) ; } do_trial ( this , curr_trial ) ; } , done : nextBlock , num_trials : trials_list . length } return block ; }
function ( newSequence , _timeValue ) { if ( typeof this . seq === "undefined" || this . seq === null ) { this . seq = Seq ( newSequence , _timeValue ) . slave ( this ) ; } else { this . seq . sequences . note = newSequence . split ( "" ) ; } }
function ( event ) { if ( event . state && event . state . _davis ) { handler ( new Davis . Request ( event . state . _davis ) ) } else { if ( hasPopped ( ) ) handler ( Davis . Request . forPageLoad ( ) ) popped = true } ; }
function ( ) { app . use ( express . errorHandler ( { dumpExceptions : true , showStack : true } ) ) ; app . set ( 'port' , 3000 ) ; }
function ( location ) { if ( location . status === "OK" ) { var geometry = location . results [ 0 ] . geometry . location ; model . target = { "latitude" : geometry . $a , "longitude" : geometry . ab } ; } else { } }
function handleStartedPlaying ( event ) { lastPlayer = event . source ; changeIcon ( icons . pause ) ; unIdle ( ) ; if ( event . data . info ) { changeTitle ( htmlDecode ( event . data . info [ 5 ] + ' - ' + event . data . info [ 6 ] ) + ' (' + event . data . info [ 4 ] + ')' ) ; } startMonitorPlayer ( ) ; }
function htmlDecode ( input ) { var e = window . document . createElement ( 'div' ) ; e . innerHTML = input ; return e . childNodes . length === 0 ? "" : e . childNodes [ 0 ] . nodeValue ; }
function ( e , email , uid ) { if ( e ) { logger . warn ( "couldn't complete email verification: " + e ) ; wsapi . databaseDown ( res , e ) ; } else { wsapi . authenticateSession ( req . session , uid , 'password' ) ; res . json ( { success : true } ) ; } }
function ( req , res ) { wsapi . authenticateSession ( req . session , req . session . userid , req . session . auth_level , config . get ( 'authentication_duration_ms' ) ) ; res . send ( 200 ) ; }
function ( db , collection , id , params , callback ) { id = ObjectIdfromString ( id ) ; db . collection ( collection , function ( error , collection ) { collection . find ( { _id : id } ) . toArray ( callback ) ; } ) ; }
function ( db , collectionName , params , callback ) { if ( '_id' in params ) { params [ '_id' ] = ObjectIdfromString ( params [ '_id' ] ) ; } ; db . collection ( collectionName , function ( error , collection ) { if ( error ) { callback ( error ) ; } else { collection . findAndUpdate ( params , callback ) ; } ; } ) ; }
function ( db , collectionName , params , callback ) { if ( '_id' in params ) { params [ '_id' ] = ObjectIdfromString ( params [ '_id' ] ) ; } ; db . collection ( collectionName , function ( error , collection ) { if ( error ) { callback ( error ) ; } else { collection . remove ( params , callback ) ; } ; } ) ; }
function ( resource , statement , context , source ) { return _iterate ( resource , statement , context , source , true ) ; }
function ( index , item ) { if ( index == 0 ) localStorage [ 'last_id' ] = item . id_str ; var tweet = $ ( '<div class="tweet"></div>' ) ; tweet . text ( item . text ) ; homeTimeline . append ( tweet ) ; }
function ( index , item ) { if ( index + 1 == data . length ) localStorage [ 'last_id' ] = item . id_str ; var tweet = $ ( '<div class="tweet"></div>' ) ; tweet . text ( item . text ) ; homeTimeline . prepend ( tweet ) ; }
function lm_init ( ) { window . addEventListener ( 'click' , this , true ) ; window . addEventListener ( 'screenchange' , this , true ) ; window . addEventListener ( 'keyup' , this , true ) ; this . element . addEventListener ( 'transitionend' , this , true ) ; }
function ( ) { io . Transport . XHR . prototype . onClose . call ( this ) ; if ( this . xhr ) { this . xhr . onreadystatechange = this . xhr . onload = empty ; try { this . xhr . abort ( ) ; } catch ( e ) { } this . xhr = null ; } }
function ( e ) { if ( e . keyCode === e . DOM_VK_ESCAPE && ! e . defaultPrevented && displayedApp !== null ) { setDisplayedApp ( null ) ; } if ( e . keyCode === e . DOM_VK_ESCAPE && ModalDialog . blocked ) { ModalDialog . cancelHandler ( ) ; } }
function ( ) { expect ( 1 ) ; var markup = jQuery ( '<div><p><a href="#">target</a></p></div>' ) ; markup . on ( "click" , function ( ) { ok ( false , "directly-bound event on delegate target was called" ) ; } ) . on ( "click" , "a" , function ( e ) { e . stopPropagation ( ) ; ok ( true , "delegated handler was called" ) ; } ) . find ( "a" ) . click ( ) . end ( ) . remove ( ) ; }
function ( e , ui ) { var hash = fm . cwd ( ) . hash ; $ . each ( ui . helper . data ( 'files' ) , function ( i , h ) { if ( fm . file ( h ) . phash == hash ) { cwd . removeClass ( clDropActive ) ; return false ; } } ) }
function ( roomJid , msg , type ) { msg = $ . trim ( msg ) ; if ( msg === '' ) { return false ; } Candy . Core . getConnection ( ) . muc . message ( Candy . Util . escapeJid ( roomJid ) , undefined , msg , type ) ; return true ; }
function ( ) { $ ( this ) . button ( ) ; $ ( this ) . attr ( "checked" , 'unchecked' ) ; $ ( this ) . button ( 'refresh' ) ; }
function ( ) { if ( show ) $ ( this ) . attr ( "checked" , 'checked' ) ; else $ ( this ) . removeAttr ( "checked" ) ; $ ( this ) . button ( 'refresh' ) ; var graphId = GRAPH_BASE_ID + $ ( this ) . attr ( 'id' ) . slice ( SHOW_EVENTS_BASE_ID_LEN ) ; showTimeShift ( graphId , show ) ; }
function SyncWithCacheThread ( aFunc ) { do_check_eq ( sync_with_cache_IO_thread_cb . listener , null ) ; sync_with_cache_IO_thread_cb . listener = aFunc ; var cache = get_cache_service ( ) ; var session = cache . createSession ( "HTTP" , Ci . nsICache . STORE_ANYWHERE , Ci . nsICache . STREAM_BASED ) ; var cacheEntry = session . asyncOpenCacheEntry ( "nonexistententry" , Ci . nsICache . ACCESS_READ , sync_with_cache_IO_thread_cb ) ; }
function ( ) { var cache = get_cache_service ( ) ; var session = cache . createSession ( "HTTP" , this . _asFile ? Ci . nsICache . STORE_ON_DISK_AS_FILE : Ci . nsICache . STORE_ON_DISK , Ci . nsICache . STREAM_BASED ) ; var cacheEntry = session . asyncOpenCacheEntry ( this . _key , this . _append ? Ci . nsICache . ACCESS_READ_WRITE : Ci . nsICache . ACCESS_WRITE , this ) ; }
function ( ) { html = "<div id='zeega-player'>" ; if ( this . zeega ) html += "<div id='preview-close' class='player-overlay'><a href='#'><span class='zicon orange zicon-close' ></span></a></div>" ; html += "<div id='preview-left' class='hidden preview-nav-arrow preview-nav'>" + "<div class='arrow-background'></div>" + "<img class='player-arrow arrow-left' src='" + sessionStorage . getItem ( 'hostname' ) + sessionStorage . getItem ( 'directory' ) + 'images/mediaPlayerArrow_shadow.png' + "'>" + "</div>" + "<div id='preview-right' class='hidden preview-nav-arrow preview-nav'>" + "<div class='arrow-background'></div>" + "<img class='player-arrow arrow-right' src='" + sessionStorage . getItem ( 'hostname' ) + sessionStorage . getItem ( 'directory' ) + 'images/mediaPlayerArrow_shadow.png' + "'>" + "</div>" + "<div id='preview-media'></div>" + "<div id='citation' class='player-overlay'><ul class='citation-list unstyled'></ul></div>" ; return html ; }
function ( ) { $j ( "#photo_div img" ) . enableTap ( ) . click ( saveUserPic ) ; if ( typeof sforce . Client != "undefined" ) sforce . Client . prototype . addAttachment = function ( a , b , c , d , e , f ) { var h = getBaseUrl ( ) + "/services/apexrest/cvapi?action=insertSObject&sobject=Attachment" ; this . ajax ( "POST" , h , { Name : a , ParentId : b , Body : c } , d , e , f ) } }
function ( word , i ) { }
function ( doc ) { if ( document . location . pathname !== "/tests/qunit/" && document . location . pathname !== "/tests/qunit/index.html" ) { sakai . api . User . loadMeData ( function ( success , data ) { sakai . api . i18n . init ( data ) ; } ) ; } }
function ( doc ) { if ( document . location . pathname !== "/tests/qunit/" && document . location . pathname . indexOf ( "/tests/qunit/index.html" ) === - 1 ) { sakai . api . User . loadMeData ( function ( success , data ) { sakai . api . i18n . init ( data ) ; } ) ; } }
function ( doc ) { if ( document . location . pathname !== "/tests/qunit/" && document . location . pathname . indexOf ( "/tests/qunit/index.html" ) === - 1 ) { sakai . api . User . loadMeData ( function ( success , data ) { sakai . api . i18n . init ( data ) ; } ) ; } }
function ( $ , sakai ) { require ( [ "misc/domReady!" ] , function ( doc ) { module ( "Load me data" ) ; sakai_global . qunit . loginWithAdmin ( ) ; asyncTest ( "Test if the correct data is retrieved and stored in the sakai.data.me object" , function ( ) { sakai . api . User . loadMeData ( function ( success , data ) { ok ( data . profile , "check if there's profile information" ) ; ok ( data . user , "check if there's user information" ) ; same ( data . user . userid , "admin" , "Check the username" ) ; start ( ) ; } ) ; } ) ; } ) ; }
function ( ) { $ ( '#sidebar' ) . resizable ( 'option' , 'maxWidth' , $ ( '#content' ) . width ( ) ) ; $ ( '#builder' ) . css ( { "overflow-y" : "auto" } ) ; $ ( '#builder' ) . height ( $ ( window ) . height ( ) - $ ( '#header' ) . height ( ) - $ ( '#footer' ) . height ( ) ) ; $ ( '#sidebar' ) . height ( $ ( '#builder' ) . height ( ) ) ; }
function ( data ) { var resultJson = data ; if ( resultJson == "Success" ) { that . initializeText ( enteredText ) ; handleRefresh ( id ) ; } else { $ ( '#statusMessage' ) . modal ( 'show' ) ; $ ( "#statusMessageHeader" ) . html ( '<h3 style="color:red">Error!</h3>' ) ; $ ( "#statusMessageText" ) . html ( '<h5>Could not save presentation.</h5>' ) ; that . initializeText ( oldText ) ; } }
function _create ( aField ) { if ( Array . isArray ( aField ) ) { for ( let i = 0 ; i < aField . length ; i ++ ) { if ( typeof aField [ i ] !== "string" ) aField [ i ] = String ( aField [ i ] ) ; } return aField ; } else if ( aField != null ) { return [ String ( aField ) ] ; } }
function ( inSender , inEvent ) { enyo . log ( 'onItemTap' ) ; if ( inSender . item ) { enyo . log ( JSON . stringify ( inSender . item . images ) ) ; document . location . href = inSender . item . images [ 'standard_resolution' ] [ 'url' ] ; } }
function ( e ) { enyo . log ( 'on connect click' ) ; var clientID = '9b384ddcfacc427c99396cc068f2798b' ; var redirectUri = 'http://instagrio.tsung.bz/token' ; var url = 'https://api.instagram.com/oauth/authorize/?client_id=' + clientID + '&redirect_uri=' + redirectUri + '&response_type=code&scope=likes+comments+relationships' ; enyo . log ( 'opening url: ' + url ) ; document . location . href = url ; new io . OAuthPasscode ( ) . renderInto ( document . body ) ; }
function ( ) { var that = this ; enyo . log ( 'on main create' ) ; this . inherited ( arguments ) ; this . items = [ ] ; this . origItems = [ ] ; this . fetch ( 'HOT' ) ; this . index = 0 ; }
function ( error , result ) { if ( error ) callBack . error ( error ) ; successItems += result . length ; if ( c . removeAll && c . removeAll . length ) { removeFn ( client , c , collection ) ; } else { callBack . success ( successItems ) ; client . close ( ) ; } }
function ( dt ) { if ( this . _firstTick ) { this . _firstTick = false ; this . _elapsed = 0 ; } else { this . _elapsed += dt ; } this . update ( ( 1 > ( this . _elapsed / this . _duration ) ) ? this . _elapsed / this . _duration : 1 ) ; }
function ( action , times ) { var d = action . getDuration ( ) * times ; if ( this . initWithDuration ( d ) ) { this . _times = times ; this . _innerAction = action ; this . _total = 0 ; return true ; } return false ; }
function ( dt ) { this . _innerAction . step ( dt ) ; if ( this . _innerAction . isDone ( ) ) { var diff = dt + this . _innerAction . getDuration ( ) - this . _innerAction . getElapsed ( ) ; this . _innerAction . startWithTarget ( this . _target ) ; this . _innerAction . step ( diff ) ; } }
function ( texture , rect , rotated , offset , originalSize ) { var spriteFrame = new cc . SpriteFrame ( ) ; spriteFrame . _texture = texture ; spriteFrame . _rectInPixels = rect ; spriteFrame . _rect = cc . RECT_PIXELS_TO_POINTS ( rect ) ; spriteFrame . _rotated = rotated ; spriteFrame . _offsetInPixels = offset ; spriteFrame . _originalSizeInPixels = originalSize ; return spriteFrame ; }
function ( ) { Templates = { torrent_row : Handlebars . compile ( $ ( '#tmpl_torrent' ) . html ( ) ) } btapp . connect ( { } , { poll_frequency : 1000 , queries : Helpers . poll_queries } ) this . torrents = new Torrents ( ) ; this . torrents_contents = new TorrentsList ( { model : torrents } ) ; $ ( '#torrents .content' ) . replaceWith ( this . torrents_contents . render ( ) . el ) ; }
function ( status ) { var statuses = [ ] ; _ . map ( this . bits , function ( value , index ) { if ( Math . pow ( 2 , index ) & status ) statuses . push ( value ) ; } ) ; return statuses ; }
function ( error , session ) { if ( error ) { logger . error ( 'Invalid session' ) ; } else { request . session = session ; } var resource = Guard . Resource . fromRequest ( request ) ; guard . authorize ( resource , request . session , callback ) ; }
function handleSubmitButton ( event ) { var headline = $ ( "#entry_list input[name=entry_headline]" ) . val ( ) ; var body = $ ( "#entry_list textarea[name=entry_body]" ) . val ( ) ; var entry = "\<article\>" + "\<h2\>" + headline + "\<\/h2\>" + "\<p\>" + body + "\<\/p\>" + "\<a href=\"\#\" class=\"deleter\"\>Delete this entry\<\/a\>" + "\<\/article\>" ; alert ( entry ) ; $ ( ".entries" ) . prepend ( entry ) ; }
function ( wisemlParameter , parentDiv ) { this . wiseml = wisemlParameter ; this . origin ; this . predLat = "http://www.w3.org/2003/01/geo/wgs84_pos#lat" ; this . predLong = "http://www.w3.org/2003/01/geo/wgs84_pos#long" ; this . nodes = new Array ( ) ; this . markersArray ; this . map ; this . view = null ; this . parse ( ) ; this . buildView ( parentDiv ) ; }
function ( models , options ) { options || ( options = { } ) ; if ( options . comparator ) this . comparator = options . comparator ; _ . bindAll ( this , '_onModelEvent' , '_removeReference' ) ; this . _reset ( ) ; if ( models ) this . reset ( models , { silent : true } ) ; this . initialize . apply ( this , arguments ) ; }
function ( models , options ) { models || ( models = [ ] ) ; options || ( options = { } ) ; this . each ( this . _removeReference ) ; this . _reset ( ) ; this . add ( models , { silent : true } ) ; if ( ! options . silent ) this . trigger ( 'reset' , this , options ) ; return this ; }
function ( model , options ) { var coll = this ; options || ( options = { } ) ; model = this . _prepareModel ( model , options ) ; if ( ! model ) return false ; var success = options . success ; options . success = function ( nextModel , resp , xhr ) { coll . add ( nextModel , options ) ; if ( success ) success ( nextModel , resp , xhr ) ; } ; model . save ( null , options ) ; return model ; }
function ( options ) { this . length = 0 ; this . models = [ ] ; this . _byId = { } ; this . _byCid = { } ; }
function ( model , options ) { if ( ! ( model instanceof Backbone . Model ) ) { var attrs = model ; model = new this . model ( attrs , { collection : this } ) ; if ( model . validate && ! model . _performValidation ( attrs , options ) ) model = false ; } else if ( ! model . collection ) { model . collection = this ; } return model ; }
function ( ) { if ( ! this . el ) { var attrs = this . attributes || { } ; if ( this . id ) attrs . id = this . id ; if ( this . className ) attrs [ 'class' ] = this . className ; this . el = this . make ( this . tagName , attrs ) ; } else if ( _ . isString ( this . el ) ) { this . el = $ ( this . el ) . get ( 0 ) ; } }
function ( obj , iterator , context ) { var result = true ; if ( obj == null ) return result ; if ( nativeEvery && obj . every === nativeEvery ) return obj . every ( iterator , context ) ; each ( obj , function ( value , index , list ) { if ( ! ( result = result && iterator . call ( context , value , index , list ) ) ) return breaker ; } ) ; return result ; }
function ( obj , iterator , context ) { iterator = iterator || _ . identity ; var result = false ; if ( obj == null ) return result ; if ( nativeSome && obj . some === nativeSome ) return obj . some ( iterator , context ) ; each ( obj , function ( value , index , list ) { if ( result |= iterator . call ( context , value , index , list ) ) return breaker ; } ) ; return ! ! result ; }
function ( value , index , list ) { if ( index == 0 ) { shuffled [ 0 ] = value ; } else { rand = Math . floor ( Math . random ( ) * ( index + 1 ) ) ; shuffled [ index ] = shuffled [ rand ] ; shuffled [ rand ] = value ; } }
function ( value , index , list ) { return { value : value , criteria : iterator . call ( context , value , index , list ) } ; }
function ( iterable ) { if ( ! iterable ) return [ ] ; if ( iterable . toArray ) return iterable . toArray ( ) ; if ( _ . isArray ( iterable ) ) return slice . call ( iterable ) ; if ( _ . isArguments ( iterable ) ) return slice . call ( iterable ) ; return _ . values ( iterable ) ; }
function ( array , n , guard ) { return ( n != null ) && ! guard ? slice . call ( array , array . length - n ) : array [ array . length - 1 ] ; }
function ( array ) { return _ . reduce ( array , function ( memo , value ) { if ( _ . isArray ( value ) ) return memo . concat ( _ . flatten ( value ) ) ; memo [ memo . length ] = value ; return memo ; } , [ ] ) ; }
function ( array , other ) { return _ . filter ( array , function ( value ) { return ! _ . include ( other , value ) ; } ) ; }
function ( array , item ) { if ( array == null ) return - 1 ; if ( nativeLastIndexOf && array . lastIndexOf === nativeLastIndexOf ) return array . lastIndexOf ( item ) ; var i = array . length ; while ( i -- ) if ( array [ i ] === item ) return i ; return - 1 ; }
function ( ) { timeout = null ; func . apply ( context , args ) ; }
function ( ) { var context = this , args = arguments ; var throttler = function ( ) { timeout = null ; func . apply ( context , args ) ; } ; if ( debounce ) clearTimeout ( timeout ) ; if ( debounce || ! timeout ) timeout = setTimeout ( throttler , wait ) ; }
function ( ) { var args = slice . call ( arguments ) ; for ( var i = funcs . length - 1 ; i >= 0 ; i -- ) { args = [ funcs [ i ] . apply ( this , args ) ] ; } return args [ 0 ] ; }
function ( ) { var funcs = slice . call ( arguments ) ; return function ( ) { var args = slice . call ( arguments ) ; for ( var i = funcs . length - 1 ; i >= 0 ; i -- ) { args = [ funcs [ i ] . apply ( this , args ) ] ; } return args [ 0 ] ; } ; }
function ( obj ) { if ( obj !== Object ( obj ) ) throw new TypeError ( 'Invalid object' ) ; var keys = [ ] ; for ( var key in obj ) if ( hasOwnProperty . call ( obj , key ) ) keys [ keys . length ] = key ; return keys ; }
function ( obj ) { if ( _ . isArray ( obj ) || _ . isString ( obj ) ) return obj . length === 0 ; for ( var key in obj ) if ( hasOwnProperty . call ( obj , key ) ) return false ; return true ; }
function ( string ) { return ( '' + string ) . replace ( /&(?!\w+;|#\d+;|#x[\da-f]+;)/gi , '&amp;' ) . replace ( /</g , '&lt;' ) . replace ( />/g , '&gt;' ) . replace ( /"/g , '&quot;' ) . replace ( /'/g , '&#x27;' ) . replace ( /\//g , '&#x2F;' ) ; }
function ( ) { method . apply ( this . _wrapped , arguments ) ; return result ( this . _wrapped , this . _chain ) ; }
function ( item ) { $ ( '.fg-menu li a' , container ) . removeClass ( options . callerOnState ) ; $ ( item ) . addClass ( options . callerOnState ) ; if ( $ . address . value ( ) == $ ( item ) . attr ( 'rel' ) ) { $ . address . trigger ( ) ; } else { $ . address . value ( $ ( item ) . attr ( 'rel' ) ) ; } return false ; }
function ( directions , useforce ) { if ( ! directions ) return this . _base directions = directions . split ( '.' ) var topic = this . _base , edge , len = directions . length , i = 0 if ( len ) { do { edge = directions [ i ++ ] if ( topic [ edge ] instanceof Topic ) topic = topic [ edge ] else if ( useforce ) topic = topic [ edge ] = new Topic else break } while ( i < len ) } return topic }
function ( topic , data ) { if ( typeof topic === 'string' ) { topic = SignalTree . prototype . collect . call ( this , topic . split ( '.' ) ) } else { data = topic topic = this . _base . _listeners } return SignalTree . prototype . _emit . call ( this , topic , data ) }
function ( topics , callback ) { if ( typeof topics !== 'string' ) { if ( ! callback ) this . _base . removeListener ( topics ) else throw 'no topic specified' } topics . split ( ' ' ) . forEach ( function ( topic ) { topic = this . get ( topic , false ) if ( topic ) topic . remove ( callback ) } , this ) }
function posfn ( e , ele ) { var setpos = new pos ( ) ; setpos . x = e . clientX - ( ele . offsetLeft - document . documentElement . scrollLeft ) ; setpos . y = e . clientY - ( ele . offsetTop - document . documentElement . scrollTop ) ; console . log ( e . clientY + ":" + e . screenY + ":" + ele . offsetTop + ":" + document . documentElement . scrollTop + ":" + ele . scrollHeight + "\n" ) ; return setpos ; }
function toggleCheck ( ) { var checked = $ ( "#check_all" ) . attr ( "checked" ) ; $ ( '.host_select_boxes' ) . each ( function ( index , box ) { box . checked = checked ; hostChecked ( box ) ; } ) ; if ( ! checked ) { cleanHostsSelection ( ) ; } return false ; }
function ( options ) { var defaults = this . options || Consumer . defaults for ( var i in defaults ) { if ( defaults . hasOwnProperty ( i ) ) { this [ i ] = options [ i ] || defaults [ i ] } } this . signature_method = this . signature_method . toUpperCase ( ) }
function ( ) { var size = this . grid . get ( "size" ) , range = Math . roundTo ( this . get ( "vision" ) / size , size ) ; this . halt ( ) ; this . set ( "animation" , "attack" ) ; Tilekit . Projectile ( { source : this , from : this . get ( "position" ) , distance : this . get ( "vision" ) * 2 , angle : this . get ( "face" ) , scene : this . scene } ) ; }
function ( ) { this . halt ( ) ; this . set ( "animation" , "attack" ) ; Tilekit . emit ( "damage" , this . getPositionFront ( ) , this ) ; }
function ( ) { var size = this . grid . get ( "size" ) , range = Math . roundTo ( this . get ( "vision" ) / size , size ) ; this . halt ( ) ; this . set ( "animation" , "attack" ) ; Tilekit . Projectile ( { source : this , from : this . get ( "position" ) , distance : this . get ( "vision" ) * 2 , angle : this . get ( "face" ) , scene : this . scene } ) ; }
function markConversationAsRead ( ) { $ ( gSelectedElement ) . removeClass ( "unreadconversation" ) ; $ ( gSelectedElement ) . addClass ( "readconversation" ) ; app . decrementNrOfUnreadConvs ( ) ; $ . getJSON ( 'Messages/MarkConversationAsRead' , { conversationId : gSelectedConversationID } , function ( data ) { console . log ( data ) ; } ) ; }
function ( to ) { var presence = $pres ( ) . c ( "status" ) . t ( "Ready or not" ) ; this . connection . send ( presence ) ; this . log ( "Initial presence sent" ) ; }
function ( ) { this . _isCacheDirty = true ; this . _isNeedUpdate = true ; }
function ( fileName ) { return this . initWithTexture ( cc . TextureCache . sharedTextureCache ( ) . addImage ( fileName ) ) ; }
function ( index ) { switch ( index ) { case 0 : return new SpriteProgressToRadial ( ) ; case 1 : return new SpriteProgressToHorizontal ( ) ; case 2 : return new SpriteProgressToVertical ( ) ; } return null ; }
function ( ) { this . callSuper ( 'init' ) ; this . createEventListener ( 'textPropertyChanged' , this . _updateText , this ) ; this . setWidth ( 'auto' ) ; this . setHeight ( 'auto' ) ; $ ( this . domElement ) . html ( this . getText ( ) ) ; }
function ( e ) { if ( e . which != 9 ) return ; if ( ! e . ctrlKey && ! e . altKey && ! e . shiftKey && tinymce . activeEditor && ! tinymce . activeEditor . isHidden ( ) ) { $ ( 'td.mceToolbar > a' ) . focus ( ) ; e . preventDefault ( ) ; } }
function ( i ) { var $input ; $input = $ ( this ) ; $input . val ( i + 1 ) ; }
function ( e ) { enyo . log ( 'on connect click' ) ; var clientID = '9b384ddcfacc427c99396cc068f2798b' ; var redirectUri = 'http://instagrio.tsung.bz/token' ; var url = 'https://api.instagram.com/oauth/authorize/?client_id=' + clientID + '&redirect_uri=' + redirectUri + '&response_type=code&scope=likes+comments+relationships' ; enyo . log ( 'opening url: ' + url ) ; new io . OAuthPasscode ( ) . renderInto ( document . body ) ; }
function ( ) { var that = this ; enyo . log ( 'on main create' ) ; this . inherited ( arguments ) ; this . items = [ ] ; this . fetch ( 'hot' ) ; this . index = 1 ; }
function ( index ) { enyo . log ( 'getView ' + index ) ; if ( this . items && this . items . length > index && index >= 0 ) { return { kind : 'io.TinyGrid' , items : this . items [ index ] } } else { return { content : this . items [ index ] } ; } }
function ( draggable ) { var torrent = draggable . data ( 'torrent' ) . id ; if ( ! draggable . data ( 'bubble' ) || ! torrent ) { return ; } var addable = this . model . btapp . has ( 'add' ) ; var duplicate = this . model . btapp . has ( 'torrent' ) && this . model . btapp . get ( 'torrent' ) . get ( torrent . toUpperCase ( ) ) ; var ret = addable && ! duplicate ; return ret ; }
function ap_ext_newUser ( ) { newuser = $ ( "#newuser" ) . val ( ) ; if ( newuser == "" ) { alert ( lang_checkUsername ) ; return false ; } $ . post ( ap_ext_path + "processor.php" , { axAction : "createUsr" , axValue : newuser , id : 0 } , function ( data ) { ap_ext_refreshSubtab ( 'usr' ) ; ap_ext_editUser ( data ) ; } ) ; }
function ap_ext_newGroup ( ) { newgroup = $ ( "#newgroup" ) . val ( ) ; if ( newgroup == "" ) { alert ( lang_checkGroupname ) ; return false ; } $ . post ( ap_ext_path + "processor.php" , { axAction : "createGrp" , axValue : newgroup , id : 0 } , function ( data ) { ap_ext_refreshSubtab ( 'grp' ) ; } ) ; }
function ap_ext_newStatus ( ) { newstatus = $ ( "#newstatus" ) . val ( ) ; if ( newstatus == "" ) { alert ( lang_checkStatusname ) ; return false ; } $ . post ( ap_ext_path + "processor.php" , { axAction : "createStatus" , axValue : newstatus , id : 0 } , function ( data ) { ap_ext_refreshSubtab ( 'status' ) ; } ) ; }
function ( data ) { switch ( tab ) { case "usr" : target = "#ap_ext_s1" ; break case "grp" : target = "#ap_ext_s2" ; break case "status" : target = "#ap_ext_s3" ; break case "adv" : target = "#ap_ext_s4" ; break case "db" : target = "#ap_ext_s5" ; break case "knd" : target = "#ap_ext_s6" ; break case "pct" : target = "#ap_ext_s7" ; break case "evt" : target = "#ap_ext_s8" ; break } $ ( target ) . html ( data ) ; }
function ( data ) { if ( confirm ( data ) ) { $ . post ( ap_ext_path + "processor.php" , { axAction : "deleteUsr" , axValue : 1 , id : id } , function ( ) { ap_ext_refreshSubtab ( 'usr' ) ; ap_ext_refreshSubtab ( 'grp' ) ; hook_chgUsr ( ) ; } ) ; } }
function ap_ext_deleteUser ( id ) { $ . post ( ap_ext_path + "processor.php" , { axAction : "deleteUsr" , axValue : 0 , id : id } , function ( data ) { if ( confirm ( data ) ) { $ . post ( ap_ext_path + "processor.php" , { axAction : "deleteUsr" , axValue : 1 , id : id } , function ( ) { ap_ext_refreshSubtab ( 'usr' ) ; ap_ext_refreshSubtab ( 'grp' ) ; hook_chgUsr ( ) ; } ) ; } } ) ; }
function ap_ext_deleteGroup ( id ) { $ . post ( ap_ext_path + "processor.php" , { axAction : "deleteGrp" , axValue : 0 , id : id } , function ( data ) { if ( confirm ( data ) ) { $ . post ( ap_ext_path + "processor.php" , { axAction : "deleteGrp" , axValue : 1 , id : id } , function ( ) { ap_ext_refreshSubtab ( 'grp' ) ; } ) ; } } ) ; }
function ap_ext_deleteStatus ( id ) { $ . post ( ap_ext_path + "processor.php" , { axAction : "deleteStatus" , axValue : 0 , id : id } , function ( data ) { if ( confirm ( data ) ) { $ . post ( ap_ext_path + "processor.php" , { axAction : "deleteStatus" , axValue : 1 , id : id } , function ( ) { ap_ext_refreshSubtab ( 'status' ) ; } ) ; } } ) ; }
function ( data ) { if ( confirm ( data ) ) { if ( currentRecording == - 1 && selected_pct == id ) { $ ( '#buzzer' ) . addClass ( 'disabled' ) ; selected_pct = false ; $ ( "#sel_pct" ) . html ( '' ) ; } $ . post ( ap_ext_path + "processor.php" , { axAction : "deletePct" , axValue : 1 , id : id } , function ( ) { ap_ext_refreshSubtab ( 'pct' ) ; hook_chgPct ( ) ; } ) ; } }
function ( data ) { if ( confirm ( data ) ) { if ( currentRecording == - 1 && selected_knd == id ) { $ ( '#buzzer' ) . addClass ( 'disabled' ) ; selected_knd = false ; $ ( "#sel_knd" ) . html ( '' ) ; } $ . post ( ap_ext_path + "processor.php" , { axAction : "deleteKnd" , axValue : 1 , id : id } , function ( ) { ap_ext_refreshSubtab ( 'knd' ) ; hook_chgKnd ( ) ; } ) ; } }
function ( data ) { if ( confirm ( data ) ) { if ( currentRecording == - 1 && selected_evt == id ) { $ ( '#buzzer' ) . addClass ( 'disabled' ) ; selected_evt = false ; $ ( "#sel_evt" ) . html ( '' ) ; } $ . post ( ap_ext_path + "processor.php" , { axAction : "deleteEvt" , axValue : 1 , id : id } , function ( ) { ap_ext_refreshSubtab ( 'evt' ) ; hook_chgEvt ( ) ; } ) ; } }
function ap_ext_unbanUser ( id ) { $ ( "#ban" + id ) . blur ( ) ; $ ( "#ban" + id ) . html ( "<img border='0' width='16' height='16' src='../skins/" + skin + "/grfx/loading13.gif'/>" ) ; $ . post ( ap_ext_path + "processor.php" , { axAction : "unbanUsr" , axValue : 0 , id : id } , function ( data ) { $ ( "#ban" + id ) . html ( data ) ; $ ( "#ban" + id ) . attr ( { "ONCLICK" : "ap_ext_banUser('" + id + "'); return false;" } ) ; } ) ; }
function ap_ext_banUser ( id ) { $ ( "#ban" + id ) . blur ( ) ; $ ( "#ban" + id ) . html ( "<img border='0' width='16' height='16' src='../skins/" + skin + "/grfx/loading13.gif'/>" ) ; $ . post ( ap_ext_path + "processor.php" , { axAction : "banUsr" , axValue : 0 , id : id } , function ( data ) { $ ( "#ban" + id ) . html ( data ) ; $ ( "#ban" + id ) . attr ( { "ONCLICK" : "ap_ext_unbanUser('" + id + "'); return false;" } ) ; } ) ; }
function exp_ext_get_dimensions ( ) { scroller_width = 17 ; if ( navigator . platform . substr ( 0 , 3 ) == 'Mac' ) { scroller_width = 16 ; } ( kndShrinkMode ) ? subtableCount = 2 : subtableCount = 3 ; subtableWidth = ( pageWidth ( ) - 10 ) / subtableCount - 7 ; exp_w = pageWidth ( ) - 24 ; exp_h = pageHeight ( ) - 224 - headerHeight ( ) - 28 ; }
function exp_ext_applyHoverIntent2expRows ( ) { $ ( '#exp tr' ) . hoverIntent ( { sensitivity : 1 , interval : 500 , over : function ( ) { $ ( '#exp tr' ) . removeClass ( 'hover' ) ; $ ( this ) . addClass ( 'hover' ) ; } , out : function ( ) { $ ( this ) . removeClass ( 'hover' ) ; } } ) ; }
function exp_pasteNow ( value ) { now = new Date ( ) ; H = now . getHours ( ) ; i = now . getMinutes ( ) ; s = now . getSeconds ( ) ; if ( H < 10 ) H = "0" + H ; if ( i < 10 ) i = "0" + i ; if ( s < 10 ) s = "0" + s ; time = H + ":" + i + ":" + s ; $ ( "#edit_time" ) . val ( time ) ; }
function xp_ext_select_filter ( ) { $ ( '#xp_ext_select_filter' ) . addClass ( "pressed" ) ; $ ( '#xp_ext_tab_filter' ) . css ( "display" , "block" ) ; $ ( '#xp_ext_select_location' ) . removeClass ( "pressed" ) ; $ ( '#xp_ext_tab_location' ) . css ( "display" , "none" ) ; $ ( '#xp_ext_select_timeformat' ) . removeClass ( "pressed" ) ; $ ( '#xp_ext_tab_timeformat' ) . css ( "display" , "none" ) ; }
function xp_ext_select_location ( ) { $ ( '#xp_ext_select_location' ) . addClass ( "pressed" ) ; $ ( '#xp_ext_tab_location' ) . css ( "display" , "block" ) ; $ ( '#xp_ext_select_filter' ) . removeClass ( "pressed" ) ; $ ( '#xp_ext_tab_filter' ) . css ( "display" , "none" ) ; $ ( '#xp_ext_select_timeformat' ) . removeClass ( "pressed" ) ; $ ( '#xp_ext_tab_timeformat' ) . css ( "display" , "none" ) ; }
function xp_ext_select_timeformat ( ) { $ ( '#xp_ext_select_timeformat' ) . addClass ( "pressed" ) ; $ ( '#xp_ext_tab_timeformat' ) . css ( "display" , "block" ) ; $ ( '#xp_ext_select_filter' ) . removeClass ( "pressed" ) ; $ ( '#xp_ext_tab_filter' ) . css ( "display" , "none" ) ; $ ( '#xp_ext_select_location' ) . removeClass ( "pressed" ) ; $ ( '#xp_ext_tab_location' ) . css ( "display" , "none" ) ; }
function xp_ext_get_dimensions ( ) { scroller_width = 17 ; if ( navigator . platform . substr ( 0 , 3 ) == 'Mac' ) { scroller_width = 16 ; } ( kndShrinkMode ) ? subtableCount = 2 : subtableCount = 3 ; subtableWidth = ( pageWidth ( ) - 10 ) / subtableCount - 7 ; xp_w = pageWidth ( ) - 24 ; xp_h = pageHeight ( ) - 274 - headerHeight ( ) - 28 ; }
function ts_ext_get_dimensions ( ) { scroller_width = 17 ; if ( navigator . platform . substr ( 0 , 3 ) == 'Mac' ) { scroller_width = 16 ; } ( kndShrinkMode ) ? subtableCount = 2 : subtableCount = 3 ; subtableWidth = ( pageWidth ( ) - 10 ) / subtableCount - 7 ; zef_w = pageWidth ( ) - 24 ; zef_h = pageHeight ( ) - 224 - headerHeight ( ) - 28 ; }
function ts_ext_applyHoverIntent2zefRows ( ) { $ ( '#zef tr' ) . hoverIntent ( { sensitivity : 1 , interval : 500 , over : function ( ) { $ ( '#zef tr' ) . removeClass ( 'hover' ) ; $ ( this ) . addClass ( 'hover' ) ; } , out : function ( ) { $ ( this ) . removeClass ( 'hover' ) ; } } ) ; }
function ( data ) { $ ( "#add_edit_zef_evt_ID" ) . html ( data ) ; $ ( "#add_edit_zef_evt_ID" ) . val ( selected_evt ) ; if ( noUpdateRate == undefined ) getBestRates ( ) ; ts_add_edit_validate ( ) ; if ( evt > 0 ) { $ . getJSON ( "../extensions/ki_timesheets/processor.php" , { axAction : "budgets" , project_id : pct , event_id : evt , zef_id : zef } , function ( data ) { ts_ext_updateBudget ( data ) ; } ) ; } }
function ( data ) { eval ( data ) ; ts_ext_reload ( ) ; buzzer_preselect ( 'pct' , pct , pct_name , knd , knd_name , false ) ; buzzer_preselect ( 'evt' , evt , evt_name , 0 , 0 , false ) ; $ ( "#ticker_knd" ) . html ( knd_name ) ; $ ( "#ticker_pct" ) . html ( pct_name ) ; $ ( "#ticker_evt" ) . html ( evt_name ) ; }
function ( data ) { if ( data . hourlyRate == false ) { } else { $ ( "#ts_ext_form_add_edit_record #rate" ) . val ( data . hourlyRate ) ; } if ( data . fixedRate == false ) { $ ( "#ts_ext_form_add_edit_record #fixed_rate" ) . val ( '' ) ; } else { $ ( "#ts_ext_form_add_edit_record #fixed_rate" ) . val ( data . fixedRate ) ; } }
function stopRecord ( ) { $ ( "#zeftable>table>tbody>tr>td>a.stop>img" ) . attr ( "src" , "../skins/" + skin + "/grfx/loading13_red.gif" ) ; $ ( "#zeftable>table>tbody>tr:first-child>td" ) . css ( "background-color" , "#F00" ) ; $ ( "#zeftable>table>tbody>tr:first-child>td" ) . css ( "color" , "#FFF" ) ; show_selectors ( ) ; $ . post ( "processor.php" , { axAction : "stopRecord" , axValue : 0 , id : currentRecording } , function ( ) { ts_ext_reload ( ) ; document . title = default_title ; } ) ; }
function updateRecordStatus ( record_ID , record_startTime , knd_ID , knd_name , pct_ID , pct_name , evt_ID , evt_name ) { startsec = record_startTime ; if ( record_ID == false ) { currentRecording = - 1 ; show_selectors ( ) ; return ; } buzzer_preselect ( 'pct' , pct_ID , pct_name , knd_ID , knd_name , false ) ; lists_reload ( 'evt' , function ( ) { buzzer_preselect ( 'evt' , evt_ID , evt_name , 0 , '' , false ) ; } ) ; }
function show_selectors ( ) { ticktack_off ( ) ; $ ( "#selector" ) . css ( 'display' , 'block' ) ; $ ( "#stopwatch" ) . css ( 'display' , 'none' ) ; $ ( "#stopwatch_ticker" ) . css ( 'display' , 'none' ) ; $ ( "#buzzer" ) . removeClass ( "act" ) ; if ( ! ( selected_knd && selected_pct && selected_evt ) ) { $ ( '#buzzer' ) . addClass ( 'disabled' ) ; } }
function buzzer ( ) { if ( currentRecording == - 1 && $ ( '#buzzer' ) . hasClass ( 'disabled' ) ) return ; if ( currentRecording > - 1 ) { currentRecording = 0 ; stopRecord ( ) ; } else { setTimespace ( undefined , new Date ( ) ) ; startRecord ( selected_pct , selected_evt , usr_ID ) ; $ ( '#buzzer' ) . addClass ( 'disabled' ) ; } }
function editSubject ( subject , id ) { var height = 180 ; var width = 450 ; if ( subject == 'pct' ) { height = 250 ; width = 650 ; } floaterShow ( 'floaters.php' , 'add_edit_' + subject , 0 , id , width , height ) ; return false ; }
function lists_shrinkExtToggle ( ) { ( extShrinkMode ) ? extShrinkMode = 0 : extShrinkMode = 1 ; if ( extShrinkMode ) { $ ( '#extShrink' ) . css ( "background-image" , "url('../skins/" + skin + "/grfx/zefShrink_down.png')" ) ; } else { $ ( '#extShrink' ) . css ( "background-image" , "url('../skins/" + skin + "/grfx/zefShrink_up.png')" ) ; } lists_set_heightTop ( ) ; hook_resize ( ) ; }
function lists_shrinkUsrToggle ( ) { ( usrShrinkMode ) ? usrShrinkMode = 0 : usrShrinkMode = 1 ; if ( usrShrinkMode ) { $ ( '#usr, #usr_head, #usr_foot' ) . fadeOut ( fading_enabled ? "slow" : 0 , lists_set_tableWrapperWidths ) ; $ ( '#usrShrink' ) . css ( "background-image" , "url('../skins/" + skin + "/grfx/kndShrink_right.png')" ) ; } else { $ ( '#usr, #usr_head, #usr_foot' ) . fadeIn ( fading_enabled ? "slow" : 0 ) ; lists_set_tableWrapperWidths ( ) ; $ ( '#usrShrink' ) . css ( "background-image" , "url('../skins/" + skin + "/grfx/kndShrink_left.png')" ) ; } }
function lists_get_dimensions ( ) { scroller_width = 17 ; if ( navigator . platform . substr ( 0 , 3 ) == 'Mac' ) { scroller_width = 16 ; } subtableCount = 4 ; if ( kndShrinkMode ) { subtableCount -- ; } if ( usrShrinkMode ) { subtableCount -- ; } subtableWidth = ( pageWidth ( ) - 10 ) / subtableCount - 7 ; usr_w = subtableWidth - 5 ; knd_w = subtableWidth - 5 ; pct_w = subtableWidth - 6 ; evt_w = subtableWidth - 5 ; }
function ( data ) { $ ( "#usr" ) . html ( data ) ; ( $ ( "#usr" ) . innerHeight ( ) - $ ( "#usr table" ) . outerHeight ( ) > 0 ) ? scr = 0 : scr = scroller_width ; $ ( "#usr table" ) . css ( "width" , knd_w - scr ) ; lists_live_filter ( 'usr' , $ ( '#filt_usr' ) . val ( ) ) ; lists_write_annotations ( 'usr' ) ; if ( typeof ( callback ) != "undefined" ) callback ( ) ; }
function ( data ) { $ ( "#knd" ) . html ( data ) ; ( $ ( "#knd" ) . innerHeight ( ) - $ ( "#knd table" ) . outerHeight ( ) > 0 ) ? scr = 0 : scr = scroller_width ; $ ( "#knd table" ) . css ( "width" , knd_w - scr ) ; lists_live_filter ( 'knd' , $ ( '#filt_knd' ) . val ( ) ) ; lists_write_annotations ( 'knd' ) ; if ( typeof ( callback ) != "undefined" ) callback ( ) ; }
function lists_update_annotations ( id , usr , knd , pct , evt ) { lists_ann_usr [ id ] = usr ; lists_ann_knd [ id ] = knd ; lists_ann_pct [ id ] = pct ; lists_ann_evt [ id ] = evt ; if ( $ ( '.menu li#exttab_' + id ) . hasClass ( 'act' ) ) lists_write_annotations ( ) ; }
function ( form ) { $ ( '#results' ) . empty ( ) ; searchSpinner = startSpinner ( $ ( '#results' ) . get ( 0 ) ) ; $ ( '#lastQuery' ) . val ( $ ( '#q' ) . val ( ) . trim ( ) ) ; $ ( '#advanced-search' ) . fadeOut ( ) ; }
function findFile ( paths , file ) { for ( var i = 0 ; i < paths . length ; i ++ ) { var filePath = path . resolve ( paths [ i ] , file ) if ( path . existsSync ( filePath ) ) { return filePath } } return null }
function ( ) { if ( commentsOnly . attr ( 'checked' ) ) { $ ( "div.change ul.changes" ) . hide ( ) ; $ ( "div.change:not(:has(.comment))" ) . hide ( ) ; } else { $ ( "div.change ul.changes" ) . show ( ) ; $ ( "div.change:not(:has(.comment))" ) . show ( ) ; } }
function ( response ) { var form = jQuery ( '#type-metadata-form' ) ; form . hide ( ) ; form . html ( response ) ; form . trigger ( 'omeka:elementformload' ) ; form . slideDown ( 1000 , function ( ) { jQuery ( this ) . show ( ) ; } ) ; }
function ( ) { alert ( '删除成功' ) ; $ ( '#efcList' ) . window ( 'refresh' ) ; }
function ( msg ) { window . parent . makeRequest ( ) ; }
function ( data ) { alert ( "记录删除成功" ) ; window . location . href = 'ef_list_by_item.jsp?efiId=' + getQueryString ( "efiId" ) ; }
function dispatch ( ) { var node = this . first ; while ( node = node . next ) { document . documentElement . attachEvent ( "onpropertychange" , getSignalClosure ( this , node , arguments ) , false ) ; } ++ document . documentElement [ SIGNAL_EVENT ] ; }
function wrapDialogButtons ( buttons ) { for ( title in buttons ) { if ( buttons . hasOwnProperty ( title ) ) { buttons [ title ] = ( function ( orgCallback ) { return function ( ) { orgCallback . apply ( this ) ; $ ( this ) . dialog ( 'destroy' ) ; } ; } ) ( buttons [ title ] ) ; } } return buttons ; }
function ( ) { return resolveAPromise ( ) ; }
function ( ) { r . resolveURL ( { client : client , userAgent : userAgent } ) . then ( notCalled , spy ) ; expect ( db . logActivity ) . not . toHaveBeenCalled ( ) ; expect ( db . logError ) . toHaveLogged ( { message : 'Missing or invalid URI' , url : undefined , client : client , code : 404 } ) ; }
function ( ) { r . resolveURL ( { url : invalidUrl , client : client , userAgent : userAgent } ) . then ( notCalled , spy ) ; expect ( db . logActivity ) . not . toHaveBeenCalled ( ) ; expect ( db . logError ) . toHaveLogged ( { message : 'Missing or invalid URI' , url : invalidUrl , client : client , code : 404 } ) ; }
function ( ) { return resolveAPromise ( ) ; }
function ( longLink ) { promise . resolve ( longLink ) ; db . logActivity ( { message : 'Link hit' , linkID : id } ) . then ( null , function ( err ) { db . logError ( { message : 'Database error writing to the activity log' , error : err . error , code : err . code } ) . then ( null , throwImmediately ) ; } ) ; }
function ( err ) { err = err || { } ; if ( ! err . message ) { err . message = 'Database error' ; } if ( ! err . code ) { err . code = 500 ; } promise . reject ( err . message , err . code ) ; logging . error ( err ) ; }
function ( buffer , contentType , httpStatusCode ) { try { response . writeHead ( httpStatusCode , { 'Content-Type' : contentType , 'Content-Length' : buffer . length , 'Cache-Control' : 'max-age=2592000' } ) ; options . stats . dataCount [ request . connection . remoteAddress ] += buffer . length ; response . end ( buffer , 'binary' ) ; options . logger . access ( request , httpStatusCode , buffer . length ) ; } catch ( e ) { } }
function ( inputdata ) { var lines = inputdata . split ( "\n" ) ; for ( var i in lines ) { if ( lines [ i ] . search ( /Permalink/ ) == - 1 ) { lines [ i ] = replaceSoupLinksInString ( lines [ i ] ) ; } } return new Buffer ( lines . join ( "\n" ) ) ; }
function mouseMoveHandler ( e , position ) { if ( ! this . handles . initialized ) return ; if ( ! this . handles . moveHandler ) return ; var delta = position . dX , selection = this . selection . selection , area = this . selection . getArea ( ) , handles = this . handles ; handles . moveHandler ( area , delta ) ; checkSwap ( area , handles ) ; this . selection . setSelection ( area ) ; }
function ( index , value ) { jQuery ( this ) . siblings ( '.block-content, .view' ) . slideToggle ( 'slow' ) ; var parent = jQuery ( this ) . parent ( '.block-slider' ) ; if ( parent . hasClass ( 'toggle-open' ) ) { parent . removeClass ( 'toggle-open' ) . addClass ( 'toggle-close' ) ; } else { parent . removeClass ( 'toggle-close' ) . addClass ( 'toggle-open' ) ; } return false ; }
function ( event ) { event . preventDefault ( ) ; var hashId = this . hash ; if ( hashId == '#write-review-link' ) { jQuery ( hashId ) . parents ( 'form' ) . parent ( '.block-content' ) . slideToggle ( 'slow' ) ; } jQuery ( 'html,body' ) . animate ( { scrollTop : jQuery ( this . hash ) . offset ( ) . top } , 500 ) ; }
function ( ) { if ( angular . isString ( ngModel . $viewValue ) ) { codemirror . setValue ( ngModel . $viewValue ) ; } else { var changeHandler = codemirror . getOption ( 'onChange' ) ; codemirror . setOption ( 'onChange' , angular . noop ) ; codemirror . setValue ( '' ) ; codemirror . setOption ( 'onChange' , changeHandler ) ; } }
function km_disableSetting ( theKey ) { var i = this . settingGroups . indexOf ( theKey ) ; if ( i === - 1 ) { this . updateSettings ( ) ; return ; } this . settingGroups = [ ] . concat ( this . settingGroups . slice ( 0 , i ) , this . settingGroups . slice ( i + 1 , this . settingGroups . length ) ) ; this . updateSettings ( ) ; }
function ( i ) { return i ; }
function ( ) { expect ( 2 ) ; equal ( baidu ( "#text1" ) . attr ( "value" , function ( ) { return this . id ; } ) [ 0 ] . value , "text1" , "Set value from id" ) ; equal ( baidu ( "#text1" ) . attr ( "title" , function ( i ) { return i ; } ) . attr ( "title" ) , "0" , "Set value with an index" ) ; }
function ( obj ) { if ( obj . err ) { alertFailure ( "#selectSubjectAlert" , obj . err ) ; } else { var origin = subjectDictionary [ profile . selected ] ; origin . selected_by = subjectRemoveMyself ( origin . selected_by , profile . username ) ; origin . updateInfo ( ) ; profile . selected = s . id ; s . selected_by . push ( { username : profile . username , realname : profile . realname } ) ; s . updateInfo ( ) ; } }
function ( ) { var container = $ ( "<div></div>" , { "class" : "select2-container select2-container-multi" } ) . html ( [ "    <ul class='select2-choices'>" , "  <li class='select2-search-field'>" , "    <input type='text' autocomplete='off' style='width: 25px;' class='select2-input'>" , "  </li>" , "</ul>" , "<div class='select2-drop select2-drop-multi' style='display:none;'>" , "   <ul class='select2-results'>" , "   </ul>" , "</div>" ] . join ( "" ) ) ; this . setContainerWidth ( container ) ; return container ; }
function ( event ) { this . $el . empty ( ) ; this . $el . html ( this . template ( { title : this . options . page_title , back_label : this . options . back_label } ) ) ; this . renderContent ( ) ; return this ; }
function ( ) { var content_template = TapAPI . templateManager . get ( 'tour-list' ) ; $ ( ":jqmData(role='content')" , this . $el ) . append ( this . content_template ) ; _ . each ( this . model . models , function ( tour ) { $ ( '#tour-list' , this . $el ) . append ( new TapAPI . views . TourListItem ( { model : tour } ) . render ( ) . el ) ; } , this ) ; $ ( '#tour-list' ) . listview ( 'refresh' ) ; }
function ( ) { var bracketsSHA = BuildInfoUtils . getBracketsSHA ( ) , bracketsAppSHA = BuildInfoUtils . getBracketsAppSHA ( ) , versionLabel = "" ; if ( bracketsSHA ) { versionLabel += " (" + bracketsSHA . substr ( 0 , 7 ) + ")" ; } if ( bracketsAppSHA ) { versionLabel += " (shell " + bracketsAppSHA . substr ( 0 , 7 ) + ")" ; } $ ( "#about-build-number" ) . text ( versionLabel ) ; Dialogs . showModalDialog ( Dialogs . DIALOG_ID_ABOUT ) ; }
function lineComment ( editor ) { editor = editor || EditorManager . getFocusedEditor ( ) ; if ( ! editor ) { return ; } var mode = editor . _codeMirror . getOption ( "mode" ) ; if ( mode === "javascript" || mode === "less" ) { lineCommentSlashSlash ( editor ) ; } }
function _extractTagName ( ctx ) { if ( ctx . token . state . tagName ) { return ctx . token . state . tagName ; } else { return ctx . token . state . htmlState . tagName ; } }
function ( ) { var defaults = { projectPath : _getDefaultProjectPath ( ) , projectTreeState : "" } ; _prefs = PreferencesManager . getPreferenceStorage ( PREFERENCES_CLIENT_ID , defaults ) ; $ ( FileViewController ) . on ( "documentSelectionFocusChange" , _documentSelectionFocusChange ) ; $ ( "#open-files-container" ) . on ( "contentChanged" , function ( ) { _redraw ( false ) ; } ) ; CommandManager . register ( Commands . FILE_OPEN_FOLDER , openProject ) ; }
function markStart ( name ) { if ( ! enabled ) { return ; } var time = brackets . app . getElapsedMilliseconds ( ) ; if ( Array . isArray ( name ) ) { var i ; for ( i = 0 ; i < name . length ; i ++ ) { _markStart ( name [ i ] , time ) ; } } else { _markStart ( name , time ) ; } return name ; }
function ( ) { myDocument = SpecRunnerUtils . createMockDocument ( content ) ; $ ( "body" ) . append ( "<div id='editor'/>" ) ; myEditor = new Editor ( myDocument , true , "" , $ ( "#editor" ) . get ( 0 ) , { } ) ; }
function ( ) { it ( "should not have focus until explicitly set" , function ( ) { expect ( myEditor . hasFocus ( ) ) . toBe ( false ) ; } ) ; it ( "should be able to detect when it has focus" , function ( ) { myEditor . focus ( ) ; expect ( myEditor . hasFocus ( ) ) . toBe ( true ) ; } ) ; }
function _isModifier ( left , right , previouslyFound , origDescriptor ) { if ( ! left || ! right ) { return false ; } left = left . trim ( ) . toLowerCase ( ) ; right = right . trim ( ) . toLowerCase ( ) ; var matched = ( left . length > 0 && left === right ) ; if ( matched && previouslyFound ) { console . log ( "KeyMap _normalizeKeyDescriptorString() - Modifier defined twice: " + origDescriptor ) ; } return matched ; }
function _handleRunUnitTests ( ) { if ( _testWindow ) { try { _testWindow . location . reload ( ) ; } catch ( e ) { _testWindow = null ; } } if ( ! _testWindow ) { _testWindow = window . open ( "../test/SpecRunner.html" ) ; _testWindow . location . reload ( ) ; } }
function findByPath ( file , i ) { ret = i ; return file . fullPath === fullPath ; }
function findInWorkingSet ( fullPath ) { var ret = - 1 ; var found = _workingSet . some ( function findByPath ( file , i ) { ret = i ; return file . fullPath === fullPath ; } ) ; return ( found ? ret : - 1 ) ; }
function addToWorkingSet ( file ) { if ( findInWorkingSet ( file . fullPath ) !== - 1 ) { return ; } _workingSet . push ( file ) ; $ ( exports ) . triggerHandler ( "workingSetAdd" , file ) ; }
function _removeFromWorkingSet ( file ) { var index = findInWorkingSet ( file . fullPath ) ; if ( index === - 1 ) { return ; } _workingSet . splice ( index , 1 ) ; $ ( exports ) . triggerHandler ( "workingSetRemove" , file ) ; }
function setCurrentDocument ( document ) { if ( _currentDocument === document ) { return ; } var perfTimerName = PerfUtils . markStart ( "setCurrentDocument:\t" + ( ! document || document . file . fullPath ) ) ; if ( ! ProjectManager . isWithinProject ( document . file . fullPath ) ) { addToWorkingSet ( document . file ) ; } _currentDocument = document ; $ ( exports ) . triggerHandler ( "currentDocumentChange" ) ; PerfUtils . addMeasurement ( perfTimerName ) ; }
function ( q , e , n ) { var f = new JMEFunction ( this ) ; if ( n != undefined ) this . functions . splice ( n , 0 , f ) ; else this . functions . push ( f ) ; return f ; }
function ( event , position , total , percentComplete ) { if ( uploads . length > 0 ) { var percentVal = percentComplete + '%' ; $ ( '#' + formid + ' .progress .bar' ) . width ( percentVal ) $ ( '#' + formid + ' .progress .percent' ) . html ( percentVal ) ; } }
function preFlight ( formData , jqForm , options ) { var formID = $ ( jqForm [ 0 ] [ 'form_id' ] ) . val ( ) ; if ( $ ( '#form' + formID ) . valid ( ) ) { if ( $ ( '#form' + formID + ' .fileupload' ) . length > 0 ) { $ ( '#form' + formID + ' .progress' ) . show ( ) ; } return true ; } else { $ ( '#form' + formID ) . validate ( { errorElement : 'span' } ) ; return false ; } }
function cpac_initialise ( ) { jQuery ( '#respond_title' ) . after ( '<div id="error" style="background: #761d19; margin: 0 0 0.4em 0; padding: 0.4em; -moz-border-radius: 6px; -khtml-border-radius: 6px; -webkit-border-radius: 6px; border-radius: 6px; color: #fff; line-height: 1.3em;"></div>' ) ; jQuery ( '#commentform' ) . after ( '<img src="' + cpac_path + 'loading.gif" id="loading" alt="' + cpac_lang [ 0 ] + '" />' ) ; jQuery ( '#loading' ) . hide ( ) ; form = jQuery ( '#commentform' ) ; err = jQuery ( '#error' ) ; err . hide ( ) ; }
function cpac_initialise ( ) { jQuery ( '#respond_title' ) . after ( '<div id="error" style="background: #761d19; margin: 0 0 0.4em 0; padding: 0.4em; -moz-border-radius: 6px; -khtml-border-radius: 6px; -webkit-border-radius: 6px; border-radius: 6px; color: #fff; line-height: 1.3em;"></div>' ) ; jQuery ( '#commentform' ) . after ( '<img src="' + cpac_path + 'loading.gif" id="loading" alt="' + cpac_lang [ 0 ] + '" />' ) ; jQuery ( '#loading' ) . hide ( ) ; form = jQuery ( '#commentform' ) ; err = jQuery ( '#error' ) ; err . hide ( ) ; }
function loadFromDirectory ( dir ) { var newData = this . parseBestMatch ( pathUtils . join ( dir , this . file ) ) ; this . result = Object . merge ( newData , this . result ) ; return this ; }
function ( T ) { if ( $$ . fjs . twitter . user ) { $$ . fjs . fire ( 'org.fjs.twitter.login_status.change' , true , true , $$ . fjs . twitter . user ) ; return true ; } T . signIn ( ) ; }
function ( req , res ) { var artist_id = req . params . id ; database . getArtist ( artist_id , function ( err , artist ) { if ( artist == undefined ) { res . send ( 404 ) ; return ; } database . getAlbumsByArtist ( artist_id , function ( err , albums ) { res . render ( 'artist' , { title : artist . name , artist : artist , albums : albums } ) ; } ) ; } ) ; }
function cursorX ( evt ) { if ( evt . pageX ) return evt . pageX ; else if ( evt . clientX ) return evt . clientX + ( document . documentElement . scrollLeft ? document . documentElement . scrollLeft : document . body . scrollLeft ) ; }
function cursorX ( evt ) { if ( evt . pageX ) return evt . pageX ; else if ( evt . clientX ) return evt . clientX + ( document . documentElement . scrollLeft ? document . documentElement . scrollLeft : document . body . scrollLeft ) ; }
function ( field ) { var max = this . data [ 0 ] [ field ] ; for ( var dP in this . data ) { if ( this . data [ dP ] [ field ] > max ) max = this . data [ dP ] [ field ] ; } return max ; }
function ( field ) { var mean = 0 ; for ( var dP in this . data ) { mean += this . data [ dP ] [ field ] ; } return ( mean / this . data . length ) ; }
function ( ) { if ( $ ( this ) . attr ( "checked" ) ) { $ . get ( 'actions/experiments.php' , { action : "hideSes" , id : $ ( this ) . attr ( 'name' ) } , function ( data ) { alert ( data ) ; } ) ; } else { $ . get ( 'actions/experiments.php' , { action : "unhideSes" , id : $ ( this ) . attr ( 'name' ) } , function ( data ) { alert ( data ) ; } ) ; } }
function ( reason ) { self . error ( reason ) ; }
function ( ) { if ( transactions . length == size ) { apiGetRejectionReason ( Crypto . util . bytesToHex ( self . tx . getHash ( ) . reverse ( ) ) , function ( reason ) { self . error ( reason ) ; } , function ( ) { self . error ( 'Unknown Error Pushing Transaction' ) ; } ) ; } }
function ( data ) { var change = false ; for ( var key in addresses ) { var addr = addresses [ key ] ; if ( addr . tag == 1 ) { addr . tag = null ; change = true ; } if ( change ) buildVisibleView ( ) ; } payload_checksum = checksum ; makeNotice ( 'success' , 'misc-success' , data ) ; if ( successcallback != null ) successcallback ( ) ; updateCacheManifest ( ) ; }
function ( resp ) { if ( onError ) { onError ( model , resp , options ) ; } else { model . trigger ( 'error' , model , resp , options ) ; } }
function ( exists ) { if ( ! exists ) { return callback ( new Error ( "Error: Theme does not exist" ) ) ; } path . exists ( themeAssets , function ( exists ) { if ( ! exists ) { util . log ( "No assets directory found in " + themeDirectory ) ; fs . mkdir ( siteAssets , function ( ) { return moveQuillAssets ( ) ; } ) ; } wrench . copyDirRecursive ( themeAssets , siteAssets , function ( ) { util . log ( "Successfully copied assets" ) ; moveQuillAssets ( ) ; } ) ; } ) ; }
function ( err , data ) { if ( err ) return res . send ( err , 500 ) ; cache . template = data ; cache [ req . headers . host ] = data . replace ( /\/\*\*HOST\*\*\//g , req . headers . host ) ; res . send ( cache [ req . headers . host ] , { 'content-type' : 'text/javascript' } ) ; }
function ( ) { this . passwordChangePanel = Ext . create ( "PartKeepr.UserPasswordChangePanel" ) ; this . tipsPanel = Ext . create ( "PartKeepr.TipOfTheDayPreferencesPanel" ) ; this . formattingPanel = Ext . create ( "PartKeepr.FormattingPreferencesPanel" ) ; this . categoryTreePanel = Ext . create ( "PartKeepr.CategoryTreePreferencesPanel" ) ; this . stockPanel = Ext . create ( "PartKeepr.StockPreferencesPanel" ) ; this . items = [ this . tipsPanel , this . formattingPanel , this . categoryTreePanel , this . passwordChangePanel , this . stockPanel ] ; this . callParent ( ) ; }
function ( file ) { var params = Url . parseURLParams ( file . href ) ; var url = "" ; for ( var i = 0 ; i < params . length ; i ++ ) { var result = params . map ( function ( o ) { return o . name + ": " + o . value ; } ) ; } System . copyToClipboard ( result . join ( "\n" ) ) ; }
function submitbutton3 ( pressbutton ) { var form = $ ( 'adminForm' ) ; if ( form . install_directory . value === "" ) { alert ( "<?php echo JText::_( 'NO_DIRECTORY'); ?>" ) ; } else { form . installtype . value = 'folder' ; form . submit ( ) ; } }
function ( title , lang ) { return app . makeAPIRequest ( { action : 'mobileview' , page : title , redirects : 'yes' , prop : 'sections|text' , sections : 'all' , sectionprop : 'level|line' , noheadings : 'yes' } , lang , { converters : { 'json wpage' : function ( data ) { return Page . fromRawJSON ( title , data , lang ) ; } } } ) ; }
function ( ctx ) { var result ; if ( ctx . mechanicsCtx . headers != null ) { result = ctx . mechanicsCtx . headers . auth ; } else if ( ctx . mechanicsCtx . req != null ) { if ( ctx . mechanicsCtx . req . cookies != null ) { result = ctx . mechanicsCtx . req . cookies . auth ; } } return result ; }
function ( newCfg , callback ) { cfg = newCfg ; if ( ! ( 'publicKey' in cfg ) ) { payswarm . createKeyPair ( { keySize : 1024 } , function ( err , pair ) { cfg . publicKey = { } ; cfg . publicKey . publicKeyPem = pair . publicKey ; cfg . publicKey . privateKeyPem = pair . privateKey ; config . writeConfigFile ( cfgFile , cfg , callback ) ; } ) ; } else { callback ( ) ; } }
function ( ) { var billboards = new Cesium . BillboardCollection ( undefined ) ; var textureAtlas = scene . getContext ( ) . createTextureAtlas ( { image : image } ) ; billboards . setTextureAtlas ( textureAtlas ) ; billboards . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , imageIndex : 0 } ) ; primitives . add ( billboards ) ; }
function ( ) { var c = new Cartographic3 ( ) ; expect ( c . longitude ) . toEqual ( 0 ) ; expect ( c . latitude ) . toEqual ( 0 ) ; expect ( c . height ) . toEqual ( 0 ) ; }
function ( ) { var c = new Cartographic3 ( 1 , 2 ) ; expect ( c . longitude ) . toEqual ( 1 ) ; expect ( c . latitude ) . toEqual ( 2 ) ; expect ( c . height ) . toEqual ( 0 ) ; }
function ( ) { var polyline = new Cesium . Polyline ( undefined ) ; polyline . setPositions ( Cesium . Shapes . computeCircleBoundary ( ellipsoid , ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , 300000.0 ) ) ; primitives . add ( polyline ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( Cesium . Shapes . computeCircleBoundary ( ellipsoid , ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , 300000.0 ) ) ; primitives . add ( polygon ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( Cesium . Shapes . computeCircleBoundary ( ellipsoid , ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , 300000.0 ) ) ; polygon . material = new Cesium . TieDyeMaterial ( undefined ) ; primitives . add ( polygon ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( Cesium . Shapes . computeEllipseBoundary ( ellipsoid , ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , 500000.0 , 300000.0 , Cesium . Math . toRadians ( 60 ) ) ) ; primitives . add ( polygon ) ; }
function ( ) { var c = CesiumMath . cartographic2ToRadians ( new Cartographic2 ( 180.0 , 360.0 ) ) ; expect ( c . longitude ) . toEqual ( Math . PI ) ; expect ( c . latitude ) . toEqual ( 2.0 * Math . PI ) ; }
function ( ) { var c = CesiumMath . cartographic2ToDegrees ( new Cartographic2 ( Math . PI , 2.0 * Math . PI ) ) ; expect ( c . longitude ) . toEqual ( 180.0 ) ; expect ( c . latitude ) . toEqual ( 360.0 ) ; }
function ( ) { var transform = Transforms . eastNorthUpToFixedFrame ( Ellipsoid . UNIT_SPHERE . cartographicDegreesToCartesian ( new Cartographic2 ( - 76.0 , 40.0 ) ) ) ; csc . setReferenceFrame ( transform , Ellipsoid . UNIT_SPHERE ) ; expect ( csc . getEllipsoid ( ) ) . toEqual ( Ellipsoid . UNIT_SPHERE ) ; expect ( camera . transform . equals ( transform ) ) . toEqual ( true ) ; }
function ( ) { var labels = new Cesium . LabelCollection ( undefined ) ; labels . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.10 , 39.57 ) ) , text : 'Philadelphia' } ) ; primitives . add ( labels ) ; }
function ( ) { var labels = new Cesium . LabelCollection ( undefined ) ; var l = labels . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.10 , 39.57 ) ) , text : 'Philadelphia' } ) ; l . setPosition ( ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic3 ( - 75.10 , 39.57 , 300000.0 ) ) ) ; l . setScale ( 2.0 ) ; primitives . add ( labels ) ; }
function ( movement ) { var p = scene . pickEllipsoid ( movement . endPosition , ellipsoid ) ; if ( p ) { var d = Cesium . Math . cartographic2ToDegrees ( ellipsoid . toCartographic2 ( p ) ) ; label . setShow ( true ) ; label . setText ( '(' + d . longitude . toFixed ( 2 ) + ', ' + d . latitude . toFixed ( 2 ) + ')' ) ; label . setPosition ( p ) ; } else { label . setText ( '' ) ; } }
function ( ) { var billboards = new Cesium . BillboardCollection ( undefined ) ; var textureAtlas = scene . getContext ( ) . createTextureAtlas ( { image : image } ) ; billboards . setTextureAtlas ( textureAtlas ) ; billboard = billboards . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , imageIndex : 0 } ) ; primitives . add ( billboards ) ; }
function ( ) { var billboards = new Cesium . BillboardCollection ( undefined ) ; var textureAtlas = scene . getContext ( ) . createTextureAtlas ( { image : image } ) ; billboards . setTextureAtlas ( textureAtlas ) ; billboard = billboards . add ( { position : ellipsoid . cartographicDegreesToCartesian ( new Cesium . Cartographic2 ( - 75.59777 , 40.03883 ) ) , imageIndex : 0 } ) ; billboard . highlighted = true ; primitives . add ( billboards ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 72.0 , 40.0 ) , new Cesium . Cartographic2 ( - 70.0 , 35.0 ) , new Cesium . Cartographic2 ( - 75.0 , 30.0 ) , new Cesium . Cartographic2 ( - 70.0 , 30.0 ) , new Cesium . Cartographic2 ( - 68.0 , 40.0 ) ] ) ) ; primitives . add ( polygon ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 80.0 , 30.0 ) , new Cesium . Cartographic2 ( - 70.0 , 30.0 ) , new Cesium . Cartographic2 ( - 70.0 , 40.0 ) , new Cesium . Cartographic2 ( - 80.0 , 40.0 ) ] ) ) ; polygon . material = new Cesium . VerticalStripeMaterial ( { repeat : 5.0 } ) ; primitives . add ( polygon ) ; }
function ( ) { var polygon = new Cesium . Polygon ( undefined ) ; polygon . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 80.0 , 30.0 ) , new Cesium . Cartographic2 ( - 70.0 , 30.0 ) , new Cesium . Cartographic2 ( - 70.0 , 40.0 ) , new Cesium . Cartographic2 ( - 80.0 , 40.0 ) ] ) ) ; polygon . material = new Cesium . BlobMaterial ( { repeat : 10.0 } ) ; primitives . add ( polygon ) ; }
function ( ) { var polyline = new Cesium . Polyline ( undefined ) ; polyline . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 75.10 , 39.57 ) , new Cesium . Cartographic2 ( - 80.12 , 25.46 ) ] ) ) ; primitives . add ( polyline ) ; }
function ( ) { var polyline = new Cesium . Polyline ( undefined ) ; polyline . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 75.10 , 39.57 ) , new Cesium . Cartographic2 ( - 77.02 , 38.53 ) , new Cesium . Cartographic2 ( - 80.50 , 35.14 ) , new Cesium . Cartographic2 ( - 80.12 , 25.46 ) ] ) ) ; primitives . add ( polyline ) ; }
function ( ) { var polyline = new Cesium . Polyline ( undefined ) ; polyline . setPositions ( ellipsoid . cartographicDegreesToCartesians ( [ new Cesium . Cartographic2 ( - 75.10 , 39.57 ) , new Cesium . Cartographic2 ( - 80.12 , 25.46 ) ] ) ) ; polyline . width = 5 ; polyline . outlineWidth = 10 ; primitives . add ( polyline ) ; }
function ( ) { if ( ! me . sys . useNativeAnimFrame && me . sys . pauseOnBlur && ( _state != obj . LOADING ) ) { obj . resume ( true ) ; me . game . repaint ( ) ; } if ( obj . onResume ) obj . onResume ( ) ; }
function ( ) { this . PreviousFrameTime = this . CurrentFrameTime ; this . CurrentFrameTime = ( new Date ( ) ) . getTime ( ) - this . TimeOffset ; for ( EventHandlerName in this . EventHandlerList ) { this . EventHandlerList [ EventHandlerName ] ( this ) ; } }
function ( ) { return "Offset: " + this . TimeOffset + "<br>Current frame time: " + this . CurrentFrameTime + "<br>Elapsed time: " + this . getElapsedTime ( ) ; }
function testDialogReadOnly ( field ) { var before = blackberry . ui . dialog [ field ] ; blackberry . ui . dialog [ field ] = - 1 ; expect ( blackberry . ui . dialog [ field ] ) . toEqual ( before ) ; }
function ( ) { var buttons = [ "Hello" , "World" ] , settings = { title : "Dialog" , size : blackberry . ui . dialog . SIZE_LARGE , position : blackberry . ui . dialog . CENTER } , callback = jasmine . createSpy ( ) ; blackberry . ui . dialog . customAskAsync ( "Click the button, this dialog is not a global dialog and should have two buttons, click the pass button to proceed" , buttons , dialogCallback , settings ) ; waitsFor ( function ( ) { return checkForCallback ( callback ) ; } , "dialog callback was never called" , 10000 ) ; }
function ( value ) { var threshold = 14 , formattedValue = this . formatValue ( value ) , result = ( formattedValue > threshold ) || ( this . fieldValue && this . fieldValue <= threshold ) ; this . fieldValue = value ; return result ; }
function ( value , metaData , record , rowIndex , colIndex , store ) { metaData . css += ' x-grid3-check-col-td' ; return String . format ( '<div class="x-grid3-check-col{0}" style="background-position:10px center;">&#160;</div>' , value ? '-on' : '' ) ; }
function Setup ( ) { var currcolor = rndInt ( 0 , TeamColors . length - 1 ) ; for ( var i = 0 ; i <= NUM_TEAMS - 1 ; i ++ , currcolor = ( currcolor + 1 ) % TeamColors . length ) Teams [ i ] = new Team ( TeamColors [ currcolor ] , getName ( 4 , 7 , null , null ) ) ; Bullets . init ( ) ; Smokes . init ( ) ; Explosions . init ( ) ; }
function _setImage ( image ) { _imageWidth = image . width ; _imageHeight = image . height ; _canvas . setAttribute ( 'width' , _imageWidth ) ; _canvas . setAttribute ( 'height' , _imageHeight ) ; _clipObj . w = _imageWidth ; _clipObj . h = _imageHeight ; _context . drawImage ( image , 0 , 0 , _imageWidth , _imageHeight ) ; _bitmapData = _context . getImageData ( 0 , 0 , _imageWidth , _imageHeight ) ; _originalBitmapData = _cloneBitmapData ( _bitmapData ) ; }
function _getBitmapData ( ) { return _bitmapData ; }
function ( ) { geo . watchPosition ( s , e ) ; expect ( window . setInterval ) . toHaveBeenCalledWith ( jasmine . any ( Function ) , Infinity ) ; }
function ( t ) { t . plan ( 1 ) ; var src = browserify ( { exports : [ 'require' , 'process' ] } ) . addEntry ( __dirname + '/export/entry.js' ) . bundle ( ) ; var c = { } ; vm . runInNewContext ( src , c ) ; t . same ( Object . keys ( c ) , [ 'require' , 'process' ] ) ; }
function ( e ) { var width = $ ( window ) . width ( ) ; if ( width <= 719 && ! Tabzilla . smallMode ) { Tabzilla . enterSmallMode ( ) ; } if ( width > 719 && Tabzilla . smallMode ) { Tabzilla . leaveSmallMode ( ) ; } }
function ( ) { var width = this . domRoot . innerWidth ( ) , height = this . domRoot . innerHeight ( ) , factor = Ori . gfxProfile . resolution ; this . currentCamera . setAspect ( width / height ) ; this . canvas . setSize ( width * factor , height * factor ) ; }
function ( ) { happy = true ; result = response . parseResponse ( timings , reqStart , args , res , bufs ) ; putInCache ( key , cache , result , res , expires ) ; response . exec ( timings , reqStart , args , uniqueId , res , start , result , options ) ; }
function ( ) { if ( zipped ) { unzip . end ( ) ; } else { result = response . parseResponse ( timings , reqStart , args , res , bufs ) ; putInCache ( key , cache , result , res , expires ) ; response . exec ( timings , reqStart , args , uniqueId , res , start , result , options , status ) ; } }
function ( err , stdout , stderr ) { if ( err ) { res . json ( err , 404 ) ; } else if ( stderr ) { res . json ( stderr , 404 ) ; } else { res . setHeader ( 'Expires' , new Date ( Date . now ( ) + 604800000 ) ) ; stdout . pipe ( res ) ; } }
function ( ) { var defaults = { projectPath : _getDefaultProjectPath ( ) , projectTreeState : "" } ; _prefs = PreferencesManager . getPreferenceStorage ( PREFERENCES_CLIENT_ID , defaults ) ; $ ( FileViewController ) . on ( "documentSelectionFocusChange" , _documentSelectionFocusChange ) ; $ ( "#open-files-container" ) . on ( "contentChanged" , function ( ) { _redraw ( false ) ; } ) ; CommandManager . register ( Strings . CMD_OPEN_FOLDER , Commands . FILE_OPEN_FOLDER , openProject ) ; }
function ( ) { that . dom . scroller . scrollTop = that . dom . grid . left . liner . scrollTop ; if ( that . s . iRightColumns > 0 ) { that . dom . grid . right . liner . scrollTop = that . dom . grid . left . liner . scrollTop ; } }
function ( ) { that . dom . scroller . scrollTop = that . dom . grid . right . liner . scrollTop ; if ( that . s . iLeftColumns > 0 ) { that . dom . grid . left . liner . scrollTop = that . dom . grid . right . liner . scrollTop ; } }
function ( e ) { e = hui . event ( e ) ; var a = e . findByTag ( 'a' ) ; if ( a ) { this . goToPage ( parseInt ( a . getAttribute ( 'data' ) ) ) ; } }
function ( ) { this . label . opacity = 255 ; Tweener . addTween ( this . label , { opacity : 0 , time : DASH_ITEM_LABEL_HIDE_TIME , transition : 'easeOutQuad' , onComplete : Lang . bind ( this , function ( ) { this . label . hide ( ) ; } ) } ) ; }
function ( ) { $html . setStyle ( 'overflow' , '' ) ; $html . off ( 'keydown.deatilsPanel, mousedown.deatilsPanel' ) ; window . off ( 'resize.deatilsPanel' ) ; }
function ( fxRenderer , delay , duration , timingFunction ) { fxRenderer . delay = delay ; fxRenderer . duration = duration ; fxRenderer . timingFunction = getTimingFunction ( timingFunction ) ; fxRenderer . status = BEFORE_STARTING_POINT ; this . clips . push ( fxRenderer ) ; this . duration = Math . max ( this . duration , delay + duration ) ; return this ; }
function ( ) { var animation = this ; if ( animation . status !== STARTING_POINT ) { animation . timePoint = 0 ; animation . status = STARTING_POINT ; animation . clips . forEach ( function ( clip ) { clip . status = BEFORE_STARTING_POINT ; } ) ; if ( animation . timestamp ) { unmountAnimation ( animation ) ; } animation . fire ( 'stop' ) ; } return animation ; }
function ( queue ) { queue . currentAnimation = queue . shift ( ) . on ( 'playfinish' , function ( ) { if ( queue . length ) { playQueue ( queue ) ; } else { delete queuePool [ queue . id ] ; } } ) . play ( ) ; }
function ( uid , animation ) { var queue = queuePool [ uid ] ; if ( ! queue ) { queue = queuePool [ uid ] = [ ] ; queue . id = uid ; } queue . push ( animation ) ; if ( ! queue . currentAnimation ) { playQueue ( queue ) ; } }
function ( e ) { chrome . extension . sendRequest ( { action : "display_message" , message : "Your advertisement views are now counting towards " + $ ( this ) . attr ( 'data-name' ) + "." , time : 2500 } , function ( response ) { noty ( response . formated_message ) ; } ) ; chrome . extension . sendRequest ( { action : "set_charity" , "charity" : $ ( this ) . attr ( 'data-cid' ) , "name" : $ ( this ) . attr ( 'data-name' ) } ) ; update_current_charity ( ) ; }
function ( event , ui ) { $ ( this ) . removeClass ( 'a4c_idle' ) ; }
function getNargs ( ast , n ) { if ( n === 0 ) { return Nil ; } else { return cons ( Parse . getLambdaVar ( ast ) , getNargs ( Parse . getLambdaBody ( ast ) , n - 1 ) ) ; } }
function ( env , cont ) { if ( msg ( ) !== _nil ( ) ) env . write ( "" + ( msg ( ) ) + "\n" ) ; return cont ( _false ( ) ) ; }
function concatList ( l ) { if ( l === _nil ( ) ) { return "" ; } else { return ( head ( l ) ) + concatList ( tail ( l ) ) ; } }
function startup ( evt ) { window . removeEventListener ( 'localized' , startup ) ; NavbarManager . init ( ) ; KeypadManager . init ( ) ; document . documentElement . lang = navigator . mozL10n . language . code ; document . documentElement . dir = navigator . mozL10n . language . direction ; document . body . classList . remove ( 'hidden' ) ; }
function ( i ) { comment = tpl ( { useravatar : data [ i ] . user . avatar_url , username : data [ i ] . user . login , url : data [ i ] . user . url . split ( 'users/' ) [ 1 ] , content : data [ i ] . body_html , date : formatDate ( data [ i ] . created_at ) , commenturl : data [ i ] . url , classname : clsname } ) ; listing . innerHTML += comment ; }
function ( i ) { comment = tpl ( { useravatar : data [ i ] . user . avatar_url , username : data [ i ] . user . login , url : data [ i ] . user . url . split ( 'users/' ) [ 1 ] , content : data [ i ] . body_html , date : formatDate ( data [ i ] . created_at ) , commenturl : data [ i ] . url , classname : clsname } ) ; listing . innerHTML += comment ; }
function ( ) { var content ; content = this . content [ 0 ] ; this . maxScrollTop = content . scrollHeight - content . clientHeight ; this . contentScrollTop = content . scrollTop ; this . maxSliderTop = this . paneOuterHeight - this . sliderHeight ; this . sliderTop = this . contentScrollTop * this . maxSliderTop / this . maxScrollTop ; }
function ( index , Element ) { if ( $ ( this ) . val ( ) != '' ) { ranked . push ( $ ( this ) . val ( ) ) ; htmloption = $ ( "#htmlblock-" + qID + '-' + $ ( this ) . val ( ) ) . html ( ) ; var liCode = '<li class="ui-widget-content choice" id="choice_' + $ ( this ) . val ( ) + '">' + htmloption + '</li>' $ ( liCode ) . appendTo ( '#sortable-rank-' + qID + '' ) ; } }
function ( index , Element ) { var thisvalue = $ ( this ) . val ( ) ; if ( thisvalue != '' && jQuery . inArray ( thisvalue , ranked ) < 0 ) { htmloption = $ ( "#htmlblock-" + qID + '-' + $ ( this ) . val ( ) ) . html ( ) ; var liCode = '<li class="ui-widget-content choice" id="choice_' + $ ( this ) . val ( ) + '">' + htmloption + '</li>' $ ( liCode ) . appendTo ( '#sortable-choice-' + qID + '' ) ; } }
function ( event , ui ) { maxanswers = parseInt ( $ ( "#ranking-" + qID + "-maxans" ) . text ( ) , 10 ) ; if ( $ ( this ) . attr ( "id" ) == 'sortable-rank-' + qID && $ ( maxanswers > 0 && '#sortable-rank-' + qID + ' li' ) . length > maxanswers ) { sortableAlert ( qID , showpopups ) ; $ ( ui . sender ) . sortable ( 'cancel' ) ; } }
function performSearch ( ) { var params = { term : ( jQuery ( '#keyword' ) . val ( ) ) , country : 'US' , media : 'music' , entity : 'song' , limit : 12 , callback : 'handleTunesSearchResults' } ; var params = urlEncode ( params ) ; var url = 'http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/wa/wsSearch?' + params ; var html = '<script src="' + url + '"><\/script>' ; jQuery ( 'head' ) . append ( html ) ; }
function performSearch1 ( ) { var params = { term : ( jQuery ( '#keyword1' ) . val ( ) ) , country : 'US' , media : 'music' , entity : 'song' , limit : 12 , callback : 'handleTunesSearchResults1' } ; var params = urlEncode ( params ) ; var url = 'http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/wa/wsSearch?' + params ; var html = '<script src="' + url + '"><\/script>' ; jQuery ( 'head' ) . append ( html ) ; }
function performSearch2 ( ) { var params = { term : ( jQuery ( '#keyword2' ) . val ( ) ) , country : 'US' , media : 'music' , entity : 'song' , limit : 12 , callback : 'handleTunesSearchResults2' } ; var params = urlEncode ( params ) ; var url = 'http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/wa/wsSearch?' + params ; var html = '<script src="' + url + '"><\/script>' ; jQuery ( 'head' ) . append ( html ) ; }
function performSearch3 ( ) { var params = { term : ( jQuery ( '#keyword3' ) . val ( ) ) , country : 'US' , media : 'music' , entity : 'song' , limit : 12 , callback : 'handleTunesSearchResults3' } ; var params = urlEncode ( params ) ; var url = 'http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/wa/wsSearch?' + params ; var html = '<script src="' + url + '"><\/script>' ; jQuery ( 'head' ) . append ( html ) ; }
function performSearch4 ( ) { var params = { term : ( jQuery ( '#keyword4' ) . val ( ) ) , country : 'US' , media : 'music' , entity : 'song' , limit : 12 , callback : 'handleTunesSearchResults4' } ; var params = urlEncode ( params ) ; var url = 'http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/wa/wsSearch?' + params ; var html = '<script src="' + url + '"><\/script>' ; jQuery ( 'head' ) . append ( html ) ; }
function ( jQuerySelection , parent , child ) { console . log ( "WHYYY" ) ; if ( jQuerySelection . hasClass ( "Numbers" ) && jQuerySelection . children ( ) . length === 0 ) { addClickableLiteralBoxHelper ( jQuerySelection , new ExprNumber ( ) , parent , child ) ; } else if ( jQuerySelection . hasClass ( "Strings" ) ) { addClickableLiteralBoxHelper ( jQuerySelection , new ExprString ( ) , parent , child ) ; } }
function ( pokemon ) { if ( pokemon . hasType ( 'Flying' ) ) { if ( typeof pokemon . types [ 1 ] === 'undefined' ) { pokemon . types = [ 'Normal' ] ; } else if ( pokemon . types [ 0 ] === 'Flying' ) { pokemon . types = [ pokemon . types [ 1 ] ] ; } else { pokemon . types = [ pokemon . types [ 0 ] ] ; } } }
function ( event ) { console . debug ( "SERVER>" + event . data ) ; var d = JSON . parse ( event . data ) ; if ( d . type === "player.kickout" ) { gameIsOn = false ; alert ( "You have been kicked on in this window : " + d . args [ 0 ] ) ; } }
function ( req , res , next ) { var user = req . session . oauthUser ; res . writeHeader ( 200 , { 'Content-Type' : 'text/html' } ) ; if ( ! user ) { res . end ( '<a href="/login?type=weibo">Login</a> first, please.' ) ; return ; } res . end ( 'Hello, <a href="' + user . t_url + '" target="_blank">@' + user . screen_name + '</a>. ' + '<a href="/logout">Logout</a>' ) ; }
function get_referer ( req , options ) { var referer = req . headers [ 'referer' ] || '/' ; if ( referer . indexOf ( options . login_path ) === 0 || referer . indexOf ( options . logout_path ) === 0 ) { referer = '/' ; } return referer ; }
function ( error , t_user ) { if ( error ) { return next ( error ) ; } for ( var k in auth_user ) { t_user [ k ] = auth_user [ k ] ; } req . session . oauthUser = t_user ; redirect ( res , referer ) ; }
function ( error , auth_user ) { if ( error ) { return next ( error ) ; } tapi . verify_credentials ( auth_user , function ( error , t_user ) { if ( error ) { return next ( error ) ; } for ( var k in auth_user ) { t_user [ k ] = auth_user [ k ] ; } req . session . oauthUser = t_user ; redirect ( res , referer ) ; } ) ; }
function fixed ( t , r , s , result ) { result = result || new M4 ( matrix4 . identity ) ; if ( t ) { translate ( t , result ) ; } if ( r ) { rotate ( r , result ) ; } if ( s ) { scale ( s , result ) ; } return result ; }
function computeLocalMatrix ( ) { if ( this . _cachedLocalMatrixIsValid ) { return this . _cachedLocalMatrix ; } else { math . transform . fixed ( this . position . buffer , this . rotation . buffer , this . scale . buffer , this . _cachedLocalMatrix . buffer ) ; this . _cachedLocalMatrixIsValid = true ; return this . _cachedLocalMatrix ; } }
function onUpdate ( event ) { var position2 = this . box2dBody . GetPosition ( ) ; var angle2 = this . box2dBody . GetAngle ( ) ; var transform = this . owner . findComponent ( "Transform" ) ; transform . setPosition ( math . Vector3 ( position2 . get_x ( ) , position2 . get_y ( ) , transform . position [ 2 ] ) ) ; transform . setRotation ( math . Vector3 ( transform . rotation . x , transform . rotation . y , angle2 ) ) ; }
function ( ) { if ( this . $root == this ) return ; var parent = this . $parent ; this . $broadcast ( '$destroy' ) ; if ( parent . $$childHead == this ) parent . $$childHead = this . $$nextSibling ; if ( parent . $$childTail == this ) parent . $$childTail = this . $$prevSibling ; if ( this . $$prevSibling ) this . $$prevSibling . $$nextSibling = this . $$nextSibling ; if ( this . $$nextSibling ) this . $$nextSibling . $$prevSibling = this . $$prevSibling ; }
function ( expr ) { try { flagPhase ( this , '$apply' ) ; return this . $eval ( expr ) ; } catch ( e ) { $exceptionHandler ( e ) ; } finally { this . $root . $$phase = null ; this . $root . $digest ( ) ; } }
function ( $rootScope ) { $rootScope . $watch ( 'a' , function ( ) { $rootScope . b ++ ; } ) ; $rootScope . $watch ( 'b' , function ( ) { $rootScope . a ++ ; } ) ; $rootScope . a = $rootScope . b = 0 ; expect ( function ( ) { $rootScope . $digest ( ) ; } ) . toThrow ( '100 $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: ' + '[["a; newVal: 96; oldVal: 95","b; newVal: 97; oldVal: 96"],' + '["a; newVal: 97; oldVal: 96","b; newVal: 98; oldVal: 97"],' + '["a; newVal: 98; oldVal: 97","b; newVal: 99; oldVal: 98"],' + '["a; newVal: 99; oldVal: 98","b; newVal: 100; oldVal: 99"],' + '["a; newVal: 100; oldVal: 99","b; newVal: 101; oldVal: 100"]]' ) ; }
function ( ) { var interactive = getCachedInteractiveScript ( ) ; if ( ! interactive || ! interactive . src || /steal\.(production|production\.[a-zA-Z0-9\-\.\_]*)*js/ . test ( interactive . src ) ) { return ; } var src = interactive . src ; if ( ! interactives [ src ] ) { interactives [ src ] = [ ] } if ( src ) { interactives [ src ] . push . apply ( interactives [ src ] , pending ) ; pending = [ ] ; } }
function ( stel ) { var src = stel . options . src , interactiveSrc = getCachedInteractiveScript ( ) . src ; interactives [ src ] = interactives [ interactiveSrc ] ; interactives [ interactiveSrc ] = null ; }
function ( done ) { this . model . bind ( 'validated' , function ( valid , model , attr ) { refute ( valid ) ; assert . same ( this . model , model ) ; assert . equals ( [ 'age' ] , attr ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 } ) ; }
function ( done ) { this . model . bind ( 'validated:invalid' , function ( model , attr ) { assert . same ( this . model , model ) ; assert . equals ( [ 'age' ] , attr ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 } ) ; }
function ( done ) { this . model . bind ( 'error' , function ( model , error ) { assert . same ( this . model , model ) ; assert . equals ( [ 'age' ] , error ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 } ) ; }
function ( done ) { this . model . bind ( 'validated' , function ( valid , model , attrs ) { refute ( valid ) ; assert . same ( this . model , model ) ; assert . equals ( [ 'age' , 'name' ] , attrs ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 , name : '' } ) ; }
function ( done ) { this . model . bind ( 'validated:invalid' , function ( model , attrs ) { assert . same ( this . model , model ) ; assert . equals ( [ 'age' , 'name' ] , attrs ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 , name : '' } , this ) ; }
function ( done ) { this . model . bind ( 'error' , function ( model , error ) { assert . equals ( [ 'age' , 'name' ] , error ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 , name : '' } ) ; }
function ( ) { assert ( this . model . set ( { dependsOnName : undefined } ) ) ; this . model . set ( { name : 'name' } ) ; refute ( this . model . set ( { dependsOnName : undefined } ) ) ; }
function ( err , resp ) { try { if ( err ) throw err ; if ( resp . code !== 200 ) throw "non-200 status: " + resp . code + + " - " + resp . body ; if ( typeof resp . body !== 'string' ) throw cb ( "no response body" ) ; userdb . addCertToUserCtx ( ctx , email , resp . body ) ; cb ( ) ; } catch ( e ) { cb ( "can't certify key" + ( e ? ( ": " + e . toString ( ) ) : "" ) ) ; } }
function ( err , r ) { try { if ( err ) throw err ; if ( r . code !== 200 ) throw "non-200 status: " + r . code ; if ( ! JSON . parse ( r . body ) . status === 'okay' ) throw "verification failed with: " + r . reason ; cb ( undefined ) ; } catch ( e ) { return cb ( "can't verify: " + e . toString ( ) ) ; } }
function ( err , assertion ) { if ( err ) cb ( err ) ; else { cb ( null , { audience : obj . audience , assertion : assertion , expirationDate : expirationDate } ) ; } }
function s_removeBoundChan ( win , origin , scope ) { var arr = s_boundChans [ origin ] [ scope ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . win === win ) { arr . splice ( i , 1 ) ; } } if ( s_boundChans [ origin ] [ scope ] . length === 0 ) { delete s_boundChans [ origin ] [ scope ] } }
function s_removeBoundChan ( win , origin , scope ) { var arr = s_boundChans [ origin ] [ scope ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . win === win ) { arr . splice ( i , 1 ) ; } } if ( s_boundChans [ origin ] [ scope ] . length === 0 ) { delete s_boundChans [ origin ] [ scope ] } }
function s_removeBoundChan ( win , origin , scope ) { var arr = s_boundChans [ origin ] [ scope ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] . win === win ) { arr . splice ( i , 1 ) ; } } if ( s_boundChans [ origin ] [ scope ] . length === 0 ) { delete s_boundChans [ origin ] [ scope ] } }
function ( users , maxUsers , el ) { var percentage = users ? users / maxUsers : 0.5 , scale = users ? ( users / maxUsers + 1 ) : 1 ; el . css ( { "-webkit-transform" : "scale( " + scale + "," + scale + ")" , opacity : percentage } ) ; }
function ( channel , data ) { var pipe = this . getChannel ( channel ) ; if ( ! pipe && channel . length == 32 ) pipe = this . getPipe ( channel ) ; if ( pipe ) { var $event = typeof data == "string" ? "message" : "data" ; var args = { data : data } ; pipe . send ( $event , data ) ; } else { this . log ( "NO Channel " + channel ) ; } }
function ( key , value ) { var el = value ; el . id = key ; el . repositoryId = that . repositoryId ; el . type = 'language' ; el . url = FlagIcons . path + '/img/flags/' + el . id + '.png' ; that . languageCodes . push ( new Aloha . RepositoryDocument ( el ) ) ; }
function ( filterOn ) { if ( filterOn == true ) { $ ( '.over18' ) . hide ( ) ; } else { $ ( '.over18' ) . show ( ) ; } }
function ( ) { var self = this ; this . canvas = this . element [ 0 ] ; $ ( this . canvas ) . css ( { 'width' : this . options . width , 'height' : this . options . height , } ) ; }
function ( t ) { t = builder . selenium2 . rcPlayback . fixServerResponse ( t ) ; if ( t . length == 0 ) { return { } ; } else { try { return JSON . parse ( t ) ; } catch ( e ) { return { } ; } } }
function ( response , errorThrown ) { var err = "Server Error" ; if ( response . value && response . value . message ) { err += ": " + response . value . message ; } else { if ( errorThrown ) { err += ": " + errorThrown ; } } builder . selenium2 . rcPlayback . recordError ( err ) ; }
function ( ) { var myArray = new ko . observableArray ( [ { personName : "Bob" } , { personName : "Frank" } ] ) ; ko . setTemplateEngine ( new dummyTemplateEngine ( { itemTemplate : "The item # is <span data-bind='text: $index'></span>" } ) ) ; testNode . innerHTML = "<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection }'></div>" ; ko . applyBindings ( { myCollection : myArray } , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "the item # is <span>0</span>the item # is <span>1</span>" ) ; }
function ( ) { score += settings . points ; var aud = $ ( '<audio autoplay="autoplay"><source src="/mario.ogg" type="audio/ogg" /></audio>' ) . clone ( ) . remove ( ) coins_left -= 1 ; $ ( this ) . hide ( ) . remove ( ) settings . coin_callback ( ) if ( coins_left === 0 ) { settings . got_all_coins_callback ( score ) } }
function ( ) { score += settings . points ; var aud = $ ( '<audio autoplay="autoplay"><source src="/mario.ogg" type="audio/ogg" /></audio>' ) . clone ( ) . remove ( ) coins_left -= 1 ; $ ( this ) . hide ( ) . remove ( ) settings . coin_callback ( ) if ( coins_left === 0 ) { settings . got_all_coins_callback ( score ) } }
function ( ) { score += settings . points ; var aud = $ ( '<audio autoplay="autoplay"><source src="/mario.ogg" type="audio/ogg" /></audio>' ) . clone ( ) . remove ( ) coins_left -= 1 ; $ ( this ) . hide ( ) . remove ( ) settings . coin_callback ( ) if ( coins_left === 0 ) { settings . got_all_coins_callback ( score ) } }
function ( elm ) { prevAddDebugRender ( elm ) ; elm . __paint ( E . DEBUG_PNT , 0 , p_drawCPath ) ; elm . __paint ( E . DEBUG_PNT , 0 , p_drawAdoptedRect ) ; elm . __paint ( E . DEBUG_PNT , 0 , p_drawAdoptedPoints ) ; }
function ( p ) { if ( ! this . _started ) { return ; } this . _outstandingPaintOperations ++ ; if ( this . _adjustWidthsTimer ) { this . _adjustWidthsTimer . remove ( ) ; delete this . _adjustWidthsTimer ; } var oc = lang . hitch ( this , function ( ) { this . _outstandingPaintOperations -- ; if ( this . _outstandingPaintOperations <= 0 && ! this . _adjustWidthsTimer ) { this . _adjustWidthsTimer = this . defer ( "_adjustWidths" ) ; } } ) ; when ( p , oc , oc ) ; }
function ( ) { if ( outerElement . isActivated === true ) { outerElement . isActivated = false ; outerElement . currentXPos = outerElement . transientXPos ; outerElement . value = parseInt ( outerElement . range . value ) ; outerElement . halo . style [ '-webkit-transform' ] = 'scale(0)' ; outerElement . halo . style [ '-webkit-animation-name' ] = 'implode' ; outerElement . indicator . setAttribute ( 'class' , 'indicator' ) ; outerElement . indicator . style . background = '' ; } }
function ( evt ) { var pointView = this . getPointViewUnderMouse ( this . parentView . dataHolder , evt ) || null ; this . _pointView = pointView ; if ( ! pointView ) { return ; } this . _pointView = pointView ; pointView . mouseDown ( ) ; }
function ( err , success ) { if ( err ) { console . log ( err ) ; } sent ++ ; socket . emit ( "send" , Math . round ( sent * 100 / pending ) + "%" ) ; if ( pending === sent ) { socket . emit ( "done" ) ; delete sockets [ hash ] ; } }
function km_handleMouseDownEvent ( keyCode ) { if ( Keyboards [ _baseLayout ] . type == 'ime' && _layoutMode == LAYOUT_MODE_DEFAULT ) { this . currentEngine . click ( keyCode ) ; window . setTimeout ( _updateTargetWindowHeight , 100 ) ; return ; } window . navigator . mozKeyboard . sendKey ( 0 , keyCode ) ; if ( _isUpperCase && ! _isUpperCaseLocked && _layoutMode === LAYOUT_MODE_DEFAULT ) { _isUpperCase = false ; _draw ( _baseLayout , _currentInputType , _layoutMode , _isUpperCase ) ; } }
function DVS_destroy ( ) { this . _scripts . removeEventListener ( "select" , this . _onScriptsChange , false ) ; this . _searchbox . removeEventListener ( "select" , this . _onScriptsSearch , false ) ; this . _searchbox . removeEventListener ( "input" , this . _onScriptsSearch , false ) ; this . _searchbox . removeEventListener ( "keyup" , this . _onScriptsKeyUp , false ) ; this . _scripts = null ; this . _searchbox = null ; }
function DVB__destroyContextMenu ( aBreakpoint ) { let commandsetId = "breakpointMenuCommands-" + aBreakpoint . id ; let menupopupId = "breakpointContextMenu-" + aBreakpoint . id ; let commandset = document . getElementById ( commandsetId ) ; let menupopup = document . getElementById ( menupopupId ) ; if ( commandset ) { commandset . parentNode . removeChild ( commandset ) ; } if ( menupopup ) { menupopup . parentNode . removeChild ( menupopup ) ; } }
function ( ) { is ( breakpointsRemoved , 3 , "Should have 3 removed breakpoints." ) ; is ( gBreakpointsElement . childNodes . length , 1 , "The breakpoints pane should be empty, but showing a " + "'no breakpoints' information message." ) ; is ( gBreakpointsElement . childNodes . length , gBreakpointsElement . querySelectorAll ( ".list-item.empty" ) . length , "Found junk in the breakpoints container." ) ; finish ( ) ; }
function ( url ) { var callback = "sakai_global.documentviewer.googlemaps." + tuid ; sakai_global . documentviewer . googlemaps [ tuid ] . url = url ; if ( window [ "google" ] ) { debug . info ( "Already have google maps api calling the callback ourselves" ) ; sakai_global . documentviewer . googlemaps [ tuid ] ( ) ; } else { debug . info ( "Getting google maps api" ) ; require ( [ "http://maps.google.com/maps/api/js?sensor=false&callback=" + callback ] ) ; } }
function ( err , player ) { if ( err ) { socket . emit ( 'error' ) ; } else { socket . emit ( 'test' , { msg : "done adding player to socket" , err : err , player : player } ) ; socket . emit ( 'ready' ) ; } }
function ( err , player ) { if ( err ) { socket . emit ( 'error' ) ; } else { socket . emit ( 'test' , { playerToSocket : 'added player to socket' } ) ; player . time = data . lapTime ; player . save ( ) ; } }
function toggleRowGroup ( el ) { var tr = $ ( el ) . closest ( 'tr' ) ; var n = tr . next ( ) ; tr . toggleClass ( 'open' ) ; while ( n . length > 0 && ! n . hasClass ( 'group' ) ) { n . toggle ( ) ; n = n . next ( ) ; } }
function ( i , line ) { var div = $ ( document . createElement ( 'div' ) ) ; div . text ( line ) ; div . html ( div . html ( ) . replace ( /(https?:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%#]+)/g , '<a href="$1" target="_blank">$1</a>' ) ) ; div . appendTo ( element ) ; }
function ( pair ) { if ( ! celSlideShow_isInOverlay ( pair . key ) ) { celSlideShowStopSlideShow ( pair . key ) ; celSlideShowPausedSlideShowIds . push ( pair . key ) ; celSlideShow_getOuterWrapperElement ( pair . key ) . removeClassName ( 'celanim_slideshow_running' ) ; celSlideShow_getOuterWrapperElement ( pair . key ) . addClassName ( 'celanim_slideshow_paused' ) ; } }
function ( elemId ) { return ( typeof $ ( elemId ) . up ( '.highslide-container' ) != "undefined" ) ; }
function ( ) { var url , question ; if ( Exhibit . Persistence . _urlWithoutQuery == null ) { url = document . location . href ; question = url . indexOf ( "?" ) ; if ( question >= 0 ) { url = url . substr ( 0 , question ) ; } Exhibit . Persistence . _urlWithoutQuery = url ; } return Exhibit . Persistence . _urlWithoutQuery ; }
function ( ) { if ( _doc ) { var wrapper = _doc . getElementById ( 'HTMLCS-wrapper' ) ; if ( wrapper ) { _doc . querySelector ( 'body' ) . removeChild ( wrapper ) ; var pointerEl = pointer . pointer ; if ( pointerEl && pointerEl . parentNode ) { pointerEl . parentNode . removeChild ( pointerEl ) ; } if ( _options . closeCallback ) { _messages = _options . closeCallback . call ( this ) ; } } } }
function ( error , newNotification ) { if ( error ) { callback ( error , null ) ; } else { addedUserNotifications . push ( newNotification ) ; callback ( null , newNotification ) ; } }
function ( ) { var dropWarningEl ; if ( mouseDropWarning ) { dropWarningEl = mouseDropWarning [ 0 ] ; } avatar = $ ( options . avatarCreator ( item [ 0 ] , styles . avatar , dropWarningEl ) ) ; avatar . prop ( "id" , createAvatarId ( thatReorderer . container . id ) ) ; return avatar ; }
function ( item , newPosition ) { fluid . clear ( movedMap ) ; var movingId = fluid . allocateSimpleId ( item ) ; movedMap [ movingId ] = { oldRender : that . renderLabel ( item ) } ; }
function ( button , e , options ) { Util . logoutUser ( ) ; var logconfirm = Ext . getCmp ( 'LogoutConfirmPanelID' ) ; logconfirm . hide ( ) ; }
function ( ) { lab_num ++ ; var endOfForm = 6 ; this . getLabOrderForm ( ) . insert ( endOfForm , { xtype : 'labStore' , id : 'lab' + lab_num , width : '350px' , height : '70px' } ) ; }
function ( ) { Util . saveBasicAuthHeader ( "admin" , "Hello123" ) ; if ( ! store ) { store = Ext . create ( 'Screener.store.Doctors' ) ; } expect ( store ) . toBeTruthy ( ) waitsFor ( function ( ) { return ! store . isLoading ( ) ; } , "load never completed" , timeout ) }
function ( list , index , node , record ) { if ( ! this . showContact ) { this . showContact = Ext . create ( 'RaxaEmr.Outpatient.view.patient.more' ) ; } this . showContact . setRecord ( record ) ; this . getMain ( ) . push ( this . showContact ) ; }
function ( ) { inflate = spdy . utils . zwrap ( spdy . utils . createInflate ( ) ) ; deflate = spdy . utils . zwrap ( spdy . utils . createDeflate ( ) ) ; framer = new spdy . protocol [ 2 ] . Framer ( deflate , inflate ) ; }
function ( ) { var deflate = spdy . utils . createDeflate ( ) , inflate = spdy . utils . createInflate ( ) ; parser = new spdy . parser . create ( deflate , inflate ) ; }
function ( distance ) { distance || ( distance = 1 ) ; var index = ( this . edits ( ) [ 0 ] ? this . edits ( ) . length - distance : 0 ) ; if ( index < 0 ) index = 0 ; debugger return this . restore ( { _index : index } ) ; }
function showPage ( pageName ) { addToHistory ( pageName ) ; var $page = $ ( "#" + pageName ) ; if ( ! $page . hasClass ( 'popup-container-container' ) ) { $ ( '.page, .popup-container-container' ) . hide ( ) ; curPageName = pageName ; } $page . show ( ) ; }
function scm_turnScreenOn ( ) { if ( this . screenEnabled ) return false ; window . addEventListener ( 'devicelight' , this ) ; window . addEventListener ( 'mozfullscreenchange' , this ) ; navigator . mozPower . screenEnabled = this . screenEnabled = true ; navigator . mozPower . screenBrightness = this . _brightness ; this . screen . classList . remove ( 'screenoff' ) ; this . fireScreenChangeEvent ( ) ; return true ; }
function get_cam_alt_url ( alt_src , append_abenc ) { var url = alt_src ; if ( append_abenc && user_info_USER . length > 0 ) { url += '&ab=' + base64_encode_user_info_USER + ':' + PHP_AUTH_PW ; } return url ; }
function ( obj , next ) { if ( ! obj . id ) { if ( obj . role ) { var role = parseInt ( obj . role ) if ( role < 0 || role > 5 ) { obj . role = 5 } } else { obj . role = 5 } } next ( ) }
function ( obj , next ) { if ( obj . id ) { obj . updated_at = ( new Date ( ) ) . toJSON ( ) } else { obj . updated_at = null } next ( ) }
function ( ) { $ ( ".main-left-col" ) . height ( $ ( document ) . height ( ) ) . css ( "background" , "#333232" ) ; eva . multiform ( ) ; eva . highlightmenu ( ) ; eva . ui . init ( ) ; $ ( '.dropdown-toggle' ) . dropdown ( ) ; return false ; }
function sendAsyncEvent ( data , fn , format ) { if ( $ . type ( data ) === 'string' && data . length > 0 ) { data = data + '&app_mode=async&_txp_token=' + textpattern . _txp_token ; } else { data . app_mode = 'async' ; data . _txp_token = textpattern . _txp_token ; } format = format || 'xml' ; $ . post ( 'index.php' , data , fn , format ) ; }
function ( ) { var hand = new Hand ( ) ; if ( hand . score ( ) < 17 ) { hand . hitMe ( ) ; } return hand ; }
function changeAccessibility ( x , y , state ) { if ( ! state ) { $ ( '#cell_' + x + '_' + y ) . css ( 'opacity' , 0.3 ) ; } else { $ ( '#cell_' + x + '_' + y ) . css ( 'opacity' , 1 ) ; } }
function ( event , ui ) { count ++ ; }
function re_getDayDate ( timestamp ) { var date = new Date ( timestamp ) ; var startDate = new Date ( date . getFullYear ( ) , date . getMonth ( ) , date . getDate ( ) ) ; return startDate . getTime ( ) ; }
function updateState ( ) { switching = false ; var currentNetwork = wifiManager . connection . network ; if ( currentNetwork ) { infoBlock . textContent = _ ( 'connected' , { ssid : currentNetwork . ssid } ) ; checkbox . checked = true ; } else if ( wifiManager . enabled ) { infoBlock . textContent = _ ( 'fullStatus-disconnected' ) ; checkbox . checked = true ; } else { infoBlock . textContent = _ ( 'disabled' ) ; checkbox . checked = false ; } }
function toggleWifi ( ) { if ( switching ) return ; switching = true ; var req ; if ( wifiManager . enabled ) { gNetworkList . clear ( ) ; infoBlock . textContent = '' ; req = wifiManager . setEnabled ( false ) ; req . onsuccess = updateState ; } else { req = wifiManager . setEnabled ( true ) ; gNetworkList . clear ( true ) ; req . onsuccess = function ( ) { updateState ( ) ; gNetworkList . scan ( ) ; } } }
function close ( ) { document . body . classList . remove ( 'dialog' ) ; dialog . classList . remove ( 'active' ) ; }
function ( path , params ) { var ROOT = '' ; switch ( path ) { case 'user' : ROOT = USER_STREAM ; break ; case 'site' : ROOT = SITE_STREAM ; break ; default : ROOT = PUB_STREAM ; break ; } return this . request ( 'POST' , ROOT + path , params , true ) ; }
function ( e ) { var marginLeft = modules [ 'subredditManager' ] . shortCutsContainer . firstChild . style . marginLeft ; marginLeft = parseInt ( marginLeft . replace ( 'px' , '' ) ) ; if ( isNaN ( marginLeft ) ) marginLeft = 0 ; marginLeft += ( window . innerWidth - 380 ) ; if ( marginLeft <= 0 ) { modules [ 'subredditManager' ] . shortCutsContainer . firstChild . style . marginLeft = marginLeft + 'px' ; } }
function ( ) { if ( progress_scroll - 30 >= 0 ) { progress_scroll -= 30 ; } $ ( ".bar" ) . scrollTo ( progress_scroll , 250 , { axis : "x" } ) ; }
function WritableStream ( ) { this . writable = true ; }
function ( key , defaults , askParent ) { var value = component . config . get ( normalize ( key ) , plugin . manifest . config [ key ] ) ; return typeof value == undefined ? askParent ? component . config . get ( key , defaults ) : defaults : value ; }
function ( err , result ) { callback ( err , result ) ; }
function ( err , result ) { callback ( err , result ) ; }
function ( eid , callback ) { db . collection ( 'ext' ) . update ( { _id : db . ObjectID . createFromHexString ( eid ) } , { "$inc" : { "like" : 1 } } , function ( err ) { callback ( err ) ; } ) ; }
function ( err , result ) { callback ( err , result ) ; }
function ( el ) { return el . get ( 'completed' ) == 'completed' ; }
function ( html ) { $ ( '#uncollapse' ) . after ( html ) ; if ( start <= 0 ) $ ( '#uncollapse' ) . hide ( ) ; $ ( '#uncollapse1' ) . show ( ) ; $ ( '#uncollapse2' ) . show ( ) ; $ ( '#uncollapse3' ) . hide ( ) ; }
function onConnect ( ) { req . emit ( 'progress' , { } ) ; socket . end ( options . encodedBody ) ; socket . on ( 'drain' , onRequestDrain ) ; socket . setTimeout ( options . timeout || 120 * 1000 , function ( ) { socket . destroy ( ) ; if ( ! req . isComplete ) { req . emit ( 'timeout' , { } ) ; } else { res . emit ( 'timeout' , { } ) ; } } ) ; }
function ( ) { $ ( this ) . find ( ".info" ) . animate ( { width : '220' } ) ; }
function ( ) { $ ( this ) . find ( ".info" ) . animate ( { width : '0' } ) ; }
function ( stepID , afterStepID ) { var step = this . removeStepWithID ( stepID ) ; if ( this . getLastStep ( ) . id === afterStepID ) { this . steps . push ( step ) ; } else { this . steps . splice ( this . getStepIndexForID ( afterStepID ) + 1 , 0 , step ) ; } }
function ( newType ) { this . type = newType ; var pNames = this . type . getParamNames ( ) ; for ( var i = 0 ; i < pNames . length ; i ++ ) { if ( ! this [ pNames [ i ] ] ) { this [ pNames [ i ] ] = this . type . getParamType ( pNames [ i ] ) === "locator" ? builder . locator . empty ( ) : "" ; } } }
function ( evt , ui ) { var reorderedSteps = jQuery ( '#steps .b-step' ) . get ( ) ; var reorderedIDs = [ ] ; for ( var i = 0 ; i < reorderedSteps . length ; i ++ ) { reorderedIDs . push ( reorderedSteps [ i ] . id ) ; } builder . getScript ( ) . reorderSteps ( reorderedIDs ) ; }
function findPashua ( ) { var locations = [ process . execPath . replace ( /[^\/]*$/ , "Pashua" ) , '/Applications/Pashua.app/Contents/MacOS/Pashua' ] ; for ( var i in locations ) { var candidate = locations [ i ] ; if ( path . existsSync ( candidate ) ) { return candidate ; } } throw "Pashua not found in any of these locations: " + locations ; }
function ( err , links ) { should . exist ( err ) ; err . should . be . a ( "object" ) ; err . should . be . an . instanceOf ( RelMe . HTTPError ) ; err . should . have . property ( "code" ) ; err . code . should . equal ( 404 ) ; done ( ) ; }
function ( ) { this . _rendered = true ; var convEl = $ ( "#conversations" ) ; convEl . html ( '' ) ; var self = this ; this . convsList . each ( function ( conv ) { self . addConversationBasicEffect ( conv ) ; } ) ; }
function ( ) { _ . bindAll ( this , 'render' , 'appendWorkingPoint' , 'phoneNumbersPoolChanged' , 'getWorkingPoints' ) ; this . phoneNumbersPool = new PhoneNumbersPool ( ) ; checkedPhoneNumbers = this . phoneNumbersPool ; this . phoneNumbersPool . bind ( "add" , this . appendWorkingPoint , this ) ; this . phoneNumbersPool . bind ( "reset" , this . render ) ; }
function ( options , appId , path , name , fileType , cb ) { var payload = { app : appId , filePath : path , fileName : name , type : fileType } ; api . doFileCall ( options , "create" , payload , "Error creating file: " , cb ) ; }
function ( ) { var path , features , index = i ; var dir = $ ( /^@import(?:-(once))?\s+/ ) ; if ( dir && ( path = $ ( this . entities . quoted ) || $ ( this . entities . url ) ) ) { features = $ ( this . mediaFeatures ) ; if ( $ ( ';' ) ) { return new ( tree . Import ) ( path , imports , features , ( dir [ 1 ] === 'once' ) , index ) ; } } }
function ( ) { var tagName = this . element . extends ; var created = this . created ; var extended = function ( ) { var element = document . createElement ( tagName ) ; extended . prototype . __proto__ = element . __proto__ ; element . __proto__ = extended . prototype ; created . call ( element ) ; } extended . prototype = this . elementPrototype ; return extended ; }
function ( element ) { if ( ! this . template ) { return ; } var shadowRoot = new WebKitShadowRoot ( element ) ; shadowRoot . host = element ; [ ] . forEach . call ( this . template . childNodes , function ( node ) { shadowRoot . appendChild ( node . cloneNode ( true ) ) ; } ) ; return shadowRoot ; }
function onDown ( e ) { if ( killTimeout ( ) ) { return ; } _downLock = true ; _d = wax . u . eventoffset ( e ) ; if ( e . type === 'mousedown' ) { bean . add ( document . body , 'mouseup' , onUp ) ; } else if ( e . type === 'touchstart' && e . touches . length === 1 ) { bean . fire ( interaction , 'off' ) ; bean . add ( parent ( ) , touchEnds ) ; } }
function ( ) { var player = _V_ ( "modal_video" ) ; playerHtml = $ ( "#modal_video_player" ) ; playerHtml . removeClass ( "hidden" ) ; player . width ( 580 ) ; player . height ( 326 ) ; player . play ( ) ; }
function ( ) { console . log ( $ ( window ) . innerWidth ( ) ) ; menuWidthCheck ( ) ; if ( ! mobile ) { menu . show ( ) ; searchBar . show ( ) ; } else { if ( changed ) { menu . hide ( ) ; searchBar . hide ( ) ; } } }
function ( $resource , appSettings ) { var actions , defaults , proj ; defaults = { applicationId : appSettings . applicationId } ; actions = { getJson : { method : 'GET' , isArray : false , params : { action : "grids" } } } ; proj = $resource ( appSettings . serverUrl + "/client/json/:applicationId/:link?callback=JSON_CALLBACK" , defaults , actions ) ; return proj ; }
function ( $scope , $routeParams , clientApi ) { var p ; p = $routeParams ; $scope . $parent . refresh ( p . link ) ; return clientApi . getJson ( { link : p . link } , function ( data ) { return $scope . data = data ; } ) ; }
function ( $resource , appSettings ) { var actions , defaults , proj ; defaults = { applicationId : appSettings . applicationId } ; actions = { getJson : { method : 'GET' , isArray : false , params : { action : "grids" } } } ; proj = $resource ( appSettings . serverUrl + "/client/json/:applicationId/:link?callback=JSON_CALLBACK" , defaults , actions ) ; return proj ; }
function ( $scope , $routeParams , clientApi ) { var p ; p = $routeParams ; $scope . $parent . refresh ( p . link ) ; return clientApi . getJson ( { link : p . link } , function ( data ) { return $scope . data = data ; } ) ; }
function ( stream ) { if ( resultStream ) { console . log ( "concating " + seg ) ; processors . cat . init ( function ( st ) { if ( ! st ) { onError ( "Cat returned unll stream" ) ; return ; } next ( ) ; } , context , resultStream , stream ) ; } else { console . log ( "initial stream: " + seg ) ; resultStream = stream ; if ( ! resultStream ) { onError ( seg + " returned null stream" ) ; return ; } } next ( ) }
function ( ) { var text = this . descriptions [ $ ( "#expense-type-select" ) . val ( ) ] ; if ( text != null ) { $ ( "#type-description" ) . html ( text ) ; } else { $ ( "#type-description" ) . html ( $ ( "#no-description-template" ) . text ( ) ) ; } }
function ( e ) { var dataId = $ ( this ) . attr ( 'data-id' ) ; $ ( '#modal-share' ) . click ( function ( m ) { $ ( this ) . find ( 'textarea' ) . val ( ) $ . post ( ) } ) $ ( '#modal-share' ) . modal ( { } ) }
function ( ) { try { $ ( "#js" ) . val ( "" ) ; $ ( "#js" ) . val ( translator . toJS ( $ ( "#grass" ) . val ( ) ) ) ; } catch ( e ) { alert ( e ) ; } }
function ( ) { var originalDocumentWrite = document . write ; try { $ ( "#stdout" ) . val ( "" ) ; document . write = function ( string ) { $ ( "#stdout" ) . val ( $ ( "#stdout" ) . val ( ) + string ) ; } ; eval ( $ ( "#js" ) . val ( ) ) ; } catch ( e ) { alert ( e ) ; } finally { document . write = originalDocumentWrite ; } }
function ( resp , entryInfo , deleteLink , eText ) { if ( ! resp ) { alert ( 'Berta says, there was a server error while deleting this entry! Something has gone sooooo wrong...' ) ; } else if ( resp && ! resp . error_message ) { this . unlinearProcess_stop ( processId ) ; value == 'yes' ? el . set ( 'checked' , true ) : el . set ( 'checked' , false ) ; elParent . removeClass ( 'xSavingAtLarge' ) ; } else { alert ( resp . error_message ) ; elParent . removeClass ( 'xSavingAtLarge' ) ; } }
function ( ) { var id = ed . getParam ( 'wp_fullscreen_editor_id' ) || ed . getParam ( 'fullscreen_editor_id' ) || ed . id , link = tinymce . DOM . select ( '#wp-' + id + '-media-buttons a.thickbox' ) ; if ( link && link [ 0 ] ) link = link [ 0 ] ; else return ; tb_show ( '' , link . href ) ; tinymce . DOM . setStyle ( [ 'TB_overlay' , 'TB_window' , 'TB_load' ] , 'z-index' , '999999' ) ; }
function ( err , data ) { args . attribute = 2 ; self . addNotifier ( args , function ( err , data ) { args . attribute = 3 ; self . addNotifier ( args , function ( err , data ) { callback ( null , 1 ) ; } ) ; } ) ; }
function ( args , callback ) { var self = this ; args . attribute = 1 ; self . addNotifier ( args , function ( err , data ) { args . attribute = 2 ; self . addNotifier ( args , function ( err , data ) { args . attribute = 3 ; self . addNotifier ( args , function ( err , data ) { callback ( null , 1 ) ; } ) ; } ) ; } ) ; }
function ( err , data ) { args . app = 0 ; self . addNotificationSetting ( args , function ( err , data ) { args . app = 2 ; self . addNotificationSetting ( args , function ( err , data ) { callback ( 1 ) ; } ) ; } ) ; }
function ( settings ) { if ( null === settings ) { args . app = 1 ; self . addNotificationSetting ( args , function ( err , data ) { args . app = 0 ; self . addNotificationSetting ( args , function ( err , data ) { args . app = 2 ; self . addNotificationSetting ( args , function ( err , data ) { callback ( 1 ) ; } ) ; } ) ; } ) ; } }
function ( successCb , failureCb ) { if ( ! this . isPhysical ( ) ) { var computeStore = Ext . data . StoreManager . lookup ( 'ComputesStore' ) ; var parentId = this . get ( 'url' ) . split ( '/' ) [ 2 ] ; computeStore . loadById ( parentId , successCb , failureCb ) ; } }
function ( err , data ) { if ( err ) { res . send ( 404 ) ; return ; } var type = mime . lookup ( url , 'application/octet-stream' ) ; res . contentType ( type ) ; res . send ( data ) ; }
function _onEventPause ( res ) { var eventName = res . data . eventName . substr ( 9 ) ; var trace = new Trace . Trace ( "event" , res . callFrames , eventName ) ; $exports . triggerHandler ( "eventTrace" , trace ) ; _lastEvent = res ; Inspector . Debugger . resume ( ) ; }
function _onConnect ( ) { Inspector . Debugger . enable ( ) ; for ( var i = 0 ; i < _breakEvents . length ; i ++ ) { Inspector . DOMDebugger . setEventListenerBreakpoint ( _breakEvents [ i ] ) ; } if ( ! LiveDevelopment . agents . script ) { ScriptAgent . load ( ) ; } }
function unload ( ) { Inspector . off ( "connect" , _onConnect ) ; Inspector . off ( "disconnect" , _onDisconnect ) ; Inspector . off ( "Debugger.paused" , _onPaused ) ; Inspector . off ( "Debugger.resumed" , _onResumed ) ; Inspector . off ( "Debugger.globalObjectCleared" , _onGlobalObjectCleared ) ; for ( var i = 0 ; i < _breakEvents . length ; i ++ ) { Inspector . DOMDebugger . removeEventListenerBreakpoint ( _breakEvents [ i ] ) ; } $exports . off ( ) ; _onDisconnect ( ) ; }
function ( ) { var scopeChain = callFrame . scopeChain ; for ( var i = 0 ; i < scopeChain . length ; i ++ ) { var vars = scopeChain [ i ] . resolved ; if ( vars && vars [ variable ] ) { return resolveVariable ( vars [ variable ] ) . done ( result . resolve ) ; } } result . reject ( ) ; }
function _setupTraceTree ( trace ) { if ( trace . type === "function.end" ) { _lastParent = _lastParent . parent ; return ; } if ( _lastParent ) { _lastParent . children . push ( trace ) ; trace . parent = _lastParent ; } if ( trace . type === "event" || ! _lastParent ) { _rootTraces . push ( trace ) ; } _lastParent = trace ; }
function onResumed ( event , res ) { if ( res . halt && res . location ) { var editor = _editorForLocation ( res . location ) ; if ( ! editor ) { return ; } editor . _codeMirror . setLineClass ( res . location . lineNumber ) ; } }
get linearization ( ) { var length = this . stream . length ; var linearization = false ; if ( length ) { linearization = new Linearization ( this . stream ) ; if ( linearization . length != length ) linearization = false ; } return shadow ( this , 'linearization' , linearization ) ; } ,
function ( ) { if ( ! self . $s . $feed_list . hasClass ( 'NB-feed-sorting' ) ) { var $this = $ ( this ) ; if ( $this . offset ( ) . top > $ ( window ) . height ( ) - 270 ) { $this . addClass ( 'NB-hover-inverse' ) ; } } }
function ( result ) { if ( result === "startedPZP" && self . webServerState !== global . states [ 2 ] ) { console . log ( self . webServerState ) ; pzpWebSocket . startPzpWebSocketServer ( self , config , function ( ) { self . update ( callback ) ; } ) ; } }
function checkConfiguration ( config ) { log . info ( "Your device has not been enrolled to PZH yet" ) ; console . log ( config ) ; if ( config . pzhHost === "" ) { log . error ( "pzhHost should be ip address or a domain name, by default value it is localhost" ) ; return false ; } if ( config . pzhName === "" ) { log . error ( "pzhName should not be empty, please enter your full name as it appears on PZH farm page" ) ; log . error ( "./webinos_pzp.js --auth-code=\"<code>\"  --pzh-name=\"<fullname>\"" ) ; return false ; } if ( config . code === "DEBUG" ) { log . error ( "No authorization code specified, please generate code on PZH and enter while starting PZP" ) ; log . error ( "./webinos_pzp.js --auth-code=\"<code>\"  --pzh-name=\"<fullname>\"" ) ; return false ; } return true ; }
function ( insertButton ) { var self = this ; self . $node . css ( jQuery ( insertButton ) . offset ( ) ) ; self . $node . show ( ) ; self . $node . find ( '.focused' ) . removeClass ( 'focused' ) ; jQuery ( self . $node . find ( 'td' ) [ 0 ] ) . addClass ( 'focused' ) ; }
function ( e ) { var overlayVisibleAndNotTarget = ( self . $node . css ( 'display' ) === 'table' ) && ( e . target !== self . $node [ 0 ] ) && ! jQuery ( e . target ) . is ( 'button.aloha-button-characterpicker' ) ; if ( overlayVisibleAndNotTarget ) { self . $node . hide ( ) ; } }
function ( event , data ) { var config = self . getEditableConfig ( data . editable . obj ) ; if ( jQuery . isArray ( config ) ) { config = config . join ( ' ' ) ; } if ( config ) { self . characterOverlay . setCharacters ( config ) ; self . insertButton . show ( ) ; } else { self . insertButton . hide ( ) ; } }
function ( event , options ) { if ( options . entityElement . get ( 0 ) !== element ) { return ; } options . element . effect ( 'highlight' , { color : widget . options . highlightColor } , 3000 ) ; }
function ( event , options ) { if ( options . entityElement . get ( 0 ) !== element ) { return ; } options . element . effect ( 'highlight' , { color : widget . options . highlightColor } , 3000 ) ; }
function ( ) { var m = new DatumField ( { "state" : this . $el . find ( ".add_input" ) . val ( ) , "color" : this . $el . find ( ".add_color_chooser" ) . val ( ) } ) ; this . model . get ( "datumStates" ) . add ( m ) ; }
function ( cell , date ) { var day = date . format ( "yyyy-mm-dd" ) ; var entries = dayEntries [ day ] ; if ( entries !== undefined ) { cell . addClass ( 'fc-xdate' ) ; cell . click ( function ( ) { if ( cell . hasClass ( 'fc-xdate' ) ) { showDayEntries ( entries ) ; } } ) ; } }
function ( ) { var title = this [ 'title' ] ; call = $ . ajax ( { url : this [ 'url' ] } ) ; call . done ( function ( data ) { dayContent += '<div class="post">' + '<h3>' + title + '<h3>' + '<div class="post-content">' + data + '</div>' + '</div>' ; } ) ; entry_calls . push ( call ) ; }
function ( ) { this . setIsTouchEnabled ( true ) ; var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; this . addNewSpriteWithCoords ( cc . ccp ( s . width / 2 , s . height / 2 ) ) ; }
function ( selector , interval , repeat , delay ) { interval = interval || 0 ; cc . Assert ( selector , "Argument must be non-nil" ) ; cc . Assert ( interval >= 0 , "Argument must be positive" ) ; repeat = repeat || cc . REPEAT_FOREVER ; delay = delay || 0 ; this . _scheduler . scheduleSelector ( selector , this , interval , ! this . _isRunning , repeat , delay ) ; }
function ( ) { this . _super ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . _ignoreAnchorPointForPosition = true ; var director = cc . Director . sharedDirector ( ) ; if ( ! director ) { return false ; } this . setContentSize ( director . getWinSize ( ) ) ; this . _isTouchEnabled = false ; this . _isAccelerometerEnabled = false ; }
function ( ) { this . _ignoreAnchorPointForPosition = true ; var director = cc . Director . sharedDirector ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . setContentSize ( director . getWinSize ( ) ) ; }
function ( cleanup ) { if ( this . _usesBatchNode ) { if ( this . _children != null ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { if ( this . _children [ i ] instanceof cc . Sprite ) { this . _batchNode . removeSpriteFromAtlas ( this . _children [ i ] ) ; } } } } this . _super ( cleanup ) ; this . _hasChildren = false ; }
function ( value ) { this . _dirty = this . _recursiveDirty = value ; if ( this . _children != null ) { for ( var i in this . _children ) { if ( this . _children [ i ] instanceof cc . Sprite ) { this . _children [ i ] . setDirtyRecursively ( true ) ; } } } }
function ( newFrame ) { this . setNodeDirty ( ) ; this . _unflippedOffsetPositionFromCenter = newFrame . getOffsetInPixels ( ) ; var pNewTexture = newFrame . getTexture ( ) ; if ( pNewTexture != this . _texture ) { this . setTexture ( pNewTexture ) ; } this . _rectRotated = newFrame . isRotated ( ) ; if ( this . _rectRotated ) this . setRotation ( - 90 ) ; this . setTextureRectInPixels ( newFrame . getRectInPixels ( ) , newFrame . isRotated ( ) , newFrame . getOriginalSizeInPixels ( ) ) ; }
function ( animationName , frameIndex ) { cc . Assert ( animationName , "" ) ; var a = cc . AnimationCache . sharedAnimationCache ( ) . animationByName ( animationName ) ; cc . Assert ( a , "" ) ; var frame = a . getFrames ( ) [ frameIndex ] ; cc . Assert ( frame , "" ) ; this . setDisplayFrame ( frame ) ; }
function ( ) { if ( cc . renderContextType == cc . CANVAS ) { return cc . SpriteFrame . _frameWithTextureForCanvas ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSize ) ; } else { return cc . SpriteFrame . create ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSize ) ; } }
function ( spriteFrame ) { var sprite = new cc . Sprite ( ) ; if ( sprite && sprite . initWithSpriteFrame ( spriteFrame ) ) { return sprite ; } return null ; }
function ( label , target , selector ) { var ret = new cc . MenuItemLabel ( ) ; if ( arguments . length == 3 ) { ret . initWithLabel ( label , target , selector ) ; } else { ret . initWithLabel ( label ) ; } return ret ; }
function ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) { cc . Assert ( value != null && value . length != 0 , "value length must be greater than 0" ) ; var label = new cc . LabelAtlas ( ) ; label . initWithString ( value , charMapFile , itemWidth , itemHeight , startCharMap ) ; this . initWithLabel ( label , target , selector ) ; return true ; }
function ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) { var ret = new cc . MenuItemAtlasFont ( ) ; ret . initFromString ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) ; return ret ; }
function ( NormalImage ) { if ( NormalImage ) { this . addChild ( NormalImage , 0 , cc . NORMAL_TAG ) ; NormalImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; NormalImage . setVisible ( true ) ; } if ( this . _normalImage ) { this . removeChild ( this . _normalImage , true ) ; } this . _normalImage = NormalImage ; }
function ( DisabledImage ) { if ( DisabledImage ) { this . addChild ( DisabledImage , 0 , cc . DISABLE_TAG ) ; DisabledImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; DisabledImage . setVisible ( false ) ; } if ( this . _disabledImage ) { this . removeChild ( this . _disabledImage , true ) ; } this . _disabledImage = DisabledImage ; }
function ( normalSprite , selectedSprite , disabledSprite , target , selector ) { cc . Assert ( normalSprite != null , "" ) ; this . initWithTarget ( target , selector ) ; this . setNormalImage ( normalSprite ) ; this . setSelectedImage ( selectedSprite ) ; this . setDisabledImage ( disabledSprite ) ; this . setContentSize ( this . _normalImage . getContentSize ( ) ) ; return true ; }
function ( ) { this . _super ( ) ; if ( this . _disabledImage ) { this . _disabledImage . setVisible ( false ) ; } if ( this . _selectedImage ) { this . _normalImage . setVisible ( false ) ; this . _selectedImage . setVisible ( true ) ; } else { this . _normalImage . setVisible ( true ) ; } }
function ( ) { this . _super ( ) ; this . _normalImage . setVisible ( true ) ; if ( this . _selectedImage ) { this . _selectedImage . setVisible ( false ) ; } if ( this . _disabledImage ) { this . _disabledImage . setVisible ( false ) ; } }
function ( normalSprite , selectedSprite , three , four , five ) { var ret = new cc . MenuItemSprite ( ) ; if ( five ) { ret . initFromNormalSprite ( normalSprite , selectedSprite , three , four , five ) ; } else if ( four ) { return cc . MenuItemSprite . create ( normalSprite , selectedSprite , null , three , four ) ; } else { return cc . MenuItemSprite . create ( normalSprite , selectedSprite , three , null , null ) ; } return ret ; }
function ( enabled ) { this . _super ( enabled ) ; if ( this . _subItems && this . _subItems . length > 0 ) { for ( var it = 0 ; it < this . _subItems . length ; it ++ ) { this . _subItems [ it ] . setIsEnabled ( enabled ) ; } } }
function ( ) { data = data . replace ( /(^[\r\n\s\t ]+|[\r\n\s\t ]+$)/g , '' ) data = data . match ( /^\{.*\}$/ ) ? JSON . parse ( data ) : { } cb ( data , response . headers ) }
function get_square_coords ( e ) { var x = e . hasOwnProperty ( 'offsetX' ) ? e . offsetX : e . layerX ; var y = e . hasOwnProperty ( 'offsetY' ) ? e . offsetY : e . layerY ; return { Y : Math . floor ( y / 48 ) , X : Math . floor ( x / 48 ) } ; }
function ( ) { if ( ! this . is_multiple ) { this . selected_item . removeClass ( "chzn-single-with-drop" ) ; } this . result_clear_highlight ( ) ; this . form_field_jq . trigger ( "liszt:hiding_dropdown" , { chosen : this } ) ; this . dropdown . css ( { "left" : "-9000px" , "display" : "none" } ) ; return this . results_showing = false ; }
function ( ) { mainPage . startApplication ( ) ; expect ( mainPage . displayedTasks ( ) . length ) . toBe ( 0 ) ; }
function ( ) { webPage . evaluate ( function ( ) { window . startApp ( ) ; } ) ; }
function ( event ) { $ ( this . dom ) . parent ( ) . toggleClass ( 'hidden' ) ; }
function ( record , index , rowParams , store ) { var c = record . get ( 'rolled_by' ) ; if ( c > 0 ) { return 'invisible' } var c = record . get ( 'maked' ) ; if ( c ) { return 'maked_true_class' ; } else { return 'maked_false_class' ; } }
function ( ) { var lines = defaultContent . split ( "\n" ) , len = lines . length , expectedText = '' ; lines . push ( '}' ) ; expectedText = lines . join ( "\n" ) ; myEditor . setCursorPos ( len - 1 , 1 ) ; CommandManager . execute ( Commands . EDIT_DUPLICATE , myEditor ) ; expect ( myDocument . getText ( ) ) . toEqual ( expectedText ) ; expectCursorAt ( { line : len , ch : 1 } } ) ;
function ( ev ) { console . log ( util . inspect ( ev , null , true ) ) ; console . log ( 'contract ' + ev . nce_ctid + ' empty' ) ; ct . abandon ( ) ; ct . removeAllListeners ( ) ; }
function updateGraph ( report , newSeries ) { newSeries . active = report . graph . series . active ; report . graph . series = newSeries ; try { report . graph . update ( ) ; } catch ( e ) { drawGraph ( report , newSeries ) ; report . decorateGraph ( report ) ; } }
function cursorX ( elem , evt ) { if ( isFixed ( elem ) ) { var bodyLeft = parseInt ( document . defaultView . getComputedStyle ( document . body , "" ) . marginLeft , 10 ) - calc ( elem , 'scrollLeft' ) + elem . style . marginLeft ; console . log ( elem . style ) ; return evt . clientX - bodyLeft ; } if ( evt . pageX ) return evt . pageX ; else if ( evt . clientX ) return evt . clientX + document . body . scrollLeft ; }
function updateTime ( spy ) { var timeBox = spy . logRow . getElementsByClassName ( "spyTime" ) . item ( 0 ) ; if ( spy . responseTime ) timeBox . textContent = " " + Str . formatTime ( spy . responseTime ) ; }
function ( ) { if ( ! this . defaultStringBundle ) { var chromeRegistry = Cc [ "@mozilla.org/chrome/chrome-registry;1" ] . getService ( Ci . nsIChromeRegistry ) ; var uri = Services . io . newURI ( "chrome://firebug/locale/firebug.properties" , "UTF-8" , null ) ; var fileURI = chromeRegistry . convertChromeURL ( uri ) . spec ; var parts = fileURI . split ( "/" ) ; parts [ parts . length - 2 ] = "en-US" ; this . defaultStringBundle = stringBundleService . createBundle ( parts . join ( "/" ) ) ; } return this . defaultStringBundle ; }
function loadScript ( src ) { var script = document . createElement ( "script" ) ; script . onload = function ( ) { if ( scripts . length ) { loadScript ( scripts . shift ( ) ) ; } } ; script . src = GLOBAL . relative_path + "javascript/" + src + ".js" ; console . log ( script . src ) document . body . appendChild ( script ) ; }
function ( ) { var me = this , store = me . store , proxy = store . getProxy ( ) , val ; if ( me . hasSearch ) { me . setValue ( '' ) ; proxy . extraParams [ me . paramName ] = '' ; store . currentPage = 1 ; store . load ( { start : 0 } ) ; me . hasSearch = false ; me . triggerEl . item ( 0 ) . setDisplayed ( 'none' ) ; me . doComponentLayout ( ) ; } }
function ( ) { var end = new fcgi . records . EndRequest ( 0 , fcgi . records . EndRequest . protocolStatus . REQUEST_COMPLETE ) ; fastcgiStream . writeRecord ( requestId , end ) ; closeConnection ( socket ) ; }
function p_drawGhost ( ctx ) { var me = this . $ ; if ( me . __ghost_m && ! me . __ghostLock ) { ctx . save ( ) ; me . __ghostLock = true ; me . __ghost_m . apply ( ctx ) ; ctx . globalAlpha = 0.6 ; me . draw ( ctx ) ; me . __ghostLock = false ; ctx . restore ( ) ; } }
function ( elm ) { prevAddDebugRender ( elm ) ; elm . __paint ( E . DEBUG_PNT , 0 , p_drawCPath ) ; elm . __paint ( E . DEBUG_PNT , 0 , p_drawAdoptedRect ) ; elm . __paint ( E . DEBUG_PNT , 0 , p_drawAdoptedPoints ) ; elm . __paint ( E . DEBUG_PNT , 0 , p_drawGhost ) ; elm . __paint ( E . DEBUG_PNT , 0 , p_drawGhostVec ) ; }
function ( thePostPlayCallback ) { builder . selenium1 . playback . runtestbetween ( 0 , 0 , thePostPlayCallback ) ; }
function ( func , keyGen ) { var cache = { } ; keyGen = keyGen || function ( args ) { return JSON . stringify ( args ) ; } ; return function ( ) { var args = slice . call ( arguments ) , key = keyGen ( args ) ; return ( typeof cache [ key ] === 'undefined' ) ? cache [ key ] = func ( args ) : cache [ key ] ; } ; }
function setMediaSrc ( domElement , url , kind ) { var player , $d ; $d = $ ( domElement ) ; player = $d . siblings ( kind ) . get ( 0 ) ; $ ( player ) . attr ( 'src' , url ) ; player . load ( ) ; player . play ( ) ; }
function ( ) { href = $ ( this ) . children ( "a" ) . attr ( "href" ) ; if ( href && new RegExp ( href ) . test ( url . toLowerCase ( ) ) ) { $ ( this ) . addClass ( "active" ) ; $ ( this ) . children ( "a" ) . children ( "i" ) . addClass ( "icon-white" ) ; } }
function ( ) { var self = this ; this . el = $ ( this . el ) ; _ . bindAll ( this , 'render' ) ; this . model . currentDocuments . bind ( 'add' , this . render ) ; this . model . currentDocuments . bind ( 'reset' , this . render ) ; this . model . currentDocuments . bind ( 'remove' , this . render ) ; this . state = { } ; this . hiddenFields = [ ] ; }
function ( doc ) { var tr = $ ( '<tr />' ) ; self . el . find ( 'tbody' ) . append ( tr ) ; var newView = new my . DataTableRow ( { model : doc , el : tr , fields : self . fields , } ) ; newView . render ( ) ; }
function ( ) { var doc = this . model ; var cellData = this . _fields . map ( function ( field ) { return { field : field . id , value : doc . get ( field . id ) } } ) return { id : this . id , cells : cellData } }
function Argument ( text , prefix , suffix ) { if ( text === undefined ) { this . text = '' ; this . prefix = '' ; this . suffix = '' ; } else { this . text = text ; this . prefix = prefix !== undefined ? prefix : '' ; this . suffix = suffix !== undefined ? suffix : '' ; } }
function TrueNamedArgument ( name , arg ) { this . arg = arg ; this . text = arg ? arg . text : '--' + name ; this . prefix = arg ? arg . prefix : ' ' ; this . suffix = arg ? arg . suffix : '' ; }
function NamedArgument ( nameArg , valueArg ) { this . nameArg = nameArg ; this . valueArg = valueArg ; if ( valueArg == null ) { this . text = '' ; this . prefix = nameArg . toString ( ) ; this . suffix = '' ; } else { this . text = valueArg . text ; this . prefix = nameArg . toString ( ) + valueArg . prefix ; this . suffix = valueArg . suffix ; } }
function clear ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; vv . changeEvent = { set : true } ; vv . value = [ ] ; runtime . touch ( vv ) ; }
function push ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; vv . changeEvent = { adds : [ { index : vv . value . length , howMany : arguments . length } ] } ; Array . prototype . push . apply ( vv . value , arguments ) ; runtime . touch ( vv ) ; return vv . value . length ; }
function reverse ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; vv . value . reverse ( ) ; vv . changeEvent = { set : true } ; runtime . touch ( vv ) ; }
function sort ( f ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; vv . value . sort ( f ) ; vv . changeEvent = { set : true } ; runtime . touch ( vv ) ; }
function unshift ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; vv . changeEvent = { adds : [ { index : 0 , howMany : arguments . length } ] } ; Array . prototype . unshift . apply ( vv . value , arguments ) ; runtime . touch ( vv ) ; return vv . value . length ; }
function searchStartScript ( dir ) { var scripts = [ 'server.js' , 'bin/server' , 'app.js' , 'index.js' ] ; for ( i in scripts ) { if ( path . existsSync ( path . join ( dir , scripts [ i ] ) ) ) { return scripts [ i ] ; } } }
function ( payload ) { assert ( Buffer . isBuffer ( payload ) ) ; var len = payload . length ; var packet = new Buffer ( len + 4 ) ; packet [ 0 ] = len >>> 24 ; packet [ 1 ] = len >>> 16 ; packet [ 2 ] = len >>> 8 ; packet [ 3 ] = len & 255 ; payload . copy ( packet , 4 , 0 ) ; this . socket . write ( packet ) ; }
function ( el ) { var self = this ; this . setupSidebar ( el ) ; this . setupDashlets ( el ) ; this . setupPage ( el ) ; this . subscribe ( this . subscription , this . refresh ) ; this . model ( el ) ; self . renderTemplate ( el , self . TEMPLATE , function ( el ) { el . swap ( ) ; } ) ; }
function ( ) { var nodeObj = this . object ; if ( nodeObj [ 'title' ] ) { nodeObj [ 'name' ] = nodeObj [ 'title' ] ; } nodeObj [ "avatar" ] = this . attachment ( 'avatar' ) . getDownloadUri ( ) ; nodes [ this . getId ( ) ] = this . object ; }
function ( entry ) { this . responsecode = null ; this . response_headers = null ; this . response_headers_raw = null ; this . responsebody = null ; this . header_tokens = null ; this . is_response = true ; this . logger_entry_type = entry . type ; this . logger_entry_id = entry . id ; this . logger_entry_mime = entry . mime ; this . logger_entry_is_finished = entry . is_finished ; this . logger_entry_touched_network = entry . touched_network ; }
function getUserImage ( ) { var image ; FB . api ( { method : 'fql.query' , query : 'SELECT pic_square FROM user WHERE uid=me()' } , function ( response ) { image = response [ 0 ] . pic_square ; } ) ; return image ; }
function ( ) { console . log ( 'asd' ) ; var data = { text : $ ( this ) . siblings ( '.feedback-input' ) . text ( ) , image : this . getUserImage ( ) } ; console . log ( this . getUserImage ( ) ) ; console . log ( data ) ; $ ( this ) . siblings ( '#comments' ) . append ( Mustache . render ( commentTemplate , data ) ) ; }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function getTitle ( mdown ) { var match = getHeaderRegExp ( _headingLevel - 1 ) . exec ( mdown ) ; return match ? match [ 1 ] . trim ( ) : '' ; }
function ( error , mainFramePayload ) { if ( error ) { console . error ( JSON . stringify ( error ) ) ; return ; } this . dispatchEventToListeners ( WebInspector . ResourceTreeModel . EventTypes . WillLoadCachedResources ) ; WebInspector . inspectedPageURL = mainFramePayload . frame . url ; this . _addFramesRecursively ( null , mainFramePayload ) ; this . _dispatchInspectedURLChanged ( ) ; this . dispatchEventToListeners ( WebInspector . ResourceTreeModel . EventTypes . CachedResourcesLoaded ) ; WebInspector . Resource . restoreRevisions ( ) ; this . _cachedResourcesProcessed = true ; }
function ( event ) { if ( this . isActive ) { var scope = event . data . scope ; for ( var key in scope . keys ) { if ( key == event . keyCode ) { scope . keysState [ key ] = false ; } } } }
function packToBuffer ( value , buffer , callback ) { var offset = packToBufferWithOffsetSync ( value , buffer , 0 ) ; process . nextTick ( function ( ) { callback ( offset ) ; } ) ; }
function ( test ) { test . expect ( 1 ) ; UBJSON . unpackBuffer ( ubjsonBuffer , function ( object ) { test . equal ( object , jsonObject , 'UBJSON.unpackBuffer(' + dataType + ')' ) ; test . done ( ) ; } ) ; }
function ( offset ) { resultBuffer = buffer . slice ( 0 , offset ) ; test . equal ( resultBuffer . toString ( 'binary' ) , ubjsonBuffer . toString ( 'binary' ) ) ; UBJSON . unpackBuffer ( ubjsonBuffer , function ( object ) { test . deepEqual ( object , jsObject ) ; test . done ( ) ; } ) ; }
function ( test ) { test . expect ( 1 ) ; UBJSON . unpackBuffer ( ubjsonBuffer , function ( object ) { test . deepEqual ( object , jsonObject , 'UBJSON.unpackBuffer(' + dataType + ')' ) ; test . done ( ) ; } ) ; }
function ( ) { var $field = $ ( this ) ; var id = this . id ; var $labels = $ ( 'label[for=' + id + ']' ) . hide ( ) ; var label = $labels . last ( ) . text ( ) ; if ( label . length > 0 && label [ label . length - 1 ] == '*' ) { label = label . substring ( 0 , label . length - 1 ) + ' *' ; } $field . attr ( 'placeholder' , label ) ; }
function thrown ( error , steps , index , context , callbacks , callback ) { if ( steps . length && steps . length && ~ steps [ 0 ] . parameters . indexOf ( "error" ) ) { context . error = error ; } abended = true ; if ( timer ) clearTimeout ( timer ) ; callback ( error ) ; }
function ( value , data , done ) { data . js_safe_name = value . replace ( /[\W_]+/g , '_' ) . replace ( /^(\d)/ , '_$1' ) ; done ( ) ; }
function ( thisDisplayName , index ) { var elem = { } ; elem [ urn ] = match [ baseUrn ] . concat ( "'" , thisDisplayName , "'" ) ; elem [ displayName ] = thisDisplayName ; elem [ preferred ] = index === 0 ; return elem ; }
function ( preset ) { if ( this . model ) this . view . cleanUp ( ) ; this . setModel ( this . getModelById ( preset . model ) ) ; this . model . setPreset ( preset . params ) ; this . updateText ( preset . text ) ; this . view = this . getViewByName ( preset . view ) ; this . view . setPreset ( this . model , preset . viewParams ) ; this . updateUI ( ) ; }
function ( ) { var db = start ( ) , M = db . model ( modelname , collection + random ( ) ) , _id = new DocumentObjectId , pending = 2 M . findByIdAndRemove ( _id , { fields : 'name' } , done ) ; M . findByIdAndRemove ( _id , done ) ; function done ( err , doc ) { should . strictEqual ( null , err ) ; should . strictEqual ( null , doc ) ; if ( -- pending ) return ; db . close ( ) ; } }
function ( err , found ) { should . strictEqual ( err , null ) ; found . id ; found . _id . should . eql ( created . _id ) ; BlogPostB . where ( 'title' ) . $regex ( /^Next/ ) . findOne ( function ( err , found ) { db . close ( ) ; should . strictEqual ( err , null ) ; found . id ; found . _id . should . eql ( created . _id ) ; } ) ; }
function ( err ) { should . strictEqual ( err , null ) ; BlogPost . findById ( post . _id ) . populate ( '_creator' , { email : 0 } ) . run ( function ( err , post ) { db . close ( ) ; should . strictEqual ( err , null ) ; post . _creator . name . should . equal ( 'Aaron' ) ; should . not . exist ( post . _creator . email ) ; } ) ; }
function ( err , post ) { should . strictEqual ( err , null ) ; BlogPost . findById ( post . _id ) . populate ( 'comments._creator' , [ 'email' ] ) . run ( function ( err , returned ) { db . close ( ) ; worked = true ; should . strictEqual ( err , null ) ; returned . id . should . equal ( post . id ) ; } ) ; }
function ( err ) { should . strictEqual ( err , undefined ) ; BlogPost . findById ( post . _id ) . populate ( 'fans' , [ 'name' ] ) . run ( function ( err , returned ) { db . close ( ) ; should . strictEqual ( err , null ) ; returned . id . should . equal ( post . id ) ; returned . fans . length . should . equal ( 1 ) ; } ) ; }
function ( ) { var query = new Query ( ) ; query . fields ( { a : 1 , b : 1 , c : 1 } ) ; query . _fields . should . eql ( { a : 1 , b : 1 , c : 1 } ) ; }
function ( ) { var query = new Query ( ) ; query . fields ( { only : [ 'a' , 'b' , 'c' ] } ) ; query . _fields . should . eql ( { a : 1 , b : 1 , c : 1 } ) ; }
function ( ) { var query = new Query ( ) ; query . where ( 'age' ) . notEqualTo ( 21 ) ; query . _conditions . should . eql ( { age : { $ne : 21 } } ) ; query = new Query ( ) ; query . notEqualTo ( 'age' , 21 ) ; query . _conditions . should . eql ( { age : { $ne : 21 } } ) ; }
function ( ) { var query = new Query ( ) ; query . wherein . box ( 'gps' , { ll : [ 5 , 25 ] , ur : [ 10 , 30 ] } ) ; query . _conditions . should . eql ( { gps : { $within : { $box : [ [ 5 , 25 ] , [ 10 , 30 ] ] } } } ) ; }
function ( ) { var query = new Query ( ) ; query . where ( 'gps' ) . wherein . box ( { ll : [ 5 , 25 ] , ur : [ 10 , 30 ] } ) ; query . _conditions . should . eql ( { gps : { $within : { $box : [ [ 5 , 25 ] , [ 10 , 30 ] ] } } } ) ; }
function ( ) { var query = new Query ( ) ; query . wherein . center ( 'gps' , { center : [ 5 , 25 ] , radius : 5 } ) ; query . _conditions . should . eql ( { gps : { $within : { $center : [ [ 5 , 25 ] , 5 ] } } } ) ; }
function DbError ( msg , code ) { this . name = 'UserError' ; if ( typeof ( msg ) === 'string' ) { this . message = msg ; } else { this . data = msg ; this . message = 'custom' ; } this . code = code || 500 ; Error . call ( this , msg ) ; }
function ( ) { var f = ( function ( _e ) { return _bind ( ) ( _startPhysics ) ( ( function ( ) { var $m ; return ( function ( ) { return $m || ( $m = ( function ( __ ) { return _runPhysics ( ) ; } ) ) } ) } ) ( ) ) ; } ) ; return function _startBlocky ( ) { return f ; } }
function unreffedValue ( deref , name , ast , top ) { if ( deref ) { return this ; } else { return this . lazy ( name , ast , top ) ; } }
function memoize ( deref , name , ast , top ) { var tmp ; if ( deref ) { return this ; } else { tmp = this . copyWith ( "$m || ($m = (" + this . main + "))" ) . lazy ( name , ast , top ) ; return tmp . copyWith ( "(function(){var $m; return " + tmp . main + "})()" ) ; } }
function receiverPositionFor ( ast ) { var i , _ref ; for ( i = 0 , _ref = ast . leisureArgNames . length ; 0 <= _ref ? i < _ref : i > _ref ; 0 <= _ref ? i ++ : i -- ) { if ( ast . leisureTypeAssertions [ ast . leisureArgNames [ i ] ] != null ) return i ; } return - 1 ; }
function genDispatchFunc ( methodName , receiverName , index , args ) { var joined ; if ( index < args . length ) { return "function(" + args [ index ] + ") {return " + ( genDispatchFunc ( methodName , receiverName , index + 1 , args ) ) + ";}" ; } else { joined = args . join ( ', ' ) ; return "(" + receiverName + "() instanceof LeisureObject ? " + receiverName + "() : LeisureObject.prototype)." + methodName + "(" + joined + ")" ; } }
function receiverAndArgs ( ast ) { var args , rPos , receiver ; rPos = receiverPositionFor ( ast ) ; args = ast . leisureArgNames ; receiver = nameSub ( args [ rPos ] ) ; return [ receiver , args . slice ( 1 , args . length ) . map ( function ( n ) { return nameSub ( n ) ; } ) . filter ( function ( n ) { return n !== receiver ; } ) ] ; }
function ( ) { var f = ( Parse . setDataType ( function ( _f ) { return Parse . setType ( function ( _a ) { return function ( _b ) { return _f ( ) ( _b ) ( _a ) ; } ; } , 'flip' ) ; } , 'flip' ) ) ; return function _flip ( ) { return f ; } }
function ( ) { var f = ( Parse . setType ( function ( _a ) { return function ( _b ) { return _a ( ) ; } ; } , 'true' ) ) ; return function _true ( ) { return f ; } }
function ( ) { var f = ( Parse . setType ( function ( _a ) { return function ( _b ) { return _b ( ) ; } ; } , 'false' ) ) ; return function _false ( ) { return f ; } }
function ( ) { var f = ( function ( _a ) { return function ( _b ) { return _a ( ) ( _b ) ( _false ) ; } ; } ) ; return function _and ( ) { return f ; } }
function ( ) { var f = ( function ( _a ) { return function ( _b ) { return _not ( ) ( ( function ( ) { var $m ; return ( function ( ) { return $m || ( $m = ( _eq ( ) ( _a ) ( _b ) ) ) } ) } ) ( ) ) ; } ; } ) ; return function _neq ( ) { return f ; } }
function ( ) { var f = ( Parse . setDataType ( function ( _v ) { return Parse . setType ( function ( _l ) { return function ( _r ) { return _l ( ) ( _v ) ; } ; } , 'left' ) ; } , 'left' ) ) ; return function _left ( ) { return f ; } }
function ( ) { var f = ( Parse . setDataType ( function ( _v ) { return Parse . setType ( function ( _l ) { return function ( _r ) { return _r ( ) ( _v ) ; } ; } , 'right' ) ; } , 'right' ) ) ; return function _right ( ) { return f ; } }
function ( ) { var f = ( Parse . setDataType ( function ( _x ) { return Parse . setType ( function ( _yes ) { return function ( _no ) { return _yes ( ) ( _x ) ; } ; } , 'some' ) ; } , 'some' ) ) ; return function _some ( ) { return f ; } }
function ( ) { var f = ( Parse . setDataType ( function ( _a ) { return function ( _b ) { return Parse . setType ( function ( _yes ) { return function ( _no ) { return _yes ( ) ( _a ) ( _b ) ; } ; } , 'some2' ) ; } ; } , 'some2' ) ) ; return function _some2 ( ) { return f ; } }
function ( ) { var f = ( Parse . setType ( function ( _yes ) { return function ( _no ) { return _no ( ) ; } ; } , 'none' ) ) ; return function _none ( ) { return f ; } }
function runMonad ( monad , env , cont ) { if ( monad . cmd != null ) { return monad . cmd ( env , continueMonad ( cont ) ) ; } else { return cont ( monad ) ; } }
function ( ) { return function ( name ) { return makeMonad ( function ( env , cont ) { return cont ( values [ name ( ) ] ) ; } ) ; } ; }
get linearization ( ) { var length = this . stream . length ; var linearization = false ; if ( length ) { linearization = new Linearization ( this . stream ) ; if ( linearization . length != length ) linearization = false ; } return shadow ( this , 'linearization' , linearization ) ; } ,
function combine ( ) { var composite = { } ; for ( var i = 0 , length = arguments . length ; i < length ; ++ i ) { var object = arguments [ i ] ; for ( var key in object ) { if ( object . hasOwnProperty ( key ) ) { if ( typeof composite [ key ] !== 'undefined' ) { throw new DeveloperError ( 'Duplicate member: ' + key ) ; } composite [ key ] = object [ key ] ; } } } return composite ; }
function destroyObject ( object , message ) { message = defaultValue ( message , 'This object was destroyed, i.e., destroy() was called.' ) ; function throwOnDestroyed ( ) { throw new DeveloperError ( message ) ; } for ( var key in object ) { if ( typeof object [ key ] === 'function' ) { object [ key ] = throwOnDestroyed ; } else { delete object [ key ] ; } } object . isDestroyed = returnTrue ; return undefined ; }
function ( url , textureAvailableCallback ) { if ( typeof url === 'undefined' ) { throw new DeveloperError ( 'url is required.' ) ; } if ( typeof textureAvailableCallback === 'undefined' ) { throw new DeveloperError ( 'textureAvailableCallback is required.' ) ; } this . addTextureFromFunction ( url , getImageFromUrl , textureAvailableCallback ) ; }
function ( ) { oDialog . cfg . queueProperty ( "buttons" , aButtonsDone ) ; }
function ( ) { nock . restore ( ) ; ret = nock . recorder . play ( ) ; t . equal ( ret . length , 1 ) ; t . equal ( ret [ 0 ] . indexOf ( "\nnock('expensecat.iriscouch.com')\n  .post('/, \"ABCDEF\"')\n  .reply(" ) , 0 ) ; t . end ( ) ; }
function ( rs , fn ) { var module = { } , exports = { } module . exports = exports fn ( module , exports , require ) if ( Object . prototype . toString . call ( rs ) == '[object Array]' ) { for ( var i = 0 , l = rs . length ; i < l ; i ++ ) { modules [ rs [ i ] ] = module . exports } } else { modules [ rs ] = module . exports } }
function ( error , res , more ) { if ( error ) { self . emit ( "error" , error ) ; } else { for ( var serviceName in res ) { self . _services [ serviceName ] = { endpoint : res [ serviceName ] , client : null , context : null , introspected : null } ; } registrarClient . close ( ) ; callback ( error , self ) ; } }
function ( data , meta ) { var ct = meta . http . headers [ 'content-type' ] ; doneCalled = true ; A . areSame ( 'hi' , data , 'bad string to done' ) ; A . areSame ( 1 , ct . length , "should be only one content-type header" ) ; A . areSame ( 'text/plain; charset="utf-8"' , ct [ 0 ] ) ; }
function ( data , meta ) { var ct = meta . http . headers [ 'content-type' ] ; doneCalled = true ; A . areSame ( JSON . stringify ( json ) , data , 'bad string to done' ) ; A . areSame ( 1 , ct . length , "should be only one content-type header" ) ; A . areSame ( 'application/json; charset="utf-8"' , ct [ 0 ] ) ; }
function ( data , meta ) { var ct = meta . http . headers [ 'content-type' ] ; doneCalled = true ; A . areSame ( '<xml><hi>there</hi></xml>' , data , 'bad string to done' ) ; A . areSame ( 1 , ct . length , "should be only one content-type header" ) ; A . areSame ( 'application/xml; charset="utf-8"' , ct [ 0 ] ) ; }
function ( data ) { var channel = irc . chatWindows . getByName ( data . channel ) ; channel . userList = new UserList ( channel ) ; $ . each ( data . nicks , function ( nick , role ) { channel . userList . add ( new User ( { nick : nick , role : role , idle : 61 , user_status : 'idle' , activity : '' } ) ) ; } ) ; }
function ( data ) { var channel = irc . chatWindows . getByName ( data . channel ) ; channel . set ( { topic : data . topic } ) ; var topicMessage = new Message ( { type : 'topic' , nick : data . nick , topic : data . topic } ) ; channel . stream . add ( topicMessage ) ; }
function ( err , hash ) { var user = new User ( ) ; user . username = data . username ; user . password = hash ; user . save ( ) ; console . log ( user ) ; socket . emit ( 'register_success' , { username : user . username } ) ; current_user = user ; }
function ( name ) { client . part ( name ) ; if ( current_user ) { if ( logger_users [ name ] == current_user . username ) { delete logger_users [ name ] ; for ( client_key in clients ) { if ( client_key == current_user . username ) { continue ; } var cl = clients [ client_key ] ; if ( cl . chans [ name . toLowerCase ( ) ] !== undefined ) { logger_users [ name . toLowerCase ( ) ] = cl . nick ; } } } } }
function ( data ) { client . action ( data . target , data . message ) ; socket . emit ( 'message' , { to : data . target , from : client . nick , text : '\u0001ACTION ' + data . message } ) ; }
function ( err , results ) { if ( results ) { if ( results [ 0 ] ) { if ( data . channelName [ 0 ] == '#' ) { results [ 0 ] [ 'name' ] = data . channelName ; } else { results [ 0 ] [ 'name' ] = data . channelName . replace ( client . nick , '' ) ; } } socket . emit ( 'oldMessages' , results [ 0 ] ) ; } }
function ( ) { app . router = new Router ( ) ; Backbone . history . start ( { pushState : true } ) ; }
function ( request , status ) { if ( status == "completed" || status == "announced" || status == "closed-out" || status == "deleted" ) { return '<a href="' + WMStats . Globals . WORKLOAD_SUMMARY_URL_PREFIX + encodeURIComponent ( request ) + '" target="_blank">' + status + '</a>' ; } else { return status ; } }
function ( self ) { var item = declaration [ key ] ; var Repository = item [ 'repository' ] || EntityRepository ; var repository = self . create ( Repository , key ) ; repository . Entity = item [ 'entity' ] || Entity ; if ( typeof repository . Entity !== 'function' ) { throw new Error ( 'Invalid entity constructor for the repository \'' + key + '\'' ) ; } return repository ; }
function ( listId ) { var textField = $ ( 'input' , this ) ; var list = $ ( 'div.list' , this ) ; $ ( list ) . addClass ( 'myListId' + listId ) ; ensureTasksNumber ( list [ 0 ] ) ; textField . bind ( 'keypress' , function ( e ) { if ( e . keyCode == 13 && textField . val ( ) != '' ) { addTask ( textField . val ( ) , list ) ; textField . val ( '' ) ; } } ) ; }
function ( ) { var d = new Date ( calendar . last ( ) . time ( ) ) ; d . setDate ( 0 ) ; d . setMonth ( d . getMonth ( ) + 2 ) ; return d ; }
function ( item , immediate ) { if ( this . _isEditFormLocked ( ) ) { return ; } this . editForm . itemform ( 'hideForm' , item , immediate ) ; this . _trigger ( 'endmapedit' , { } , { 'immediate' : immediate } ) ; item . data ( 'expanded' , false ) ; this . _currentFormItem = null ; this . _showItemRows ( ) ; this . _recuperateScrollTop ( ) ; }
function ( ) { var textColor = this . options . colors . dark_purple ; if ( this . textSpan . data ( 'changed' ) ) { textColor = this . options . colors . red ; } this . textSpan . css ( { 'font-weight' : 'bold' , 'color' : textColor } ) ; }
function onLongPress ( evt ) { evt . preventDefault ( ) ; evt . stopPropagation ( ) ; document . body . dataset . mode = 'edit' ; if ( 'origin' in evt . target . dataset ) { document . body . dataset . transitioning = true ; DragDropManager . start ( evt , { x : evt . pageX , y : evt . pageY } ) ; } }
function showAppDialog ( origin ) { var app = Applications . getByOrigin ( origin ) ; var title = 'Remove ' + app . manifest . name ; var body = 'This application will be uninstalled fully from your mobile' ; Permissions . show ( title , body , function onAccept ( ) { app . uninstall ( ) } , function onCancel ( ) { } ) ; }
function ( $event ) { if ( $event ) { delete this . __events [ $event ] ; } else { this . __events = { } ; } return this ; }
function dataSaved ( data ) { if ( data . status == 'success' ) { loadData ( ) ; } else if ( data . status == 'error' ) { $ ( '#errorBox' ) . html ( data . data ) ; } else { $ ( '#errorBox' ) . html ( 'An unknown error occurred' ) ; } }
function ( up , file , response ) { var resp = JSON . parse ( response . response ) ; $ ( '#id_logo' ) . val ( resp . id ) ; $ ( '#logo-thumb' ) . html ( '' + '<img src="' + resp . url + '" >' ) ; setLogoChoice ( 'uploaded' ) ; }
function ( ) { var data = JSON . parse ( this . innerHTML ) ; console . log ( data ) ; console . log ( document . getElementById ( 'post_action' ) ) ; qp ( data . text , document . getElementById ( 'post_action' ) . parentNode . parentNode ) ; document . getElementById ( 'post_action' ) . id = '' ; }
function ( ) { var index , cslId = parseInt ( hoveredNodeStack [ hoveredNodeStack . length - 1 ] , 10 ) , selectedNode ; assert ( hoveredNodeStack . length > 0 ) ; selectedNode = CSLEDIT . data . getNode ( cslId ) ; if ( selectedNode . name === "macro" ) { assert ( hoveredNodeStack . length > 1 ) ; cslId = hoveredNodeStack [ hoveredNodeStack . length - 2 ] ; } if ( selectedCslId !== cslId ) { selectedCslId = cslId ; CSLEDIT . viewController . selectNode ( cslId , highlightedTreeNodes ) ; } }
function ( startDate , endDate , fn , incrementBy , factor ) { var instance = this ; var curDate = DateMath . clone ( startDate ) ; var endDateMs = endDate . getTime ( ) , index ; for ( index = 0 ; curDate . getTime ( ) <= endDateMs ; index ++ ) { fn . apply ( instance , [ curDate , index ] ) ; curDate = DateMath . add ( curDate , ( incrementBy || DateMath . DAY ) , ( factor || 1 ) ) ; } }
function ( evt ) { var instance = this ; var endDate = evt . get ( END_DATE ) ; var startDate = evt . get ( START_DATE ) ; return [ startDate . getHours ( ) , DASH , endDate . getHours ( ) , SPACE , evt . get ( CONTENT ) ] . join ( EMPTY_STR ) ; }
function ( val ) { var instance = this ; instance . syncDaysHeaderUI ( ) ; instance . syncGridUI ( ) ; }
function ( request , sender , sendResponse ) { if ( request . method == "getSelection" ) { var selection = getSelectionHTML ( ) ; sendResponse ( { data : selection ? selection : document . execCommand ( 'paste' ) ; } ) ; } else sendResponse ( { } ) ; }
function Game ( ) { this . grid = new Array ( 9 ) ; for ( i = 0 ; i < 9 ; i ++ ) { this . grid [ i ] = new Array ( 9 ) ; for ( j = 0 ; j < 9 ; j ++ ) this . grid [ i ] [ j ] = null ; } }
function ( e ) { console . log ( this ) ; this . modifiedCell = e . target ; if ( this . commands . className == 'hidden' ) this . commands . className = 'displayed' ; else this . commands . className = 'hidden' ; }
function ( aRelativePath ) { var file = Components . classes [ "@mozilla.org/file/directory_service;1" ] . getService ( Components . interfaces . nsIProperties ) . get ( "ProfD" , Components . interfaces . nsIFile ) ; var path = aRelativePath . split ( "/" ) ; for ( var i = 0 , sz = path . length ; i < sz ; i ++ ) { if ( path [ i ] != "" ) file . append ( path [ i ] ) ; } return file . path ; }
function addToHistory ( page ) { if ( pageHistory [ pageHistory . length - 1 ] !== page ) { pageHistory . push ( page ) ; } }
function ( ) { if ( ! isLocalStorageSupported ) { alert ( "Your browser is very out of date. To use Ω, please use a newer browser." ) ; return ; } processScroll ( ) ; $ ( window ) . on ( 'scroll' , processScroll ) ; $ ( '.flash' ) . click ( hideFlashMessages ) . delay ( 500 ) . fadeIn ( ) . delay ( 8000 ) . fadeOut ( ) ; var projectView = new ProjectView ( $ ( "#nameInput" ) , $ ( "#messageInput" ) , $ ( "#form" ) , $ ( "#messages" ) , socket ) ; }
function processScroll ( ) { var scrollTop = $ ( window ) . scrollTop ( ) ; if ( ! isFixed && scrollTop >= topOffset ) { isFixed = true ; $toFix . addClass ( 'fixed' ) ; } else if ( isFixed && scrollTop <= topOffset ) { isFixed = false ; $toFix . removeClass ( 'fixed' ) ; } }
function ( ) { if ( ! help . hasClass ( 'hidden' ) ) open_h . click ( ) ; else if ( ! info . hasClass ( 'hidden' ) ) open_i . click ( ) ; else if ( searches . length && ( searches . length > 1 || ! is_curr_search ( searches [ searches . length - 1 ] ) ) ) search_num ( ) ; else navigator . app . exitApp ( ) ; }
function ( ) { this . pitchdeck = new pitchdeck . PitchDeck ( ) ; var problem_data = specfactory . PitchDeckFactory . SlideData ( "problem" ) ; this . pitchdeck . LoadDeck ( [ problem_data ] ) ; this . pitchdeck . Start ( ) ; }
function ( stuff ) { return stuff [ tools . Random . Number ( stuff . length ) ] ; }
function ( page ) { var act = this . actions [ page ] ; var old_act = this . actions [ this . active_scene ] ; this . slides . get ( old_act ) . Hide ( ) ; this . slides . get ( act ) . Show ( ) ; this . active_scene = page ; }
function getImage ( imgName , makeSubList ) { var imageLi = document . createElement ( 'li' ) ; makeSubList . appendChild ( imageLi ) ; var newImage = document . createElement ( 'img' ) ; var setSrc = newImage . setAttribute ( "src" , "Images/" + imgName + ".png" ) ; newImage . style . paddingTop = "10px" ; imageLi . appendChild ( newImage ) ; }
function ( x ) { return [ x . nodeName . toLowerCase ( ) , x . nodeValue ] ; }
function ( x ) { return [ x . nodeName . toLowerCase ( ) , x . nodeValue ] ; }
function ( e ) { log . warning ( 'Got connection lost notification' ) ; CDOT . disconnectHandler ( ) ; if ( e . errCode == CDO . ErrorCodes . Communication . COMM_REMOTE_END_DIED ) { log . warn ( 'Connection terminated due to internet connection issues. ' + 'Trying to reconnect in 5 seconds' ) ; CDOT . tryReconnect ( ) ; } }
function ( ) { var connDescriptor = $ . extend ( { } , CDOT . CONNECTION_CONFIGURATION ) ; connDescriptor . url = CDOT . STREAMER_URL_PFX + CDOT . scopeId ; connDescriptor . token = CDOT . userId + '' ; connDescriptor . autopublishAudio = $ ( '#publishAudioChckbx' ) . is ( ':checked' ) ; connDescriptor . autopublishVideo = $ ( '#publishVideoChckbx' ) . is ( ':checked' ) ; }
function ( msg ) { if ( this . backend == 'stdout' ) { this . util . log ( msg ) ; } else { this . util . log ( this . util . LOG_INFO , msg ) ; } }
function loadBackend ( config , name ) { var backendmod = require ( name ) ; if ( config . debug ) { l . log ( "Loading backend: " + name ) ; } var ret = backendmod . init ( startup_time , config , backendEvents ) ; if ( ! ret ) { l . log ( "Failed to load backend: " + name ) ; process . exit ( 1 ) ; } }
function ( RA , water ) { if ( ! water ) { water = w . profile ; } var ca2 = 3.5 * ( ( water . HCO * 0.819672131 ) - ( 0.714 * water . Ca ) - ( 0.585 * water . Mg ) - RA ) ; return Math . min ( w . ions . Ca . max , ca2 ) ; }
function updateSrm ( ) { var v = srmSlider . slider ( "option" , "value" ) ; srmValue . html ( 'SRM: ' + parseInt ( v , 10 ) ) ; srmColor . css ( { background : B . units . convert ( 'SRM' , 'HTML_RGB' , v ) } ) ; compute ( ) ; }
function ( ) { if ( arguments . length === 8 ) { p . beginShape ( ) ; p . curveVertex ( arguments [ 0 ] , arguments [ 1 ] ) ; p . curveVertex ( arguments [ 2 ] , arguments [ 3 ] ) ; p . curveVertex ( arguments [ 4 ] , arguments [ 5 ] ) ; p . curveVertex ( arguments [ 6 ] , arguments [ 7 ] ) ; p . endShape ( ) ; } }
function ( err , fd ) { ( ! err ) . should . eql ( true ) ; fd1 = fd ; var buf = new Buffer ( 'party rockin' ) ; fs . write ( fd1 , buf , 0 , buf . length , null , function ( err , bytesWritten ) { ( ! err ) . should . eql ( true ) ; } ) ; }
function ( ) { expect . expect ( 'unlink' , function ( err , data ) { if ( err ) throw err ; done ( ) ; } , 1000 ) ; fs . unlink ( logFile , function ( err ) { ( ! err ) . should . eql ( true ) ; } ) ; }
function ( err , fd ) { ( ! err ) . should . eql ( true ) ; fd2 = fd ; var buf = new Buffer ( 'new party' ) ; fs . write ( fd2 , buf , 0 , buf . length , null , function ( err , bytesWritten ) { ( ! err ) . should . eql ( true ) ; } ) ; }
function showMapDirectPopup ( ) { if ( typeof mapDirect != 'undefined' ) { if ( markerFeatures [ mapDirect ] . popup == null ) fillPopup ( markerFeatures [ mapDirect ] ) ; if ( ! markerFeatures [ mapDirect ] . popup . visible ( ) ) showPopup ( markerFeatures [ mapDirect ] . popup ) mapDirect = undefined ; } }
function getFirstPageWithEmptySpace ( ) { var index = 0 ; var total = pageHelper . total ( ) ; var maxPerPage = pageHelper . getMaxPerPage ( ) ; while ( index < total ) { var page = pages [ index ] ; if ( page . getNumApps ( ) < maxPerPage ) { break ; } index ++ ; } return index ; }
function processResult ( result , env , next ) { next = next != null ? next : nextFunc ; if ( ( getType ( result ) ) === 'monad' ) { console . log ( "RESULT IS A MONAD" ) ; return Prim . runMonad ( result , env != null ? env : Prim . defaultEnv , function ( ) { return next ( ) ; } ) ; } else { console . log ( "RESULT IS NOT A MONAD, IT'S " + ( getType ( result ) ) + ": " + result ) ; return next ( ) ; } }
function evalCompiledAst ( ast ) { console . log ( "EVAL AST: " + ( Parse . print ( ast ) ) + ", " + ast . src ) ; if ( ast . lits . length ) { return evalFunc ( "(function(__lits){\nreturn " + ast . src + "})" ) ( ast . lits ) ; } else { return Parse . evalFunc ( ast . src ) ; } }
function presentValue ( v ) { var content ; if ( ( ReplCore . getType ( v ) ) === 'svg-node' ) { content = v ( laz ( id ) ) ; return _svg$_present ( ) ( laz ( content ) ) ( laz ( id ) ) ; } else { return basePresentValue ( v ) ; } }
function getAst ( bx , def ) { if ( bx . ast != null ) { patchFuncAst ( bx . ast ) ; return bx . ast ; } else { def = def || bx . textContent ; setAst ( bx , ( Leisure . compileNext ( def , Leisure . Nil , true , null , true ) ) [ 0 ] ) ; return bx . ast ; } }
function join ( str ) { return this . toArray ( ) . join ( str ) ; }
function define ( name , func , arity , src ) { var nm ; func . src = src ; func . leisureContexts = [ ] ; nm = nameSub ( name ) ; func . leisureName = name ; func . leisureArity = arity ; if ( global . noredefs && ( global [ nm ] != null ) ) { throwError ( "[DEF] Attempt to redefine definition: " + name ) ; } global [ nm ] = global . leisureFuncs [ nm ] = func ; ( evalFunc ( 'leisureAddFunc' ) ) ( name ) ; return func ; }
function defGroup ( open , close ) { console . log ( "DEFINING GROUP: " + open + ", " + close ) ; if ( ! ( tokens [ open ] != null ) ) { defToken ( open ) ; defToken ( close ) ; groupOpens [ open ] = close ; return groupCloses [ close ] = 1 ; } }
function elements ( l , first , nosubs ) { if ( getType ( l ) === 'nil' ) { return '' ; } else if ( getType ( l ) !== 'lexCons' ) { return " | " + ( print ( l ) ) ; } else { return "" + ( first ? '' : ' ' ) + ( print ( l . head ( ) ) + elements ( l . tail ( ) , false ) ) ; } }
function ( ) { return function ( a ) { return function ( b ) { return b ( ) ; } ; } ; }
function ( i , kvA ) { var annotation = Zipkin . fromRawKvAnnotation ( kvA ) ; span . addKvAnnotation ( annotation ) ; annotation . setSpan ( span ) ; kvAnnotations . push ( annotation ) ; }
function ( ) { $ . ajax ( { type : 'GET' , url : root_url + 'traces/is_pinned_json?trace_id=' + trace . trace_id , success : function ( data ) { pinned = data . pinned === true ; updatePinButton ( ) ; } , error : function ( xhr , status , error ) { $ ( '#pinned-modal-error' ) . text ( "Could not check trace pin status due to this error: " + error ) ; $ ( '#pinned-modal' ) . modal ( 'show' ) ; } } ) ; }
function ( e ) { $ . ajax ( { type : 'GET' , url : root_url + 'traces/pin_json?trace_id=' + trace . trace_id + '&pinned=' + ! pinned , success : function ( data ) { pinned = data . pinned === true ; updatePinButton ( ) ; } , error : function ( xhr , status , error ) { $ ( '#pinned-modal-error' ) . text ( "Could not pin trace due to this error: " + error ) ; $ ( '#pinned-modal' ) . modal ( 'show' ) ; } } ) ; return false ; }
function ( j , a ) { if ( a . getTimestamp ( ) < min ) { min = a . getTimestamp ( ) ; } if ( $ . inArray ( a . getValue ( ) , [ "Client send" , "Client receive" , "Server send" , "Server receive" ] ) == - 1 ) { a . services = d . services ; a . annotations = d . annotations ; annotation_data . push ( a ) ; annotation_to_row [ a . getValue ( ) + a . getTimestamp ( ) ] = i ; } }
function ( name , value ) { var names = name . split ( d3_selection_classedWhitespace ) , n = names . length , i = - 1 ; if ( arguments . length > 1 ) { while ( ++ i < n ) d3_selection_classed . call ( this , names [ i ] , value ) ; return this ; } else { while ( ++ i < n ) if ( ! d3_selection_classed . call ( this , names [ i ] ) ) return false ; return true ; } }
function ( a , b ) { return this . call ( n , a , b || k ) } , n . getComputedStyle ) } "classList" in D || Object . defineProperty ( s , "classList" , { get : function ( ) { if ( this . tagName ) { var a = this . _ || ( this . _ = { } ) ; a . _ccl_ || ( a . _ccl_ = new K ( 0 , sa , ta , this ) ) ; return a . _ccl_ } }
function ( data , status ) { var fileURL = $ ( data ) . find ( 'file_url' ) . text ( ) ; var error = $ ( data ) . find ( 'error' ) . text ( ) ; if ( error != '' ) { alert ( error ) ; if ( startUploadHandler ) { $ ( '#file-upload' ) . change ( startUploadHandler ) ; } } else { imageUrl . attr ( 'value' , fileURL ) ; } }
function ( data ) { if ( data [ 'success' ] ) { me . setOn ( data [ 'is_member' ] ) ; } else { showMessage ( me . getElement ( ) , data [ 'message' ] ) ; } }
function ( idx , name ) { var tag = new Tag ( ) ; tag . setName ( name ) ; me . _tags . push ( tag ) ; me . _tag_list_element . append ( tag . getElement ( ) ) ; }
function ( element ) { this . _element = element ; this . _name = $ . trim ( element . find ( 'a' ) . html ( ) ) ; var deleter = new DeleteIcon ( ) ; deleter . setHandler ( this . getDeleteHandler ( ) ) ; deleter . setContent ( 'x' ) ; this . _element . find ( '.group-name' ) . append ( deleter . getElement ( ) ) ; this . _delete_icon = deleter ; }
function ( element ) { this . _element = element ; var add_link = element . find ( '#add-group' ) ; var adder = new GroupAdderWidget ( ) ; adder . decorate ( add_link ) ; var groups_container = new GroupsContainer ( ) ; groups_container . decorate ( element . find ( 'ul' ) ) ; adder . setGroupsContainer ( groups_container ) ; }
function ( doPostback ) { if ( doPostback ) { $ . post ( askbot [ 'urls' ] [ 'mark_read_message' ] , { formdata : "required" } ) ; } $ ( ".notify" ) . fadeOut ( "fast" ) ; $ ( "body" ) . css ( "margin-top" , "0" ) ; visible = false ; }
function ( ) { var $elems = this , e , ctx ; for ( e = 0 ; e < $elems . length ; e += 1 ) { ctx = getContext ( $elems [ e ] ) ; if ( ctx ) { ctx . restore ( ) ; } } return $elems ; }
function ( args ) { var $elems = this , e , ctx , params = merge ( new Prefs ( ) , args ) ; for ( e = 0 ; e < $elems . length ; e += 1 ) { ctx = getContext ( $elems [ e ] ) ; if ( ctx ) { if ( params . autosave ) { ctx . save ( ) ; } translateCanvas ( ctx , params ) ; } } return $elems ; }
function ( args ) { var $elems = this , e , ctx , params = merge ( new Prefs ( ) , args ) ; for ( e = 0 ; e < $elems . length ; e += 1 ) { ctx = getContext ( $elems [ e ] ) ; if ( ctx ) { if ( params . autosave ) { ctx . save ( ) ; } rotateCanvas ( ctx , params ) ; } } return $elems ; }
function onload ( elem , e , ctx ) { return function ( ) { draw ( e , ctx ) ; if ( params . load ) { params . load . call ( elem , args ) ; } } ; }
function ( data ) { self . progressHtml ( data . html ) ; var pct = parseInt ( ( data . complete / data . total ) * 100.0 , 10 ) ; self . progressBarWidth ( pct + "%" ) ; if ( pct >= 100 ) { self . triggerDone ( ) ; } }
function ( nmp ) { var mojits = me . _mojits , viewid = nmp . proxy . getId ( ) , binder = nmp . proxy . _binder , node = nmp . proxy . _node , elem = nmp . proxy . _element ; mojits [ viewid ] = { proxy : nmp . proxy , children : nmp . children , handles : bindNode ( binder , node , elem ) } ; recordBoundMojit ( mojits , parentId , viewid , nmp . proxy . type ) ; }
function ( result ) { if ( result . isMatch ) { self . shouldAllowCreate ( false ) ; self . nameIsAvailable ( false ) ; self . nameIsTaken ( true ) ; $ . publish ( '/gym/name/taken' , result . id ) ; } else { self . shouldAllowCreate ( true ) ; self . nameIsAvailable ( result . inputHasValue ) ; self . nameIsTaken ( false ) ; $ . publish ( '/gym/name/available' ) ; } }
function ( ) { this . input = this . $ ( "#new-todo" ) ; this . allCheckbox = this . $ ( "#toggle-all" ) [ 0 ] ; Todos . on ( 'add' , this . adcompleted , this ) ; Todos . on ( 'reset' , this . addAll , this ) ; Todos . on ( 'all' , this . render , this ) ; this . $footer = $ ( '#footer' ) ; this . $main = $ ( '#main' ) ; Todos . fetch ( ) ; }
function ( ) { Todos . each ( this . adcompleted , this ) ; }
function ( param ) { switch ( param ) { default : console . log ( Todos ) ; break ; case 'active' : console . log ( Todos . remaining ( ) ) ; break ; case 'completed' : console . log ( Todos . completed ( ) ) ; break ; } $ ( '#filters li a' ) . removeClass ( 'selected' ) . filter ( "[href='#/" + param + "']" ) . addClass ( 'selected' ) ; }
function ( ) { var tags = this . collection ; tags . on ( 'add' , this . addOne , this ) ; tags . on ( 'reset' , this . addAll , this ) ; tags . on ( 'all' , this . render , this ) ; tags . fetch ( { success : function ( ) { tags . pager ( ) ; } , silent : true } ) ; }
function ( type , args , delay ) { if ( ! this . $events ) return ; type = removeOn ( type ) ; var events = this . $events [ type ] ; if ( ! events ) return this ; args = Array . from ( args ) ; events . each ( function ( fn ) { if ( delay ) fn . delay ( delay , this , args ) ; else fn . apply ( this , args ) ; } , this ) ; return this ; }
function ( type , fn ) { if ( ! this . $events ) return ; type = removeOn ( type ) ; var events = this . $events [ type ] ; if ( events && ! fn . internal ) { var index = events . indexOf ( fn ) ; if ( index != - 1 ) delete events [ index ] ; } return this ; }
function ( value ) { value = value ? value : valueToSet var total = controlDataSource . total ( ) ; for ( var itemIndex = 0 ; itemIndex < total ; itemIndex ++ ) { if ( accessDataItemValue ( controlDataSource . at ( itemIndex ) ) == value ) { control . value ( controlDataSource . at ( itemIndex ) ) ; return ; } } control . value ( null ) ; }
function ( value ) { value = value ? value : valueToSet var total = controlDataSource . total ( ) ; for ( var itemIndex = 0 ; itemIndex < total ; itemIndex ++ ) { if ( accessDataItemValue ( controlDataSource . at ( itemIndex ) ) == value ) { control . value ( controlDataSource . at ( itemIndex ) ) ; return ; } } control . value ( null ) ; }
function ( ) { if ( this . paused === false || ! this . readable ) { return ; } this . paused = false ; var self = this ; if ( self . pendingChunk != null ) { self . currentChunk = self . pendingChunk ; process . nextTick ( function ( ) { self . _execute ( ) ; } ) ; } else { self . readable = false ; self . emit ( "close" ) ; } }
function _fnBrowserDetect ( oSettings ) { var n = $ ( '<div style="position:absolute; top:0; left:0; height:1px; width:1px; overflow:hidden">' + '<div style="position:absolute; top:1px; left:1px; width:100px; height:50px; overflow:scroll;">' + '<div id="DT_BrowserTest" style="width:100%; height:10px;"></div>' + '</div>' + '</div>' ) [ 0 ] ; document . body . appendChild ( n ) ; oSettings . oBrowser . bScrollOversize = $ ( '#DT_BrowserTest' , n ) [ 0 ] . offsetWidth === 100 ? true : false ; document . body . removeChild ( n ) ; alert ( oSettings . oBrowser . bScrollOversize ) ; }
function _fnBrowserDetect ( oSettings ) { var n = $ ( '<div style="position:absolute; top:0; left:0; height:1px; width:1px; overflow:hidden">' + '<div style="position:absolute; top:1px; left:1px; width:100px; height:50px; overflow:scroll;">' + '<div id="DT_BrowserTest" style="width:100%; height:10px;"></div>' + '</div>' + '</div>' ) [ 0 ] ; document . body . appendChild ( n ) ; oSettings . oBrowser . bScrollOversize = $ ( '#DT_BrowserTest' , n ) [ 0 ] . offsetWidth === 100 ? true : false ; document . body . removeChild ( n ) ; alert ( oSettings . oBrowser . bScrollOversize ) ; }
function jQuery_log ( str , verbose ) { if ( ! THIRDCONTEXT . CONSTANTS . DEBUGMODE ) { return ; } void 0 === verbose && ( verbose = false ) ; if ( ! verbose || THIRDCONTEXT . CONSTANTS . DEBUG_VERBOSE ) { str . constructor !== Array ? console . log ( str ) : console . log . apply ( console , str ) ; } return ; }
function jQuery_polyfillInputNumber ( ) { var testEle = document . createElement ( 'input' ) ; testEle . setAttribute ( 'type' , 'number' ) ; if ( testEle . type === 'number' ) { $ . log ( 'input[type=number] is supported, no polyfill needed.' ) ; } else { $ . log ( 'input[type=number] is not supported, loading polyfill.' ) ; var Modernizr = { inputtypes : { number : false } } ; eval ( localStorage . getItem ( 'inputNumberPolyfill' ) ) ; } }
function jQuery_prototype_appendAll ( arrayToAdd ) { var $fragment = $ . single ( document . createDocumentFragment ( ) ) , i = 0 , len = arrayToAdd . length , $fragAppend = $fragment . append ; do { $fragAppend . apply ( this , arrayToAdd [ i ] ) ; } while ( i ++ < len ) ; return this . append ( $fragment ) ; }
function jQuery_make ( tagName , options ) { var domEl = [ document . createElement ( tagName ) ] , jq = $ ; jq . fn . prop . call ( domEl , options , true ) ; return jq . merge ( jq ( ) , domEl ) ; }
function ( e ) { if ( engine . onKeydown ( e ) ) { e . preventDefault ( ) ; return false ; } }
function ( module , filename ) { var code = fs . read ( filename ) ; var CoffeeScript = require ( '_coffee-script' ) ; try { code = CoffeeScript . compile ( code ) ; } catch ( e ) { e . fileName = filename ; throw e ; } module . _compile ( code ) ; }
function ( request , exports ) { self . stubs [ request ] = { exports : exports } ; }
function ( ) { var cwd , mainFilename , mainModule = new Module ( ) ; window . require = mainModule . _getRequire ( ) ; fs = loadFs ( ) ; cwd = fs . absolute ( phantom . libraryPath ) ; mainFilename = joinPath ( cwd , basename ( require ( 'system' ) . args [ 0 ] ) || 'repl' ) ; mainModule . _setFilename ( mainFilename ) ; }
function ( obj ) { if ( obj . err ) { alertFailure ( "#subjectFormAlert" , obj . err ) ; $ ( "#subjectFormAlert" ) . goTo ( ) ; } else { subject . id = obj . id ; alertSuccess ( "#subjectFormAlert" , "成功增加课题" ) ; $ ( '#subject-form' ) . hide ( "fast" ) ; addToMySubject ( subject ) ; } }
function ( err , results ) { if ( err ) return cb ( err , null ) ; var data = { } ; for ( var i = 0 ; i < results . length ; i ++ ) { data [ destinations [ i ] ] = results [ i ] ; } return main_cb ( undefined , data ) ; }
function ( cb ) { var app = createdApp || apps [ 0 ] ; if ( app ) { fh . config . list ( options , app . guid , "all" , function ( error , data ) { console . log ( arguments ) ; cb ( error ) ; } ) ; } else { console . log ( "No apps to read" ) ; } }
function ( data ) { this . _super ( data ) ; data . report = repl ( "<a href=\"#!Report2/%(ref_doctype)s/%(name)s\">\ 								%(name)s</a>" , data ) ; }
function ( data ) { this . _super ( data ) ; data . report = repl ( "<a href=\"#!Report/%(doc_type)s/%(criteria_name)s\">\ 								%(criteria_name)s</a>" , data ) ; data . edit = repl ( "<a href=\"#!Form/Search Criteria/%(name)s\">Edit</a>" , data ) ; }
function ( msg ) { if ( typeof msg === 'object' && msg . message ) { msg = { type : msg . type , message : msg . message , stack : msg . stack , stackArray : msg . stack . split ( '\n' ) . slice ( 1 ) . map ( trim ) } ; } else { msg = { message : msg } ; } return { error : msg } ; }
function ( ) { var $btn = $ ( this ) ; var $element = $btn . siblings ( '.element' ) ; $btn . css ( 'margin-top' , ( $element . height ( ) - $btn . height ( ) ) / 2 ) ; }
function ( event ) { event . preventDefault ( ) ; var $target = $ ( event . currentTarget ) ; var $element = $target . siblings ( '.element' ) . clone ( ) ; $element . removeClass ( 'element' ) . addClass ( 'live-element' ) ; this . trigger ( 'createElement' , $element ) ; }
function ( ) { componentGroup . bind ( 'add' , this . addComponent , this ) ; componentGroup . bind ( 'reset' , this . addAllComponents , this ) ; this . bind ( 'closePopover' , this . resetActiveElement , this ) ; this . bind ( 'applyEdits' , this . applyEdits , this ) ; this . bind ( 'removeElement' , this . removeElement , this ) ; }
function wsp_test_func ( func , data , expect ) { let result_str = JSON . stringify ( func ( data ) ) ; let expect_str = JSON . stringify ( expect ) ; if ( result_str !== expect_str ) { do_throw ( "expect decoded value: '" + expect_str + "', got '" + result_str + "'" ) ; } }
function ( temp ) { Object . keys ( validators || { } ) . forEach ( function ( k ) { var v = validators [ k ] ; if ( v . constructor == Validator ) { temp [ k ] = { parse : v } ; } else temp [ k ] = clone ( v ) ; } ) ; return temp ; } ) ( { }
function ( volume ) { volume += self . getVolume ( ) ; if ( volume <= 0 ) { self . setVolume ( 0 ) ; } else if ( volume >= 100 ) { self . setVolume ( 100 ) ; } else { self . setVolume ( volume ) ; } }
function ( ) { if ( ++ count > 100 ) return clearInterval ( poll ) ; if ( CodeMirror . modes . hasOwnProperty ( mode ) ) { clearInterval ( poll ) ; loading [ mode ] = null ; ensureDeps ( mode , function ( ) { for ( var i = 0 ; i < list . length ; ++ i ) list [ i ] ( ) ; } ) ; } }
function ( fileName ) { var scripts = localStorage . getObject ( "scripts" ) ; if ( scripts != null ) { if ( typeof scripts [ fileName ] !== "undefined" ) { return scripts [ fileName ] ; } } if ( typeof Gibber . defaultScripts [ fileName ] !== "undefined" ) { return Gibber . defaultScripts [ fileName ] ; } else { window . alert ( "The file " + fileName + " is not found" ) ; return null ; } }
function analyseContent ( sourceCode ) { if ( sourceCode . match ( /<a href="viewstory\.php\?sid=\d+&amp;index=1">Table of Contents<\/a>/ ) ) { var sid = sourceCode . match ( /<div id="pagetitle"><a href="viewstory.php\?sid=(\d+)">/m ) [ 1 ] ; linkAdditionInfo = "http://www.yourfanfiction.com/viewstory.php?sid=" + sid + "&index=1&ageconsent=ok&warning=5" ; return true ; } return analyseIndex ( sourceCode ) ; }
function ( entry , left_val , do_raw ) { return ( [ "div" , [ "span" , [ "span" , "class" , "close-request-detail" , "handler" , "close-request-detail" , "tabindex" , "1" ] , "class" , "resize-request-detail" , "handler" , "resize-request-detail" ] , [ "div" , templates . _details_content ( entry , do_raw ) , "data-object-id" , String ( entry . id ) , "class" , "entry-details" ] , "class" , "network-details-container" , "style" , "left:" + left_val + "px" ] ) ; }
function ( ) { var entity , _i , _len , _ref ; _ref = window . game . entities ; for ( _i = 0 , _len = _ref . length ; _i < _len ; _i ++ ) { entity = _ref [ _i ] ; window . physics . world . DestroyBody ( entity . GetBody ( ) ) ; } window . game . entities = [ ] ; return window . game . load_state ( window . game . default_state ) ; }
function manipulating_exercise ( ) { $ ( '#myList' ) . append ( "<li>First</li><li>Second</li><li>Third</li><li>Fourth</li><li>Fifth</li>" ) ; $ ( '#myList li:nth-child(odd)' ) . remove ( ) ; $ ( 'div.module:last' ) . append ( '<h2></h2><p></p>' ) ; $ ( 'body' ) . find ( 'select' ) . append ( '<option>Monday</option>' ) ; $ ( 'div.module' ) . parent ( ) . append ( '<div class"module"></div>' ) . find ( 'div.module:last' ) . append ( $ ( 'img' ) [ 0 ] ) ; }
function ( ) { var mapStatus = { latitude : map . getCenter ( ) . lat ( ) , longitude : map . getCenter ( ) . lng ( ) , zoom : map . getZoom ( ) } ; $ . cookie ( 'mapStatus' , JSON . stringify ( mapStatus ) , { expires : cookieExpiration } ) ; }
function ( numLoaded ) { GEvent . removeListener ( loadMarkersListener ) ; var host = hosts [ uid ] ; if ( ! host ) { map . openInfoWindowHtml ( map . getCenter ( ) , Drupal . t ( "User's general location<br/>(Not currently available to host)" ) , { maxWidth : 220 } ) ; return ; } txt = makePopupHtml ( host ) ; host . marker . openInfoWindowHtml ( txt , { maxWidth : 220 } ) ; }
function ( ) { if ( this . opened ( ) ) return ; this . container . addClass ( "select2-dropdown-open" ) . addClass ( "select2-container-active" ) ; this . dropdown . detach ( ) . appendTo ( this . opts . element . parents ( "body" ) ) . addClass ( "select2-drop-active" ) ; this . positionDropdown ( ) ; this . updateResults ( true ) ; this . dropdown . show ( ) ; this . ensureHighlightVisible ( ) ; this . focusSearch ( ) ; }
function ( ) { return { doctype : this . doctype , fields : this . get_query_fields ( ) , filters : this . filter_list . get_filters ( ) , docstatus : this . can_submit ? $ . map ( this . $page . find ( '.show-docstatus :checked' ) , function ( inp ) { return $ ( inp ) . attr ( 'data-docstatus' ) } ) : [ ] , order_by : this . listview . order_by || undefined , } }
function ( ) { model . set ( { 'currentLevelNum' : model . get ( 'currentLevelNum' ) + 1 } ) ; model . loadMap ( 'level' + model . get ( 'currentLevelNum' ) ) ; infobox = new Infobox ( { 'text' : "Level " + model . get ( 'currentLevel' ) . get ( 'name' ) + " Push Space" , 'actionToTrigger' : 'LevelRestart' } ) ; }
function ( ) { if ( this . isDown ( 'SPACE' ) ) { if ( Crafty . isPaused ( ) ) { Crafty . pause ( ) ; } this . destroy ( ) ; Crafty . trigger ( model . get ( 'actionToTrigger' ) ) ; } }
function ( x , y , state ) { var graphView = this . graphViewForPane ( this . paneForState ( state ) ) ; var coords = graphView . graphCanvasView . axesView . inputAreaView . coordsForEvent ( { pageX : x , pageY : y } ) ; return graphView . pointForCoordinates ( coords . x , coords . y ) ; }
function ( actual , expected , place ) { if ( actual !== expected ) { throw Error ( "assert fail: " + place + "\n" + actual + " !== " + expected ) ; } }
function ( v , opts ) { if ( opts && opts . adbs ) this . _adbs = true ; else if ( ! opts || opts . adbs === undefined ) this . _adbs = false ; if ( ! v ) { if ( this . _adbs ) { this . _adbs = false ; } else if ( opts && ! opts . adbs ) return this . _disabled ; } return v ; }
function ( v , opts ) { if ( opts && opts . adbs ) this . _adbs = true ; else if ( ! opts || opts . adbs === undefined ) this . _adbs = false ; if ( ! v ) { if ( this . _adbs ) this . _adbs = false ; else if ( opts && ! opts . adbs ) return this . _disabled ; } return v ; }
function ( thread , callback ) { var self = this ; async . waterfall ( [ function ( callback ) { self . client . collection ( 'threads' , callback ) ; } , function ( collection , callback ) { collection . insert ( thread , callback ) ; } , function ( docs , callback ) { thread . id = docs [ 0 ] . _id ; callback ( null , thread ) ; } ] , callback ) ; }
function ( collection , callback ) { collection . find ( { $or : [ { _id : new ObjectID ( id ) } , { parentID : id } , { parents : id } ] } , { } , callback ) ; }
function ( msgText , author , parentThread ) { this . msgText = msgText ; this . author = author ; if ( parentThread ) { this . parentID = parentThread . id ; this . parents = [ ] ; this . parents . push ( parentThread . id . toString ( ) ) ; this . parents = this . parents . concat ( parentThread . parents ) ; } else { this . parentID = null ; this . parents = [ ] ; } this . child = [ ] ; }
function ( data ) { var ul = $ ( ".thread[data-id=" + editor . find ( 'input#rootID' ) . val ( ) + "]>ul" ) ; console . log ( ul ) ; if ( ul . length == 1 ) { ul . append ( $ ( "<li>" , { html : data } ) ) ; } else { console . log ( data ) ; comments . append ( data ) ; } }
function ( error ) { if ( error ) { test . ok ( false ) ; test . done ( ) ; } done ( ) ; }
function ( test ) { console . log ( 'testThreadConstructor' ) ; var thread = new t . Thread ( "msg" , 'author' , null ) , secondThread = new t . Thread ( "msg" , 'author' , 1 ) ; test . equals ( thread . parentID , null ) ; test . equals ( secondThread . parentID , 1 ) ; test . done ( ) ; }
function ( ) { if ( this . whichView === "hintable" ) { this . containerHintable . classList . remove ( "hidden" ) ; this . containerPropvals . classList . add ( "hidden" ) ; this . myHintable . start ( ) ; } else { this . containerHintable . classList . add ( "hidden" ) ; this . containerPropvals . classList . remove ( "hidden" ) ; this . _showTweener ( ) ; } }
function ( pokemon ) { if ( ! pokemon . volatiles [ 'illusion' ] ) { for ( i = pokemon . side . pokemon . length - 1 ; i > pokemon . position ; i -- ) { if ( ! pokemon . side . pokemon [ i ] ) continue ; if ( ! pokemon . side . pokemon [ i ] . fainted ) break ; } pokemon . illusion = pokemon . side . pokemon [ i ] ; } }
function printResult ( result , wasThrown ) { if ( ! result ) return ; if ( ! showResultOnly ) { this . prompt . pushHistoryItem ( text ) ; WebInspector . settings . consoleHistory . set ( this . prompt . historyData . slice ( - 30 ) ) ; } this . _appendConsoleMessage ( new WebInspector . ConsoleCommandResult ( result , wasThrown , commandMessage , this . _linkifier ) ) ; }
function ( event ) { if ( this . _javaScriptSource . isDirty ( ) ) return ; if ( event . button != 0 || event . altKey || event . ctrlKey || event . metaKey ) return ; var target = event . target . enclosingNodeOrSelfWithClass ( "webkit-line-number" ) ; if ( ! target ) return ; var lineNumber = target . lineNumber ; this . _toggleBreakpoint ( lineNumber , event . shiftKey ) ; event . preventDefault ( ) ; }
function ( snippetJavaScriptSource ) { var snippet = this . _snippetStorage . snippetForId ( snippetJavaScriptSource . snippetId ) ; this . _snippetStorage . deleteSnippet ( snippet ) ; this . _releaseSnippetScript ( snippetJavaScriptSource ) ; delete this . _snippetJavaScriptSourceForSnippetId [ snippet . id ] ; this . _snippetScriptMapping . _fireUISourceCodeRemoved ( snippetJavaScriptSource ) ; }
function ( snippetJavaScriptSource ) { this . _releaseSnippetScript ( snippetJavaScriptSource ) ; var evaluationIndex = this . _lastSnippetEvaluationIndexSetting . get ( ) + 1 ; this . _lastSnippetEvaluationIndexSetting . set ( evaluationIndex ) ; var snippet = this . _snippetStorage . snippetForId ( snippetJavaScriptSource . snippetId ) ; var sourceURL = this . _sourceURLForSnippet ( snippet , evaluationIndex ) ; snippet . _lastEvaluationSourceURL = sourceURL ; var expression = "\n//@ sourceURL=" + sourceURL + "\n" + snippet . content ; WebInspector . evaluateInConsole ( expression , true ) ; }
function ( rawLocation ) { var uiSourceCode = this . _uiSourceCodeForScriptId [ rawLocation . scriptId ] ; if ( uiSourceCode . isSnippet ) { var uiLineNumber = rawLocation . lineNumber - WebInspector . ScriptSnippetModel . evaluatedSnippetExtraLinesCount ; return new WebInspector . UILocation ( uiSourceCode , uiLineNumber , rawLocation . columnNumber || 0 ) ; } return new WebInspector . UILocation ( uiSourceCode , rawLocation . lineNumber , rawLocation . columnNumber || 0 ) ; }
function ( uiSourceCode , lineNumber , columnNumber ) { var script = this . _scriptForUISourceCode . get ( uiSourceCode ) ; if ( ! script ) return null ; if ( uiSourceCode . isSnippet ) { var rawLineNumber = lineNumber + WebInspector . ScriptSnippetModel . evaluatedSnippetExtraLinesCount ; return WebInspector . debuggerModel . createRawLocation ( script , rawLineNumber , columnNumber ) ; } return WebInspector . debuggerModel . createRawLocation ( script , lineNumber , columnNumber ) ; }
function ( snippetJavaScriptSource ) { var script = this . _scriptForUISourceCode . get ( snippetJavaScriptSource ) ; if ( ! script ) return ; delete this . _uiSourceCodeForScriptId [ script . scriptId ] ; this . _scriptForUISourceCode . remove ( snippetJavaScriptSource ) ; this . _createUISourceCodeForScript ( script ) ; }
function ( data , textStatus , jqXHR ) { if ( data . length ) { $ ( ".domain_list" ) . empty ( ) ; $ . each ( data , function ( i , elem ) { $ ( "<li><a href=\"http://" + elem + "/\">" + elem + "</a></li>" ) . appendTo ( ".domain_list" ) ; } ) ; } else { $ ( ".ajax_not_found" ) . show ( ) ; } }
function ( accu , square ) { if ( square . tile && _ . find ( lettersTaken , function ( letter ) { return letter == square . tile . letter ; } ) ) { lettersTaken = _ . without ( lettersTaken , square . tile . letter ) ; accu . push ( square . tile ) ; square . placeTile ( null ) ; } return accu ; }
function ( ) { var obj = ko . toJS ( this ) ; return { id : obj . id , menu_item : obj . menuItem , amount : obj . amount } ; }
function ( ) { if ( ! $ ( this ) . val ( ) ) { if ( selector && selector . display ) return ; me . set_input_value ( '' ) ; } }
function ( ) { $ . ajax ( { url : "/" , type : "POST" , data : { raw : $ ( "textarea" ) . val ( ) } , success : function ( response ) { $ ( ".output" ) . html ( response ) ; } , error : function ( error ) { $ ( ".output" ) . text ( "Crap, something went wrong!" ) ; } } ) ; }
function ( Example ) { describe ( "test Example" , function ( ) { it ( "should be a function" , function ( ) { expect ( typeof Example ) . toEqual ( "function" ) ; } ) ; it ( "should return Example" , function ( done ) { expect ( Example ( ) ) . toEqual ( "Example" ) ; } ) ; } ) ; }
function ( str ) { var token , _i , _len , _ref ; _ref = [ 'snippet' , 'include' , 'partial' , 'raw' , 'html' , 'json' ] ; for ( _i = 0 , _len = _ref . length ; _i < _len ; _i ++ ) { token = _ref [ _i ] ; if ( str . slice ( 0 , token . length ) === token ) { return true ; } } return false ; }
function ( str ) { var token , _i , _len , _ref ; _ref = [ 'snippet' , 'include' , 'partial' , 'raw' , 'html' , 'json' ] ; for ( _i = 0 , _len = _ref . length ; _i < _len ; _i ++ ) { token = _ref [ _i ] ; if ( str . slice ( 0 , token . length ) === token ) { return true ; } } return false ; }
function ( rowid ) { var marker = hell . map . allmarkers [ $ ( '#tab' ) . jqGrid ( 'getRowData' , rowid ) . id ] ; if ( ! marker ) return true ; ; hell . map . panTo ( marker . getLatLng ( ) ) ; marker . openPopup ( ) ; return true ; }
function goToSelectTag ( event ) { var tagList = event . target . dataset . taglist ; var options = TAG_OPTIONS [ tagList ] ; fillTagOptions ( options , tagList , event . target ) ; navigation . go ( 'view-select-tag' , 'right-left' ) ; }
function ( ) { if ( this . showMeridian ) { if ( this . hour === 11 ) { this . toggleMeridian ( ) ; } else if ( this . hour === 12 ) { this . hour = 1 ; } } if ( this . hour === 23 ) { return this . hour = 0 ; } this . hour = this . hour + 1 ; }
function ( ) { if ( this . showMeridian ) { if ( this . hour === 1 ) { this . hour = 12 ; return this . toggleMeridian ( ) ; } } if ( this . hour === 0 ) { return this . hour = 23 ; } this . hour = this . hour - 1 ; }
function ( name ) { var $elems = this , e , layers , l ; for ( e = 0 ; e < $elems . length ; e += 1 ) { layers = $ ( $elems [ e ] ) . getLayers ( ) ; for ( l = 0 ; l < layers . length ; l += 1 ) { if ( layers [ l ] . group === name ) { layers . splice ( l , 1 ) ; } } } return $elems ; }
function ( ) { console . log ( $ ( window ) . innerWidth ( ) ) ; menuWidthCheck ( ) ; if ( ! mobile ) { menu . show ( ) ; searchBar . show ( ) ; } else { if ( changed ) { menu . hide ( ) ; searchBar . hide ( ) ; } } }
function ( ) { this . audioVideoView = new AudioVideoEditView ( { model : this . model . get ( "audioVideo" ) , } ) ; this . datumTagsView = new UpdatingCollectionView ( { collection : this . model . get ( "datumTags" ) , childViewConstructor : DatumTagEditView , childViewTagName : "li" , } ) ; this . datumFieldsView = new UpdatingCollectionView ( { collection : this . model . get ( "datumFields" ) , childViewConstructor : DatumFieldEditView , childViewTagName : "li" , childViewFormat : "datum" } ) ; }
function ( Backbone , Consultant ) { var DatumState = Backbone . Model . extend ( { initialize : function ( ) { } , defaults : { state : "Checked" , color : "success" , consultant : Consultant , showInSearchResults : true , selected : "" } , model : { consultant : Consultant } } ) ; return DatumState ; }
function Simulations ( node ) { if ( ! node ) { Y . error ( NAME + ': invalid target node' ) ; } this . node = node ; this . target = Y . Node . getDOMNode ( node ) ; START_PAGEX = this . node . getX ( ) + this . target . getBoundingClientRect ( ) . width / 2 ; START_PAGEY = this . node . getY ( ) + this . target . getBoundingClientRect ( ) . height / 2 ; }
function Simulations ( node ) { if ( ! node ) { Y . error ( NAME + ': invalid target node' ) ; } this . node = node ; this . target = Y . Node . getDOMNode ( node ) ; START_PAGEX = this . node . getX ( ) + this . target . getBoundingClientRect ( ) . width / 2 ; START_PAGEY = this . node . getY ( ) + this . target . getBoundingClientRect ( ) . height / 2 ; }
function Simulations ( node ) { if ( ! node ) { Y . error ( NAME + ': invalid target node' ) ; } this . node = node ; this . target = Y . Node . getDOMNode ( node ) ; START_PAGEX = this . node . getX ( ) + this . target . getBoundingClientRect ( ) . width / 2 ; START_PAGEY = this . node . getY ( ) + this . target . getBoundingClientRect ( ) . height / 2 ; }
function ( ) { var file_path = this . route_declaration_path_ ; if ( ! file_path ) { throw new Error ( 'Route declaration path not specified' ) ; } try { var declaration = DeclarationParser . parse ( this . route_declaration_path_ , this . type_handlers_ ) ; this . updateRoutes_ ( declaration ) ; this . isLoaded_ = true ; } catch ( err ) { throw new Error ( 'Error parsing the route declaration file: ' + err . message ) ; } }
function ( message , actual , expected ) { var passed = true ; if ( arguments . length == 2 ) { passed = actual ; } else { passed = actual == expected ; } if ( ! passed ) { throw new Exception ( message ) ; } }
function ( ) { var cancel = false ; if ( callback ) { cancel = callback ( ) ; } if ( cancel ) { return ; } dojo . disconnect ( handle ) ; dojo . disconnect ( handle2 ) ; myDialog . destroyRecursive ( ) ; }
function _selectStorage ( flag ) { var storage ; if ( typeof flag !== 'boolean' && flag !== undefined ) { throw new Error ( '2nd argument should be boolean' ) ; } else { if ( flag === true || flag === undefined ) { storage = localStorage ; } else { storage = sessionStorage ; } } return storage ; }
function put ( obj , flag ) { var storage = _selectStorage ( flag ) ; if ( typeof obj === 'object' && ! ( obj instanceof Array ) ) { for ( var i in obj ) { if ( obj . hasOwnProperty ( i ) ) { storage . setItem ( i , JSON . stringify ( obj [ i ] ) ) ; } } } else { throw new Error ( '1st argument should be object' ) ; } }
function get ( key , flag ) { var storage = _selectStorage ( flag ) , selectKey = storage . getItem ( key ) ; if ( typeof key === 'string' ) { if ( selectKey ) { return JSON . parse ( selectKey ) ; } else { return console . log ( 'This key is not in storage' ) ; } } else { throw new Error ( '1st argument should be string' ) ; } }
function remove ( key , flag ) { var storage = _selectStorage ( flag ) , selectKey = storage . getItem ( key ) ; if ( typeof key === 'string' ) { if ( selectKey ) { storage . removeItem ( key ) ; } else { console . log ( 'This key is not in storage' ) ; } } }
function is ( key , flag ) { var storage = _selectStorage ( flag ) , selectKey = storage . getItem ( key ) ; if ( typeof key === 'string' ) { if ( selectKey ) { return true ; } else { return false ; } } else { throw new Error ( '1st argument should be strings' ) ; } }
function ( node ) { this . release ( node ) ; delete node . parent . children [ node . id ] ; }
function ( full , prefix , root , _ , sep , _ , _ , suffix ) { root = root . replace ( /-/g , '--' ) ; root = root . replace ( /\./g , '-' ) ; root = encode ( root ) ; return ( prefix || '' ) + root + sep + options . serverAndPort + ( suffix || '' ) ; }
function ( ) { width = image . width ; height = image . height ; canvas = document . getElementById ( "obstacles" ) ; x = index * mul ; context = canvas . getContext ( "2d" ) ; context . drawImage ( image , x , y , frameSize , frameSize , xpos * mul + 7 , ypos * mul + 7 , frameSize , frameSize ) ; }
function ( ) { if ( ! options . inline ) { path_selector . show ( ) ; scroll_obj . bind ( '#' + KT . common . escapeId ( paths_id ) ) ; path_selector . hide ( ) ; } else { scroll_obj . bind ( '#' + KT . common . escapeId ( paths_id ) ) ; } }
function ( name ) { if ( regex ) { if ( name . match ( regex ) ) r . push ( addPrefix + name ) ; } else { r . push ( addPrefix + name ) ; } }
function ( str , version ) { var pattern ; if ( version == 3 || version == 'v3' ) { pattern = /[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i ; } else if ( version == 4 || version == 'v4' ) { pattern = /[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i ; } else { pattern = /[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i ; } return str . match ( pattern ) ; }
function ( deferred , apiAction ) { var api = new mw . Api ( ) ; var apiCall = this . getApiCallParams ( apiAction ) ; $ . extend ( apiCall , { usekeys : 1 } ) ; api . post ( apiCall , { ok : function ( response ) { deferred . resolve ( response ) ; } , err : function ( textStatus , response ) { deferred . reject ( textStatus , response ) ; } } ) ; }
function ( ) { var selector = this . get ( 'selector' ) ; return SC . CoreQuery ( selector ) . html ( ) ; }
function ( speed ) { this . targetSpeed = speed ; if ( this . targetSpeed === null ) { this . speedBug . hide ( ) ; this . targetSpeedDisplay . hide ( ) ; } else { this . speedBug . setY ( this . _calcSpeedBugY ( ) ) ; this . speedBug . show ( ) ; this . targetSpeedDisplay . setText ( pfd . zeroPad ( Math . round ( speed ) , 4 , ' ' ) ) ; this . targetSpeedDisplay . show ( ) ; } }
function ( altitude ) { this . altitude = altitude ; this . altitudeInst . setText ( pfd . zeroPad ( Math . round ( altitude ) , 3 , ' ' ) ) ; this . altitudeTape . setY ( altitude * 4 ) ; if ( this . altitudeBug . isVisible ( ) ) { this . altitudeBug . setY ( this . _calcAltitudeBugY ( ) ) ; } }
function ( altitude ) { this . targetAltitude = altitude ; if ( this . targetAltitude === null ) { this . altitudeBug . hide ( ) ; this . targetAltitudeDisplay . hide ( ) ; } else { this . altitudeBug . setY ( this . _calcAltitudeBugY ( ) ) ; this . altitudeBug . show ( ) ; this . targetAltitudeDisplay . setText ( pfd . zeroPad ( Math . round ( altitude ) , 4 , ' ' ) ) ; this . targetAltitudeDisplay . show ( ) ; } }
function ( mode ) { if ( mode != this . flightMode ) { this . flightMode = mode ; this . flightModeDisplay . setText ( mode ) ; this . flightModeRect . setWidth ( mode . length * this . options . fontSize ) ; this . flightModeRect . setAlpha ( 1.0 ) ; this . flightModeRect . show ( ) ; this . flightModeRect . transitionTo ( { alpha : 0.0 , duration : 10 , easing : 'ease-out' } ) ; } }
function ( source , sections , css ) { if ( css == null ) css = '' ; return template ( { title : baseFilename ( source ) , sections : sections , project : { name : options . name , menu : menu } , previewCSS : cssmin ( css ) + previewCSS , previewJS : previewJS } ) ; }
function ( ) { var number = new Text ( ) ; number . text = this . number ; number . color = '#000' ; number . font = 'bold 7px Arial' ; number . textAlign = 'center' ; number . textBaseline = 'middle' ; number . x = 0 ; number . y = 0 ; if ( this . isDown ) { number . rotation = 90 ; } else if ( this . isStunned ) { number . rotation = 180 ; } return number ; }
function ( ) { if ( ! this . renderCache ) { this . addChild ( this . renderShape ( ) ) ; this . addChild ( this . renderNumber ( ) ) ; this . x = ( this . location [ 0 ] * variables . gridUnit ) + variables . gridUnit / 2 - 0.5 ; this . y = ( this . location [ 1 ] * variables . gridUnit ) + variables . gridUnit / 2 - 0.5 ; this . renderCache = this ; } }
function ( i ) { thistext = $ ( this ) . text ( ) . replace ( /[ ]*$/ , '' ) . replace ( /^[ ]*/ , '' ) if ( thistext . match ( RegExp ( ltext ) ) ) el . push ( this ) }
function ( reg ) { if ( ! ctest . lastAlert ) { throw ( { may_appear_later : true , text : 'No alert yet' } ) } if ( reg ) { re = RegExp ( reg ) if ( ! re . match ( ctest . lastAlert ) ) throw ( { may_appear_later : false , text : 'Wrong alert found, waiting for' + reg + ', found ' + txt } ) } ctest . lastAlert = false ctest . nextAlert = undefined }
function ( reg ) { if ( ! ctest . lastPrompt ) { throw ( { may_appear_later : true , text : 'No prompt yet' } ) } if ( reg ) { re = RegExp ( reg ) if ( ! re . match ( ctest . lastPrompt ) ) throw ( { may_appear_later : false , text : 'Wrong prompt found, waiting for' + reg + ', found ' + txt } ) } ctest . lastPrompt = false ctest . nextPrompt = undefined }
function ( reg ) { if ( ! ctest . lastConfirm ) { throw ( { may_appear_later : true , text : 'No confirmation yet' } ) } ctestui . log ( 'confirm appeared with text: ' + ctest . lastConfirm ) ; if ( reg ) { re = RegExp ( reg ) if ( ! re . match ( ctest . lastConfirm ) ) throw ( { may_appear_later : false , text : 'Wrong confirm found, waiting for' + reg + ', found ' + txt } ) } ctest . lastConfirm = false ctest . nextConfirm = undefined }
function ( ) { try { ctest . execCommand ( command ) } catch ( e ) { if ( e . may_appear_later && ( ctest . notHereCounter > 0 ) ) { ctest . notHereCounter -= 1 ctest . setFunctionForNextRound ( doMyCommand ) return ; } if ( ! e . may_appear_later ) ctestui . log ( 'Error that is not solvable later' ) onFailure ( e ) } ctest . pageLoaded = false onSuccess ( ) }
function ( ) { ctestui . log ( 'docommand error try ' + ctest . notHereCounter + ', command ' + command ) try { ctest . execCommand ( command ) } catch ( e ) { ctest . pageLoaded = false ctest . errorOnNext = 0 onSuccess ( ) return } if ( ctest . notHereCounter > 0 ) { ctest . notHereCounter -= 1 ctest . setFunctionForNextRound ( doMyCommand ) return ; } onFailure ( { text : 'No error appeared' } ) }
function ( msg , ok ) { ctest . running = false if ( ok ) { $ ( 'body' ) . first ( ) . addClass ( 'all_test_passed' ) ctestui . log ( msg ) if ( ctest . atEnd ) ctest . atEnd ( ) } else { $ ( 'body' ) . first ( ) . addClass ( 'failed_tests' ) ctestui . log ( msg , 'error' ) } ctest . runningCycle = false throw ( { 'stop' : true } ) }
function ( txt ) { ctestui . log ( 'alert: ' + txt ) ; if ( ctest . lastAlert ) stopExecuting ( 'There was an unmanaged alert, and appeared a new one: ' + ctest . lastAlert ) ctest . lastAlert = txt ; }
function ( txt ) { ctestui . log ( 'prompt: ' + txt ) ; if ( ctest . lastPrompt ) stopExecuting ( 'There was an unmanaged prompt, and appeared a new one: ' + ctest . lastPrompt ) ctest . lastPrompt = txt ; return ctest . nextPrompt ; }
function stateIsValid ( state , obstacles ) { if ( ! ( state . p . x > 0 && state . p . x < CANVAS_WIDTH && state . p . y > 0 && state . p . y < CANVAS_HEIGHT ) ) return false ; return true ; }
function wf_loop ( ) { var leftDist = readDistSensors ( ) [ 0 ] ; var normal = leftDist - 100 ; if ( normal < - 10 ) { wfpow1 = .4 ; wfpow2 = - .4 ; } else if ( normal > 10 ) { wfpow1 = .4 ; wfpow2 = .6 ; } else { wfpow1 = .8 ; wfpow2 = .8 ; } setMotorPowers ( wfpow1 , wfpow2 ) ; }
function ( ) { var onejan = new Date ( this . getFullYear ( ) , 0 , 1 ) ; var week = Math . ceil ( ( ( ( this - onejan ) / 86400000 ) + onejan . getDay ( ) + 1 ) / 7 ) ; if ( week > 52 ) week = 1 ; return week ; }
function ( ) { var form = $ ( 'form#new_user' ) , password = form . find ( 'input#user_password' ) , confirmation = form . find ( 'input#user_password_confirmation' ) ; var label = $ ( 'label[for="user_password"]' ) ; password . val ( 'password' ) ; confirmation . trigger ( 'focusout' ) ; ok ( password . parent ( ) . hasClass ( 'field_with_errors' ) ) ; ok ( label . parent ( ) . hasClass ( 'field_with_errors' ) ) ; }
function ( ) { element . data ( 'changed' , true ) . isValid ( settings . validators ) ; }
function ( data , searchObj ) { if ( searchObj . searchQuery === '' ) { console . log ( "search query is empty" ) ; data . query . bool . must = [ { match_all : { } } ] ; } data . sort = [ { "commentCount" : { "order" : "desc" } } , { "title.untouched" : { "order" : "asc" } } ] ; return data ; }
function ( data , searchObj ) { if ( searchObj . searchQuery === '' ) { console . log ( "search query is empty" ) ; data . query . bool . must = [ { match_all : { } } ] ; } data . query . bool . must . push ( { "term" : { "user" : searchObj . user } } ) ; return data ; }
function ( result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , questions : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : "Object not found" } ) ) ; } }
function ( ) { chart . resetSvg ( ) ; if ( chart . dataAreSet ( ) ) { g = chart . generateSvg ( ) . append ( "g" ) . attr ( "transform" , "translate(" + margin . left + "," + margin . top + ")" ) ; renderAxisX ( ) ; renderAxisY ( ) ; redrawBars ( ) ; renderBrush ( ) ; } return chart ; }
function ( ) { return chart . width ( ) - chart . margins ( ) . left - chart . margins ( ) . right ; }
function finalBarWidth ( ) { var w = Math . floor ( chart . axisXLength ( ) / xUnits ( x . domain ( ) [ 0 ] , x . domain ( ) [ 1 ] ) . length ) ; if ( isNaN ( w ) || w < MIN_BAR_WIDTH ) w = MIN_BAR_WIDTH ; return w ; }
function ( ) { chart . resetSvg ( ) ; if ( chart . dataAreSet ( ) ) { chart . generateG ( ) ; chart . renderAxisX ( chart . g ( ) ) ; chart . renderAxisY ( chart . g ( ) ) ; redrawBars ( ) ; chart . renderBrush ( chart . g ( ) ) ; } return chart ; }
function finalBarWidth ( ) { var w = Math . floor ( chart . axisXLength ( ) / chart . xUnits ( ) ( chart . x ( ) . domain ( ) [ 0 ] , chart . x ( ) . domain ( ) [ 1 ] ) . length ) ; if ( isNaN ( w ) || w < MIN_BAR_WIDTH ) w = MIN_BAR_WIDTH ; return w ; }
function ( ) { var min = d3 . min ( chart . group ( ) . all ( ) , function ( e ) { return e . value ; } ) ; if ( min > 0 ) min = 0 ; return min ; }
function ( ) { chart . resetSvg ( ) ; if ( chart . dataAreSet ( ) ) { chart . generateG ( ) ; chart . renderAxisX ( chart . g ( ) ) ; chart . renderAxisY ( chart . g ( ) ) ; redrawLine ( ) ; chart . renderBrush ( chart . g ( ) ) ; } return chart ; }
function ( ) { resetAllFilters ( ) ; d3 . select ( "body" ) . append ( "div" ) . attr ( "id" , "bar-chart3" ) ; var chart = dc . barChart ( "#bar-chart3" ) ; chart . dimension ( valueDimension ) . group ( valueGroup ) . width ( 400 ) . height ( 150 ) . x ( d3 . scale . linear ( ) . domain ( [ 10 , 80 ] ) ) . elasticAxisY ( true ) . transitionDuration ( 0 ) ; chart . render ( ) ; return chart ; }
function ( S , TheBrick ) { var config = S . merge ( { el : '#' + k , pagelet : self } , o . config ) ; var myBrick = new TheBrick ( config ) ; o . brick = myBrick ; self . _addBehavior ( o . bricks ) ; self . brickCount -- ; if ( self . brickCount == 0 ) { self . _fireReady ( ) ; } }
function ( event ) { if ( this . request . readyState == 4 ) { if ( this . request . status == 200 ) { this . responseText = this . request . responseText ; this . fireEvent ( 'complete' , this ) ; } else this . fireEvent ( 'error' , this , this . request . status ) ; this . request = undefined ; } }
function ( ) { var scoresToCalculate = [ ] ; var ratings = this . get ( 'ratings' ) ; for ( var i = 0 ; i < ratings . length ; i ++ ) { if ( ratings [ i ] . ignored === false || ratings [ i ] . ignored === undefined ) { scoresToCalculate . push ( ratings [ i ] . score ) ; } } return scoresToCalculate ; }
function ( ) { var scores = this . getScoresToCalculate ( ) ; var scoresSum = 0 ; var combinedRating = 0 ; for ( var i = 0 ; i < scores . length ; i ++ ) { scoresSum += scores [ i ] ; } if ( scores . length > 0 ) { combinedRating = scoresSum / scores . length ; } this . set ( 'combined_rating' , combinedRating ) ; }
function ( callback ) { if ( ! cfg . listingUrl ) { prompt . start ( ) ; prompt . get ( { properties : { listingUrl : { description : 'Enter the URL of the listing you want to purchase' } } } , function ( err , results ) { if ( err ) { return callback ( err ) ; } cfg . listingUrl = results . listingUrl ; callback ( ) ; } ) ; } else { callback ( ) ; } }
function ( callback ) { payswarm . purchase ( cfg . listingUrl , { transactionService : authority + 'transactions' , buyer : cfg . owner , source : cfg . source , publicKey : cfg . publicKey . id , privateKeyPem : cfg . publicKey . privateKeyPem } , callback ) ; }
function ( listing , hash , callback ) { var purchaseRequest = { '@context' : 'http://purl.org/payswarm/v1' , type : 'ps:PurchaseRequest' , identity : options . buyer , listing : listing . id , listingHash : hash , source : options . source } ; api . sign ( purchaseRequest , { publicKeyId : options . publicKey , privateKeyPem : options . privateKeyPem } , callback ) ; }
function ( ) { View . getMain ( ) . push ( 'settings' , new View . Object ( { title : 'Settings' , content : UI . render ( 'settings' , { user : LocalStorage . get ( 'User' ) } ) } ) ) ; }
function ( ) { View . getMain ( ) . push ( 'settings' , new View . Object ( { title : 'About' , content : UI . render ( 'about' , { version : version } ) } ) ) ; }
function ( ) { localStorage . settings = JSON . stringify ( { 'language' : this . language , 'enableTranslationTool' : this . enableTranslationTool , 'quality' : this . quality , 'announceTimeout' : this . announceTimeout } ) ; LoadingBar . show ( ) ; params = { flattr_automatically : this . flattr_automatically , send_new_follower_email : this . send_new_follower_email , send_new_subscriber_email : this . send_new_subscriber_email } ; $ . post ( '/me/settings' , params , function ( data ) { LoadingBar . hide ( ) ; } ) ; }
function findError ( script , lineNumber ) { var start = 0 ; var end = 1 ; for ( var i = 0 ; i < script . offsets . length ; i ++ ) { end = script . offsets [ i ] ; if ( lineNumber <= end ) { return { uri : script . requires [ i ] . fileURL , lineNumber : ( lineNumber - start ) } ; } start = end ; } return { uri : script . fileURL , lineNumber : ( lineNumber - end ) } ; }
function issuesPage ( ) { initIssuesSearch ( ) ; setSortable ( ) ; $ ( "#label_name" ) . chosen ( ) ; $ ( "#assignee_id" ) . chosen ( ) ; $ ( "#milestone_id" ) . chosen ( ) ; $ ( "#milestone_id, #assignee_id, #label_name" ) . on ( "change" , function ( ) { $ ( this ) . closest ( "form" ) . submit ( ) ; } ) ; }
function ( r , c ) { for ( var i = c ; i < cols ; i ++ ) { if ( grid [ r ] [ i ] ) return i - c ; } return cols - c ; }
function ( r , c ) { for ( var i = r ; i < rows ; i ++ ) { if ( grid [ i ] [ c ] ) return i - r ; } return rows - r ; }
function ( roomId ) { var html = '<div id="emailBody"><ul style="list-style:none;margin:0px;padding:0px;width:650px;">' ; var messages = Messages . find ( { roomId : roomId , archived : null } ) ; for ( message in messages ) { html += '<li class="' + message . role + '" style="border-bottom:1px solid #CCC;padding:4px;">' ; if ( message . role == 'host' ) { html += '<span style="color: #29642a;">' ; } html += '<strong>' + message . user + '</strong> <em>(' + message . timestamp + ')</em></span>: ' + message . content + '</li>' ; } html += '</ul></div>' ; return html ; }
function ( ) { if ( this . options . allow_single_deselect && dojo . query ( 'abbr' , this . selected_item ) . length < 1 ) { dojo . create ( 'abbr' , { class : 'search-choice-close' } , dojo . query ( 'span' , this . selected_item ) . shift ( ) ) ; } }
function ( terms ) { var no_results_html = dojo . create ( 'li' , { class : 'no-results' , innerHTML : this . results_none_found + ' "<span></span>" ' } , this . search_results ) ; dojo . query ( 'span' , no_results_html ) . shift ( ) . innerHTML = terms ; }
function evaluatePostFix_inner ( token ) { if ( ! this . isOperator ( token ) ) { stack . push ( token ) ; } else { var op2 = stack . pop ( ) ; var op1 = stack . pop ( ) ; var result = this . evaluate [ token ] ( op1 , op2 ) ; if ( isNaN ( result ) ) throw { type : 'error' , msg : 'Value is ' + result } ; stack . push ( result ) ; } }
function ( evt ) { var firstCellElement = $element . children ( 'li:first-child' ) [ 0 ] ; if ( firstCellElement ) firstCellElement . tableViewCell . setIndex ( 0 ) ; } ) . bind ( SKScrollEventType . DidScrollToTop , function ( evt ) { self . reloadData ( ) ; }
function ( ) { var numberOfRows = this . _numberOfRows ; var visibleCellCount = Math . min ( this . getCalculatedNumberOfVisibleCells ( ) , numberOfRows ) ; var hiddenCellCount = numberOfRows - visibleCellCount ; var scrollView = this . scrollView ; scrollView . setContentOffset ( { x : 0 , y : 0 } , false ) ; scrollView . setMargin ( { top : 0 , bottom : hiddenCellCount * this . getRowHeight ( ) } ) ; }
function resolvePath ( filePath ) { var resolvedPath = mod . _findPath ( filePath , [ path . dirname ( state . currentPath ) ] . concat ( state . options . searchPaths ) ) ; if ( ! resolvedPath ) throw new Error ( 'Path ' + filePath + ' not found.' ) ; return fs . realpathSync ( resolvedPath ) ; }
function ( response ) { if ( response . error ) { $ ( '#pay-error' ) . show ( ) . find ( 'div' ) . text ( response . error ) ; installError ( product ) ; return ; } if ( response . receipt ) { data [ 'data' ] = { 'receipts' : [ response . receipt ] } ; } $ . when ( apps . install ( product , data ) ) . done ( installSuccess ) . fail ( installError ) ; }
function ( ) { if ( $ ( this ) . attr ( "value" ) == $id ) { $ ( this ) . css ( "display" , "none" ) ; if ( $ ( this ) . attr ( "selected" ) ) { $ ( this ) . siblings ( ) . attr ( "selected" , "selected" ) ; $ ( this ) . removeAttr ( "selected" ) ; } ; } }
function ( req , res ) { fs . readFile ( "public/images/favicon.ico" , function ( err , icon ) { if ( err ) { throw err ; } console . log ( "Favicon requested" ) ; res . writeHead ( 200 , { "Content-Type" : "image/x-icon" } ) ; res . end ( icon ) ; } ) }
function ( req , res , path ) { console . log ( "Variable route hit" ) ; fs . readFile ( "posts/" + path + ".md" , function ( err , data ) { if ( err ) { console . log ( "Variable route did not exist" ) ; res . writeHead ( 404 , { "Content-Type" : "text/plain" } ) ; return res . end ( "Error 404: " + req . url + " not found." ) ; } console . log ( "Var serving " + path ) ; res . end ( data ) ; } ) }
function ( fmt , obj , named ) { if ( ! fmt ) return "" ; if ( named ) { return fmt . replace ( /%\(\w+\)s/g , function ( match ) { return String ( obj [ match . slice ( 2 , - 2 ) ] ) } ) ; } else { return fmt . replace ( /%s/g , function ( match ) { return String ( obj . shift ( ) ) } ) ; } }
function playlistQueues_playlistQueuesDestroy ( playlistQueueId ) { var playlistQueue = $ ( "#playlist_queues tbody #" + playlistQueueId ) ; if ( playlistQueue . length > 0 ) { playlistQueue . remove ( ) ; $ ( "#playlist_queues tbody tr" ) . each ( function ( ) { $this = $ ( this ) var row = $this [ 0 ] . rowIndex ; $this . find ( "td.row_number" ) . html ( row ) ; } ) ; playlistQueues_renderTableEmptyMessage ( ) ; } }
function ( path , rules ) { var value ; rules = rules . split ( '\n' ) ; value = applyRules ( rules , path . slice ( 0 , path . indexOf ( sep ) + 1 ) , path ) ; if ( value . value === true ) { return deferred ( value . value ) ; } }
function ( popped , action_table_obj ) { $ ( document ) . one ( 'content_added' , function ( evt ) { NewmanLib . restore_form ( popped . form_data , $ ( '.change-form' ) , { } ) ; } ) ; $ ( document ) . one ( 'media_loaded' , function ( ) { popped . selection_callback ( popped . oid , { str : popped . str } ) ; } ) ; }
function ( ) { this . listItem . series . programId = Number ( SpinningWheel . getSelectedValues ( ) . keys [ 0 ] ) ; $ ( "#moveTo" ) . val ( SpinningWheel . getSelectedValues ( ) . values [ 0 ] ) ; this . swtoucheventproxy = null ; }
function ( route ) { route = expandRoute ( route , '.css' , context . css . root ) ; if ( ! route . match ( REMOTE_PATH ) ) { route = _this . options . servePath + _this . compileCSS ( route ) ; } if ( _this . options . pathsOnly ) return route ; return "<link rel='stylesheet' href='" + route + "'>" ; }
function ( ) { var _j , _len2 , _ref2 , _results ; _results = [ ] ; for ( _j = 0 , _len2 = chain . length ; _j < _len2 ; _j ++ ) { _ref2 = chain [ _j ] , filename = _ref2 . filename , js = _ref2 . js ; filename = stripExt ( filename ) + '.js' ; this . cache . set ( filename , js ) ; _results . push ( "/" + filename ) ; } return _results ; }
function ( ) { var questionPattern = /^Question \d+$/ for ( var i = 0 ; i < questionnaireViewModel . questions ( ) . length ; i ++ ) { var question = questionnaireViewModel . questions ( ) [ i ] ; if ( questionPattern . test ( question . title ( ) ) ) question . title ( "Question " + ( i + 1 ) ) ; } }
function ( done ) { var ok = false ; var server = VarnishEmu ( ) ; server . on ( 'listening' , function ( ) { var client = new varnish . VarnishClient ( '127.0.0.1' , server . address ( ) . port ) ; client . on ( 'connect' , function ( ) { ok = true ; } ) ; } ) ; setTimeout ( function ( ) { assert . ok ( ok ) ; server . close ( ) ; done ( ) ; } , 200 ) ; }
function ( done ) { var server = VarnishEmu ( ) server . on ( 'listening' , function ( ) { var queue = new varnish . VarnishQueue ( '127.0.0.1' , server . address ( ) . port ) ; for ( var i = 0 ; i < 5 ; ++ i ) { queue . run_cmd ( 'purge simon_is == the_best' ) ; } } ) ; setTimeout ( function ( ) { assert . equal ( 5 , server . commands ) ; done ( ) ; } , 100 ) ; }
function ( done ) { var queue = new varnish . VarnishQueue ( '127.0.0.1' , 1234 ) for ( var i = 0 ; i < 10 ; ++ i ) { queue . run_cmd ( 'purge simon_is == the_best' ) ; } var server = VarnishEmu ( null , 1234 ) setTimeout ( function ( ) { assert . equal ( 10 , server . commands ) ; done ( ) ; } , 2000 ) ; }
function ( req , res ) { if ( req . loggedIn ) { users . find ( { userid : req . session . auth . twitter . user . id_str } , function ( err , docs ) { console . log ( docs ) ; res . render ( 'index' , { title : 'langy.io' , user : docs , req : req } ) ; } ) ; } else { res . render ( 'error' , { title : 'error' , user : nobody , req : req } ) ; } }
function set_user ( req ) { }
function ( entries ) { var examples = [ ] ; for ( name in entries ) if ( entries . hasOwnProperty ( name ) ) { examples . push ( new JSSpec . Example ( name , entries [ name ] , this . beforeEach , this . afterEach ) ) ; } return examples ; }
function ( name , target , before , after ) { this . id = JSSpec . Example . id ++ ; this . name = name ; this . target = target ; this . before = before ; this . after = after ; }
function constructMemoizedTagReplacement ( dataBindAttributeValue , tagToRetain , templateEngine ) { var dataBindKeyValueArray = ko . jsonExpressionRewriting . parseObjectLiteral ( dataBindAttributeValue ) ; validateDataBindValuesForRewriting ( dataBindKeyValueArray ) ; var rewrittenDataBindAttributeValue = ko . jsonExpressionRewriting . insertPropertyAccessorsIntoJson ( dataBindKeyValueArray ) ; var applyBindingsToNextSiblingScript = "ko.templateRewriting.applyMemoizedBindingsToNextSibling(function() { \             return (function() { return { " + rewrittenDataBindAttributeValue + " } })() \         })" ; return templateEngine [ 'createJavaScriptEvaluatorBlock' ] ( applyBindingsToNextSiblingScript ) + tagToRetain ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . isArray ( obj ) ; assert . equal ( obj . length , 3 ) ; assert . equal ( obj [ 0 ] . key , 'bob' ) ; assert . equal ( obj [ 1 ] . key , 'mat' ) ; assert . equal ( obj [ 2 ] . key , 'tim' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . strictEqual ( obj . constructor , resources [ e ] . Author ) ; assert . instanceOf ( obj , resources [ e ] . Author ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . age , 30 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . age , 30 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . strictEqual ( obj . constructor , resources [ e ] . Creature ) ; assert . instanceOf ( obj , resources [ e ] . Creature ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . resource , 'Creature' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . age , 30 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . age , 30 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . notEqual ( obj . key , undefined ) ; assert . equal ( obj . age , 51 ) ; assert . equal ( obj . hair , 'white' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . length , 3 ) ; assert . equal ( obj [ 0 ] . key , 'bob' ) ; assert . equal ( obj [ 1 ] , null ) ; assert . equal ( obj [ 2 ] . key , 'tim' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . lengthOf ( obj , 2 ) ; assert . equal ( obj [ 0 ] . key , 'user/pavan/bullet' ) ; assert . equal ( obj [ 0 ] . name , 'bullet' ) ; assert . equal ( obj [ 1 ] . key , 'user/pavan/octonode' ) ; assert . equal ( obj [ 1 ] . name , 'octonode' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . lengthOf ( obj , 2 ) ; assert . equal ( obj [ 0 ] . key , 'user/pavan/bullet' ) ; assert . equal ( obj [ 0 ] . name , 'bullet' ) ; assert . equal ( obj [ 1 ] . key , 'user/pavan/octonode' ) ; assert . equal ( obj [ 1 ] . name , 'octonode' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'christian' ) ; assert . equal ( obj . name , 'christian' ) ; assert . equal ( obj . resource , 'User' ) ; assert . lengthOf ( obj . repository_ids , 2 ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'marak' ) ; assert . equal ( obj . name , 'marak' ) ; assert . equal ( obj . resource , 'User' ) ; assert . lengthOf ( obj . repository_ids , 2 ) ; assert . lengthOf ( obj . follower_ids , 2 ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj [ 0 ] . key , 'user/pavan/bullet' ) ; assert . equal ( obj [ 0 ] . name , 'bullet' ) ; assert . equal ( obj [ 1 ] . key , 'user/pavan/octonode' ) ; assert . equal ( obj [ 1 ] . name , 'octonode' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'christian' ) ; assert . equal ( obj . name , 'christian' ) ; assert . equal ( obj . resource , 'User' ) ; assert . include ( obj . repository_ids , 'issues' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'christian' ) ; assert . equal ( obj . name , 'christian' ) ; assert . equal ( obj . resource , 'User' ) ; assert . lengthOf ( obj . repository_ids , 2 ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'forum/forum/develop/nodejitsu/haibu' ) ; assert . equal ( obj . name , 'haibu' ) ; assert . equal ( obj . resource , 'Forum' ) ; assert . equal ( obj . forum_id , 'forum/develop/nodejitsu' ) ; assert . lengthOf ( obj . forum_ids , 0 ) ; }
function ( ) { options . locked = false ; if ( ! global ) { run . updateCSS ( domain ) ; delElement ( overlay . clearStyle ) ; document . removeEventListener ( 'keypress' , press , false ) ; delete options . stop ; delElement ( overlay ) ; } else { delete options . stop ; self . close ( ) ; } }
function ( index , li ) { var link = $ ( li ) . children ( "a" ) ; if ( link . length ) { var idSelector = link . attr ( "href" ) ; tabIds2Tab [ idSelector ] = $ ( li ) ; if ( index == 0 ) firstTab = idSelector ; link . click ( function ( ) { showTab ( idSelector ) ; return false ; } ) ; } }
function ( ) { var containerElement , containerData ; containerElement = $ ( this ) ; containerData = containerElement . data ( 'jqae' ) ; if ( ( containerData . containerWidth != containerElement . innerWidth ( ) ) || ( containerData . containerHeight != containerElement . innerHeight ( ) ) ) { ellipsisOnElement ( containerElement , liveUpdatingTargetSelectors [ targetSelector ] ) ; } }
function findFirstLiWithPositionAfter ( ul , targetPosition ) { var children = ul . children ( "li" ) ; for ( var i = 0 ; i < children . length ; i ++ ) { var liPosition = parseFloat ( $ ( children [ i ] ) . attr ( "data-position" ) ) ; if ( liPosition > targetPosition ) { return $ ( children [ i ] ) ; } } return null ; }
function createAddNewStoryMessage ( ul , newStoryName ) { var newPosition = 0 ; var lastLi = ul . children ( "li" ) . last ( ) ; if ( lastLi . length === 1 ) { newPosition = parseFloat ( lastLi . attr ( "data-position" ) ) + 10 ; } var addNewStoryMessage = { MessageId : newGuid ( ) , MessageType : "AddNewStory" , StoryId : newGuid ( ) , Name : newStoryName , ListId : ul . attr ( "data-id" ) , Position : newPosition } ; return addNewStoryMessage ; }
function createChangeOrRemoveStoryMessage ( li , newStoryName ) { var storyId = $ ( li ) . attr ( "data-id" ) ; if ( newStoryName === "" || newStoryName === null ) { var removeStoryMessage = { MessageId : newGuid ( ) , MessageType : "RemoveStory" , StoryId : storyId } ; return removeStoryMessage ; } var changeStoryNameMessage = { MessageId : newGuid ( ) , MessageType : "ChangeStoryName" , StoryId : storyId , Name : newStoryName } ; return changeStoryNameMessage ; }
function ( ) { modelClass = Ember . Object . extend ( Ember . Validations ) ; model = modelClass . create ( { validations : { name : { customPresence : { validator : function ( obj , attr , val ) { if ( ! val ) { obj . get ( 'errors' ) . add ( attr , "is empty" ) ; } } } } } } ) }
function ( ) { var validate = function ( ) { } ; var validator = Ember . Validators . getValidator ( 'foo' , { validator : validate , options : { opt : 'yes' } } ) ok ( Ember . Validator . detectInstance ( validator ) , "should be an instance of Validator" ) ; equal ( validator . get ( 'validate' ) , validate , "should set validate method from options" ) ; equal ( validator . getPath ( 'options.opt' ) , 'yes' , "should set validator options" ) ; }
function ( err ) { if ( this . error ) { return ; } this . error = err ; this . pause ( ) ; this . emit ( 'error' , err ) ; }
function ( headerValue ) { var m = headerValue . match ( /filename="(.*?)"($|; )/i ) if ( ! m ) return ; var filename = m [ 1 ] . substr ( m [ 1 ] . lastIndexOf ( '\\' ) + 1 ) ; filename = filename . replace ( /%22/g , '"' ) ; filename = filename . replace ( /&#([\d]{4});/g , function ( m , code ) { return String . fromCharCode ( code ) ; } ) ; return filename ; }
function ( filename ) { var name = '' ; for ( var i = 0 ; i < 32 ; i ++ ) { name += Math . floor ( Math . random ( ) * 16 ) . toString ( 16 ) ; } if ( this . keepExtensions ) { var ext = path . extname ( filename ) ; ext = ext . replace ( /(\.[a-z0-9]+).*/ , '$1' ) name += ext ; } return path . join ( this . uploadDir , name ) ; }
function writeGameScreen ( ) { drawGameScreen ( ) ; drawStatusBar ( ) ; }
function deleteAll ( messages ) { for ( var i = 0 ; i < messages . length ; i ++ ) { if ( messages [ i ] . delivery == 'sent' || messages [ i ] . delivery == 'received' ) { ThreadListUI . delNumList . push ( messages [ i ] . id ) ; } else { ThreadListUI . pendingDelList . push ( messages [ i ] ) ; } } }
function thui_updateHeaderData ( ) { var number = MessageManager . getNumFromHash ( ) ; ThreadUI . title . innerHTML = number ; ContactDataManager . getContactData ( number , function gotContact ( contact ) { if ( contact && contact . length > 0 ) { ThreadUI . title . innerHTML = contact [ 0 ] . name ; } } ) ; }
function thui_cleanForm ( ) { var inputs = this . view . querySelectorAll ( 'input[type="checkbox"]' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; } this . delNumList = [ ] ; }
function createFormRow ( text , value , idForElement , info ) { return '<label for="' + idForElement + '">' + text + '</label>' + '<div>' + '<input id="' + idForElement + '" class="reg_input" type="text" value="' + value + '" name="' + idForElement + '">' + '<br>' + '</div>' + '<span class="reg_info">' + info + '</span>' ; }
function enableControls ( ) { this . controls . search . removeAttribute ( "disabled" ) ; this . controls . exp . removeAttribute ( "disabled" ) ; this . controls . show . removeAttribute ( "disabled" ) ; this . controls . launch . removeAttribute ( "hidden" ) ; this . controls . launch . setAttribute ( "label" , _ ( "oqs.relaunch" ) ) ; }
function ( ) { if ( this . showMeridian ) { if ( this . hour === 12 ) { this . hour = 1 ; return this . toggleMeridian ( ) ; } } if ( this . hour === 23 ) { return this . hour = 0 ; } this . hour = this . hour + 1 ; }
function formatQuestion ( question ) { return "<div class='question'>" + "<div class='questionText'>" + question . _source . body + "</div>" + "<div class='questionData'>" + "<div class='profResponsesRecent'>5 <img src='../images/rqra/prof.png' alt='Instructor Responses'/></div>" + "<div class='replies'>" + question . _source . commentCount + " <img src='../images/rqra/reply.png' alt='Replies'/></div>" + "<div class='views'>" + question . _source . viewCount + " <img src='../images/rqra/view.png' alt='Views'/></div>" + "<div>Asked " + "<span class='inserted'>" + jQuery . timeago ( new Date ( question . _source . timestamp ) ) + "</span> " + "by <span class='inserted'>" + question . _source . user + "</span></div>" + "</div>" ; }
function formatComment ( comment ) { return "<div class='comment'>" + "<div class='questionText'>" + comment . _source . body + "</div>" + "<div class='questionData'>" + "<div>Asked " + "<span class='inserted'>" + jQuery . timeago ( new Date ( comment . _source . timestamp ) ) + "</span> " + "by <span class='inserted'>" + comment . _source . user + "</span></div>" + "<div class='votes'><img src='../images/rqra/up.png' alt='UpVotes'/>" + comment . _source . upvote + " <img src='../images/rqra/reply.png' alt='Replies'/></div>" + "<div class='votes'><img src='../images/rqra/down.png' alt='DownVotes'/>" + comment . _source . downvote + " <img src='../images/rqra/view.png' alt='Views'/></div>" + "</div>" ; }
function checkEmail ( ) { var str = document . forms [ 0 ] . Email . value ; if ( ( str == "" ) || ( str . length < 1 ) ) { alert ( "\nPlease enter your email." ) document . forms [ 0 ] . Email . focus ( ) ; return false ; } return true ; }
function ( repo ) { self . views . push ( new Github . Views . GithubRepo ( { el : '#github-projects' , model : repo } ) ) ; }
function ( ) { prop . uiCanvas = pCanvas ; prop . uiContex = pCanvas . getContext ( '2d' ) ; prop . uiContex . lineWidth = 5 ; prop . uiCanvas . onmousemove = onMouseMove ; prop . uiCanvas . onmousedown = onMouseDown ; prop . uiCanvas . onmouseup = onMouseUp ; }
function ( e ) { var paginator = this , host = this . _host , index = paginator . get ( INDEX ) ; paginator . cards [ index ] . scrollY = host . get ( 'scrollY' ) ; paginator . _optimize ( ) ; paginator . _uiEnable ( ) ; }
function ( x , y , duration , easing ) { duration = duration || 0 ; easing = easing || null ; this . scrollTo ( x , y , duration , easing ) ; }
function ( e ) { var sv = this , duration = e . duration , easing = e . easing , val = e . newVal , currentX = sv . get ( SCROLL_X ) , currentY = sv . get ( SCROLL_Y ) ; if ( e . src !== UI ) { if ( e . attrName == SCROLL_X ) { this . _uiScrollTo ( val , currentY , duration , easing ) ; } else { this . _uiScrollTo ( currentX , val , duration , easing ) ; } } }
function ExportMap ( ) { log ( "Saving map..." ) ; var data = g_Map . getMapData ( ) ; g_Environment . Water . WaterBody . Height = SEA_LEVEL - 0.1 ; data . Environment = g_Environment ; g_Camera . Position = { x : g_MapSettings . Size * 2 , y : g_MapSettings . Size * 2 , z : - g_MapSettings . Size * 2 } ; data . Camera = g_Camera ; RMS . ExportMap ( data ) ; }
function addComment ( start , end , type , value ) { assert ( typeof start === 'number' , 'Comment must have valid position' ) ; if ( extra . comments . length > 0 ) { if ( extra . comments [ extra . comments . length - 1 ] . range [ 1 ] > start ) { return ; } } extra . comments . push ( { range : [ start , end ] , type : type , value : value } ) ; }
function ( ) { if ( $ ( this ) . attr ( 'data-protocol' ) === 'http' ) { var portNum = $ ( '.js-portNum.js-http' ) . val ( ) ; tabs . makeNew ( $ ( this ) . attr ( 'data-protocol' ) , portNum ) ; } makeRequest ( $ ( this ) . attr ( 'data-protocol' ) ) ; }
function ( ) { var protocol = $ ( this ) . parent ( ) . attr ( 'data-protocol' ) , port = $ ( this ) . parent ( ) . find ( 'a' ) . html ( ) ; socket . emit ( 'kill' + protocol , port ) ; tabs . closeTab ( port , this ) ; }
function ( num , protocol ) { options . body = 'Closed Connection on ' + num ; options . cssClass = 'css-streamCloseConnection' ; visual . stateChange ( protocol , num , false ) ; options . protocol = protocol ; injectMessage ( options , 'default' ) ; injectMessage ( options , num ) ; }
function ( e ) { if ( e . code == 'EADDRINUSE' ) { console . log ( 'Address in use, retrying...' ) ; setTimeout ( function ( ) { listener . close ( ) ; listener . listen ( request . params . portNum , function ( ) { console . log ( 'server re-bound to ' + request . params . portNum ) ; success . listening = true ; response . json ( success ) ; response . end ( ) ; } ) ; } , 1000 ) ; } else console . log ( 'other error ' , e ) ; }
function ( ) { _ . bindAll ( this , 'render' ) ; this . collection . bind ( 'reset' , this . render ) ; this . collection . bind ( 'add' , this . render ) ; this . collection . bind ( 'remove' , this . render ) ; this . collection . bind ( 'change:ps' , this . render ) ; this . collection . bind ( 'change:nt' , this . render ) ; this . collection . bind ( 'change:ng' , this . render ) ; }
function ( ) { var ieRange , endRange , startRange , range , sel ; range = rangy . createRange ( ) ; range . setStart ( this . startContainer , this . startOffset ) ; range . setEnd ( this . endContainer , this . endOffset ) ; sel = rangy . getSelection ( ) ; sel . setSingleRange ( range ) ; }
function ( data ) { var self = this ; data = data || { } ; if ( data . result == "error" ) { this . startLiveUpdates ( ) ; return ; } this . nextSince = data . nextSince || 0 ; this . refreshItemsDate ( ) ; this . checkTimeframeSatisfy ( ) ; this . applyLiveUpdates ( data . entries ) ; this . render ( "state" ) ; this . executeNextActivity ( ) ; this . startLiveUpdates ( ) ; }
function ( item , acc ) { var template = ( item . length > limit ) ? '<span title="{data:item}">{data:truncatedItem}</span>' : '<span>{data:item}</span>' ; var truncatedItem = $ . htmlTextTruncate ( item , limit , "..." ) ; acc . push ( self . substitute ( template , { "item" : item , "truncatedItem" : truncatedItem } ) ) ; }
function ( element , dom ) { var self = this ; var get = function ( field ) { return ( self . data [ field ] . name || "" ) . toLowerCase ( ) ; } ; if ( get ( "source" ) == get ( "provider" ) ) return ; this . render ( "viaText" , element , dom , { "label" : "via" , "field" : "provider" } ) ; }
function ( element ) { var self = this ; element . unbind ( "click" ) . click ( function ( ) { self . textExpanded = ! self . textExpanded ; self . rerender ( [ "body" , "textToggleTruncated" ] ) ; } ) ; return this . labels . get ( "textToggleTruncated" + ( this . textExpanded ? "Less" : "More" ) ) ; }
function ( $0 , $1 , $2 , $3 , $4 ) { if ( $1 ) { var content = tags2meta ( $3 ) ; content . text = insertHashTags ( content . text ) ; $0 = $2 + meta2tags ( content ) + $4 ; } tags . push ( $0 ) ; return ' %%HTML_TAG%% ' ; }
function ( path ) { var xmlHttp = new XMLHttpRequest ( ) ; xmlHttp . open ( 'GET' , path , false ) ; xmlHttp . send ( null ) ; if ( xmlHttp . status === 200 || xmlHttp . status === 0 ) { var dotIndex = path . lastIndexOf ( '.' ) ; if ( dotIndex === - 1 ) { dotIndex = path . length ; } return new Danmakufu ( xmlHttp . responseText , path . substr ( 0 , dotIndex ) ) ; } return null ; }
functionsToSymbols = function ( functions ) { var arr = [ ] ; for ( var i in functions ) { if ( functions . hasOwnProperty ( i ) ) { arr . push ( { name : i , func : functions [ i ] } ) ; } } return arr ; }
function ( blocks , filename ) { this . blocks = blocks ; this . header = 'define(\'danmakufu/' + filename + '\', function(require) {\n' + 'var __functions__ = require(\'Functions\');\n' + 'var Container = {};\n' this . footer = 'return Container;\n});' ; this . variables = [ ] ; this . result = JSBeautify ( this . header + this . addJSBlock ( 0 ) + this . footer , { indent_size : 2 , keep_array_indentation : true } ) ; console . log ( this . result ) ; }
function ( ) { var zoom = svgCanvas . getZoom ( ) ; var x = ( workarea [ 0 ] . scrollLeft + workarea . width ( ) / 2 ) / zoom - svgCanvas . contentW ; var y = ( workarea [ 0 ] . scrollTop + workarea . height ( ) / 2 ) / zoom - svgCanvas . contentH ; svgCanvas . pasteElements ( 'point' , x , y ) ; }
function ( ) { if ( selectedElement != null ) { svgCanvas . convertToPath ( ) ; elems = svgCanvas . getSelectedElems ( ) svgCanvas . selectorManager . requestSelector ( elems [ 0 ] ) . selectorRect . setAttribute ( "display" , "none" ) ; svgCanvas . setMode ( "pathedit" ) path . toEditMode ( elems [ 0 ] ) ; svgCanvas . clearSelection ( ) ; } }
function ( dx , dy ) { if ( selectedElement != null || multiselected ) { if ( curConfig . gridSnapping ) { var multi = svgCanvas . getZoom ( ) * curConfig . snappingStep ; dx *= multi ; dy *= multi ; } svgCanvas . moveSelectedElements ( dx , dy ) ; } }
function ( responseData ) { var mentionValues = _ . pluck ( this . mentionsCollection , 'value' ) ; responseData = _ . reject ( responseData , function ( item ) { return _ . include ( mentionValues , item . name ) ; } ) ; self . autoCompleter . populate ( responseData , query ) ; }
function ( ) { Ext . create ( 'Ext.Container' , { id : 'mainView' , fullscreen : true , layout : 'card' , items : [ { xclass : 'RaxaEmr.view.Login' } , { xclass : 'RaxaEmr.view.AppGrid' } , { xclass : 'RaxaEmr.view.AppCarousel' } ] } ) ; }
function ( ) { Util . saveBasicAuthHeader ( "admin" , "Hello123" ) ; if ( ! store ) { store = Ext . create ( 'Screener.store.Doctors' ) ; } expect ( store ) . toBeTruthy ( ) waitsFor ( function ( ) { return ! store . isLoading ( ) ; } , "load never completed" , timeout ) }
function ( ) { var placeholder = this . getPlaceholder ( ) ; if ( placeholder !== undefined && this . getVal ( ) . length === 0 && this . search . hasClass ( "select2-focused" ) === false ) { this . search . val ( placeholder ) . addClass ( "select2-default" ) ; this . search . width ( this . getContainerWidth ( ) ) ; } else { this . search . val ( " " ) . width ( 10 ) ; } }
function ( data ) { var i , results = [ ] , subResult ; if ( ! isADT ( data ) ) return f ( data ) ; for ( i = 1 ; i < data . length ; ++ i ) { subResult = recurse ( data [ i ] ) ; if ( typeof subResult !== 'undefined' ) results . push ( subResult ) ; } return f ( construct ( data [ 0 ] , results ) ) ; }
function ( data ) { var i , results = [ ] , subResult ; if ( ! isADT ( data ) ) return f ( data ) ; for ( i = 1 ; i < data . length ; ++ i ) { subResult = recurse ( data [ i ] ) ; if ( typeof subResult !== 'undefined' ) results . push ( subResult ) ; } return f ( construct ( data [ 0 ] , results ) ) ; }
function ( ) { delete blade . cb [ filename ] ; st . parentNode . removeChild ( st ) ; cb ( new Error ( "Timeout Error: Blade Template [" + filename + "] could not be loaded." ) ) ; }
function ( ) { if ( this . lastOrder ) { this . orderSend = new OrderList ( ) ; this . orderSend . url = '/orders/' + this . lastOrder . id ; this . orderSend . fetch ( ) ; return this . orderSend . on ( 'reset' , this . updateOrderStatus , this ) ; } }
function ( order ) { if ( order . sentAt === void 0 ) { return $ ( this . buttonSelector ) . removeClass ( 'btn-important' ) . addClass ( 'btn-success' ) . text ( 'Отправить заказ' ) ; } else { return $ ( this . buttonSelector ) . removeClass ( 'btn-success' ) . addClass ( 'btn-important' ) . text ( 'Заказ отправлен' ) ; } }
function isInternetExplorer ( ) { var rv = - 1 ; if ( navigator . appName == 'Microsoft Internet Explorer' ) { var ua = navigator . userAgent ; var re = new RegExp ( "MSIE ([0-9]{1,}[\.0-9]{0,})" ) ; if ( re . exec ( ua ) != null ) rv = parseFloat ( RegExp . $1 ) ; } return rv >= 8 ; }
function isFennec ( ) { try { return ( navigator . userAgent . indexOf ( 'Fennec/' ) != - 1 ) ; } catch ( e ) { } ; return false ; }
function cleanup ( ) { if ( iframe ) document . body . removeChild ( iframe ) ; iframe = undefined ; if ( w ) w . close ( ) ; w = undefined ; }
function onMessage ( e ) { removeListener ( window , 'message' , onMessage ) ; var d ; o = e . origin ; try { d = JSON . parse ( e . data ) ; } catch ( e ) { } if ( cb ) { setTimeout ( function ( ) { cb ( o , d . d , function ( r ) { cb = undefined ; doPost ( { a : 'response' , d : r } ) ; } ) ; } , 0 ) ; } }
function ( ) { if ( cb ) doPost ( { a : 'error' , d : 'client closed window' } ) ; cb = undefined ; try { window . close ( ) ; } catch ( e ) { } ; }
function isInternetExplorer ( ) { var rv = - 1 ; if ( navigator . appName == 'Microsoft Internet Explorer' ) { var ua = navigator . userAgent ; var re = new RegExp ( "MSIE ([0-9]{1,}[\.0-9]{0,})" ) ; if ( re . exec ( ua ) != null ) rv = parseFloat ( RegExp . $1 ) ; } return rv >= 8 ; }
function isFennec ( ) { try { return ( userAgent . indexOf ( 'Fennec/' ) != - 1 ) || ( userAgent . indexOf ( 'Firefox/' ) != - 1 && userAgent . indexOf ( 'Android' ) != - 1 ) ; } catch ( e ) { } ; return false ; }
function cleanup ( ) { if ( iframe ) document . body . removeChild ( iframe ) ; iframe = undefined ; if ( w ) w . close ( ) ; w = undefined ; }
function ( tabId , changeInfo , tab ) { updateMeta ( tab , tabId ) ; listUpdater ( tab ) ; console . log ( "=========debug=========                                       " ) ; }
function ( ) { var rel ; rel = $ ( this ) . attr ( 'rel' ) ; $ ( "#subscribe_email" ) . attr ( 'data-slug' , rel ) ; $ ( "#subscribe_form" ) . attr ( 'action' , "/subscribe/" + rel ) ; return $ ( "#subscribe" ) . modal ( 'show' ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 528 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 550 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 684 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function pm_init ( ) { window . addEventListener ( 'mozbrowseropenwindow' , this . open . bind ( this ) ) ; window . addEventListener ( 'mozbrowserclose' , this . close . bind ( this ) ) ; window . addEventListener ( 'home' , this . backHandling . bind ( this ) , true ) ; }
function ut_init ( ) { var touchEvents = [ 'touchstart' , 'touchmove' , 'touchend' ] ; touchEvents . forEach ( function bindEvents ( name ) { Mouse2Touch . addEventHandler ( window , name , this ) ; } , this ) ; window . addEventListener ( 'screenchange' , this ) ; window . addEventListener ( 'home' , this , true ) ; this . overlay . addEventListener ( 'transitionend' , this ) ; }
function nextAdaptive ( ) { count ++ ; if ( ! -- pending ) { var elapsed = timer . stop ( ) . elapsed ; if ( elapsed < duration ) { var add = Math . round ( count * ( duration / ( elapsed + 1 ) ) ) ; pending = add ; run ( ) ; } else { onFinish ( elapsed ) ; } } }
function ( config ) { var public , path ; path = require ( 'path' ) ; public = config . public ; if ( fs . existsSync ( public ) ) { return Ext . server . Connect . static ( public ) ; } return null ; }
function ( req ) { switch ( req . method . toLowerCase ( ) ) { case "get" : case "head" : case "del" : return true ; case "post" : case "put" : return false ; default : throw new Error ( "I don't support HTTP " + req . method + " method yet!" ) ; } }
function ( req , res , options ) { var hasBody , pipe , requestOpts ; options = makeDefaults ( options ) ; hasBody = reqHasBody ; requestOpts = buildRequestObject ( req , hasBody , options ) ; pipe = null ; if ( hasBody ) { pipe = req . pipe ( request ( requestOpts ) ) . pipe ( res ) ; } else { pipe = request ( requestOpts ) . pipe ( res ) ; } return handleError ( pipe , options . onError , req , res ) ; }
function _push ( message ) { if ( _activeRequest != null || _sse != null ) { _pushAjaxMessage ( message ) ; } else if ( _ieStream != null ) { _pushIE ( message ) ; } else if ( _jqxhr != null ) { _pushJsonp ( message ) ; } else if ( _websocket != null ) { _pushWebSocket ( message ) ; } }
function ( fn , interval ) { var timeoutId ; interval = interval || 0 ; ( function loop ( ) { timeoutId = setTimeout ( function ( ) { if ( fn ( ) === false ) { return ; } loop ( ) ; } , interval ) ; } ) ( ) ; return function ( ) { clearTimeout ( timeoutId ) ; } ; }
function rNewTab ( tabId , changeInfo , tab ) { if ( changeInfo . status == 'complete' ) { if ( tab . url . split ( 'oauth' ) . length > 1 ) { var appName = tab . url . split ( 'apps.facebook.com%2F' ) [ 1 ] . split ( '%2F' ) [ 0 ] ; var actions = tab . url . split ( 'scope=' ) . pop ( ) ; } } }
function ( ) { this . waitingPiece = this . createPiece ( ) ; this . playPiece = this . createPiece ( ) ; this . renderWaiting ( ) ; this . render ( ) ; var that = this ; this . time = window . setInterval ( $ . proxy ( this . gameLoop , this ) , 500 ) ; }
function ( e ) { if ( e . keyCode === 37 ) { if ( that . wallHit ( "left" ) === false ) { that . moveLeft ( ) ; } else { console . log ( 'wall hit' ) ; } } if ( e . keyCode === 39 ) { if ( that . wallHit ( "right" ) === false ) { that . moveRight ( ) ; } else { console . log ( 'wall hit' ) ; } } }
function ( ) { var allPieces = [ 'o' , 't' , 'i' , 'z' , 's' , 'l' , 'j' ] ; var piece = { } ; allPieces . shuffle ( ) ; var select = allPieces [ 0 ] [ 0 ] ; piece = tetris . pieces [ select ] ( ) ; piece . name = select ; piece . color = tetris . randomColor ( ) ; return piece ; }
function ( className ) { if ( className != showSelector ) { dom . hide ( "." + className + ":not(." + showSelector + ")" ) ; } }
function ( d ) { this . data = d ; this . events = d [ 'events' ] ; this . detailLevel = 4 ; this . isArgyled = false ; this . w = 800 ; this . h = 75 ; this . tickH = 20 ; this . margin = 5 ; this . dateFmtStr = "MMM D, YYYY" ; DateSpan . init ( d [ 'timezone' ] ) ; }
function ( regexp ) { var title = handlers [ regexp ] , config = this . config ; this . io . route ( new RegExp ( regexp , 'gi' ) , this , function ( info , cb ) { title . handler ( new RegExp ( regexp ) . exec ( info . message ) , cb ) ; } , title . formatter ) ; }
function ( stream ) { if ( params . resultStream ) { processors . cat . init ( function ( st ) { if ( ! st ) { onError ( "Cat returned unll stream" ) ; return ; } params . resultStream = st ; next ( ) ; } , context , params . resultStream , stream ) ; } else { params . resultStream = stream ; if ( ! params . resultStream ) { onError ( seg + " returned null stream" ) ; return ; } } next ( ) }
function ( tweet , tweetReqStatus ) { $ . ajax ( { url : 'http://api.twitter.com/1/statuses/oembed.json?' + 'id=' + tweet . id_str + 'omit_script=1' + '&hide_thread=1' , success : function ( embed , embedReqStatus ) { $ ( embed . html ) . prependTo ( '#rendered-tweets' ) ; if ( tweet . in_reply_to_status_id_str ) { $ . ajax ( { url : 'http://api.twitter.com/1/statuses/show/' + tweet . in_reply_to_status_id_str + '.json?' + 'trim_user=1' , success : loadConfabulatedTweets } ) ; } } } ) ; }
function renderDeliciousLinks ( items ) { var output = "<ul>" ; for ( var i = 0 , l = items . length ; i < l ; i ++ ) { output += '<li><a href="' + items [ i ] . u + '" title="Tags: ' + items [ i ] . t . join ( ', ' ) + '">' + items [ i ] . d + '</a></li>' ; } output += "</ul>" ; $ ( '#delicious' ) . html ( output ) ; }
function ( html , parse ) { if ( parse ) { html = this . parent . parse ( html ) ; } this . element . innerHTML = html ; }
function ( ) { initExistingVettingInterface ( ) ; initNewVettingInterface ( ) ; }
function ( key , value ) { if ( key === 'id' ) { this . loaded = true ; } if ( this . properties && this . properties [ key ] && this . properties [ key ] . set ) { value = this . properties [ key ] . set ( value , this . data [ key ] ) ; } this . data [ key ] = value ; return this ; }
function ( ) { ( new PB . Request ( { url : this . getUrl ( ) , async : false , method : this . get ( 'id' ) ? 'PUT' : 'POST' , data : { __data : JSON . stringify ( this . getPostData ( ) ) } } ) ) . send ( ) ; }
function ( ) { if ( ! this . get ( 'id' ) ) { return ; } ( new PB . Request ( { url : this . getUrl ( ) , async : false , method : 'DELETE' } ) ) . send ( ) ; }
function ( id ) { if ( ! this . name ) { throw new Error ( 'Model.name required' ) ; } if ( ! this . model ) { throw new Error ( 'Model.model required for ' + this . name ) ; } this . model . id = { type : 'number' } ; this . data = { } ; this . loaded = false ; if ( id !== undefined ) { this . set ( 'id' , id ) . read ( id ) ; } }
function ( key , value ) { if ( key === 'id' ) { this . loaded = true ; } if ( this . properties && this . properties [ key ] && this . properties [ key ] . set ) { value = this . properties [ key ] . set ( value , this . data [ key ] ) ; } this . data [ key ] = value ; return this ; }
function ( key ) { var value = this . data [ key ] ; if ( value === undefined ) { return null ; } if ( this . properties && this . properties [ key ] && this . properties [ key ] . get ) { value = this . properties [ key ] . get ( value ) ; } return value ; }
function ( ) { ( new PB . Request ( { url : this . getUrl ( ) , async : false , method : this . get ( 'id' ) ? 'PUT' : 'POST' , data : { __data : JSON . stringify ( this . getPostData ( ) ) } } ) ) . send ( ) ; }
function ( ) { if ( ! this . get ( 'id' ) ) { return ; } ( new PB . Request ( { url : this . getUrl ( ) , async : false , method : 'DELETE' } ) ) . send ( ) ; }
function ( accessKey , secretKey , securityToken ) { this . errorCount = 0 ; this . accessKey = accessKey ; this . secretKey = secretKey ; this . securityToken = typeof securityToken == "string" ? securityToken : "" ; debug ( 'setCreds: ' + this . accessKey + ", " + this . secretKey + ", " + this . securityToken ) }
function ( ) { var xhr = io . util . request ( ) , uri = this . resource + '/' + io . protocol + '/' + this . sessionid ; xhr . open ( 'GET' , uri , true ) ; this . onDisconnect ( 'booted' ) ; }
function scm_handleWakeLock ( topic , state ) { switch ( topic ) { case 'screen' : self . _screenWakeLocked = ( state == 'locked-foreground' ) ; if ( self . _screenWakeLocked ) { self . turnScreenOn ( ) ; } else { if ( self . _idled ) self . turnScreenOff ( false ) ; } break ; case 'cpu' : power . cpuSleepAllowed = ( state != 'locked-foreground' && state != 'locked-background' ) ; break ; case 'wifi' : break ; } }
function scm_setIdleTimeout ( time ) { if ( ! ( 'addIdleObserver' in navigator ) ) return ; if ( this . isIdleObserverInitialized ) { navigator . removeIdleObserver ( this . idleObserver ) ; } if ( ! time ) return ; this . idleObserver . time = time ; navigator . addIdleObserver ( this . idleObserver ) ; this . isIdleObserverInitialized = true ; }
function ( newAttr , silent ) { var _this = this ; _ . extend ( this . get ( 'attr' ) , newAttr ) ; if ( ! silent ) { this . save ( { } , { success : function ( ) { _this . trigger ( 'update' ) } } ) ; } }
function ( ) { var style = { 'backgroundColor' : this . attr . backgroundColor , 'height' : this . model . get ( 'attr' ) . height + '%' } $ ( this . el ) . css ( style ) ; this . model . trigger ( 'ready' , this . model . id ) return this ; }
function ( ev , ui ) { console . log ( "### " + minuteDelta ) ; minuteDelta = Math . round ( ( ui . position . top - origPosition . top ) / slotHeight ) * opt ( 'slotMinutes' ) ; if ( minuteDelta != prevMinuteDelta ) { if ( ! allDay ) { updateTimeText ( minuteDelta ) ; } prevMinuteDelta = minuteDelta ; } }
function updateTimeText ( minuteDelta ) { var newStart = addMinutes ( cloneDate ( event . start ) , minuteDelta ) ; var newEnd ; if ( event . end ) { newEnd = addMinutes ( cloneDate ( event . end ) , minuteDelta ) ; } timeElement . text ( formatDates ( newStart , newEnd , opt ( 'timeFormat' ) ) ) ; console . log ( "!!!!" ) ; }
function ( evt ) { if ( this . inRoundedMold ( ) && ! this . _buttonVisible ) return ; if ( ! this . _disabled && ! zk . animating ( ) ) { if ( this . _open ) this . close ( { focus : true , sendOnOpen : true } ) ; else this . open ( { focus : true , sendOnOpen : true } ) ; } evt . stop ( ) ; }
function ( evt ) { if ( ! this . _disabled ) { if ( evt . domTarget == this . getPopupNode_ ( ) ) this . close ( { focus : true , sendOnOpen : true } ) ; else if ( this . _readonly && ! this . isOpen ( ) && this . _buttonVisible ) this . open ( { focus : true , sendOnOpen : true } ) ; this . $supers ( 'doClick_' , arguments ) ; } }
function ( evt ) { if ( ! this . _disabled ) { this . _doMouseOut ( ) ; var cb = this . parent ; cb . _select ( this , { sendOnSelect : true , sendOnChange : true } ) ; this . _updateHoverImage ( ) ; cb . close ( { sendOnOpen : true } ) ; cb . _shallClose = true ; zk ( cb . getInputNode ( ) ) . focus ( ) ; evt . stop ( ) ; } }
function ( ctl , noUndo ) { val = ctl . value ; $ ( '#blur' ) . val ( val ) ; var complete = false ; if ( ! ctl || ! ctl . handle ) { $ ( '#blur_slider' ) . slider ( 'option' , 'value' , val ) ; complete = true ; } if ( noUndo ) { svgCanvas . setBlurNoUndo ( val ) ; } else { svgCanvas . setBlur ( val , complete ) ; } }
function ( ) { if ( $ ( this ) . find ( 'div' ) . length ) return ; var perc = parseInt ( $ ( this ) . text ( ) . split ( '%' ) [ 0 ] ) ; changeOpacity ( false , perc ) ; }
function ( ) { var linked = ! $ ( '#tool_node_link' ) . hasClass ( 'push_button_pressed' ) ; if ( linked ) $ ( '#tool_node_link' ) . addClass ( 'push_button_pressed' ) . removeClass ( 'tool_button' ) . find ( "input" ) . attr ( "checked" , true ) ; else $ ( '#tool_node_link' ) . removeClass ( 'push_button_pressed' ) . addClass ( 'tool_button' ) . find ( "input" ) . attr ( "checked" , false ) ; path . linkControlPoints ( linked ) ; }
function ( ) { let children = this . trash_file . enumerate_children ( '*' , 0 , null , null ) ; let child_info = null ; while ( ( child_info = children . next_file ( null , null ) ) != null ) { let child = this . trash_file . get_child ( child_info . get_name ( ) ) ; child . delete ( null ) ; } }
function checkMustAuth ( ) { var must_auth = true ; if ( uid && req . session . userid === uid ) { must_auth = false ; } else if ( ! uid && typeof req . session . pendingCreation === 'string' && req . query . token === req . session . pendingCreation ) { must_auth = false ; } res . json ( { success : true , email : email , must_auth : must_auth } ) ; }
function ( resp ) { var html , i ; if ( ! resp . error ) { initBuild ( resp ) ; } else { options . cssClass = 'css-streamError' ; for ( i = 0 ; i < resp . errors . length ; i = i + 1 ) { options . body += resp . errors [ i ] . message ; } } injectMessage ( options ) ; }
function ( ) { makeRequest ( $ ( this ) . attr ( 'data-protocol' ) ) ; }
function ( num , protocol ) { options . body = 'Closed Connection on ' + num ; options . cssClass = 'css-streamCloseConnection' ; visual . stateChange ( { active : false , protocol : protocol } ) ; options . protocol = protocol ; injectMessage ( options ) ; }
function ( ) { console . log ( 'Browser-Disconnected socket' ) ; options . cssClass = 'css-streamError' ; options . body = 'NetBug Server Down' ; options . protocol = 'all' ; injectMessage ( options ) ; options . active = false ; $ ( '.js-log.activeLog' ) . trigger ( 'click' ) ; visual . stateChange ( options ) ; }
function stateChange ( options ) { if ( options . protocol === 'all' ) { $ ( '.js-ui-tab-view.js-all' ) . addClass ( 'css-inactive' ) ; $ ( '.js-ui-tab-view.js-all' ) . removeClass ( 'css-active' ) ; } else { $ ( '.js-ui-tab-view[data-name="' + options . protocol + '"]' ) . toggleClass ( 'css-active' ) ; $ ( '.js-ui-tab-view[data-name="' + options . protocol + '"]' ) . toggleClass ( 'css-inactive' ) ; } }
function startListening ( request , response ) { var connectObj = connect . createServer ( ) . use ( getBody ) . use ( readHttp ) ; serverHttp = connectObj . listen ( request . params . portNum ) ; socketOpen = true ; currentHttpPort = request . params . portNum ; serverHttp . on ( 'close' , function ( ) { browserSocket . emit ( 'closedConnection' , request . params . portNum , 'http' ) ; socketOpen = false ; } ) ; response . end ( ) ; }
function toggleLog ( logpath ) { if ( ! isLoggingHttp ) { isLoggingHttp = true ; file . mkdir ( 'http' , currentHttpPort , logpath ) ; } else { isLoggingHttp = false ; if ( httpBuffer ) { writeFile ( logpath ) ; } } }
function ( protocol ) { if ( protocol === 'tcp' ) { tcpServer . writeFile ( logpath ) ; } else if ( protocol === 'http' ) { httpServer . writeFile ( logpath ) ; } else if ( protocol === 'udp' ) { udpServer . writeFile ( logpath ) ; } }
function $toNumber ( a ) { var result = parseFloat ( a ) ; if ( isNaN ( result ) || ! isFinite ( result ) ) { result = 0 ; } return result ; }
function ( options ) { if ( this instanceof jQuery ) { if ( ! options ) options = { } ; $ . extend ( true , options , { elements : this . get ( ) } ) ; } regula . bind ( options ) ; return this ; }
function ( ) { var inputElementId = "hiddenInput" ; var $input = createInputElement ( inputElementId ) ; var expectedExceptionMessage = new RegExp ( inputElementId + ".Pattern: You seem to have provided some optional or required parameters for @Pattern, but you are still missing the following 1 required parameters\\(s\\): regex" ) ; raises ( function ( ) { $input . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . Pattern } ] } ) ; } , expectedExceptionMessage , "@Pattern cannot be bound without its required parameter" ) ; deleteElement ( inputElementId ) ; }
function ( ) { var inputElementId = "hiddenInput" ; var $input = createInputElement ( inputElementId ) ; var expectedExceptionMessage = new RegExp ( inputElementId + ".Pattern: You seem to have provided some optional or required parameters for @Pattern, but you are still missing the following 1 required parameters\\(s\\): regex" ) ; raises ( function ( ) { $input . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . Pattern , params : { label : "test" } } ] } ) ; } , expectedExceptionMessage , "@Pattern cannot be bound without its required parameter" ) ; deleteElement ( inputElementId ) ; }
function ( ) { var inputElementId = "hiddenInput" ; var $input = createInputElement ( inputElementId ) ; var expectedExceptionMessage = new RegExp ( inputElementId + ".Pattern: You seem to have provided some optional or required parameters for @Pattern, but you are still missing the following 1 required parameters\\(s\\): regex" ) ; raises ( function ( ) { $input . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . Pattern , params : { message : "This is a test" } } ] } ) ; } , expectedExceptionMessage , "@Pattern cannot be bound without its required parameter" ) ; deleteElement ( inputElementId ) ; }
function ( ) { var inputElementId = "hiddenInput" ; var $input = createInputElement ( inputElementId ) ; var expectedExceptionMessage = new RegExp ( inputElementId + ".Pattern: You seem to have provided some optional or required parameters for @Pattern, but you are still missing the following 1 required parameters\\(s\\): regex" ) ; raises ( function ( ) { $input . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . Pattern , params : { groups : [ "Test" ] } } ] } ) ; } , expectedExceptionMessage , "@Pattern cannot be bound without its required parameter" ) ; deleteElement ( inputElementId ) ; }
function ( ) { var inputElementId = "hiddenInput" ; var $input = createInputElement ( inputElementId ) ; var expectedExceptionMessage = new RegExp ( inputElementId + ".Pattern: You seem to have provided some optional or required parameters for @Pattern, but you are still missing the following 1 required parameters\\(s\\): regex" ) ; raises ( function ( ) { $input . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . Pattern , params : { label : "test" , message : "this is a test" , groups : [ "Test" ] } } ] } ) } , expectedExceptionMessage , "@Pattern cannot be bound without its required parameter" ) ; deleteElement ( inputElementId ) ; }
function ( ) { var inputElementId = "hiddenInput" ; var $input = createInputElement ( inputElementId ) ; var expectedExceptionMessage = new RegExp ( inputElementId + ".Pattern: You seem to have provided some optional or required parameters for @Pattern, but you are still missing the following 1 required parameters\\(s\\): regex" ) ; raises ( function ( ) { $input . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . Pattern , params : { flags : "ig" } } ] } ) ; } , expectedExceptionMessage , "@Pattern cannot be bound without its required parameter" ) ; deleteElement ( inputElementId ) ; }
function ( ) { var inputElementId = "hiddenInput" ; var $input = createInputElement ( inputElementId ) ; var expectedExceptionMessage = new RegExp ( inputElementId + ".Pattern: You seem to have provided some optional or required parameters for @Pattern, but you are still missing the following 1 required parameters\\(s\\): regex" ) ; raises ( function ( ) { $input . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . Pattern , params : { flags : "ig" , label : "test" } } ] } ) ; } , expectedExceptionMessage , "@Pattern cannot be bound without its required parameter" ) ; deleteElement ( inputElementId ) ; }
function ( ) { var formElementId = "hiddenForm" ; var $form = createFormElement ( formElementId ) ; var expectedExceptionMessage = new RegExp ( formElementId + ".PasswordsMatch: You seem to have provided some optional or required parameters for @PasswordsMatch, but you are still missing the following 2 required parameters\\(s\\): field1, field2" ) ; raises ( function ( ) { $form . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . PasswordsMatch } ] } ) ; } , expectedExceptionMessage , "@PasswordsMatch cannot be bound without its required parameter" ) ; deleteElement ( formElementId ) ; }
function ( ) { var formElementId = "hiddenForm" ; var $form = createFormElement ( formElementId ) ; var expectedExceptionMessage = new RegExp ( formElementId + ".PasswordsMatch: You seem to have provided some optional or required parameters for @PasswordsMatch, but you are still missing the following 2 required parameters\\(s\\): field1, field2" ) ; raises ( function ( ) { $form . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . PasswordsMatch , params : { label : "test" } } ] } ) ; } , expectedExceptionMessage , "@PasswordsMatch cannot be bound without its required parameter" ) ; deleteElement ( formElementId ) ; }
function ( ) { var formElementId = "hiddenForm" ; var $form = createFormElement ( formElementId ) ; var expectedExceptionMessage = new RegExp ( formElementId + ".PasswordsMatch: You seem to have provided some optional or required parameters for @PasswordsMatch, but you are still missing the following 2 required parameters\\(s\\): field1, field2" ) ; raises ( function ( ) { $form . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . PasswordsMatch , params : { message : "this is a test" } } ] } ) ; } , expectedExceptionMessage , "@PasswordsMatch cannot be bound without its required parameter" ) ; deleteElement ( formElementId ) ; }
function ( ) { var formElementId = "hiddenForm" ; var $form = createFormElement ( formElementId , "@PasswordsMatch(groups=[Test])" ) ; var expectedExceptionMessage = new RegExp ( formElementId + ".PasswordsMatch: You seem to have provided some optional or required parameters for @PasswordsMatch, but you are still missing the following 2 required parameters\\(s\\): field1, field2" ) ; raises ( function ( ) { $form . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . PasswordsMatch , params : { groups : [ "Test" ] } } ] } ) ; } , expectedExceptionMessage , "@PasswordsMatch cannot be bound without its required parameter" ) ; deleteElement ( formElementId ) ; }
function ( ) { var formElementId = "hiddenForm" ; var $form = createFormElement ( formElementId , "@PasswordsMatch(label=\"test\", message=\"this is a test\", groups=[Test])" ) ; var expectedExceptionMessage = new RegExp ( formElementId + ".PasswordsMatch: You seem to have provided some optional or required parameters for @PasswordsMatch, but you are still missing the following 2 required parameters\\(s\\): field1, field2" ) ; raises ( function ( ) { $form . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . PasswordsMatch , params : { label : "test" , message : "this is a test" , groups : [ "Test" ] } } ] } ) ; } , expectedExceptionMessage , "@PasswordsMatch cannot be bound without its required parameter" ) ; deleteElement ( formElementId ) ; }
function ( ) { var formElementId = "hiddenForm" ; var $form = createFormElement ( formElementId ) ; var expectedExceptionMessage = new RegExp ( formElementId + ".PasswordsMatch: You seem to have provided some optional or required parameters for @PasswordsMatch, but you are still missing the following 1 required parameters\\(s\\): field2" ) ; raises ( function ( ) { $form . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . PasswordsMatch , params : { field1 : "field1" } } ] } ) ; } , expectedExceptionMessage , "@PasswordsMatch cannot be bound without its required parameter" ) ; deleteElement ( formElementId ) ; }
function ( ) { var formElementId = "hiddenForm" ; var $form = createFormElement ( formElementId ) ; var expectedExceptionMessage = new RegExp ( formElementId + ".PasswordsMatch: You seem to have provided some optional or required parameters for @PasswordsMatch, but you are still missing the following 1 required parameters\\(s\\): field1" ) ; raises ( function ( ) { $form . regula ( 'bind' , { constraints : [ { constraintType : regula . Constraint . PasswordsMatch , params : { field2 : "field2" } } ] } ) ; } , expectedExceptionMessage , "@PasswordsMatch cannot be bound without its required parameter" ) ; deleteElement ( formElementId ) ; }
function ( ) { regula . validate ( { elementId : "myText0" } ) } , / No constraints have been bound to element with id myText0 . Function received : { elementId : myText0 }
function ( ) { regula . compound ( { name : "MyCompoundConstraint" , params : true } ) ; }
function ( opts , tags , escape ) { var options = opts ; if ( $ . type ( options ) !== 'object' ) { options = { string : opts , tags : tags , escape : escape } ; } $ ( this ) . html ( textpattern . gTxt ( options . string , options . tags , options . escape ) ) ; return this ; }
function ( ) { var res = this . callback . apply ( this . module , this . params ) ; if ( res ) { this . module . exports = res ; if ( this . defined ) { console . warn ( 'Multiple define block with return value in' , this . module . filename ) ; } else { this . defined = true ; } } }
function ( dependencies , callback ) { if ( typeof dependencies == 'function' ) { callback = dependencies ; dependencies = [ ] ; } if ( typeof dependencies == 'string' ) { dependencies = [ dependencies ] ; } if ( typeof callback != 'function' ) { throw new TypeError ( "You must pass a callback to define" ) ; } new DefineBlock ( this , dependencies , callback ) ; }
function ( $ ) { $ ( function ( ) { $ ( '.tabs' ) . tabs ( { ajaxOptions : { error : function ( xhr , status , index , anchor ) { $ ( anchor . hash ) . html ( "Couldn't load this tab. We'll try to fix this as soon as possible. " + "If this wouldn't be a demo." ) ; } } } ) ; } ) ; }
function ( ) { this . x = this . x + this . speed * Math . cos ( this . angle ) ; this . y = this . y + this . speed * Math . sin ( this . angle ) ; if ( this . x < 0 || this . x > cp . game . width || this . y < 0 || this . y > cp . game . height ) { this . kill ( ) ; } }
function ( ) { var user_agent = window . navigator . userAgent || "" ; wot . env . is_mailru = user_agent . indexOf ( "MRCHROME" ) >= 0 ; if ( wot . env . is_mailru ) { wot . partner = "mail.ru" ; } }
function ( curVal , prop ) { newVal = props [ prop ] ; if ( newVal === undefined ) { remove && self . removeAttr ( prop ) ; return ; } if ( canMakeObserve ( curVal ) && canMakeObserve ( newVal ) ) { curVal . attr ( newVal , remove ) } else if ( curVal != newVal ) { self . _set ( prop , newVal ) } else { } delete props [ prop ] ; }
function ( ) { config . current = this ; try { this . testEnvironment . teardown . call ( this . testEnvironment ) ; checkPollution ( ) ; } catch ( e ) { QUnit . ok ( false , "Teardown failed on " + this . testName + ": " + e . message ) ; } }
function ( ) { var next = b . nextSibling . nextSibling , display = next . style . display ; next . style . display = display === "none" ? "block" : "none" ; }
function saveGlobal ( ) { config . pollution = [ ] ; if ( config . noglobals ) { for ( var key in window ) { if ( ! hasOwn . call ( window , key ) ) { continue ; } config . pollution . push ( key ) ; } } }
function checkPollution ( name ) { var old = config . pollution ; saveGlobal ( ) ; var newGlobals = diff ( config . pollution , old ) ; if ( newGlobals . length > 0 ) { ok ( false , "Introduced global variable(s): " + newGlobals . join ( ", " ) ) ; } var deletedGlobals = diff ( old , config . pollution ) ; if ( deletedGlobals . length > 0 ) { ok ( false , "Deleted global variable(s): " + deletedGlobals . join ( ", " ) ) ; } }
function diff ( a , b ) { var result = a . slice ( ) ; for ( var i = 0 ; i < result . length ; i ++ ) { for ( var j = 0 ; j < b . length ; j ++ ) { if ( result [ i ] === b [ j ] ) { result . splice ( i , 1 ) ; i -- ; break ; } } } return result ; }
function fail ( message , exception , callback ) { if ( typeof console !== "undefined" && console . error && console . warn ) { console . error ( message ) ; console . error ( exception ) ; console . warn ( callback . toString ( ) ) ; } else if ( window . opera && opera . postError ) { opera . postError ( message , exception , callback . toString ) ; } }
function extend ( a , b ) { for ( var prop in b ) { if ( b [ prop ] === undefined ) { delete a [ prop ] ; } else if ( prop !== "constructor" || a !== window ) { a [ prop ] = b [ prop ] ; } } return a ; }
function runLoggingCallbacks ( key , scope , args ) { var callbacks ; if ( QUnit . hasOwnProperty ( key ) ) { QUnit [ key ] . call ( scope , args ) ; } else { callbacks = config [ key ] ; for ( var i = 0 ; i < callbacks . length ; i ++ ) { callbacks [ i ] . call ( scope , args ) ; } } }
function join ( pre , arr , post ) { var s = jsDump . separator ( ) , base = jsDump . indent ( ) , inner = jsDump . indent ( 1 ) ; if ( arr . join ) arr = arr . join ( ',' + s + inner ) ; if ( ! arr ) return pre + post ; return [ pre , inner + arr , base + post ] . join ( s ) ; }
function ( extra ) { if ( ! this . multiline ) return '' ; var chr = this . indentChar ; if ( this . HTML ) chr = chr . replace ( /\t/g , '   ' ) . replace ( / /g , '&nbsp;' ) ; return Array ( this . _depth_ + ( extra || 0 ) ) . join ( chr ) ; }
function ( a ) { this . _depth_ -= a || 1 ; }
function startBreak ( ) { console . log ( completedPomodoros ) if ( completedPomodoros % 4 == 0 ) { tomatoidTimer . totalSeconds = 15 ; } else { tomatoidTimer . totalSeconds = 5 ; } tomatoidTimer . running = true ; inPomodoro = false ; inBreak = true ; }
function ( e ) { if ( e . success ) { var acls = e . acls [ 0 ] ; readers . public = acls . public_read || false ; readers . ids = acls . readers || [ ] ; writers . public = acls . public_write || false ; writers . ids = acls . writers || [ ] ; alert ( 'Shown!' ) ; } else { error ( e ) ; } }
function ( evt ) { Cloud . ACLs . update ( { name : name . value , reader_ids : readers . ids . join ( ',' ) , writer_ids : writers . ids . join ( ',' ) , public_read : readers . public , public_write : writers . public } , function ( e ) { if ( e . success ) { alert ( 'Updated!' ) ; } else { error ( e ) ; } } ) ; }
function ( e ) { if ( ! e ) { configuration . value ( null ) ; } configuration . value ( accessDataItemValue ( this . dataItem ( e . item . index ( ) ) ) ) ; }
function ( e ) { if ( ! e ) { configuration . value ( null ) ; } configuration . value ( accessDataItemValue ( this . dataItem ( e . item . index ( ) ) ) ) ; }
function ( key , val ) { var name = key . toUpperCase ( ) . split ( ' ' ) . join ( '_' ) ; return process . env [ name ] || val ; }
function ( ) { env ( 'foo' , 'bar' ) . should . equal ( 'bar' ) ; process . env . FOO = 'baz' ; env ( 'foo' , 'bar' ) . should . equal ( 'baz' ) ; process . env . DEV_UI = 'yes' ; env ( 'dev ui' , 'no' ) . should . equal ( 'yes' ) ; }
function outerIframeLoaded ( ) { var injectedScript = "data:,function is(a, b, desc) {                                     \       if (a == b) {                                                      \         sendAsyncMessage('test:test-pass', desc);                        \       } else {                                                           \         sendAsyncMessage('test:test-fail', desc + ' ' + a + ' != ' + b); \       }                                                                  \     }                                                                    \     is(content.window.top, content.window, 'top');                       \     is(content.window.content, content.window, 'content');               \     is(content.window.parent, content.window, 'parent');                 \     is(content.window.frameElement, null, 'frameElement');               \     var innerIframe = content.document.getElementById('inner-iframe');   \     var innerWindow = innerIframe.contentWindow;                         \     is(innerWindow.top, content.window, 'inner top');                    \     is(innerWindow.content, content.window, 'inner content');            \     is(innerWindow.parent, content.window, 'inner parent');              \     is(innerWindow.frameElement, innerIframe, 'inner frameElement');" var mm = SpecialPowers . getBrowserFrameMessageManager ( iframe ) ; function onRecvTestPass ( msg ) { numMsgReceived ++ ; ok ( true , msg . json ) ; } mm . addMessageListener ( 'test:test-pass' , onRecvTestPass ) ; function onRecvTestFail ( msg ) { numMsgReceived ++ ; ok ( false , msg . json ) ; } mm . addMessageListener ( 'test:test-fail' , onRecvTestFail ) ; mm . loadFrameScript ( injectedScript , false ) ; waitForMessages ( 6 ) ; }
function ( ) { var _id = $ ( this . el ) . find ( '.sidebar-nav li:first' ) . attr ( 'data-id' ) ; if ( window . STATICS ) { window . STATICS . currentList = _id ; } }
function ( ) { this . $el . html ( Greenmine . task_template ( this . model . toJSON ( ) ) ) ; this . $el . attr ( { 'data-id' : this . model . get ( 'id' ) , 'id' : "task_" + this . model . get ( 'id' ) } ) ; return this ; }
function readListener ( ) { var maybe = read ( view ) ; if ( "value" in maybe ) { variable ( maybe . value ) ; } else if ( "error" in maybe ) { WARNING ( "validation error: " + maybe . error ) ; } else { ERROR ( "expected error monad from read" ) ; } }
function getCaret ( ) { var input = this . tbox . get ( 0 ) ; if ( 'selectionStart' in input ) { return input . selectionStart ; } else if ( document . selection ) { input . focus ( ) ; var sel = document . selection . createRange ( ) ; var selLen = document . selection . createRange ( ) . text . length ; sel . moveStart ( 'character' , - input . value . length ) ; return sel . text . length - selLen ; } }
function publish ( evt ) { if ( ! ( evt in this . subscribers ) ) { return ; } var args = Array . prototype . slice . call ( arguments , 1 ) ; this . subscribers [ evt ] . forEach ( function ( cbWrapped ) { cbWrapped ( args ) ; } ) ; }
function ( event , target ) { var script_id = Number ( event . target . getAttribute ( "data-script-id" ) ) ; var script_line = Number ( event . target . getAttribute ( "data-script-line" ) ) ; views . js_source . show_and_flash_line ( script_id , script_line ) ; }
function ( id , name , container_class ) { View . prototype . init . call ( this , id , name , container_class ) ; this . required_services = [ "ecmascript-debugger" ] ; this . _container = null ; this . _models = [ ] ; this . _search_term = "" ; }
function ( ) { console . log ( 'here?' ) ; mkdirp ( path . join ( tempDir , '.cordova' ) , cb ) ; console . log ( 'what about here?' ) ; }
function ( data ) { rescaleGraph ( data ) graph_substrate . nodes ( data . nodes ) graph_substrate . links ( data . links ) graph_substrate . edgeBinding ( ) var g = graphDrawing ( graph_substrate , svg_substrate ) g . draw ( ) return }
function ( data ) { console . log ( "received data after synchronization: " ) console . log ( data ) ; rescaleGraph ( data ) cGraph . nodes ( data . nodes ) cGraph . links ( data . links ) cGraph . edgeBinding ( ) g = graphDrawing ( cGraph , svg ) g . show ( cGraph ) }
function ( data ) { console . log ( "received data after analysis:" ) console . log ( data ) ; rescaleGraph ( data ) graph_catalyst . nodes ( data . nodes ) graph_catalyst . links ( data . links ) graph_catalyst . edgeBinding ( ) g = graphDrawing ( graph_catalyst , svg_catalyst ) g . clear ( ) g . draw ( ) }
function ( ) { window . stock = { routers : { workspaceRouter : WorkspaceRouter } , views : { } , models : { } , ticker : null } ; var started = Backbone . history . start ( { pushState : false , root : '/HTML5BackboneJQMRequireJS/' } ) ; window . stock . routers . workspaceRouter . navigate ( "#index" , { trigger : true } ) ; }
function ( ) { this . model = window . tc . routers . workspaceRouter . ticker ; $ ( "a[href]" ) . on ( "click" , function ( e ) { navigate ( e ) ; e . preventDefault ( ) ; e . stopPropagation ( ) ; return false ; } ) ; }
function ( data ) { var list = new stockListCollection ( ) ; list . add ( data ) ; list . localSave ( list . models ) ; window . stock . routers . workspaceRouter . navigate ( "#index" , true ) ; }
function ( content ) { for ( var key in validAlias ) { var regex = new RegExp ( key , "g" ) ; content = content . replace ( regex , function ( ) { return validAlias [ key ] } ) ; } return content . replace ( /:([a-z0-9\+\-_]+):/g , emojiReplacer ) ; }
function ( resource , plotID , container , series ) { var config = SunstoneMonitoringConfig [ resource ] . monitor [ plotID ] var options = config . plotOptions $ . plot ( container , series , options ) }
function ( monitoring ) { $ ( '#totalUsers' , $dashboard ) . text ( monitoring [ 'totalUsers' ] ) if ( ! $dashboard . is ( ':visible' ) ) return ; var container = $ ( 'div#usersPerGroup' , $dashboard ) ; SunstoneMonitoring . plot ( 'USER' , 'usersPerGroup' , container , monitoring [ 'usersPerGroup' ] ) ; }
function ( ) { label = this . monitor_resources ; id_suffix = label . replace ( /,/g , '_' ) ; id_suffix = id_suffix . replace ( /\//g , '_' ) ; id = id_prefix + id_suffix ; str += '<table class="info_table">\                 <thead><tr><th colspan="1">' + this . title + '</th></tr></thead>\                 <tr><td id="legend_' + id_suffix + '"></td></tr>\                 <tr><td style="border:0">\                 <div id="' + id + '" style="width:' + width + 'px; height:150px;margin-bottom:10px;position:relative;left:-20px;">' + spinner + '</div>\               </td></tr></table>' ; }
function ( ) { $ ( 'div#cluster_tab_' + cluster . ID + ' div.plot' ) . trigger ( 'resize' ) ; }
function ( monitoring ) { $ ( '#totalHosts' , $dashboard ) . text ( monitoring [ 'totalHosts' ] ) delete monitoring [ 'totalHosts' ] if ( ! $dashboard . is ( ':visible' ) ) return ; for ( plotID in monitoring ) { var container = $ ( 'div#' + plotID , $dashboard ) ; if ( ! container . length ) continue ; SunstoneMonitoring . plot ( "HOST" , plotID , container , monitoring [ plotID ] ) ; } ; }
function ( result ) { if ( ! result . ok ) return ; var a = asItem ( folder ) . deletedItems ; var i = a . length ; while ( i -- ) { if ( sameFileName ( a [ i ] . excludeTrailing ( '/' ) , it . name ) ) { a . splice ( i , 1 ) ; } } li . remove ( ) ; updateDeletedItems ( folder ) ; addItemUnder ( folder , result . item ) ; }
function ( result ) { if ( ! log ( result ) . ok ) { msgBox ( result . error ) ; return ; } if ( result . item . nodeKind === 'temp' ) { updateDeletedItems ( it ) ; } setExpanded ( it ) ; addItemUnder ( it , result . item ) ; vfsSelect ( result . item ) ; }
function ( data ) { log ( data ) ; var folder = data . uri . substr ( 0 , data . uri . lastIndexOf ( '/' , data . uri . length - 2 ) + 1 ) ; if ( folder === currentFolder ) { loadFolder ( ) ; } }
function ( id ) { window . location = server + "/load/" + id ; }
function ( data , callback ) { XHR . post ( server + "/project/" , data , function ( ) { if ( this . readyState === 4 ) { try { var response = JSON . parse ( this . response ) ; callback ( response ) ; } catch ( err ) { callback ( { error : "an unknown error occured" } ) ; } } } ) ; }
function parameterize ( data ) { var s = [ ] ; for ( var key in data ) { if ( data . hasOwnProperty ( key ) ) { s [ s . length ] = encodeURIComponent ( key ) + "=" + encodeURIComponent ( data [ key ] ) ; } } return s . join ( "&" ) . replace ( "/%20/g" , "+" ) ; }
function ( next ) { var self = this ; var changed = this . isNew || fields . some ( function ( field ) { return self . isModified ( field ) ; } ) ; if ( changed ) this . indexFields ( ) ; next ( ) ; }
function ( content ) { var myClone = content . clone ( ) ; myClone . find ( 'time' ) . remove ( ) ; var data = { Content : myClone . find ( '.result-content' ) . html ( ) , Type : 'normal' , Author : this . author , } ; return data ; }
function ( content ) { var myClone = content . clone ( ) ; myClone . find ( 'time' ) . remove ( ) ; myClone . find ( '.attributes' ) . remove ( ) ; var data = { Content : myClone . find ( '.result-content' ) . html ( ) , Type : 'normal' , Author : this . author , } ; return data ; }
function ( data ) { html = '' ; $ . each ( data , function ( k , v ) { html = html + "<li>" + k + " -- " + v + "</li>" ; } ) ; $ ( '#filemgr #filedetails' ) . html ( "<ul class='filedetaillist'>" + html + "</ul>" ) ; $ ( '#filemgr #filedetails' ) . show ( ) ; }
function ( isp , status ) { console . log ( 'marker = ' , uMarker , 'markers.length = ' , markers . length ) ; uMarker . isp = ispName = isp ; uMarker . status = status ; uMarker . time = Date . now ( ) ; drawMap ( ) ; }
function ( a ) { for ( var i = a . length - 1 ; i >= 0 ; i -- ) { if ( a [ i ] . user == false ) { addMarker ( a [ i ] ) ; } else { uMarker = drawGeoMarker ( a [ i ] ) ; } } drawMap ( ) ; }
function ( ) { this . createstageElement ( this . application . ninja . selectedElements [ 0 ] ) ; }
function getBrowserDocument ( ) { return Firebug . chrome . inDetachedScope ? Firebug . chrome . originalBrowser . ownerDocument : top . document ; }
function ( ) { bigPlayButton . removeEventListener ( "mouseup" , bigPlayClicked , false ) ; bigPlayButton . classList . remove ( "controls-ready" ) ; p . media . addEventListener ( "mouseover" , activate , false ) ; p . play ( ) ; }
function ( path ) { if ( options . force === true && existsSync ( path ) && isOutsideCWD ( path ) ) { grunt . fail . warn ( 'trying to clean "' + path + '" which is outside the working dir.' ) ; } grunt . helper ( "clean" , path ) ; }
function ( callback ) { var control = this ; return Echo . UserSession ( { "appkey" : this . config . get ( "appkey" ) , "ready" : $ . proxy ( callback , control ) } ) ; }
function ( td ) { return { row : td . parentNode . rowIndex - self . blockedRows . count ( ) , col : td . cellIndex - self . blockedCols . count ( ) } ; }
function init ( ) { var header = document . getElementById ( 'qunit-header' ) ; if ( header ) { header . appendChild ( label1 ) ; header . appendChild ( label2 ) ; if ( build == 'prod' ) { dropdown . selectedIndex = 1 ; } else if ( build == 'custom' ) { dropdown . selectedIndex = 2 ; } checkbox . checked = norequire ; addEvent ( checkbox , 'click' , eventHandler ) ; addEvent ( dropdown , 'change' , eventHandler ) ; } else { setTimeout ( init , 15 ) ; } }
function ( ) { var args , object = { 'a' : 'A' , 'b' : 'B' , 'c' : 'C' } , keys = _ . keys ( object ) ; _ . reduceRight ( object , function ( ) { args || ( args = slice . call ( arguments ) ) ; } ) ; deepEqual ( args , [ 'C' , 'B' , 'b' , object ] ) ; }
function ( ) { args || ( args = slice . call ( arguments ) ) ; }
function ( aChannel ) { if ( ! aChannel ) return ; this . _docRequest = aChannel ; let uri = aChannel . URI . cloneIgnoringRef ( ) ; uri . userPass = '' ; this . _request = uri . asciiSpec ; let referrer = aChannel . referrer . cloneIgnoringRef ( ) ; referrer . userPass = '' ; this . _referrer = referrer . asciiSpec ; }
function isInView ( elem , up ) { if ( ! elem && elem . length == 0 ) return false ; var margin = 60 ; var top = 56 + margin ; var bottom = $ ( '#center' ) . height ( ) + top - margin * 2 ; if ( up ) return elem . offset ( ) . top > top ; else return ( elem . offset ( ) . top + elem . height ( ) ) < bottom ; }
function ( ) { window . plugins . nativeUI . setTitle ( { title : "Лепрочятик" , organize : false , refresh : false , menu : true } ) ; $ . mobile . showPageLoadingMsg ( ) requestNewChatData ( true ) ; refreshInterval = window . setInterval ( requestNewChatData , 10000 ) ; }
function ( manager , context ) { setProperty ( manager , context ) ; var record = get ( manager , 'record' ) , errors = get ( record , 'errors' ) , key = context . key ; errors . set ( key , null ) ; if ( ! hasDefinedProperties ( errors ) ) { manager . send ( 'becameValid' ) ; } }
function ( padID , text , callback ) { getPadSafe ( padID , true , function ( err , pad ) { if ( ERR ( err , callback ) ) return ; pad . setText ( text ) ; padMessageHandler . updatePadClients ( pad , callback ) ; } ) ; }
function ( pos ) { console . log ( pos ) ; console . log ( NewCommentsHighlighter . new_comment_boxes ) ; if ( NewCommentsHighlighter . new_comment_boxes . length == 0 ) { return ; } var comment = NewCommentsHighlighter . new_comment_boxes [ NewCommentsHighlighter . presentCommentMarker ] ; console . log ( comment ) ; window . scroll ( 0 , NewCommentsHighlighter . findPos ( comment ) ) ; NewCommentsHighlighter . presentCommentMarker = pos + 1 ; }
function ( ) { if ( self . model . get ( "userPrivate" ) . get ( "mostRecentIds" ) == undefined ) { Utils . debug ( "User does not have most recent ids, doing nothing." ) ; } else { var appids = self . model . get ( "userPrivate" ) . get ( "mostRecentIds" ) ; window . app . loadBackboneObjectsById ( couchConnection , appids ) ; } }
function ( err , thread ) { var post_count = thread . cache . real . post_count ; var thread = { forum_id : thread . forum_id , seo_desc : thread . cache . real . seo_desc , id : thread_id , title : thread . title , post_count : post_count } ; callback ( err , thread ) ; }
function ( val ) { mc . set ( key , val , tm_out , function ( err , c_result ) { result = val ; f [ 'return' ] ( ) ; } ) ; }
function ( macro_errors ) { var result = _ . map ( tokens , function ( tok ) { if ( 'TEXT' == tok . type ) { return tok . out ; } else if ( 'MACRO' == tok . type ) { return macros [ tok . hash ] . out ; } } ) . join ( '' ) ; var errors = [ ] . concat ( tmpl_errors , macro_errors ) ; process_done ( errors . length ? errors : null , result ) ; }
function ( hash ) { macro_q . push ( hash ) ; }
function ( err ) { log . error ( 'uncaughtException:' , err . message ) ; log . error ( err . stack ) ; process . exit ( 1 ) ; }
function ( code , context , file , cb ) { log . info ( "REPL (cmd): > " + util . inspect ( code ) ) ; var err , result ; try { result = vm . runInContext ( code , context , file ) ; } catch ( e ) { err = e ; } log . info ( "REPL (result): " + util . inspect ( [ err , result ] ) ) ; cb ( err , result ) ; }
function ( socket ) { var r_host = socket . remoteAddress ; var r_port = socket . remotePort ; var shell = repl . start ( "ks> " , socket , eval ) ; _ ( shell . context ) . extend ( context ) ; log . info ( "REPL received connection from " + r_host + ":" + r_port ) ; socket . on ( 'close' , function ( ) { log . info ( "REPL connection closed for " + r_host + ":" + r_port ) ; } ) ; }
function ( err , tile , headers ) { if ( err ) { console . log ( "[TILE RENDER ERROR]\n" + err ) ; res . send ( err , 500 ) ; } else { app . sendWithHeaders ( res , tile , 200 , headers ) ; } }
function ( ) { data = data . join ( "" ) ; if ( response . statusCode != 200 ) { callback ( { statusCode : response . statusCode , data : data , oauth : oauthDetails } ) ; } else { callback ( undefined , data , response ) ; } }
function calculator_appendValue ( value ) { if ( this . toClear ) { this . stack = [ ] ; this . toClear = false ; } this . stack . push ( value ) ; this . updateDisplay ( ) ; }
function evaluatePostFix_inner ( token ) { if ( ! this . isOperator ( token ) ) { stack . push ( token ) ; } else { var op2 = stack . pop ( ) ; var op1 = stack . pop ( ) ; var result = this . evaluate [ token ] ( op1 , op2 ) ; stack . push ( result ) ; } }
function ( idx , name ) { var tag = new Tag ( ) ; tag . setName ( name ) ; me . _tags . push ( tag ) ; me . _tag_list_element . append ( tag . getElement ( ) ) ; }
function placePlayer ( x , y , socket ) { var player = entityFactory . entity ( x , y , clientNumber , "player" ) ; field . getNode ( x , y ) . containedEntity = player ; ; player . currentBombCount = 0 ; player . maxBombCount = 1 ; player . blastRadius = 1 ; players [ clientNumber ] = player ; socket . emit ( 'identity' , { entity : player } ) ; socket . emit ( 'players' , { players : players } ) ; }
function ( data , type , name ) { var key , prop , x ; x = [ ] ; for ( key in data ) { prop = data [ key ] ; if ( prop . type === type ) { x . push ( "@" + key ) ; } } return x ; }
function ( ) { if ( useAbility ( abilities , 'peek' , $ ( '#left_buttons' ) . find ( '.peek' ) ) ) { them . setValue ( opponentText ) ; setTimeout ( function ( ) { them . setValue ( censor ( opponentText ) ) ; } , 1500 ) ; socket . emit ( 'peek' ) ; } }
function ( ) { var text = you . getValue ( ) . split ( '' ) , swap = Math . floor ( Math . random ( ) * text . length - 1 ) , holder = text [ swap ] ; useAbility ( opponentAbilities , 'swap' , $ ( '#right_buttons' ) . find ( '.swap' ) ) ; text [ swap ] = text [ swap + 1 ] text [ swap + 1 ] = holder ; you . setValue ( text . join ( '' ) ) ; }
function ( line , i ) { return i !== killLine ; }
function ( res ) { if ( res . statusCode != 200 ) { callback ( new Error ( 'GCM service returned code ' + res . statusCode ) ) ; } else res . on ( 'end' , function ( ) { callback ( true ) ; } ) ; }
function ( layout ) { if ( ! this . cell ) return ; if ( this . set_hidden != this . df . hidden ) { if ( this . df . hidden ) this . cell . hide ( ) ; else this . cell . show ( ) ; this . set_hidden = this . df . hidden ; } }
function ( from_form ) { if ( this . df . hidden ) { if ( this . row ) this . row . hide ( ) ; } else { if ( this . collapsible ) { } } }
function ( key , element , resourceTable ) { var self = this ; this . element = element ; this . resourceTable = resourceTable ; element . change ( function ( ) { var filter = { } ; filter [ key ] = element . val ( ) ; resourceTable . filter ( filter ) ; } ) ; }
function ( pos ) { for ( var s = 0 ; s < this . _ranges . length ; ++ s ) { if ( this . _ranges [ s ] . contains ( pos ) ) { return true ; } } return false ; }
function ( ) { if ( typeof self . current . response . headers [ header ] !== "undefined" ) { expect ( self . current . response . headers [ header ] . toLowerCase ( ) ) . toEqual ( content . toLowerCase ( ) ) ; } else { fail ( "Header '" + header . toLowerCase ( ) + "' not present in HTTP response" ) ; } }
function ( ) { if ( typeof self . current . response . headers [ header ] !== "undefined" ) { expect ( self . current . response . headers [ header ] . toLowerCase ( ) ) . toContain ( content . toLowerCase ( ) ) ; } else { fail ( "Header '" + header . toLowerCase ( ) + "' not present in HTTP response" ) ; } }
function ( ex , type , message ) { result = { ex : ex , type : type , message : message } ; context . onError ( message ) ; container . html ( message ) ; }
function ( stream , onSuccess , onFailure ) { if ( ! stream . length ) return onFailure ( stream ) ; var head = stream . charAt ( 0 ) ; if ( cond ( head ) ) { return onSuccess ( stream . slice ( 1 ) , head ) ; } else { return onFailure ( stream , ch ) ; } }
function ( req , res ) { var sid = req . cookies . sid ; if ( sid !== undefined ) { getUser ( ) . clearSession ( sid ) ; res . clearCookie ( 'SID' ) ; } res . send ( { result : 'ok' } ) ; }
function ( ) { this . canvasView = new app . views . Canvas ( { model : this . stream } ) this . headerView = new app . views . Header ( { model : this . stream } ) this . canvasView . postClass = app . views . Post . ConversationFrame }
function ( event ) { var id = getUrlVars ( ) [ "id" ] ; showEvent ( id ) ; }
function getEvents ( ) { $ . ajax ( { cache : false , type : "GET" , async : false , dataType : "jsonp" , url : 'http://localhost:8080/TheEvent/event/list' , success : function ( data ) { if ( data ) { var eventList = new EventList ( ) ; eventList . add ( data ) ; eventList . renderToHtml ( ) ; } } , error : function ( xhr ) { alert ( xhr . responseText ) ; } } ) ; }
function ( c , t ) { t || ( t = window ) ; var i = - 1 ; while ( ++ i < this . length ) c . call ( t , this [ i ] , i , this ) ; }
function ( c , t ) { t || ( t = window ) ; var i = - 1 ; while ( ++ i < this . length ) if ( c . call ( t , this [ i ] , i , this ) === false ) return false ; return true ; }
function ( c , t ) { t || ( t = window ) ; var i = - 1 ; while ( ++ i < this . length ) if ( c . call ( t , this [ i ] , i , this ) === true ) return true ; return false ; }
function ( c , t ) { t || ( t = window ) ; var a = [ ] , i = - 1 ; while ( ++ i < this . length ) a [ i ] = c . call ( t , this [ i ] , i , this ) ; return a ; }
function ( c , t ) { t || ( t = window ) ; var a = [ ] , i = - 1 ; while ( ++ i < this . length ) c . call ( t , this [ i ] , i , this ) && a . push ( this [ i ] ) ; return a ; }
function ( c , v ) { var i = - 1 ; if ( v === undefined ) v = this [ ++ i ] ; while ( ++ i < this . length ) v = c ( v , this [ i ] , i , this ) ; return v ; }
function ( c , v ) { var i = this . length ; if ( v === undefined ) v = this [ -- i ] ; while ( -- i >= 0 ) v = c ( v , this [ i ] , i , this ) ; return v ; }
function ( ) { _redraw ( false ) ; }
function ( er , cr , data ) { if ( er || cr . statusCode !== 200 ) { return cb ( er ) } if ( data . email ) { data . gravatar = gravatar ( data . email , { s : 50 , d : 'retro' } , true ) } req . session . set ( 'profile' , data ) return cb ( null , data ) }
function findCmd ( name ) { "use strict" ; var paths = process . env [ 'PATH' ] . split ( ':' ) ; var pathLen = paths . length ; for ( var i = 0 ; i < pathLen ; i ++ ) { var sp = path . resolve ( paths [ i ] ) ; var fname = path . normalize ( path . join ( sp , name ) ) ; if ( path . existsSync ( fname ) ) { return fname ; } } return null ; }
function ( e ) { var layout_pane = jQuery ( '.ui-layout-' + e ) , tabs_height = layout_pane . find ( '.ui-tabs-nav' ) . height ( ) , pane_height = layout_pane . height ( ) - tabs_height , pane_width = layout_pane . width ( ) ; jQuery ( layout_pane . find ( '.ui-tabs-panel' ) . each ( function ( ) { var panel = jQuery ( this ) ; panel . height ( pane_height ) ; panel . width ( pane_width ) ; } ) ) ; }
function ( spans ) { for ( var i = spans . length ; i -- ; ) { var span = spans [ i ] ; for ( var j = 0 ; j < span . childNodes . length ; j ++ ) { span . parentNode . insertBefore ( span . childNodes [ j ] , span ) ; } span . parentNode . removeChild ( span ) ; } }
function ( req , res ) { if ( req . session && req . session . user ) { res . render ( "engage/index" , { title : "SFU ENGAGE" , user : userobject , courses : req . session . courses , status : "logged in" } ) } else { res . redirect ( "/demo" ) ; } }
function ( req , res ) { if ( req . session && req . session . user ) { res . render ( "engage/starred" , { title : "SFU ENGAGE" , user : userobject , courses : req . session . courses , status : "logged in" } ) } else { res . redirect ( "/demo" ) ; } }
function ( req , res ) { if ( req . session && req . session . user ) { res . render ( "engage/instructor" , { title : "SFU ENGAGE" , user : userobject , courses : req . session . courses , status : "logged in" } ) } else { res . redirect ( "/demo" ) ; } }
function ( req , res ) { if ( req . session && req . session . user ) { var pickedArticle = articles [ req . params . id - 1 ] ; res . render ( "engage/article" , { title : "SFU ENGAGE" , article : pickedArticle , user : userobject , courses : req . session . courses , status : "logged in" } ) } else { res . redirect ( "/demo" ) ; } }
function getBrowserDocument ( ) { return Firebug . chrome . inDetachedScope ? Firebug . chrome . originalBrowser . ownerDocument : top . document ; }
function onError ( err ) { self . removeListener ( 'listening' , onListen ) ; restoreErrorListeners ( ) ; restoreListeningListeners ( ) ; if ( err . code !== 'EADDRINUSE' ) { try { self . close ( ) } catch ( ex ) { } self . emit ( 'error' , err ) ; } else { ourListen . call ( self , '0.0.0.0' , 0 , addressType , desired ) ; } }
function deleteLast ( ) { if ( ui . keyboardPlacements . length ) { var lastPlacement = ui . keyboardPlacements . pop ( ) ; var rackSquare = lastPlacement [ 0 ] ; var boardSquare = lastPlacement [ 1 ] ; if ( ! rackSquare . tile && boardSquare . tile ) { ui . moveTile ( boardSquare , rackSquare ) ; ui . setCursor ( boardSquare ) ; } else { ui . keyboardPlacements = [ ] ; } } handled ( ) ; }
function ( square ) { var oldCursorSquare = ui . cursor . square ; ui . cursor . square = square ; ui . updateBoardSquare ( square ) ; ui . updateBoardSquare ( oldCursorSquare ) ; }
function ( ) { var self = this ; this . _overlay = ui . overlay ( { closable : true } ) . on ( 'hide' , function ( ) { self . closedOverlay = true ; self . emit ( 'close' ) ; self . hide ( ) ; } ) ; return this ; }
function ( ev ) { if ( $ . browser . ie ) { var trigger = $trigger [ 0 ] ; trigger . onbeforedeactivate = function ( ) { window . event . returnValue = false ; trigger . onbeforedeactivate = null ; } ; } ev . preventDefault ( ) ; }
function ( ) { app . use ( connectLess ( { src : __dirname + '/webapp' , force : true , debug : true } ) ) ; app . use ( express . static ( __dirname + '/webapp' ) ) ; app . use ( express . static ( __dirname + '/test' ) ) ; app . use ( express . errorHandler ( { dumpExceptions : true , showStack : true } ) ) ; }
function naclCmdProcess ( cmdType , cmd ) { if ( cmdType == asyncCmd ) { cc . Log ( "AsyncCmd result from nacl." ) ; cocos2dnaclModule . postMessage ( asyncCmd + ": " + "I am cocos2d." ) ; return ; } else { cocos2dNaclBlock = true ; cocos2dnaclModule . postMessage ( syncCmd + ": " + "I am cocos2d." ) ; return naclResult ; } }
function ( tag , cleanup ) { cc . Assert ( tag != cc . NODE_TAG_INVALID , "Invalid tag" ) ; var child = this . getChildByTag ( tag ) ; if ( child == null ) { cc . Log ( "cocos2d: removeChildByTag: child not found!" ) ; } else { this . removeChild ( child , cleanup ) ; } }
function ( obj ) { if ( cc . ENABLE_CACHE_TEXTURE_DATA ) { cc . SAFE_DELETE ( this . pITextureImage ) ; this . pITextureImage = this . newCCImage ( ) ; if ( this . pITextureImage ) { var s = this . _texture . getContentSizeInPixels ( ) ; VolatileTexture . addDataTexture ( this . _texture , this . pITextureImage . getData ( ) , cc . TEXTURE_2D_PIXEL_FORMAT_RGBA8888 , s ) ; } else { cc . Log ( "Cache rendertexture failed!" ) ; } } }
function ( quantity ) { cc . Log ( "cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this . _textureAtlas . getCapacity ( ) + "] to [" + quantity + "]." ) ; if ( ! this . _textureAtlas . resizeCapacity ( quantity ) ) { cc . Log ( "cocos2d: WARNING: Not enough memory to resize the atlas" ) ; cc . Assert ( false , "XXX: cc.ParticleBatchNode #increaseAtlasCapacity SHALL handle this assert" ) ; } }
function ( ) { if ( ! this . _paused ) { return ; } this . setAnimationInterval ( this . _oldAnimationInterval ) ; this . _lastUpdate = cc . Time . gettimeofdayCocos2d ( ) ; if ( ! this . _lastUpdate ) { cc . Log ( "cocos2d: Director: Error in gettimeofday" ) ; } this . _paused = false ; this . _deltaTime = 0 ; }
function ( spriteFrame ) { if ( typeof ( spriteFrame ) == 'string' ) { var pFrame = cc . SpriteFrameCache . getInstance ( ) . spriteFrameByName ( spriteFrame ) ; if ( pFrame ) { spriteFrame = pFrame ; } else { cc . Log ( "Invalid spriteFrameName: " + spriteFrame ) ; return null ; } } var sprite = new cc . Sprite ( ) ; if ( sprite && sprite . initWithSpriteFrame ( spriteFrame ) ) { return sprite ; } return null ; }
function ( ) { var quantity = ( this . _textureAtlas . getCapacity ( ) + 1 ) * 4 / 3 ; cc . Log ( "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from " + this . _textureAtlas . getCapacity ( ) + " to [" + quantity + "]." ) ; if ( ! this . _textureAtlas . resizeCapacity ( quantity ) ) { cc . Log ( "cocos2d: WARNING: Not enough memory to resize the atlas" ) ; cc . Assert ( false , "Not enough memory to resize the atla" ) ; } }
function ( jsonData ) { var dict = jsonData ; var texturePath = "" ; var metadataDict = dict [ "metadata" ] ; if ( metadataDict ) { texturePath = this . _valueForKey ( "textureFileName" , metadataDict ) ; texturePath = texturePath . toString ( ) ; } var texture = cc . TextureCache . getInstance ( ) . addImage ( texturePath ) ; if ( texture ) { this . _addSpriteFramesWithDictionary ( dict , texture ) ; } else { cc . Log ( "cocos2d: cc.SpriteFrameCache: Couldn't load texture" ) ; } }
function ( file , capacity ) { var texture = cc . TextureCache . getInstance ( ) . addImage ( file ) ; if ( texture ) { return this . initWithTexture ( texture , capacity ) ; } else { cc . Log ( "cocos2d: Could not open file: " + file ) ; return null ; } }
function ( imageUrl ) { var imageType = cc . computeImageFormatType ( imageUrl ) ; if ( imageType == cc . FMT_UNKNOWN ) { cc . Log ( "unsupported format" + imageUrl ) ; return ; } var image = new Image ( ) ; image . src = imageUrl ; image . onLoad = function ( e ) { cc . TextureCache . getInstance ( ) . cacheImage ( imageUrl , image ) ; } ; }
function ( path ) { cc . Assert ( path != null , "TextureCache: file image MUST not be null" ) ; var key = path ; if ( this . textures [ key ] != null ) { return this . textures [ key ] ; } var tex = new cc . Texture2D ( ) ; if ( tex . initWithPVRFile ( key ) ) { this . textures [ key ] = tex ; } else { cc . Log ( "cocos2d: Couldn't add PVRImage:" + key + " in TextureCache" ) ; } return tex ; }
function ( ) { cc . Log ( "--------" ) ; cc . Log ( "--- PNG 128x128 ---" ) ; this . performTestsPNG ( "res/Images/test_image.png" ) ; cc . Log ( "--- PNG 512x512 ---" ) ; this . performTestsPNG ( "res/Images/texture512x512.png" ) ; cc . Log ( "EMPTY IMAGE" ) ; cc . Log ( "--- PNG 1024x1024 ---" ) ; this . performTestsPNG ( "res/Images/texture1024x1024.png" ) ; cc . Log ( "LANDSCAPE IMAGE" ) ; cc . Log ( "--- PNG 1024x1024 ---" ) ; this . performTestsPNG ( "res/Images/landscape-1024x1024.png" ) ; }
function ( dt ) { this . _ticks ++ ; cc . Log ( "schedUpdate: " + dt . toFixed ( 2 ) ) ; if ( this . _ticks > 3 ) { this . _interval += 1.0 ; this . schedule ( this . schedUpdate , this . _interval ) ; this . _ticks = 0 ; } }
function ( ) { this . _super ( ) ; var map = cc . TMXTiledMap . create ( "res/TileMaps/ortho-tile-property.tmx" ) ; this . addChild ( map , 0 , TAG_TILE_MAP ) ; for ( var i = 1 ; i <= 20 ; i ++ ) { cc . Log ( "GID:" + i + ", Properties:" + JSON . stringify ( map . propertiesForGID ( i ) ) ) ; } }
function ( ) { this . _super ( ) ; var map = cc . TMXTiledMap . create ( "res/TileMaps/ortho-rotation-test.tmx" ) ; this . addChild ( map , 0 , TAG_TILE_MAP ) ; var s = map . getContentSize ( ) ; cc . Log ( "ContentSize:" + s . width + "," + s . height ) ; var action = cc . ScaleBy . create ( 2 , 0.5 ) ; map . runAction ( action ) ; }
function ( ) { this . _super ( ) ; var map = cc . TMXTiledMap . create ( "res/TileMaps/ortho-rotation-test.tmx" ) ; this . addChild ( map , 0 , TAG_TILE_MAP ) ; var s = map . getContentSize ( ) ; cc . Log ( "ContentSize:" + s . width + "," + s . height ) ; var action = cc . ScaleBy . create ( 2 , 0.5 ) ; map . runAction ( action ) ; this . schedule ( this . flipIt , 1 ) ; }
function ( ) { this . _super ( ) ; var map = cc . TMXTiledMap . create ( "res/TileMaps/test-object-layer.tmx" ) ; this . addChild ( map , - 1 , TAG_TILE_MAP ) ; var s = map . getContentSize ( ) ; cc . Log ( "ContentSize:" + s . width + "," + s . height ) ; cc . Log ( "---. Iterating over all the group objets" ) ; }
function ( arr , type ) { if ( arr && arr . length > 0 ) { for ( var i = 0 ; i < arr . length ; i ++ ) { if ( ! ( arr [ i ] instanceof type ) ) { cc . Log ( "element type is wrong!" ) ; return false ; } } } return true ; }
function ( ) { doc . location . href = redirectTo ; complete ( oncomplete , verified ) ; }
function ( ) { testEmail ( ) ; ok ( $ ( ".siteinfo" ) . is ( ":visible" ) , "siteinfo is visible when we say what it is" ) ; equal ( $ ( ".website:nth(0)" ) . text ( ) , returnTo , "website is updated" ) ; testHasClass ( "body" , "complete" ) ; equal ( doc . location . href , returnTo , "redirection occurred to correct URL" ) ; equal ( storage . getLoggedIn ( "https://test.domain" ) , "testuser@testuser.com" , "logged in status set" ) ; start ( ) ; }
function ( route ) { if ( ! wn . boot ) { return [ window . page_name ] ; } return $ . map ( wn . get_route_str ( route ) . split ( '/' ) , function ( r ) { return decodeURIComponent ( r ) ; } ) ; }
function ( route ) { if ( ! wn . boot ) { return [ window . page_name ] ; } return $ . map ( wn . get_route_str ( route ) . split ( '/' ) , function ( r ) { return decodeURIComponent ( r ) ; } ) ; }
function ( e ) { if ( item . parent ( ) [ 0 ] . childElementCount < 3 ) return ; if ( item . next ( ) [ 0 ] === item . parent ( ) [ 0 ] . lastElementChild && ! item . children ( ".ItemPrice" ) . val ( ) ) item . next ( ) . remove ( ) ; }
function ( value ) { return value . split ( ':' ) . splice ( 1 ) . join ( ':' ) ; }
function ( value ) { return value . split ( ':' ) . splice ( 1 ) . join ( ':' ) ; }
function ( n ) { var params = { prefix : "exec" , id : n . attr ? n . attr ( "id" ) . replace ( "exec_" , "" ) : - 1 } ; if ( $ ( "#filters #cb_myself" ) . is ( ":checked" ) ) { params [ "myself" ] = true ; } params [ "execution_status" ] = $ ( "#filters :checkbox[name=execution_status]:checked" ) . map ( function ( ) { return $ ( this ) . val ( ) ; } ) . get ( ) ; return params ; }
function ( show ) { if ( show ) { $ ( "#searchbox" ) . val ( "סינון חופשי של ההמלצות" ) ; } else { if ( wm_shown ) $ ( "#searchbox" ) . val ( "" ) ; } wm_shown = show ; return $ ( "#searchbox" ) . toggleClass ( 'watermark' , show ) ; }
function ( show ) { if ( show ) { $ ( "#searchbox" ) . val ( "סינון חופשי של ההמלצות" ) ; } else { if ( wm_shown ) $ ( "#searchbox" ) . val ( "" ) ; } wm_shown = show ; return $ ( "#searchbox" ) . toggleClass ( 'watermark' , show ) ; }
function ( show ) { if ( show ) { $ ( "#searchbox" ) . val ( "סינון חופשי של ההמלצות" ) ; } else { if ( wm_shown ) $ ( "#searchbox" ) . val ( "" ) ; } wm_shown = show ; return $ ( "#searchbox" ) . toggleClass ( 'watermark' , show ) ; }
function ( e ) { var target , _ref ; target = e . target || e . srcElement ; if ( target !== itembox && __indexOf . call ( itembox . childNodes , target ) < 0 && ( ( _ref = target . tagName ) !== 'LI' && _ref !== 'A' && _ref !== 'INPUT' ) ) { return itembox . style . display = 'none' ; } }
function ( event , ui ) { if ( ui . item . is ( 'li' ) ) { carrying = ui . item . html ( ) ; } }
function ( jQuerySelection ) { if ( jQuerySelection != null ) { $ ( jQuerySelection ) . draggable ( { connectToSortable : "#List" , helper : 'clone' , start : function ( event , ui ) { carrying = getHTML ( $ ( this ) ) ; } } ) ; } }
function ( event , ui ) { if ( $ ( this ) . children ( ) . length === 0 ) { $ ( this ) . html ( carrying ) ; addDraggingFeature ( $ ( this ) . find ( "table" ) ) $ ( this ) . css ( "border" , "none" ) ; addDroppableFeature ( $ ( carrying ) . find ( '.droppable' ) ) ; ui . helper . hide ( ) ; ui . draggable . remove ( ) ; } }
function defineConstant ( node , fw ) { var name = node . name , type = getType ( node ) _global . __defineGetter__ ( name , function ( ) { var ptr = fw . lib . get ( name ) ptr . _type = '^' + type var val = ptr . deref ( ) return val } ) }
function ( event ) { moveEvents [ currentIndex ] = [ ] ; currentPoint = event ; moveEvents [ currentIndex ] . push ( event ) ; paint = true ; drawPoints ( ) ; intervalId = setInterval ( function ( ) { moveEvents [ currentIndex ] . push ( currentPoint ) ; } , 100 ) ; }
function ( params , content ) { var myUrl ; if ( params === "" ) { myUrl = content . replace ( /<.*?>/g , "" ) ; } else { myUrl = params . substr ( 1 ) ; } urlPattern . lastIndex = 0 ; if ( ! urlPattern . test ( myUrl ) ) { myUrl = "#" ; } return '<a href="' + myUrl + '">' ; }
function ( matchStr , bbcodeLevel , tagName , tagParams , tagContents ) { var processedContent = tags [ tagName ] . noParse ? unprocess ( tagContents ) : tagContents . replace ( bbRegExp , replaceFunct ) , openTag = tags [ tagName ] . openTag ( tagParams , processedContent ) , closeTag = tags [ tagName ] . closeTag ( tagParams , processedContent ) ; if ( tags [ tagName ] . displayContent === false ) { processedContent = "" ; } return openTag + processedContent + closeTag ; }
function ( initializeDefault ) { if ( SoundJS . activePlugin == null ) { if ( initializeDefault && ! SoundJS . pluginsRegistered ) { SoundJS . registerPlugin ( SoundJS . HTMLAudioPlugin ) ; } if ( SoundJS . activePlugin == null ) { return false ; } } return true ; }
function ( ) { if ( TissueStack . phone ) { TissueStack . Utils . adjustScreenContentToActualScreenSize ( 0 ) ; } _this . addToOrReplaceSelectedDataSets ( dataSet . id , 0 ) ; _this . showDataSet ( 1 ) ; TissueStack . InitUserInterface ( ) ; TissueStack . BindDataSetDependentEvents ( ) ; if ( TissueStack . phone ) { var urlSplit = document . location . href . split ( "#" ) ; var page = urlSplit [ 0 ] ; window . location = page + '#tissueX' ; } }
function ( ) { console . log ( 'grid!' ) ; console . log ( this . grid ) ; this . snake = this . grid . snake = new SNAKE . Snake ( this ) ; this . grid . makeWorld ( ) ; return this . _startGame ( ) ; }
function isNotNative ( classDef ) { if ( ( classDef . flags ( ) & ClassDefinition . IS_NATIVE ) != 0 ) { return false ; } return classDef . forEachClassFromBase ( isNotNative ) ; }
function ( width , height ) { this . viewed_tiles = this . create_matrix ( width , height ) ; for ( var i = 0 ; i < width ; i ++ ) { for ( var j = 0 ; j < height ; j ++ ) { this . viewed_tiles [ i ] [ j ] = this . UNSEEN ; } } }
function ( width , height ) { this . merged_visible_tiles = this . create_matrix ( width , height ) ; for ( var i = 0 ; i < width ; i ++ ) { for ( var j = 0 ; j < height ; j ++ ) { this . merged_visible_tiles [ i ] [ j ] = this . BLOCKED ; } } }
function ( width , height ) { var matrix = new Array ( height ) ; var row ; var col ; for ( row = 0 ; row < height ; row ++ ) { matrix [ row ] = new Array ( width ) ; } return matrix ; }
function ( event ) { var key = event . keyCode || event . which ; if ( key == 27 ) { this . value = t ; this . blur ( ) ; return ; } else if ( key == 13 ) { this . blur ( ) ; return ; } else { h2 . width ( Math . min ( h1 . text ( "pW" + this . value ) . width ( ) , w ) ) ; } }
function ( ) { console . log ( "tree is updated." ) }
function ( ) { if ( this . collection ) { this . collection . off ( ) ; } this . collection = new collections . Graph ( { targets : this . getTargets ( ) , source : this . model . get ( 'source' ) , aggregate_function : this . model . get ( 'aggregate_function' ) || 'sum' , from : this . from ( ) , to : this . to ( ) } ) ; this . collection . on ( 'reset' , this . render ) ; }
function ( ) { if ( this . secondaryCollection ) { this . secondaryCollection . off ( ) ; } this . secondaryCollection = new collections . Graph ( { time : this . model . get ( 'time' ) , targets : this . getTargets ( ) , source : this . model . get ( 'source' ) , aggregate_function : this . model . get ( 'aggregate_function' ) || 'sum' , from : this . previousFrom ( ) , to : this . to ( ) } ) ; }
function ( arg ) { if ( arg ) { var active = Ext . getCmp ( 'viewPort' ) . getActiveItem ( ) ; if ( active . getActiveItem ( ) === PAGES . loginScreen ) { this . doList ( 'familyList' ) ; Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . familyList ) } else if ( active . getActiveItem ( ) === PAGES . familyList ) { this . doList ( 'familyDetails' ) Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . familyDetails ) } } }
function ( imageURI ) { var ft , options ; alert ( "got photo data" ) ; options = new FileUploadOptions ( ) ; options . fileKey = "displayImage" ; options . fileName = imageURI . substr ( imageURI . lastIndexOf ( '/' ) + 1 ) ; options . mimeType = "image/jpeg" ; ft = new FileTransfer ; return ft . upload ( imageURI , this . fimo . hostname + "/upload" , onPhotoUploadSuccess , onPhotoUploadFail , options ) ; }
function ( obj ) { this . syncQueue . push ( obj ) ; }
function ( val ) { this . beginTag = val [ 0 ] ; this . endTag = val [ 1 ] ; this . text = val [ 2 ] ; this . nodeType = val [ 3 ] ; this . id = val [ 4 ] ; }
function ( record , data ) { var index = exports . find ( record , data ) ; if ( index == - 1 ) { return false ; } else { var o = data [ index ] ; for ( var e in record ) { if ( record . hasOwnProperty ( e ) && o . hasOwnProperty ( e ) ) { o [ e ] = record [ e ] ; } } return true ; } }
function ( result ) { var value = result . data ( 'value' ) ; if ( typeof ( value ) == 'string' && isNaN ( value ) && value . match ( /^http:/ ) ) { $ . ajax ( this . autocompleteOptions . url , { async : false , type : 'post' , data : { 'value' : value , } , success : function ( text , jqXHR , textStatus ) { value = text ; } } ) ; } return value ; }
function callbackSliderLoadedChanged ( args ) { $ ( args . sliderObject ) . siblings ( '.paging' ) . children ( '.box' ) . removeClass ( 'selected' ) ; $ ( args . sliderObject ) . siblings ( '.paging' ) . children ( '.box:eq(' + args . currentSlideNumber + ')' ) . addClass ( 'selected' ) ; console . log ( args ) ; }
function handleAfterFeatureEvent ( event , callback ) { self . addFeature ( self . currentFeature ) ; callback ( ) ; }
function ( ) { $ ( '#error' ) . text ( compareGPUAndCPUResults ( ) ) ; $ ( '#render-time' ) . text ( ( renderTime ) . toFixed ( 1 ) ) ; $ ( '#cpu-time' ) . text ( ( cpuTime ) . toFixed ( 1 ) ) ; $ ( '#gpu-time' ) . text ( ( gpuTime ) . toFixed ( 1 ) ) ; $ ( '#read-time' ) . text ( ( readTime ) . toFixed ( 1 ) ) ; }
function ( o ) { o = extend ( o ) ; o . scope = this . frame ; assert ( this . body instanceof BlockStatement ) ; this . body . body = compileList ( this . body . body , o ) ; return this ; }
function ( ) { $ ( this ) . empty ( ) ; }
function ( ) { var m = $ ( this ) . siblings ( '.message' ) . html ( ) ; var s = $ ( this ) . siblings ( '.orig_message' ) . html ( ) ; $ ( this ) . siblings ( '.message' ) . html ( s ) ; $ ( this ) . siblings ( '.orig_message' ) . html ( m ) ; $ ( this ) . text ( '[ Less ]' ) ; }
function ( ) { $ ( '.post .message, .comment .message' ) . linkify ( ) ; $ ( '.timeago' ) . timeago ( ) ; $ ( '.show_older_comments' ) . click ( function ( ) { $ ( this ) . nextAll ( '.comment-hidden' ) . slideDown ( ) . removeClass ( 'comment-hidden' ) ; $ ( this ) . remove ( ) ; } ) ; initMessageToggle ( ) ; }
function ( key ) { var elem = this . stack [ 0 ] ; if ( key ) return elem ? null : elem [ { 'width' : 'offsetWidth' , 'height' : 'offsetHeight' } [ key ] ] ; if ( ! elem ) return { } ; var ret = { 'left' : elem . offsetLeft , 'top' : elem . offsetTop } return ret ; }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function ( ) { var d = util . deferred ( ) ; var c = model . get_rdf ( this . get ( 'url' ) ) ; c . fetch ( ) . then ( function ( ) { console . log ( 'caling resolve ' ) ; d . resolve ( c ) ; } ) ; return d . promise ( ) ; }
function ( m ) { if ( this . row_views [ m . id ] !== undefined ) { throw new Error ( "Cannot add view twice" ) ; } var rw = new RowView ( { model : m , columns : this . options . columns } ) ; this . row_views [ m . id ] = rw ; this . $el . find ( 'tbody' ) . append ( rw . render ( ) ) ; }
function ( arg1 , arg2 , option ) { var entity = this ; if ( typeof arg1 === "string" && arg2 ) { entity . _setOrAddOne ( arg1 , arg2 , option ) ; } else if ( typeof arg1 === "object" ) { _ ( arg1 ) . each ( function ( val , key ) { entity . _setOrAddOne ( key , val , arg2 ) ; } ) ; } return this ; }
function ( ) { wn . views . breadcrumbs ( $ ( '<span>' ) . appendTo ( this . page . appframe . $titlebar ) , locals . DocType [ this . doctype ] . module ) ; this . reportview = new wn . views . ReportView ( this . doctype , this . docname , this . page ) }
function sameOrigin ( url ) { var host = document . location . host ; var protocol = document . location . protocol ; var sr_origin = '//' + host ; var origin = protocol + sr_origin ; return ( url == origin || url . slice ( 0 , origin . length + 1 ) == origin + '/' ) || ( url == sr_origin || url . slice ( 0 , sr_origin . length + 1 ) == sr_origin + '/' ) || ! ( /^(\/\/|http:|https:).*/ . test ( url ) ) ; }
function ( x , y , contents ) { $tooltip . css ( { top : y + 10 , left : x + 10 , } ) ; if ( contents . key !== cur_key ) { cur_key = contents . key ; $tooltip . html ( contents . msg ) ; } if ( ! tooltipvisible ) { tooltipvisible = true ; $tooltip . stop ( true , true ) . fadeIn ( 200 ) ; } }
function ( idx , el ) { jqEl = $ ( el ) ; if ( jqEl . children ( ) . length === 0 ) { json [ el . nodeName ] = jqEl . text ( ) ; } else { json [ el . nodeName ] = self . _AtomToJson ( el ) ; } }
function ( e ) { if ( e . success ) { var tabgroup = ( isAndroid ) ? require ( '../common/ApplicationTabGroup' ) : require ( 'ui/common/ApplicationTabGroup' ) ; tabgroup . ApplicationTabGroup ( ) ; } else { var tabgroup = ( isAndroid ) ? require ( '../common/ApplicationTabGroup' ) : require ( 'ui/common/ApplicationTabGroup' ) ; tabgroup . ApplicationTabGroup ( ) ; Ti . App . fireEvent ( 'error_login' ) ; } }
function ( followedNode , rect ) { var ret = new cc . Follow ( ) ; if ( rect != null && ret && ret . initWithTarget ( followedNode , rect ) ) { return ret ; } else if ( ret && ret . initWithTarget ( followedNode ) ) { return ret ; } return null ; }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = restartTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = nextTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = backTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( node , rule ) { var style = document . styleSheets [ document . styleSheets . length - 1 ] , cssText = style ? ( style . cssRules && style . cssRules [ 0 ] ? style . cssRules [ 0 ] . cssText : style . cssText || '' ) : '' ; bool = /src/i . test ( cssText ) && cssText . indexOf ( rule . split ( ' ' ) [ 0 ] ) === 0 ; }
function ( t ) { try { this . socket . emit ( 'playmusic_order' , t ) ; } catch ( e ) { console . log ( e ) ; } var timer = ( Math . round ( t . length ) + 1 ) * 1000 ; console . log ( "start" ) ; console . log ( t ) ; console . log ( timer ) ; var timeoutId = setTimeout ( this . emit . bind ( this , 'play_done' , t ) , timer ) ; }
function ( ) { var $pre = $ ( "<pre>" ) ; $pre . text ( "Loading..." ) ; this . getResponseContent ( function ( data ) { console . log ( arguments ) $pre . text ( "Content: \n" + data ) ; } ) ; return $pre [ 0 ] ; }
function ( nameOrPattern , callback ) { if ( packet = this . _packets [ nameOrPattern ] ) { pattern = packet . pattern . slice ( 0 ) ; callback = callback || packet . callback || null ; } else { pattern = parse ( nameOrPattern ) ; } this . _pattern = pattern ; this . _callback = callback ; this . _patternIndex = 0 ; }
function ( value ) { pattern = this . _pattern [ this . _patternIndex ] ; little = pattern . endianness == 'l' ; bytes = pattern . bytes ; this . _value = value ; this . _offset = little ? 0 : bytes - 1 ; this . _increment = little ? 1 : - 1 ; this . _terminal = little ? bytes : - 1 ; }
function ( ) { pattern = this . _pattern [ this . _patternIndex ] ; if ( pattern . endianness != "x" ) { this . _skipping = pattern . bytes ; } else { value = pattern . exploded ? [ ] : 0 ; } Parser . prototype . _nextValue . call ( this , value ) ; }
function ( ) { pattern = this . _pattern [ this . _patternIndex ] this . _repeat = pattern . repeat this . _terminated = ! pattern . terminator this . _terminates = ! this . _terminated this . _index = 0 delete this . _padding if ( pattern . endianness == "x" ) { this . _outgoing . splice ( this . _patternIndex , 0 , null ) ; if ( pattern . padding != null ) this . _padding = pattern . padding } }
function ( ) { createButter ( function ( butter ) { var m1 = butter . addMedia ( { name : "Media 1" , target : "audio-test" , url : "../external/popcorn-js/test/trailer.ogv" } ) ; ok ( m1 . name === "Media 1" , "Name is correct" ) ; ok ( m1 . target === "audio-test" && m1 . url === "../external/popcorn-js/test/trailer.ogv" , "Media storage is correct" ) ; start ( ) ; } ) ; }
function ( layer ) { layer . trigger ( 'loading' , layer . id ) this . $el . find ( '#preview-media' ) . append ( layer . visual . render ( ) . el ) ; layer . trigger ( 'player_preload' ) ; }
function ( ) { if ( path . existsSync ( this . options . conf ) ) { return this . logger . info ( "" + this . options . conf + " already exists" ) ; } else { fs . writeFileSync ( this . options . conf , sample_conf ) ; return this . logger . info ( "Wrote " + this . options . conf ) ; } }
function ( options , selected_id ) { var html = "" ; selector . empty ( ) ; KT . utils . each ( options , function ( option ) { html += '<option value="' + option [ 'id' ] + '"' ; if ( option [ 'id' ] === selected_id ) { html += "selected=selected" ; } html += '>' + option [ 'name' ] + '</option>' ; } ) ; selector . append ( html ) ; }
function ( name , id ) { if ( ! id ) { return ; } var list = ac_container . find ( 'ul' ) ; list . find ( '.all' ) . hide ( ) ; if ( ac_container . find ( 'li[data-id=' + id + ']' ) . length === 0 ) { list . prepend ( '<li data-name="' + name + '" data-id="' + id + '">' + name + '<a class="remove">-</a></li>' ) ; } }
function ( event ) { var $this = $ ( this ) ; var options = $this . data ( 'alchemy-overlay' ) ; event . preventDefault ( ) ; Alchemy . openWindow ( $this . attr ( 'href' ) , options . title , options . size_x , options . size_y , options . resizable , options . overflow ) ; return false ; }
function ( ) { refresh_overview ( ) ; window . location . hash = $searchform . serialize ( ) ; var query = window . location . hash . slice ( 1 ) ; query = addstar ( query ) ; $all_results . empty ( ) ; append_search ( 'search?' + query ) ; }
function addslashes ( v ) { v = v . toString ( ) ; v = v . replace ( /\\/g , "\\" ) ; v = v . replace ( /\r/g , "\\r" ) ; v = v . replace ( /\t/g , "\\t" ) ; v = v . replace ( /\f/g , "\\f" ) ; v = v . replace ( /\n/g , "\\n" ) ; return v ; }
function ( hasErrOrWarn , target , className ) { var $t = $ ( target ) ; if ( hasErrOrWarn ) { $t . removeClass ( 'no_' + className ) ; $t . addClass ( className ) ; } else { $t . addClass ( 'no_' + className ) ; $t . removeClass ( className ) ; } }
function ( ) { var id = $ ( this ) . attr ( 'id' ) ; var sid = ( id . length > 25 ) ? ( id . slice ( 0 , 22 ) + ' ...' ) : id return '<li><a href="#' + id + '" title="' + id + '">' + sid + '</a></li>' ; }
function ( ) { logout ( ) ; app . instance . render ( ) ; if ( $ ( '#start' ) . length > 0 ) { app . instance . start ( ) ; } else { app . instance . mainView . render ( ) ; } return false ; }
function ( ) { this . meta = get_local ( 'DocType' , this . doctype ) ; this . perm = get_perm ( this . doctype ) ; if ( this . meta . istable ) { this . meta . in_dialog = 1 } this . setup_print ( ) ; }
function ( ) { if ( ! this . meta . in_dialog ) { set_title ( this . meta . issingle ? this . doctype : this . docname ) ; } if ( this . frm_head ) this . frm_head . refresh ( ) ; if ( wn . ui . toolbar . recent ) wn . ui . toolbar . recent . add ( this . doctype , this . docname , 1 ) ; }
function ( ) { var f = this . page_layout . footer ; if ( f . save_area ) { if ( get_url_arg ( 'embed' ) || ( this . editable && ! this . meta . in_dialog && this . doc . docstatus == 0 && ! this . meta . istable && this . get_doc_perms ( ) [ WRITE ] ) ) { f . show_save ( ) ; } else { f . hide_save ( ) ; } } }
function ( ) { $ ( '.dropdown-toggle' ) . dropdown ( ) ; $ ( ".collapse" ) . collapse ( ) ; $ ( '.mechanic-details, .car-details' ) . click ( function ( e ) { addActiveClass ( this ) ; target = $ ( this ) . attr ( 'data-target' ) url = $ ( this ) . attr ( 'url' ) $ ( target ) . load ( url ) ; } ) }
function Document ( json ) { if ( typeof json === 'string' ) { json = JSON . parse ( json ) ; } else if ( ! json ) { json = { } ; } if ( typeof json !== 'object' ) { throw new Error ( 'A document must be an object' ) ; } this . _raw = json ; }
function ( other ) { var merge = new Merge ( ) ; merge . addDocument ( this . _raw ) ; merge . addDocument ( other ) ; this . _raw = merge . finalize ( ) ; }
function ( doc , ignoreMeta ) { this . id = this . id || doc . _id ; var meta = doc . _meta ; if ( this . addRevision ( doc ) && ! ignoreMeta && meta ) { this . addMeta ( meta ) ; if ( ! this . lastRev ) { this . lastRev = doc . _rev ; if ( meta . history ) { this . lastHistorySize = meta . history . length ; } } } }
function ( ) { if ( ! haveTags ( ) ) { alert ( "Before you upload your files, you should tag them." ) return false ; } $ ( '.files' ) . find ( '.start button' ) . click ( ) ; return true ; }
function ( ) { __executeQueryCommand ( self , replSetGetStatusCommand , { readPreference : ReadPreference . SECONDARY_PREFERRED } , function ( _replerr , _replresult ) { if ( _replerr == null ) { self . serverConfig . validateReplicaset ( _replresult ) ; } } ) }
function ( link ) { link . addEventListener ( 'click' , function ( event ) { var page = url . format ( url . resolve ( location , link . getAttribute ( 'href' ) ) ) ; piccolo . loadPage ( page ) ; event . preventDefault ( ) ; return false ; } ) ; }
function ( error , Resource ) { if ( error ) return piccolo . emit ( 'error' , error ) ; console . log ( Resource ) ; var presenter = new Resource ( document , state . query . href ) ; presenter [ state . resolved . method ] . apply ( presenter , state . resolved . args ) ; }
function ContentSecurityPolicy ( ) { CSPdebug ( "CSP CREATED" ) ; this . _isInitialized = false ; this . _reportOnlyMode = false ; this . _policy = CSPRep . fromString ( "default-src *" ) ; this . _policy . _allowInlineScripts = true ; this . _policy . _allowEval = true ; this . _request = "" ; this . _docRequest = null ; CSPdebug ( "CSP POLICY INITED TO 'default-src *'" ) ; }
function ( aViolationType , aSourceFile , aScriptSample , aLineNum ) { switch ( aViolationType ) { case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_INLINE_SCRIPT : if ( ! this . _policy . allowsInlineScripts ) this . _asyncReportViolation ( 'self' , 'inline script base restriction' , 'violated base restriction: Inline Scripts will not execute' , aSourceFile , aScriptSample , aLineNum ) ; break ; case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_EVAL : if ( ! this . _policy . allowsEvalInScripts ) this . _asyncReportViolation ( 'self' , 'eval script base restriction' , 'violated base restriction: Code will not be created from strings' , aSourceFile , aScriptSample , aLineNum ) ; break ; } }
function generatePlayerobj ( x ) { for ( var i = 0 ; i < x ; i ++ ) { playerObj [ i ] = refPlayerObj [ i ] ; config . player [ playerObj [ i ] . spriteposition ] . taken = true ; } }
function resetArray ( ) { for ( var i = 0 ; i < playerObj . length ; i ++ ) { playerObj [ i ] . wins = 0 ; playerObj [ i ] . money = 0 ; } }
function issuesPage ( ) { initIssuesSearch ( ) ; setSortable ( ) ; $ ( "#label_name" ) . chosen ( ) ; $ ( "#assignee_id" ) . chosen ( ) ; $ ( "#milestone_id" ) . chosen ( ) ; $ ( "#milestone_id, #assignee_id, #label_name" ) . on ( "change" , function ( ) { $ ( this ) . closest ( "form" ) . submit ( ) ; } ) ; }
function ( pack ) { if ( wolfpacks [ pack ] == null ) { var app = new WolfpackPage ( "__pack__" + pack , pack , applicationFrame ) ; menuList . addMenuItem ( "__pack__" + pack , pack ) ; wolfpacks [ pack ] = app ; } }
function ( tile , amount ) { var target , health ; target = tile instanceof TK . Unit ? tile : this . scene . findAt ( tile ) ; if ( target ) { health = target . get ( "health" ) ; target . set ( "health" , health - amount ) ; } }
function ( tile , amount ) { var target , health ; target = tile instanceof TK . Unit ? tile : this . scene . findAt ( tile ) ; if ( target ) { health = target . get ( "health" ) ; target . set ( "health" , health + amount ) ; } }
function ( x , y ) { var size = this . get ( 'size' ) , center = this . findCenter ( ) ; x = this . canvas . width - ( this . canvas . width - x ) - center . x ; y = this . canvas . height - ( this . canvas . height - y ) - center . y ; return { x : floorTo ( x , size ) / size , y : floorTo ( y , size ) / size } ; }
function ( tile , callback ) { var tile2 ; for ( var c in this . units ) { if ( this . units . hasOwnProperty ( c ) ) { tile2 = this . units [ c ] . tile ( ) ; if ( tile . x === tile2 . x && tile . y === tile2 . y ) { if ( callback ) { callback ( this . units [ c ] ) ; } else { return this . units [ c ] ; } } } } }
function ( x , y ) { var size = this . get ( 'size' ) , center = this . findCenter ( ) ; x = this . canvas . width - ( this . canvas . width - x ) - center . x ; y = this . canvas . height - ( this . canvas . height - y ) - center . y ; return { x : floorTo ( x , size ) / size , y : floorTo ( y , size ) / size } ; }
function ( tile , callback ) { var tile2 ; for ( var c in this . units ) { if ( this . units . hasOwnProperty ( c ) ) { tile2 = this . units [ c ] . tile ( ) ; if ( tile . x === tile2 . x && tile . y === tile2 . y ) { if ( callback ) { callback ( this . units [ c ] ) ; } else { return this . units [ c ] ; } } } } }
function ( tile , amount ) { var target , health ; target = tile instanceof TK . Unit ? tile : this . scene . findAt ( tile ) ; if ( target ) { health = target . get ( "health" ) ; target . set ( "health" , health - amount ) ; } }
function ( tile , amount ) { var target , health ; target = tile instanceof TK . Unit ? tile : this . scene . findAt ( tile ) ; if ( target ) { health = target . get ( "health" ) ; target . set ( "health" , health + amount ) ; } }
function ( trackEvent ) { var targetList = createTargetsList ( trackEvent ) ; if ( ! trackEvent . manifest ) { throw "Unable to create properties from null manifest. Perhaps trackevent is not initialized properly yet." ; } var manifestOptions = trackEvent . manifest . options ; for ( var item in manifestOptions ) { if ( manifestOptions . hasOwnProperty ( item ) ) { _rootElement . appendChild ( createManifestItem ( item , manifestOptions [ item ] , trackEvent . popcornOptions [ item ] , trackEvent ) ) ; } } _rootElement . appendChild ( targetList ) ; _this . updatePropertiesFromManifest ( trackEvent . popcornOptions ) ; }
function ( popcornOptions ) { var element ; for ( var option in popcornOptions ) { if ( popcornOptions . hasOwnProperty ( option ) ) { element = _rootElement . querySelector ( "[data-manifest-key='" + option + "']" ) ; if ( element . type === "checkbox" ) { element . checked = popcornOptions [ option ] ; } else { element . value = popcornOptions [ option ] ; } } } }
function openEditor ( trackEvent ) { if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( "default" , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; return _currentEditor ; }
function ( activeModuleName ) { for ( var i in this . globalModuleNavigationButtons ) { var button = this . globalModuleNavigationButtons [ i ] ; if ( dijit . byId ( button ) && button . containerNode ) { dojo . removeClass ( button . containerNode , 'selected' ) ; } } var activeModuleButton = this . globalModuleNavigationButtons [ activeModuleName ] ; if ( activeModuleButton ) { dojo . addClass ( activeModuleButton . containerNode , 'selected' ) ; } }
function ( newString ) { this . _string = newString ; if ( this . _children ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var node = this . _children [ i ] ; if ( node ) { node . setIsVisible ( false ) ; } } } this . createFontChars ( ) ; }
function ( ) { "use strict" ; var Wait = { authentication : { title : gettext ( "Finishing Sign In..." ) , message : gettext ( "In just a moment you'll be signed into BrowserID." ) } , generateKey : { title : gettext ( "Finishing Sign In..." ) , message : gettext ( "Please wait a few seconds while we sign you into the site." ) } , slowXHR : { title : gettext ( "We are sorry, this request is taking a LOOONG time." ) , message : gettext ( "This message will go away when the request completes (hopefully soon). If you wait too long, close this window and try again." ) , id : "slowXHR" } } ; return Wait ; }
function ( ) { var page = Y . one ( '.yui3-cssfonts' ) , h = page . one ( 'h1' ) , i = 0 , size , viewPort = Y . one ( 'body' ) . get ( 'viewportRegion' ) . right - 20 ; size = h . getComputedStyle ( 'fontSize' ) ; Assert . isTrue ( ( ( size === '13px' ) || ( parseInt ( size ) > viewPort ) ) , ' - Failed to set correct h1 - h6 fontsizes' ) ; }
function ( ) { var page = Y . one ( '.yui3-cssfonts' ) , h = page . one ( 'ul li' ) , family = h . getComputedStyle ( 'fontFamily' ) . replace ( /\s/g , "" ) ; Assert . areEqual ( 'arial,helvetica,clean,sans-serif' , family , ' - Failed to set correct h1 - h6 fontsizes' ) ; }
function ( ) { var page = Y . one ( '.yui3-cssreset' ) , h = page . one ( 'h1' ) , i = 0 , size , viewPort = Y . one ( 'body' ) . get ( 'viewportRegion' ) . right - 20 ; size = h . getComputedStyle ( 'fontSize' ) ; Assert . isTrue ( ( ( size === '16px' ) || ( parseInt ( size ) > viewPort ) ) , ' - Failed to set correct h1 - h6 fontsizes' ) ; }
function ( user , repo , number ) { if ( ! ( this instanceof gh . issue ) ) return new gh . commit ( user , repo , number ) ; this . user = user ; this . repo = repo ; this . number = number ; }
function ( ) { for ( var i = 0 ; i < arguments . length ; i ++ ) { var scriptEl = doc . createElement ( 'script' ) ; scriptEl . src = window . Worker . baseURI + arguments [ i ] ; scriptEl . type = 'text/javascript' ; doc . body . appendChild ( scriptEl ) ; } }
function publishStory ( ) { FB . ui ( { method : 'feed' , name : 'I\'m building a social mobile web app!' , caption : 'This web app is going to be awesome.' , description : 'Check out Facebook\'s developer site to start building.' , link : 'http://icebreaker.fb.com/index.html' , picture : 'http://www.colmisainmdom.com/img/headshot.jpg' } , function ( response ) { console . log ( 'publishStory response: ' , response ) ; } ) ; return false ; }
function xb ( a , b ) { this . start = ca ( a ) ? a . clone ( ) : new u ; this . end = ca ( b ) ? b . clone ( ) : new u }
function yb ( a , b , c , d , e ) { if ( ! a . fa ) a . fa = [ ] ; E ( b ) || ( b = 0 ) ; a . fa . push ( setTimeout ( function ( ) { a . fa . splice ( g , 1 ) ; c . apply ( d , e || [ ] ) } , b ) ) ; var g = a . fa . length }
function ( a ) { var b = t ( "^[" + a . source + "\\s]+$" ) , c = t ( "[" + a . source + "]" ) ; a . ca . forEach ( function ( d ) { fa ( v . prototype , "is" + d , function ( ) { return b . test ( this . trim ( ) ) } ) ; fa ( v . prototype , "has" + d , function ( ) { return c . test ( this ) } ) } ) }
function yb ( a , b , c , d , e ) { if ( ! a . fa ) a . fa = [ ] ; E ( b ) || ( b = 0 ) ; a . fa . push ( setTimeout ( function ( ) { a . fa . splice ( g , 1 ) ; c . apply ( d , e || [ ] ) } , b ) ) ; var g = a . fa . length }
function ( a ) { var b = t ( "^[" + a . source + "\\s]+$" ) , c = t ( "[" + a . source + "]" ) ; a . ca . forEach ( function ( d ) { fa ( v . prototype , "is" + d , function ( ) { return b . test ( this . trim ( ) ) } ) ; fa ( v . prototype , "has" + d , function ( ) { return c . test ( this ) } ) } ) }
function xb ( a , b ) { this . start = ca ( a ) ? a . clone ( ) : new u ; this . end = ca ( b ) ? b . clone ( ) : new u }
function ( a ) { var b = t ( "^[" + a . source + "\\s]+$" ) , c = t ( "[" + a . source + "]" ) ; a . ca . forEach ( function ( d ) { fa ( v . prototype , "is" + d , function ( ) { return b . test ( this . trim ( ) ) } ) ; fa ( v . prototype , "has" + d , function ( ) { return c . test ( this ) } ) } ) }
function ( list ) { if ( retVal . tag != "" ) { me . core . setTags ( list , retVal . tag , function ( ) { ew_InstancesTreeView . refresh ( ) } ) ; } else { ew_InstancesTreeView . refresh ( ) ; } me . core . selectTab ( 'ew.tabs.instance' + ( this . core . isVpcMode ( ) ? ".vpc" : "" ) ) ; }
function ( obj ) { var result = [ ] ; multiArgs ( arguments , function ( a ) { if ( a && a . callee ) a = getArgs ( a ) ; result = result . concat ( a ) ; } ) ; return result ; }
function ( ) { var args = getArgs ( arguments ) ; return this . map ( function ( el , i ) { return [ el ] . concat ( args . map ( function ( k ) { return ( i in k ) ? k [ i ] : null ; } ) ) ; } ) ; }
function ( obj ) { var values = object . keys ( obj ) . map ( function ( key ) { return obj [ key ] ; } ) ; return values . reduce . apply ( values , array . create ( arguments ) . slice ( 1 ) ) ; }
function ( ) { var all = arguments . length === 0 , methods = getArgs ( arguments ) ; iterateOverObject ( klass [ 'SugarMethods' ] , function ( name , m ) { if ( all || methods . indexOf ( name ) > - 1 ) { defineProperty ( m . instance ? klass . prototype : klass , name , m . method ) ; } } ) ; }
function getArgs ( args , index ) { return array . prototype . slice . call ( args , index ) ; }
function ( ) { var ret ; storedArguments . push ( getArgs ( arguments ) ) ; counter ++ ; if ( counter == num ) { ret = fn . call ( this , storedArguments ) ; counter = 0 ; storedArguments = [ ] ; return ret ; } }
function ( ) { var args = getArgs ( arguments ) ; curried . forEach ( function ( arg , index ) { if ( arg != null || index >= args . length ) args . splice ( index , 0 , arg ) ; } ) ; return fn . apply ( this , args ) ; }
function ( ) { var fn = this , curried = getArgs ( arguments ) ; return function ( ) { var args = getArgs ( arguments ) ; curried . forEach ( function ( arg , index ) { if ( arg != null || index >= args . length ) args . splice ( index , 0 , arg ) ; } ) ; return fn . apply ( this , args ) ; } }
function ( separator ) { if ( separator === undefined ) separator = '-' ; var str = this . normalize ( ) ; str = str . replace ( /[^a-z0-9\-_]+/gi , separator ) if ( separator ) { str = str . replace ( new RegExp ( '^{sep}+|{sep}+$|({sep}){sep}+' . assign ( { 'sep' : RegExp . escape ( separator ) } ) , 'g' ) , '$1' ) ; } return str . toLowerCase ( ) ; }
function convertCharacterWidth ( str , args , reg , table ) { var mode = getArgs ( args ) . join ( '' ) ; mode = mode . replace ( /all/ , '' ) . replace ( /(\w)lphabet|umbers?|atakana|paces?|unctuation/g , '$1' ) ; return str . replace ( reg , function ( c ) { if ( table [ c ] && ( ! mode || mode . has ( table [ c ] . type ) ) ) { return table [ c ] . to ; } else { return c ; } } ) ; }
function ( ) { doc . head . appendChild ( faviconLink ) ; rasterizeHTML . loadAndInlineCSS ( doc , callback ) ; expect ( callback ) . toHaveBeenCalled ( ) ; expect ( doc . head . getElementsByTagName ( "style" ) . length ) . toEqual ( 0 ) ; expect ( doc . head . getElementsByTagName ( "link" ) . length ) . toEqual ( 1 ) ; }
function ( ) { doc . head . appendChild ( cssLink ) ; rasterizeHTML . loadAndInlineCSS ( doc , callback ) ; expect ( callback ) . toHaveBeenCalled ( ) ; expect ( doc . head . getElementsByTagName ( "style" ) . length ) . toEqual ( 1 ) ; expect ( doc . head . getElementsByTagName ( "style" ) [ 0 ] . textContent ) . toEqual ( "p { font-size: 14px; }" ) ; expect ( doc . head . getElementsByTagName ( "link" ) . length ) . toEqual ( 0 ) ; }
function ( ) { doc . head . appendChild ( emptyCssLink ) ; rasterizeHTML . loadAndInlineCSS ( doc , callback ) ; expect ( callback ) . toHaveBeenCalled ( ) ; expect ( doc . head . getElementsByTagName ( "style" ) . length ) . toEqual ( 0 ) ; expect ( doc . head . getElementsByTagName ( "link" ) . length ) . toEqual ( 0 ) ; }
function ( ) { joinUrlSpy . andCallThrough ( ) ; doc = rasterizeHTMLTestHelper . readDocumentFixtureWithoutBaseURI ( "externalCSS.html" ) ; rasterizeHTML . loadAndInlineCSS ( doc , "./fixtures/" , callback ) ; expect ( callback ) . toHaveBeenCalled ( ) ; expect ( joinUrlSpy ) . toHaveBeenCalledWith ( "./fixtures/" , "some.css" ) ; }
function ( ) { doc . head . appendChild ( brokenCssLink ) ; doc . head . appendChild ( cssLink ) ; rasterizeHTML . loadAndInlineCSS ( doc , callback ) ; expect ( callback ) . toHaveBeenCalledWith ( [ { resourceType : "stylesheet" , url : "a_document_that_doesnt_exist.css" } ] ) ; }
function ( ) { doc . head . appendChild ( brokenCssLink ) ; doc . head . appendChild ( anotherBrokenCssLink ) ; rasterizeHTML . loadAndInlineCSS ( doc , callback ) ; expect ( callback ) . toHaveBeenCalledWith ( [ jasmine . any ( Object ) , jasmine . any ( Object ) ] ) ; expect ( callback . mostRecentCall . args [ 0 ] [ 0 ] ) . not . toEqual ( callback . mostRecentCall . args [ 0 ] [ 1 ] ) ; }
function Request ( request ) { var parsed = url . parse ( request . url , true ) ; this . pathname = request . url ; this . headers = request . headers ; this . method = request . method ; this . pathname = parsed . pathname ; this . hash = parsed . hash ; this . params = parsed . query ; this . data = querystring . parse ( request . post ) ; }
function ( err , stat ) { if ( err || ! stat . isFile ( ) ) { self . send ( 404 ) ; } else { fs . readFile ( self . path , function ( err , buffer ) { if ( err || ! stat . isFile ( ) ) { self . send ( 500 ) ; } else { self . data = buffer ; self . dispatch ( ) ; } } ) ; } }
function ( app , options , fn ) { if ( fn == null ) { fn = options ; options = { } ; } return this . request ( { method : "GET" , path : "/apps/" + app + "/logs" , query : options } , fn ) ; }
function ( delta ) { var choices = this . results . find ( ".select2-result-selectable" ) , index = this . highlight ( ) ; while ( index > - 1 && index < choices . length ) { index += delta ; if ( $ ( choices [ index ] ) . hasClass ( "select2-result-selectable" ) ) { this . highlight ( index ) ; break ; } } }
function ( ) { if ( global . screen . n_workspaces <= 1 ) return false ; this . emit ( 'remove-event' ) ; Main . _removeWorkspace ( this . metaWorkspace ) ; this . removed = true ; return true ; }
function ( ) { this . _stateCounts [ thumbnail . state ] -- ; thumbnail . state = ThumbnailState . DESTROYED ; let index = this . _thumbnails . indexOf ( thumbnail ) ; this . _thumbnails . splice ( index , 1 ) ; thumbnail . destroy ( ) ; this . _queueUpdateStates ( ) ; }
function ( id , offset , callback ) { $ . ajax ( { url : forum_config [ 'url' ] + 'ajax/posts.php' , type : 'post' , data : 'do=getposts&parent=' + id + '&offset=' + offset , success : function ( json ) { json = eval ( '(' + json + ')' ) ; if ( callback ) { callback ( json ) ; } } } ) ; }
function ( changeto , changes ) { if ( this . currentContentPanel != changeto || changeto == 1 ) { this . contentPanelTransitionEffect ( '#contentpanel-' + this . currentContentPanel , '#contentpanel-' + changeto , changes ) ; this . currentContentPanel = changeto ; } }
function ( proj , body ) { var template ; if ( proj == null ) { proj = '.' ; } if ( body == null ) { body = "" ; } template = fs . readFileSync ( "" + proj + "/layout.html" , "utf8" ) ; return eco . render ( template , { body : body } ) ; }
function ( ) { $ . ui . dialog . prototype . _setOption . apply ( this , arguments ) ; $ ( this . refreshButton ) . toggle ( this . options . url !== null ) ; $ ( this . shareButton ) . toggle ( this . options . url !== null ) ; }
function ( options ) { if ( options . id === null ) { options . id = $ . tk . randomId ( ) ; } return dialog = $ ( "<div id=" + options . id + "><!-- --></div>" ) . appendTo ( 'body' ) . dialog ( { disabled : true , autoOpen : false } ) ; }
function extend ( target ) { var mixins = [ ] . slice . call ( arguments , 1 ) ; for ( var index = 0 , mixin ; mixin = mixins [ index ] ; ++ index ) { for ( var key in mixin ) { target [ key ] = mixin [ key ] ; } } return target ; }
function ( ) { var target = { } ; var retval = helpers . extend ( target , { field1 : true , field2 : "value" } ) ; equal ( target . field1 , true , "target extended" ) ; equal ( target . field2 , "value" , "target extended" ) ; strictEqual ( retval , target , "the updated target is returned" ) ; }
function ( json ) { _deviceDetailsDb = jQuery . parseJSON ( json ) ; _deviceDetailsDb [ "os_versions" ] = _deviceDetailsDb [ "os_versions" ] . join ( "," ) . replace ( /\./g , ":" ) . split ( "," ) ; }
function ( ok ) { flag = true ; result = ok ; }
function ( obj ) { if ( uMarker ) { uMarker . setPosition ( new google . maps . LatLng ( obj . lat , obj . lng ) ) ; searchCircle . setCenter ( new google . maps . LatLng ( obj . lat , obj . lng ) ) ; drawMap ( ) ; } }
function JQLiteRemoveData ( element ) { var cacheId = element [ jqName ] , cache = jqCache [ cacheId ] ; if ( cache ) { if ( cache . handle ) { cache . events . $destroy && cache . handle ( { } , '$destroy' ) ; JQLiteUnbind ( element ) ; } delete jqCache [ cacheId ] ; element [ jqName ] = undefined ; } }
function ( ) { expect ( angular . element . cache ) . toEqual ( { } ) ; var div = angular . element ( '<div></div>' ) ; div . data ( 'name' , 'angular' ) ; expect ( keys ( angular . element . cache ) ) . not . toEqual ( [ ] ) ; angular . mock . clearDataCache ( ) ; expect ( keys ( angular . element . cache ) ) . toEqual ( [ ] ) ; }
function ( bodyWrap ) { var errors = bodyWrap . getElementsByTagName ( "stream:error" ) ; if ( errors . length === 0 ) { return ; } var error = errors [ 0 ] ; var condition = error . childNodes [ 0 ] . tagName ; var text = error . getElementsByTagName ( "text" ) [ 0 ] . textContent ; Strophe . error ( "WebSocket stream error: " + condition + " - " + text ) ; this . _c . _changeConnectStatus ( Strophe . Status . CONNFAIL , condition ) ; return Strophe . Status . CONNFAIL ; }
function ( APIKEY , respondToCrewmember ) { console . log ( 'New cremember asking for supervisor for APIKEY: ' + APIKEY ) ; if ( apikeys [ APIKEY ] && apikeys [ APIKEY ] . allowed ) { var thisSupervisor = getSupervisor ( APIKEY ) ; setupForeman ( APIKEY , supervisor ) ; console . log ( 'New cremember reporting to: /' + supervisorNamespace ) ; respondToCrewmember ( supervisorNamespace ) ; } }
function ( cfg ) { var me = this ; cfg = cfg || { } ; me . callParent ( [ Ext . apply ( { storeId : 'access' , model : 'MyApp.model.Access' , data : [ { value : 'RW' , text : 'Read & Write' } , { value : 'RO' , text : 'Read Only' } , { value : '--' , text : 'No Access' } ] } , cfg ) ] ) ; }
function ( next ) { if ( typeof next !== 'function' ) next = function ( err ) { if ( err ) console . error ( err . message ) } ; this . nconf = new require ( 'nconf' ) ; this . load ( next ) ; }
function ( err ) { ( fs . existsSync || path . existsSync ) ( confTest . file ) ; }
function ( err ) { var confTest = new Config ( { path : path . join ( rootpath , 'tmp' ) } ) ; confTest . get ( 'test:setsave' ) . should . equal ( 'Yah!' ) ; }
function ( ) { this . cleanUpIncompleteConnection_ ( ) ; if ( ! this . isConnected ( ) ) return ; this . state_ = goog . net . xpc . ChannelStates . CLOSED ; this . transport_ . dispose ( ) ; this . transport_ = null ; this . connectCb_ = null ; goog . net . xpc . logger . info ( 'Channel "' + this . name + '" closed' ) ; }
function ( ) { goog . base ( this , 'disposeInternal' ) ; this . close ( ) ; this . peerWindowObject_ = null ; this . iframeElement_ = null ; delete goog . net . xpc . channels_ [ this . name ] ; goog . dispose ( this . peerLoadHandler_ ) ; delete this . peerLoadHandler_ ; }
function ( title , items , modeless ) { var params = { core : this , title : title , items : items || [ "" ] , values : null , modeless : modeless } ; var win = window . openDialog ( "chrome://ew/content/dialogs/input.xul" , null , "chrome,centerscreen,resizable," + ( modeless ? "modeless" : "modal" ) , params ) ; return modeless ? win : ( params . ok ? params . values : null ) ; }
function ( model , obj , field ) { var o = this . findModel ( this . getModel ( model ) , obj [ field || 'id' ] ) ; if ( o ) { for ( var p in obj ) { o [ p ] = obj [ p ] ; } } else { this . addModel ( model , obj ) ; } }
function ( list ) { if ( retVal . tag != "" ) { me . core . setTags ( list , retVal . tag , function ( ) { ew_InstancesTreeView . refresh ( ) } ) ; } else { ew_InstancesTreeView . refresh ( ) ; } me . core . selectTab ( 'ew.tabs.instance' ) ; }
function bummer_init ( ) { var profile_link = $ ( '.headerTinymanPhoto' ) . attr ( 'id' ) ; var parts = profile_link . split ( '_' ) ; var id = parts [ 3 ] ; if ( id ) { Current_FBUID = id ; Port . postMessage ( { type : 'access_token_request' , id : Current_FBUID } ) ; } }
function ( type , data ) { switch ( type ) { case 'load' : this . _attributes . _naturalWidth = data . width ; this . _attributes . _naturalHeight = data . height ; this . _mutatedAttributes . naturalWidth = true ; this . _mutatedAttributes . naturalHeight = true ; this . emit ( 'load' , this ) ; this . markUpdate ( ) ; break ; case 'error' : this . emit ( 'error' , Error ( data . error ) , this ) ; break ; } return this ; }
function ( type , data ) { switch ( type ) { case 'load' : this . emit ( 'load' , this ) ; break ; case 'error' : this . emit ( 'error' , Error ( data . error ) , this ) ; break ; } return this ; }
function ( type , data ) { switch ( type ) { case 'load' : this . attr ( { width : data . width , height : data . height } ) ; this . emit ( 'load' ) ; break ; case 'error' : this . emit ( 'error' , new Error ( data . error ) ) ; } return this ; }
function ( ) { if ( timeout ) { clearTimeout ( timeout ) ; } if ( opts . type ) { if ( opts . type . toLowerCase ( ) != 'auto' ) { return cb ( returnType ( opts . type , body ) , null , res ) ; } } cb ( body , null , res ) ; }
function returnType ( type , body ) { switch ( type . toLowerCase ( ) ) { case 'jsdom' : var jsdom = require ( "jsdom" ) var _jsdom = new jsdom . jsdom ( body , null , { features : { QuerySelector : true } } ) ; return _jsdom . createWindow ( ) ; case 'json' : return JSON . parse ( body ) ; case 'xml' : var parser = require ( 'xml2json' ) ; return JSON . parse ( parser . toJson ( body ) ) ; default : return body ; } }
function ( ) { expect ( hadError ) . toEqual ( true ) ; }
function ( ) { page . onError = function ( ) { hadError = true } ; page . evaluate ( function ( ) { caughtError = false ; setTimeout ( function ( ) { try { referenceError } catch ( e ) { caughtError = true ; } } , 0 ) } ) ; }
function ( selector , eventName ) { var handler = function ( e ) { data . spiedEvents [ [ selector , eventName ] ] = e } jQuery ( selector ) . bind ( eventName , handler ) data . handlers . push ( handler ) }
function ( selector ) { this . message = function ( ) { return [ "Expected event " + this . actual + " to have been triggered on " + selector , "Expected event " + this . actual + " not to have been triggered on " + selector ] } return jasmine . JQuery . events . wasTriggered ( $ ( selector ) , this . actual ) }
function ( selector ) { this . message = function ( ) { return [ "Expected event " + this . actual + " to have been prevented on " + selector , "Expected event " + this . actual + " not to have been prevented on " + selector ] } return jasmine . JQuery . events . wasPrevented ( selector , this . actual ) }
function ( ) { $ ( '#clickme' ) . bind ( 'click' , function ( event ) { event . preventDefault ( ) } ) $ ( '#clickme' ) . click ( ) expect ( 'click' ) . toHaveBeenPreventedOn ( $ ( '#clickme' ) ) }
function ( value ) { if ( arguments . length === 0 ) { return this . selection . data ( "select2-data" ) ; } else { if ( ! value || value === "" ) { this . clear ( ) ; } else { this . opts . element . val ( ! value ? "" : this . id ( value ) ) ; this . updateSelection ( value ) ; } } }
function unselect_metadata_file ( ) { selected_metadata_file = "" ; selected_libraries = [ ] ; document . getElementById ( "sel_md_pill" ) . className = "pill_incomplete" ; document . getElementById ( "icon_step_1" ) . style . display = "none" ; update_inbox ( ) ; check_submittable ( ) ; }
function ( str ) { if ( ! this . _options . color ) return this . _write ( str ) ; if ( before ) before . call ( this ) ; this . _write ( str ) ; this . cursor . reset ( ) ; return this ; }
function ( e ) { var x = e . pageX - this . offsetLeft ; var y = e . pageY - this . offsetTop ; mouseDown = true ; drawCircle ( x , y ) ; }
function ( ) { if ( ! this . haEnabled ) return false ; var currentTime = new Date ( ) . getTime ( ) ; if ( ( currentTime - this . lastReplicaSetTime ) >= this . replicasetStatusCheckInterval && ! this . haProcessInProgress ) { this . haProcessInProgress = true ; this . lastReplicaSetTime = currentTime ; return true ; } else { return false ; } }
function ( ) { __executeAllCallbacksWithError ( parent , err ) ; if ( typeof parent . openCalled != 'undefined' ) parent . openCalled = false ; if ( callback != null ) { var internalCallback = callback ; callback = null ; internalCallback ( err , null ) ; } else { if ( parent . listeners ( "close" ) . length > 0 ) { parent . emit ( "close" , err ) ; } } }
function ( ) { __executeAllCallbacksWithError ( parent , err ) ; if ( typeof parent . openCalled != 'undefined' ) parent . openCalled = false ; if ( callback != null ) { var internalCallback = callback ; callback = null ; internalCallback ( new Error ( "connection timed out" ) , null ) ; } else { if ( parent . listeners ( "error" ) . length > 0 ) { parent . emit ( "timeout" , new Error ( "connection timed out" ) ) ; } } }
function ( ) { __executeAllCallbacksWithError ( parent , err ) ; if ( typeof parent . openCalled != 'undefined' ) parent . openCalled = false ; if ( callback != null ) { var internalCallback = callback ; callback = null ; internalCallback ( err , null ) ; } else { if ( parent . listeners ( "error" ) . length > 0 ) { parent . emit ( "error" , err ) ; } } }
function ( err ) { var internalCallback = callback ; callback = null ; process . nextTick ( function ( ) { parent . emit ( "fullsetup" , null , parent ) ; replSetSelf . emit ( "fullsetup" , null , parent ) ; } ) ; if ( typeof internalCallback == 'function' ) { internalCallback ( null , parent ) ; } }
function ( err ) { var internalCallback = callback ; callback = null ; process . nextTick ( function ( ) { parent . emit ( "fullsetup" , null , parent ) ; replSetSelf . emit ( "fullsetup" , null , parent ) } ) ; if ( typeof internalCallback == 'function' ) { internalCallback ( null , parent ) ; } }
function ( ev ) { var signer = new geierlein . Signer ( ) ; signer . setKeyFromPkcs12Der ( ev . target . result , pincode ) ; geierlein . sendData ( asTestcase , signer ) ; }
function ( evt ) { var $this = $ ( this ) , target = $this . attr ( 'href' ) , targetId = target . substring ( 1 ) ; if ( document . getElementById ( targetId ) === null ) return false ; $ . bbq . pushState ( '/' + targetId , 2 ) ; evt . preventDefault ( ) ; }
function ( ) { var args = arguments var argsSize = packets . OutgoingPacket . calcArgs ( args ) var size = 2 + argsSize var packet = new packets . OutgoingPacket ( client , packets . TYPE_CALLBACK , size ) packet . writeUInt16BE ( id , packet . index ) packet . index += 2 packet . writeArgs ( args , argsSize ) return client . sendPacket ( packet ) }
function ( ) { $ ( '#edit_descriptions_link' ) . attr ( 'class' , '' ) ; $ ( '#edit_versioning_link' ) . attr ( 'class' , 'active' ) ; $ ( '#edit_permissions_link' ) . attr ( 'class' , '' ) ; $ ( '#descriptions_display' ) . hide ( ) ; $ ( '#versioning_display' ) . show ( ) ; $ ( '#permissions_display' ) . hide ( ) ; $ ( '#permissions_submit' ) . hide ( ) ; }
function ( val ) { if ( _state !== val ) { _state = val ; if ( _state ) { document . body . classList . remove ( "minimized" ) ; _element . setAttribute ( "data-ui-state" , "visible" ) ; _this . dispatch ( "uivisibilitychanged" , true ) ; } else { document . body . classList . add ( "minimized" ) ; _element . setAttribute ( "data-ui-state" , "hidden" ) ; _this . dispatch ( "uivisibilitychanged" , false ) ; } } }
function ( menu ) { if ( menu . data ( 'scrollPanel' ) ) { console . log ( '---- update' , menu . data ( 'scrollPanel' ) ) ; menu . scrollPanel ( 'updateContainerWidth' ) ; } else { console . log ( '---- add' ) ; menu . scrollPanel ( { children : '> ul > li' } ) ; } }
function ( newValue ) { if ( arguments . length ) { this . options . value = newValue ; this . _refreshValue ( ) ; this . _change ( null , 0 ) ; return ; } return this . options . value ; }
function ( map ) { self . mapHandlers = [ new MMHandlers . MouseWheelHandler ( self . map , self . mapModel ) , new MMHandlers . TouchHandler ( self . map , self . mapModel , self . guideModel ) , new MMHandlers . MouseWheelHandler ( self . map , self . mapModel ) , ] }
function checkInstantResume ( isPaused , arg2 , cont ) { if ( ! isPaused && arg2 === true ) { var options = $ ( cont ) . data ( 'cycle.opts' ) ; if ( ! options ) { log ( 'options not found, can not resume' ) ; return false ; } if ( cont . cycleTimeout ) { clearTimeout ( cont . cycleTimeout ) ; cont . cycleTimeout = 0 ; } go ( options . elements , options , 1 , ! options . backwards ) ; } }
function ( event ) { offersListComp = $ ( '#' + offersListName ) ; $ . ajax ( { url : 'allOffers.xml' , dataType : 'xml' , success : populateOffers } ) ; }
function ( ) { $ ( '#handPhone' ) . animate ( { opacity : 1 , bottom : '-950' , left : '590px' , width : '492px' } , 3000 , function ( ) { $ ( '.phoneSlideshowSmall' ) . fadeIn ( ) ; phonesmall = 1 ; } ) ; }
function ( ) { var player = Players . find ( this . _id ) . fetch ( ) [ 0 ] ; console . log ( "You pressed the button on player:" + player . name + " id" + this . _id ) ; Session . set ( "selected_player" , this . _id ) ; Session . set ( "team1_action" , "main" ) ; }
function ( ) { var height = 0 ; $ ( '#playerContainer > .block' ) . each ( function ( ) { height += $ ( this ) . outerHeight ( true ) ; } ) ; if ( $ ( '#container' ) . hasClass ( 'vertical' ) && ! $ ( '#container' ) . hasClass ( 'fullscreen' ) ) { height += $ ( '#playlistContainer' ) . outerHeight ( true ) ; } return height ; }
function ( ) { if ( $ ( '#container' ) . hasClass ( 'vertical' ) && ! $ ( '#container' ) . hasClass ( 'fullscreen' ) ) { $ ( '#playerContainer' ) . height ( window . innerHeight - $ ( '#playlistContainer' ) . outerHeight ( true ) ) ; } }
function ( ) { delete this . $ ; can . Control . prototype . destroy . call ( this ) ; }
function ( ) { S ( "#scrollable" ) . click ( ) . wait ( 100 ) ; S ( '.can_ui_table_scroll div:eq(1)' ) . scroll ( "left" , 10 ) ; S ( '.can_ui_table_scroll div:eq(0)' ) . scrollLeft ( 10 , function ( ) { ok ( true , "assertions make people feel better" ) } ) ; }
function ( e , ret ) { if ( e && ! isSyntaxError ( e ) ) return finish ( e ) ; if ( typeof ret === 'function' || e ) { self . eval ( evalCmd , self . context , 'repl' , finish ) ; } else { finish ( null , ret ) ; } }
function ( ) { var articlesData = { } ; for ( articleId in this . articles ) { var articleData = { "id" : articleId , "name" : this . articles . name } ; articlesData [ articleId ] = articleData ; } return articleData ; }
function ( articlesData ) { }
function ( trackEvent ) { var targetList = createTargetsList ( trackEvent ) ; var manifestOptions = trackEvent . manifest . options ; for ( var item in manifestOptions ) { if ( manifestOptions . hasOwnProperty ( item ) ) { _rootElement . appendChild ( createManifestItem ( item , manifestOptions [ item ] , trackEvent . popcornOptions [ item ] , trackEvent ) ) ; } } _rootElement . appendChild ( targetList ) ; _this . updatePropertiesFromManifest ( trackEvent . popcornOptions ) ; }
function openEditor ( trackEvent ) { if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( "default" , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; }
function ( ) { var slide = $ ( "<div/>" , { 'class' : 'item item1' , 'id' : 'item1' } ) . append ( $ ( '<img />' , { 'src' : '../../_site-demo/_img/h-slider-1.jpg' } ) ) ; ; $ ( '.add-remove-slide-slider' ) . iosSlider ( 'addSlide' , slide , 6 ) ; }
function ( ) { $ ( this ) . nextAll ( '.error' ) . first ( ) . hide ( ) ; $ ( this ) . nextAll ( '.help' ) . first ( ) . show ( ) . css ( 'display' , 'block' ) ; }
function ( ) { $ ( this ) . nextAll ( '.error' ) . first ( ) . hide ( ) ; $ ( this ) . nextAll ( '.help' ) . first ( ) . show ( ) . css ( 'display' , 'block' ) ; }
function ( ) { var cancel = false ; if ( callback ) { cancel = callback ( ) ; } if ( cancel ) { return ; } dojo . forEach ( handles , function ( handle ) { dojo . disconnect ( handle ) } ) ; myDialog . destroyRecursive ( ) ; }
function ( ) { this . map . controls . add ( 'typeSelector' , { right : 5 , top : 5 } ) ; this . map . controls . add ( 'zoomControl' , { right : 5 , top : 50 } ) ; }
function ( filename ) { var dir = path . dirname ( filename ) , base = path . basename ( filename ) if ( ! listingCache [ dir ] ) listingCache [ dir ] = path . existsSync ( dir ) ? fs . readdirSync ( dir ) : [ ] return listingCache [ dir ] . indexOf ( base ) !== - 1 }
function breathe ( fn ) { var t = jq . now ( ) , dt = t - _t0 ; if ( dt > 2500 ) { _t0 = t ; dt >>= 6 ; setTimeout ( fn , dt < 10 ? dt : 10 ) ; return true ; } }
function ( evt ) { if ( this . inRoundedMold ( ) && ! this . _buttonVisible ) return ; if ( ! this . _disabled && ! zk . animating ( ) ) { if ( this . _open ) this . close ( { focus : true , sendOnOpen : true } ) ; else this . open ( { focus : true , sendOnOpen : true } ) ; } evt . stop ( ) ; }
function ( err , js ) { if ( err ) { if ( ! ( err instanceof Error ) ) { err = new Error ( err ) ; } throw err ; send ( createSomethingWentWrong ( ) ) ; return ; } cache [ key ] = js ; send ( js ) ; }
function ( a ) { if ( a . slug === req . params . assignslug ) { console . log ( a ) ; ass . push ( a ) ; } }
function ( ) { switch ( this . model . get ( 'state' ) ) { case 'folder' : break ; case 'config' : this . toggleModal ( true ) ; break ; } }
function ( container ) { if ( this . isvisible ( ) && context [ 'container-height' ] != parseInt ( container . style . height ) ) { __view_is_destroyed = true ; this . createView ( container ) ; messages . post ( 'view-created' , { id : this . id , container : container } ) ; } }
function ( id ) { if ( ! ( id in __runtimes ) ) { opera . postError ( ui_strings . S_DRAGONFLY_INFO_MESSAGE + 'runtime id does not exist' ) ; __runtimes [ id ] = null ; var tag = tagManager . set_callback ( this , this . handleListRuntimes ) ; services [ 'ecmascript-debugger' ] . requestListRuntimes ( tag , [ id ] ) ; } }
function ( ) { return stop_at_user_settings ; }
function ( ) { if ( ! _is_initial_settings_set ) { var config_arr = [ ] , prop = '' ; for ( prop in stop_at_settings ) { config_arr [ stop_at_id_map [ prop ] ] = ( ( stop_at_user_settings [ prop ] = settings [ 'js_source' ] . get ( prop ) ) || stop_at_settings [ prop ] ) && 1 || 0 ; } ecma_debugger . requestSetConfiguration ( 0 , config_arr ) ; _is_initial_settings_set = true ; } }
function ( container ) { container . clearAndRender ( templates . network_options_main ( this . _bypass_cache , this . _track_bodies , this . _headers , this . _overrides ) ) ; this . _output = container . querySelector ( "code" ) ; this . _headerele = container . querySelector ( ".header-override-input" ) ; }
function ( container ) { container . clearAndRender ( templates . network_request_crafter_main ( this . _prev_url , this . _is_listening , this . _prev_request , this . _prev_response ) ) ; this . _urlfield = new cls . BufferManager ( container . querySelector ( "input" ) ) ; this . _input = new cls . BufferManager ( container . querySelector ( "textarea" ) ) ; this . _output = container . querySelector ( "code" ) ; }
function ( ) { return [ "div" , [ "div" , [ "span" , "class" , "ui-button" , "handler" , "reload-window" , "tabindex" , "1" ] ] , [ "p" , ui_strings . S_HTTP_INCOMPLETE_LOADING_GRAPH ] , [ "span" , " " , "class" , "close_incomplete_warning" , "handler" , "close-incomplete-warning" , "tabindex" , "1" ] , "class" , "info-box network_incomplete_warning" ] ; }
function ( status , message ) { const DATA = 0 ; if ( status === 0 && message [ DATA ] ) { var error_messages = message [ DATA ] ; for ( var i = 0 , error_message ; error_message = error_messages [ i ] ; i ++ ) { this . _on_console_message ( error_message ) ; } ; } }
function ( evt , target ) { this . clear ( ) ; var cursor_pos = this . _textarea_handler . get_cursor ( ) ; this . _data . clear ( ) ; this . _textarea . focus ( ) ; this . _textarea_handler . put_cursor ( cursor_pos ) ; return false ; }
function ( event ) { if ( this . _textarea && ! /^(?:input|textarea|button)$/i . test ( event . target . nodeName ) && ! event . target . hasTextNodeChild ( ) ) { this . _textarea . focus ( ) ; this . _current_scroll = null ; } else { this . _current_scroll = this . _container . scrollTop ; } }
function ( msg ) { this . _top_rt_id = msg . runtimes_with_dom [ 0 ] ; if ( this . _take_screenshot && this . isvisible ( ) ) { this . _pixel_magnifier . scale = 1 ; window . messages . post ( 'screenshot-scale' , { scale : this . _pixel_magnifier . scale } ) ; this . _get_window_size ( ) ; } }
function ( ) { if ( window . messages ) { window . messages . addListener ( 'active-tab' , this . _on_active_tab . bind ( this ) ) ; window . messages . addListener ( 'reset-state' , this . _on_reset_state . bind ( this ) ) ; } }
function ( id , name , view_list , default_unfolded_list ) { this . _super_createView = this . createView ; this . createView = function ( container ) { this . _super_createView ( container ) ; var quick_find = this . getToolbarControl ( container , 'css-inspector-text-search' ) ; var search_term = window . element_style . get_search_term ( ) ; if ( quick_find && search_term ) { quick_find . value = search_term ; } } this . init ( id , name , view_list , default_unfolded_list ) ; }
function ( ) { this . init ( id , name , container_class ) ; this . _container = null ; this . _update_layout_bound = this . update_layout . bind ( this ) ; this . _update_offsets_bound = this . update_offsets . bind ( this ) window . messages . addListener ( "setting-changed" , this . _on_setting_change . bind ( this ) ) ; }
function ( key , value , sync_switches ) { window . localStorage . setItem ( key , JSON . stringify ( this . map [ key ] = value ) ) ; if ( this . callback_map . hasOwnProperty ( key ) ) { this . callback_map [ key ] . call ( this , value ) ; } messages . post ( "setting-changed" , { id : this . view_id , key : key } ) ; }
function ( id ) { var id_c = '' , i = 0 ; for ( ; ( id_c = this . container_ids [ i ] ) && id_c != id ; i ++ ) ; if ( id_c ) { this . container_ids . splice ( i , 1 ) ; } }
function ( cell ) { this . init ( this , arguments ) ; this . _history = [ ] ; this . tabs = [ ] ; this . activeTab = '' ; this . cell = cell ; }
function ( button_templates , group , view_id ) { var ret = [ "toolbar-buttons" , button_templates ] ; if ( group . type ) { ret . push ( "handler" , "toolbar-" + group . type ) ; if ( group . type === "single-select" ) { ret = ret . concat ( [ "data-single-select-name" , group . name , "data-view-id" , view_id ] ) ; } } return ret ; }
function ( switches ) { var ret = [ "toolbar-buttons" ] , i = 0 , setting = null ; ret . extend ( switches . map ( this . _switch , this ) ) ; ret . push ( "handler" , "toolbar-switch" ) ; return ret ; }
function ( filters ) { var id = '' , i = 0 , ret = [ ] ; for ( ; id = ids [ i ] ; i ++ ) { if ( views [ id ] . type == 'single-view' && ( ! filters || ! filter ( views [ id ] , filters ) ) ) { ret [ ret . length ] = id ; } } return ret ; }
function ( ) { var id = '' , i = 0 , c = null , ret = [ ] ; for ( ; id = this . container_ids [ i ] ; i ++ ) { if ( c = document . getElementById ( id ) ) { ret [ ret . length ] = c ; } } return ret ; }
function ( id , name , container_class ) { this . _highlighter = new VirtualTextSearch ( ) ; this . _highlight_style = this . _highlighter . get_match_style ( 'highlight' ) ; this . init ( id , name , container_class , '' , 'clear-search-hit' ) ; var clear_search_hit = this . _onscroll . bind ( this ) ; eventHandlers . scroll [ 'clear-search-hit' ] = clear_search_hit ; window . messages . addListener ( "panel-search-executed" , clear_search_hit ) ; }
function ( code ) { buf . setCode ( code ) ; buf . cmd ( "javascript_dl_mode" , true ) ; ymacs . switchToBuffer ( buf ) ; }
function ( url ) { filepicker . saveAs ( url , "*/*" , { "modal" : true } , function ( ) { alert ( "File saved" ) ; } ) ; }
function createColumnPropertiesOnObject ( obj ) { var columnName ; for ( columnName in obj . _getModel ( ) . columns ) { var column = obj . _getModel ( ) . columns [ columnName ] ; if ( ! obj [ columnName ] ) { if ( ! column . foreignKey ) { obj [ columnName ] = column . defaultValue ( ) ; } } } }
function ( ) { var ret = 'apps' ; var fh = ini . get ( 'feedhenry' ) ; if ( fh && fh !== '' ) { var dom_start = fh . indexOf ( ':' ) + 3 ; var dom_end = fh . indexOf ( '.' ) ; ret = fh . substring ( dom_start , dom_end ) ; } return ret ; }
function save ( user , cookie ) { var o ; var keyId = keys . KEY_ID ; if ( arguments . length == 1 ) { o = { } ; o [ keyId ] = user ; } else if ( arguments . length == 2 ) { o = { user : user , cookie : cookie } ; } saveTarget ( o ) ; }
function getOffsetOf ( child , parent ) { var result = { x : 0 , y : 0 } ; if ( ! child || ! parent || child === parent || ! $ . contains ( parent , child ) ) return result ; do { result . x += child . offsetLeft ; result . y += child . offsetTop ; if ( child === parent ) break ; } while ( child = child . offsetParent ) ; return result ; }
function ( callback ) { var confirmMessage , _this = this ; if ( App . localStorageAvailable && this . getConfigFromLocalStorage ( ) ) { confirmMessage = "I have detected data stored in you local storage, Do you want to load it?" ; return this . confirmBox . initConfirmation ( confirmMessage , function ( e ) { if ( e ) { _this . MarkersConfig = _this . getConfigFromLocalStorage ( ) ; } else { _this . MarkersConfig = Markers ; } return callback ( ) ; } ) ; } else { this . MarkersConfig = Markers ; return callback ( ) ; } }
function ( data ) { schemas . push ( data ) ; urlsGot ++ ; if ( urlsGot === includeSchemaURLs . length + 1 ) { init ( ) ; } }
function light_switch ( ) { if ( lights === 'off' ) { $ ( 'body' ) . css ( 'background' , prefs [ 'light_color' ] ) ; lights = 'on' ; } else if ( lights === 'on' ) { $ ( 'body' ) . css ( 'background' , prefs [ 'bg_color' ] ) ; lights = 'off' ; } }
function ( a , b ) { for ( var i = 0 ; i < b . length ; i ++ ) for ( var j = 0 ; j < b [ i ] . length ; j ++ ) a [ i ] [ j ] = b [ i ] [ j ] ; }
function ( ) { if ( this . current < this . last ) { this . current += 1 ; this . set ( this . current ) ; } else if ( this . current === this . last ) { this . set ( this . current ) ; } else { this . end = true ; $ . timer . stop ( ) ; $ . endGame . init ( "win" ) ; return "end game" ; } }
function NoClickDelay ( el , options ) { this . element = $j ( el ) ; this . options = options || { } ; if ( window . Touch ) this . element . off ( 'touchstart' ) . on ( 'touchstart' , this ) ; }
function ( e ) { switch ( e . type ) { case 'touchstart' : this . onTouchStart ( e ) ; break ; case 'touchmove' : this . onTouchMove ( e ) ; break ; case 'touchend' : this . onTouchEnd ( e ) ; break ; } }
function ( ) { config . current = this ; if ( config . notrycatch ) { this . testEnvironment . teardown . call ( this . testEnvironment ) ; return ; } else { try { this . testEnvironment . teardown . call ( this . testEnvironment ) ; } catch ( e ) { QUnit . ok ( false , "Teardown failed on " + this . testName + ": " + e . message ) ; } } checkPollution ( ) ; }
function ( params ) { params = extend ( extend ( { } , QUnit . urlParams ) , params ) ; var querystring = "?" , key ; for ( key in params ) { if ( ! hasOwn . call ( params , key ) ) { continue ; } querystring += encodeURIComponent ( key ) + "=" + encodeURIComponent ( params [ key ] ) + "&" ; } return window . location . pathname + querystring . slice ( 0 , - 1 ) ; }
function escapeInnerText ( s ) { if ( ! s ) { return "" ; } s = s + "" ; return s . replace ( /[\&<>]/g , function ( s ) { switch ( s ) { case "&" : return "&amp;" ; case "<" : return "&lt;" ; case ">" : return "&gt;" ; default : return s ; } } ) ; }
function fail ( message , exception , callback ) { if ( typeof console !== "undefined" && console . error && console . warn ) { console . error ( message ) ; console . error ( exception ) ; console . error ( exception . stack ) ; console . warn ( callback . toString ( ) ) ; } else if ( window . opera && opera . postError ) { opera . postError ( message , exception , callback . toString ) ; } }
function ( done ) { var opts = { endpoint : '' } ; setupMock ( function ( opts , callback ) { assert . ok ( typeof callback === 'function' ) ; assert . equal ( opts . method , 'GET' ) ; done ( ) ; } ) ; var op = seraph . operation ( opts , '' ) ; seraph . call ( opts , op ) ; }
function ( done ) { var opts = { endpoint : '' } ; var testObject = { foo : 'foo' , bar : 10 } ; setupMock ( function ( opts , callback ) { assert . ok ( typeof callback === 'function' ) ; assert . equal ( opts . method , 'POST' ) ; assert . deepEqual ( opts . json , testObject ) ; done ( ) ; } ) ; var op = seraph . operation ( opts , '' , testObject ) ; seraph . call ( opts , op ) ; }
function ( done ) { var opts = { endpoint : '' } ; var obj = { } ; setupMock ( function ( opts , callback ) { assert . equal ( opts . uri , '/db/data/' ) ; done ( ) ; } ) ; var op = seraph . operation ( opts , '' , obj ) ; seraph . call ( opts , op ) ; }
function ( ) { console . debug ( '[Heatmap.update]' ) ; this . clearEverything ( ) ; this . recalibrateHeatmap ( ) ; this . context . translate ( this . o_x , this . o_y ) ; this . scaleContext . translate ( this . o_x , this . o_y ) ; this . drawStatusBar ( ) ; this . drawGrid ( ) ; }
function ( pair ) { try { console . debug ( '[Heatmap.hidePairsExcept] hiding pair: ' + pair ) ; self . model . hiddenPairs . hidePair ( pair ) ; } catch ( e ) { } _ . each ( visiblePairs , function ( vp ) { if ( vp == pair ) { console . debug ( '[Heatmap.hidePairsExcept] revealing pair: ' + pair ) ; self . model . hiddenPairs . revealPair ( pair ) ; } } ) ; }
function ( ) { var self = this ; var pairs = this . model . aggregates . pluck ( 'pair' ) ; var html = '<select id="pair-filter" data-placeholder="Select pairs to hide" style="width: 600px;" multiple class="chzn-select">' html = html + '<option value=""></option>' _ . each ( pairs , function ( pair ) { html = html + self . buildOption ( pair , self . model . hiddenPairs . get ( pair ) ) ; } ) ; html = html + '</select>' ; return html ; }
function ( method , model , opts ) { var self = this ; console . debug ( '[HiddenPair.sync] method: ' + method ) ; if ( method == "read" ) { Backbone . sync ( method , model , opts ) ; } else if ( method == "delete" ) { self . deleteModel ( self . deleteUrl ( self . collection . user , self . collection . domain . id , self . id ) ) ; } }
function ( pairKey ) { var self = this ; self . add ( { id : pairKey , user : self . user , domain : self . domain . id } ) ; $ . ajax ( { url : self . putUrl ( pairKey ) , type : 'PUT' } ) ; }
function ( models , options ) { var self = this ; _ . each ( models , function ( model ) { console . debug ( '[HiddenPairs.remove] model: ' + model . id ) ; if ( model ) { model . destroy ( { wait : true } ) ; } } ) ; }
function ( p ) { var v = { } ; Ext . apply ( v , this . store . baseParams ) ; Ext . apply ( v , p ) ; this . pagingBar . changePage ( 1 ) ; this . store . baseParams = v ; this . store . load ( ) ; }
function ( ) { events . fire ( new Event ( EventCode . SCHEME . CREATED , { parent : parent , uri : uri , type : 'scheme' } ) ) ; events . fire ( new Event ( EventCode . CONCEPT . UPDATED , { uris : [ parent , uri ] } ) ) ; close ( ) ; }
function ( ) { events . fire ( new Event ( EventCode . CONCEPT . CREATED , { parent : parent , uri : uri , type : 'top-concept' } ) ) ; events . fire ( new Event ( EventCode . CONCEPT . UPDATED , { uris : [ parent , uri ] } ) ) ; close ( ) ; }
function ( ) { events . fire ( new Event ( EventCode . CONCEPT . CREATED , { parent : parent , uri : uri , type : 'concept' } ) ) ; events . fire ( new Event ( EventCode . CONCEPT . UPDATED , { uris : [ parent , uri ] } ) ) ; close ( ) ; }
function ( ) { events . fire ( new Event ( EventCode . GRAPH . SELECTED , { uri : uri } ) ) ; events . fire ( new Event ( EventCode . CONCEPT . UPDATED , { uris : [ uri ] } ) ) ; close ( ) ; }
function ( ) { events . fire ( new Event ( EventCode . CONCEPT . UPDATED , { uris : [ graph ] } ) ) ; settings . setLanguages ( ls2 ) ; updated = true ; write ( ) ; } , function ( ) { alert ( "could not set languages" ) }
function ( ) { events . fire ( new Event ( EventCode . CONCEPT . UPDATED , { uris : [ graph ] } ) ) ; settings . setLanguages ( ls ) ; updated = true ; write ( ) ; } , function ( ) { alert ( "could not set languages" ) }
function ( ) { var algs = self . options ( ) . algs ; if ( algs && algs . length ) { var data = parts ; algs . forEach ( function ( elem ) { data = elem . callback . call ( data ) ; } ) ; self . persist ( data ) ; } }
function ( event ) { event . preventDefault ( ) ; var delete_link = $ ( event . currentTarget ) ; var id = parseInt ( delete_link . attr ( 'id' ) . replace ( "todo-delete-" , "" ) ) ; $ ( '#delete-todo-id' ) . html ( id ) ; $ ( '#delete-todo-modal' ) . modal ( 'show' ) ; }
function done ( value ) { var expected = ( 24 + 3 + 1 + 2 + 3 ) * 200 ; if ( value == expected ) testPassed ( "done() called with " + expected ) ; else testFailed ( "done() called with " + value + ", but expected " + expected ) ; layoutTestController . notifyDone ( ) ; }
function done ( value ) { var expected = ( 24 + 3 + 1 + 2 + 3 ) * 200 ; if ( value == expected ) testPassed ( "done() called with " + expected ) ; else testFailed ( "done() called with " + value + ", but expected " + expected ) ; layoutTestController . notifyDone ( ) ; }
function done ( value ) { var expected = ( 24 + 3 ) * 200 + 19900 + 20100 + 39800 ; if ( value == expected ) testPassed ( "done() called with " + expected ) ; else testFailed ( "done() called with " + value + ", but expected " + expected ) ; layoutTestController . notifyDone ( ) ; }
function ( e ) { if ( e . success ) refresh ( ) ; else alert ( 'Error:\\n' + ( ( e . error && e . message ) || JSON . stringify ( e ) ) ) ; }
function ( ) { var value ; for ( i = 0 ; i < lbl_arr . length ; i ++ ) { value = new Text ( lbl_arr [ i ] ) ; value . scale . set ( scale , scale , scale ) ; value . position . x = pos_arr [ i ] ; value . position . y = 1 ; value . position . z = 58 ; mesh . add ( value ) ; } }
function ( ) { var label = new Text ( config . label ) ; label . scale . set ( scale , scale , scale ) ; label . position . x = - 47 ; label . position . y = 1 ; label . position . z = 63 ; mesh . add ( label ) ; }
function ( points ) { var path = new THREE . SplineCurve3 ( points ) , tube = new THREE . TubeGeometry ( path , 20 , 0.2 , 10 , false , true ) ; return new THREE . Mesh ( tube , new THREE . MeshBasicMaterial ( { color : 0xff0000 , wireframe : false } ) ) ; }
function ( text , title ) { text = text || "(an empty string)" ; if ( title ) text = "<b>" + title + "</b><br/>" + text ; counter [ 0 ] ++ ; bCount [ 0 ] . remove ( ) ; bCount [ 0 ] = paper . text ( paper . width - 125 , 11 , counter [ 0 ] ) . attr ( { fill : "white" } ) ; mask . toFront ( ) ; this . addMessage ( text , 0 ) ; }
function ( ev ) { var city = $ ( this ) . val ( ) ; if ( city . match ( /[a-zA-z]/ ) ) { $ ( '.city-correct' ) . attr ( 'data-status' , 'correct' ) ; cityCheck = true ; } if ( city . match ( /[0-9]/ ) ) { $ ( '.city-correct' ) . attr ( 'data-status' , 'incorrect' ) ; cityCheck = false ; } if ( city . match ( /[^a-zA-z0-9\s]/ ) ) { $ ( '.city-correct' ) . attr ( 'data-status' , 'correct' ) ; cityCheck = false ; } }
function ( sender , vm ) { this . fireBusEvent ( 'displayEditVMDialog' , { hn : vm . getParent ( ) , compute : vm } ) ; }
function emit ( event , args ) { var callbacks = events [ event ] || false ; if ( callbacks === false ) { return self ; } for ( var i in callbacks ) { if ( callbacks . hasOwnProperty ( i ) ) { callbacks [ i ] ( args ) ; } } return self ; }
function wsc_packetstr ( cmd , param , args , body ) { var ret = '' ; if ( cmd ) { ret = cmd if ( param ) { ret = ret + " " + param ; } } if ( args ) { for ( var key in args ) { ret = ret + "\n" + key + "=" + args [ key ] ; } } ret = ret + "\n" ; if ( body ) { ret = ret + "\n" + body ; } return ret ; }
function ( ) { this . window . css ( { 'display' : 'block' } ) ; this . tab . addClass ( 'active' ) ; this . resize ( ) ; }
function ( e ) { pack = wsc_packet ( e . pkt [ "body" ] ) ; this . info [ 'members' ] = { } ; while ( pack [ "cmd" ] == "member" ) { this . registerUser ( pack ) ; pack = wsc_packet ( pack . body ) ; if ( pack == null ) break ; } this . setUserList ( ) ; }
function ( evt ) { this . client . trigger ( 'connected.wsc' , { name : 'connected' , pkt : wsc_packet ( 'connected\n\n' ) } ) ; this . client . connected = true ; this . client . handshake ( ) ; }
function ( evt ) { var pack = wsc_packet ( evt . data ) ; if ( pack == null ) return ; var event = this . client . event_name ( pack ) ; pevt = this . packetEvent ( event , pack ) ; this . log ( pevt ) ; this . client . trigger ( 'data.wsc' , pevt ) ; this . client . trigger ( event + '.wsc' , pevt ) ; }
function ( name , packet ) { args = { 'name' : name , 'pkt' : packet , 'ns' : this . client . mns } ; if ( ! this . maps [ name ] ) return args ; mapping = this . maps [ name ] ; cmd = packet . cmd ; if ( this . mapper [ cmd ] ) this . mapper [ cmd ] ( args , packet , mapping ) ; else this . mapPacket ( args , packet , mapping ) ; return args ; }
function ( ) { if ( client . connected ) return ; if ( CanCreateWebsocket ( ) ) { client . conn = client . createChatSocket ( ) ; client . trigger ( 'start.wsc' , wsc_packet ( 'client connecting\ne=ok\n\n' ) ) ; } else { client . monitor ( "Your browser does not support WebSockets. Sorry." ) ; client . trigger ( 'start.wsc' , wsc_packet ( 'client connecting\ne=no websockets available\n\n' ) ) ; } }
function ( ) { this . window . css ( { 'display' : 'block' } ) ; this . tab . addClass ( 'active' ) ; this . resize ( ) ; }
function ( e ) { pack = wsc_packet ( e . pkt [ "body" ] ) ; this . info [ 'members' ] = { } ; while ( pack [ "cmd" ] == "member" ) { this . registerUser ( pack ) ; pack = wsc_packet ( pack . body ) ; if ( pack == null ) break ; } this . setUserList ( ) ; }
function ( ) { if ( client . connected ) return ; if ( CanCreateWebsocket ( ) ) { client . conn = client . createChatSocket ( ) ; client . trigger ( 'start.wsc' , wsc_packet ( 'client connecting\ne=ok\n\n' ) ) ; } else { client . monitor ( "Your browser does not support WebSockets. Sorry." ) ; client . trigger ( 'start.wsc' , wsc_packet ( 'client connecting\ne=no websockets available\n\n' ) ) ; } }
function emit ( event , args ) { var callbacks = events [ event ] || false ; if ( callbacks === false ) { return self ; } for ( var i in callbacks ) { if ( callbacks . hasOwnProperty ( i ) ) { callbacks [ i ] ( args ) ; } } return self ; }
function wsc_packetstr ( cmd , param , args , body ) { var ret = '' ; if ( cmd ) { ret = cmd if ( param ) { ret = ret + " " + param ; } } if ( args ) { for ( var key in args ) { ret = ret + "\n" + key + "=" + args [ key ] ; } } ret = ret + "\n" ; if ( body ) { ret = ret + "\n" + body ; } return ret ; }
function ( evt ) { this . client . trigger ( 'connected.wsc' , { name : 'connected' , pkt : wsc_packet ( 'connected\n\n' ) } ) ; this . client . connected = true ; this . client . handshake ( ) ; }
function ( evt ) { var pack = wsc_packet ( evt . data ) ; if ( pack == null ) return ; var event = this . client . event_name ( pack ) ; pevt = this . packetEvent ( event , pack ) ; this . log ( pevt ) ; this . client . trigger ( 'data.wsc' , pevt ) ; this . client . trigger ( event + '.wsc' , pevt ) ; }
function ( name , packet ) { args = { 'name' : name , 'pkt' : packet , 'ns' : this . client . mns } ; if ( ! this . maps [ name ] ) return args ; mapping = this . maps [ name ] ; cmd = packet . cmd ; if ( this . mapper [ cmd ] ) this . mapper [ cmd ] ( args , packet , mapping ) ; else this . mapPacket ( args , packet , mapping ) ; return args ; }
function ( options ) { options = options || { } ; email = options . email ; var self = this ; self . renderWait ( "is_this_your_computer" , options ) ; dom . focus ( "#this_is_my_computer" ) ; self . click ( "#this_is_my_computer" , self . yes ) ; self . click ( "#this_is_not_my_computer" , self . no ) ; Module . sc . start . call ( self , options ) ; }
function ( event ) { var locationModels = _ ( event . get ( 'location' ) . map ( function ( l ) { return nameResolver . resolve ( l ) ; } ) ) . flatten ( ) ; return { _oid : event . id , "http://purl.org/NET/c4dm/event.owl#place" : locationModels } ; }
function ( opt_data , opt_sb ) { var output = opt_sb || new soy . StringBuilder ( ) ; var elementList1096 = opt_data . list ; var elementListLen1096 = elementList1096 . length ; for ( var elementIndex1096 = 0 ; elementIndex1096 < elementListLen1096 ; elementIndex1096 ++ ) { var elementData1096 = elementList1096 [ elementIndex1096 ] ; output . append ( '<div class="well"><h3>' , soy . $$escapeHtml ( elementData1096 . title ) , '</h3></div><p>' , soy . $$escapeHtml ( elementData1096 . body ) , '</p>' ) ; } return opt_sb ? '' : output . toString ( ) ; }
function ( ) { var name = $ . trim ( $ ( this . el ) . find ( "#folderName-input" ) . val ( ) ) ; console . log ( name ) ; if ( name . length > 0 ) { this . options . folder . set ( { name : name } ) ; this . options . folder . save ( ) ; this . options . context . backToMain ( ) ; } }
function ( ) { $ ( this . el ) . find ( "a" ) . text ( this . model . get ( 'name' ) ) ; this . messageContainer . find ( "#folderName" ) . text ( this . model . get ( 'name' ) ) ; }
function ( ) { this . options . collection . bind ( 'reset' , this . addAll , this ) ; this . options . collection . fetch ( ) ; }
function ( ) { self . remove ( ) ; }
function ( ) { this . permissions = new PermissionList ( ) ; this . permissions . bind ( 'reset' , this . addAll , this ) ; }
function ( ev , ui ) { minuteDelta = Math . round ( ( ui . position . top - origPosition . top ) / slotHeight ) * opt ( 'slotMinutes' ) ; if ( minuteDelta != prevMinuteDelta ) { if ( ! allDay ) { updateTimeText ( minuteDelta ) ; } prevMinuteDelta = minuteDelta ; } }
function updateTimeText ( minuteDelta ) { var newStart = addMinutes ( cloneDate ( event . start ) , minuteDelta ) ; var newEnd ; if ( event . end ) { newEnd = addMinutes ( cloneDate ( event . end ) , minuteDelta ) ; } timeElement . text ( formatDates ( newStart , newEnd , opt ( 'timeFormat' ) ) ) ; }
function ( node , elem , content , move ) { if ( elem . isRoot ) throw new Error ( 'can not insert content at beforebegin on root element' ) ; var insert = elem . pos . beforeend + elem . pos . afterend + 1 ; replaceContent ( node , insert , insert , content ) ; moveParentSiblings ( elem , move ) ; if ( node . document . liveParsing === true ) { insertElements ( elem . parent , elem . parent . indexOf ( elem ) + 1 , insert , content ) ; } }
function ( feed ) { var subscribers = subscriptions [ feed . src ] || [ ] ; subscribers . forEach ( function ( s ) { s ( feed ) ; } ) ; }
function ( response ) { response = this . parse ( response ) ; this . add . apply ( this , response ) ; this . trigger ( 'fetchSuccess' , { response : response } ) ; }
function ( response ) { self . html ( selector ? $ ( document . createElement ( 'div' ) ) . html ( response . replace ( rscript , "" ) ) . find ( selector ) . html ( ) : response ) success && success . call ( self ) }
function playMovie ( building ) { window . plugins . videoPlayer . play ( 'http://tali.irail.be/REST/Movie/qrID/' + building . token + '.gp3' ) ; }
function ( ) { it ( 'should delete a target' , function ( ) { spyOnPromise ( Mongo , 'deleteTarget' ) . andCallSuccess ( ) ; spyOnPromise ( Mongo , 'findTargetById' ) . andCallSuccess ( '12345678901234567890abcd' ) ; spyOnPromise ( Mongo , 'deleteTargetById' ) . andCallSuccess ( '12345678901234567890abcd' ) ; req . params . id = '12345678901234567890abcd' ; API . deleteTarget ( req , res , next ) ; expect ( Mongo . deleteTargetById ) . toHaveBeenCalledWith ( '12345678901234567890abcd' ) ; } ) ; }
function ( x , y , r ) { var p = new Circle ( { x : x || 0 , y : y || 0 , radio : r || 50 } ) ; p . ownerDocument = this ; return p ; }
function float_done ( ) { running = false if ( ! isIgnored ) { if ( isQuiet ) handler ( atok . offset - atok . offsetBuffer , - 1 , null ) else { var num = Number ( atok . slice ( atok . offsetBuffer , atok . offset ) ) if ( isFinite ( num ) ) handler ( num , - 1 , null ) else { } } } if ( resetOffsetBuffer ) atok . offsetBuffer = - 1 }
function float_done ( ) { running = false if ( ! isIgnored ) { if ( isQuiet ) handler ( atok . offset - atok . offsetBuffer , - 1 , null ) else { var num = Number ( atok . slice ( atok . offsetBuffer , atok . offset ) ) if ( isFinite ( num ) ) handler ( num , - 1 , null ) else { } } } if ( resetOffsetBuffer ) atok . offsetBuffer = - 1 }
function browser_updateSecurityIcon ( ) { if ( ! this . currentTab . security ) { this . sslIndicator . value = '' ; return ; } this . sslIndicator . value = this . currentTab . security . state ; }
function browser_selectTab ( id ) { this . currentTab = this . tabs [ id ] ; this . urlInput . value = this . currentTab . title ; this . tabCover . setAttribute ( 'src' , this . currentTab . screenshot ) ; if ( this . currentTab . loading ) { this . throbber . classList . add ( 'loading' ) ; } this . updateSecurityIcon ( ) ; this . refreshButtons ( ) ; }
function ( tab ) { var t = this ; tab . firstChild . className = '' ; tab . setAttribute ( "aria-selected" , false ) ; tab . setAttribute ( "aria-expanded" , false ) ; tab . tabIndex = - 1 ; }
function ( data , appType , callback ) { var document ; switchIndex ( appType ) ; switchMapping ( 1 ) ; document = mapping . document ( data . id ) ; document . set ( data , function ( ) { callback ( ) ; } ) ; }
function ( uuid , user , title , body ) { this . id = uuid ; this . user = user ; this . upvote = 0 ; this . downvote = 0 ; this . title = title ; this . body = body ; this . target_uuid = '' ; this . objectType = '' ; this . timestamp = '2012-07-01' ; this . isAnswered = 'false' ; }
function ( ) { var o = $ ( this ) . parents ( '.box' ) ; $ . ajax ( { url : "/delete" , type : "POST" , data : { id : o . data ( 'id' ) , } , } ) . success ( function ( ) { o . fadeOut ( 'slow' ) ; } ) ; }
function ( ) { $ . ajax ( { url : "/update" , type : "POST" , } ) . success ( function ( ) { success ( "Обновление успешно выполнено" ) ; } ) . fail ( function ( e , b ) { fail ( "Ошибка при обновлении" ) ; } ) ; }
function onLoad ( ) { db = window . openDatabase ( "newsDB" , "1.0" , "News Database" , 256 * 1024 ) ; createDatabase ( ) ; loadItems ( ) ; fetchItems ( ) ; }
function ( ) { if ( extraFormOptions ) { $ . extend ( true , this . options , extraFormOptions ) ; } this . setupNotificationArea ( ) ; $ ( this . options . crudFormSelector , this . el ) . crudForm ( this . options . crudFormOptions , this . options . areaName ) ; this . setupBeforeSubmitions ( ) ; }
function ( ) { KYT . vent . unbind ( "AddUpdateItem" ) ; $ ( this . options . gridContainer ) . trigger ( "reloadGrid" ) ; KYT . vent . bind ( "AddUpdateItem" , this . editItem , this ) ; }
function ( ) { this . options . noBubbleUp = true ; this . popupForm = this . options . view ? new KYT . Views [ this . options . view ] ( this . options ) : new KYT . Views . AjaxFormView ( this . options ) ; this . popupForm . render ( ) ; this . storeChild ( this . popupForm ) ; $ ( this . el ) . append ( this . popupForm . el ) ; }
function ( nodeName , node , songString ) { if ( nodeName === 'ul' ) { return '[ul]\n' + songString + '\n[/ul]' ; } if ( nodeName === 'li' ) { var parent = node . parent ( ) [ 0 ] ; if ( parent && parent . nodeName . toLowerCase ( ) === 'ul' && node . next ( ) . length ) { return songString + '\n' ; } } }
function ( nodeName , node , songString ) { if ( nodeName === 'ol' ) { return '[ol]\n' + songString + '\n[/ol]' ; } if ( nodeName === 'li' ) { var parent = node . parent ( ) [ 0 ] ; if ( parent && parent . nodeName . toLowerCase ( ) === 'ol' && node . next ( ) . length ) { return songString + '\n' ; } } }
function ( ) { var $el = $ ( this ) , href = $el . data ( 'target' ) || $el . attr ( 'href' ) , $href = /^#\w/ . test ( href ) && $ ( href ) return ( $href && href . length && [ [ $href . position ( ) . top , href ] ] ) || null }
function ( jqXHR , textStatus , errorThrown ) { var errorData = { } ; try { errorData = JSON . parse ( jqXHR . responseText ) ; } catch ( e ) { } alert ( "An error occured: " + errorData . message || errorThrown + "\n\rPlease indicate if this error is relevant to your expected result. If yes, please try again or contact the administrator of this service." ) ; $ ( "#loading" ) . hide ( ) ; }
function dragstart ( e ) { e . dataTransfer . effectAllowed = "copy" ; var realtarget = $ ( e . target ) . closest ( ".tracker-div" ) ; e . dataTransfer . setData ( "Text" , realtarget . attr ( "id" ) ) ; $ ( "#tracker-info" ) . html ( "Drag here to create a new group" ) ; }
function drop ( e ) { e . preventDefault ( ) ; var realtarget = $ ( e . target ) . closest ( ".tracker-div" ) ; var data = e . dataTransfer . getData ( "Text" ) ; $ . ajax ( { url : "/ajax?request=move_tracker&url=" + data . split ( "tracker-" ) [ 1 ] + "&target_alias=" + realtarget . attr ( "id" ) . split ( "tracker-" ) [ 1 ] , success : function ( data ) { console . log ( data ) ; } } ) ; }
function ( data , response ) { console . log ( 'Request on complete' ) ; if ( response . statusCode !== 200 ) { console . log ( "Non 200 response: " + response . statusCode ) ; } else { res . json ( JSON . parse ( data ) ) ; } }
function ( type ) { var interpreter_type = type ; if ( type . search ( /effect$/ ) != - 1 ) { interpreter_type = "effect" ; tmp_tag . effect = type ; this . child_interpreters [ "effect" ] . setObjs ( label && [ label ] || pieces ) ; } label = this . child_interpreters [ interpreter_type ] . interpret ( tmp_tag ) ; }
function ( ) { $ ( this ) . attr ( 'data-text' , $ ( this ) . text ( ) ) ; $ ( this ) . text ( '收起回复' ) ; $ ( this ) . parent ( ) . parent ( ) . next ( ) . show ( ) ; }
function ( date ) { var dateobj = new Date ( date ) ; return dateobj ; }
function ( err , email ) { if ( err ) { logger . error ( 'verfication of primary assertion failed unexpectedly dbwriter (' + err + '): ' + req . body . assertion ) ; return httputils . serverError ( res ) ; } db . createUserWithPrimaryEmail ( email , function ( err , uid ) { if ( err ) return wsapi . databaseDown ( res ) ; res . json ( { success : true , userid : uid } ) ; } ) ; }
function ( req , res ) { var email = req . query . email ; db . emailIsVerified ( email , function ( err , verified ) { if ( err ) return wsapi . databaseDown ( res , err ) ; res . json ( { status : verified ? 'complete' : 'pending' } ) ; } ) ; }
function ( error ) { if ( error ) { logger . warn ( "error removing email " + email ) ; if ( error === 'database connection unavailable' ) { wsapi . databaseDown ( res , error ) ; } else { httputils . badRequest ( res , error . toString ( ) ) ; } } else { res . json ( { success : true } ) ; } }
function ( err , secret ) { if ( err ) return wsapi . databaseDown ( res , err ) ; var langContext = wsapi . langContext ( req ) ; req . session . pendingAddition = secret ; res . json ( { success : true } ) ; email . sendConfirmationEmail ( req . body . email , req . body . site , secret , langContext ) ; }
function ( err , secret ) { if ( err ) return wsapi . databaseDown ( res , err ) ; var langContext = wsapi . langContext ( req ) ; req . session . pendingReset = secret ; res . json ( { success : true } ) ; email . sendForgotPasswordEmail ( req . body . email , req . body . site , secret , langContext ) ; }
function ( err , secret ) { if ( err ) return wsapi . databaseDown ( res , err ) ; if ( ! req . session ) req . session = { } ; req . session . pendingCreation = secret ; res . json ( { success : true } ) ; email . sendNewUserEmail ( req . body . email , req . body . site , secret , langContext ) ; }
function ( err ) { var success = true ; if ( err ) { logger . error ( "error updating bcrypted password for email " + req . body . email , err ) ; wsapi . databaseDown ( res , err ) ; } else { res . json ( { success : success } ) ; } }
function ( err , uid ) { if ( err ) return wsapi . databaseDown ( res , err ) ; if ( ! uid ) return res . json ( { success : false , reason : "internal error" } ) ; wsapi . authenticateSession ( req . session , uid , 'assertion' , req . body . ephemeral ? config . get ( 'ephemeral_session_duration_ms' ) : config . get ( 'authentication_duration_ms' ) ) ; return res . json ( { success : true , userid : uid } ) ; }
function ( mdown , headingLevel ) { mdown = normalizeLineBreaks ( mdown ) ; _headingLevel = ( headingLevel || 2 ) ; var toc = getTocData ( mdown ) ; return { toc : toc , html : parseContent ( mdown , toc ) , title : getTitle ( mdown ) } ; }
function createChangeOrRemoveStoryMessage ( li , newStoryName ) { var storyId = $ ( li ) . attr ( "data-id" ) ; if ( $ . trim ( newStoryName ) === "" ) { var removeStoryMessage = { MessageId : newGuid ( ) , MessageType : "RemoveStory" , StoryId : storyId } ; return removeStoryMessage ; } var changeStoryNameMessage = { MessageId : newGuid ( ) , MessageType : "ChangeStoryName" , StoryId : storyId , Name : newStoryName } ; return changeStoryNameMessage ; }
function parseBitwiseORExpression ( ) { var expr = parseBitwiseANDExpression ( ) ; while ( match ( '|' ) ) { lex ( ) ; expr = { type : Syntax . BinaryExpression , operator : '|' , left : expr , right : parseBitwiseANDExpression ( ) } ; } return expr ; }
function parseBitwiseXORExpression ( ) { var expr = parseBitwiseORExpression ( ) ; while ( match ( '^' ) ) { lex ( ) ; expr = { type : Syntax . BinaryExpression , operator : '^' , left : expr , right : parseBitwiseORExpression ( ) } ; } return expr ; }
function parseLogicalANDExpression ( ) { var expr = parseBitwiseXORExpression ( ) ; while ( match ( '&&' ) ) { lex ( ) ; expr = { type : Syntax . LogicalExpression , operator : '&&' , left : expr , right : parseBitwiseXORExpression ( ) } ; } return expr ; }
function _addFileToIndexes ( entry ) { if ( brackets . platform === "mac" && entry . name . charAt ( 0 ) === "." ) { return ; } var fileInfo = new FileInfo ( entry ) ; $ . each ( _indexList , function ( indexName , index ) { if ( index . filterFunction ( entry ) ) { index . fileInfos . push ( fileInfo ) ; } } ) ; }
function ( ) { var acord = new Fx . Accordion ( $ ( 'acord' ) , '#acord h2' , '#acord p' ) , current = $$ ( '.current' ) ; acord . addEvent ( 'active' , function ( t , e ) { current . removeClass ( 'current' ) ; current = t ; t . addClass ( 'current' ) ; } ) ; }
function javaScriptFunctionProvider ( hostEditor , pos ) { if ( hostEditor . getModeForSelection ( ) !== "javascript" ) { return null ; } var sel = hostEditor . getSelection ( false ) ; if ( sel . start . line !== sel . end . line ) { return null ; } var functionName = _getFunctionName ( hostEditor , hostEditor . getSelection ( ) . start ) ; if ( functionName === "" ) { return null ; } return _createInlineEditor ( hostEditor , functionName ) ; }
function ( ) { FileViewController . openAndSelectDocument ( testPath + "/edit.js" , FileViewController . PROJECT_MANAGER ) . done ( function ( ) { didOpen = true ; } ) . fail ( function ( ) { gotError = true ; } ) ; }
function ( ) { var doc = DocumentManager . getCurrentDocument ( ) ; doc . setText ( doc . getText ( ) + "\n\nfunction TESTFUNCTION() {\n    return true;\n}\n" ) ; FileIndexManager . getFileInfoList ( "all" ) . done ( function ( fileInfos ) { var extensionRequire = brackets . getModule ( 'utils/ExtensionLoader' ) . getRequireContextForExtension ( 'JavaScriptQuickEdit' ) ; var JSUtilsInExtension = extensionRequire ( "JSUtils" ) ; JSUtilsInExtension . findMatchingFunctions ( "TESTFUNCTION" , fileInfos ) . done ( function ( result ) { functions = result ; } ) ; } ) ; }
function browser_handleTabsBadgeClicked ( ) { if ( this . currentScreen === this . TABS_SCREEN ) { var tabId = this . createTab ( ) ; this . selectTab ( tabId ) ; this . showAwesomeScreen ( ) ; return ; } if ( this . currentScreen === this . AWESOME_SCREEN && this . previousScreen === this . PAGE_SCREEN ) { this . showPageScreen ( ) ; return ; } if ( this . currentScreen === this . AWESOME_SCREEN ) { this . deleteTab ( this . currentTab . id ) ; } this . showTabScreen ( ) ; }
function ( source , actor , x , y , time ) { if ( source instanceof FavoritesButton ) { AppFavorites . getAppFavorites ( ) . removeFavorite ( source . app . get_id ( ) ) ; return true ; } return false ; }
function ( ) { var url = document . location . toString ( ) ; if ( url . match ( '#/' ) ) { $ ( '.nav-tabs a[href=#' + url . split ( '#/' ) [ 1 ] + ']' ) . tab ( 'show' ) ; } else if ( url . match ( '#' ) ) { $ ( '.nav-tabs a[href=#' + url . split ( '#' ) [ 1 ] + ']' ) . tab ( 'show' ) ; } }
function ( data ) { self . removeAttr ( 'disabled' ) . parents ( '.field:first' ) . removeClass ( 'loading' ) ; var newVal = decodeURIComponent ( data . value ) ; self . val ( newVal ) ; if ( oldVal != newVal ) { jQuery . noticeAdd ( ss . i18n . _t ( 'The URL has been changed' ) ) ; } }
function ( ) { $ ( '#blurryTransition_canvas_c2' ) . unbind ( ) ; $list . find ( 'li:nth-child(' + ( destination_frame + 1 ) + ')' ) . css ( 'opacity' , 1 ) ; $ ( '#blurryTransition_canvas_c2' ) . addClass ( 'slow' ) . css ( 'opacity' , 0 ) ; cycle_index = destination_frame ; }
function ( ) { jQuery ( '<li class="ui-daterangepicker-' + this . text . replace ( / /g , '' ) + ' ui-corner-all"><a href="#">' + this . text + '</a></li>' ) . data ( 'dateStart' , this . dateStart ) . data ( 'dateEnd' , this . dateEnd ) . appendTo ( ul ) ; }
function ( red , green , blue , alpha ) { red = typeof red === 'undefined' ? 255.0 : red ; green = typeof green === 'undefined' ? 255.0 : green ; blue = typeof blue === 'undefined' ? 255.0 : blue ; alpha = typeof alpha === 'undefined' ? 255.0 : alpha ; return new Color ( red / 255.0 , green / 255.0 , blue / 255.0 , alpha / 255.0 ) ; }
function ( root , target , tag ) { root = root || '' ; target = target || document ; tag = tag || 'div' ; var node = document . getElementById ( root ) ; if ( node ) return node ; var nodesArray = util . getElementsByClassName ( root , target , tag ) ; if ( nodesArray . length === 1 ) return nodesArray [ 0 ] ; }
function ( ) { if ( ! this . isNew ) { this . warDelWin = this . getView ( 'warranty.Delete' ) . create ( ) ; this . warDelWin . getComponent ( 'nb-war-del-win-container' ) . getComponent ( 'nb-war-del-win-message' ) . update ( 'Удалить заказ №' + Ext . getCmp ( 'nb-war-id' ) . getValue ( ) + ' ?' ) ; this . warDelWin . show ( ) ; } else { Ext . Msg . alert ( 'Сообщение' , 'Удалить можно только сохраненній заказ' ) ; } }
function ( e ) { if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . prev ( ) break case 40 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . next ( ) break } e . stopPropagation ( ) }
function ( e ) { if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . prev ( ) break case 40 : if ( e . type != 'keydown' ) break e . preventDefault ( ) this . next ( ) break } e . stopPropagation ( ) }
function ( info ) { if ( info ) { redirectTo = info . returnTo ; email = info . email ; showRegistrationInfo ( info ) ; mustAuth = info . must_auth ; if ( mustAuth ) { dom . addClass ( "body" , "enter_password" ) ; complete ( oncomplete , true ) ; } else { submit ( oncomplete ) ; } } else { self . renderError ( "error" , errors . cannotConfirm ) ; complete ( oncomplete , false ) ; } }
function ( ev ) { var code , key ; if ( ev . wich ) { code = ev . which } else if ( ev . keyCode ) { code = ev . keyCode } else { return ; } switch ( code ) { case 16 : key = 'SHIFT' ; break ; case 17 : key = 'CTRL' ; break ; case 18 : key = 'ALT' ; break ; default : key = String . fromCharCode ( code ) ; } return key ; }
function ( err ) { if ( err ) { console . log ( "db error" ) ; return next ( 500 ) ; } else { var params = { title : "Success" , event_name : req . session . meetup . name , event_url : req . session . meetup . event_url , eventId : req . params . eid , restaurantName : req . session . restaurantName , header : true } ; Polling . start ( req . params . eid ) ; res . render ( "setupEvent/success.jade" , params ) ; } }
function ( value ) { if ( this . stringifyProperty != null ) { return value [ this . stringifyProperty ] ; } var name = null ; var lookup = this . getLookup ( ) ; lookup . some ( function ( item ) { if ( item . value === value ) { name = item . name ; return true ; } return false ; } , this ) ; return name ; }
function ( event ) { var index = $ ( this ) . data ( "index.ui-slider-handle" ) ; if ( self . _keySliding ) { self . _keySliding = false ; self . _stop ( event , index ) ; self . _change ( event , index ) ; $ ( this ) . removeClass ( "ui-state-active" ) ; } }
function ( ) { this . stage . removeAllChildren ( ) ; this . stage . clear ( ) ; this . stage . addChildAt ( sky , 0 ) ; this . addPlayer ( ) ; this . timerId = setInterval ( this . addIngredient , 2000 ) ; this . curControlIngredientIndex = 0 ; this . stageOffsetY = 0 ; stage . update ( ) ; }
function ( ) { return { name : "question" , defaultBranch : "confirm_correct" , submitButtonTitle : "Check My Answer" , beforeText : this . initialPrompt , substitutedExpressions : [ ] , submissibilityCriterion : [ "=" , [ "lineCount" ] , 1 ] , showCrossHairs : this . showCrossHairs , showToolTipCoords : this . showToolTipCoords , showGraphGrid : this . showGraphGrid , graphAnnotations : [ 'singleLineGraphing' ] , tableAnnotations : [ ] , tools : [ 'graphing' ] , responseBranches : this . check_correct_answer ( ) } ; }
function ( ) { return { name : "confirm_correct" , isFinalStep : true , hideSubmitButton : true , beforeText : "<b>" + this . confirmCorrect + "</b>" , showcrosshairs : false , showtooltipcoord : false , showgraphgrid : this . showGraphGrid } ; }
function ( ) { return { name : "question" , defaultBranch : "confirm_correct" , submitButtonTitle : "Check My Answer" , beforeText : this . initialPrompt , substitutedExpressions : [ ] , submissibilityCriterion : [ "=" , [ "lineCount" ] , 1 ] , showCrossHairs : this . showCrossHairs , showToolTipCoords : this . showToolTipCoords , showGraphGrid : this . showGraphGrid , graphAnnotations : [ 'singleLineGraphing' ] , tableAnnotations : [ ] , tools : [ 'graphing' ] , responseBranches : this . check_correct_answer ( ) } ; }
function ( ) { return { name : "confirm_correct" , isFinalStep : true , hideSubmitButton : true , beforeText : "<b>" + this . confirmCorrect + "</b>" , showcrosshairs : false , showtooltipcoord : false , showgraphgrid : this . showGraphGrid } ; }
function ( badgeId , callback ) { if ( ! flex . badges . init ) { return { error : { code : 401 , message : "First configure badges." } } } flex . socket . emit ( 'badges.badge.get' , { 'app_id' : flex . appData . app_id , 'badge_id' : badgeId } , function ( res ) { if ( typeof callback != 'undefined' ) { return callback ( res ) ; } } ) ; }
function ( userId , callback ) { if ( ! flex . badges . init ) { return { error : { code : 401 , message : "First configure badges." } } } flex . socket . emit ( 'badges.user.getAll' , { 'app_id' : flex . appData . app_id , 'user_id' : userId } , function ( res ) { if ( typeof callback != 'undefined' ) { callback ( res ) ; } } ) ; }
function ( userId , badgeId , callback ) { if ( ! flex . badges . init ) { return { error : { code : 401 , message : "First configure badges." } } } flex . socket . emit ( 'badges.user.has' , { 'app_id' : flex . appData . app_id , 'user_id' : userId , 'badge_id' : badgeId } , function ( res ) { if ( typeof callback != 'undefined' ) { callback ( res ) ; } } ) ; }
function ( userId , badgeId , callback ) { if ( ! flex . badges . init ) { return { error : { code : 401 , message : "First configure badges." } } } flex . socket . emit ( 'badges.user.set' , { 'app_id' : flex . appData . app_id , 'user_id' : userId , 'badge_id' : badgeId } , function ( res ) { if ( typeof callback != 'undefined' ) { callback ( res ) ; } } ) ; }
function ( ) { if ( typeof store != 'undefined' ) { store . remove ( 'transactions' ) ; store . remove ( 'cart' ) ; return true ; } else { return { error : { code : 401 , message : "First run 'flex.payment.init'." } } } }
function ( e ) { e . preventDefault ( ) ; var ngModel = $parse ( attrs . ngModel ) ; ngModel . assign ( scope , null ) ; scope . $apply ( ) ; }
function ( ) { this . setIsTouchEnabled ( true ) ; var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; this . addNewSpriteWithCoords ( cc . ccp ( s . width / 2 , s . height / 2 ) ) ; }
function ( template ) { PM . syncget ( template . url , function ( content ) { ich . addPartial ( template . name , content ) ; } ) ; }
function ( name ) { PM . syncget ( 'site/{0}.html' . format ( name ) , function ( content ) { console . log ( 'Loading template ' + name ) ; ich . addTemplate ( name , content ) ; } ) ; }
function ( ) { set ( this , 'location' , get ( this , 'location' ) || window . location ) ; set ( this , 'callbacks' , Ember . A ( ) ) ; }
function ( path ) { var state = window . history . state ; if ( path === "" ) { path = '/' ; } if ( ( ! state && path !== '/' ) || ( state && state . path !== path ) ) { window . history . pushState ( { path : path } , null , path ) ; } }
function ( key , value ) { var parentView , controller ; if ( arguments . length === 2 ) { return value ; } if ( VIEW_PRESERVES_CONTEXT ) { if ( controller = get ( this , 'controller' ) ) { return controller ; } parentView = get ( this , '_parentView' ) ; if ( parentView ) { return get ( parentView , '_context' ) ; } } return this ; }
function ( event , context ) { Ember . assert ( 'Cannot send event "' + event + '" while currentState is ' + get ( this , 'currentState' ) , get ( this , 'currentState' ) ) ; if ( arguments . length === 1 ) { context = { } ; } return this . sendRecursively ( event , get ( this , 'currentState' ) , context ) ; }
function ( ) { spyOnPromise ( Mongo , 'findTargetById' ) . andCallSuccess ( { name : "T-Talon ruokajono" , _id : "accab1234" , question : 'Kauanko jonotit?' } ) ; req . params . id = 'accab1234' ; API . deleteTarget ( req , res , next ) ; expectStatus ( res ) . toEqual ( 204 ) ; }
function ( ) { "use strict" ; var prev ; if ( ! this . cursor ) { prev = this . root ; } else if ( this . cursor === this . root ) { throw new Error ( "Root node has no previous node" ) ; } else { prev = this . cursor ; do { prev = prev . previousSibling ; if ( ! prev ) { prev = this . cursor . parentNode . lastChild ; } } while ( prev && prev . nodeType !== 1 ) ; } this . changeCursor ( prev ) ; }
function ( ) { "use strict" ; var up ; if ( ! this . cursor ) { up = this . root ; } else if ( this . cursor === this . root ) { throw new Error ( "Root node has no parent node" ) ; } else { up = this . cursor . parentNode ; } this . changeCursor ( up ) ; }
function ( ) { "use strict" ; var parent , node ; if ( ! this . cursor ) { throw new Error ( "No node selected" ) ; } else if ( this . cursor === this . root ) { throw new Error ( "Cannot create node before root node" ) ; } parent = this . cursor . parentNode ; node = this . generateNode ( null , true ) ; parent . insertBefore ( node , this . cursor ) ; }
function ( feature ) { var featureFound = accessObj . features . reduce ( function ( found , currElem ) { return found || currElem . id === feature . id ; } , false ) ; if ( ! featureFound ) { accessObj . features . push ( feature ) ; } }
function ( ) { var data = testUtilities . cloneObj ( testData . xml2jsConfig ) ; data . content [ "@" ] . src = "localFile.html" ; mockParsing ( data ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . content ) . toEqual ( "local:///localFile.html" ) ; } ) ; }
function buildCommentStructure ( comments_ob ) { var comments_list = comments_ob . comments ; for ( var index in comments_list ) { var comment = comments_list [ index ] ; var line_start = comment . line_start ; if ( comments [ line_start ] === undefined ) comments [ line_start ] = [ ] ; comments [ line_start ] . push ( comment ) ; } for ( var i in comments ) { buildCommentSet ( Number ( i ) - 1 , comments [ i ] ) ; } }
function ( e ) { if ( this . inMultiSelectMode ) return ; this . inMultiSelectMode = true ; this . setStyle ( "multiselect" ) ; this . keyBinding . addKeyboardHandler ( exports . commands . keyboardHandler ) ; this . commands . on ( "exec" , this . $onMultiSelectExec ) ; this . renderer . updateCursor ( ) ; this . renderer . updateBackMarkers ( ) ; }
function ( e ) { if ( this . session . multiSelect . inVirtualMode ) return ; this . inMultiSelectMode = false ; this . unsetStyle ( "multiselect" ) ; this . keyBinding . removeKeyboardHandler ( exports . commands . keyboardHandler ) ; this . commands . removeEventListener ( "exec" , this . $onMultiSelectExec ) ; this . renderer . updateCursor ( ) ; this . renderer . updateBackMarkers ( ) ; }
function ( shouldHighlight ) { if ( this . $highlightGutterLine == shouldHighlight ) return ; this . $highlightGutterLine = shouldHighlight ; if ( ! this . $gutterLineHighlight ) { this . $gutterLineHighlight = dom . createElement ( "div" ) ; this . $gutterLineHighlight . className = "ace_gutter_active_line" ; this . $gutter . appendChild ( this . $gutterLineHighlight ) ; return ; } this . $gutterLineHighlight . style . display = shouldHighlight ? "" : "none" ; this . $updateGutterLineHighlight ( ) ; }
function ( ) { if ( steps . length ) { _self . session . setScrollTop ( steps . shift ( ) ) ; _self . session . $scrollTop = toValue ; } else { _self . $inScrollAnimation = false ; clearInterval ( _self . $timer ) ; _self . session . $scrollTop = - 1 ; _self . session . setScrollTop ( toValue ) ; callback && callback ( ) ; } }
function ( command ) { if ( this . commands [ command . name ] ) this . removeCommand ( command ) ; this . commands [ command . name ] = command ; if ( command . bindKey ) { this . _buildKeyHash ( command ) ; } }
function ( ) { this . hide_mouse_indicator ( ) ; this . $s . $content_pane . unbind ( 'mouseleave.reader' ) . bind ( 'mouseleave.reader' , $ . rescope ( this . hide_mouse_indicator , this ) ) ; this . $s . $content_pane . unbind ( 'mouseenter.reader' ) . bind ( 'mouseenter.reader' , $ . rescope ( this . show_mouse_indicator , this ) ) ; }
function ( models ) { if ( ! models || ! models . length ) { models = NEWSBLUR . assets . stories ; } if ( ! models . length ) return ; this . flags [ 'iframe_fetching_story_locations' ] = false ; this . flags [ 'iframe_story_locations_fetched' ] = false ; if ( NEWSBLUR . reader . flags [ 'story_titles_loaded' ] ) { this . fetch_story_locations_in_story_frame ( { reset_timer : true } ) ; } else { this . prefetch_story_locations_in_story_frame ( ) ; } }
function ( name , listener , e ) { var id = listener . id , el = doc . getElementById ( id ) ; if ( el . tagName === 'HTML' || el . contains ( e . target ) ) { onTrigger ( name , listener , id , e , el ) ; } }
function ( element , index , array ) { if ( _fs . lstatSync ( _path . join ( path , element ) ) . isFile ( ) && element . substring ( 0 , 1 ) !== "." ) { trimmedName = _path . basename ( element , _path . extname ( element ) ) ; module = require ( _path . join ( relativePath , trimmedName ) ) ; moduleList . push ( module ) ; obj [ trimmedName ] = module ; } }
function ( data , textStatus , jqXHR ) { $ ( core . region ) . html ( data ) . hide ( ) . fadeIn ( ) ; core . adjustMagnifyingLensPosition ( ) ; core . attachEventHandlers ( ) ; if ( enterCallBack ) enterCallBack ( ) ; }
function ( Backbone ) { var LexiconNode = Backbone . Model . extend ( { initialize : function ( ) { } , defaults : { key : "" , value : "" , data : [ ] } , model : { } } ) ; return LexiconNode ; }
function ( require , exports , module ) { exports . isDark = true ; exports . cssClass = "ace-github" ; exports . cssText = require ( 'ace/requirejs/text!./github.css' ) ; var dom = require ( "../lib/dom" ) ; dom . importCssString ( exports . cssText , exports . cssClass ) ; }
function ( assert ) { var str = auth . stringToSign ( { verb : 'PUT' , md5 : '09c68b914d66457508f6ad727d860d5b' , contentType : 'text/plain' , resource : '/learnboost' , date : new Date ( 'Mon, May 25 1987 00:00:00 GMT' ) } ) ; var expected = [ 'PUT' , '09c68b914d66457508f6ad727d860d5b' , 'text/plain' , new Date ( 'Mon, May 25 1987 00:00:00 GMT' ) . toUTCString ( ) , '/learnboost' ] . join ( '\n' ) ; assert . equal ( expected , str ) ; }
function ( assert ) { var str = auth . sign ( { verb : 'PUT' , secret : 'test' , md5 : '09c68b914d66457508f6ad727d860d5b' , contentType : 'text/plain' , resource : '/learnboost' , date : new Date ( 'Mon, May 25 1987 00:00:00 GMT' ) } ) ; assert . equal ( '7xIdjyy+W17/k0le5kwBnfrZTiM=' , str ) ; }
function ( assert ) { var str = auth . canonicalizeHeaders ( { 'X-Amz-Date' : 'some date' , 'X-Amz-Acl' : 'private' , 'X-Foo' : 'bar' } ) ; var expected = [ 'x-amz-acl:private' , 'x-amz-date:some date' ] . join ( '\n' ) ; assert . equal ( expected , str ) ; assert . equal ( '' , auth . canonicalizeHeaders ( { } ) ) ; }
function ( assert ) { var client = knox . createClient ( { key : 'foobar' , secret : 'baz' , bucket : 'misc' } ) ; assert . equal ( 'foobar' , client . key ) ; assert . equal ( 'baz' , client . secret ) ; assert . equal ( 'misc' , client . bucket ) ; assert . equal ( 's3.amazonaws.com' , client . endpoint ) ; }
function ( assert , done ) { var n = 0 ; client . putFile ( jsonFixture , '/test/user2.json' , function ( err , res ) { assert . ok ( ! err , 'putFile() got an error!' ) ; assert . equal ( 200 , res . statusCode ) ; client . get ( '/test/user2.json' ) . on ( 'response' , function ( res ) { assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) ; done ( ) ; } ) . end ( ) ; } ) ; }
function ( res ) { assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'http://' + client . endpoint + '/' + client . bucket + '/test/user.json' , client . url ( '/test/user.json' ) ) ; assert . equal ( 'http://' + client . endpoint + '/' + client . bucket + '/test/user.json' , req . url ) ; done ( ) ; }
function ( assert , done ) { var stream = fs . createReadStream ( jsonFixture ) ; client . putStream ( stream , '/test/user.json' , function ( err , res ) { assert . ok ( ! err ) ; if ( 100 !== res . statusCode ) assert . equal ( 200 , res . statusCode ) ; done ( ) ; } ) ; }
function ( assert , done ) { client . getFile ( '/test/user.json' , function ( err , res ) { assert . ok ( ! err ) ; assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) assert . equal ( 13 , res . headers [ 'content-length' ] ) done ( ) ; } ) ; }
function ( assert , done ) { client . get ( '/test/user.json' ) . on ( 'response' , function ( res ) { assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) assert . equal ( 13 , res . headers [ 'content-length' ] ) done ( ) ; } ) . end ( ) ; }
function ( assert , done ) { client . head ( '/test/user.json' ) . on ( 'response' , function ( res ) { assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) assert . equal ( 13 , res . headers [ 'content-length' ] ) done ( ) ; } ) . end ( ) ; }
function ( assert , done ) { client . headFile ( '/test/user.json' , function ( err , res ) { assert . ok ( ! err ) ; assert . equal ( 200 , res . statusCode ) ; assert . equal ( 'application/json' , res . headers [ 'content-type' ] ) assert . equal ( 13 , res . headers [ 'content-length' ] ) done ( ) ; } ) ; }
function ( ) { $ ( '.oauth2state.unauthorized>.tryout' ) . append ( $ ( '.navheader,.calendar,.icebox,.dialogs' ) ) ; $ ( '.oauth2state:not(.unauthorized)' ) . remove ( ) ; $ ( '.oauth2state' ) . show ( ) ; $ ( '.login a' ) . attr ( 'href' , this . getAuthorizationURL ( ) ) ; ko . applyBindings ( taskwalls . pagevm = new TryOutPageViewModel ( ) ) ; }
function ( ) { $ ( '#sstatus' ) . slider ( 'value' , selectedFeature . attributes . description ) ; $ ( '#vcolor' ) . css ( { color : color [ $ ( '#sstatus' ) . slider ( 'value' ) ] } ) ; $ ( '#newstatus' ) . text ( $ ( '#sstatus' ) . slider ( 'value' ) ) ; $ ( '#dstatus' ) . dialog ( 'open' ) ; }
function ( l ) { var change = l . replace ( /^-\s?(.*)$/ig , '$1' ) . trim ( ) ; if ( change && change . length ) { html += '<li>' + change + '</li>' ; } }
function ( ) { if ( this . _cssPos === 'absolute' ) { return this . attributes . zIndex ; } var z = this . attributes . zIndex + 1 , scope = this ; _ . each ( scope . current , function ( view ) { z = view . zIndex > z ? view . zIndex : z ; } ) ; return ++ z ; }
function ( view ) { if ( view . settings [ keyFilter ] === valueFilter ) { view . destroy . call ( view ) ; i ++ ; } }
function ( arg ) { alert ( "Saved " + arg + " to pouch." ) ; window . app . savedcount ++ ; if ( window . app . savedcount . length == 3 ) { localStorage . setItem ( "userid" , window . app . get ( "authentication" ) . get ( "userPrivate" ) . get ( "id" ) ) ; if ( typeof thiscallback == "function" ) { thiscallback ( ) ; } window . hub . unsubscribe ( "savedToPouch" , null , window . app ) ; } }
function ( ) { this . store . suspendEvents ( ) ; Ext . each ( this . store . data . items , function ( studentRecord , index ) { studentRecord . updateScaledPoints ( ) ; } , this ) ; this . store . resumeEvents ( ) ; this . store . fireEvent ( 'datachanged' ) ; }
function ( ) { this . _mask ( 'Rendering table of all results. May take some time for many students.' , 'page-load-mask' ) ; this . _minimalDatasetLoaded = true ; this . _createStore ( ) ; this . store . suspendEvents ( ) ; this . _mergeMinimalDatasetIntoStore ( ) ; this . store . resumeEvents ( ) ; this . _unmask ( ) ; this . store . fireEvent ( 'datachanged' ) ; this . fireEvent ( 'minimalDatasetLoaded' , this ) ; }
function ( callback , scope , args ) { if ( this . _completeDatasetLoaded ) { Ext . bind ( callback , scope , args ) ( ) ; } else { this . addListener ( 'completeDatasetLoaded' , function ( ) { Ext . bind ( callback , scope , args ) ( ) ; } , this , { single : true } ) ; this . _mask ( 'Loading all results for all students' , 'page-load-mask' ) ; this . _loadAllGroupsInPeriod ( ) ; } }
function ( ) { if ( this . _completeDatasetLoaded ) { return ; } this . _completeDatasetLoaded = true ; this . _mask ( 'Calculating table of all results. May take some time for many students.' , 'page-load-mask' ) ; this . store . suspendEvents ( ) ; this . _addAssignmentsToStore ( ) ; this . _addGroupsToStore ( ) ; this . updateScaledPoints ( ) ; this . store . resumeEvents ( ) ; this . store . fireEvent ( 'datachanged' ) ; this . fireEvent ( 'completeDatasetLoaded' , this ) ; this . _unmask ( ) ; }
function ( ) { var amount , key , lines ; lines = [ ] ; amount = 0 ; for ( key in this . data ) { if ( key . length > amount ) amount = key . length ; } for ( key in this . data ) { lines . push ( "" + ( pad ( key , amount ) ) + key + ": " + ( this . get ( key ) ) ) ; } return lines . join ( "\n" ) ; }
function CLI ( args , mockBang ) { this . bang = mockBang || new Bang ; this . program = new Command ; this . program . version ( package . version , "-v, --version" ) . usage ( "[options] [key] [value]" ) . option ( "-d, --delete" , "delete the specified key" ) . option ( "-h, --help" , "get help" ) . parse ( args ) ; }
function ( ) { var panes ; this . wrap . find ( '.padding' ) . append ( this . content ) ; this . wrap . css ( { display : "block" , position : "absolute" , "min-height" : 118 } ) ; panes = this . getPanes ( ) ; panes . overlayImage . appendChild ( this . wrap [ 0 ] ) ; this . iWidth = this . wrap . outerWidth ( ) ; this . iHeight = this . wrap . outerHeight ( ) ; return this . bindButton ( ) ; }
function ( dir ) { this . removeSubClassMethods ( ) ; if ( envCheck ( ) ) { o . domains . npm = path . resolve ( dir ) ; if ( ! path . existsSync ( o . domains . npm ) ) { error ( 'could not resolve the npm path - ' + o . domains . npm + ' does not exist' ) ; } } return this ; }
function ( dir ) { if ( this . subclassMatches ( 'Libraries' , 'path' ) && envCheck ( ) ) { if ( type . isString ( dir ) ) { dir = path . resolve ( dir ) ; if ( ! path . existsSync ( dir ) ) { error ( 'could not resolve the libraries path - ' + dir + ' does not exist' ) ; } o . libDir = dir ; } } return this ; }
function ( req , res , next ) { var message = new db . models . Message ( ) ; message . message = req . params . message ; message . X = req . params . X ; message . Y = req . params . Y ; message . Z = req . params . Z ; message . save ( function ( ) { res . send ( req . body ) ; } ) ; }
function ( err ) { if ( err ) { grunt . log . error ( err ) ; return cb ( false ) ; } grunt . helper ( 'jpegtran' , jpgfiles , jpgConfig , dest , function ( err ) { if ( err ) { grunt . log . error ( err ) ; return cb ( false ) ; } cb ( ) ; } ) ; }
function ( ) { var resourceList = ResourceManager . getKeyList ( ) ; var resStore = new Memory ( { data : [ ] } ) ; for ( var index in resourceList ) { resStore . put ( { name : resourceList [ index ] , label : "<img class='comboBoxImage' src='' style='background:url(" + ResourceManager . getResourceUrl ( resourceList [ index ] ) + ");' /><span class='comboBoxText'>" + resourceList [ index ] + "</span>" } ) ; } this . comboBox . attr ( 'store' , resStore ) ; }
function Listener ( listenerType , actionOperator , actionMap , flagMap , assessmentStatements , presentation ) { this . listenerType = listenerType ; this . actionOperator = actionOperator ; this . actionMap = actionMap ; this . flagMap = flagMap ; this . assessmentStatements = assessmentStatements ; this . last = new Date ( ) ; this . triggerBuffer = undefined ; this . actionNamesArray = new Array ( ) ; for ( actionName in actionMap ) { this . actionNamesArray . push ( actionName ) } }
function ( followedNode , rect ) { var ret = new cc . Follow ( ) ; if ( rect != null && ret && ret . initWithTarget ( followedNode , rect ) ) { return ret ; } else if ( ret && ret . initWithTarget ( followedNode ) ) { return ret ; } return null ; }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = restartTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = nextTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( sender ) { var s = new TransitionsTestScene ( ) ; var layer = new TestLayer1 ( ) ; s . addChild ( layer ) ; var scene = backTransitionAction ( TRANSITION_DURATION , s ) if ( scene ) { cc . Director . sharedDirector ( ) . replaceScene ( scene ) ; } }
function ( ) { while ( this . _listening && this . _pending . length && this . _active_count < 100 ) { this . _dequeue ( ) ; } }
function ( ) { var self = this ; if ( this . _active_count <= 0 ) { if ( this . _socket . unref ) { this . _socket . unref ( ) ; } else if ( ! this . _timer ) { this . _timer = setTimeout ( function ( ) { self . close ( ) ; } , 300 ) ; } } }
function ( ) { if ( this . _socket . ref ) { this . _socket . ref ( ) ; } else if ( this . _timer ) { clearTimeout ( this . _timer ) ; this . _timer = null ; } }
function ( ) { return self . m_strObjId ; }
function set_sprint_points ( ) { "use strict" ; $ ( '#current-points' ) . html ( $ ( '.sprint li' ) . map ( function ( i , el ) { return $ ( el ) . data ( 'points' ) } ) . get ( ) . reduce ( function ( sum , points ) { return sum + points ; } , 0 ) ) ; }
function getUserImage ( ) { var image ; console . log ( 'get user image' ) ; FB . api ( { method : 'fql.query' , query : 'SELECT pic_square FROM user WHERE uid=me()' } , function ( response ) { image = response [ 0 ] . pic_square ; } ) ; console . log ( image ) ; return image ; }
function ( eventList ) { console . log ( 'eventList : ' , eventList ) ; if ( eventList . items ) { that . reset ( eventList . items . map ( function ( evt ) { return _convert_event ( evt ) ; } ) ) ; } deferred . resolve ( that ) ; }
function feed ( text ) { for ( var i = 1 ; i < arguments . length ; ++ i ) expected . push ( arguments [ i ] ) ; parser . execute ( text ) ; assert . equal ( 0 , expected . length ) ; }
function handleContent ( text , offset ) { var stashLen = this . stash . length ; var avail = Math . min ( this . needChars , text . length + stashLen - offset ) ; var message = this . stash + text . substring ( offset , offset + avail - stashLen ) ; if ( avail < this . needChars ) this . stash = message ; else { this . stash = "" ; this . handleData ( message ) ; } return message . length - stashLen ; }
function handleHeader ( str ) { var count = parseInt ( str , 16 ) || 0 ; if ( count > 0 && count < MAX_MESSAGE_SIZE ) { this . needChars = count ; this . handleData = this . handleMessage ; } else this . needChars = HEADER_LEN ; }
function buildMessage ( obj ) { var str = obj . toString ( ) ; var lenStr = "" + str . length . toString ( 16 ) ; while ( lenStr . length < HEADER_LEN ) lenStr = "0" + lenStr ; return lenStr + str ; }
function ( key , val ) { var name = key . toUpperCase ( ) . split ( ' ' ) . join ( '_' ) ; return process . env [ name ] || val ; }
function ( ) { env ( 'foo' , 'bar' ) . should . equal ( 'bar' ) ; process . env . FOO = 'baz' ; env ( 'foo' , 'bar' ) . should . equal ( 'baz' ) ; process . env . DEV_UI = 'yes' ; env ( 'dev ui' , 'no' ) . should . equal ( 'yes' ) ; }
function ( def ) { var resource , moduleThis ; moduleThis = def . cjs ? def [ 'exports' ] : undef ; resource = def . res . apply ( moduleThis , def . deps ) ; if ( resource === undef && ( def . cjs || def . useExports || def . useModule ) ) { resource = def [ 'module' ] [ 'exports' ] ; } return resource ; }
function ( layers ) { layers = layers instanceof Array ? layers : [ layers ] ; this . _layers = { } ; this . _tileLayersNum = 0 ; var i , len ; for ( i = 0 , len = layers . length ; i < len ; i ++ ) { this . addLayer ( layers [ i ] ) ; } }
function ( ) { if ( this . options . zoomControl ) { this . zoomControl = new L . Control . Zoom ( ) ; this . addControl ( this . zoomControl ) ; } if ( this . options . attributionControl ) { this . attributionControl = new L . Control . Attribution ( ) ; this . addControl ( this . attributionControl ) ; } }
function ( ) { this . addHandler ( 'dragging' , L . Map . Drag ) . addHandler ( 'touchZoom' , L . Map . TouchZoom ) . addHandler ( 'doubleClickZoom' , L . Map . DoubleClickZoom ) . addHandler ( 'scrollWheelZoom' , L . Map . ScrollWheelZoom ) . addHandler ( 'boxZoom' , L . Map . BoxZoom ) ; }
function ( ) { if ( ! this . _content ) { return ; } if ( typeof this . _content === 'string' ) { this . _contentNode . innerHTML = this . _content ; } else { this . _contentNode . innerHTML = '' ; this . _contentNode . appendChild ( this . _content ) ; } }
function ( layer ) { var events = [ 'click' , 'dblclick' , 'mouseover' , 'mouseout' ] , i , len ; for ( i = 0 , len = events . length ; i < len ; i ++ ) { layer . on ( events [ i ] , this . _propagateEvent , this ) ; } }
function ( map ) { this . _map = map ; this . _container = L . DomUtil . create ( 'div' , 'leaflet-control-attribution' ) ; L . DomEvent . disableClickPropagation ( this . _container ) ; this . _update ( ) ; return this . _container ; }
function getVendorPrefix ( ) { var property = { transformProperty : '' , MozTransform : '-moz-' , WebkitTransform : '-webkit-' , OTransform : '-o-' , msTransform : '-ms-' } ; for ( var p in property ) { if ( typeof m_style [ p ] != 'undefined' ) { return property [ p ] ; } } return null ; }
function ( private_gameid ) { this . id = Game . new_id ( ) ; this . private_gameid = private_gameid ; this . player_limit = 8 ; this . time_limit = 60 ; this . tile_recharge = 2.0 ; this . readyTimeout = null ; this . round_timeout = null ; this . round_started = false ; this . board = new board . Board ( ) ; this . players = [ ] ; this . trails = [ ] ; }
function vendor ( el , prop ) { var s = el [ style ] , pp , i ; if ( s [ prop ] !== undefined ) return prop ; prop = prop . charAt ( 0 ) . toUpperCase ( ) + prop . slice ( 1 ) ; for ( i = 0 ; i < prefixes [ length ] ; i ++ ) { pp = prefixes [ i ] + prop ; if ( s [ pp ] !== undefined ) return pp ; } }
function anim ( ) { i ++ ; for ( var s = o [ lines ] ; s ; s -- ) { var alpha = Math . max ( 1 - ( i + s * astep ) % f * ostep , o [ opacity ] ) ; self [ opacity ] ( el , o [ lines ] - s , alpha , o ) ; } if ( self . on ) setTimeout ( anim , 50 ) ; }
function toggleShowContentFct ( e ) { e . toggleClass ( "open" ) ; var content = $ ( ".hiddenContent" , e . parent ( ) . get ( 0 ) ) ; if ( content . is ( ':visible' ) ) { content . slideUp ( 100 ) ; } else { content . slideDown ( 100 ) ; } }
function ( e ) { var cdata = { author : $this . options . me , body : newComment } jQuery ( "li.comment" , jQuery ( context ) ) . after ( ich . chatterComment ( cdata ) ) ; jQuery ( ".noposts" , jQuery ( context ) ) . hide ( ) ; jQuery ( "box" ) . val ( "" ) ; $this . setupBlocks ( $this ) }
function chromeNotifyTumblr ( tabs ) { for ( tab in tabs ) { if ( checkurl ( tabs [ tab ] . url , [ "http://*.tumblr.com/*" ] ) ) { if ( typeof chrome . tabs . sendMessage != "undefined" ) { chrome . tabs . sendMessage ( tabs [ tab ] . id , "refreshSettings" ) ; } else if ( typeof chrome . tabs . sendRequest != "undefined" ) { chrome . tabs . sendRequest ( tabs [ tab ] . id , "refreshSettings" ) ; } } } }
function ( webProgress , request , stateFlags , status ) { if ( webProgress != docShell ) { return ; } if ( stateFlags & Ci . nsIWebProgressListener . STATE_START ) { this . _seenLoadStart = true ; sendAsyncMsg ( 'loadstart' ) ; } if ( stateFlags & Ci . nsIWebProgressListener . STATE_STOP ) { sendAsyncMsg ( 'loadend' ) ; } }
function caption_menu ( ) { var selection ; return Object . create ( Object , { element : { value : document . createElement ( 'span' ) } , selection : { set : function ( s ) { selection = s ; this . element . innerText = s . toString ( ) ; } , get : function ( ) { return selection ; } } } ) ; }
function ( p ) { var dp = ( p || parent ) ; if ( dp != d_el . parentNode ) { this . hide ( ) ; dp . appendChild ( d_el ) ; } displayed = true ; }
function ( x , y ) { this . points . push ( { x : x , y : y , t : new Date ( ) . getTime ( ) , isPoint : true , color : this . color , size : this . size } ) }
function nativeRequire ( request ) { var code , module , filename = 'phantomjs://modules/' + request + '.js' ; if ( cache . hasOwnProperty ( filename ) ) { return cache [ filename ] . exports ; } code = phantom . readNativeModule ( request ) ; module = new Module ( filename ) ; cache [ filename ] = module ; module . exports = nativeExports [ request ] || { } ; module . _compile ( code ) ; return module . exports ; }
function ( ) { var cwd , mainFilename , mainModule = new Module ( ) ; window . require = mainModule . _getRequire ( ) ; fs = nativeRequire ( 'fs' ) ; cwd = fs . absolute ( phantom . libraryPath ) ; mainFilename = joinPath ( cwd , basename ( nativeRequire ( 'system' ) . args [ 0 ] ) || 'repl' ) ; mainModule . _setFilename ( mainFilename ) ; }
function ( obj , index , colwidth ) { var style = getStyle ( index ) ; obj . css ( { 'width' : colwidth , 'left' : style . x * colwidth , 'top' : style . y * ( settings . rowGap + settings . itemHeight ) , 'height' : settings . itemHeight } ) ; obj . addClass ( 'snaky-item ' + style . name ) ; }
function ( ) { $ ( drug . available ) . removeAttr ( 'disabled' ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { requiredEmail : "bademail" } ) ; equal ( retval , "invalid requiredEmail: (bademail)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( path ) { this . response . statusCode = 303 ; this . response . setHeader ( 'Location' , path ) ; this . cookies . setHeaders ( ) ; this . response . end ( ) ; return false ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ; child . __super__ = parent . prototype ; return child ; }
function ( ) { var arrayToFilter = [ { key : 'value' } , { key : 'value2' } , { key : 'value' } ] ; expect ( uniqueFilter ( arrayToFilter , '' ) ) . toEqual ( [ { key : 'value' } , { key : 'value2' } ] ) ; }
function ( ) { var arrayToFilter = [ { key : 'value' , other : 'other1' } , { key : 'value2' , other : 'other2' } , { key : 'value' , other : 'other3' } ] ; expect ( uniqueFilter ( arrayToFilter , 'key' ) ) . toEqual ( [ { key : 'value' } , { key : 'value2' } ] ) ; }
function ( ) { expect ( uniqueFilter ( 'string' , 'someKey' ) ) . toEqual ( 'string' ) ; }
function ( list , category , type ) { var markup = "<li><a href='http://s3.amazonaws.com/ShannonRoman/" + category + "/full/" + type + "/${$item.getAlbum()}${Full}'><img src='http://s3.amazonaws.com/ShannonRoman/" + category + "/thumb/" + type + "/${$item.getAlbum()}${Thumb}' class='image0' /></a></li>" ; $ . template ( "imageTemplate" , markup ) ; $ . tmpl ( "imageTemplate" , list , { getAlbum : function ( ) { if ( this . data . Album == "" ) return "" ; return this . data . Album + "/" ; } } ) . appendTo ( ".ad-thumb-list" ) ; }
function set ( value ) { if ( value === this . value ) return ; ASSERT ( ! this . isChanged ( ) , "overlapping writes" ) ; this . changeEvent = { set : true , log : "set " + this + " : " + ( ( typeof this . value === "function" ) ? "<function>" : JSON . stringify ( this . value ) ) + " ==> " + ( ( typeof value === "function" ) ? "<function>" : JSON . stringify ( value ) ) } ; this . value = value ; }
function push ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; vv . changeEvent = { adds : [ { index : vv . value . length , howMany : arguments . length } ] } ; Array . prototype . push . apply ( vv . value , arguments ) ; runtime . touch ( vv ) ; }
function remove ( item ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; var index = vv . value . indexOf ( item ) ; if ( index < 0 ) return ; vv . changeEvent = { removes : [ { index : index , howMany : 1 } ] } ; vv . value . splice ( index , 1 ) ; runtime . touch ( vv ) ; }
function pop ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; if ( vv . value . length === 0 ) return ; vv . changeEvent = { removes : [ { index : vv . value . length - 1 , howMany : 1 } ] } ; vv . value . pop ( ) ; runtime . touch ( vv ) ; }
function hdVariableProxy ( value ) { if ( arguments . length > 0 ) { ASSERT ( ! evaluator . isUpdating ( ) , "do not set variables from within methods" ) ; LOG ( "edited " + vv + ": " + JSON . stringify ( value ) ) ; vv . set ( value ) ; runtime . touch ( vv ) ; } else { return evaluator . get ( vv ) ; } }
function adapt ( o ) { [ "subscribers" , "subscribe" , "publish" ] . forEach ( function ( f ) { if ( o [ f ] !== undefined ) { ERROR ( "new publisher already has property: " + f ) ; } } ) ; o . subscribers = { } ; o . subscribe = subscribe ; o . publish = publish ; }
function start ( points ) { var app = require ( 'express' ) . createServer ( ) ; app . set ( 'views' , __dirname + '/views' ) ; app . get ( '/' , function ( req , res ) { res . render ( 'index.jade' , { title : 'maps' , points : points } ) ; } ) ; app . listen ( 3000 ) ; console . log ( 'server is running' ) ; }
function ( e ) { var that = e . data . fileupload , dataTransfer = e . dataTransfer = e . originalEvent . dataTransfer ; if ( that . _trigger ( 'dragover' , e ) === false ) { return false ; } if ( dataTransfer ) { dataTransfer . dropEffect = dataTransfer . effectAllowed = 'copy' ; } e . preventDefault ( ) ; }
function ( data ) { if ( ! data || this . options . disabled ) { return ; } data . files = $ . each ( $ . makeArray ( data . files ) , this . _normalizeFile ) ; this . _onAdd ( null , data ) ; }
function ( events ) { allEvents = allEvents . concat ( events ) ; if ( -- pendingRequests === 0 ) { allEvents . sort ( function ( first , second ) { return first . startTime . getTime ( ) - second . startTime . getTime ( ) ; } ) ; feeds . events = allEvents ; callback && callback ( ) ; } }
function ( ) { var latest_circles = Circles . find ( { graph_id : Session . get ( 'selected_graph' ) } , { } ) ; for ( var circle in latest_circles ) { draw_circle ( circle . cx , circle . cy ) ; } }
function ( ) { if ( this . isRoot ( ) ) { throw "Root paths do not have a parent" ; } var data = _ . extend ( { } , this , { descriptors : _ ( this . descriptors ) . initial ( ) } ) ; return new PathInfo ( data ) ; }
function ( ) { data = data . join ( "" ) ; if ( response . statusCode != 200 ) { callback ( { statusCode : response . statusCode , data : data , oauth : oauthDetails } ) ; } else { callback ( null , data , response ) ; } }
function ( checked , conditions ) { if ( checked . length > conditions . length ) return false ; var len = checked . length ; var count = 0 ; _ . each ( checked , function ( value ) { if ( conditions . indexOf ( value ) > - 1 ) { count += 1 ; } } ) ; return ( count == len ) ; }
function ( results ) { for ( var metricName in results ) { var resultMetricData = results [ metricName ] ; var graphMetricData = graph . data [ metricName ] ; for ( var j = 0 ; j < resultMetricData . length ; j ++ ) { graphMetricData [ j ] = resultMetricData [ j ] ; } } graph . object . update ( ) ; }
function extract ( bag , key , def ) { if ( ! key ) { return bag || { } ; } var keys = key . split ( '.' ) , cur = bag , i ; for ( i = 0 ; i < keys . length ; i += 1 ) { if ( cur [ keys [ i ] ] ) { cur = cur [ keys [ i ] ] ; } else { return def ; } } return cur ; }
function compound ( t , r , s , result ) { if ( result ) { matrix4 . set ( result , matrix4 . identity ) ; } result = result || new M4 ( matrix4 . identity ) ; if ( t ) { translate ( t , result ) ; } if ( r ) { rotate ( r , result ) ; } if ( s ) { scale ( s , result ) ; } return result ; }
function ( ) { writeMessage ( SHAPE . name + ( ( Type . Kind == TankKindEnum . TURRET ) ? " TurretA=" + TurretAngle : " BaseA=" + BaseAngle ) + " State#=" + State + " TurretBaseA=" + TargetBaseAngle + ( ( Target != null ) ? " Trgt=" + Target . getShape ( ) . name : "" ) ) }
function ( ) { if ( bShape == null || bShape == undefined ) { bShape = KBullet ( ) ; bShape . setPosition ( X , Y ) ; LAYER . add ( bShape ) ; } else if ( bShape != null || bShape != undefined ) bShape . setPosition ( X , Y ) ; }
function explode ( ) { if ( Type === ShotType . SHELL ) { } else if ( Type === ShotType . BOMB ) { } else { } if ( bShape != null || bShape != undefined ) LAYER . remove ( bShape ) ; Bullets . remove ( This ) ; }
function ( ) { if ( gamedata . gamephase == 1 ) return "INITIAL ORDERS" ; if ( gamedata . gamephase == 2 ) return "MOVEMENT ORDERS:" ; if ( gamedata . gamephase == 3 ) return "FIRE ORDERS" ; if ( gamedata . gamephase == 4 ) return "FINAL ORDERS" ; return "ERROR" }
function ( ) { var b = $ ( "body" ) ; b . removeClass ( "phase1" ) ; b . removeClass ( "phase2" ) ; b . removeClass ( "phase3" ) ; b . removeClass ( "phase4" ) ; b . addClass ( "phase" + gamedata . gamephase ) ; }
function ( e ) { e . stopPropagation ( ) ; var id = $ ( this ) . data ( "id" ) ; var ship = gamedata . getShip ( id ) ; if ( shipSelectList . haveToShowList ( ship , e ) ) { shipSelectList . showList ( ship ) ; } else { shipManager . doShipClick ( ship ) ; } }
function ( x ) { if ( /[\/\\]_/ . test ( x . name ) || ! /\.js$/ . test ( x . name ) ) { print ( " >>>>>>>>>>>>>>> skipping " + x . name ) ; return ; } load ( 'jstests/aggregation/data/articles.js' ) ; print ( " *******************************************" ) ; print ( "         Test : " + x . name + " ..." ) ; print ( "                " + Date . timeFunc ( function ( ) { load ( x . name ) ; } , 1 ) + "ms" ) ; }
function ( cssSelector , callback ) { var self = this ; self . element ( "css selector" , cssSelector , function ( result ) { if ( result . status == 0 ) { self . elementIdClear ( result . value . ELEMENT , function ( result ) { if ( typeof callback === "function" ) { callback ( result ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result ) ; } } } ) ; }
function ( movie ) { var view = new AnyGood . MovieView ( { model : movie } ) ; this . $ ( "#result" ) . html ( view . render ( ) . el ) ; }
function ( e , token ) { req . cookies . _tracker = token res . cookie ( '_tracker' , req . cookies . _tracker , { expires : new Date ( Date . now ( ) + 900000 ) , httpOnly : true } ) res . end ( pixel , 'binary' ) }
function ( e , href ) { response . domain = url . parse ( href ) . hostname _flush ( extend ( response , req . query ) ) }
function ( e , remoteAddress ) { response . geo = { ip : remoteAddress } _fixHref ( req . headers . host , function ( e , href ) { response . domain = url . parse ( href ) . hostname _flush ( extend ( response , req . query ) ) } ) }
function ( e , language ) { response . language = language _getRemoteAddress ( function ( e , remoteAddress ) { response . geo = { ip : remoteAddress } _fixHref ( req . headers . host , function ( e , href ) { response . domain = url . parse ( href ) . hostname _flush ( extend ( response , req . query ) ) } ) } ) }
function ( removals ) { for ( var i = 0 ; i < removals . length ; i ++ ) { var store = Ext . getStore ( 'ComputesStore' ) ; store . remove ( store . findRecord ( 'id' , removals [ i ] ) ) ; } }
function ( callback ) { var self = this ; this . bufferedRequest ( { path : '/store' } , function ( result ) { if ( result . buffer . length === 0 ) { self . emit ( 'error' , new Error ( 'Empty response from server - are you registered?' ) ) ; } else { callback ( JSON . parse ( result . buffer ) ) ; } } ) . end ( ) ; }
function ( callback ) { var self = this ; this . bufferedRequest ( { path : '/newtoken' , method : 'POST' } , function ( result ) { if ( result . buffer . length === 0 ) { self . emit ( 'error' , new Error ( 'Empty response from server - are you registered?' ) ) ; } else { callback ( JSON . parse ( result . buffer ) ) ; } } ) . end ( ) ; }
function ( name , callback ) { var self = this ; this . bufferedRequest ( { path : '/users/' + name , method : 'POST' } , function ( result ) { if ( result . buffer . length === 0 ) { self . emit ( 'error' , new Error ( 'Empty response from server - are you a registered admin?' ) ) ; } else { callback ( JSON . parse ( result . buffer ) ) ; } } ) . end ( ) ; }
function ( ) { $ . ajax ( { url : 'products' , dataType : 'json' , success : function ( data ) { $ ( '.main' ) . thiralLazyLoad ( { 'nav' : $ ( '.nav' ) , 'data' : data } ) ; } } ) ; }
function ( err ) { debug ( 'HTTP SOCKET ERROR: ' + err . message + '\n' + err . stack ) ; req . emit ( 'error' , err ) ; req . _hadError = true ; if ( parser ) { parser . finish ( ) ; freeParser ( parser , req ) ; } socket . destroy ( ) ; }
function ( choice , value ) { var existing_choice = this . deck . find ( '[data-value=' + value + ']' ) ; if ( ! existing_choice . length ) { var choice = choice . clone ( ) ; if ( ! choice . attr ( 'data-value' ) ) { choice . attr ( 'data-value' , value ) ; } this . deck . append ( choice ) ; choice . append ( this . widget . find ( '.remove' ) . clone ( ) . show ( ) ) ; } }
function ( event ) { that . parent . innerHide ( event ) ; that . $content . attr ( "aria-hidden" , "true" ) ; ch . utils . document . unbind ( ch . events . KEY . ESC + " " + ch . events . KEY . UP_ARROW + " " + ch . events . KEY . DOWN_ARROW ) ; return that ; }
function ( ) { var method = this [ "_" + this . config . get ( "endpoint" ) ] ; method && method . apply ( this , arguments ) ; }
function ( args ) { args = args || { } ; if ( this . config . get ( "recurring" ) ) { if ( ! this . liveUpdates ) { this . _initLiveUpdates ( ) ; } this . _startLiveUpdates ( args . force ) ; return ; } this . request ( args . data ) ; }
function ( config ) { var self = this ; var _config = $ . extend ( { } , config ) ; return $ . extend ( config , { "onData" : function ( response , requestParams ) { self . _onData ( response , { "requestType" : self . requestType } , _config ) ; } , "onError" : function ( responseError , requestParams ) { self . _onError ( responseError , requestParams , _config ) ; } } ) ; }
function ( ) { Templates = { torrent_row : Handlebars . compile ( $ ( '#tmpl_torrent' ) . html ( ) ) } btapp . connect ( { } , { poll_frequency : 1000 , queries : Helpers . poll_queries , pairing_type : 'native' , plugin : false } ) this . torrents = new Torrents ( ) this . torrents_contents = new TorrentsList ( { model : torrents } ) $ ( '#torrents .content' ) . replaceWith ( this . torrents_contents . render ( ) . el ) }
function ( ) { var opf_file = that . bookhandle . parser . getContainerFile ( that . filefacilitator . getDataFromEpub ( 'META-INF/container.xml' ) ) , ncx_file = that . bookhandle . parser . opf ( that . filefacilitator . getDataFromEpub ( opf_file ) ) ; that . bookhandle . navigator . setTOCModel ( that . bookhandle . parser . getTOC ( that . filefacilitator . getDataFromEpub ( ncx_file ) ) ) ; }
function ( that ) { fluid . tabs ( that . container . selector + ' ' + that . options . selectors . slidingTabsSelector , { tabOptions : { fx : { height : 'toggle' } } } ) ; }
function SocialUI_init ( ) { Services . obs . addObserver ( this , "social:pref-changed" , false ) ; Services . obs . addObserver ( this , "social:ambient-notification-changed" , false ) ; Services . obs . addObserver ( this , "social:profile-changed" , false ) ; Social . init ( this . _providerReady . bind ( this ) ) ; }
function SocialUI_observe ( subject , topic , data ) { switch ( topic ) { case "social:pref-changed" : SocialShareButton . updateButtonHiddenState ( ) ; SocialToolbar . updateButtonHiddenState ( ) ; break ; case "social:ambient-notification-changed" : SocialToolbar . updateButton ( ) ; break ; case "social:profile-changed" : SocialToolbar . updateProfile ( ) ; break ; } }
function ( ) { var clone = this . data ( 'hjq-spinner' ) ; var that = this ; if ( ! clone ) { $ ( ".ajax-progress" ) . each ( function ( ) { if ( $ ( this ) . data ( 'source' ) [ 0 ] == that [ 0 ] ) { clone = $ ( this ) ; return false ; } } ) ; } if ( ! clone ) return this ; clone . hide ( 'fast' ) ; return this ; }
function ( method ) { if ( methods [ method ] ) { return methods [ method ] . apply ( this , Array . prototype . slice . call ( arguments , 1 ) ) ; } else if ( typeof method === 'object' || ! method ) { return methods . init . apply ( this , arguments ) ; } else { $ . error ( 'Method ' + method + ' does not exist on hjq' ) ; } }
function setCurrentDocument ( document ) { if ( _currentDocument === document ) { return ; } var perfTimerName = PerfUtils . markStart ( "setCurrentDocument:\t" + ( ! document || document . file . fullPath ) ) ; if ( ! ProjectManager . isWithinProject ( document . file . fullPath ) ) { addToWorkingSet ( document . file ) ; } if ( ! _documentNavPending ) { _markMostRecent ( document ) ; } _currentDocument = document ; $ ( exports ) . triggerHandler ( "currentDocumentChange" ) ; PerfUtils . addMeasurement ( perfTimerName ) ; }
function findMatchingRules ( selector , htmlDocument ) { var result = new $ . Deferred ( ) , cssFilesResult = FileIndexManager . getFileInfoList ( "css" ) , resultSelectors = [ ] ; if ( htmlDocument ) { _findMatchingRulesInStyleBlocks ( htmlDocument , selector , resultSelectors ) ; } _findMatchingRulesInCSSFiles ( selector , resultSelectors ) . done ( function ( ) { result . resolve ( resultSelectors ) ; } ) . fail ( function ( error ) { result . reject ( error ) ; } ) ; return result . promise ( ) ; }
function addToWorkingSetAndSelect ( fullPath ) { CommandManager . execute ( Commands . FILE_ADD_TO_WORKING_SET , { fullPath : fullPath } ) ; return openAndSelectDocument ( fullPath , WORKING_SET_VIEW ) ; }
function ( expected ) { var i ; for ( i = 0 ; i < this . actual . length ; ++ i ) { if ( this . actual [ i ] . isDirectory && this . actual [ i ] . name === expected ) { return true ; } } return false ; }
function ( expected ) { var i ; for ( i = 0 ; i < this . actual . length ; ++ i ) { if ( this . actual [ i ] . isFile && this . actual [ i ] . name === expected ) { return true ; } } return false ; }
function requestNativeFileSystemSuccessCB ( nfs ) { var reader = nfs . createReader ( ) ; var successCallback = function ( e ) { entries = e ; readComplete = true ; } ; var errorCallback = function ( ) { readComplete = true ; gotError = true ; } ; reader . readEntries ( successCallback , errorCallback ) ; }
function ( err ) { errorCalled = true ; error = err ; }
function ( programHTML ) { $ ( "#List" ) . html ( programHTML ) ; addDroppableFeature ( $ ( "#List .droppable" ) ) ; $ ( "#List table" ) . children ( ) . each ( function ( ) { addDraggingFeature ( $ ( this ) . find ( "table" ) ) ; } ) ; }
function ( event , ui ) { if ( ui . item === null ) { throw new Error ( "sortable receive" ) ; } else { if ( ! ui . item . is ( 'span.draggable' ) ) { eliminateBorder ( ui . sender . parent ( ) . parent ( ) ) ; } } }
function ( event , ui ) { dropped = true ; if ( draggedClone != undefined ) { eliminateBorder ( draggedClone . closest ( $ ( "th" ) ) ) ; draggedClone = undefined ; } $ ( ui . draggable ) . remove ( ) ; addToHistory ( tempProgram ) ; }
function ( hold ) { if ( hold ) { return ; } if ( globals . jQuery . readyWait === 1 && globals . jQuery . isReady || globals . jQuery . readyWait === 2 && ! globals . jQuery . isReady ) { callback ( ) ; } return _holdReady . apply ( this , arguments ) ; }
function ( origin , args , cb ) { if ( window . location . hash === '#complete' ) cb ( ) ; else { wc . detach ( ) ; window . location = args ; } }
function ( err , data ) { if ( err ) { if ( ! writeStreamingHeader ) { self . httpResponse . end ( ) ; console . error ( "jsDAV GET error" , err ) ; } else { self . handleError ( err ) ; } return ; } if ( ! data ) return self . httpResponse . end ( ) ; self . httpResponse . write ( data ) ; }
function ( ) { $ ( '#tab' ) . jqGrid ( 'setGridHeight' , $ ( window ) . height ( ) / 2 - 30 ) ; $ ( '#map' ) . height ( $ ( window ) . height ( ) - $ ( '#table' ) . height ( ) - 3 ) ; map . invalidateSize ( ) ; $ ( '#tab' ) . jqGrid ( 'setGridWidth' , $ ( window ) . width ( ) ) ; }
function ( callback , node ) { callback = callback . result ? callback . success : callback . error ; if ( ! _ . isFunction ( callback ) ) callback = this [ callback ] ; return callback . apply ( this , [ node ] ) ; }
function ( cb ) { if ( cb ) { if ( this . __fired && this . __results ) { cb . apply ( this , this . __results ) ; } else { this . __cbs . push ( cb ) ; } } return this ; }
function ( cb ) { if ( cb ) { if ( this . __fired && this . __error ) { cb . apply ( this , this . __error ) ; } else { this . __errorCbs . push ( cb ) ; } } }
function ( ) { var args = base . argsToArray ( arguments ) ; if ( this . __fired ) { throw new Error ( "Already fired!" ) ; } this . __results = Array . prototype . slice . call ( arguments ) ; this . __resolve ( ) ; return this ; }
function ( callback , errback ) { this . addCallback ( callback ) ; this . addErrback ( errback ) ; return this ; }
function ( callback , errback ) { var promise = new Promise ( ) ; this . addCallback ( function ( results ) { callback . call ( this , results ) . then ( hitch ( promise , "callback" ) , hitch ( promise , "errback" ) ) ; } ) ; this . addErrback ( errback ) ; return promise ; }
function ( cb ) { if ( cb ) { if ( this . __fired && ! this . __errors . length ) { cb . call ( this , this . __results ) ; } else { this . __cbs . push ( cb ) ; } } return this ; }
function ( cb ) { if ( cb ) { if ( this . __fired && this . __errors . length ) { cb . call ( this , this . __errors ) ; } else { this . __errorCbs . push ( cb ) ; } } return this ; }
function ( active , id ) { $districts = $ ( '.districts' ) ; $districts . css ( { opacity : 1 } ) ; this . districtList = new L . Views . Districts ( { collection : this . collection [ id ] . districts } ) ; $ ( '#districts' ) . html ( this . districtList . render ( ) . el ) ; REIN . events . trigger ( 'filter:area' , id ) ; window . scrollTo ( 0 , $districts . offset ( ) . top ) ; }
function ( owner ) { var markItem = new L . Views . Mark ( { model : owner , template : self . template } ) ; self . $el . append ( markItem . render ( ) . el ) ; self . _markViews . push ( markItem ) ; }
function browser_setUrlButtonMode ( mode ) { this . urlButtonMode = mode ; switch ( mode ) { case this . GO : this . urlButton . style . backgroundImage = 'url(style/images/go.png)' ; break ; case this . REFRESH : this . urlButton . style . backgroundImage = 'url(style/images/refresh.png)' ; break ; case this . STOP : this . urlButton . style . backgroundImage = 'url(style/images/stop.png)' ; break ; } }
function ( ) { $ ( "form" ) . live ( "change" , "#id_source_group" , function ( evt ) { var $sourceGroup = $ ( this ) . find ( '#id_source_group' ) ; var $cidrContainer = $ ( this ) . find ( '#id_cidr' ) . parent ( ) . parent ( ) ; if ( $sourceGroup . val ( ) === "" ) { $cidrContainer . removeClass ( "hide" ) ; } else { $cidrContainer . addClass ( "hide" ) ; } } ) ; }
function getTwipsyTitle ( ) { return $ ( this ) . closest ( 'div.form-field' ) . children ( '.help-block' ) . text ( ) ; }
function ( ) { if ( this . value != base_type ) { $ ( "#id_" + this . value ) . closest ( ".control-group" ) . hide ( ) ; } else { $ ( "#id_" + this . value ) . closest ( ".control-group" ) . show ( ) ; } }
function ( data , textStatus , jqXHR ) { $ ( 'div.modal_wrapper' ) . append ( data ) ; $ ( '.modal span.help-block' ) . hide ( ) ; $ ( '.modal:last' ) . modal ( ) ; horizon . datatables . validate_button ( ) ; }
function ( evt ) { $ ( this ) . closest ( '.modal' ) . modal ( 'hide' ) ; evt . preventDefault ( ) ; }
function ( ) { var template = horizon . templates . compiled_templates [ "#spinner-modal" ] ; horizon . modals . spinner = $ ( template . render ( ) ) ; horizon . modals . spinner . appendTo ( "div.modal_wrapper" ) ; horizon . modals . spinner . modal ( { backdrop : 'static' } ) ; horizon . modals . spinner . spin ( horizon . conf . spinner_options . modal ) ; }
function ( evt ) { form = $action . closest ( 'form' ) ; form . append ( "<input type='hidden' name='" + $action . attr ( 'name' ) + "' value='" + $action . attr ( 'value' ) + "'/>" ) ; form . submit ( ) ; modal . modal ( 'hide' ) ; return false ; }
function ( e ) { if ( e . keyCode == 37 ) { $ ( "#previous-button" ) . click ( ) ; return false ; } if ( e . keyCode == 38 ) { $ ( "#card-partial" ) . click ( ) ; return false ; } if ( e . keyCode == 39 ) { $ ( "#next-button" ) . click ( ) ; return false ; } return false ; }
function ( ) { var res = handler . apply ( sub , params || [ ] ) ; if ( Meteor . _RemoteCollectionDriver && ( res instanceof Meteor . _Mongo . Cursor ) ) sub . _publishCursor ( res ) ; }
function ( data ) { $ ( '#content' ) . append ( data ) ; insertItem ( { id : 1 , priority : 1 , item : 'Maggi' , price : 100 , qty : 1 , units : 'kg' , tags : 'food' } ) ; }
function setupShoppingListEvents ( ) { console . log ( 'setting up events' ) ; $ ( '.item-action-delete' ) . live ( 'click' , function ( ) { console . log ( $ ( this ) . parent ( ) . attr ( 'id' ) ) ; id = $ ( this ) . parent ( ) . attr ( 'id' ) ; id = id . split ( '-' ) [ 1 ] ; $ ( '#item-' + id ) . remove ( ) ; } ) ; }
function ( err , data ) { if ( err ) return next ( err ) ; resolved . Stylesheet [ index ] = { id : path . basename ( uri . pathname ) , data : data . toString ( ) } ; next ( err ) ; }
function ( err , data ) { if ( err ) return next ( err ) ; resolved . Stylesheet [ index ] = { id : s , data : data } ; next ( err ) ; }
function ( ) { var tmp = $ ( this ) ; if ( $ ( this ) . hasClass ( "open" ) ) { $ ( "#help" ) . slideUp ( "100" , function ( ) { tmp . removeClass ( "open" ) ; $ ( "#data" ) . show ( ) ; } ) ; } else { $ ( "#data" ) . hide ( ) ; $ ( "#help" ) . slideDown ( "100" , function ( ) { tmp . addClass ( "open" ) ; } ) ; } }
function ( event , rangeObject ) { var foundMarkup ; foundMarkup = that . findLangMarkup ( rangeObject ) ; if ( foundMarkup ) { addMarkupToSelectionButton . setPressed ( true ) ; FloatingMenu . setScope ( 'wai-lang' ) ; langField . setTargetObject ( foundMarkup , 'lang' ) ; } else { langField . setTargetObject ( null ) ; } }
function ( ) { var range = Aloha . Selection . getRangeObject ( ) , foundMarkup = this . findLangMarkup ( range ) ; if ( foundMarkup ) { GENTICS . Utils . Dom . removeFromDOM ( foundMarkup , range , true ) ; range . select ( ) ; FloatingMenu . setScope ( 'Aloha.continousText' ) ; langField . setTargetObject ( null ) ; FloatingMenu . doLayout ( ) ; } }
function ( ) { var $li = jQuery ( this ) ; $li . contents ( ) . each ( function ( ) { if ( this . nodeType === 3 ) { this . data = jQuery . trim ( this . data ) ; } } ) ; }
function ( ) { var search = this . grid . find ( 'input.aloha-browser-search-field' ) , searchValue = search . val ( ) ; if ( jQuery ( search ) . css ( "font-style" ) == "italic" ) { searchValue = "" ; } this . _pagingOffset = 0 ; this . _searchQuery = search . val ( ) ; this . fetchItems ( this . _currentFolder , this . processItems ) ; }
function parseArrowFunctionExpression ( param ) { var previousStrict , body ; expect ( '=>' ) ; previousStrict = strict ; strict = true ; body = parseConciseBody ( ) ; strict = previousStrict ; return { type : Syntax . ArrowFunctionExpression , id : null , params : param , body : body } ; }
function parseYieldExpression ( ) { var delegate ; expectKeyword ( 'yield' ) ; if ( ! state . inFunctionBody ) { throwErrorTolerant ( { } , Messages . IllegalYield ) ; } delegate = false ; if ( match ( '*' ) ) { lex ( ) ; delegate = true ; } return { type : Syntax . YieldExpression , argument : parseAssignmentExpression ( ) , delegate : delegate } ; }
function ( after_out ) { var animate ; animate = ! this . the . config . enable_auto_transitions ; animate || ( animate = this . the . config . disable_transitions ) ; if ( animate ) { return typeof after_out === "function" ? after_out ( ) : void 0 ; } else { return this . el . animate ( { opacity : 0 } , 300 , after_out ) ; } }
function Config ( the ) { this . the = the ; this . app_name = "app" ; this . animate_at_startup = app . config . animate_at_startup || false ; this . enable_auto_transitions = app . enable_auto_transitions || true ; this . no_push_state = typeof history . pushState === ! 'function' ; this . no_push_state || ( this . no_push_state = /(\?|\&)(crawler)/ . test ( window . location ) ) ; this . disable_transitions = this . no_push_state ; }
function ( el ) { var _this = this ; this . $el = $ ( el ) ; this . loadEvents ( ) ; var options = $ . extend ( settings , { state : "closed" , action : "milestones" , sort : "due_date" } ) ; this . callApi ( options ) . success ( function ( resp ) { if ( resp . data ) resp = resp . data ; _this . showMilestones ( resp ) ; } ) ; }
function ( node , perfix ) { while ( node && ! node . id ) { node = node . parentNode ; } var nodeId = node . id ; var len = perfix . length ; if ( nodeId . length <= len ) { throw Error ( "repeat node id error." ) ; } var index = nodeId . substring ( len , nodeId . length ) ; return parseInt ( index ) ; }
function ( ) { dojo . style ( this . removeFileButton . domNode , { display : 'none' } ) ; dojo . style ( this . thumbnailWrapper , { display : 'none' } ) ; dojo . style ( this . infoFileButton . domNode , { display : 'none' } ) ; this . value = '' ; this . fileInfo = null ; this . labelTextField . value = '' ; this . valueTextField . value = '' ; }
function ( row ) { var gameList = new gameView ( $ ( this ) . closest ( 'li' ) . find ( 'div' ) . text ( ) ) ; $ ( this ) . closest ( 'li' ) . append ( gameList . render ( ) . $el ) ; }
function ( ) { var content = this . model . toJSON ( ) ; $ ( this . el ) . html ( this . template ( content ) ) ; return this ; }
function ( ) { if ( jQuery ( "#wpgmappity_promote" ) . is ( ':checked' ) ) { data . promote = '1' ; var text = '<a href="http://www.wordpresspluginfu.com/wpgmappity/" target="_blank">' ; text += 'Google Maps for WordPress by WPGmappity</a>' ; jQuery ( "#wpgmappity_promote_text" ) . html ( text ) ; } else { data . promote = '0' ; jQuery ( "#wpgmappity_promote_text" ) . html ( '' ) ; } }
function registerPlugins ( plugins ) { for ( var i = plugins . length ; i -- ; ) { try { var plugin = require ( path . join ( ComponentRegistry . PLUGIN_FOLDER , plugins [ i ] ) ) ; plugins [ i ] = plugin ; console . debug ( "Loaded registry plugin: " + plugin . name ) ; } catch ( ex ) { throw new RainError ( 'Registry Plugin %s is invalid.' , [ plugins [ i ] ] , RainError . ERR_IO ) ; } } }
function ( ) { var args = fn . mostRecentCall . args ; expect ( args . length ) . toEqual ( 4 ) ; expect ( args [ 0 ] ) . toEqual ( new Environment ( ) ) ; expect ( typeof args [ 1 ] ) . toEqual ( 'function' ) ; expect ( args [ 2 ] ) . toEqual ( componentOpt . context ) ; expect ( args [ 3 ] ) . toEqual ( { session : 'data' } ) ; }
function ( ) { renderer . renderBootstrap ( button , 'index' , request , response ) ; expect ( bootstrap . compiledTemplate ) . toHaveBeenCalledWith ( { id : 'button' , version : '2.0' , viewId : 'index' , placeholder : '{"html":"<div />"}' , placeholderTimeout : 500 , context : { query : 'param=value' , body : '{}' } } ) ; }
function skipWhitespace ( state ) { while ( state . strIdx < state . str . length && isWhitespace ( state . str [ state . strIdx ] ) ) { state . strIdx ++ ; } }
function ( ) { var permalink = H . generate_permalink ( $page ) ; $share_button . attr ( 'href' , [ 'https://twitter.com/intent/tweet' , '?url=' , encodeURIComponent ( permalink ) , '&text=' , encodeURIComponent ( 'ハトクラなう。今回のサプライ:' ) , '&related=' , encodeURIComponent ( 'HeartofCrown,kana1' ) ] . join ( '' ) ) ; }
function ( button_group , querystring ) { var a = document . createElement ( 'a' ) a . className = button_group . querySelector ( 'a' ) . className ; a . href = '?' + querystring ; a . title = 'Toggle Whitespace' ; a . textContent = ' \u2423 ' ; var li = document . createElement ( 'li' ) li . appendChild ( a ) ; button_group . insertBefore ( li , button_group . firstChild ) ; }
function ( ) { var active = $ ( '#list' ) . find ( '.active' ) ; KT . panel . panelAjax ( active , active . attr ( "data-ajax_url" ) , $ ( '#panel' ) , false ) ; }
function ( err , player ) { if ( err ) { socket . emit ( 'error' ) ; } else { player . time = data . lapTime ; player . save ( ) ; } }
function ( req , res ) { if ( ! req . facebook ) { res . render ( 'appauth' , { title : 'Authentication' } ) ; } else { var fbid = req . facebook . signed_request . user_id ; res . expose ( { fbid : fbid } , "lambdaracer.current" ) ; res . render ( 'index' , { title : 'Racer' } ) ; } }
function ( users ) { for ( var i = 0 ; i < users . length ; i ++ ) console . log ( users [ i ] ) ; }
function ( uiGroupClone ) { this . _inverse = new Shell . InvertLightnessEffect ( ) ; this . _brightnessContrast = new Clutter . BrightnessContrastEffect ( ) ; this . _colorSaturation = new Clutter . DesaturateEffect ( ) ; this . _inverse . set_enabled ( false ) ; this . _brightnessContrast . set_enabled ( false ) ; this . _magView = uiGroupClone ; this . _magView . add_effect ( this . _inverse ) ; this . _magView . add_effect ( this . _brightnessContrast ) ; }
function registerNavigatorEvents ( ) { if ( window . chrome && window . chrome . internal ) { chrome . internal . navigator = { } ; chrome . internal . navigator . onWindowState = function ( state ) { } ; chrome . internal . navigator . onWindowActive = function ( ) { if ( onResume ) { onResume ( ) ; } } ; chrome . internal . navigator . onWindowInactive = function ( ) { if ( onPause ) { onPause ( ) ; } } ; } }
function ( ) { var requestObj = request . init ( _webviewObj ) ; _webviewObj . visible = true ; _webviewObj . active = true ; _webviewObj . zOrder = 0 ; _webviewObj . enableCrossSiteXHR = true ; _webviewObj . setGeometry ( 0 , CHROME_HEIGHT , screen . width , screen . height - CHROME_HEIGHT ) ; window . qnx . webplatform . getApplicationWindow ( ) . visible = true ; _webviewObj . onNetworkResourceRequested = requestObj . networkResourceRequestedHandler ; if ( ready && typeof ready === 'function' ) { ready ( ) ; } }
function ( a , b ) { if ( a . nodeType == DOM . TEXT_NODE ) { return false ; } var precondition ; if ( b . nodeType == DOM . TEXT_NODE ) { b = b . parentNode ; precondition = true ; } else if ( b . nodeType == DOM . DOCUMENT_NODE ) { return false ; } else { precondition = a !== b ; } return precondition && ( a . contains ? a . contains ( b ) : true ) ; }
function ( a , b ) { if ( a . nodeType == DOM . TEXT_NODE ) { return false ; } var precondition ; if ( b . nodeType == DOM . TEXT_NODE ) { b = b . parentNode ; precondition = true ; } else if ( b . nodeType == DOM . DOCUMENT_NODE ) { return false ; } else { precondition = a !== b ; } return precondition && ( a . contains ? a . contains ( b ) : true ) ; }
function ( a , b ) { if ( a . nodeType == DOM . TEXT_NODE ) { return false ; } var precondition ; if ( b . nodeType == DOM . TEXT_NODE ) { b = b . parentNode ; precondition = true ; } else if ( b . nodeType == DOM . DOCUMENT_NODE ) { return false ; } else { precondition = a !== b ; } return precondition && ( a . contains ? a . contains ( b ) : true ) ; }
function init ( ) { var myMap = new ymaps . Map ( "map" , { center : event . coords , zoom : 15 } ) , myPlacemark = new ymaps . Placemark ( event . coords , { balloonContent : event . baloonContent } ) ; myMap . geoObjects . add ( myPlacemark ) ; myMap . controls . add ( 'smallZoomControl' ) ; }
function ( mode ) { if ( mode == null ) { mode = this . DEFAULT_MODE ; } this . mode = this . modeMap [ mode ] ; if ( this . editor != null ) { if ( this . mode != null ) { var HLMode = require ( this . MODE_BASE + this . mode ) . Mode ; this . editor . getSession ( ) . setMode ( new HLMode ( ) ) ; } else { this . editor . getSession ( ) . setMode ( null ) ; } } }
function ( ) { return { restrict : 'E' , transclude : false , scope : { level : '@level' , text : '@text' } , templateUrl : '/ng-templates/alert.html' , replace : true } }
function ( host , port ) { this . stream = null ; this . handlers = [ ] ; this . buffer = '' ; this . host = ( host === undefined ) ? DEFAULT_HOST : host ; this . port = ( port === undefined ) ? DEFAULT_PORT : port ; }
function ( data ) { self . buffer += data ; return self . tryHandlingResponse ( ) ; }
function ( err , jobid , payload ) { should . not . exist ( err ) ; jobid . should . exist ; testjobid = jobid ; var parsed = JSON . parse ( payload ) ; parsed . should . have . property ( 'type' ) ; parsed . type . should . equal ( 'test' ) ; done ( ) ; }
function ( event ) { moveEvents [ currentIndex ] = [ ] ; currentPoint = event ; moveEvents [ currentIndex ] . push ( event ) ; paint = true ; drawPoints ( ) ; intervalId = setInterval ( function ( ) { moveEvents [ currentIndex ] . push ( currentPoint ) ; } , 100 ) ; }
function ( err , tile , headers ) { if ( err ) { console . log ( "[TILE RENDER ERROR]\n" + err ) ; res . send ( err , 500 ) ; } else { res . send ( tile , headers , 200 ) ; } }
function animateEl ( el , v ) { v = v || '' ; var parent = e . parent ( ) ; el . animate ( { top : 0.3 * parseInt ( parent . height ( ) ) } , 350 , 'linear' , function ( ) { $ ( this ) . html ( v ) . css ( { top : - 0.8 * parseInt ( parent . height ( ) ) } ) . animate ( { top : 0 } , 350 , 'linear' ) } ) ; }
function ( req , res , next ) { res . locals . myCustomData = this . attributes . javascripts ; var start = new Date ( ) ; res . locals . time = function ( ) { return ( new Date ( ) ) . getTime ( ) - start . getTime ( ) ; } ; Page . prototype . render . call ( this , req , res , next ) ; }
function ( ) { if ( error ) return callback ( error ) ; self . compiler . modules . compile ( function ( error ) { if ( error ) return callback ( error ) ; self . compiler . presenter . compile ( function ( error ) { if ( error ) return callback ( error ) ; buildMap ( 'modules' ) ; buildMap ( 'presenter' ) ; callback ( ) ; } ) ; } ) ; }
function Player ( room , start_location ) { this . room = room ; if ( typeof start_location === 'undefined' ) { start_location = [ 0 , 0 ] ; } this . start_location = start_location ; this . location = start_location ; this . move ( [ 0 , 0 ] ) ; }
function ( ctx ) { this . room . draw ( ctx ) ; var x = this . location [ 0 ] , y = this . location [ 1 ] ; ctx . fillStyle = RED ; ctx . fillRect ( x * ( TILE_SIZE + 1 ) + 1 , y * ( TILE_SIZE + 1 ) + 1 , TILE_SIZE , TILE_SIZE ) ; }
function ( direction ) { var dx = direction [ 0 ] , dy = direction [ 1 ] ; var new_location = [ this . location [ 0 ] + dx , this . location [ 1 ] + dy ] ; this . room . activate ( new_location ) ; this . location = new_location ; this . draw ( ctx ) ; }
function handleKey ( ev ) { switch ( ev . keyCode ) { case KEY_LEFT : direction = [ - 1 , 0 ] ; break ; case KEY_UP : direction = [ 0 , - 1 ] ; break ; case KEY_RIGHT : direction = [ 1 , 0 ] ; break ; case KEY_DOWN : direction = [ 0 , 1 ] ; break ; default : return true ; } try { player . move ( direction ) ; } catch ( e ) { return true ; } }
function ( ) { Helpers . Log ( "App: Initialization started..." ) ; $ . ajaxSetup ( { cache : false } ) ; $ ( "head" ) . append ( "<link href='" + Helpers . GetExtensionRootURL ( "Pages/PAStyles.css" ) + "' type='text/css' rel='stylesheet' />" ) ; this . InitializeModalView ( ) ; this . isModalViewActive = false ; this . GetActivePage ( ) ; this . Load ( ) ; }
function GotRequest ( request , sender , sendResponse ) { Helpers . DLog ( "Got request { requestSign: " + request . requestSign + ", requestCategory: " + request . requestCategory + ", requestName: " + request . requestName + ", actionName: " + request . actionName + ", requestData: " + request . requestData + " }" ) ; switch ( request . requestCategory ) { case "Notification" : GotNotificationRequest ( request ) ; break ; case "Data" : GotDataRequest ( request , sendResponse ) ; break ; default : console . error ( "BackgroundScript: Unknown category!" , request ) ; break ; } }
function ( err , data ) { if ( err ) { notFound ( res ) ; } else { res . writeHead ( 200 , { 'Content-Type' : type , 'Content-Length' : stats . size , 'Last-Modified' : stats . mtime } ) ; res . end ( data ) ; } }
function ( p ) { tilesetProgress . val ( p ) ; if ( p === 0 ) { tilesetProgress . css ( { visibility : 'visible' } ) ; } else if ( p === 1 ) { tilesetProgress . css ( { visibility : 'hidden' } ) ; } }
function clearForm ( form ) { $ ( ':input' , form ) . each ( function ( ) { var type = this . type ; var tag = this . tagName . toLowerCase ( ) ; if ( type == 'text' || type == 'password' || tag == 'textarea' ) this . value = "" ; else if ( type == 'checkbox' || type == 'radio' ) this . checked = false ; else if ( tag == 'select' ) this . selectedIndex = - 1 ; } ) ; }
function ( event , args ) { if ( ! ! this . listeners [ event ] ) { for ( var i = - 1 , length = this . listeners [ event ] . length ; ++ i < length ; ) { this . listeners [ event ] [ i ] . apply ( window , args ) ; } } }
function ( event ) { $ ( document ) . unbind ( event ) ; $ . mobile . hidePageLoadingMsg ( ) ; renderNewPosts ( ) ; if ( postLimit < iLepra . inboxPosts . length ) { moreInboxBtn . show ( ) ; moreInboxBtn . bind ( "tap" , function ( event ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; postLimit += postLimit ; if ( postLimit >= iLepra . inboxPosts . length ) { moreInboxBtn . hide ( ) ; } renderNewPosts ( ) ; } ) ; } }
function ( event ) { $ ( document ) . unbind ( event ) ; $ . mobile . hidePageLoadingMsg ( ) renderNewPosts ( ) ; if ( postLimit < iLepra . myStuffPosts . length ) { mystuffMoreBtn . show ( ) ; mystuffMoreBtn . bind ( "tap" , function ( e ) { e . preventDefault ( ) ; e . stopPropagation ( ) ; postLimit += postLimit ; if ( postLimit >= iLepra . myStuffPosts . length ) { mystuffMoreBtn . hide ( ) ; } renderNewPosts ( ) ; } ) ; } }
function ( event ) { $ ( document ) . unbind ( event ) ; $ . mobile . hidePageLoadingMsg ( ) ; rendreNew ( ) ; }
function ( e , search_params ) { var old_params = $ . bbq . getState ( 'search' ) ; $ . bbq . pushState ( { search : search_params , subgrid : { } , environments : get_initial_environments ( ) } ) ; search_params = $ . bbq . getState ( "search" ) ; if ( utils . isEqual ( old_params , search_params ) ) { do_search ( search_params ) ; } }
function ( ) { this . center = { } ; this . center . chart = new window . BSource ( { trackId : this . cid } ) ; this . right = { } ; this . right . chart = new window . BSource ( { trackId : this . cid } ) ; this . left = { } ; this . left . chart = new window . BSource ( { trackId : this . cid } ) ; }
function ( min , max ) { var rover = this ; var tracks = rover . tracks ; for ( var i in tracks ) { tracks [ i ] . center . chart . scale . min = min ; tracks [ i ] . center . chart . scale . max = max ; } }
function ( url , type , hash ) { hash . url = url ; hash . type = type ; hash . dataType = 'json' ; hash . contentType = 'application/json' ; hash . context = this ; if ( hash . data && type !== 'GET' ) { hash . data = JSON . stringify ( hash . data ) ; } jQuery . ajax ( hash ) ; }
function ( ) { console . log ( "hurrah - convexProcessor is running" ) ; this . factory = new betterform . ui . UIElementFactory ( ) ; this . convex = document . getElementById ( "convex" ) ; dojo . subscribe ( "xforms-invalid" , function ( value ) { console . debug ( "received event: " , value ) ; } ) ; }
function ( event ) { console . debug ( "moveItemUp:  currentjsTreeData:" , this . currentjsTreeData ) ; console . debug ( "moveItemUp: data.rslt.obj.attr('id'): " , jsTreeObject . currentjsTreeData . rslt . obj . attr ( "id" ) ) ; console . debug ( "move item down next:" , $ ( "#xfDoc" ) ) ; console . debug ( "move item down next:" , $ ( "#xfDoc" ) . jstree ) ; console . debug ( "move item down tree index:" , $ . jstree . _reference ( "#xfDoc" ) . get_index ( ) ) ; }
function ( event ) { console . debug ( "move item down event:" , event , "currentjsTreeData:" , this . currentjsTreeData ) ; console . debug ( "moveItemUp: data.rslt.obj.attr('id'): " , this . currentjsTreeData . rslt . obj . attr ( "id" ) ) ; console . debug ( "move item down next:" , $ ( "#xfDoc" ) ) ; console . debug ( "move item down next:" , $ ( "#xfDoc" ) . jstree ) ; var data = this . currentjsTreeData . rslt . obj ; console . debug ( "move item down tree index:" , $ . jstree . _reference ( "#xfDoc" ) . get_index ( ) ) ; }
function ( origin , target ) { var xfType = origin . attr ( "data-xf-type" ) ; var targetType = target . attr ( "data-xf-type" ) ; console . log ( "check target:" , targetType ) ; var childArray = eval ( targetType + "Childs" ) ; if ( childArray == undefined ) { return false ; } if ( dojo . indexOf ( childArray , xfType ) != - 1 ) { return true ; } else { return false ; } }
function ( file ) { if ( file [ 0 ] === '.' ) { return ; } file = file . split ( '.' ) ; if ( file . length > 1 && file . pop ( ) === 'js' ) { file = file . join ( '.' ) ; file = path . join ( modelPath , file ) ; models [ path . basename ( file ) ] = file ; } }
function Thanks ( ) { comments = $ ( "#feedback" ) . val ( ) ; $ . post ( "core/DataWrangler.php" , { "page" : "comments" , "username" : username , "comments" : comments } ) ; $ ( "#feedback_h" ) . hide ( ) ; $ ( "#GetFeedback-wrapper" ) . hide ( 500 ) ; $ ( "#thanks" ) . show ( 500 ) ; }
function getTransactions ( callback ) { var params = createParams ( "chrome" , "listtransactions" , [ ] ) var success = function ( res ) { callback ( res ) ; } var failure = function ( res ) { callback ( res ) ; } send ( params , success , failure ) }
function ( ) { expect ( 2 ) ; baidu ( "#qunit-fixture" ) . html ( "<article><section><aside>HTML5 elements</aside></section></article>" ) ; equal ( baidu ( "#qunit-fixture" ) . children ( ) . children ( ) . length , 1 , "Make sure HTML5 article elements can hold children. innerHTML shortcut path" ) ; equal ( baidu ( "#qunit-fixture" ) . children ( ) . children ( ) . children ( ) . length , 1 , "Make sure nested HTML5 elements can hold children." ) ; }
function ( emitter , deltaTime ) { this . _nToCreate += this . _rate * deltaTime ; var nParticles = Math . floor ( this . _nToCreate ) ; nParticles = Math . min ( nParticles , emitter . deadParticles ( ) . length ) ; this . _nToCreate -= nParticles ; for ( var i = 0 ; i < nParticles ; i ++ ) { emitter . spawnParticle ( ) ; } }
function ( child , parent ) { for ( var key in parent ) { if ( __hasProp . call ( parent , key ) ) child [ key ] = parent [ key ] ; } function ctor ( ) { this . constructor = child ; } ctor . prototype = parent . prototype ; child . prototype = new ctor ( ) ; child . __super__ = parent . prototype ; return child ; }
function ( name , fig ) { var found = false ; jQuery . each ( json . components , function ( idx , comp ) { if ( comp . name === name ) { found = true ; } } ) ; if ( ! found ) { workflow . removeFigure ( fig ) ; self . removeChild ( fig ) ; delete self . figures [ name ] ; } }
function ( ) { var id = '_smokescreen_' , el = document . getElementById ( id ) ; if ( el === null ) { el = document . createElement ( 'div' ) ; el . setAttribute ( 'id' , id ) ; el . style . cssText = 'position:fixed;top:0px;left:0px;' + 'height:100%;width:100%;' + 'background:#EEE;opacity:.4;' + 'z-index:999;display:none' ; document . body . appendChild ( el ) ; } if ( el . style . display === 'block' ) { el . style . display = 'none' ; } else { el . style . display = 'block' ; } }
function ( ) { var jba = new JBA ( ) ; ok ( jba . isASCIICharValid ( "a" ) , "testing a" ) ; ok ( jba . isASCIICharValid ( "9" ) , "testing 9" ) ; ok ( ! jba . isASCIICharValid ( "é" ) , "testing é" ) ; ok ( ! jba . isASCIICharValid ( "þ" ) , "testing þ" ) ; }
function ( ) { var jba = new JBA ( ) ; ok ( jba . isASCIIStringValid ( "hello word" ) , "testing hello word" ) ; ok ( jba . isASCIIStringValid ( "foo" + "\0" + "bar" ) , "testing foo[null char]bar" ) ; ok ( ! jba . isASCIIStringValid ( "déjà" ) , "testing déjà" ) ; ok ( ! jba . isASCIIStringValid ( "Россия" ) , "testing Россия" ) ; }
function ( ) { var jba = new JBA ( ) ; ok ( ! jba . isUnsignedByteValid ( 256 ) , "testing 256" ) ; ok ( ! jba . isUnsignedByteValid ( - 1 ) , "testing -1" ) ; ok ( jba . isUnsignedByteValid ( 0 ) , "testing 0" ) ; ok ( jba . isUnsignedByteValid ( 255 ) , "testing 255" ) ; }
function ( ) { var jba = new JBA ( ) ; ok ( ! jba . isByteValid ( 128 ) , "testing 128" ) ; ok ( ! jba . isByteValid ( - 129 ) , "testing -129" ) ; ok ( jba . isByteValid ( - 127 ) , "testing -127" ) ; ok ( jba . isByteValid ( 127 ) , "testing 127" ) ; ok ( jba . isByteValid ( 0 ) , "testing 0" ) ; }
function ( ) { var jba = new JBA ( ) ; ok ( ! jba . isUnsignedShortValid ( 65536 ) , "testing 65536" ) ; ok ( ! jba . isUnsignedShortValid ( - 1 ) , "testing -1" ) ; ok ( jba . isUnsignedShortValid ( 0 ) , "testing 0" ) ; ok ( jba . isUnsignedShortValid ( 65535 ) , "testing 65535" ) ; }
function ( ) { var jba = new JBA ( ) ; ok ( ! jba . isShortValid ( 32768 ) , "testing 32768" ) ; ok ( ! jba . isShortValid ( - 32769 ) , "testing -32769" ) ; ok ( jba . isShortValid ( - 32768 ) , "testing -32768" ) ; ok ( jba . isShortValid ( 32767 ) , "testing 32767" ) ; ok ( jba . isShortValid ( 0 ) , "testing 0" ) ; }
function ( ) { var jba = new JBA ( ) ; ok ( ! jba . isUnsignedIntValid ( 4294967296 ) , "testing 4294967296" ) ; ok ( ! jba . isUnsignedIntValid ( - 1 ) , "testing -1" ) ; ok ( jba . isUnsignedIntValid ( 0 ) , "testing 0" ) ; ok ( jba . isUnsignedIntValid ( 4294967295 ) , "testing 4294967295" ) ; }
function ( ) { var jba = new JBA ( ) ; ok ( ! jba . isIntValid ( 2147483648 ) , "testing 2147483648" ) ; ok ( ! jba . isIntValid ( - 2147483649 ) , "testing −2147483649" ) ; ok ( jba . isIntValid ( - 2147483648 ) , "testing -2147483648" ) ; ok ( jba . isIntValid ( 2147483647 ) , "testing 2147483647" ) ; ok ( jba . isIntValid ( 0 ) , "testing 0" ) ; }
function ( ) { var jba ; jba = new JBA ( ) ; jba . writeUnsignedByte ( 0 ) ; ok ( jba . size ( ) === 1 ) ; jba = new JBA ( ) ; jba . writeUnsignedByte ( 255 ) ; ok ( jba . size ( ) === 1 ) ; }
function ( ) { var jba ; jba = new JBA ( ) ; jba . writeByte ( - 128 ) ; ok ( jba . size ( ) === 1 ) ; jba = new JBA ( ) ; jba . writeByte ( 127 ) ; ok ( jba . size ( ) === 1 ) ; }
function ( ) { var jba ; jba = new JBA ( ) ; jba . writeUnsignedShort ( 0 ) ; ok ( jba . size ( ) === 2 ) ; jba = new JBA ( ) ; jba . writeUnsignedShort ( 65535 ) ; ok ( jba . size ( ) === 2 ) ; }
function ( ) { var jba ; jba = new JBA ( ) ; jba . writeShort ( - 32768 ) ; ok ( jba . size ( ) === 2 ) ; jba = new JBA ( ) ; jba . writeShort ( 32767 ) ; ok ( jba . size ( ) === 2 ) ; }
function ( ) { var jba ; jba = new JBA ( ) ; jba . writeUnsignedInt ( 0 ) ; ok ( jba . size ( ) === 4 ) ; jba = new JBA ( ) ; jba . writeUnsignedInt ( 4294967295 ) ; ok ( jba . size ( ) === 4 ) ; }
function ( ) { var jba ; jba = new JBA ( ) ; jba . writeInt ( - 2147483648 ) ; ok ( jba . size ( ) === 4 ) ; jba = new JBA ( ) ; jba . writeInt ( 2147483647 ) ; ok ( jba . size ( ) === 4 ) ; }
function ( store , type , id ) { var fixtures = this . fixturesForType ( type ) ; if ( fixtures ) { fixtures = fixtures . findProperty ( 'id' , id ) ; } Ember . assert ( "Unable to find fixtures for model type " + type . toString ( ) , ! ! fixtures ) ; this . simulateRemoteCall ( function ( ) { store . load ( type , fixtures ) ; } , store , type ) ; }
function ( store , type , query , array ) { var fixtures = this . fixturesForType ( type ) ; fixtures = this . queryFixtures ( fixtures , query ) ; Ember . assert ( "Unable to find fixtures for model type " + type . toString ( ) , ! ! fixtures ) ; this . simulateRemoteCall ( function ( ) { array . load ( fixtures ) ; } , store , type ) ; }
function ( ) { var current = { "order_by" : this . _order_mod + this . _order , "milestone" : this . _milestone_id , } if ( this . _status . length > 0 ) { current [ 'status' ] = this . _status ; } return current ; }
function ( post_data ) { var url = this . $el . data ( 'tasks-url' ) ; if ( post_data === undefined ) { post_data = { } ; } var postdata = _ . extend ( { } , this . collectPostData ( ) , post_data ) ; $ . post ( url , postdata , function ( data ) { Greenmine . taskCollection . reset ( data . tasks ) ; } , 'json' ) ; }
function ( ) { this . crateTexture = gl . createTexture ( ) ; this . crateTexture . image = new Image ( ) ; this . crateTexture . image . src = "model/wood_floor_parquet_.jpg" ; return this . crateTexture . image . onload = this . hmm ( this . crateTexture ) ; }
function ( ) { var intervalId = setInterval ( function ( ) { crypto . randomBytes ( 16 , function ( ex , buf ) { var message = 'Message from space: ' + buf ; ss . publish . all ( 'ss-example' , message ) ; } ) ; } , 3000 ) ; res ( 42 ) ; }
function ( ) { this . element . css ( 'position' , 'absolute' ) . parent ( ) . css ( 'position' , 'relative' ) ; this . func = this . options . orientation === 'vertical' ? [ 'height' , 'outerHeight' ] : [ 'width' , 'outerWidth' ] ; this . dim = this . options . orientation === 'vertical' ? 'top' : 'left' ; this . bindEvents ( ) ; this . lock ( this . options . lock ) ; }
function ( o , element ) { this . element = element ; this . parent = null ; this . upBtn = null ; this . downBtn = null ; this . handle = null ; this . func = null ; this . dim = null ; this . options = { minHandleSize : 10 , orientation : 'vertical' , scrollDistance : 10 , showButtons : true , mouseholdDeadtime : 500 , mouseholdTimeout : 10 } ; this . init ( o ) ; }
function ( event , delta , deltaX , deltaY ) { delta = self . options . orientation === 'vertical' ? deltaY : - 1 * deltaX ; self . scrollHandle ( - 1 * delta ) ; event . preventDefault ( ) ; }
function ( tmxFile ) { cc . Assert ( tmxFile != null && tmxFile . length > 0 , "TMXTiledMap: tmx file should not be nil" ) ; this . setContentSize ( cc . SizeZero ( ) ) ; var mapInfo = cc . TMXMapInfo . create ( tmxFile ) ; if ( ! mapInfo ) { return false ; } cc . Assert ( mapInfo . getTilesets ( ) . length != 0 , "TMXTiledMap: Map not found. Please check the filename." ) ; this . buildWithMapInfo ( mapInfo ) ; return true ; }
function ( groupName ) { if ( this . _objectGroups ) { for ( var i = 0 ; i < this . _objectGroups . length ; i ++ ) { var objectGroup = this . _objectGroups [ i ] ; if ( objectGroup && objectGroup . getGroupName ( ) == groupName ) { return objectGroup ; } } } return null ; }
function ( ) { var map = cc . TMXTiledMap . create ( "TileMaps/ortho-tile-property.tmx" ) ; this . addChild ( map , 0 , TAG_TILE_MAP ) ; for ( var i = 1 ; i <= 20 ; i ++ ) { cc . Log ( "GID:%i, Properties:%p" , i , map . propertiesForGID ( i ) ) ; } }
function ( color , size ) { var box = $ ( '<div></div>' ) ; box . css ( 'background-color' , color ) ; box . css ( 'width' , size + 'px' ) ; box . css ( 'height' , size + 'px' ) ; this . _jqBody . append ( box ) ; }
function ( value ) { var panelPane = FirebugChrome . $ ( "fbPanelPane" ) ; var newOrient = value ? "vertical" : "horizontal" ; if ( panelPane . orient == newOrient ) return ; panelSplitter . orient = panelPane . orient = newOrient ; }
function notify_txt ( icon , title , body ) { if ( localStorage [ "notifCkeck" ] != 1 ) return ; var notification = webkitNotifications . createNotification ( icon , title , body ) ; notification . show ( ) ; setTimeout ( function ( ) { notification . cancel ( ) ; } , localStorage [ "notifDelay" ] * 1000 ) ; }
function ( method ) { if ( methods [ method ] ) { return methods [ method ] . apply ( this , Array . prototype . slice . call ( arguments , 1 ) ) ; } else if ( typeof method === 'object' || ! method ) { return methods . init . apply ( this , arguments ) ; } else { $ . error ( 'Method ' + method + ' does not exist on jQuery.carousel' ) ; } }
function ( fulfillmentHandler , errorHandler ) { fulfillmentHandlers . push ( fulfillmentHandler ) errorHandlers . push ( errorHandler ) return this }
function error ( resp , msg , t ) { var i for ( i = 0 ; i < errorHandlers . length ; i ++ ) { errorHandlers [ i ] ( resp , msg , t ) } complete ( resp ) }
function ( fulfillmentHandler , errorHandler ) { fulfillmentHandlers . push ( fulfillmentHandler ) errorHandlers . push ( errorHandler ) return this }
function error ( resp , msg , t ) { var i for ( i = 0 ; i < errorHandlers . length ; i ++ ) { errorHandlers [ i ] ( resp , msg , t ) } complete ( resp ) }
function ( complete ) { ajax ( { url : '/tests/fixtures/invalidJSON.json' , type : 'json' } ) . then ( function ( resp ) { ok ( false , 'success callback fired' ) } , function ( resp , msg ) { ok ( msg == 'Could not parse JSON in response' , 'error callback fired' ) } ) ajax ( { url : '/tests/fixtures/fixtures.json' , type : 'json' } ) . then ( function ( resp ) { ok ( true , 'success callback fired' ) } , function ( resp ) { ok ( false , 'error callback fired' ) } ) }
function ( formId ) { if ( $ ( '#city_chouse' , formId ) . length == 0 && this . cityView == null ) { this . createFields ( formId ) ; this . bindEvents ( formId ) ; this . refreshCitiesView ( ) ; } else { this . bindEvents ( formId ) ; } this . fromInputsToSelect ( ) ; }
function ( ) { var args ; args = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; return Boiler . inHook . apply ( Boiler , [ pot ] . concat ( __slice . call ( args ) ) ) ; }
function ( ) { var args ; args = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; return Boiler . errorHook . apply ( Boiler , [ pot ] . concat ( __slice . call ( args ) ) ) ; }
function ( ) { var args ; args = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; return Boiler . outHook . apply ( Boiler , [ pot ] . concat ( __slice . call ( args ) ) ) ; }
function playMovie ( building ) { var device = device . uuid ; $ . getJSON ( 'http://tali.irail.be/REST/Device.json?device=' + device , function ( data ) { if ( data [ "exists" ] == 'true' ) window . plugins . videoPlayer . play ( 'http://tali.irail.be/REST/Movie/qrID/' + building . token + '.gp3' ) ; else { navigator . notification . alert ( "Video is only playable from a mobile device." , null , "Device not registered" , "OK" ) ; ; } } ) ; }
function assertInstanceof ( obj , type ) { if ( ! ( obj instanceof type ) ) { var actualTypeName = null ; var actualConstructor = Object . prototypeOf ( obj ) . constructor ; if ( typeof actualConstructor == "function" ) { actualTypeName = actualConstructor . name || String ( actualConstructor ) ; } fail ( "Object <" + PrettyPrint ( obj ) + "> is not an instance of <" + ( type . name || type ) + ">" + ( actualTypeName ? " but of < " + actualTypeName + ">" : "" ) ) ; } }
function findVideoById ( chan , id ) { for ( var x in videos [ chan ] . video ) { if ( videos [ chan ] . video [ x ] . id == id ) { return Number ( x ) ; } } return false ; }
function chgChan ( up_down ) { var old_chan = cur_chan var this_chan = old_chan ; if ( up_down == 'up' && this_chan > 0 ) { this_chan -- ; } else if ( up_down != 'up' && this_chan < channels . length - 1 ) { this_chan ++ ; } if ( this_chan != old_chan ) { var parts = channels [ this_chan ] . feed . split ( "/" ) ; window . location . hash = "/" + parts [ 1 ] + "/" + parts [ 2 ] + "/" ; } }
function ( e ) { if ( that . wallHit ( ) === false ) { if ( e . keyCode === 37 ) { console . log ( 'move left :' , that . playPiece [ 0 ] ) ; that . moveLeft ( ) ; } if ( e . keyCode === 39 ) { console . log ( that . playPiece [ 0 ] ) ; that . moveRight ( ) ; } } else { console . log ( 'wall hit' ) ; } }
function ( ) { var coords = this . coords ( ) ; for ( var c = 0 ; c <= 8 ; c = c + 2 ) { if ( coords [ c ] === 0 || coords [ c ] === 8 ) { return true ; } else { return false ; } } }
function ( e ) { if ( ( e . which && e . which == 13 ) || ( e . keyCode && e . keyCode == 13 ) ) { $ ( 'form[submitOnEnterKey=true]' ) . submit ( ) ; return false ; } else { return true ; } }
function ( req , res ) { if ( req . session && req . session . user ) { res . render ( "engage/starred" , { title : "SFU ENGAGE" , user : userobject , status : "logged in" } ) } else { req . session . user = fake_user_2 ; res . render ( "engage/starred" , { title : "SFU ENGAGE" , user : userobject , status : "logged in" } ) } }
function ( ) { var columns = this . _labelToColumnMap ; var result = 0 ; for ( var key in columns ) { var left = columns [ key ] . getLeft ( ) + columns [ key ] . getWidth ( ) ; result = Math . max ( result , left ) ; } return result ; }
function ( ) { var retVal = _configure . apply ( this , arguments ) ; if ( this . augment ) { this . removeView = LayoutManager . removeView ; this . _options = LayoutManager . prototype . _options ; LayoutManager . setupView ( this , this . _options ( ) ) ; } return retVal ; }
function ( manage ) { this . collection . each ( function ( model ) { this . insertView ( "ul" , new setup . ItemView ( { model : model . toJSON ( ) } ) ) ; } , this ) ; return manage ( this ) . render ( ) ; }
function ( el ) { var trimmed = $ . trim ( $ ( el ) . find ( ".inner-left" ) . html ( ) ) ; ok ( isNode ( el ) , "Contents is a DOM Node" ) ; equal ( trimmed , "Right" , "Correct render" ) ; start ( ) ; }
function ( el ) { var trimmed = $ . trim ( $ ( el ) . find ( ".inner-right div" ) . html ( ) ) ; ok ( isNode ( el ) , "Contents is a DOM Node" ) ; equal ( trimmed , "Right" , "Correct render" ) ; start ( ) ; }
function ( el ) { var trimmed = $ . trim ( $ ( el ) . find ( ".inner-right div" ) . html ( ) ) ; ok ( isNode ( el ) , "Contents is a DOM Node" ) ; equal ( trimmed , "Right" , "Correct render" ) ; start ( ) ; }
function updateMoveUp ( el ) { var isFirst = this . isFirst ( ) ; if ( isFirst && ! this . _updating && this . nextSibling && this . nextSibling . hidden === false ) { this . _updating = true ; var next = this . nextSibling ; if ( next ) { this . ownerTree . actionsPlugin . updateActions ( next ) ; } delete this . _updating ; } if ( isFirst ) { el . addClass ( 'disabled' ) ; } else { el . removeClass ( 'disabled' ) ; } }
function updateMoveDown ( el ) { var isLast = this . isLast ( ) ; if ( isLast && ! this . _updating && this . previousSibling && this . previousSibling . hidden === false ) { this . _updating = true ; var previous = this . previousSibling ; if ( previous ) { this . ownerTree . actionsPlugin . updateActions ( previous ) ; } delete this . _updating ; } if ( isLast ) { el . addClass ( 'disabled' ) ; } else { el . removeClass ( 'disabled' ) ; } }
function ( grid ) { selectedIndex = grid . focus . rowIndex ; selectedItem = grid . getItem ( selectedIndex ) ; id = grid . store . getValue ( selectedItem , 'invoice_idInvoice' ) ; tabTitle = 'I-' + grid . store . getValue ( selectedItem , 'invoice_numberInvoice' ) ; bba . openTab ( { tabId : 'invoice' + id , title : ( tabTitle ) ? tabTitle : 'Invoice' , url : './invoice/invoice' , content : { type : 'details' , invoice_idInvoice : id } } ) ; }
function ( ) { this . bind ( 'error' , function ( model , error ) { Utils . debug ( "Error in App: " + error ) ; } ) ; if ( ! this . get ( "authentication" ) ) { this . set ( "authentication" , new Authentication ( ) ) ; } window . onbeforeunload = this . saveAllStateBeforeUserLeaves ; localStorage . setItem ( "saveStatus" , "Not Saved" ) ; }
function ( ) { this . bind ( 'error' , function ( model , error ) { Utils . debug ( "Error in Authentication  : " + error ) ; } ) ; }
function ( data ) { alert ( "I couldn't log you into your corpus." ) ; Utils . debug ( data ) ; window . app . get ( "authentication" ) . set ( "staleAuthentication" , true ) ; }
function ( lasttime ) { var now = ( new Date ( ) ) . getTime ( ) ; for ( var timestamp in store ) { if ( timestamp > lasttime ) { return store [ timestamp ] ; } else if ( timestamp < now - 2000 ) { delete store [ timestamp ] ; } } return null ; }
function ( channel , message ) { console . log ( 'message' , channel , message . toString ( ) , messages ) ; if ( currentChannel === channel ) process . stdout . write ( message + '\r\n' ) ; else messages [ channel ] . unshift ( message . toString ( ) ) ; }
function ( c ) { return "SELECT " + ( c . selectClause == "" ? "*" : c . selectClause ) + " FROM " + c . tableName + c . joinClause + c . whereClause + c . orderByClause + c . limitClause ; }
function ( strategy , root , segment , index ) { if ( typeof ( strategy ) === "function" ) { return strategy ( root , segment , index ) ; } else if ( strategy && strategy . next ) { return strategy . next ( root , segment , index ) ; } }
function ( EL , uncess ) { uncess = uncess || 0 ; var newThat = fluid . model . makeTrundler ( that . root , config , that . strategies ) ; newThat . segs = fluid . model . parseEL ( EL ) ; newThat . index = 0 ; newThat . step ( newThat . segs . length - uncess ) ; return newThat ; }
function ( parent ) { if ( ! gs . gradeHash [ parent ] ) { resolveGradesImpl ( gs , parent ) ; } }
function ( model , expandSpec , recurse ) { var left = getOrRecurse ( model , expandSpec . left , recurse ) ; var right = getOrRecurse ( model , expandSpec . right , recurse ) ; if ( typeof ( left ) !== "object" || typeof ( right ) !== "object" ) { return left ; } return fluid . merge ( expandSpec . policy ? expandSpec . policy : null , { } , left , right ) ; }
function ( rulesObj ) { transformed = { } ; for ( var targetPath in rulesObj ) { var rule = rulesObj [ targetPath ] ; if ( typeof ( rule ) === "string" ) { rule = fixupExpandSpec ( rule ) ; } var expanded = expandRule ( model , targetPath , rule ) ; if ( typeof ( expanded ) !== "undefined" ) { fluid . set ( transformed , targetPath , expanded ) ; } } ; model = transformed ; }
function ( ) { var result = fluid . model . transform . arrayValue ( source , { path : "cat" } ) ; jqUnit . assertDeepEq ( "arrayValue() should box a non-array value up as one." , [ source . cat ] , result ) ; result = fluid . model . transform . arrayValue ( source , { path : "sheep" } ) ; jqUnit . assertDeepEq ( "arrayValue() should not box up an array value." , source . sheep , result ) ; }
function ( paths ) { var values = [ ] ; for ( var i = 0 ; i < paths . length ; i ++ ) { var path = paths [ i ] ; values . push ( { expander : { type : "fluid.model.transform.value" , path : path } } ) ; } return { values : values } ; }
function ( ) { var ruleA = { kitten : "cat" } ; var ruleB = { sirius : "kitten" } ; var expected = { sirius : "meow" } ; var result = fluid . model . transformWithRules ( source , [ ruleA , ruleB ] ) ; jqUnit . assertDeepEq ( "An array of rules should cause each to be applied in sequence." , expected , result ) ; }
function ( err , results ) { cb ( err , results [ 1 ] ) ; }
function ( _ , result ) { var resultItem if ( _t . settings . template ) { resultItem = $ ( '<li>' ) . html ( $ . tmpl ( _t . settings . template , result ) ) } else { if ( typeof result == "object" ) _t . throwError ( 'Response was of type Object, but no text/html-template was specified' ) resultItem = $ ( '<li>' ) . html ( result ) } body += $ ( "<div>" ) . html ( resultItem ) . html ( ) }
function ( ) { var segments = fluid . makeArray ( arguments ) , path = "" ; for ( var i = 0 ; i < segments . length ; ++ i ) { path = fluid . pathUtil . composePath ( path , segments [ i ] ) ; } return path ; }
function ( solutionId , handlerResponse ) { var unValued = fluid . model . transform ( handlerResponse , gpii . lifecycleManager . responseToSnapshotRules , { isomorphic : true } ) ; return fluid . get ( unValued , fluid . model . escapedPath ( solutionId , "0" ) , { parser : { parse : fluid . pathUtil . parseEL , compose : fluid . pathUtil . composePath } , strategies : [ fluid . model . defaultFetchStrategy ] } ) ; }
function ( enabled ) { if ( this . _isTouchEnabled != enabled ) { this . _isTouchEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { this . registerWithTouchDispatcher ( ) ; } else { cc . TouchDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } } } }
function ( enabled ) { if ( enabled != this . _isAccelerometerEnabled ) { this . _isAccelerometerEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( this ) ; } else { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( null ) ; } } } }
function ( enabled ) { if ( enabled != this . _isKeypadEnabled ) { this . _isKeypadEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . addDelegate ( this ) ; } else { cc . KeypadDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } } } }
function ( ) { if ( this . _isTouchEnabled ) { this . registerWithTouchDispatcher ( ) ; } this . _super ( ) ; if ( this . _isAccelerometerEnabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( this ) ; } if ( this . _isKeypadEnabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . addDelegate ( this ) ; } }
function ( ) { if ( this . _isTouchEnabled ) { cc . TouchDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } if ( this . _isAccelerometerEnabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( null ) ; } if ( this . _isKeypadEnabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } this . _super ( ) ; }
function ( size ) { this . _squareVertices [ 1 ] . x = size . width * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 2 ] . y = size . height * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 3 ] . x = size . width * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 3 ] . y = size . height * cc . CONTENT_SCALE_FACTOR ( ) ; this . _super ( size ) ; }
function ( ) { this . _super ( ) ; this . _ignoreAnchorPointForPosition = true ; var director = cc . Director . sharedDirector ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . setContentSize ( director . getWinSize ( ) ) ; }
function ( dt ) { this . unschedule ( this . _setNewScene ) ; var director = cc . Director . sharedDirector ( ) ; this . _isSendCleanupToScene = director . isSendCleanupToScene ( ) ; director . replaceScene ( this . _inScene ) ; cc . TouchDispatcher . sharedDispatcher ( ) . setDispatchEvents ( true ) ; this . _outScene . setVisible ( true ) ; }
function ( label , target , selector ) { var ret = new cc . MenuItemLabel ( ) ; if ( arguments . length == 3 ) { ret . initWithLabel ( label , target , selector ) ; } else { ret . initWithLabel ( label ) ; } return ret ; }
function ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) { cc . Assert ( value != null && value . length != 0 , "value length must be greater than 0" ) ; var label = new cc . LabelAtlas ( ) ; label . initWithString ( value , charMapFile , itemWidth , itemHeight , startCharMap ) ; this . initWithLabel ( label , target , selector ) ; return true ; }
function ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) { var ret = new cc . MenuItemAtlasFont ( ) ; ret . initFromString ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) ; return ret ; }
function ( NormalImage ) { if ( NormalImage ) { this . addChild ( NormalImage , 0 , cc . NORMAL_TAG ) ; NormalImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; NormalImage . setVisible ( true ) ; } if ( this . _normalImage ) { this . removeChild ( this . _normalImage , true ) ; } this . _normalImage = NormalImage ; }
function ( DisabledImage ) { if ( DisabledImage ) { this . addChild ( DisabledImage , 0 , cc . DISABLE_TAG ) ; DisabledImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; DisabledImage . setVisible ( false ) ; } if ( this . _disabledImage ) { this . removeChild ( this . _disabledImage , true ) ; } this . _disabledImage = DisabledImage ; }
function ( normalSprite , selectedSprite , disabledSprite , target , selector ) { cc . Assert ( normalSprite != null , "" ) ; this . initWithTarget ( target , selector ) ; this . setNormalImage ( normalSprite ) ; this . setSelectedImage ( selectedSprite ) ; this . setDisabledImage ( disabledSprite ) ; this . setContentSize ( this . _normalImage . getContentSize ( ) ) ; return true ; }
function ( ) { this . _super ( ) ; if ( this . _disabledImage ) { this . _disabledImage . setVisible ( false ) ; } if ( this . _selectedImage ) { this . _normalImage . setVisible ( false ) ; this . _selectedImage . setVisible ( true ) ; } else { this . _normalImage . setVisible ( true ) ; } }
function ( ) { this . _super ( ) ; this . _normalImage . setVisible ( true ) ; if ( this . _selectedImage ) { this . _selectedImage . setVisible ( false ) ; } if ( this . _disabledImage ) { this . _disabledImage . setVisible ( false ) ; } }
function ( normalSprite , selectedSprite , three , four , five ) { var ret = new cc . MenuItemSprite ( ) ; if ( five ) { ret . initFromNormalSprite ( normalSprite , selectedSprite , three , four , five ) ; } else if ( four ) { return cc . MenuItemSprite . create ( normalSprite , selectedSprite , null , three , four ) ; } else { return cc . MenuItemSprite . create ( normalSprite , selectedSprite , three , null , null ) ; } return ret ; }
function ( enabled ) { this . _super ( enabled ) ; if ( this . _subItems && this . _subItems . length > 0 ) { for ( var it = 0 ; it < this . _subItems . length ; it ++ ) { this . _subItems [ it ] . setIsEnabled ( enabled ) ; } } }
function ( plistFile ) { var ret = false ; this . _plistFile = plistFile ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( this . _plistFile ) ; cc . Assert ( dict != null , "Particles: file not found" ) ; return this . initWithDictionary ( dict ) ; }
function ( plist ) { cc . Assert ( plist , "Invalid texture file name" ) ; var path = cc . FileUtils . fullPathFromRelativePath ( plist ) ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( path ) ; cc . Assert ( dict , "cc.AnimationCache: File could not be found" ) ; this . addAnimationsWithDictionary ( dict ) ; }
function ( fileImage ) { this . _super ( ) ; if ( fileImage ) { this . initWithFile ( fileImage , cc . DEFAULT_CAPACITY ) ; } this . setContentSize ( new cc . Size ( cc . canvas . width , cc . canvas . height ) ) ; this . _renderTexture = cc . RenderTexture . create ( cc . canvas . width , cc . canvas . height ) ; }
function ( child , zOrder ) { cc . Assert ( child != null , "SpriteBatchNode.addChild():the child should not be null" ) ; cc . Assert ( this . _children . indexOf ( child ) > - 1 , "SpriteBatchNode.addChild():sprite batch node should contain the child" ) ; if ( zOrder == child . getZOrder ( ) ) { return ; } this . removeChild ( child , false ) ; this . addChild ( child , zOrder ) ; this . setNodeDirty ( ) ; }
function ( cleanup ) { if ( this . _children && this . _children . length > 0 ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var obj = this . _children [ i ] ; if ( obj ) { this . removeSpriteFromAtlas ( obj ) ; } } } this . _super ( cleanup ) ; this . _descendants = [ ] ; this . _textureAtlas . removeAllQuads ( ) ; }
function ( jsonData ) { var dict = jsonData ; var texturePath = "" ; var metadataDict = dict [ "metadata" ] ; if ( metadataDict ) { texturePath = this . _valueForKey ( "textureFileName" , metadataDict ) ; texturePath = texturePath . toString ( ) ; } var texture = cc . TextureCache . sharedTextureCache ( ) . addImage ( texturePath ) ; if ( texture ) { this . addSpriteFramesWithDictionary ( dict , texture ) ; } else { cc . Log ( "cocos2d: cc.SpriteFrameCache: Couldn't load texture" ) ; } }
function ( name ) { if ( ! name ) { return ; } if ( this . _spriteFramesAliases . hasOwnProperty ( name ) ) { delete ( this . _spriteFramesAliases [ name ] ) ; } if ( this . _spriteFrames . hasOwnProperty ( name ) ) { delete ( this . _spriteFrames [ name ] ) ; } }
function ( plist ) { var path = cc . FileUtils . fullPathFromRelativePath ( plist ) ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( path ) ; this . removeSpriteFramesFromDictionary ( dict ) ; }
function ( texture ) { var frameDict = null ; for ( var key in this . _spriteFrames ) { var frame = this . _spriteFrames [ key ] ; if ( frame && ( frame . getTexture ( ) == texture ) ) { delete ( this . _spriteFrames [ key ] ) ; } } }
function ( ) { this . _dispatchEvents = true ; this . _targetedHandlers = new Array ( ) ; this . _standardHandlers = new Array ( ) ; this . _handlersToAdd = new Array ( ) ; this . _handlersToRemove = new Array ( ) ; this . _toRemove = false ; this . _toAdd = false ; this . _toQuit = false ; this . _locked = false ; return true ; }
function ( priority , delegate ) { cc . Assert ( delegate != null , "TouchDispatcher.setPriority():Arguments is null" ) ; var handler = this . findHandler ( delegate ) ; cc . Assert ( handler != null , "TouchDispatcher.setPriority():Cant find TouchHandler" ) ; handler . setPriority ( priority ) ; this . rearrangeHandlers ( this . _targetedHandlers ) ; this . rearrangeHandlers ( this . _standardHandlers ) ; }
function ( touches , event ) { for ( var it = 0 ; it < touches . length ; it ++ ) { var touch = touches [ it ] ; if ( ! touch ) break ; var location = touch . locationInView ( touch . view ( ) ) ; this . addNewSpriteWithCoords ( location ) ; } }
function ( touches , event ) { if ( this . isMouseDown ) { if ( touches ) { this . circle . setPosition ( new cc . Point ( touches [ 0 ] . locationInView ( 0 ) . x , touches [ 0 ] . locationInView ( 0 ) . y ) ) ; } } }
function ( ) { var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; var center = cc . LabelTTF . create ( "word wrap \"testing\" (bla0) bla1 'bla2' [bla3] (bla4) {bla5} {bla6} [bla7] (bla8) [bla9] 'bla0' \"bla1\"" , cc . SizeMake ( s . width / 2 , 200 ) , cc . TEXT_ALIGNMENT_CENTER , cc . VERTICAL_TEXT_ALIGNMENT_TOP , "Marker Felt" , 32 ) ; center . setPosition ( cc . ccp ( s . width / 2 , 150 ) ) ; this . addChild ( center ) ; }
function ( ) { var layer1 = cc . LayerGradient . create ( cc . ccc4 ( 255 , 0 , 0 , 255 ) , cc . ccc4 ( 0 , 255 , 0 , 255 ) , cc . ccp ( 0.9 , 0.9 ) ) ; this . addChild ( layer1 , 0 , cc . TAG_LAYER ) ; this . setIsTouchEnabled ( true ) ; }
function ( touch , event ) { var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; var start = touch . locationInView ( touch . view ( ) ) ; var diff = cc . ccpSub ( cc . ccp ( s . width / 2 , s . height / 2 ) , start ) ; diff = cc . ccpNormalize ( diff ) ; var gradient = this . getChildByTag ( 1 ) ; gradient . setVector ( diff ) ; }
function ( touch , event ) { var location = touch . locationInView ( touch . view ( ) ) ; var pos = cc . PointZero ( ) ; if ( this . _background ) { pos = this . _background . convertToWorldSpace ( cc . PointZero ( ) ) ; } this . _emitter . setPosition ( cc . ccpSub ( location , pos ) ) ; }
function ( ) { this . _super ( ) ; this . setIsTouchEnabled ( true ) ; var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; this . addNewSpriteWithCoords ( cc . ccp ( s . width / 2 , s . height / 2 ) ) ; }
function ( touches , event ) { for ( var it = 0 ; it < touches . length ; it ++ ) { var touch = touches [ it ] ; if ( ! touch ) break ; var location = touch . locationInView ( touch . view ( ) ) ; this . addNewSpriteWithCoords ( location ) ; } }
function ( ) { this . setIsTouchEnabled ( true ) ; var BatchNode = cc . SpriteBatchNode . create ( s_grossini_dance_atlas , 50 ) ; this . addChild ( BatchNode , 0 , TAG_SPRITE_BATCH_NODE ) ; var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; this . addNewSpriteWithCoords ( cc . ccp ( s . width / 2 , s . height / 2 ) ) ; }
function ( touches , event ) { for ( var it = 0 ; it < touches . length ; it ++ ) { var touch = touches [ it ] ; if ( ! touch ) break ; var location = touch . locationInView ( touch . view ( ) ) ; this . addNewSpriteWithCoords ( location ) ; } }
function ( ) { this . setIsTouchEnabled ( true ) ; var node = cc . Node . create ( ) ; this . addChild ( node , 0 , TAG_SPRITE_BATCH_NODE ) ; this . _texture1 = cc . TextureCache . sharedTextureCache ( ) . addImage ( s_grossini_dance_atlas ) ; this . _texture2 = cc . TextureCache . sharedTextureCache ( ) . addImage ( s_grossini_dance_atlas_mono ) ; this . _usingTexture1 = true ; for ( var i = 0 ; i < 30 ; i ++ ) { this . addNewSprite ( ) ; } }
function ( ) { this . setIsTouchEnabled ( true ) ; var batch = cc . SpriteBatchNode . create ( s_grossini_dance_atlas , 50 ) ; this . addChild ( batch , 0 , TAG_SPRITE_BATCH_NODE ) ; this . _texture1 = batch . getTexture ( ) ; this . _texture2 = cc . TextureCache . sharedTextureCache ( ) . addImage ( s_grossini_dance_atlas_mono ) ; for ( var i = 0 ; i < 30 ; i ++ ) { this . addNewSprite ( ) ; } }
function ( touch , event ) { cc . Log ( "++++++++++++++++++++++++++++++++++++++++++++" ) ; this . _beginPos = touch . locationInView ( touch . view ( ) ) ; this . _beginPos = cc . Director . sharedDirector ( ) . convertToGL ( this . _beginPos ) ; return true ; }
function ( touch ) { var getPoint = touch . locationInView ( touch . view ( ) ) ; var myRect = this . rect ( ) ; myRect . origin . x += this . getPosition ( ) . x ; myRect . origin . y += this . getPosition ( ) . y ; return cc . Rect . CCRectContainsPoint ( myRect , getPoint ) ; }
function ( touch , event ) { cc . Assert ( this . _state == PADDLE_STATE_GRABBED , "Paddle - Unexpected state!" ) ; var touchPoint = touch . locationInView ( touch . view ( ) ) ; this . setPosition ( cc . PointMake ( touchPoint . x , this . getPosition ( ) . y ) ) ; }
function ( tempArray ) { var paraArray = ( typeof tempArray == "Array" ) ? tempArray : arguments ; var prev = paraArray [ 0 ] ; for ( var i = 1 ; i < paraArray . length ; i ++ ) { if ( paraArray [ i ] != null ) { prev = cc . Sequence . _actionOneTwo ( prev , paraArray [ i ] ) ; } } return prev ; }
function ( tempArray ) { var paramArray = ( typeof tempArray == "Array" ) ? tempArray : arguments ; var prev = paramArray [ 0 ] ; for ( var i = 1 ; i < paramArray . length ; i ++ ) { if ( paramArray [ i ] != null ) { prev = this . _actionOneTwo ( prev , paramArray [ i ] ) ; } } return prev ; }
function ( ctx ) { this . _super ( ) ; if ( cc . renderContextType == cc . CANVAS ) { } else { var newBlend = this . _blendFunc . src != cc . BLEND_SRC || this . _blendFunc . dst != cc . BLEND_DST ; if ( newBlend ) { } this . _textureAtlas . drawNumberOfQuads ( this . _quadsToDraw , 0 ) ; if ( newBlend ) { } } }
function ( ) { var s = this . _textureAtlas . getTexture ( ) ; this . _itemsPerColumn = parseInt ( s . height / this . _itemHeight ) ; this . _itemsPerRow = parseInt ( s . width / this . _itemWidth ) ; }
function ( content ) { for ( var key in validAlias ) { var regex = new RegExp ( key , "g" ) ; content = content . replace ( regex , function ( ) { return validAlias [ key ] } ) ; } return content . replace ( /:([a-z0-9\+\-_]+):/g , emojiReplacer ) ; }
function ( selections , chart ) { var duration = chart . transitionDuration ( ) ; if ( duration <= 0 ) return selections ; return selections . transition ( ) . duration ( duration ) ; }
function ( ) { slicePaths = slicePaths . data ( dataPie ( chart . group ( ) . top ( Infinity ) ) ) ; dc . transition ( slicePaths , chart ) . attrTween ( "d" , tweenPie ) ; labels = labels . data ( dataPie ( chart . group ( ) . top ( Infinity ) ) ) ; redrawLabels ( arc ) ; return chart ; }
function ( selections , chart ) { var duration = chart . transitionDuration ( ) ; if ( duration <= 0 ) return selections ; return selections . transition ( ) . duration ( duration ) ; }
function ( ) { slicePaths = slicePaths . data ( dataPie ( chart . group ( ) . top ( Infinity ) ) ) ; dc . transition ( slicePaths , chart ) . attrTween ( "d" , tweenPie ) ; labels = labels . data ( dataPie ( chart . group ( ) . top ( Infinity ) ) ) ; redrawLabels ( arc ) ; return chart ; }
function ( ) { this . clock = sinon . useFakeTimers ( ) ; d3 . select ( "body" ) . append ( "div" ) . attr ( "id" , "pie-chart-age" ) ; var chart = dc . pieChart ( "#pie-chart-age" ) ; chart . dimension ( valueDimension ) . group ( valueGroup ) . width ( width ) . height ( height ) . radius ( radius ) . innerRadius ( innerRadius ) . transitionDuration ( 0 ) ; chart . render ( ) ; return chart ; }
function ( ) { var imageFinder = document . getElementById ( 'hw-image-finder' ) ; imageFinder . parentNode . removeChild ( imageFinder ) ; Event . stopObserving ( document , 'keyup' , closePicker , false ) ; Event . stopObserving ( document , 'click' , closePicker , false ) ; return false ; }
function ( pipeline ) { var existing_pipeline = _ ( self . pipelines ( ) ) . find ( function ( p ) { return p . name ( ) == pipeline . name ; } ) ; if ( existing_pipeline ) { existing_pipeline . refresh ( pipeline ) ; } else { self . pipelines . push ( new Radiator . Pipeline ( pipeline ) ) ; } }
function ( cssCompletions , sidebarPane , isEditingName , acceptCallback ) { WebInspector . TextPrompt . call ( this , this . _buildPropertyCompletions . bind ( this ) , WebInspector . StylesSidebarPane . StyleValueDelimiters ) ; this . setSuggestBoxEnabled ( "generic-suggest" ) ; this . _cssCompletions = cssCompletions ; this . _sidebarPane = sidebarPane ; this . _isEditingName = isEditingName ; }
function ( ) { if ( GM_addStyle ) { return function ( css ) { GM_addStyle ( css ) return this } } else { return function ( css ) { $ . create ( 'style' ) . prop ( { 'type' : 'text/style' } ) . insert ( head ) . html ( css ) return this } } }
function abort ( ) { this . aborted = true ; this . responseText = null ; this . errorFlag = true ; this . requestHeaders = { } ; if ( this . readyState > sinon . FakeXMLHttpRequest . UNSENT && this . sendFlag ) { this . readyStateChange ( sinon . FakeXMLHttpRequest . DONE ) ; this . sendFlag = false ; } this . readyState = sinon . FakeXMLHttpRequest . UNSENT ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "update_history" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 58 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "process_data" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 783 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "process_data" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 806 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "select_item" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 878 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 979 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "update_history" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 58 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "process_data" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 783 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "process_data" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 806 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "select_item" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 878 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 979 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "update_history" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 58 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "process_data" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 783 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "process_data" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 806 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" , funcname : "select_item" } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 878 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : "gov-watch.iced" } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 979 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ch_end ( ) { if ( this . recentsEntry && ( this . recentsEntry . type . indexOf ( '-connected' ) == - 1 ) ) { this . recentsEntry . type += '-refused' ; } if ( this . currentCall ) this . currentCall . hangUp ( ) ; OnCallHandler . disconnected ( ) ; }
function ( rowid ) { var marker = map . allmarkers [ $ ( '#tab' ) . jqGrid ( 'getRowData' , rowid ) . id ] ; if ( ! marker ) return ; map . panTo ( marker . getLatLng ( ) ) ; marker . openPopup ( ) ; return true ; }
function ( ) { return 'OAuth realm="' + this . _realm + '"' ; }
function ( ) { return 'OAuth realm="' + this . _realm + '"' ; }
function ( err ) { var index = findRunningIndex ( result . running , tc ) ; if ( index > - 1 ) { if ( err ) { result . status = TEST_STATUS_FAILED ; result . error = err ; status = 'Failed' ; } else { result . status = TEST_STATUS_SUCCESS ; } log ( "    ... '%s.%s' (async end)..." , result . module , tc . substr ( 4 ) ) ; _done ( ) ; } }
function ( error ) { OpenMEAP . doToast ( "An error occurred checking for an update\n\n" + error . type + ':' + error . message ) ; }
function ( data ) { if ( data . complete == true ) { this . onComplete ( data ) ; } else if ( ! data . error ) { this . onIncrement ( data ) ; } else { this . onError ( data ) ; } }
function ( ) { checks ++ ; if ( OpenMEAP_update != 'undefined' ) { clearInterval ( interval ) ; if ( OpenMEAP_update != null ) { OpenMEAP . updates . onUpdate ( OpenMEAP_update ) ; } else { window . document . getElementById ( 'updateCallback' ) . innerHTML = "No update after " + checks + " check(s)" ; } } }
function testNonImmediateUpdates ( ) { document . body . innerHTML = "<h6>Update Check Callback</h6><div id=\"updateCallback\">No update</div>" ; checks = 0 ; interval = setInterval ( function ( ) { checks ++ ; if ( OpenMEAP_update != 'undefined' ) { clearInterval ( interval ) ; if ( OpenMEAP_update != null ) { OpenMEAP . updates . onUpdate ( OpenMEAP_update ) ; } else { window . document . getElementById ( 'updateCallback' ) . innerHTML = "No update after " + checks + " check(s)" ; } } } , 250 ) ; }
function ( chrName , min , max , callback ) { var chr = this . bwg . chromsToIDs [ chrName ] ; if ( chr === undefined ) { return callback ( [ ] ) ; } else { return this . readWigDataById ( chr , min , max , callback ) ; } }
function outerIframeLoaded ( ) { var injectedScript = "data:,function is(a, b, desc) {                                     \       if (a == b) {                                                      \         sendAsyncMessage('test:test-pass', desc);                        \       } else {                                                           \         sendAsyncMessage('test:test-fail', desc + ' ' + a + ' != ' + b); \       }                                                                  \     }                                                                    \     is(content.window.top, content.window, 'top');                       \     is(content.window.content, content.window, 'content');               \     is(content.window.parent, content.window, 'parent');                 \     is(content.window.frameElement, null, 'frameElement');               \     var innerIframe = content.document.getElementById('inner-iframe');   \     var innerWindow = innerIframe.contentWindow;                         \     is(innerWindow.top, content.window, 'inner top');                    \     is(innerWindow.content, content.window, 'inner content');            \     is(innerWindow.parent, content.window, 'inner parent');              \     is(innerWindow.frameElement, innerIframe, 'inner frameElement');" var mm = SpecialPowers . getBrowserFrameMessageManager ( iframe ) ; function onRecvTestPass ( msg ) { numMsgReceived ++ ; ok ( true , msg . json ) ; } mm . addMessageListener ( 'test:test-pass' , onRecvTestPass ) ; function onRecvTestFail ( msg ) { numMsgReceived ++ ; ok ( false , msg . json ) ; } mm . addMessageListener ( 'test:test-fail' , onRecvTestFail ) ; mm . loadFrameScript ( injectedScript , false ) ; waitForMessages ( 6 ) ; }
function ( target , source ) { if ( source . item ) { return ; } var yourItem = target . takeItem ( source ) ; if ( ! yourItem ) { return ; } if ( ! source . setItem ( yourItem ) ) { target . item = yourItem . id ; return ; } this . add ( '-item' , source , yourItem , '[from] move: Covet' ) ; }
function ( target , pokemon ) { if ( pokemon . status && ! target . status && target . trySetStatus ( pokemon . status ) ) { this . add ( '-curestatus' , pokemon , '[from] move: Psycho Shift' , '[of] ' + target ) ; pokemon . setStatus ( '' ) ; } else { return false ; } }
function ( target , source ) { if ( source . item ) { return ; } var yourItem = target . takeItem ( source ) ; if ( ! yourItem ) { return ; } if ( ! source . setItem ( yourItem ) ) { target . item = yourItem . id ; return ; } this . add ( '-item' , source , yourItem , '[from] move: Thief' ) ; }
function ( e , ui ) { dialogEvent . open ( $dialog ) ; if ( $ . isFunction ( oldCallbacks . open ) ) { oldCallbacks . open . apply ( $dialog , arguments ) ; } if ( ! options . destroyOnClose ) { $dialog . closest ( '.ui-dialog' ) . appendTo ( 'body' ) ; } }
function ( event ) { $ ( '.fb_share_message' ) . text ( "Connecting to Facebook..." ) ; $ ( '.fb_share_message' ) . show ( ) ; submitFacebookAction ( ) ; }
function ( element , suggestion ) { event . go = true ; if ( ! $hint . html ( ) ) { var suggestion = 'Did you mean <a href="#" id="suggested_email" class="suggested_email">' + suggestion . full + "</a>?" + "<br/>Click the '" + $ ( "#sign_petition" ) . val ( ) + "' button again if your address is correct" ; $hint . html ( suggestion ) . fadeIn ( 150 ) ; event . go = false ; } }
function ( d , s , id ) { var js , fjs = d . getElementsByTagName ( s ) [ 0 ] ; if ( ! d . getElementById ( id ) ) { js = d . createElement ( s ) ; js . id = id ; js . src = "//platform.twitter.com/widgets.js" ; fjs . parentNode . insertBefore ( js , fjs ) ; } }
function ( newPrice , oldPrice ) { var price = this . down ( '#price' ) ; if ( oldPrice ) { price . setHtml ( '' ) ; } if ( newPrice ) { price . setHtml ( 'Price: ' + newPrice + ' ' + Cs . Cart . getCurrency ( ) ) ; } }
function ( newPrice , oldPrice ) { var price = this . down ( '#price' ) ; if ( oldPrice ) { price . setHtml ( '' ) ; } if ( newPrice ) { price . setHtml ( 'Price: ' + newPrice + ' ' + Cs . Cart . getCurrency ( ) ) ; } }
function Module ( filename , stubs ) { this . id = this . filename = filename ; this . dirname = dirname ( filename ) ; this . exports = { } ; this . stubs = { } ; for ( var name in stubs ) { this . stubs [ name ] = stubs [ name ] ; } }
function ( pokemon , target ) { if ( pokemon . removeVolatile ( 'solarbeam' ) ) return ; this . add ( '-prepare' , pokemon , 'SolarBeam' , target ) ; if ( this . weather === 'sunnyday' ) return ; pokemon . addVolatile ( 'solarbeam' ) ; return true ; }
function insert ( str ) { var newpos = { } ; var lines = _this . introspect_state . before_replacing_word . split ( "\n" ) ; newpos . line = lines . length - 1 ; newpos . ch = lines [ lines . length - 1 ] . length + str . length ; editor . setValue ( _this . introspect_state . before_replacing_word + str + _this . introspect_state . after_cursor ) ; editor . setCursor ( newpos ) ; }
function ( ) { builder . plugins . setInstallState ( info . identifier , builder . plugins . TO_INSTALL ) ; info . installState = builder . plugins . TO_INSTALL ; builder . views . plugins . updatePluginEntry ( info ) ; }
function ( e , el ) { e && e . stop && e . stop ( ) ; var id = el . getParent ( 'div.task' ) . get ( 'data-id' ) , model = this . collection . getModelById ( id ) ; this . collection . removeModel ( model ) ; model . delete ( ) ; this . render ( ) ; }
function ( a , b ) { var map = { asc : a . get ( key ) > b . get ( key ) , desc : a . get ( key ) < b . get ( key ) } ; if ( typeof map [ type ] == 'undefined' ) type = 'asc' ; return map [ type ] ; }
function ( data ) { json = eval ( '(' + data + ')' ) ; plot ( json . data ) ; $ ( '#analytics-new-messages-range' ) . html ( v ) ; $ ( '#analytics-new-messages-range-type' ) . html ( range_type ) ; $ ( "#analytics-new-messages-update-loading" ) . hide ( ) ; }
function ( data ) { json = eval ( '(' + data + ')' ) ; count = $ ( ".health-throughput-current" ) ; count . html ( parseInt ( parseInt ( json . count ) / 5 ) ) ; count . fadeOut ( 200 , function ( ) { count . fadeIn ( 200 ) ; } ) ; }
function ( data ) { result = eval ( '(' + data + ')' ) ; if ( result . code == "success" ) { render_result ( success ( result . ms , result . content , result . op , result . result ) ) ; } else { render_result ( error ( result . reason ) ) ; } bindMessageSidebarClicks ( ) ; eternalize ( ) ; }
function ( item , value ) { var result ; if ( typeof item [ value ] === "function" ) { result = item [ value ] ( ) ; } else { result = item [ value ] ; } return result ; }
function ( context , args ) { var points = this . getPath ( 'toolRoot.annotation' ) . get ( 'points' ) ; for ( var i = 0 ; i < points . length ; i ++ ) { if ( Math . round ( args . x ) == Math . round ( points [ i ] [ 0 ] ) && Math . round ( args . y ) == Math . round ( points [ i ] [ 1 ] , 2 ) ) { break ; } } }
function ( args ) { var controller = this . graphControllerForPane ( args . pane ) ; controller . graphingToolStartTool ( { annotationName : args . annotationName , shape : args . shape , datadefName : args . data } ) ; this . set ( 'annotationName' , args . annotationName ) ; this . set ( 'datadefName' , args . data ) ; }
function ( ) { var count = $ ( '#post_line' ) . val ( ) . length ; if ( count > 15 ) { $ ( '#post_email' ) . show ( ) ; } $ ( '#post_email' ) . val ( ) = 'to see how the story develops...' ; }
function ( err , results ) { if ( err ) return callback ( err ) ; var path = '/apps/' + name ; self . del ( path , callback ) ; }
function ( err , app ) { if ( err ) return callback ( err ) ; var deleteService = function ( service , callback ) { self . deleteService ( service , callback ) ; } ; async . map ( app . services , deleteService , function ( err , results ) { if ( err ) return callback ( err ) ; var path = '/apps/' + name ; self . del ( path , callback ) ; } ) ; }
function ( asObject ) { var clonedObj = jQuery ( this . obj [ 0 ] . outerHTML ) ; clonedObj . find ( '.aloha-cleanme' ) . remove ( ) ; this . removePlaceholder ( clonedObj ) ; PluginManager . makeClean ( clonedObj ) ; return asObject ? clonedObj . contents ( ) : contentSerializer ( clonedObj [ 0 ] ) ; }
function ( data ) { if ( data && data . indexOf ( "<strong>Module Information</strong>" ) != - 1 ) { _ripper . getModule ( $ ( data ) ) ; NUSchedule . signals . send ( "on_module_rip_success" , index ) ; } else { NUSchedule . signals . send ( "on_module_rip_error" , index ) ; } _ripper . ripNext ( ) ; }
function ( ) { var element = $compile ( '<textarea ui-codemirror ng-model="foo"></textarea>' ) ( scope ) ; scope . foo = 'bar' ; scope . $apply ( ) ; expect ( element . siblings ( ) . text ( ) . trim ( ) ) . toBe ( scope . foo ) ; }
function ( ) { var all = this . paths ; if ( this . _shouldUseBrowserRequire ( ) ) { var browserRequirePath = new Path ( { type : "include" , path : __dirname + "/browser-require.js" } ) ; var browserRequireHackPath = new Path ( { type : "include" , path : __dirname + "/browser-require-hack.js" } ) ; all = [ browserRequirePath , browserRequireHackPath ] . concat ( all ) ; } return all ; }
function pathsFromGlob ( filepath , cb ) { if ( pathLib . extname ( filepath ) === "" ) { filepath += ".*" } glob ( filepath , cb ) ; }
function ( ex ) { if ( ! ex ) t . fail ( 'K not created' ) else fs . stat ( '/kvdb/' + K , function ( err , stat ) { if ( err ) t . fail ( err ) else { t . equal ( stat . mode & 0777 , 0755 ) ; t . ok ( stat . isFile ( ) , 'target not a Key' ) ; t . end ( ) ; } } ) }
function ( ) { if ( ! this . disposed_ ) { if ( goog . Disposable . ENABLE_MONITORING ) { if ( this . disposed_ == undefined ) { throw Error ( this + ' did not call the goog.Disposable base ' + 'constructor' ) ; } var uid = goog . getUid ( this ) ; delete goog . Disposable . instances_ [ uid ] ; } this . disposed_ = true ; this . disposeInternal ( ) ; } }
function ( date ) { var today = this . today , month = date . getMonth ( ) == today . getMonth ( ) , day = date . getDate ( ) == today . getDate ( ) , year = date . getYear ( ) == today . getYear ( ) ; if ( month && day && year ) { return true ; } return false ; }
function ( id ) { var parts = id . split ( '-' ) , date , type ; if ( parts . length > 1 ) { type = parts . shift ( ) ; switch ( type ) { case 'd' : date = new Date ( parts [ 0 ] , parts [ 1 ] , parts [ 2 ] ) ; break ; case 'm' : date = new Date ( parts [ 0 ] , parts [ 1 ] ) ; break ; } return date ; } return false ; }
function ( date , day , month , year ) { day = day || 0 ; month = month || 0 ; year = year || 0 ; return new Date ( year || date . getFullYear ( ) , month || date . getMonth ( ) , day || date . getDate ( ) ) ; }
function ( day , month ) { var states ; if ( this . isToday ( day ) ) { return this . PRESENT ; } states = '' ; if ( this . isPast ( day ) ) { states += this . PAST ; } else { states += this . FUTURE ; } if ( day . getMonth ( ) !== month . getMonth ( ) ) { states += ' ' + this . OTHER_MONTH ; } return states ; }
function bsm_winopen ( evt ) { if ( evt . detail . features !== 'background' ) return ; evt . preventDefault ( ) ; evt . stopPropagation ( ) ; var manifestURL = evt . target . getAttribute ( 'mozapp' ) ; var origin = manifestURL . substr ( 0 , manifestURL . indexOf ( '/' ) ) ; var frame = open ( origin , evt . detail . name , evt . detail . url ) ; if ( frame ) evt . detail . frameElement = frame ; }
function cm_init ( ) { this . muteButton . addEventListener ( 'mouseup' , this . toggleMute . bind ( this ) ) ; this . keypadButton . addEventListener ( 'mouseup' , this . toggleKeypad . bind ( this ) ) ; this . speakerButton . addEventListener ( 'mouseup' , this . toggleSpeaker . bind ( this ) ) ; this . answerButton . addEventListener ( 'mouseup' , OnCallHandler . answer . bind ( OnCallHandler ) ) ; this . rejectButton . addEventListener ( 'mouseup' , OnCallHandler . end . bind ( OnCallHandler ) ) ; }
function cm_update ( phone_number ) { document . getElementById ( 'cs-h-info-primary' ) . innerHTML = phone_number ; KeypadManager . phoneNumber = phone_number ; document . getElementById ( 'phone-number-view' ) . value = KeypadManager . phoneNumber ; KeypadManager . util . moveCaretToEnd ( document . getElementById ( 'phone-number-view' ) ) ; }
function cs_transitionNextLoop ( ) { self . screen . classList . add ( 'animate' ) ; self . screen . classList . toggle ( 'displayed' ) ; self . screen . classList . toggle ( 'prerender' ) ; self . screen . addEventListener ( 'transitionend' , function trWait ( ) { self . screen . removeEventListener ( 'transitionend' , trWait ) ; if ( displayed ) window . close ( ) ; } ) ; }
function getName ( origin ) { var manifest = getManifest ( origin ) ; if ( ! manifest ) { return null ; } if ( 'locales' in manifest ) { var locale = manifest . locales [ document . documentElement . lang ] ; if ( locale && locale . name ) { return locale . name ; } } return manifest . name ; }
function pan ( movementX ) { var currentPage = pages . current ; pageHelper . getCurrent ( ) . moveTo ( movementX + 'px' ) ; if ( currentPage > 0 ) { pageHelper . getPrevious ( ) . moveTo ( '-100% + ' + movementX + 'px' ) ; } if ( currentPage < pages . total - 1 ) { pageHelper . getNext ( ) . moveTo ( '100% + ' + movementX + 'px' ) ; } }
function ( lang ) { document . documentElement . lang = lang ; var total = pageHelper . total ( ) ; for ( var i = 0 ; i < total ; i ++ ) { pages . list [ i ] . translate ( ) ; } }
function checkEmptyPages ( ) { var index = 0 ; var total = pages . total ; while ( index < total ) { var page = pages . list [ index ] ; if ( page . getNumApps ( ) === 0 ) { pageHelper . remove ( index ) ; break ; } index ++ ; } }
function showAppDialog ( origin ) { if ( Applications . isCore ( origin ) ) return ; var app = Applications . getByOrigin ( origin ) ; var title = 'Remove ' + app . manifest . name ; var body = 'This application will be uninstalled fully from your mobile' ; Permissions . show ( title , body , function onAccept ( ) { app . uninstall ( ) } , function onCancel ( ) { } ) ; }
function pb_update ( current , total ) { if ( previousTotal !== total ) { style . width = ( 100 / total ) + percentage ; previousTotal = total ; } style . MozTransform = 'translateX(' + current * 100 + '%)' ; }
function _is_target_slot ( list ) { var i , slot ; if ( list == null ) { return true ; } for ( i = 0 ; i < list . length ; i += 1 ) { slot = list [ i ] ; if ( slot . ioperator == this . operator . id && slot . name == this . meta . name ) { return true ; } } return false ; }
function ( app , server ) { exports . admin_controller = require ( "./admin.js" ) ( app , server ) ; exports . auth_controller = require ( "./auth.js" ) ( app , server ) ; exports . home_controller = require ( "./home.js" ) ( app , server ) ; }
function ( value , idx ) { if ( value . id == id ) { this . set ( idx , value ) ; } }
function ( value , idx ) { if ( value . id == id ) { this . set ( idx , value ) ; } }
function ( path ) { if ( views . hasOwnProperty ( path ) ) return views [ path ] ; var view = $ . ajax ( { async : false , contentType : "text/html; charset=utf-8" , dataType : "text" , timeout : 10000 , url : path , success : function ( ) { } , error : function ( ) { throw "Error: template not found" ; } } ) . responseText ; views [ path ] = views ; return view ; }
function ( tempArray ) { var paraArray = ( typeof tempArray == "Array" ) ? tempArray : arguments ; var prev = paraArray [ 0 ] ; for ( var i = 1 ; i < paraArray . length ; i ++ ) { if ( paraArray [ i ] != null ) { prev = cc . Sequence . _actionOneTwo ( prev , paraArray [ i ] ) ; } } return prev ; }
function ( tempArray ) { var paramArray = ( typeof tempArray == "Array" ) ? tempArray : arguments ; var prev = paramArray [ 0 ] ; for ( var i = 1 ; i < paramArray . length ; i ++ ) { if ( paramArray [ i ] != null ) { prev = this . _actionOneTwo ( prev , paramArray [ i ] ) ; } } return prev ; }
function ( prefix , res ) { var _this = this , suffix = 'bemhtml.js' ; return Q . when ( res , function ( res ) { return _this . storeBuildResult ( _this . getPath ( prefix , suffix ) , suffix , res [ 'bemhtml' ] ) ; } ) ; }
function ( p ) { if ( p >= 0 ) { this . setOptions ( { page : p } ) ; } }
function startLearningNow ( ) { var routeName = $ ( '#newRouteName' ) . val ( ) ; newRoute = new route ( routeName ) ; newRoute . alertOps . displayInDiv ( true ) ; newRoute . alertOps . divId ( "#loaderDialog-alertsConsole" ) ; newRoute . learn ( ) ; $ ( "#loaderDialog-header" ) . html ( "<h1>Learning...</h1>" ) ; $ ( "#loaderDialog-top" ) . html ( "<a href=\"javascript:newRoute.endLearn()\" data-role=\"button\" " + "data-theme=\"b\" data-transition=\"none\">Destination reached</a>" ) $ . mobile . changePage ( '#loaderDialog' , 'none' , true , true ) ; }
function endLearning ( ) { newRoute . end ( ) ; $ ( "#loaderDialog-top" ) . empty ( ) ; $ ( "#loaderDialog-alertsConsole" ) . empty ( ) ; $ ( "#loaderDialog-bottom" ) . empty ( ) ; $ . mobile . changePage ( '#startpage' , 'none' , true , true ) ; }
function ( ) { $ . ajax ( { type : 'POST' , url : "/save/sources" , data : JSON . stringify ( arrsources ) } ) . done ( function ( msg ) { console . log ( msg ) ; if ( msg == 1 ) { window . location . reload ( ) ; } } ) ; return false ; }
function ( ) { var _this = this ; $ . ajax ( { url : '/users/me' , type : 'GET' , async : false , success : function ( json ) { _this . user = json ; _this . showUserinfo ( json ) ; } , error : function ( ) { _this . showLogin ( ) ; } , complete : function ( ) { _this . updateRoominfo ( ) ; _this . status ( 0 ) ; } } ) ; }
function ( ) { var songRows = _songList . children ( ) ; var ids = [ ] ; for ( var index = 0 ; index < songRows . length ; index ++ ) ids . push ( songRows [ index ] . id ) ; return ids ; }
function ( e , ui ) { var getIds = function ( ) { var songRows = _songList . children ( ) ; var ids = [ ] ; for ( var index = 0 ; index < songRows . length ; index ++ ) ids . push ( songRows [ index ] . id ) ; return ids ; } Player . sync ( getIds ( ) ) ; }
function ( event , ui ) { event . preventDefault ( ) ; if ( _source == Source . TYPING_SUGGEST ) _analyzeForSong ( ui . item . value ) ; else if ( _source == Source . SONG_SUGGEST ) { Player . addSongById ( ui . item . value . videoId ) ; _flashMessage ( 'Thanks!' , 2000 ) ; } }
function ( ) { this . prepareCommonInputs ( ) ; _class . addToolBar ( this . textarea , false ) ; }
function ( emitter ) { var self = this emitter . success ( function ( ) { self . finishedEmits ++ finish . call ( self ) } ) . error ( function ( err ) { self . finishedEmits ++ self . fails . push ( err ) finish . call ( self ) } ) . on ( 'sql' , function ( sql ) { self . eventEmitter . emit ( 'sql' , sql ) } ) }
function createTokenId ( ) { var len = 2 , key = createKey ( ) , offset = parseInt ( Math . random ( ) * ( key . length - len ) ) ; return 1 ; return key . substring ( offset , offset + len ) ; }
function ( data ) { console . log ( 'sender registered' ) ; socket . emit ( 'rcjs:confirmRegistration' , { tokenId : data . tokenId , events : self . captureEvents } ) ; socket . on ( 'rcjs:event' , function ( data ) { type = data . type ; if ( type ) { self . emitEvent ( type , data . event ) ; } } ) ; }
function capture ( doCapture , events ) { var method = doCapture ? window . addEventListener : window . removeEventListener ; self . captureEvents = events || self . captureEvents ; self . captureEvents . forEach ( function ( type ) { method ( type , genericEventHandler , false ) ; } ) ; }
function ( event ) { print ( '' , 'rcjs:swipeend' , event ) ; }
function ( e ) { if ( this . scrollingEnabled ) { self . _animateToPosition ( startTranslationX , startTranslationY , 400 + 0.3 * calculateDistance ( startTranslationX , startTranslationY , self . _currentTranslationX , self . _currentTranslationY ) , "ease-in-out" , function ( ) { self . _handleDragCancel && self . _handleDragCancel ( e ) ; } ) ; self . _endScrollBars ( ) ; self . _handleDragCancel && self . _handleDragCancel ( e ) ; } }
function ( side , value , animate ) { var top = /top/i . test ( side ) , me = this , dom = me . dom ; if ( ! top ) { if ( dom === document . body || dom === document . documentElement ) { value = - value ; } else { value = dom . scrollWidth - dom . clientWidth - value ; } } return this . callParent ( [ side , value , animate ] ) ; }
function ( ownerContext ) { var me = this , layout = me . layout , dom = layout . innerCt . dom , pos = dom . scrollWidth - dom . clientWidth - dom . scrollLeft ; this . callParent ( arguments ) ; ownerContext . innerCtScrollPos = pos ; }
function ( ownerContext ) { var me = this , layout = me . layout , dom = layout . innerCt . dom , scrollPos = Math . min ( me . getMaxScrollPosition ( ) , ownerContext . innerCtScrollPos ) ; dom . scrollLeft = dom . scrollWidth - dom . clientWidth - scrollPos ; }
function ( ) { var me = this , layout = me . layout , dom = layout . innerCt . dom , result ; if ( me . hasOwnProperty ( 'scrollPosition' ) ) { result = me . scrollPosition ; } else { result = ( dom . scrollWidth - dom . clientWidth - dom . scrollLeft ) || 0 ; } return result ; }
function ( e ) { var val = $ ( 'input#searchfield' ) . val ( ) ; if ( val != '' ) { search_string = '' ; $ ( 'input#searchfield' ) . val ( search_string ) ; qs . search ( search_string ) ; qs . cache ( ) ; redraw_grid ( ) ; } }
function ( e ) { var val = $ ( 'input#searchfield' ) . val ( ) ; var fullname = $ ( item ) . data ( 'fullname' ) ; if ( val != '' ) { search_string = '' ; } else { search_string = fullname ; } $ ( 'input#searchfield' ) . val ( search_string ) ; qs . search ( search_string ) qs . cache ( ) ; redraw_grid ( ) ; }
function Balloon ( options ) { this . options = options != null ? options : { } ; this . width = options . width || this . defaultWidth ; this . createInfoBox ( this . options ) ; this . setMap ( this . options . map ) ; this . customize ( ) ; }
function ( options ) { return this . setInfoBox ( new InfoBox ( { pixelOffset : new google . maps . Size ( 0 ) } , - 20 , { enableEventPropagation : true , closeBoxMargin : "10px" , disableAutoPan : true , boxStyle : { cursor : "pointer" , background : "url(/static/img/infowindow-arrow.png) no-repeat 0 10px" , width : this . width } } ) ) ; }
function ( ) { this . infoBox . close ( ) ; if ( this . feature . isHighlighted ) this . feature . setHighlight ( false ) ; this . feature = null ; return this . isMouseover = false ; }
function ( ) { return document . getElementById ( 'file' ) . files [ 0 ] . fileName ; }
function ( ) { var map = this . get ( "identityMap" ) ; if ( map === undefined ) { this . set ( "identityMap" , EmberMapper . NullIdentityMap . create ( ) ) ; } else if ( ! map ) { this . set ( "identityMap" , EmberMapper . IdentityMap . create ( ) ) ; } }
function set ( key , value ) { var val = style . call ( this . source , this . extended ) ; value ? ( val |= this . values [ key ] ) : ( val &= ~ this . values [ key ] ) ; style . call ( this . source , val , this . extended ) ; }
function installModule ( ) { var cmd = 'npm install ' + module ; console . log ( "Installing locally the module " + module ) ; console . log ( cmd ) ; var child = exec ( cmd , function ( err ) { callback ( err ) ; } ) ; child . stdout . on ( 'data' , console . log . bind ( console ) ) ; child . stderr . on ( 'data' , console . error . bind ( console ) ) ; }
function ( cid , cb ) { this . _showMessage ( 'Getting Info...' ) ; var self = this ; libDesigner . getConstructByID ( cid , function ( c ) { self . _con = c ; self . _hideMessage ( ) ; if ( $ . isFunction ( cb ) ) cb ( c ) ; } ) ; return this ; }
function ( cfids , dirs , _suc ) { AJAX . post ( { url : '/gibthon/api/' + this . id + '/saveOrder/' , data : { 'd[]' : { 'cfid' : cfids , 'direction' : dirs , } , } , success : function ( ) { if ( _suc != undefined ) _suc ( ) ; } , } ) ; }
function ( ) { ajax . post ( { url : '/gibthon/api/' + this . id + '/saveMeta/' , data : { 'name' : this . name , 'desc' : this . desc , } , } ) ; }
function ( data , textStatus , jqXHR ) { if ( data [ 0 ] == AJAX_ERROR ) { if ( args . error != undefined ) args . error ( jqXHR , data [ 1 ] , 'ServerError' ) ; else console . error ( 'AJAX Error: ' + data [ 1 ] ) ; } else s_fn ( data [ 1 ] ) ; }
function ( runner ) { var failed = runner . results ( ) . failedCount === 0 ? 0 : 1 ; childProcess . exec ( 'rm -rf node_modules/ripple*' , function ( ) { ( typeof done !== "function" ? process . exit : done ) ( failed ) ; } ) ; }
function ( ) { var targets = __dirname + "/../" + ( custom ? custom : "test" ) ; jasmine . run ( targets . split ( ' ' ) , function ( runner ) { var failed = runner . results ( ) . failedCount === 0 ? 0 : 1 ; childProcess . exec ( 'rm -rf node_modules/ripple*' , function ( ) { ( typeof done !== "function" ? process . exit : done ) ( failed ) ; } ) ; } ) ; }
function ( ) { set ( this , 'location' , get ( this , 'location' ) || window . location ) ; set ( this , 'callbacks' , Ember . A ( ) ) ; }
function ( path ) { var state = window . history . state ; if ( path === "" ) { path = '/' ; } if ( ( ! state && path !== '/' ) || ( state && state . path !== path ) ) { window . history . pushState ( { path : path } , null , path ) ; } }
function ( ) { expect ( 1 ) ; stop ( ) ; var count = 0 ; window . history . pushState = function ( data , title , path ) { count ++ ; } ; setTimeout ( function ( ) { start ( ) ; equal ( count , 0 , "pushState should not have been called" ) ; } , 100 ) ; locationObject . setURL ( '/' ) ; }
function ( ) { dijit . byId ( this . divname ) . show ( ) ; }
function Testling ( harness , name , conf ) { Test . apply ( this , arguments ) ; for ( var key in Test . prototype ) { this [ key ] = Test . prototype [ key ] . bind ( this ) ; } for ( var key in Testling . prototype ) { this [ key ] = Testling . prototype [ key ] . bind ( this ) ; } }
function showMultipleDetailsPanel ( itemTypeString ) { $ ( '#single-' + itemTypeString ) . hide ( ) ; var multipleDetails = $ ( "#multiple-" + itemTypeString + 's' ) ; multipleDetails . show ( ) ; fsmsButton . findAndApply ( "input[type='submit']" , multipleDetails ) ; if ( itemTypeString == "contact" ) selectmenuTools . refresh ( "#multi-group-dropdown" ) ; else selectmenuTools . refresh ( "#move-actions" ) ; }
function ( ) { $heatmap_canvas = $ ( '<canvas />' ) ; $heatmap_canvas . attr ( 'id' , html_id || DEFAULT_ID ) ; canvas_ctx = $heatmap_canvas [ 0 ] . getContext ( '2d' ) ; }
function ( new_heatmap , new_grid_width , new_grid_height ) { if ( new_grid_width * new_grid_height !== new_heatmap . length ) { throw new Error ( "Heatmap: provided heatmap has wrong dimensions." ) ; } heatmap = new_heatmap ; grid_width = new_grid_width ; grid_height = new_grid_height ; $heatmap_canvas . attr ( 'width' , grid_width ) ; $heatmap_canvas . attr ( 'height' , grid_height ) ; }
function ( ) { canvas_width = $heatmap_canvas . width ( ) ; canvas_height = $heatmap_canvas . height ( ) ; if ( hq_rendering ) { $heatmap_canvas . attr ( 'width' , canvas_width ) ; $heatmap_canvas . attr ( 'height' , canvas_height ) ; } else { $heatmap_canvas . attr ( 'width' , grid_width ) ; $heatmap_canvas . attr ( 'height' , grid_height ) ; } }
function ( event ) { var x = this . _startPositionX + event . translateX - this . _startTranslateX ; if ( x < 0 ) { x = 0 ; } else { if ( x > this . _sliderWidth ) { x = this . _sliderWidth ; } } this . _positionX = x ; }
function ( uuid ) { return $ . ajax ( { accepts : { json : 'application/json' } , cache : false , dataType : 'json' , error : function ( xhr , textStatus , errorThrown ) { console . log ( errorThrown ) ; } , type : 'DELETE' , url : '/dashboards/' + uuid } ) . done ( function ( d ) { console . log ( 'Dashboard ' + uuid + ' successfully deleted' ) ; } ) ; }
function ( opts ) { console . log ( opts ) ; var myUrl = window . location . pathname ; return $ . ajax ( { accepts : { json : 'application/json' } , cache : false , data : opts , dataType : 'json' , error : function ( xhr , textStatus , errorThrown ) { console . log ( textStatus ) ; } , type : 'PUT' , url : myUrl } ) . done ( function ( d ) { window . location . href = myUrl ; } ) }
function ( ) { $ ( this ) . unbind ( 'click' ) ; $ ( this ) . removeClass ( 'locked' ) ; $ ( this ) . addClass ( 'unlocked' ) ; myHeaderName = $ ( this ) . text ( ) ; $ ( this ) . html ( '<input type="text" class="name input-xxlarge" value="' + $ ( this ) . html ( ) + '" />' ) ; $ ( 'h1 input.name' ) . focus ( ) ; return false ; }
function ( e ) { if ( e . which === 13 ) { var newName = $ ( 'h1 input.name' ) . attr ( 'value' ) ; updateObjectAttributes ( { 'name' : newName } ) ; return false ; } }
function ( e ) { $ ( 'h1' ) . removeClass ( 'unlocked' ) ; $ ( 'h1' ) . addClass ( 'locked' ) ; $ ( this ) . remove ( ) ; $ ( 'h1' ) . html ( myHeaderName ) ; myHeaderName = '' ; $ ( 'h1.locked' ) . on ( 'click' , editObjectName ) ; return false ; }
function defaultReportDiagnosis ( severity , status , problemList ) { var classification = ses . logger . classify ( severity ) ; ses . logger [ classification . consoleLevel ] ( problemList . length + ' ' + status ) ; }
function ( e ) { tab . screenshot = e . target . result ; if ( ! isCurrentTab ) { this . setTabVisibility ( tab , false ) ; } if ( this . currentScreen === this . TABS_SCREEN ) { this . showTabScreen ( ) ; } }
function browser_handleEvent ( evt ) { var urlInput = this . urlInput ; switch ( evt . type ) { case 'submit' : this . go ( evt ) ; break ; case 'keyup' : if ( evt . keyCode === evt . DOM_VK_ESCAPE ) { evt . preventDefault ( ) ; this . showPageScreen ( ) ; this . urlInput . blur ( ) ; } } }
function browser_navigate ( url ) { this . showPageScreen ( ) ; this . currentTab . title = null ; this . currentTab . url = url ; this . currentTab . dom . setAttribute ( 'src' , url ) ; this . urlInput . value = url ; }
function browser_setUrlButtonMode ( mode ) { this . urlButtonMode = mode ; switch ( mode ) { case this . GO : this . urlButton . src = 'style/images/go.png' ; this . urlButton . style . display = 'block' ; break ; case this . REFRESH : this . urlButton . src = 'style/images/refresh.png' ; this . urlButton . style . display = 'block' ; break ; case this . STOP : this . urlButton . style . display = 'none' ; break ; } }
function browser_deselectAwesomescreenTabs ( ) { this . topSites . classList . remove ( 'selected' ) ; this . topSitesTab . classList . remove ( 'selected' ) ; this . bookmarks . classList . remove ( 'selected' ) ; this . bookmarksTab . classList . remove ( 'selected' ) ; this . history . classList . remove ( 'selected' ) ; this . historyTab . classList . remove ( 'selected' ) ; }
function browser_selectTab ( id ) { this . currentTab = this . tabs [ id ] ; this . urlInput . value = this . currentTab . title ; this . tabCover . setAttribute ( 'src' , this . currentTab . screenshot ) ; this . updateSecurityIcon ( ) ; this . refreshButtons ( ) ; }
function browser_showAwesomeScreen ( ) { this . urlInput . focus ( ) ; this . setUrlButtonMode ( this . GO ) ; this . tabsBadge . innerHTML = '' ; this . switchScreen ( this . AWESOME_SCREEN ) ; this . tabCover . style . display = 'none' ; this . showTopSitesTab ( ) ; }
function tabSwipe_pan ( e ) { if ( ! this . deleteable ) { return ; } var movement = Math . min ( this . containerWidth , Math . abs ( e . detail . absolute . dx ) ) ; if ( movement > 0 ) { this . tab . style . opacity = 1 - ( movement / this . containerWidth ) ; } this . tab . style . left = e . detail . absolute . dx + 'px' ; }
function places_addBookmark ( uri , title , callback ) { if ( ! title ) title = uri ; var bookmark = { uri : uri , title : title , timestamp : new Date ( ) . getTime ( ) } ; this . addPlace ( uri , ( function ( ) { this . db . saveBookmark ( bookmark , callback ) ; } ) . bind ( this ) ) ; }
function ( event ) { var place = event . target . result ; if ( place ) { if ( callback ) callback ( ) ; return ; } else { place = { uri : uri , title : uri , frecency : 0 } ; } var writeRequest = objectStore . add ( place ) ; writeRequest . onsuccess = function onsucess ( event ) { if ( callback ) callback ( ) ; } ; writeRequest . onerror = function onerror ( event ) { console . log ( 'error writing place' ) ; } ; }
function ( window ) { if ( typeof ( Calendar ) === 'undefined' ) { Calendar = { } ; } var Presets = { 'google' : { provider : 'Caldav' , group : 'remote' , options : { domain : 'https://calendar.google.com' , uri : '/calendar/dav/' } } , 'yahoo' : { provider : 'Caldav' , group : 'remote' , options : { domain : 'https://caldav.calendar.yahoo.com' , uri : '/' } } , 'local' : { provider : 'Local' , group : 'local' , options : { } } } ; Calendar . Presets = Presets ; }
function viewResponder ( ctx , next ) { self . _activeObjects . push ( object ) ; if ( 'onactive' in object ) { if ( ! object . __routerActive ) { object . onactive ( ) ; object . __routerActive = true ; } } next ( ) ; }
function ( ctx , next ) { var item ; while ( item = this . _activeObjects . pop ( ) ) { if ( 'oninactive' in item ) { if ( '__routerActive' in item ) { if ( item . __routerActive ) { item . oninactive ( ) ; } } else { item . oninactive ( ) ; } } if ( '__routerActive' in item ) { item . __routerActive = false ; } } next ( ) ; }
function ( ) { var args = Array . prototype . slice . call ( arguments ) ; args . push ( this . _noop ) ; var len = args . length ; var i = 0 ; var item ; for ( ; i < len ; i ++ ) { item = args [ i ] ; if ( typeof ( item ) === 'object' ) { args [ i ] = this . _wrapObject ( item ) ; } } this . page . apply ( this . page , args ) ; }
function ( match , name , type ) { if ( type === '' ) { type = 'h' ; } if ( type === 's' ) { return '" + String((a["' + name + '"] || "")) + "' ; } else { return '" + h["' + type + '"]((a["' + name + '"] || "")) + "' ; } }
function ( window ) { if ( typeof ( Calendar . Templates ) === 'undefined' ) { Calendar . Templates = { } ; } var Account = Calendar . Template . create ( { accountItem : [ '<li class="{name}">' , '<a data-provider="{name}" href="create-account/{name}">{name}</a>' , '</li>' ] . join ( '' ) } ) ; Calendar . Templates . Account = Account ; }
function View ( selector ) { this . element = document . querySelector ( selector ) ; }
function ( ) { if ( this . seen === false ) { this . onfirstseen ( ) ; } this . seen = true ; if ( this . element ) { this . element . classList . add ( this . activeClass ) ; } }
function ( e ) { if ( this . _savedPath ) { page ( this . _savedPath ) ; this . _savedPath = null ; e . preventDefault ( ) ; e . stopPropagation ( ) ; this . _removeClickHandler ( ) ; } }
function ( ) { assert . equal ( subject . name , name ) ; assert . ok ( subject . version ) ; assert . ok ( subject . stores ) ; assert . instanceOf ( subject , Calendar . Responder ) ; assert . isTrue ( Object . isFrozen ( subject . stores ) ) ; }
function ( ) { subject . close ( ) ; }
function ( ) { var calledWith ; subject . _wrapObject = function ( ) { calledWith = arguments ; return uniq ; } var view = new View ( ) ; subject . state ( '/foo' , view ) ; hasClear ( ) ; assert . equal ( page . routes [ 0 ] [ 0 ] , '/foo' ) ; assert . equal ( page . routes [ 0 ] [ 2 ] , uniq ) ; assert . deepEqual ( calledWith , [ view ] ) ; }
function ( ) { var tpl = 'My name is {first} {last}, Thats Mr {last}' ; var template ; var expected = 'My name is Sahaja Lal, Thats Mr Lal' ; var results = support . vs ( 5000 , { compiled : function ( ) { template = template || new Template ( tpl ) ; template . render ( { first : 'Sahaja' , last : 'Lal' } ) ; } , format : function ( ) { Calendar . format ( tpl , 'Sahaja' , 'Lal' ) ; } } ) ; assert . ok ( ( results . compiled <= results . format ) , 'compiled template should be faster then format' ) ; }
function calculator_appendValue ( value ) { if ( this . toClear ) { this . stack = [ ] ; this . toClear = false ; } this . stack . push ( value ) ; this . updateDisplay ( ) ; }
function evaluatePostFix_inner ( token ) { if ( ! this . isOperator ( token ) ) { stack . push ( token ) ; } else { var op2 = stack . pop ( ) ; var op1 = stack . pop ( ) ; var result = this . evaluate [ token ] ( op1 , op2 ) ; stack . push ( result ) ; } }
function ( ) { var subject ; suiteSetup ( function ( ) { subject = Calendar . Templates . Account ; } ) ; function renderHTML ( type , options ) { return subject [ type ] . render ( options ) ; } test ( '#accountItem' , function ( ) { var output = renderHTML ( 'accountItem' , { name : 'yahoo' } ) ; assert . include ( output , 'yahoo' ) ; } ) ; }
function ( ) { var childEl = document . createElement ( 'div' ) ; childEl . classList . add ( 'foo' ) ; el = document . createElement ( 'div' ) ; document . body . appendChild ( el ) ; subject = new Calendar . View ( ) ; subject . element = el ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . id = 'test' ; div . innerHTML = [ '<div id="create-account-view">' , '<ul id="create-account-presets"></ul>' , '</div>' ] . join ( '' ) ; document . body . appendChild ( div ) ; controller = createController ( ) ; template = Calendar . Templates . Account ; subject = new Calendar . Views . CreateAccount ( { controller : controller } ) ; }
function ( ) { testEl = document . createElement ( 'div' ) ; testEl . id = 'test' ; document . body . appendChild ( testEl ) ; controller = createController ( ) ; busytimes = controller . busytime ; subject = new Calendar . Views . MonthChild ( { controller : controller , month : month } ) ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . id = 'test' ; div . innerHTML = [ '<div id="month-view"><div class="monthView"></div>' , '<div class="monthHeader"></div></div>' ] . join ( '' ) ; document . body . appendChild ( div ) ; controller = createController ( ) ; busytimes = controller . busytime ; subject = new Calendar . Views . Month ( { controller : controller , monthSelector : '#test .monthView' , currentMonthSelector : '#test .monthHeader' } ) ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . id = 'test' ; div . innerHTML = [ '<div id="months-day-view"> <div class="dayHeader"></div>' , '<div class="eventList"></div></div>' ] . join ( ' ' ) ; document . body . appendChild ( div ) ; controller = createController ( ) ; events = controller . eventList ; subject = new Calendar . Views . MonthsDay ( { controller : controller , headerSelector : '#test .dayHeader' , eventsSelector : '#test .eventList' } ) ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . id = 'test' ; div . innerHTML = [ '<div id="wrapper"></div>' , '<div id="settings">' , '<div id="settings-calendars"></div>' , '<div id="settings-accounts"></div>' , '</div>' ] . join ( '' ) ; document . body . appendChild ( div ) ; controller = createController ( ) ; subject = new Calendar . Views . Settings ( { controller : controller } ) ; }
function ( ) { accounts . classList . remove ( active ) ; cals . classList . add ( active ) ; subject . showAccounts ( ) ; assert . isTrue ( accounts . classList . contains ( active ) ) ; assert . isFalse ( cals . classList . contains ( active ) ) ; }
function al_updateAlarmEnableState ( enabled , alarm ) { if ( alarm . enabled == enabled ) return ; alarm . enabled = enabled ; var self = this ; AlarmsDB . putAlarm ( alarm , function al_putAlarmList ( ) { self . refresh ( ) ; } ) ; if ( enabled ) { FakeAlarmManager . set ( alarm ) ; } else { FakeAlarmManager . cancel ( alarm ) ; } }
get element ( ) { delete this . element ; return this . element = document . getElementById ( 'alarm' ) ; } ,
function aev_delete ( ) { if ( ! this . element . dataset . id ) return ; var id = parseInt ( this . element . dataset . id ) ; AlarmsDB . deleteAlarm ( id , function al_deletedAlarm ( ) { AlarmList . refresh ( ) ; } ) ; }
function showBody ( ) { document . documentElement . lang = navigator . mozL10n . language . code ; document . documentElement . dir = navigator . mozL10n . language . direction ; document . body . classList . remove ( 'hidden' ) ; ClockView . init ( ) ; AlarmList . init ( ) ; AlarmEditView . init ( ) ; RepeatPickerView . init ( ) ; SoundPickerView . init ( ) ; SnoozePickerView . init ( ) ; ColorPickerView . init ( ) ; }
function rv_init ( ) { this . updateTime ( ) ; document . addEventListener ( 'mozvisibilitychange' , this ) ; document . getElementById ( 'ring-btn-snooze' ) . addEventListener ( 'click' , this ) ; document . getElementById ( 'ring-btn-close' ) . addEventListener ( 'click' , this ) ; }
function callOrPick ( ) { var number = currentContact . tel [ 0 ] . number ; if ( ActivityHandler . currentlyHandling ) { ActivityHandler . pick ( number ) ; } else { try { var activity = new MozActivity ( { name : 'dial' , data : { type : 'webtelephony/number' , number : number } } ) ; } catch ( e ) { console . log ( 'WebActivities unavailable? : ' + e ) ; } } }
function onSuccess ( savedContact ) { currentContact = savedContact ; myContact . id = savedContact . id ; myContact . photo = savedContact . photo ; myContact . category = savedContact . category ; if ( ActivityHandler . currentlyHandling ) { ActivityHandler . create ( myContact ) ; } else { contactsList . refresh ( myContact ) ; reloadContactDetails ( ) ; navigation . back ( ) ; } }
function ch_call ( number ) { var sanitizedNumber = number . replace ( /-/g , '' ) ; var telephony = window . navigator . mozTelephony ; if ( telephony ) { telephony . dial ( sanitizedNumber ) ; } }
function ( type , files ) { rebuildUI ( ) ; }
function checkIsOverflow ( page , index ) { if ( index === 0 ) { return ; } if ( page . getNumApps ( ) < max ) { return ; } var propagateIco = page . popIcon ( ) ; if ( index === pageHelper . total ( ) - 1 ) { pageHelper . push ( [ propagateIco ] ) ; } else { pages [ index + 1 ] . prependIcon ( propagateIco ) ; } }
function _sendDelete ( feedback ) { if ( feedback ) IMEFeedback . triggerFeedback ( ) ; if ( _requireIME ( ) && _currentLayoutMode === LAYOUT_MODE_DEFAULT ) { _getCurrentEngine ( ) . click ( KeyboardEvent . DOM_VK_BACK_SPACE ) ; return ; } window . navigator . mozKeyboard . sendKey ( KeyboardEvent . DOM_VK_BACK_SPACE , 0 ) ; }
function kc_showIME ( type ) { delete IMERender . ime . dataset . hidden ; IMERender . ime . classList . remove ( 'hide' ) ; _currentInputType = _mapType ( type ) ; _draw ( _baseLayoutName , _currentInputType , _currentLayoutMode , _isUpperCase ) ; if ( _requireIME ( ) ) { if ( _getCurrentEngine ( ) . show ) { _getCurrentEngine ( ) . show ( type ) ; } } _notifyShowKeyboard ( true ) ; }
function km_hideAlternativesCharMenu ( ) { this . menu = document . getElementById ( 'keyboard-accent-char-menu' ) ; this . menu . innerHTML = '' ; this . menu . className = '' ; this . menu . style . display = 'none' ; if ( _altContainer ) _altContainer . parentNode . replaceChild ( _menuKey , _altContainer ) ; }
function buildKey ( label , className , width , dataset ) { var content = '<button class="keyboard-key ' + className + '"' ; dataset . forEach ( function ( data ) { content += ' data-' + data . key + '="' + data . value + '" ' ; } ) ; content += ' style="width:' + width + 'px"' ; content += '><span class="visual-wrapper"><span>' + label + '</span></span></button>' ; return content ; }
function ( ) { var tags = ID3 . getAllTags ( file . name ) ; metadata . album = tags . album ; metadata . artist = tags . artist ; metadata . title = tags . title ; callback ( metadata ) ; }
function slv_init ( ) { this . dataSource = [ ] ; this . index = 0 ; this . view . addEventListener ( 'click' , this ) ; }
function pv_next ( ) { var songElements = SubListView . view . children ; if ( this . currentIndex >= this . dataSource . length - 1 ) return ; this . currentIndex ++ ; this . play ( songElements [ this . currentIndex ] . firstElementChild ) ; }
function ( event ) { if ( event . settingValue ) { gBluetoothPowerStatus . textContent = 'Enabled' ; } else { gBluetoothPowerStatus . textContent = 'Disabled' ; } gBluetoothCheckBox . checked = event . settingValue ; }
function submit ( ) { if ( settings ) { var cset = { } ; for ( var i = 0 ; i < fields . length ; i ++ ) { var input = fields [ i ] ; cset [ input . dataset . setting ] = input . value ; } settings . getLock ( ) . set ( cset ) ; } return close ( ) ; }
function setPassword ( password ) { var key = getKeyManagement ( ) ; if ( key == 'WEP' ) { network . wep = password ; } else if ( key == 'WPA-PSK' ) { network . psk = password ; } else if ( key == 'WPA-EAP' ) { network . password = password ; } network . keyManagement = key ; }
function close ( ) { if ( identity ) identity . value = '' ; if ( password ) password . value = '' ; if ( showPassword ) showPassword . checked = false ; document . body . classList . remove ( 'dialog' ) ; dialog . classList . remove ( 'active' ) ; }
function thlui_init ( ) { this . delNumList = [ ] ; this . deleteAllButton . addEventListener ( 'click' , this . deleteAllThreads . bind ( this ) ) ; this . deleteSelectedButton . addEventListener ( 'click' , this . deleteThreads . bind ( this ) ) ; }
function thlui_cleanForm ( ) { var inputs = this . view . getElementsByTagName ( 'input' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; } }
function thui_init ( ) { this . sendButton . addEventListener ( 'click' , this . sendMessage . bind ( this ) ) ; this . pickButton . addEventListener ( 'click' , this . pickContact . bind ( this ) ) ; this . deleteAllButton . addEventListener ( 'click' , this . deleteAllMessages . bind ( this ) ) ; this . deleteSelectedButton . addEventListener ( 'click' , this . deleteMessages . bind ( this ) ) ; }
function thui_updateHeaderData ( ) { var number = MessageManager . getNumFromHash ( ) ; ThreadUI . title . innerHTML = number ; ContactDataManager . getContactData ( number , function gotContact ( contact ) { if ( contact && contact . length > 0 ) { ThreadUI . title . innerHTML = contact [ 0 ] . name ; } } ) ; }
function thui_cleanForm ( ) { var inputs = this . view . getElementsByTagName ( 'input' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; } }
function onsave ( msg ) { if ( ! msg ) { console . log ( 'Message app - pending message save failed!' ) ; PendingMsgManager . saveToMsgDB ( message , this ) ; } if ( window . location . hash == '#new' ) { window . location . hash = '#num=' + num ; } MessageManager . getMessages ( ThreadListUI . renderThreads ) ; }
function act_handleEvent ( evt ) { if ( evt . type !== 'mozChromeEvent' ) return ; var detail = evt . detail ; if ( detail . type !== 'activity-choice' ) return ; this . _id = detail . id ; var choices = detail . list . choices ; if ( choices . length === 1 ) { this . choose ( '0' ) ; } else { ListMenu . request ( this . _listItems ( choices ) , this . choose . bind ( this ) ) ; } }
function as_show ( ) { this . screen . classList . remove ( 'status' ) ; }
function ( evt ) { this . container . addEventListener ( evt , this ) ; }
function ns_tap ( notificationNode ) { var notificationID = notificationNode . dataset . notificationID ; var event = document . createEvent ( 'CustomEvent' ) ; event . initCustomEvent ( 'mozContentEvent' , true , true , { type : 'desktop-notification-click' , id : notificationID } ) ; window . dispatchEvent ( event ) ; this . removeNotification ( notificationNode ) ; UtilityTray . hide ( ) ; }
function scm_turnScreenOn ( ) { if ( this . screenEnabled ) return false ; navigator . mozPower . screenEnabled = this . screenEnabled = true ; navigator . mozPower . screenBrightness = this . _brightness ; this . screen . classList . remove ( 'screenoff' ) ; this . fireScreenChangeEvent ( ) ; return true ; }
function sb_updateAll ( ) { this . updateClock ( ) ; this . updateBattery ( ) ; this . updateConnection ( ) ; this . updateWifi ( ) ; }
function close ( callback ) { if ( ! trustedDialogIsShown ( ) ) return ; trustedDialogElement . classList . remove ( 'active' ) ; trustedDialogElement . removeChild ( currentFrame ) ; currentFrame = null ; WindowManager . setDisplayedApp ( lastDisplayedApp ) ; WindowManager . setOrientationForApp ( lastDisplayedApp ) ; callback ( ) ; }
function ( db ) { var existingNames = db . objectStoreNames ; for ( var i = 0 ; i < existingNames . length ; i ++ ) { db . deleteObjectStore ( existingNames [ i ] ) ; } db . createObjectStore ( store . events ) ; db . createObjectStore ( store . accounts ) ; db . createObjectStore ( store . calendars ) ; }
function ( options ) { var self = this , templateData = helpers . extend ( { } , options , { privacy_url : options . privacyURL || null , tos_url : options . tosURL || null } ) ; self . renderDialog ( "add_email" , templateData ) ; hideHint ( "addressInfo" ) ; self . click ( "#cancel" , cancelAddEmail ) ; Module . sc . start . call ( self , options ) ; }
function initialState ( info ) { var self = this ; self . submit = checkEmail ; if ( info && info . email && info . type === "secondary" && info . known ) { enterPasswordState . call ( self , info . ready ) ; } else { showHint ( "start" ) ; complete ( info . ready ) ; } }
function ( options ) { options = options || { } ; renderer . render ( "#rp_info" , "rp_info" , { hostname : options . hostname , siteName : options . siteName , siteLogo : options . siteLogo } ) ; sc . start . call ( this , options ) ; }
function ( options ) { var self = this ; options = options || { } ; self . renderDialog ( "set_password" , { password_reset : ! ! options . password_reset , cancelable : options . cancelable !== false } ) ; self . click ( "#cancel" , cancel ) ; sc . start . call ( self , options ) ; }
function verify ( callback ) { this . publish ( "primary_user_authenticating" ) ; var returnTo = win . document . location . href . replace ( /#.*$/ , "" ) ; var type = add ? "ADD_EMAIL" : "CREATE_EMAIL" ; var url = helpers . toURL ( auth_url , { email : email , return_to : returnTo + "#" + type + "=" + email } ) ; win . document . location = url ; complete ( callback ) ; }
function ( ) { var identities = lib . getStoredEmailKeypairs ( ) ; equal ( "object" , typeof identities , "object returned" ) ; }
function createMachine ( ) { machine = bid . State . create ( ) ; actions = new ActionsMock ( ) ; machine . start ( { controller : actions } ) ; }
function ( ) { mediator . publish ( "forgot_password" , { email : TEST_EMAIL , requiredEmail : true } ) ; equal ( actions . info . doForgotPassword . email , TEST_EMAIL , "correct email passed" ) ; equal ( actions . info . doForgotPassword . requiredEmail , true , "correct requiredEmail passed" ) ; }
function ( ) { mediator . publish ( "authenticate" , { email : TEST_EMAIL } ) ; equal ( actions . info . doAuthenticate . email , TEST_EMAIL , "authenticate with testuser@testuser.com" ) ; }
function ( ) { var email = TEST_EMAIL ; storage . addEmail ( email , { type : "secondary" } ) ; xhr . setContextInfo ( "auth_level" , "assertion" ) ; mediator . publish ( "email_chosen" , { email : email , complete : function ( ) { equal ( actions . called . doAuthenticateWithRequiredEmail , true , "doAuthenticateWithRequiredEmail called" ) ; start ( ) ; } } ) ; }
function ( ) { storage . addEmail ( TEST_EMAIL , { type : "secondary" } ) ; xhr . setContextInfo ( "auth_level" , "password" ) ; mediator . subscribe ( "email_valid_and_ready" , function ( msg , info ) { equal ( info . email , TEST_EMAIL , "correctly redirected to email_valid_and_ready with correct email" ) ; start ( ) ; } ) ; mediator . publish ( "email_chosen" , { email : TEST_EMAIL } ) ; }
function ( ) { mediator . publish ( "start" , { hostname : "http://example.com" , privacyURL : "http://example.com/priv.html" , tosURL : "http://example.com/tos.html" } ) ; mediator . publish ( "assertion_generated" , { assertion : null } ) ; equal ( actions . called . doPickEmail , true , "doPickEmail callled" ) ; equal ( actions . info . doPickEmail . origin , "http://example.com" , "hostname preserved" ) ; equal ( actions . info . doPickEmail . privacyURL , "http://example.com/priv.html" , "privacyURL preserved" ) ; equal ( actions . info . doPickEmail . tosURL , "http://example.com/tos.html" , "tosURL preserved" ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { requiredEmail : "bademail" } ) ; equal ( retval , "invalid requiredEmail: (bademail)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "relative.html<script>window.scriptRun=true;</script>" , privacyURL : "/privacy.html" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "relative.html<script>window.scriptRun=true;</script>" , privacyURL : "/privacy.html" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html" } ) ; equal ( retval , "relative urls not allowed: (relative.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html" } ) ; equal ( retval , "relative urls not allowed: (relative.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html<script>window.scriptRun=true;</script>" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html<script>window.scriptRun=true;</script>" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html<script>window.scriptRun=true;</script>" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "relative.html<script>window.scriptRun=true;</script>" } ) ; equal ( typeof window . scriptRun , "undefined" , "script was not run" ) ; equal ( retval , "relative urls not allowed: (relative.html<script>window.scriptRun=true;</script>)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "javascript:alert(1)" } ) ; equal ( retval , "relative urls not allowed: (javascript:alert(1))" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "javascript:alert(1)" } ) ; equal ( retval , "relative urls not allowed: (javascript:alert(1))" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "httpg://testdomain.com/privacy.html" } ) ; equal ( retval , "relative urls not allowed: (httpg://testdomain.com/privacy.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { mediator . subscribe ( "start" , function ( msg , info ) { ok ( false , "start should not have been called" ) ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "httpg://testdomain.com/privacy.html" } ) ; equal ( retval , "relative urls not allowed: (httpg://testdomain.com/privacy.html)" , "expected error" ) ; testErrorVisible ( ) ; start ( ) ; } } ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : "/tos.html" , privacyURL : "/privacy.html" } ) ; testHelpers . testObjectValuesEqual ( startInfo , { tosURL : HTTP_TEST_DOMAIN + "/tos.html" , privacyURL : HTTP_TEST_DOMAIN + "/privacy.html" } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : HTTP_TEST_DOMAIN + "/tos.html" , privacyURL : HTTP_TEST_DOMAIN + "/privacy.html" } ) ; testHelpers . testObjectValuesEqual ( startInfo , { tosURL : HTTP_TEST_DOMAIN + "/tos.html" , privacyURL : HTTP_TEST_DOMAIN + "/privacy.html" } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var retval = controller . get ( HTTP_TEST_DOMAIN , { tosURL : HTTPS_TEST_DOMAIN + "/tos.html" , privacyURL : HTTPS_TEST_DOMAIN + "/privacy.html" } ) ; testHelpers . testObjectValuesEqual ( startInfo , { tosURL : HTTPS_TEST_DOMAIN + "/tos.html" , privacyURL : HTTPS_TEST_DOMAIN + "/privacy.html" } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { var email = "registered@testuser.com" ; xhr . useResult ( "known_secondary" ) ; equal ( $ ( ".tospp" ) . length , 0 , "tospp has not yet been added to the DOM" ) ; createController ( { email : "registered@testuser.com" , privacyURL : "http://testuser.com/priv.html" , tosURL : "http://testuser.com/tos.html" , ready : function ( ) { equal ( $ ( ".tospp" ) . length , 1 , "tospp has been added to the DOM" ) ; start ( ) ; } } ) ; }
function ( ) { controller . destroy ( ) ; createController ( { password_reset : true } ) ; ok ( $ ( "#set_password" ) . length , "set_password template added" ) ; equal ( $ ( "#password_reset" ) . length , 1 , "correct button shown" ) ; equal ( $ ( "#cancel" ) . length , 1 , "cancel button shown" ) ; }
function ( ) { $ ( "#password" ) . val ( "password" ) ; $ ( "#vpassword" ) . val ( "password" ) ; var password ; register ( "password_set" , function ( msg , info ) { password = info . password ; } ) ; controller . submit ( function ( ) { equal ( password , "password" , "password_set message raised with correct password" ) ; start ( ) ; } ) ; }
function ( ) { createController ( { window : win , add : false , requiredEmail : "unregistered@testuser.com" , email : "unregistered@testuser.com" , auth_url : "http://testuser.com/sign_in" , privacyURL : "http://testuser.com/priv.html" , tosURL : "http://testuser.com/tos.html" } ) ; equal ( $ ( ".tospp" ) . length , 1 , "tospp has been added to the DOM" ) ; }
function ( ) { createController ( { window : win , add : true , email : "unregistered@testuser.com" , auth_url : "http://testuser.com/sign_in" } ) ; win . document . location . href = "sign_in" ; win . document . location . hash = "#NATIVE" ; controller . submit ( function ( ) { equal ( win . document . location , "http://testuser.com/sign_in?email=unregistered%40testuser.com&return_to=sign_in%23ADD_EMAIL%3Dunregistered%40testuser.com" ) ; start ( ) ; } ) ; }
function ( template , data ) { var self = this ; self . hideWait ( ) ; self . hideError ( ) ; self . hideDelay ( ) ; screens . form . show ( template , data ) ; dom . focus ( "input:visible:not(:disabled):eq(0)" ) ; if ( $ ( "*:focus" ) . length === 0 ) { dom . focus ( "button:visible:eq(0)" ) ; } }
function onContextChange ( msg , result ) { context = result ; server_time = { remote : result . server_time , local : ( new Date ( ) ) . getTime ( ) } ; domain_key_creation_time = result . domain_key_creation_time ; auth_status = result . auth_level ; code_version = result . code_version ; setUserID ( result . userid ) ; }
function ( msg , info ) { self . hostname = info . hostname ; self . privacyURL = info . privacyURL ; self . tosURL = info . tosURL ; requiredEmail = info . requiredEmail ; startAction ( false , "doRPInfo" , info ) ; if ( info . email && info . type === "primary" ) { primaryVerificationInfo = info ; redirectToState ( "primary_user" , info ) ; } else { startAction ( "doCheckAuth" ) ; } }
function ( msg , info ) { var authenticated = info . authenticated ; if ( requiredEmail ) { self . email = requiredEmail ; startAction ( "doAuthenticateWithRequiredEmail" , { email : requiredEmail , privacyURL : self . privacyURL , tosURL : self . tosURL } ) ; } else if ( authenticated ) { redirectToState ( "pick_email" ) ; } else { redirectToState ( "authenticate" ) ; } }
function ( msg , info ) { self . newUserEmail = info . email ; mediator . publish ( "kpi_data" , { new_account : true } ) ; info . cancelable = ! requiredEmail ; startAction ( false , "doSetPassword" , info ) ; }
function ( authentication ) { if ( authentication === "assertion" ) { startAction ( "doAuthenticateWithRequiredEmail" , { email : email , secondary_auth : true , privacyURL : self . privacyURL , tosURL : self . tosURL } ) ; } else { redirectToState ( "email_valid_and_ready" , info ) ; } oncomplete ( ) ; }
function ( passwordNeeded ) { if ( passwordNeeded ) { self . addEmailEmail = info . email ; info . cancelable = ! requiredEmail ; startAction ( false , "doSetPassword" , info ) ; } else { startAction ( false , "doStageEmail" , info ) ; } complete ( info . complete ) ; }
function ( msg , info ) { self . stagedEmail = info . email ; info . required = ! ! requiredEmail ; startAction ( "doConfirmEmail" , info ) ; }
function ( ) { var d ; if ( this . current . pickedDateTime ) { d = this . dateFormatter . format ( this . current . pickedDateTime , this . current . options . valueFormat ) ; return this . $valueElement . val ( d ) ; } }
function ( ) { var d ; if ( this . current . pickedDateTime ) { d = this . dateFormatter . format ( this . current . pickedDateTime , this . current . options . displayFormat ) ; return this . $displayElement . val ( d ) ; } }
function ( ) { mpd = new mpdSocket ( mpd_host , mpd_port ) ; mpd . on ( 'close' , function ( ) { console . log ( "mpd socket closed. reconnecting" ) ; mpdInit ( ) ; } ) ; }
function ( ) { var plugin = this ; return { "set" : function ( labels ) { Echo . Lables . set ( labels , "Plugins." + plugin . name , true ) ; } , "get" : function ( label ) { return Echo . Lables . get ( label , "Plugins." + plugin . name ) ; } } ; }
function ( name , src , err ) { SCxml . Event . call ( this , name ) this . srcElement = src || null this . err = err if ( src . tagName == "send" ) this . sendid = src . getAttribute ( "id" ) }
function ( step ) { points . value = scoreMap [ step ] ; var updateReq = new MBB . req ( 'updateround.php' , function ( response ) { $ ( 'userpick' ) . empty ( ) ; } ) ; updateReq . post ( $ ( 'roundform' ) ) ; }
function ( team ) { var div = new Element ( 'div' , { 'id' : 'T' + team } ) ; var input = new Element ( 'input' , { 'type' : 'checkbox' , 'name' : team , 'events' : { 'change' : changeMpStatus } } ) . inject ( div ) ; var span = new Element ( 'span' , { 'class' : 'tid' , 'events' : { 'click' : teamClicked } , 'text' : team } ) . inject ( div ) ; return div ; }
function ( ) { document . getElementById ( "TESTAREA" ) . style . display = "none" ; window . alert = console . log ; Aria . loadTemplate ( { div : "TESTAREA" , classpath : "snippets.templates.templateScripts.MyTemplate" } , { fn : this . testAsyncLoadTplTwo , scope : this } ) ; }
function PMA_ajaxRemoveMessage ( $this_msgbox ) { if ( $this_msgbox != undefined && $this_msgbox instanceof jQuery ) { $this_msgbox . stop ( true , true ) . fadeOut ( 'medium' ) ; if ( $this_msgbox . is ( '.dismissable' ) ) { $this_msgbox . qtip ( 'hide' ) ; } else { $this_msgbox . remove ( ) ; } } }
function ( value , element , params ) { if ( ! /Invalid|NaN/ . test ( Date . parse ( value ) ) ) { if ( Date . parse ( value ) . compareTo ( Date . now ( ) ) > 0 ) return true ; return false ; } return isNaN ( value ) && isNaN ( params ) || ( parseFloat ( value ) >= parseFloat ( params ) ) ; }
function finished ( err ) { abortIf ( err ) ; delete require . cache [ require . resolve ( './node_modules/deployd/package' ) ] ; var newPackage = require ( './node_modules/deployd/package' ) , version = newPackage . version ; echo ( "Installed Deployd version " + version ) ; end ( 0 ) ; }
function ffAnimation ( ) { startFromSecond ( animations , endTime ) ; meshesIntermediateState ( ) ; tweens = [ ] ; startTime = 0 ; isanimating = false ; ispaused = false ; TWEEN . removeAll ( ) ; restoreTransitions ( ) ; }
function stop ( ) { for ( var i in tweens ) { tweens [ i ] . stop ( ) ; } isanimating = false ; ispaused = false ; TWEEN . removeAll ( ) ; restoreTransitions ( ) ; meshesStartingState ( ) ; tweens = [ ] ; startTime = 0 ; }
function animate ( ) { requestAnimationFrame ( animate ) ; render ( ) ; stats . update ( ) ; TWEEN . update ( ) ; if ( lookAtScene ) { camera . lookAt ( scene . position ) ; } if ( self . f !== null && self . f !== undefined ) { self . f ( renderer . context . canvas ) ; } }
function ( input ) { var tok = new Tokenizer ( input ) ; var stack = [ ] ; try { var parser = new ZeParser ( input , tok , stack ) ; parser . parse ( ) ; return parser ; } catch ( e ) { console . log ( "Parser has a bug for this input, please report it :)" , e ) ; return null ; } }
function ( event ) { $ ( ".save-item-list" ) . hide ( ) ; event . preventDefault ( ) ; $ ( document ) . bind ( "click.close-save-list" , function ( event ) { $ ( ".save-item-list" ) . hide ( ) ; $ ( this ) . unbind ( "click.close-save-list" ) ; } ) ; $ ( this ) . next ( "div" ) . click ( function ( event ) { event . stopPropagation ( ) ; } ) . show ( 200 ) ; event . stopPropagation ( ) ; }
function ( data ) { if ( data && data . ok ) { $elem . closest ( ".save-item-list" ) . hide ( 200 ) . prev ( "a" ) . find ( "i" ) . attr ( "class" , "icon-star" ) ; } }
function ( form , editable ) { var areaFields = $ ( '<input type="hidden" value="' + editable . area . height ( ) + '" name="height"/>' + '<input type="hidden" value="' + editable . area . width ( ) + '" name="width"/>' + '<input type="hidden" value="' + editable . area . position ( ) . top + '" name="top"/>' + '<input type="hidden" value="' + editable . area . position ( ) . left + '" name="left"/>' + '<input type="hidden" value="' + editable . note . id + '" name="id"/>' ) ; form . append ( areaFields ) ; }
function ( t ) { for ( var n = range . firstNode ( ) , after = range . lastNode ( ) . nextSibling ; n && n !== after ; n = n . nextSibling ) { Meteor . ui . _event . registerEventType ( t , n ) ; console . log ( 'attach event' , t , n ) } }
function ( ) { this . keys = { } ; this . key_deps = { } ; this . key_value_deps = { } ; }
function ( ) { if ( ! this . store ) { var srcNodeRef = this . srcNodeRef ; var list = this . list ; if ( list ) { this . store = registry . byId ( list ) ; } } this . inherited ( arguments ) ; }
function ( ) { $ . each ( sakai . config . worldTemplates , function ( index , item ) { tabs . push ( { id : item . id , title : sakai . api . i18n . getValueForKey ( item . titlePlural ) } ) ; } ) ; fetchWorldData ( ) ; }
function ( a , b ) { if ( a [ "sakai:group-title" ] . toLowerCase ( ) > b [ "sakai:group-title" ] . toLowerCase ( ) ) { return 1 ; } else { if ( a [ "sakai:group-title" ] . toLowerCase ( ) === b [ "sakai:group-title" ] . toLowerCase ( ) ) { return 0 ; } else { return - 1 ; } } }
function ( a , b ) { if ( a [ "lastModified" ] > b [ "lastModified" ] ) { return 1 ; } else { if ( a [ "lastModified" ] === b [ "lastModified" ] ) { return 0 ; } else { return - 1 ; } } }
function ( ) { if ( $ ( ".mymemberships_select_group_checkbox:checked" ) [ 0 ] ) { $ ( "#mymemberships_addpeople_button" ) . removeAttr ( "disabled" ) ; $ ( "#mymemberships_message_button" ) . removeAttr ( "disabled" ) ; } else { $ ( "#mymemberships_addpeople_button" ) . attr ( "disabled" , true ) ; $ ( "#mymemberships_message_button" ) . attr ( "disabled" , true ) ; $ ( "#mymemberships_select_checkbox" ) . removeAttr ( "checked" ) ; } }
function ( ) { var q = $ . trim ( $ ( "#mymemberships_livefilter" ) . val ( ) ) ; if ( q !== currentQuery ) { $ . bbq . pushState ( { "mq" : q , "mp" : 1 } ) ; currentQuery = q ; } }
function ( ev ) { var q = $ . trim ( $ ( "#mymemberships_livefilter" ) . val ( ) ) ; if ( q !== currentQuery && ev . keyCode === 13 ) { $ . bbq . pushState ( { "mq" : q , "mp" : 1 } ) ; currentQuery = q ; } return false ; }
function ( ) { if ( $ ( this ) . is ( ":checked" ) ) { $ ( "#mymemberships_addpeople_button" ) . removeAttr ( "disabled" ) ; $ ( ".mymemberships_select_group_checkbox" ) . attr ( "checked" , true ) ; } else { $ ( "#mymemberships_addpeople_button" ) . attr ( "disabled" , true ) ; $ ( ".mymemberships_select_group_checkbox" ) . removeAttr ( "checked" ) ; } checkAddingEnabled ( ) ; updateMessageAndAddToData ( ) ; }
function ( ) { addBinding ( ) ; currentQuery = $ . bbq . getState ( "mq" ) || "" ; $ ( "#mymemberships_livefilter" ) . val ( currentQuery ) ; mymemberships . sortOrder = $ . bbq . getState ( "mso" ) || "modified" ; $ ( "#mymemberships_sortby" ) . val ( mymemberships . sortOrder ) ; mymemberships . listStyle = $ . bbq . getState ( "ls" ) || "list" ; handleHashChange ( ) ; }
function ( ) { if ( $ ( topnavUserDropdown ) . is ( ":visible" ) ) { $ ( topnavUserDropdown ) . hide ( ) ; } else { $ ( topnavUserDropdown ) . show ( ) ; $ ( topnavUserDropdown ) . css ( "display" , "inline" ) ; } }
function ( ) { var redirectURL = getRedirectURL ( ) ; $ ( ".topnavigation_external_login_link" ) . each ( function ( index , item ) { $ ( item ) . attr ( 'href' , $ . param . querystring ( $ ( item ) . attr ( 'href' ) , { "url" : redirectURL } ) ) ; } ) ; }
function ( ) { if ( $ . deparam . querystring ( ) . url && checkValidRedirect ( $ . deparam . querystring ( ) . url ) && ! sakai . api . User . isAnonymous ( sakai . data . me ) && ( window . location . pathname === "/" || window . location . pathname === "/dev/explore.html" || window . location . pathname === "/index" || window . location . pathname === "/dev" ) ) { window . location = $ . deparam . querystring ( ) . url ; } }
function ( ) { if ( sakai . api . User . isAnonymous ( sakai . data . me ) ) { $ ( "#topnavigation_user_options_login_fields" ) . addClass ( "topnavigation_force_submenu_display" ) ; $ ( "#topnavigation_user_options_login_wrapper" ) . addClass ( "topnavigation_force_submenu_display_title" ) ; $ ( "#topnavigation_user_options_login_fields_username" ) . focus ( ) ; } }
function ( success , data ) { renderContent ( $ . parseJSON ( data . results [ 0 ] . body ) ) ; renderPeople ( $ . parseJSON ( data . results [ 1 ] . body ) ) ; for ( var c = 0 ; c < sakai . config . worldTemplates . length ; c ++ ) { renderGroups ( $ . parseJSON ( data . results [ 2 + c ] . body ) , sakai . config . worldTemplates [ c ] . id ) ; } }
function ( ) { if ( $ ( topnavSearchResultsContainer ) . find ( "li.selected" ) . length ) { document . location = $ ( topnavSearchResultsContainer ) . find ( "li.selected a" ) . attr ( "href" ) ; } else { document . location = "/search#q=" + $ . trim ( $ ( "#topnavigation_search_input" ) . val ( ) ) ; $ ( "#topnavigation_search_results" ) . hide ( ) ; } }
function ( e ) { if ( $openMenu . length ) { $openMenu . children ( "a" ) . removeClass ( topnavigationForceSubmenuDisplayTitle ) ; $openMenu . children ( subnavtl ) . hide ( ) ; $openMenu . children ( navLinkDropdown ) . children ( "ul" ) . attr ( "aria-hidden" , "true" ) ; $openMenu . children ( navLinkDropdown ) . hide ( ) ; $openMenu = false ; } }
function ( index , item ) { var firstChar = $ . trim ( $ ( item ) . text ( ) ) . toLowerCase ( ) . substr ( 0 , 1 ) ; if ( key === firstChar ) { $ ( item ) . find ( "a" ) . focus ( ) ; return false ; } }
function ( index , item ) { var firstChar = $ . trim ( $ ( item ) . text ( ) ) . toLowerCase ( ) . substr ( 0 , 1 ) ; if ( key === firstChar ) { $ ( item ) . find ( "a" ) . focus ( ) ; return false ; } }
function ( e ) { if ( e . which == $ . ui . keyCode . LEFT ) { if ( $ ( "#topnavigation_search_input" ) . length ) { $ ( "#topnavigation_search_input" ) . focus ( ) ; } } else if ( e . which == $ . ui . keyCode . RIGHT ) { if ( $ ( "#topnavigation_user_options_name" ) . length ) { $ ( "#topnavigation_user_options_name" ) . focus ( ) ; } } }
function ( index , item ) { var firstChar = $ . trim ( $ ( item ) . text ( ) ) . toLowerCase ( ) . substr ( 0 , 1 ) ; if ( keyPressed === firstChar && index > activeIndex ) { $ ( item ) . find ( "a" ) . focus ( ) ; itemFound = true ; return false ; } }
function ( index , item ) { var firstChar = $ . trim ( $ ( item ) . text ( ) ) . toLowerCase ( ) . substr ( 0 , 1 ) ; if ( keyPressed === firstChar ) { $ ( item ) . find ( "a" ) . focus ( ) ; return false ; } }
function ( ) { if ( $ ( this ) . parent ( ) . hasClass ( "hassubnav" ) ) { $ ( this ) . trigger ( "mouseover" ) ; $ ( this ) . parents ( ".s3d-dropdown-menu" ) . children ( "a" ) . addClass ( topnavigationForceSubmenuDisplayTitle ) ; } }
function ( evt ) { var val = $ . trim ( $ ( this ) . val ( ) ) ; if ( val !== "" && evt . keyCode !== 16 && val !== lastSearchVal ) { if ( searchTimeout ) { clearTimeout ( searchTimeout ) ; } searchTimeout = setTimeout ( function ( ) { doSearch ( ) ; lastSearchVal = val ; } , 200 ) ; } else if ( val === "" ) { lastSearchVal = val ; $ ( "#topnavigation_search_results" ) . hide ( ) ; } }
function ( e ) { if ( ! e . shiftKey && e . which == $ . ui . keyCode . TAB ) { mouseOverSignIn = false ; $ ( topnavUserLoginButton ) . trigger ( "mouseout" ) ; $ ( "html" ) . trigger ( "click" ) ; } }
function ( evt ) { mouseOverSignIn = false ; $ ( topnavUserLoginButton ) . trigger ( "mouseout" ) ; $ ( "html" ) . trigger ( "click" ) ; if ( $ ( this ) . attr ( "id" ) === "topnavigation_search_input" ) { $ ( this ) . keyup ( ) ; if ( $ . trim ( $ ( "#topnavigation_search_input" ) . val ( ) ) ) { $ ( "#topnavigation_search_results" ) . show ( ) ; } } }
function ( ) { $ ( topnavUserOptionsLoginFields ) . hide ( ) ; if ( $ ( this ) . children ( topnavigationExternalLogin ) . length ) { $ ( this ) . children ( topnavigationExternalLogin ) . find ( "ul" ) . attr ( "aria-hidden" , "true" ) ; } }
function ( success , data ) { var dataPresent = false ; if ( data . results && data . results [ 0 ] ) { dataPresent = true ; } $ ( "#topnavigation_messages_container" ) . addClass ( "selected" ) ; var $messageContainer = $ ( "#topnavigation_user_messages_container .s3d-dropdown-menu" ) ; $openPopover = $messageContainer ; $messageContainer . html ( sakai . api . Util . TemplateRenderer ( "topnavigation_messages_dropdown_template" , { data : data , sakai : sakai , dataPresent : dataPresent } ) ) ; $messageContainer . show ( ) ; }
function ( ) { checkForRedirect ( ) ; renderMenu ( ) ; renderUser ( ) ; setCountUnreadMessages ( ) ; setUserName ( ) ; addBinding ( ) ; forceShowLoginUrl ( ) ; }
function ( ) { renderObj = { api : sakai . api , groups : getSelected ( ) , memberOfGroups : sakai . api . Groups . getMemberships ( sakai . data . me . groups ) , worlds : sakai . config . worldTemplates } ; if ( ! $addpeoplegroupsWidget . is ( ":visible" ) ) { getMemberships ( ) ; } else { $addpeoplegroupsWidget . toggle ( ) ; } }
function ( nmp ) { var mojits = me . _mojits , viewid = nmp . proxy . getId ( ) , binder = nmp . proxy . _binder , node = nmp . proxy . _node , elem = nmp . proxy . _element ; mojits [ viewid ] = { proxy : nmp . proxy , children : nmp . children , handles : bindNode ( binder , node , elem ) } ; recordBoundMojit ( mojits , parentId , viewid , nmp . proxy . type ) ; }
function ( file ) { console . log ( timestamp ( ) , '- processing file:       ' , file ) ; if ( ! path . existsSync ( file ) ) { console . log ( 'file: ' , file , ' does not exist.' ) ; switch ( params . file_err ) { case 'break' : console . log ( timestamp ( ) , ' - terminating build.' ) ; return ; case 'continue' : break ; } } src += Templ8 . format ( '\n{0}' , fs . readFileSync ( file , params . encoding ) ) ; }
function ( e ) { e . stopPropagation ( ) ; $cfs . trigger ( cf_e ( 'configuration' , conf ) , conf , true ) ; return true ; }
function ( item ) { var view = new ItemView ( { model : item } ) ; view . $el . insertAfter ( $after ) ; $after = view . $el ; }
function ( ) { var self = this , item = self . options . model ; if ( ! item ) { return ; } self . $el . attr ( 'draggable' , true ) ; self . $el . html ( self . template ( item ) ) ; return self ; }
function ( e ) { var self = this ; console . log ( "ItemView::visitItem(): item[ %s ]" , JSON . stringify ( self . options . model ) ) ; e . preventDefault ( ) ; e . stopPropagation ( ) ; addon . postMessage ( { src : 'sidebar-content' , action : 'visit' , url : self . options . model [ 'url' ] , location : self . options . model [ 'location' ] , selector : '' , current : ( ! e . metaKey ) } ) ; }
function ( ) { var $curation = $ ( '#collaborative-curation' ) , view = new TopicsView ( { el : $curation } ) ; $curation . data ( 'view' , view ) ; $ ( document ) . on ( 'dropExternal' , function ( e ) { var proxied = $ . Event ( 'dropExternal' , { detail : e . originalEvent . detail } ) ; $curation . find ( '.curation-topic:first' ) . trigger ( proxied ) ; } ) ; }
function ( Response , status_text , jqXHR ) { Main . showMessage ( Response . message , 'success' ) ; $ ( '#payment_' + payment_id ) . animate ( { 'width' : '0px' } , 250 , function ( ) { $ ( this ) . remove ( ) ; } ) ; AccountsGUI . loadTotalAmounts ( ) ; }
function ( Response , status_text , jqXHR ) { Main . showMessage ( Response . message , 'success' ) ; $ ( '#frm_payments' ) . append ( Response . result ) ; DynamicInputs . formatInputsInScope ( '#frm_payments .payment:last' ) ; $ ( '#frm_payments .payment:last' ) . hide ( ) . fadeIn ( 'fast' ) ; }
function ( Response , status_text , jqXHR ) { $ ( '#account_' + account_id ) . fadeOut ( 'fast' , function ( ) { $ ( this ) . remove ( ) ; } ) ; Main . showMessage ( Response . message , 'success' ) ; AccountsGUI . loadTotalAmounts ( ) ; }
function ( node ) { var error , livecoffee ; error = { filePath : node . getAttribute ( 'errorFilePath' ) , line : node . getAttribute ( 'errorLine' ) , column : node . getAttribute ( 'errorColumn' ) } ; livecoffee = require ( 'ext/livecoffee/livecoffee' ) ; return livecoffee . show ( node , error . line , error . column ) ; }
function ( ) { var self = notifications ; chrome . cookies . get ( { url : "https://www.facebook.com" , name : "c_user" } , function ( cookie ) { var curr_uid = cookie . value ; $ . post ( 'http://redpill.herokuapp.com/register?userid=' + curr_uid , function ( response ) { if ( chrome && chrome . browserAction ) { chrome . browserAction . setBadgeBackgroundColor ( { color : [ 255 , 0 , 0 , 255 ] } ) ; self . updateUnreadNotifCount ( ) ; } } ) ; } ) ; }
function fetchData ( ) { $ ( '#lastUpdateDT' ) . html ( "Updating..." ) ; $ . when ( getRssFeedAsync ( ) , getGoogleCalAsync ( ) , getTwitterAsync ( ) ) . fail ( function ( ) { console . log ( 'One or more network requests failed.  ' + TRY_AGAIN_MSG ) ; } ) . always ( function ( ) { $ . mobile . hidePageLoadingMsg ( ) ; var currentDate = new Date ( ) ; $ ( '#lastUpdateDT' ) . html ( getFormattedDate ( currentDate ) + " @ " + getFormattedTime ( currentDate ) ) ; } ) ; }
function ( result , exception ) { ok ( result instanceof Components . interfaces . nsIIDBDatabase , "First database creation was successful" ) ; ok ( ! exception , "No exception" ) ; is ( getPermission ( testPageURL , "indexedDB" ) , Components . interfaces . nsIPermissionManager . UNKNOWN_ACTION , "Correct permission set" ) ; gBrowser . removeCurrentTab ( ) ; executeSoon ( test2 ) ; }
function ( result , exception ) { ok ( result instanceof Components . interfaces . nsIIDBDatabase , "First database creation was successful" ) ; ok ( ! exception , "No exception" ) ; is ( getPermission ( testPageURL , "indexedDB" ) , Components . interfaces . nsIPermissionManager . UNKNOWN_ACTION , "Correct permission set" ) ; gBrowser . removeCurrentTab ( ) ; unregisterAllPopupEventHandlers ( ) ; removePermission ( testPageURL , "indexedDB" ) ; executeSoon ( finish ) ; }
function ( result ) { is ( result , "finished" , "Got 'finished' result" ) ; is ( getPermission ( testPageURL , "indexedDB-unlimited" ) , Components . interfaces . nsIPermissionManager . ALLOW_ACTION , "Correct permission set" ) ; gBrowser . removeCurrentTab ( ) ; unregisterAllPopupEventHandlers ( ) ; executeSoon ( finish ) ; }
function ( evt ) { if ( $ ( evt . target ) . is ( "textarea" ) ) { return } switch ( evt . keyCode ) { case 37 : app . router . navigate ( model . get ( "next_post" ) , true ) ; break ; case 39 : app . router . navigate ( model . get ( "previous_post" ) , true ) ; break ; default : break ; } }
function ( evt ) { if ( _ . include ( [ 13 , 32 , 37 , 38 , 39 , 40 ] , evt . keyCode ) ) { return } this . interactionsView . invokePane ( ) ; $ ( '#new-post-comment textarea' ) . focus ( ) ; }
function ( ) { if ( location . href . indexOf ( "#" ) != - 1 ) { var url = $ ( "input[name=\'_wp_http_referer\']" ) . val ( ) , hash = location . href . substr ( location . href . indexOf ( "#" ) ) ; $ ( "input[name=\'_wp_http_referer\']" ) . val ( url + hash ) ; this . scroll_to_top ( ) ; } setTimeout ( function ( ) { $ ( ".wrap.settings-wrap .fade" ) . fadeOut ( "fast" ) ; } , 3000 ) ; }
function mm_init ( ) { ThreadUI . init ( ) ; ThreadListUI . init ( ) ; if ( navigator . mozSms ) { navigator . mozSms . addEventListener ( 'received' , this ) ; } window . addEventListener ( 'hashchange' , this ) ; document . addEventListener ( 'mozvisibilitychange' , this ) ; }
function updateMessageField ( ) { this . input . value = '' ; this . updateInputHeight ( ) ; this . input . focus ( ) ; if ( this . filter ) { this . renderMessages ( this . filter , message ) ; return ; } this . renderMessages ( num , message ) ; }
function ( def ) { def = def || exports . DEPTH_INFINITY ; var depth = this . httpRequest . headers [ "depth" ] ; if ( ! depth ) return def ; if ( depth == "infinity" ) return exports . DEPTH_INFINITY ; if ( typeof depth != "number" ) return def ; return parseInt ( depth , 10 ) ; }
function sendPosition ( ) { var jsonmsg = JSON . stringify ( { type : 'move' , id : myId , 'new-pos' : { 'x' : players [ id ] . position . x , 'y' : players [ id ] . position . y , 'o' : players [ id ] . position . o } } ) ; connection . send ( jsonmsg ) ; }
function ( ) { return false ; }
function ( ) { $ ( this ) . submit ( function ( ) { return false ; } ) ; $ ( 'input:submit' ) . removeClass ( 'primary' ) . addClass ( 'disabled' ) ; $ ( 'input:submit' ) . attr ( 'disabled' , 'disabled' ) ; return true ; }
function ( blocks ) { var domBlocks = $ ( blocks ) ; var domBlocksLength = domBlocks . length ; var domArray = [ ] ; for ( var i = 0 ; i < domBlocksLength ; i = i + 10 ) { domArray . push ( domBlocks . slice ( i , i + 10 ) ) ; } return domArray ; }
function ( ) { console . log ( 'moveDown--------------' ) ; var space = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ] ; for ( var i = 0 ; i < 4 ; i ++ ) { this . playPiece [ i ] . unshift . apply ( this . playPiece [ i ] , space ) ; } this . render ( ) ; }
function ( ) { console . log ( 'touchdown' ) ; this . loadBoard ( ) ; this . playPiece = this . waitingPiece ; this . waitingPiece = this . createPiece ( ) ; if ( this . collisionTest ( 'init' ) === true ) { this . gameOver ( ) ; } this . render ( ) ; this . renderWaiting ( ) ; }
function ( ) { var time = L . Transition . getTime ( ) , elapsed = time - this . _startTime , duration = this . options . duration * 1000 ; if ( elapsed < duration ) { this . _runFrame ( this . _cubicBezier ( elapsed / duration ) ) ; } else { this . _runFrame ( 1 ) ; this . _complete ( ) ; } }
function colorToggle ( ) { var body = document . getElementsByTagName ( 'body' ) [ 0 ] if ( body . className == 'dark' ) { body . className = localStorage . getItem ( 'typeface' ) localStorage . setItem ( 'bgcolor' , '' ) } else { body . className = 'dark ' + localStorage . getItem ( 'typeface' ) localStorage . setItem ( 'bgcolor' , 'dark' ) } }
function serifToggle ( ) { var body = document . getElementsByTagName ( 'body' ) [ 0 ] if ( body . className == 'serif' ) { body . className = localStorage . getItem ( 'bgcolor' ) localStorage . setItem ( 'typeface' , '' ) } else { body . className = 'serif ' + localStorage . getItem ( 'bgcolor' ) localStorage . setItem ( 'typeface' , 'serif' ) } }
function displaySeries ( ) { years = 10 ; var data = calcSeries ( years , rate , timesPerYear ) ; o = options . clone ( ) ; o [ "xaxis" ] = { title : "Growth after 10 years is $" + Math . round ( interest ( timesPerYear , 10 , rate ) * 100 ) / 100 } graph = Flotr . draw ( container , [ data ] , o ) ; }
function ( ) { var self = this ; self . httpServer = self . createHTTPServer ( ) ; self . httpServer . listen ( self . settings . port ) ; console . log ( 'Server started on PORT' + self . settings . port ) ; }
function ( ) { this . loadConfig ( ) ; this . loadOverrides ( ) ; this . initModules ( ) ; if ( this . config . operators ) { this . operators = this . config . operators . map ( function ( op ) { return new RegExp ( op . replace ( /[-[\]{}()+?.,\\^$|#\s]/g , "\\$&" ) . replace ( /\*/g , '(.+?)' ) ) ; } ) ; } }
function handler ( results , cb ) { if ( ! results ) { return ; } request ( 'http://gdata.youtube.com/feeds/api/videos/' + results [ 1 ] + '?alt=jsonc&v=2' , function ( err , res , body ) { if ( err || res . statusCode !== 200 ) { return ; } var data = JSON . parse ( body ) . data ; if ( data ) { cb ( data ) ; } } ) ; }
function ( ) { var id = ed . getParam ( 'wp_fullscreen_editor_id' ) || ed . getParam ( 'fullscreen_editor_id' ) || ed . id , link = tinymce . DOM . select ( '#wp-' + id + '-media-buttons a.thickbox' ) ; if ( link && link [ 0 ] ) link = link [ 0 ] ; else return ; tb_show ( '' , link . href ) ; tinymce . DOM . setStyle ( [ 'TB_overlay' , 'TB_window' , 'TB_load' ] , 'z-index' , '999999' ) ; }
function ( req , res , next ) { var context = null ; var referrer = req . header ( 'Referrer' ) ; if ( referrer . indexOf ( "docs" ) > 0 ) { context = "docs" ; } else if ( referrer . indexOf ( "developer" ) > 0 ) { context = "developer" ; } res . local ( "context" , context ) ; next ( ) ; }
function getServerData ( ) { $ . ajax ( { url : options . sourceDomain + "api/live-info/" , data : { type : "endofday" , limit : "5" } , dataType : "jsonp" , success : function ( data ) { processData ( data ) ; } , error : airtimeScheduleJsonpError } ) ; setTimeout ( getServerData , options . updatePeriod * 1000 ) ; }
function ( event ) { onTraceSelected ( $ ( event . target ) . closest ( 'li' ) . data ( 'trace' ) ) ; }
function init ( ) { $tab = $ ( '<div class="table-container quiet-scrollbars">' ) . attr ( 'id' , tabId ) ; $events = $ ( '<div class="events">' ) . on ( 'click' , 'div.event' , onEventClicked ) . appendTo ( $tab ) ; $tree = $ ( '<div class="tree quiet-scrollbars">' ) . appendTo ( $tab ) ; Panel . addTab ( tabId , "Traces" , $tab ) ; $ ( Debugger ) . on ( "paused" , onPaused ) ; $ ( Debugger ) . on ( "eventTrace" , onEventTrace ) ; }
function toggleCmnts ( ) { var a = document . getElementsByClassName ( 'cmnt' ) ; if ( a . length == 0 ) return ; console . log ( 'old display: ' + a [ 0 ] . style . display ) ; var s = a [ 0 ] . style . display !== 'block' ? 'block' : 'none' ; for ( var i = 0 ; i < a . length ; i ++ ) a [ i ] . style . display = s ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 708 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 730 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 771 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 801 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 898 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 708 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 730 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 771 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 801 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 898 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 708 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 730 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 771 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 801 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 898 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( allDSD ) { this . emptyDataStructureDefinitions ( ) ; var allDSD_length = allDSD . length ; while ( allDSD_length -- ) { this . addItem ( "sidebar-left-data-selection-strc" , allDSD [ allDSD_length ] ) ; } $ ( "sidebar-left-data-selection-strc" ) . trigger ( "dsdRendered.CubeViz" ) ; this . setSelectedDSD ( ) ; }
function ( allDS ) { this . emptyDataSets ( ) ; var allDS_length = allDS . length ; while ( allDS_length -- ) { this . addItem ( "sidebar-left-data-selection-sets" , allDS [ allDS_length ] ) ; } $ ( "sidebar-left-data-selection-sets" ) . trigger ( "dsRendered.CubeViz" ) ; this . setSelectedDS ( ) ; }
function loadAlerts ( services , fromDate , refresh ) { var delayer = 0 ; $ . each ( services , function ( service , filter ) { setTimeout ( function ( ) { getAlerts ( service , filter + fromDate , refresh ) ; } , delayer ) ; delayer += 100 ; } ) ; }
function ( v , md , r ) { if ( r . get ( 'tipe_file' ) == 0 ) { return "<span class='dir'>" + v + "</span>" ; } else { return "<a class='doc' target='_blank'" + " href='data/download.jsp" + "?berkas=" + r . get ( 'sha' ) + "&nama=" + v + "'>" + v + "</a>" ; } }
function ( ) { this . win_share = Ext . create ( 'Earsip.view.BerkasBerbagiWin' , { } ) ; this . win_search = Ext . create ( 'Earsip.view.CariBerkasWin' , { } ) ; this . win_viewer = Ext . create ( 'Earsip.view.DocViewer' , { } ) ; this . callParent ( arguments ) ; }
function ( b ) { var dv = this . getDocviewer ( ) ; try { Ext . destroy ( Ext . get ( 'downloadIframe' ) ) ; } catch ( e ) { } Ext . DomHelper . append ( document . body , { tag : 'iframe' , id : 'downloadIframe' , frameBorder : 0 , width : 0 , height : 0 , css : 'display:none;visibility:hidden;height:0px;' , src : 'data/download.jsp?berkas=' + dv . berkas . get ( 'sha' ) + '&nama=' + dv . berkas . get ( 'nama' ) } ) ; }
function ( passageId , version , fireChange ) { if ( version ) { $ ( ".passageVersion" , step . util . getPassageContainer ( passageId ) ) . val ( version ) ; $ . shout ( "version-changed-" + passageId , version ) ; } return step . state . _storeAndRetrieveCookieState ( passageId , "version" , version , fireChange ) ; }
function ( result ) { console . log ( ) ; aResults . push ( [ aTest . name + ( sync ? ' - sync' : ' - async' ) , result . okN , result . failN , result . fatalN ] ) ; doTest ( i + ! sync , ! sync ) ; }
function ( Backbone , _ , $ ) { "use strict" ; var spinner = new Backbone . UI . Spinner ( { el : $ ( '.sp_example' ) , settings : { value : 600 , max : 3300 , type : 'integer' , disabled : false } } ) ; }
function nonChromiumPlatform ( builderNameUpperCase ) { if ( stringContains ( builderNameUpperCase , 'LION' ) ) return 'APPLE_LION' ; if ( stringContains ( builderNameUpperCase , 'SNOWLEOPARD' ) ) return 'APPLE_SNOWLEOPARD' ; if ( stringContains ( builderNameUpperCase , 'LEOPARD' ) ) return 'APPLE_LEOPARD' ; if ( stringContains ( builderNameUpperCase , 'WINDOWS 7' ) ) return 'APPLE_WIN7' ; if ( stringContains ( builderNameUpperCase , 'WINDOWS XP' ) ) return 'APPLE_XP' ; if ( stringContains ( builderNameUpperCase , 'GTK LINUX' ) ) return 'GTK_LINUX' ; if ( stringContains ( builderNameUpperCase , 'QT LINUX' ) ) return 'QT_LINUX' ; }
function ( ) { resetGlobals ( ) ; var test = 'bar/1.html' ; g_expectations = 'WONTFIX : bar = FAIL PASS TIMEOUT\n' + 'WONTFIX MAC : ' + test + ' = FAIL\n' + 'LINUX DEBUG : ' + test + ' = CRASH' ; runExpectationsTest ( 'Webkit Win' , test , 'FAIL PASS TIMEOUT' , 'WONTFIX' ) ; runExpectationsTest ( 'Webkit Win (dbg)(3)' , test , 'FAIL PASS TIMEOUT' , 'WONTFIX' ) ; runExpectationsTest ( 'Webkit Linux' , test , 'FAIL PASS TIMEOUT' , 'WONTFIX' ) ; runExpectationsTest ( 'Webkit Linux (dbg)(3)' , test , 'CRASH' , 'LINUX DEBUG' ) ; runExpectationsTest ( 'Webkit Mac10.5' , test , 'FAIL' , 'WONTFIX MAC' ) ; runExpectationsTest ( 'Webkit Mac10.5 (dbg)(3)' , test , 'FAIL' , 'WONTFIX MAC' ) ; }
function ( ) { resetGlobals ( ) ; var test = 'dummytest.html' ; var builderName = 'dummyBuilder' ; g_testToResultsMap [ test ] = [ createResultsObjectForTest ( test , builderName ) ] ; equal ( htmlForIndividualTestOnAllBuildersWithResultsLinks ( test ) , '<table class=test-table><thead><tr>' + '<th sortValue=test><div class=table-header-content><span></span><span class=header-text>test</span></div></th>' + '<th sortValue=bugs><div class=table-header-content><span></span><span class=header-text>bugs</span></div></th>' + '<th sortValue=modifiers><div class=table-header-content><span></span><span class=header-text>modifiers</span></div></th>' + '<th sortValue=expectations><div class=table-header-content><span></span><span class=header-text>expectations</span></div></th>' + '<th sortValue=slowest><div class=table-header-content><span></span><span class=header-text>slowest run</span></div></th>' + '<th sortValue=flakiness colspan=10000><div class=table-header-content><span></span><span class=header-text>flakiness (numbers are runtimes in seconds)</span></div></th>' + '</tr></thead>' + '<tbody></tbody>' + '</table>' + '<div>The following builders either don\'t run this test (e.g. it\'s skipped) or all runs passed:</div>' + '<div class=skipped-builder-list>' + '<div class=skipped-builder>Webkit Linux</div>' + '<div class=skipped-builder>Webkit Linux (dbg)</div>' + '<div class=skipped-builder>Webkit Mac10.5</div>' + '<div class=skipped-builder>Webkit Win</div>' + '</div>' + '<div class=expectations test=dummytest.html>' + '<div><span class=link onclick="setQueryParameter(\'showExpectations\', true)">Show results</span> | ' + '<span class=link onclick="setQueryParameter(\'showLargeExpectations\', true)">Show large thumbnails</span> | ' + '<b>Only shows actual results/diffs from the most recent *failure* on each bot.</b></div>' + '</div>' ) ; }
function ( ) { resetGlobals ( ) ; var test = 'dummytest.html' ; var builderName = 'dummyBuilder' ; BUILDER_TO_MASTER [ builderName ] = WEBKIT_BUILDER_MASTER ; g_testToResultsMap [ test ] = [ createResultsObjectForTest ( test , builderName ) ] ; equal ( htmlForIndividualTestOnAllBuildersWithResultsLinks ( test ) , '<table class=test-table><thead><tr>' + '<th sortValue=test><div class=table-header-content><span></span><span class=header-text>test</span></div></th>' + '<th sortValue=bugs><div class=table-header-content><span></span><span class=header-text>bugs</span></div></th>' + '<th sortValue=modifiers><div class=table-header-content><span></span><span class=header-text>modifiers</span></div></th>' + '<th sortValue=expectations><div class=table-header-content><span></span><span class=header-text>expectations</span></div></th>' + '<th sortValue=slowest><div class=table-header-content><span></span><span class=header-text>slowest run</span></div></th>' + '<th sortValue=flakiness colspan=10000><div class=table-header-content><span></span><span class=header-text>flakiness (numbers are runtimes in seconds)</span></div></th>' + '</tr></thead>' + '<tbody></tbody>' + '</table>' + '<div>The following builders either don\'t run this test (e.g. it\'s skipped) or all runs passed:</div>' + '<div class=skipped-builder-list>' + '<div class=skipped-builder>Webkit Linux</div>' + '<div class=skipped-builder>Webkit Linux (dbg)</div>' + '<div class=skipped-builder>Webkit Mac10.5</div>' + '<div class=skipped-builder>Webkit Win</div>' + '</div>' + '<div class=expectations test=dummytest.html>' + '<div><span class=link onclick="setQueryParameter(\'showExpectations\', true)">Show results</span> | ' + '<span class=link onclick="setQueryParameter(\'showLargeExpectations\', true)">Show large thumbnails</span>' + '<form onsubmit="setQueryParameter(\'revision\', revision.value);return false;">' + 'Show results for WebKit revision: <input name=revision placeholder="e.g. 65540" value="" id=revision-input>' + '</form></div>' + '</div>' ) ; }
function ( ) { alert ( "Ha donat un error al ordenar la llista! No s'han guardat els canvis" ) ; }
function configureResources ( config , cb ) { if ( config && config . webserver && config . webserver . resources ) { return resources . configure ( config . webserver . resources , synchronizer . register ( function ( err , resources ) { console . log ( "Check" ) ; if ( err ) { return callback ( err ) ; } cb ( config , resources ) ; } ) ) ; } else { return cb ( null , config ) ; } }
function ( o , field ) { if ( o . hasOwnProperty != null ) return o . hasOwnProperty ( field ) ; var arr = Reflect . fields ( o ) ; var $it0 = arr . iterator ( ) ; while ( $it0 . hasNext ( ) ) { var t = $it0 . next ( ) ; if ( t == field ) return true ; } return false ; }
function ( ) { var a = new Array ( ) ; var _g1 = 0 , _g = arguments . length ; while ( _g1 < _g ) { var i = _g1 ++ ; a . push ( arguments [ i ] ) ; } return f ( a ) ; }
function joinAdjacentList ( border , list ) { var children ; if ( border . safeBlock && /ul/i . test ( border . safeBlock . nodeName ) ) { next = border . safeBlock [ border . nextProperty ] ; children = $ ( border . safeBlock ) . remove ( ) . children ( ) ; if ( border . nextProperty === 'previousSibling' ) { children . prependTo ( list ) ; } else { children . appendTo ( list ) ; } border . safeBlock = next ; } }
function ( ) { start ( ) ; ok ( ! previewButton . is ( '.on' ) , 'preview off' ) ; ok ( changeMode . val ( ) === 'haml' , 'The datamode should stay the same' ) ; previewButton . mouseup ( ) ; async ( function ( ) { start ( ) ; ok ( previewButton . is ( '.on' ) , 'preview on' ) ; ok ( changeMode . val ( ) === 'haml' , 'The datamode should stay the same' ) ; } ) ; }
function ( ) { if ( this . history ) { return $ ( window ) . unbind ( 'popstate' , this . change ) ; } else { return $ ( window ) . unbind ( 'hashchange' , this . change ) ; } }
function ( settings , args ) { var a = argParse ( args , { 'target_dir' : { match : [ '-d' , '--package-dir' ] , value : true } } ) ; var opt = a . options ; opt . target_dir = opt . target_dir || path . resolve ( 'jam' ) ; exports . clean ( opt , function ( err ) { if ( err ) { return logger . error ( err ) ; } logger . end ( ) ; } ) ; }
function ( ) { HordeCore . initHandler ( 'click' ) ; $ ( 'action_choose0' , 'action_choose1' ) . invoke ( 'observe' , 'change' , this . changeHandler . bindAsEventListener ( this ) ) ; if ( this . mbox_expand ) { $ ( 'fmanager' ) . observe ( 'Horde_Tree:collapse' , this . toggleSubfolder . bindAsEventListener ( this , 'collapse' ) ) ; $ ( 'fmanager' ) . observe ( 'Horde_Tree:expand' , this . toggleSubfolder . bindAsEventListener ( this , 'expand' ) ) ; } }
function showPage ( pageName ) { addToHistory ( pageName ) ; var $page = $ ( "#" + pageName ) ; if ( ! $page . hasClass ( 'popup-container-container' ) ) { $ ( '.page, .popup-container-container' ) . hide ( ) ; curPageName = pageName ; } $page . show ( ) ; }
function ( event ) { console . log ( "HellO!" ) ; $ ( this ) . parents ( ".option-field" ) . find ( ".add-followup-button" ) . click ( ) ; $ ( this ) . parents ( ".question-entry" ) . addClass ( "has-follow-up" ) ; event . preventDefault ( ) ; }
function ( ) { var url = jQuery . path_join ( this . FILE_PUT_URL , this . CURRENT_PATH , this . file . name ) console . log ( url ) jQuery . ajax ( { url : url , type : 'PUT' , data : { 'slice_temp_file_id' : this . SLICE_TEMP_FILE_ID } , success : function ( data ) { pie . log ( 'inform返回: ' , arguments ) ; } , error : _this . show_error } ) ; }
function ( e ) { if ( e . eventPhase == EventSource . CLOSED ) { console . log ( "SignalR: EventSource closed" ) ; if ( ! opened ) { onFailed ( ) ; } that . stop ( ) ; } else { console . log ( "SignalR: EventSource error" ) ; $ ( instance ) . trigger ( "onError" , [ data ] ) ; } }
function ( elCell , oRecord , oColumn , oData ) { if ( ! oData ) { $ ( elCell ) . html ( oData ) ; return ; } var outputContainer = $ ( "<span/>" ) ; var removed = oData . replace ( /[\n|\r\n]/g , " " ) ; var broken = pub . breakOnToken ( removed , " " , 400 ) ; outputContainer . html ( broken . replace ( /[\n|\r\n]/g , "<br/>" ) ) ; $ ( elCell ) . html ( "" ) ; elCell . appendChild ( outputContainer [ 0 ] ) ; }
function ( cleanup ) { var i ; if ( this . _descendants && this . _descendants . length > 0 ) { for ( i = 0 ; i < this . _descendants . length ; i ++ ) { if ( this . _descendants [ i ] ) { this . _descendants . setBatchNode ( null ) ; } } } this . _super ( cleanup ) ; this . _descendants = [ ] ; this . _textureAtlas . removeAllQuads ( ) ; }
function ( msg ) { var m ; var found = false ; if ( m = msg . match ( /^SEEK_CANCELED (\d+)$/ ) ) { C4 . debug ( msg ) ; var seekId = + m [ 1 ] ; C4 . remove_my_seek ( seekId ) ; found = true ; } else if ( msg . match ( /^NO_SEEK_FOUND (\d+)$/ ) ) { C4 . debug ( msg ) ; found = true ; } ; if ( found ) C4 . remove_handler ( C4 . cb_cancel_seek ) ; return found ; }
function centerPopup ( ) { var windowWidth = document . documentElement . clientWidth ; var windowHeight = document . documentElement . clientHeight ; var popupHeight = $ ( "#popupContact" ) . height ( ) ; var popupWidth = $ ( "#popupContact" ) . width ( ) ; $ ( "#popupContact" ) . css ( { "position" : "absolute" , "top" : windowHeight / 2 - popupHeight / 2 , "left" : windowWidth / 2 - popupWidth / 2 } ) ; $ ( "#backgroundPopup" ) . css ( { "height" : windowHeight } ) ; }
function centerPopup1 ( ) { var windowWidth = document . documentElement . clientWidth ; var windowHeight = document . documentElement . clientHeight ; var popupHeight = $ ( "#popupContact1" ) . height ( ) ; var popupWidth = $ ( "#popupContact1" ) . width ( ) ; $ ( "#popupContact1" ) . css ( { "position" : "absolute" , "top" : windowHeight / 2 - popupHeight / 2 , "left" : windowWidth / 2 - popupWidth / 2 } ) ; $ ( "#backgroundPopup" ) . css ( { "height" : windowHeight } ) ; }
function ( status , isp ) { onIspSelected ( isp ) ; map . setUserIspAndStatus ( isp , status ) ; writeToDatabase ( { isp : isp , status : status , lat : loc . lat , lng : loc . lng } ) ; $ ( '#header' ) . show ( ) ; }
function ( imageId ) { if ( $ ( '#images li' ) . length <= _updateImageListThreshold ) { var lastImage = $ ( '#images li' ) . last ( ) ; $ . get ( '/next/' + ( _listCount - _updateImageListThreshold ) + '?last_id=' + lastImage . data ( 'image-id' ) , appendImages ) ; } }
function ( element , className ) { if ( supportsClassList ) { return element . classList . add ( className ) ; } if ( api . hasClass ( element , className ) ) { return ; } element . className += " " + className ; }
function ( element , className ) { if ( supportsClassList ) { return element . classList . remove ( className ) ; } element . className = element . className . replace ( new RegExp ( "(^|\\s+)" + className + "(\\s+|$)" ) , " " ) ; }
function ( element , className ) { if ( supportsClassList ) { return element . classList . contains ( className ) ; } var elementClassName = element . className ; return ( elementClassName . length > 0 && ( elementClassName == className || new RegExp ( "(^|\\s)" + className + "(\\s|$)" ) . test ( elementClassName ) ) ) ; }
function ( e ) { var code = e . keyCode || e . which ; if ( ( code == 13 ) && ( this . $el . find ( ".username" ) . val ( ) != "YourNewUserNameGoesHere" ) ) { this . model . set ( "username" , $ ( ".username" ) . val ( ) ) ; $ ( ".confirm-password" ) . show ( ) ; $ ( ".password" ) . focus ( ) } }
function ( e ) { var $goToTab , toTab ; e . preventDefault ( ) ; if ( self . settings . tabsClickable ) { $goToTab = $ ( this ) ; if ( ! $goToTab . hasClass ( self . settings . activeClass ) ) { toTab = $goToTab . index ( this . $tabs ) ; return self . seek ( toTab ) ; } } }
function ( cssClass , value ) { store . add ( new store . recordType ( { text : value , value : cssClass , style : ( ! ( this . pageTSconfiguration && this . pageTSconfiguration . disableStyleOnOptionLabel ) && ! this . editor . config . disablePCexamples && HTMLArea . classesValues && HTMLArea . classesValues [ cssClass ] && ! HTMLArea . classesNoShow [ cssClass ] ) ? HTMLArea . classesValues [ cssClass ] : null } ) ) ; }
function ( change ) { if ( change . type === "Checkpoint" ) return false ; return true ; }
function ( change ) { if ( change . type === "Checkpoint" ) return false ; return true ; }
function ( change ) { if ( change . type === "Checkpoint" ) return false ; return true ; }
function callback ( response ) { var status = response . status ; $ ( '#spawn' ) . append ( '<div>Job status: ' + status + '</div>' ) ; switch ( status ) { case 'processing' : setTimeout ( check_job , 5000 ) ; break ; case 'success' : show_batch ( ) ; break ; default : $ ( '#spawn' ) . append ( '<div>invalid response</div>' ) ; } }
function ( chunk ) { var len = ( chunk [ 0 ] << 24 ) + ( chunk [ 1 ] << 16 ) + ( chunk [ 2 ] << 8 ) ; var payload = new Buffer ( len ) ; chunk . copy ( payload , 0 , 4 ) ; handler ( payload ) ; }
function onLocationDetected ( ok , e ) { if ( e ) { console . log ( 'onLocationDetected :: ' + e ) ; } else { drawISPList ( ) ; map . setLocation ( { isp : isp , status : status , lat : loc . lat , lng : loc . lng } ) ; if ( ! initialized ) { map . getMarkers ( ) ; mdl . setLocation ( loc . city , loc . state , isps ) ; initialized = true ; } } }
function doTask ( id , name , pomodoros ) { insertCompleteTask ( name , pomodoros ) ; removeIncompleteTask ( id ) ; }
function startTask ( id ) { console . log ( id ) tomatoidTimer . taskId = id ; tomatoidTimer . totalSeconds = pomodoroLenght * 60 ; tomatoidTimer . running = true ; inPomodoro = true ; inBreak = false ; }
function startBreak ( ) { console . log ( completedPomodoros ) if ( completedPomodoros % pomodorosPerLongBreak == 0 ) { tomatoidTimer . totalSeconds = longBreakLenght * 60 ; } else { tomatoidTimer . totalSeconds = shortBreakLenght * 60 ; } tomatoidTimer . running = true ; inPomodoro = false ; inBreak = true ; }
function ( event , ui ) { console . log ( 'drag at: (' + event . pageX + ', ' + event . pageY + ')' ) ; var p = self . _fc . globalToLocal ( event . pageX - o . left , event . pageY - o . top ) ; if ( ( p . x * p . x + p . y * p . y ) < F . joinRadius * F . joinRadius ) { self . join ( jf ) ; } }
function ( ) { Session . set ( DROPDOWN_VISIBLE_KEY , true ) ; }
function ( ) { expect ( Square . prototype . configure ) . to . be . an ( 'function' ) ; var backup = Square . prototype . configure ; function noop ( ) { } Square . extend ( { configure : noop } ) ; expect ( Square . prototype . configure ) . to . equal ( noop ) ; Square . prototype . configure = backup ; }
function ( ) { var square = new Square ( ) ; expect ( square . env ) . to . not . equal ( 'whoopwhoop' ) ; var square2 = new Square ( { env : 'whoopwhoop' } ) ; expect ( square . env ) . to . equal ( 'whoopwhoop' ) ; }
function ( ) { it ( 'should only accept functions' ) ; it ( 'should not add duplicate plugins' ) ; }
function ( ) { it ( 'should call the function if no evn variable is given' ) ; it ( 'should not execute the function if the env doesnt match' ) ; it ( 'should execute the function on evn match' ) ; }
function ( ) { it ( 'should iterate over all plugins' ) ; it ( 'should catch errors generated by the plugins' ) ; it ( 'should handle plugins that doesnst return content' ) ; it ( 'should callback with one error when things breaks' ) ; it ( 'should callback the newly generated collection' ) ; }
function ( ) { it ( 'should read .json files' ) ; it ( 'should require .js files' ) ; it ( 'should also read objects' ) ; it ( 'should generate inclusion details' ) ; it ( 'should parse boolean values using eson' ) ; it ( 'should parse include statements using eson' ) ; it ( 'should glob directories using eson' ) ; it ( 'should return false when it fails to read the file' ) ; it ( 'should return true when it sucessfully read the file' ) ; }
function ( x , y ) { var from = this . GetCenterRounded ( ) ; var to = { x : x , y : y } ; this . _pendingPath = NavigationManager . GetPathFinder ( ) . FindPath ( from , to ) ; this . _onNavigationStarted ( ) ; this . _advancePath ( ) ; }
function ( ) { this . _isNavigationPaused = true ; this . StopMoving ( ) ; }
function ( world ) { this . _world = world ; this . _pathFinders . length = 0 ; this . _semantics = new WorldPathSemantics ( world ) ; this . _interRegionPathFinder = new PathFinder ( new InterRegionPathSemantics ( world ) ) ; }
function ( ra , dec , redshift ) { var x , y , z ; x = redshift * Math . sin ( ra ) * Math . cos ( dec ) ; y = redshift * Math . sin ( ra ) * Math . sin ( dec ) ; z = redshift * Math . cos ( ra ) ; return [ x , y , z ] ; }
function process ( cell , x ) { switch ( x ) { case '1' : cell . removeClass ( 'cell-free' ) ; cell . addClass ( 'cell-o' ) ; cell . off ( 'click' ) ; break ; case '3' : cell . removeClass ( 'cell-free' ) ; cell . addClass ( 'cell-x' ) ; cell . off ( 'click' ) ; break ; } }
function ( ) { var noop = function ( ) { } ; var methods = [ 'assert' , 'count' , 'debug' , 'dir' , 'dirxml' , 'error' , 'exception' , 'group' , 'groupCollapsed' , 'groupEnd' , 'info' , 'log' , 'markTimeline' , 'profile' , 'profileEnd' , 'time' , 'timeEnd' , 'timeStamp' , 'trace' , 'warn' ] ; var length = methods . length ; var console = window . console = { } ; while ( length -- ) { console [ methods [ index ] ] = noop ; } }
function slashAdd ( v ) { v = v . toString ( ) ; v = v . replace ( /\\/g , "\\" ) ; v = v . replace ( /\r/g , "\\r" ) ; v = v . replace ( /\t/g , "\\t" ) ; v = v . replace ( /\f/g , "\\f" ) ; v = v . replace ( /\n/g , "\\n" ) ; return v ; }
function slashRemove ( v ) { v = v . replace ( /\\r/g , "\r" ) ; v = v . replace ( /\\t/g , "\t" ) ; v = v . replace ( /\\f/g , "\f" ) ; v = v . replace ( /\\n/g , "\n" ) ; v = v . replace ( /\\\\/g , "\\" ) ; return v ; }
function ( ) { Tr8n . SDK . Proxy . initTml ( ) } ) : this . text_enabled && Tr8n . Utils . addEvent ( window , "load" , function ( ) { Tr8n . SDK . Proxy . initText ( ) } ) ; return this } , translate : function ( a , b , c , d ) { if ( ! a ) return "" ; c = c || { } ; d = d || { }
function ( options ) { this . options = options || { } ; this . keyboardMode = false ; this . loaded = false ; this . container = document . createElement ( 'div' ) ; this . container . className = 'tr8n_language_selector' ; this . container . id = 'tr8n_language_selector' ; this . container . style . display = "none" ; document . body . appendChild ( this . container ) ; }
function ( ) { if ( Tr8n . inline_translations_enabled ) { Tr8n . UI . Lightbox . show ( '/tr8n/language/toggle_inline_translations' , { width : 400 , height : 480 , message : "Disabling inline translations..." } ) ; } else { Tr8n . UI . Lightbox . show ( '/tr8n/language/toggle_inline_translations' , { width : 400 , height : 480 , message : "Enabling inline translations..." } ) ; } }
function ( ) { this . container . style . display = "none" ; this . overlay . style . display = "none" ; this . content_frame . src = 'about:blank' ; Tr8n . Utils . showFlash ( ) ; }
function ( options ) { this . options = options || { } ; this . keyboardMode = false ; this . loaded = false ; this . container = document . createElement ( 'div' ) ; this . container . className = 'tr8n_language_selector' ; this . container . id = 'tr8n_language_selector' ; this . container . style . display = "none" ; document . body . appendChild ( this . container ) ; }
function ( ) { if ( Tr8n . inline_translations_enabled ) { Tr8n . UI . Lightbox . show ( '/tr8n/language/toggle_inline_translations' , { width : 400 , height : 480 , message : "Disabling inline translations..." } ) ; } else { Tr8n . UI . Lightbox . show ( '/tr8n/language/toggle_inline_translations' , { width : 400 , height : 480 , message : "Enabling inline translations..." } ) ; } }
function ( ) { this . container . style . display = "none" ; this . overlay . style . display = "none" ; this . content_frame . src = 'about:blank' ; Tr8n . Utils . showFlash ( ) ; }
function ( evt ) { $ [ '_each' ] ( findHdls ( el , evt , fn , sel ) , function ( hdl ) { delete handlers [ id ] [ hdl . i ] ; unbind ( el , hdl . e , hdl . del || hdl . fn ) ; } ) ; }
function remEvt ( el , evts , fn , sel ) { var id = jquid ( el ) ; $ [ '_each' ] ( ( evts || '' ) . split ( /\s/ ) , function ( evt ) { $ [ '_each' ] ( findHdls ( el , evt , fn , sel ) , function ( hdl ) { delete handlers [ id ] [ hdl . i ] ; unbind ( el , hdl . e , hdl . del || hdl . fn ) ; } ) ; } ) ; }
function ( data , textstatus , request ) { var obj = $ . parseJSON ( request . responseText ) console . log ( obj . object ) ; var data = obj . object ; buildGraph ( data ) ; firstTime = false ; }
function ( ) { if ( $ . isFunction ( _this . startedAdPlayback ) ) { _this . onAdError ( " CONTENT_PAUSE_REQUESTED without no ad LOADED! " ) ; } }
function ( event ) { _this . startedAdPlayback = function ( ) { _this . embedPlayer . adTimeline . updateUiForAdPlayback ( _this . currentAdSlotType ) ; _this . startedAdPlayback = null ; } _this . embedPlayer . pauseLoading ( ) ; setTimeout ( function ( ) { if ( $ . isFunction ( _this . startedAdPlayback ) ) { _this . onAdError ( " CONTENT_PAUSE_REQUESTED without no ad LOADED! " ) ; } } , 8000 ) ; }
function ( args , resolve ) { var result ; if ( this . failed ) { return resolve ( this . promise ) ; } else { try { result = ext . call ( this . value , args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; } catch ( e ) { return resolve ( e ) ; } return resolve ( result ) ; } }
function ( win , fail ) { ( win == null ) || callable ( win ) ; ( fail == null ) || callable ( fail ) ; if ( win || fail ) { if ( this . _base . resolved ) { b . apply ( this . _base , arguments ) ; } else { this . _base . next ( 'cb' , arguments ) ; } } return this ; }
function ( args , resolve ) { var result ; if ( this . failed ) { return resolve ( this . promise ) ; } try { result = reduce . call ( args , function ( obj , key ) { return value ( obj ) [ String ( key ) ] ; } , this . value ) ; } catch ( e ) { return resolve ( e ) ; } return resolve ( result ) ; }
function ( args , resolve ) { var win = args [ 0 ] , fail = args [ 1 ] ; return back . then . call ( this , ( ! this . failed && isFunction ( win ) ) ? match . call ( win ) : win , fail , resolve ) ; }
function ( ) { return this . _base . resolved ? this . _base . value : this ; }
function ( win , fail ) { if ( this . failed ) { if ( fail ) { fail ( this . value ) ; } else if ( ! win || ( arguments . length > 1 ) ) { throw this . value ; } else { win ( this . value ) ; } } else if ( win ) { if ( arguments . length > 1 ) { win ( this . value ) ; } else { win ( null , this . value ) ; } } }
function ( index , value ) { this . processResult ( index , value ) ; if ( ! this . d . promise . _base . resolved ) { if ( this . held . length ) { this . held . shift ( ) ( ) ; } } }
function ( index , value ) { if ( this . d . promise . _base . resolved ) { return ; } this . result [ index ] = value ; if ( ! -- this . waiting && this . initialized ) { this . d . resolve ( this . result ) ; } }
function ( t , a , d ) { var promise = t ( ) , x = { } , count = 0 ; promise ( function ( result ) { ++ count ; } , a . never ) . end ( ) ; promise ( function ( result ) { a ( count , 1 ) ; } , a . never ) . end ( d ) ; promise . _base . resolve ( x ) ; }
function ( t , a , d ) { var p1 = t ( ) , x = { } , p2 = t ( ) ; p1 ( function ( result ) { a ( result , x ) ; } , a . never ) . end ( d ) ; p1 . _base . resolve ( p2 ) ; p2 . _base . resolve ( x ) ; }
function ( t , a ) { var y = t ( ) ; a ( y . valueOf ( ) , y , "Unresolved" ) ; y . _base . resolve ( x ) ; a ( y . valueOf ( ) , x , "Resolved" ) ; }
function ( ) { var value = this . list [ this . current ] ; if ( isPromise ( value ) && isPromise ( value = value . valueOf ( ) ) ) { value . end ( this . processCb . bind ( this ) , this . resolve ) ; return ; } this . processCb ( value ) ; }
function ( ) { var d = deferred ( ) ; setTimeout ( delayed . bind ( this , fn , arguments , d . resolve ) , timeout ) ; return d . promise ; }
function ( e ) { e . preventDefault ( ) ; e . stopPropagation ( ) ; this . commit ( ) ; return this . model . save ( { } , { success : function ( ) { return app . vent . trigger ( 'notice' , 'Your info has been updated.' ) ; } } ) ; }
function ( ) { var transitionStopRule ; if ( this . appModel . livePreview ) { transitionStopRule = "nj-css-garbage-selector" ; this . stage . bindingView . hide = true ; } else { transitionStopRule = "*" this . stage . bindingView . hide = false ; } this . application . ninja . stylesController . _stageStylesheet . rules [ 0 ] . selectorText = transitionStopRule ; this . _toggleWebGlAnimation ( this . appModel . livePreview ) ; }
function ( elt ) { var len = this . length ; var from = Number ( arguments [ 1 ] ) || 0 ; from = ( from < 0 ) ? Math . ceil ( from ) : Math . floor ( from ) ; if ( from < 0 ) { from += len ; } for ( ; from < len ; ++ from ) { if ( from in this && this [ from ] === elt ) { return from ; } } return - 1 ; }
function ( from , to ) { var rest = this . slice ( ( to || from ) + 1 || this . length ) ; this . length = from < 0 ? this . length + from : from ; return this . push . apply ( this , rest ) ; }
function addIvar ( name , type , size , alignment ) { if ( ! size ) { var ffiType = types . map ( type ) size = core . TYPE_SIZE_MAP [ ffiType ] } if ( ! alignment ) { alignment = Math . log ( size ) / Math . log ( 2 ) } if ( ! core . class_addIvar ( this , name , size , alignment , type ) ) { throw new Error ( 'ivar "' + name + '" was NOT sucessfully added to Class: ' + this . getName ( ) ) } return this }
function ( data ) { var old = this . opts . element . val ( ) ; this . opts . element . val ( data . id ) ; this . updateSelection ( data ) ; this . close ( ) ; this . selection . focus ( ) ; if ( ! equal ( old , data . id ) ) { this . triggerChange ( ) ; } }
function ( ) { var choice = $ ( this ) , id = choice . data ( "select2-data" ) . id ; if ( indexOf ( id , val ) >= 0 ) { choice . addClass ( "select2-disabled" ) ; } else { choice . removeClass ( "select2-disabled" ) ; } }
function ( ) { var rawPads = getField ( ) var len = rawPads . length ; for ( var i = 0 ; i < len ; ++ i ) { mapIndividualPad ( rawPads , i ) ; } for ( ; i < curData . length ; ++ i ) { prevData [ i ] = undefined ; curData [ i ] = undefined ; } return curData ; }
function ( data ) { sp . write ( 'G90\n' ) ; sp . write ( [ 'G1' , 'X' + data . x , 'Y' + data . y , 'F800' ] . join ( ' ' ) + '\n' ) ; sp . write ( [ 'G1' , 'Z' + data . z , 'F400' ] . join ( ' ' ) + '\n' ) ; }
function ( response ) { switch ( response . header . status ) { case 0 : callback && callback ( response . val , response . extras ) break ; case 1 : callback && callback ( null , null ) ; break ; default : console . log ( 'MemJS GET: ' + errors [ response . header . status ] ) ; callback && callback ( ) ; } }
function ( response ) { switch ( response . header . status ) { case 0 : callback && callback ( true ) break ; default : console . log ( 'MemJS SET: ' + errors [ response . header . status ] ) ; callback && callback ( ) ; } }
function ( response ) { switch ( response . header . status ) { case 0 : callback && callback ( true ) break ; case 2 : callback && callback ( false ) ; break ; default : console . log ( 'MemJS ADD: ' + errors [ response . header . status ] ) ; callback && callback ( ) ; } }
function ( response ) { switch ( response . header . status ) { case 0 : callback && callback ( true ) break ; case 1 : callback && callback ( false ) ; break ; default : console . log ( 'MemJS REPLACE: ' + errors [ response . header . status ] ) ; callback && callback ( ) ; } }
function ( response ) { switch ( response . header . status ) { case 0 : callback && callback ( true ) break ; case 1 : callback && callback ( false ) ; break ; default : console . log ( 'MemJS DELETE: ' + errors [ response . header . status ] ) ; callback && callback ( ) ; } }
function ( server , stats ) { assert . equal ( '1432' , stats . bytes ) ; assert . equal ( '5432' , stats . count ) ; assert . equal ( 'myhostname:5544' , server ) ; callbn += 1 ; }
function move ( to , from ) { var selected = $ ( from ) ; var pool = $ ( to ) ; while ( pool . selectedIndex != - 1 ) { selected . appendChild ( pool . options . item ( pool . selectedIndex ) ) } }
function select_assigned ( ) { var assigned = $ ( 'milestone_assigned_projects' ) ; for ( x = 0 ; x < assigned . options . length ; x ++ ) { assigned . options [ x ] . selected = true ; } return true ; }
function ( buf , off ) { debug ( 'frame_hi(' + sys . inspect ( buf ) + ', ' + off + ')' ) ; if ( buf [ off ] !== 0 ) { throw new Error ( 'High-byte framing not supported.' ) ; } serverClosed = true ; return 1 ; }
function updateState ( ) { switching = false ; var currentNetwork = wifiManager . connection . network ; if ( currentNetwork ) { infoBlock . textContent = _ ( 'fullStatus-connected' , currentNetwork ) ; checkbox . checked = true ; } else if ( wifiManager . enabled ) { infoBlock . textContent = _ ( 'fullStatus-disconnected' ) ; checkbox . checked = true ; } else { infoBlock . textContent = _ ( 'disabled' ) ; checkbox . checked = false ; } }
function ( scope , attrExpr , value ) { if ( ! attrExpr || ! attrExpr . expression ) return ; var v = value ; v = this . parseValue ( v , attrExpr , scope ) ; scope . $set ( attrExpr . expression , v ) ; scope . $parent . $eval ( ) ; }
function ( i , el ) { var id = $ ( el ) . attr ( 'id' ) ; if ( ! id ) return ; selectedTabs . push ( { id : id , selected : $ ( el ) . tabs ( 'option' , 'selected' ) } ) ; }
function ( ) { cdb . admin . User = Backbone . Model . extend ( { } ) ; cdb . admin . Table = cdb . ui . common . TableProperties . extend ( { idAttribute : 'name' } ) ; cdb . admin . Tables = Backbone . Collection . extend ( { model : cbd . admin . Table , url : function ( ) { return '/api/v1/tables' ; } , initialize : function ( ) { } } ) ; }
function scm_turnScreenOn ( ) { if ( this . screenEnabled ) return false ; navigator . mozPower . screenEnabled = this . screenEnabled = true ; navigator . mozPower . screenBrightness = this . _brightness ; this . screen . classList . remove ( 'screenoff' ) ; this . fireScreenChangeEvent ( ) ; return true ; }
function ( ) { canvas = $ ( '#myCanvas' ) . get ( 0 ) ; context = canvas . getContext ( '2d' ) ; g_elements . push ( new Emitter ( canvas . width / 2 , canvas . height / 2 , 5 , g_generate ) ) ; reciever = new Reciever ( 100 , 100 , 5 ) ; g_elements . push ( reciever ) ; startDraw ( ) ; }
function ( generate , canvas ) { this . canvas = $ ( '#' + canvas ) . get ( 0 ) ; this . context = this . canvas . getContext ( '2d' ) ; this . points = [ ] ; this . currentX = 0 ; this . generate = generate ; }
function ( id , args , callback ) { MediaFile . updateMediaFile ( id , args , function ( error , updatedMediaFile ) { if ( ! error ) { callback ( null , updatedMediaFile ) ; } else { callback ( error , null ) ; } } ) }
function ( test ) { var target = { 'target' : 'abc1230' } ; var updateAttributes = { 'title' : 'jericho twist' , 'path' : 'www.google.com' } ; MediaFile . updateMediaFile ( target , updateAttributes , function ( error , updatedMediaFile ) { console . log ( "expect = " + updateAttributes . title ) ; console . log ( "result = " + updatedMediaFile . title ) ; test . ok ( updatedMediaFile . title . should . be . eql ( updateAttributes . title ) ) ; test . done ( ) ; } ) }
function ( canvas , area , g ) { canvas . fillStyle = "rgba(105, 105, 185, 185)" ; colnum = 0 ; for ( var k = 0 ; k < simplificationPoints [ colnum ] . length - 1 ; k ++ ) { var bottom_left = g . toDomCoords ( simplificationPoints [ colnum ] [ k ] , - 20 ) ; var left = bottom_left [ 0 ] ; canvas . fillRect ( left , area . y , 2 , area . h ) ; } }
function ( data ) { var data = $ . parseJSON ( data ) ; $ ( ".standard-price-value" ) . html ( data [ "price" ] ) ; $ ( ".for-sale-price-value" ) . html ( data [ "for-sale-price" ] ) ; $ ( ".for-sale-standard-price-value" ) . html ( data [ "for-sale-standard-price" ] ) ; $ ( "a.product-image" ) . lightBox ( { "txtImage" : "Image" , "txtOf" : " of " } ) ; }
function styleCode ( ) { var a = false ; $ ( "pre code" ) . parent ( ) . each ( function ( ) { if ( ! $ ( this ) . hasClass ( "prettyprint" ) ) { $ ( this ) . addClass ( "prettyprint" ) ; a = true ; } } ) ; if ( a ) { prettyPrint ( ) ; } }
function ( ) { debug ( 'HTTP socket close' ) ; req . emit ( 'close' ) ; if ( req . res && req . res . readable ) { req . res . emit ( 'aborted' ) ; req . res . emit ( 'end' ) ; req . res . emit ( 'close' ) ; } else if ( ! req . res && ! req . _hadError ) { req . emit ( 'error' , createHangUpError ( ) ) ; } }
function renderDeliciousLinks ( items ) { var output = "<ul>" ; for ( var i = 0 , l = items . length ; i < l ; i ++ ) { output += '<li><a href="' + items [ i ] . u + '" title="Tags: ' + ( items [ i ] . t == "" ? "" : items [ i ] . t . join ( ', ' ) ) + '">' + items [ i ] . d + '</a></li>' ; } output += "</ul>" ; $ ( '#delicious' ) . html ( output ) ; }
function ( event , ui ) { history [ history . length ] = program ; $ ( ui . item ) . remove ( ) ; for ( var i = 0 ; i < program . length ; i ++ ) { if ( program [ i ] . id === $ ( ui . item ) . id ) { program . splice ( i , 1 ) ; } } console . log ( program + "asdfasdf \n" ) ; console . log ( history ) ; }
function ( data ) { while ( data . length > 0 ) { var chunk = data . substring ( 0 , this . options . bufferLimit ) ; data = data . substring ( chunk . length ) ; this . buffer += chunk ; if ( this . buffer . length > this . options . bufferLimit ) { this . flush ( this . options . bufferSize ) ; } } }
function dataSaved ( data ) { if ( data . status == 'success' ) { message ( 'success' , data . data ) ; loadData ( ) ; } else if ( data . status == 'error' ) { message ( 'errors' , data . data ) ; } else { message ( 'error' , 'An unknown error occurred' ) ; } }
function ( ) { if ( $ ( this ) [ 0 ] == $ ( target ) [ 0 ] || $ ( target ) . parent ( ) . is ( $ ( this ) ) ) { checker = true ; } else { console . log ( $ ( this ) ) ; } }
function checkParent ( target ) { var checker = false ; $ ( el , slider . containerSelector ) . find ( '> .flex-viewport > .subSlides' ) . children ( ) . each ( function ( ) { if ( $ ( this ) [ 0 ] == $ ( target ) [ 0 ] || $ ( target ) . parent ( ) . is ( $ ( this ) ) ) { checker = true ; } else { console . log ( $ ( this ) ) ; } } ) ; return checker ; }
function ( err , result ) { self . _numberOfServersLeftToInitialize = self . _numberOfServersLeftToInitialize - 1 ; if ( self . _numberOfServersLeftToInitialize == 0 ) { if ( self . haEnabled ) { self . _replicasetTimeoutId = setTimeout ( self . mongosCheckFunction , self . mongosStatusCheckInterval ) ; } self . _serverState = "connected" ; callback ( null , null ) ; } }
function ( ) { __executeAllCallbacksWithError ( parent , err ) ; if ( callback != null ) { var internalCallback = callback ; callback = null ; internalCallback ( err , null ) ; } else { if ( parent . listeners ( "close" ) . length > 0 ) { parent . emit ( "close" , err ) ; } } }
function ( ) { __executeAllCallbacksWithError ( parent , err ) ; if ( callback != null ) { var internalCallback = callback ; callback = null ; internalCallback ( new Error ( "connection timed out" ) , null ) ; } else { if ( parent . listeners ( "error" ) . length > 0 ) { parent . emit ( "timeout" , new Error ( "connection timed out" ) ) ; } } }
function ( ) { __executeAllCallbacksWithError ( parent , err ) ; if ( callback != null ) { var internalCallback = callback ; callback = null ; internalCallback ( err , null ) ; } else { if ( parent . listeners ( "error" ) . length > 0 ) { parent . emit ( "error" , err ) ; } } }
function ( err ) { var internalCallback = callback ; callback = null ; if ( typeof internalCallback == 'function' ) { internalCallback ( null , parent ) ; } replSetSelf . emit ( "fullsetup" ) }
function ( ) { test . equal ( true , closedCalled ) ; test . done ( ) ; }
function ( err , items ) { console . log ( "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2" ) test . ok ( err != null ) ; collection . find ( { } ) . toArray ( function ( err , items ) { console . log ( "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 3" ) test . ok ( err == null ) ; test . equal ( 1 , items . length ) ; console . log ( "================================== dbCLOSE" ) db . close ( function ( ) { test . done ( ) ; } ) ; } ) ; }
function ( api ) { api . use ( 'http' , 'server' ) ; api . add_files ( 'accounts_common.js' , [ 'client' , 'server' ] ) ; api . add_files ( 'accounts_server.js' , 'server' ) ; api . add_files ( 'accounts_client.js' , 'client' ) ; }
function ( ) { var sw = parseInt ( d3 . select ( "#display" ) . style ( "width" ) ) ; var sh = parseInt ( d3 . select ( "#display" ) . style ( "height" ) ) ; tributary . canvas . width = sw ; tributary . canvas . height = sh ; tributary . ctx . clearRect ( 0 , 0 , sw , sh ) ; }
function ( count ) { while ( count > my . size ) { var index = Math . floor ( count * Math . random ( ) ) ; var evct ; for ( var s in my . cache ) { if ( my . cache . hasOwnProperty ( s ) ) { if ( count == index ) evct = s ; } } count -- ; invalidate ( evct ) ; } }
function onCheckContinue ( req , res ) { if ( log . trace ( ) ) log . trace ( { event : 'checkContinue' } , 'event handled' ) ; if ( self . listeners ( 'checkContinue' ) . length > 0 ) return ( self . emit ( 'checkContinue' , req , res ) ) ; self . _setupRequest ( req , res ) ; res . writeContinue ( ) ; return ( self . _handle ( req , res , true ) ) ; }
function addLine ( msg ) { if ( msg . counter == - 1 ) { msgClass = 'system' ; } else { msgClass = 'user' + msg . counter ; } var mp = $ ( '<p>' ) . addClass ( msgClass ) . css ( 'color' , '#' + msg . color ) . text ( msg . line ) . appendTo ( '#conversation' ) ; conversation . scrollTop ( conversation [ 0 ] . scrollHeight ) ; }
function ( ) { if ( updateChatPreview ( ) ) { if ( $ ( '#textInput' ) . val ( ) != '' ) { if ( pingInterval ) { window . clearTimeout ( pingInterval ) ; } $ . post ( POST_URL , { 'chat' : chat , 'line' : $ ( '#preview' ) . text ( ) } ) ; pingInterval = window . setTimeout ( pingServer , PING_PERIOD * 1000 ) ; $ ( '#textInput' ) . val ( '' ) ; } } return false ; }
function ( value , cb ) { switch ( value . length ) { case void 0 : return cb ( null , value ) ; case 0 : return cb ( null , value ( ) ) ; case 1 : return value ( cb ) ; } }
function ( subs ) { var html = tmpls . subs_nav ( { groups : subs } ) ; $subs_list . empty ( ) . append ( html ) . find ( 'img' ) . each ( util . favicon_error ) ; $subs_list . trigger ( 'refresh.rm' ) ; util . call_if_fn ( cb ) ; }
function show_server_message ( ) { if ( _RM_ . gw ) { var msg = 'Busy importing from google reader, please refresh in a few seconds' ; notify . show_msg ( msg , 10000 ) ; _RM_ . gw = 0 ; } if ( _RM_ . ge ) { var msg2 = 'Error: ' + _RM_ . ge + ' , please try again' ; notify . show_msg ( msg2 , 4000 ) ; _RM_ . ge = 0 ; } }
function ( ) { $ ( 'html, body' ) . animate ( { scrollTop : $ ( $ ( this ) . attr ( 'href' ) ) . offset ( ) . top - 30 + 'px' } , { duration : 450 , easing : 'swing' } ) ; return false ; }
function ( e ) { var exportPackage = { html : butter . getHTML ( ) , json : butter . exportProject ( ) } ; var dialog = new IFrameDialog ( { type : "iframe" , modal : true , url : butter . ui . dialogDir + "view-source.html" , events : { open : function ( ) { dialog . send ( "export" , exportPackage ) ; } , cancel : function ( e ) { dialog . close ( ) ; } } } ) ; dialog . open ( ) ; }
function showErrorDialog ( message , callback ) { var dialog = new IFrameDialog ( { type : "iframe" , modal : true , url : butter . ui . dialogDir + "error-message.html" , events : { open : function ( e ) { dialog . send ( "message" , message ) ; } , cancel : function ( e ) { dialog . close ( ) ; if ( callback ) { callback ( ) ; } } } } ) ; dialog . open ( ) ; }
function ( ) { if ( this . readyState === 4 ) { try { var response = JSON . parse ( this . response ) ; callback ( response ) ; } catch ( err ) { callback ( { error : "an unknown error occured" } ) ; } } }
function ( ) { if ( this . readyState === 4 ) { try { var response = JSON . parse ( this . response ) ; callback ( response ) ; } catch ( err ) { callback ( { error : "an unknown error occured" } ) ; } } }
function editorClosed ( e ) { if ( _openEditor . frame === "iframe" ) { if ( butter . ui . contentState === "editor" ) { butter . ui . popContentState ( "editor" ) ; } } _openEditor . unlisten ( "close" , editorClosed ) ; _openEditor = null ; }
function ( source , type , frameType ) { if ( ! type || ! source ) { throw new Error ( "Can't create an editor without a plugin type and editor source" ) ; } var editor = _editors [ type ] = new Editor ( butter , source , type , frameType , _editorContainer ) ; return editor ; }
function evaluatePostFix_inner ( token ) { if ( ! this . isOperator ( token ) ) { stack . push ( token ) ; } else { var op2 = stack . pop ( ) ; var op1 = stack . pop ( ) ; var result = this . evaluate [ token ] ( op1 , op2 ) ; if ( isNaN ( result ) ) throw { type : 'error' , msg : 'Value is ' + result } ; stack . push ( result ) ; } }
function ( fileName , index , array ) { var fullFileName = descriptionsFolder + "\\" + fileName ; printDebugMessages ( "Uploading swarming:" + fileName ) ; var content = fs . readFileSync ( fullFileName ) ; redisClient . hset ( thisAdaptor . mkUri ( "system" , "code" ) , fileName , content ) ; }
function ( descriptionsFolder ) { var files = fs . readdirSync ( descriptionsFolder ) ; files . forEach ( function ( fileName , index , array ) { var fullFileName = descriptionsFolder + "\\" + fileName ; printDebugMessages ( "Uploading swarming:" + fileName ) ; var content = fs . readFileSync ( fullFileName ) ; redisClient . hset ( thisAdaptor . mkUri ( "system" , "code" ) , fileName , content ) ; } ) ; }
function printDebugMessages ( msg ) { return false ; console . log ( msg ) ; }
function ( message ) { if ( message . type == "start" && message . instanceUID != thisAdaptor . instanceUID ) { console . log ( "[" + thisAdaptor . nodeName + "] Forcing process exit because an node with the same name got alive!" ) ; process . exit ( 999 ) ; } if ( thisAdaptor . onBroadcastCallback != null ) { thisAdaptor . onBroadcastCallback ( message ) ; } }
function ( event ) { event . stopPropagation ( ) ; var list = [ ] ; for ( var i = 0 ; i < 12 ; i ++ ) { list . push ( this . symbols_ . MONTHS [ i ] ) ; } this . createMenu_ ( this . elMonth_ , list , this . handleMonthMenuClick_ , this . symbols_ . MONTHS [ this . activeMonth_ . getMonth ( ) ] ) ; }
function setup_redirect ( aSettings ) { var url = "https://example.com/browser/toolkit/mozapps/extensions/test/xpinstall/redirect.sjs?mode=setup" ; for ( var name in aSettings ) { url += "&" + name + "=" + aSettings [ name ] ; } var req = new XMLHttpRequest ( ) ; req . open ( "GET" , url , false ) ; req . send ( null ) ; }
function waitForSingleNotification ( ) { ok ( PopupNotifications . isPanelOpen , "Notification should still be open" ) ; if ( PopupNotifications . panel . childNodes . length == 2 ) { executeSoon ( waitForSingleNotification ) ; return ; } is ( PopupNotifications . panel . childNodes . length , 1 , "Should be only one notification" ) ; notification = aPanel . childNodes [ 0 ] ; is ( notification . id , "addon-install-failed-notification" , "Should have seen the install fail" ) ; Services . prefs . setBoolPref ( PREF_INSTALL_REQUIREBUILTINCERTS , true ) ; wait_for_notification_close ( runNextTest ) ; gBrowser . removeTab ( gBrowser . selectedTab ) ; }
function DbError ( msg , code ) { this . name = 'DbError' ; if ( typeof ( msg ) === 'string' ) { this . message = msg ; } else { this . data = msg ; this . message = 'custom' ; } this . code = code || 500 ; Error . call ( this , msg ) ; }
function ( req , res , next ) { var selected = req . getDb ( ) ; if ( ! selected ) { next ( new DbError ( 'Invalid database selected and default fallback does not exist.' ) ) ; } res . ok ( { host : selected . host , port : selected . port } ) ; }
function ( err ) { if ( err ) { fs . unlinkSync ( fetch_target ) ; return _cb ( err ) ; } if ( version == 'latest' ) { nodist . determineVersion ( fetch_target , function ( err , real_version ) { fs . renameSync ( fetch_target , n . sourceDir + '/' + real_version + '.exe' ) ; _cb ( null , real_version ) ; } ) ; } else return _cb ( null , version ) ; }
function unlink ( version , cb ) { var n = this ; var source = this . sourceDir + '/' + version + '.exe' ; if ( fs . existsSync ( source ) ) { return fs . unlink ( source , cb ) ; } return cb ( ) ; }
function ( err , real_version ) { if ( err ) return cb ( err ) ; source = n . sourceDir + '/' + real_version + '.exe' ; var node = exec ( source , args , { stdio : 'inherit' , cwd : path . resolve ( '.' ) } ) ; node . on ( 'exit' , cb . bind ( n , null ) ) ; }
function ( terminal ) { terminal . terminal ( function ( str , terminal , stack ) { try { forth . runString ( str ) ; } catch ( err ) { terminal . error ( err ) ; } forth . redrawStack ( ) ; } , { greetings : "FORTH Interpreter. Type 'clear' to clear" , prompt : '> ' } ) ; forth . terminal = terminal . terminal ( ) ; forth . stackElt = $ ( stack ) ; }
function ( options ) { options = options || { } ; email = options . email ; var self = this ; self . renderWait ( "is_this_your_computer" , options ) ; dom . focus ( "#this_is_my_computer" ) ; self . click ( "#this_is_my_computer" , self . yes ) ; self . click ( "#this_is_not_my_computer" , self . no ) ; Module . sc . start . call ( self , options ) ; }
function ( ) { db . save ( constants . BATTERY . TIME , time . value ) ; clearInterval ( interval ) ; if ( ( time . value !== undefined ) && ( time . value > 0 ) ) { interval = setInterval ( chargingVolume , INTERVAL ) ; } }
function ( cartesian , result ) { if ( typeof result === 'undefined' ) { return new Cartesian3 ( cartesian . x , cartesian . y , cartesian . z ) ; } result . x = cartesian . x ; result . y = cartesian . y ; result . z = cartesian . z ; return result ; }
function ( ) { var left = new Cartesian2 ( 2.0 , 3.0 ) ; var right = new Cartesian2 ( 4.0 , 5.0 ) ; var expectedResult = 23.0 ; var result = left . dot ( right ) ; expect ( result ) . toEqual ( expectedResult ) ; }
function ( ) { var cartesian = new Cartesian2 ( 1.0 , 2.0 ) ; expect ( cartesian . equals ( new Cartesian2 ( 1.0 , 2.0 ) ) ) . toEqual ( true ) ; expect ( cartesian . equals ( new Cartesian2 ( 2.0 , 2.0 ) ) ) . toEqual ( false ) ; expect ( cartesian . equals ( new Cartesian2 ( 2.0 , 1.0 ) ) ) . toEqual ( false ) ; expect ( cartesian . equals ( undefined ) ) . toEqual ( false ) ; }
function ( ) { var v = new Cartesian3 ( ) ; expect ( v . x ) . toEqual ( 0 ) ; expect ( v . y ) . toEqual ( 0 ) ; expect ( v . z ) . toEqual ( 0 ) ; }
function ( ) { var c = new Cartesian3 ( 1 , 0 , 0 ) . cross ( new Cartesian3 ( 0 , 1 , 0 ) ) ; expect ( c . equals ( new Cartesian3 ( 0 , 0 , 1 ) ) ) . toEqual ( true ) ; }
function ( ) { var s = new Cartesian3 ( 2 , 3 , 4 ) . dot ( new Cartesian3 ( 5 , 6 , 7 ) ) ; expect ( s ) . toEqual ( 2 * 5 + 3 * 6 + 4 * 7 ) ; }
function ( ) { var v = new Cartesian3 ( 1 , 2 , 3 ) . add ( new Cartesian3 ( 4 , 5 , 6 ) ) ; expect ( v . equals ( new Cartesian3 ( 5 , 7 , 9 ) ) ) . toEqual ( true ) ; }
function ( ) { var v = new Cartesian3 ( 1 , 2 , 3 ) . multiplyWithScalar ( 2 ) ; expect ( v . equals ( new Cartesian3 ( 2 , 4 , 6 ) ) ) . toEqual ( true ) ; }
function ( ) { var x = Cartesian3 . UNIT_X ; var y = Cartesian3 . UNIT_Y ; expect ( x . angleBetween ( x ) ) . toEqual ( 0 ) ; expect ( x . angleBetween ( y ) ) . toEqual ( CesiumMath . PI_OVER_TWO ) ; }
function ( ) { var v = new Cartesian3 ( 1 , 2 , 3 ) ; expect ( v . toString ( ) ) . toEqual ( '(1, 2, 3)' ) ; }
function findMarkdownHereWrappersInRange ( range ) { var documentFragment , cloneWrappers , wrappers , selection , i ; documentFragment = range . cloneContents ( ) ; cloneWrappers = documentFragment . querySelectorAll ( '.markdown-here-wrapper' ) ; if ( cloneWrappers && cloneWrappers . length > 0 ) { wrappers = [ ] ; for ( i = 0 ; i < cloneWrappers . length ; i ++ ) { wrappers . push ( range . commonAncestorContainer . ownerDocument . getElementById ( cloneWrappers [ i ] . id ) ) ; } return wrappers ; } else { return null ; } }
function ( ) { var compact = require ( '../../compact' ) . createCompact ( { srcPath : srcPath , destPath : destPath + '/invalid-dest' } ) ; path . existsSync ( destPath + '/invalid-dest' ) . should . equal ( true ) ; }
function ( helper ) { helper . compactJs ( ) . should . eql ( [ '/large.js' , '/a.js' , '/b.js' , '/c.js' ] ) ; }
function ( helper ) { helper . compactJs ( ) . should . eql ( [ '/a.js' , '/b.js' , '/c.js' ] ) ; done ( ) ; }
f exports . version = '0.1.0' ; exports . protocol = 1 ; exports . util = require ( './util' ) ; exports . parser = require ( './parser' ) ; exports . Socket = require ( './socket' ) ; exports . EventEmitter = require ( './event-emitter' ) exports . Transport = require ( './transport' ) ; exports . transports = require ( './transports' ) ; } ) ; require . register ( "node_modules/engine.io-client-f/lib/event-emitter.js" , function ( module , exports , require , global ) {
f exports . version = '0.1.0' ; exports . protocol = 1 ; exports . util = require ( './util' ) ; exports . parser = require ( './parser' ) ; exports . Socket = require ( './socket' ) ; exports . EventEmitter = require ( './event-emitter' ) exports . Transport = require ( './transport' ) ; exports . transports = require ( './transports' ) ; } ) ; require . register ( "node_modules/engine.io-client-f/lib/event-emitter.js" , function ( module , exports , require , global ) {
function ( val ) { var code = val . replace ( regs . compile . only , '$1' ) ; code = escapers . htmlEscape ( code ) ; code = ";show('" + code + "');" ; code = simpleParse ( code ) ; str = str . replace ( regs . compile . first , function ( ) { return code ; } ) ; }
function ( val ) { var code = val . replace ( regs . simple . only , '$1' ) ; code = escapers . htmlUnescape ( code ) ; code = escapers . simpleEscape ( code ) ; code = "'+(" + code + ")+'" ; str = str . replace ( regs . simple . first , function ( ) { return code ; } ) ; }
function matchRule ( req , rule ) { return req . url . match ( rule ) ; }
function ( cssSelector , callback ) { var self = this ; self . element ( "css selector" , cssSelector , function ( result ) { if ( result . status == 0 ) { self . elementIdClick ( result . value . ELEMENT , function ( result ) { if ( typeof callback === "function" ) { callback ( ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result ) ; } } } ) ; }
function ( ctrlSeq ) { var cmdKlass = LatexCmds [ ctrlSeq ] ; if ( cmdKlass ) { return cmdKlass ( ctrlSeq ) . parser ( ) ; } else { var textBlock = TextBlock ( ) ; textBlock . replaces ( ctrlSeq ) ; return textBlock ; } }
function ( two ) { var one = this ; two = ensureFunction ( two ) ; return one . then ( function ( result ) { return ensureParser ( two ( result ) ) . then ( function ( ) { return ensureParser ( result ) ; } ) ; } ) ; }
function timesReverse ( self , n ) { if ( n === 0 ) return ensureParser ( [ ] ) ; return self . then ( function ( x ) { return timesReverse ( self , n - 1 ) . then ( accumulate ( x ) ) } ) ; }
function , pipes the value in and uses that return value
function ( ) { var parser = string ( 'x' ) . skip ( string ( 'y' ) ) ; assert . equal ( parser . parse ( 'xy' ) , 'x' ) ; assert . throws ( function ( ) { parser . parse ( 'x' ) ; } ) ; }
function , uses the previous return value
function ( x ) { piped = x ; return string ( 'y' ) ; }
function ( idProp , collection , data , callback ) { if ( idProp && data [ idProp ] && parseInt ( data [ idProp ] , 10 ) > 0 ) { var id = data [ idProp ] ; delete data [ idProp ] ; this . _updateRecord ( collection , idProp , data , id , callback ) ; } else { this . _insertRecord ( collection , data , callback ) ; } }
function ( collection , data , callback ) { return helpers . createSqlInsert ( { table : this . _collectionToTable ( collection ) , escape : this . _escapeId , info : helpers . escapeInsertFields ( data , { date_convert_fmt : "FROM_UNIXTIME(?)" , boolean_convert : this . _booleanToSqlValue } ) , orm : this . _orm , data : data , db : this . _client , callback : helpers . handleSqlInsertCall ( callback ) } ) ; }
function ( collection , idProp , data , id , callback ) { return helpers . createSqlUpdate ( { table : this . _collectionToTable ( collection ) , key : idProp , id : id , escape : this . _escapeId , info : helpers . escapeUpdateFields ( data , this . _escapeId , { date_convert_fmt : "FROM_UNIXTIME(?)" , boolean_convert : this . _booleanToSqlValue } ) , db : this . _client , callback : helpers . handleSqlUpdateCall ( callback ) } ) ; }
function ( e ) { e . preventDefault ( ) ; if ( self . flags . river_view ) { self . mark_folder_as_read ( ) ; } else { self . mark_feed_as_read ( ) ; } }
function ( data ) { $error . show ( ) . html ( ( data && data . message ) || "There was a problem fetching the feed from this URL." ) ; $loading . removeClass ( 'NB-active' ) ; $submit . removeClass ( 'NB-disabled' ) . attr ( 'value' , 'Parse this RSS/XML Feed' ) ; }
function ( data ) { $error . show ( ) . html ( ( data && data . message ) || "There was a problem fetching the feed from this URL." ) ; $loading . removeClass ( 'NB-active' ) ; $submit . removeClass ( 'NB-disabled' ) . attr ( 'value' , 'Fetch Feed from Website' ) ; }
function ( position ) { if ( this . _sliderLeft <= 0 ) { var x = this . _getElementPosition ( this . element ) . left ; if ( x > 0 ) { this . _sliderLeft = x ; } } var positionX = ( position - ( this . _sliderLeft + InputRange . HANDLE_ADJUST ) ) ; if ( positionX < 0 ) { positionX = 0 ; } this . _positionX = positionX ; }
function ( ) { this . _sliderWidth = this . element . offsetWidth - ( 1.5 * InputRange . HANDLE_ADJUST ) ; var x = this . _getElementPosition ( this . element ) . left ; if ( x > 0 ) { this . _sliderLeft = x ; } if ( ! this . _valueSyncedWithPosition ) { this . _calculatePositionFromValue ( ) ; } }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( response ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } return response ; }
function ( self ) { var item = declaration [ key ] ; var Repository = item [ 'repository' ] || EntityRepository ; var repository = self . create ( Repository , item ) ; repository . Entity = item [ 'entity' ] || Entity ; if ( typeof repository . Entity !== 'function' ) { throw new Error ( 'Invalid entity constructor for the repository \'' + key + '\'' ) ; } return repository ; }
function ( block ) { if ( DEBUG_WIRE ) { console . group ( "root " + block + ":" + getBehavior ( block ) ) ; } if ( getBehavior ( block ) === Circuit . behaviors . junction ) { if ( DEBUG_WIRE ) { console . groupEnd ( ) ; } return ; } traceIntoNode ( null , block , null ) ; if ( DEBUG_WIRE ) { console . groupEnd ( ) ; } }
function ( req , res , next ) { console . log ( "REQUEST" , util . inspect ( req , false , 4 , true ) ) ; next ( ) ; }
function Cache ( file , options ) { this . options = copy ( options ) ; this . options . maxAge || ( this . options . maxAge = 300 ) ; this . file = file ; this . mime = mime . lookup ( this . file ) ; this . buf = fs . readFileSync ( file ) ; if ( /^text\// . exec ( mime ) ) { this . gzip ( ) ; } this . buildHeaders ( ) ; }
function ( ) { res . writeHead ( 404 , { 'Content-Type' : 'text/plain' } ) ; res . write ( 'file not found' ) ; res . end ( ) ; }
function ( file ) { var pattern = /<!ENTITY\s(.*?)[\s]+\"(.*?)\">/g ; var URL = file ; var req = new XMLHttpRequest ( ) ; req . overrideMimeType ( 'text/plain' ) ; req . open ( 'GET' , URL , false ) ; req . send ( null ) ; if ( req . status == 0 ) { var result ; while ( result = pattern . exec ( req . responseText ) ) { strings . values [ result [ 1 ] ] = result [ 2 ] ; } } }
function ( ) { var transport = nodemailer . createTransport ( "sendmail" , { path : "/usr/local/bin/sendmail" , args : [ "-f online@southern.edu" ] } ) ; var mailOptions = { from : "online@southern.edu" , to : email , subject : "Online Campus Suport - Chat Transcript" , generateTextFromHTML : true , html : chatTranscript } console . log ( mailOptions ) ; console . log ( chatTranscript ) ; return 'Email response successfull!\nEmail to: ' + email + '\nEmail text: \n' + chatTranscript ; }
function ( pos ) { var locs = locationList ; var toReturn ; for ( var i = 0 ; i < args . length ; i ++ ) { if ( i === pos ) { toReturn = locs . first ( ) ; } locs = locs . rest ( ) ; } return toReturn ; }
function ( aState , str ) { check ( aState , aState , str , isString , 'string->list' , 'string' , 1 ) ; var lst = types . EMPTY ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { lst = types . cons ( types [ 'char' ] ( str . charAt ( i ) ) , lst ) ; } aState . v = lst ; }
function ( aState , formatStr , args ) { check ( aState , aState , formatStr , isString , 'format' , 'string' , 1 , [ formatStr ] . concat ( args ) ) ; aState . v = types . string ( helpers . format ( formatStr , args , 'format' ) ) ; }
function ( state , formatStr , args ) { check ( aState , aState , formatStr , isString , 'printf' , 'string' , 1 , [ formatStr ] . concat ( args ) ) ; var msg = helpers . format ( formatStr , args , 'printf' ) ; state . getDisplayHook ( ) ( msg ) ; state . v = types . VOID ; }
function ( aState , str ) { check ( aState , aState , str , isString , 'explode' , 'string' , 1 ) ; var ret = types . EMPTY ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { ret = types . cons ( types . string ( str . charAt ( i ) ) , ret ) ; } aState . v = ret ; }
function ( aState , str ) { check ( aState , aState , str , isString , 'string-lower-case?' , 'string' , 1 ) ; var primStr = str . toString ( ) ; aState . v = isAlphabeticString ( str ) && primStr . toLowerCase ( ) === primStr ; }
function ( aState , str ) { check ( aState , aState , str , isString , 'string-upper-case?' , 'string' , 1 ) ; var primStr = str . toString ( ) ; aState . v = isAlphabeticString ( str ) && primStr . toUpperCase ( ) === primStr ; }
function ( k ) { check ( aState , aState , k , isNatural , 'make-bytes' , 'non-negative exact integer' , 1 ) ; var ret = [ ] ; for ( var i = 0 ; i < jsnums . toFixnum ( k ) ; i ++ ) { ret . push ( 0 ) ; } return types . bytes ( ret , true ) ; }
function ( k , b ) { check ( aState , aState , k , isNatural , 'make-bytes' , 'non-negative exact integer' , 1 , arguments ) ; check ( aState , aState , b , isByte , 'make-bytes' , 'byte' , 2 , arguments ) ; var ret = [ ] ; for ( var i = 0 ; i < jsnums . toFixnum ( k ) ; i ++ ) { ret . push ( b ) ; } return types . bytes ( ret , true ) ; }
function ( aState , bstr ) { check ( aState , aState , bstr , isByteString , 'bytes->immutable-bytes' , 'byte string' , 1 ) ; if ( bstr . mutable ) { aState . v = bstr . copy ( false ) ; return ; } else { aState . v = bstr ; } }
function ( data ) { json = eval ( '(' + data + ')' ) ; plot ( json . data ) ; $ ( '#analytics-new-messages-range' ) . html ( v ) ; $ ( '#analytics-new-messages-range-type' ) . html ( range_type ) ; $ ( "#analytics-new-messages-update-loading" ) . hide ( ) ; }
function ( data ) { json = eval ( '(' + data + ')' ) ; count = $ ( ".health-throughput-current" ) ; count . html ( json . count ) ; count . fadeOut ( 200 , function ( ) { count . fadeIn ( 200 ) ; } ) ; }
function ( data ) { mqjson = eval ( '(' + data + ')' ) ; mqcount = $ ( ".health-mqsize-current" ) ; mqcount . html ( mqjson . count ) ; mqcount . fadeOut ( 200 , function ( ) { mqcount . fadeIn ( 200 ) ; } ) ; }
function ( data ) { result = eval ( '(' + data + ')' ) ; if ( result . code == "success" ) { render_result ( success ( result . ms , result . content , result . op , result . result ) ) ; } else { render_result ( error ( result . reason ) ) ; } bindMessageSidebarClicks ( ) ; eternalize ( ) ; }
function ( responseText ) { var response = JSON . parse ( responseText ) ; builder . selenium2 . rcPlayback . sessionID = response . sessionId ; builder . selenium2 . rcPlayback . playResult . success = true ; builder . selenium2 . rcPlayback . playNextStep ( null ) ; }
function ( ) { builder . selenium2 . rcPlayback . requestStop = true ; jQuery ( '#edit-rc-playing' ) . hide ( ) ; jQuery ( '#edit-rc-stopping' ) . show ( ) ; }
function ( responseText ) { var response = JSON . parse ( responseText ) ; if ( response . value . indexOf ( builder . selenium2 . rcPlayback . param ( "text" ) ) != - 1 ) { builder . selenium2 . rcPlayback . recordResult ( { success : true } ) ; } else { builder . selenium2 . rcPlayback . recordResult ( { success : false , message : "Text not present." } ) ; } }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . width = bb . innerWidth ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-left' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . width = bb . innerWidth ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-right' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . height = bb . innerHeight ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-up' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . height = bb . innerHeight ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-down' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . width = bb . innerWidth ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-left' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . width = bb . innerWidth ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-right' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . height = bb . innerHeight ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-up' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . height = bb . innerHeight ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-down' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . width = bb . innerWidth ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-left' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . width = bb . innerWidth ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-right' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . height = bb . innerHeight ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-up' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( screen ) { var r = 0 , duration = 0.3 , timing = 'ease-out' , s = screen . style ; s . height = bb . innerHeight ( ) + 'px' ; s [ '-webkit-animation-name' ] = 'bbUI-slide-down' ; s [ '-webkit-animation-duration' ] = duration + 's' ; s [ '-webkit-animation-timing-function' ] = timing ; s [ '-webkit-transform' ] = 'translate3d(0,0,0)' ; s [ '-webkit-backface-visibility' ] = 'hidden' ; }
function ( request , response ) { var parsed = parseQuotas ( response . GROUP ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . VM ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . DATASTORE ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . IMAGE ) ; $ ( '.current_quotas table tbody' , $group_quotas_dialog ) . append ( parsed . NETWORK ) ; }
function updateGroupsView ( request , group_list ) { group_list_json = group_list ; var group_list_array = [ ] ; $ . each ( group_list , function ( ) { group_list_array . push ( groupElementArray ( this ) ) ; } ) ; updateView ( group_list_array , dataTable_groups ) ; updateGroupSelect ( group_list ) ; SunstoneMonitoring . monitor ( 'GROUP' , group_list ) updateSystemDashboard ( "groups" , group_list ) ; }
function ( ) { var uname = getValue ( $ ( this ) . val ( ) , 4 , 2 , dataTable_images ) ; $ ( 'input#IMAGE_UNAME' , section_disks ) . val ( uname ) ; var target = getValue ( $ ( this ) . val ( ) , 4 , 12 , dataTable_images ) ; if ( target && target != "--" ) $ ( 'input#TARGET' , section_disks ) . val ( target ) ; else $ ( 'input#TARGET' , section_disks ) . val ( '' ) ; }
function ( request , response ) { var parsed = parseQuotas ( response . USER ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . VM ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . DATASTORE ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . IMAGE ) ; $ ( '.current_quotas table tbody' , $user_quotas_dialog ) . append ( parsed . NETWORK ) ; }
function ( monitoring ) { $ ( '#totalUsers' , $dashboard ) . text ( monitoring [ 'totalUsers' ] ) var container = $ ( 'div#usersPerGroup' , $dashboard ) ; SunstoneMonitoring . plot ( 'USER' , 'usersPerGroup' , container , monitoring [ 'usersPerGroup' ] ) ; }
function updateUsersView ( request , users_list ) { var user_list_array = [ ] ; $ . each ( users_list , function ( ) { user_list_array . push ( userElementArray ( this ) ) ; } ) ; updateView ( user_list_array , dataTable_users ) ; SunstoneMonitoring . monitor ( 'USER' , users_list ) updateSystemDashboard ( "users" , users_list ) ; updateUserSelect ( ) ; }
function ( url , lineNumber , classes , tooltipText ) { var linkText = WebInspector . formatLinkText ( url , lineNumber ) ; var anchor = WebInspector . linkifyURLAsNode ( url , linkText , classes , false , tooltipText ) ; anchor . preferredPanel = "resources" ; anchor . lineNumber = lineNumber ; return anchor ; }
function ( ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( "GET" , "Logs/timeline_data" , false ) ; xhr . send ( null ) ; if ( xhr . status == 200 ) { console . log ( "Loading Timeline Data" ) ; var data = JSON . parse ( xhr . responseText ) ; WebInspector . timelinePanel . _model . reset ( ) ; WebInspector . timelinePanel . _model . _loadNextChunk ( data , 1 ) ; } }
function ( ) { this . running = true ; var self = this ; this . loop_id = setInterval ( function ( ) { var cycles = self . cycles ; while ( self . cycles < cycles + 10000 ) { self . run ( self . _read_memory ( self . PC ++ ) ) ; } self . draw ( ) ; if ( ! self . running ) { clearInterval ( self . loop_id ) ; } } , 20 ) ; }
function _init ( ) { if ( window . localStorage && window . sessionStorage ) { if ( _checkArgument ( 'Undefined' , window . RS ) ) { window . RS = { } ; } window . RS = { put : put , get : get , remove : remove , clear : clear , is : is } ; } else { throw new Error ( 'This browser have no storage.' ) ; } }
function _selectStorage ( flag ) { var storage ; if ( ! _checkArgument ( 'Boolean' , flag ) && flag !== undefined ) { throw new Error ( '2nd argument should be boolean' ) ; } else { storage = ( flag === true || flag === undefined ) ? localStorage : sessionStorage ; } return storage ; }
function put ( obj , flag ) { var storage = _selectStorage ( flag ) ; if ( _checkArgument ( 'Object' , obj ) && ! _checkArgument ( 'Array' , obj ) ) { for ( var i in obj ) { if ( obj . hasOwnProperty ( i ) ) { storage . setItem ( i , JSON . stringify ( obj [ i ] ) ) ; } } } else { throw new Error ( '1st argument should be object' ) ; } }
function get ( key , flag ) { var storage = _selectStorage ( flag ) , selectKey = storage . getItem ( key ) ; if ( _checkArgument ( 'String' , key ) ) { if ( selectKey ) { return JSON . parse ( selectKey ) ; } else { return console . log ( 'This key is not in storage' ) ; } } else { throw new Error ( '1st argument should be string' ) ; } }
function remove ( key , flag ) { var storage = _selectStorage ( flag ) , selectKey = storage . getItem ( key ) ; if ( _checkArgument ( 'String' , key ) ) { if ( selectKey ) { storage . removeItem ( key ) ; } else { console . log ( 'This key is not in storage' ) ; } } }
function is ( key , flag ) { var storage = _selectStorage ( flag ) , selectKey = storage . getItem ( key ) ; if ( _checkArgument ( 'String' , key ) ) { if ( selectKey ) { return true ; } else { return false ; } } else { throw new Error ( '1st argument should be strings' ) ; } }
function ( ) { var data = { alpha_a : { id : 'alpha_a' , type : 'test_a' , name : 'arnold' } } ; var a = Common . entity . create ( { type : 'test_a' } ) ; var parsed = a . parse ( data ) ; assert . equal ( parsed . id , 'alpha_a' ) ; }
function ( err , keys ) { var config = Common . config . sync . redis ; var key = config . key_prefix + ':' + config . uuid . key ; assert . equal ( key , _ . difference ( keys , initialKeys ) [ 0 ] ) ; assert . equal ( initialCount , keys . length - 1 ) ; done ( ) ; }
function confirmAllDestroyed ( err , keys ) { var config = Common . config . sync . redis ; var key = config . key_prefix + ':' + config . uuid . key ; assert . equal ( key , _ . difference ( keys , initialKeys ) [ 0 ] ) ; assert . equal ( initialCount , keys . length - 1 ) ; done ( ) ; }
function ( ) { equals ( true , Modernizr . testProp ( 'margin' ) , 'Everyone supports margin' ) ; equals ( false , Modernizr . testProp ( 'happiness' ) , 'Nobody supports the happiness style. :(' ) ; equals ( 'pointerEvents' in document . createElement ( 'div' ) . style , Modernizr . testProp ( 'pointerEvents' ) , 'results for `pointer-events` are consistent with a homegrown feature test' ) ; }
function ( ) { equals ( true , Modernizr . testAllProps ( 'margin' ) , 'Everyone supports margin' ) ; equals ( false , Modernizr . testAllProps ( 'happiness' ) , 'Nobody supports the happiness style. :(' ) ; equals ( Modernizr . csstransitions , Modernizr . testAllProps ( 'transition' ) , 'Modernizr result matches API result: csstransitions' ) ; equals ( Modernizr . csscolumns , Modernizr . testAllProps ( 'columnCount' ) , 'Modernizr result matches API result: csscolumns' ) }
function ( test ) { var clip = require ( "clipboard" ) ; var flavor = "image" ; var fullFlavor = "image/png" ; var base64Data = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAQ0lEQVRYhe3OwQkAIBTD0Oyqg7idbqUr9B9EhBRyLY8F+0akEyBAgIBvAI1eCuaIEiBAgAABzwH50sNqAgQIEPAYcABJQw5EXdmcNgAAAABJRU5ErkJggg==" ; var contents = "data:image/png;base64," + encodeURIComponent ( base64Data ) ; test . assert ( clip . set ( contents , flavor ) , "clipboard set" ) ; test . assertEqual ( clip . currentFlavors [ 0 ] , flavor , "flavor is set" ) ; console . log ( "" ) console . log ( contents ) console . log ( clip . get ( ) ) ff ( contents ) }
function ( ) { $ ( 'html' ) . on ( 'click.dropdown.data-api' , clearMenus ) $ ( 'body' ) . on ( 'click.dropdown.data-api' , toggle , Dropdown . prototype . toggle ) }
function ( options ) { options = $ . extend ( { } , $ . fn [ this . type ] . defaults , options , this . $element . data ( ) ) if ( options . delay && typeof options . delay == 'number' ) { options . delay = { show : options . delay , hide : options . delay } } return options }
function ( e ) { var self = $ ( e . currentTarget ) [ this . type ] ( this . _options ) . data ( this . type ) if ( ! self . options . delay || ! self . options . delay . show ) { self . show ( ) } else { self . hoverState = 'in' setTimeout ( function ( ) { if ( self . hoverState == 'in' ) { self . show ( ) } } , self . options . delay . show ) } }
function ( ) { var title , $e = this . $element , o = this . options title = $e . attr ( 'data-original-title' ) || ( typeof o . title == 'function' ? o . title . call ( $e [ 0 ] ) : o . title ) title = title . toString ( ) . replace ( /(^\s*|\s*$)/ , "" ) return title }
function ( ) { var $tip = this . tip ( ) , title = this . getTitle ( ) , content = this . getContent ( ) $tip . find ( '.popover-title' ) [ $ . type ( title ) == 'object' ? 'append' : 'html' ] ( title ) $tip . find ( '.popover-content > *' ) [ $ . type ( content ) == 'object' ? 'append' : 'html' ] ( content ) $tip . removeClass ( 'fade top bottom left right in' ) }
function ( ) { var content , $e = this . $element , o = this . options content = $e . attr ( 'data-content' ) || ( typeof o . content == 'function' ? o . content . call ( $e [ 0 ] ) : o . content ) content = content . toString ( ) . replace ( /(^\s*|\s*$)/ , "" ) return content }
function ( target ) { var active this . activeTarget = target this . $body . find ( this . selector ) . parent ( '.active' ) . removeClass ( 'active' ) active = this . $body . find ( this . selector + '[href="' + target + '"]' ) . parent ( 'li' ) . addClass ( 'active' ) if ( active . parent ( '.dropdown-menu' ) ) { active . closest ( 'li.dropdown' ) . addClass ( 'active' ) } }
function next ( ) { $active . removeClass ( 'active' ) . find ( '> .dropdown-menu > .active' ) . removeClass ( 'active' ) element . addClass ( 'active' ) if ( transition ) { element [ 0 ] . offsetWidth element . addClass ( 'in' ) } else { element . removeClass ( 'fade' ) } if ( element . parent ( '.dropdown-menu' ) ) { element . closest ( 'li.dropdown' ) . addClass ( 'active' ) } callback && callback ( ) }
function ( ) { var pos = $ . extend ( { } , this . $element . offset ( ) , { height : this . $element [ 0 ] . offsetHeight } ) this . $menu . css ( { top : pos . top + pos . height , left : pos . left } ) this . $menu . show ( ) this . shown = true return this }
function ( $1 , match ) { return '<strong>' + match + '</strong>' }
function ( e ) { e . stopPropagation ( ) e . preventDefault ( ) switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : this . hide ( ) break default : this . lookup ( ) } }
function ( e ) { e . stopPropagation ( ) if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : e . preventDefault ( ) this . prev ( ) break case 40 : e . preventDefault ( ) this . next ( ) break } }
function ( obj ) { this . knowPos ( obj , Infinity , Infinity ) ; }
function ( ) { this . modalview . hide ( ) ; this . container . find ( '*' ) . off ( ) ; this . container . html ( '' ) ; this . options . onClose . call ( this ) ; }
function ( ) { this . subscribe ( "entity/buy" , this . trackPurchase ) ; this . subscribe ( "player/level-up" , this . trackLevelUp ) ; this . subscribe ( "tutorial/done" , this . trackTutorialDone ) ; this . subscribe ( "enemy/kill" , this . trackEnemyKilled ) ; this . subscribe ( "contract/start" , this . trackContractStarted ) ; this . subscribe ( "contract/collect" , this . trackContractRewardCollected ) ; this . subscribe ( "castle/upgrade" , this . trackCastleUpgraded ) ; this . subscribe ( "game/ready" , this . beginTrackingUser ) ; }
function ( message ) { kontagent . trackEvent ( wooga . castle . playerData . kontagent_id , 'contract_started' , { 'subtype1' : message . entity . getProperName ( ) . replace ( /\s/g , '' ) . substring ( 0 , 32 ) } , function ( ) { } , function ( error ) { window . alert ( "Could not send contract_started EVT due to " + error ) ; } ) ; }
function ( tr , row_index ) { var classname = 'drop-into-' + row_index + '-' + col . id . split ( '-' ) [ 1 ] ; tr . down ( 'td' , col . up ( ) . childElements ( ) . indexOf ( col ) ) . select ( '.cardwall_board_postit' ) . invoke ( 'removeClassName' , classname ) ; }
function ( l , t ) { this . animate ( { left : l , top : t } , { queue : false } ) ; }
function ( b ) { return function ( ctx ) { var bi = b ( this . $ ) ; DU . qDraw ( ctx , bi . s , bi . f , function ( ) { ctx . arc ( 0 , 0 , radius , 0 , Math . PI * 2 , true ) ; } ) ; } }
function ( ) { var clone = new Element ( ) ; clone . name = this . name ; clone . children = this . children . slice ( 0 ) ; clone . sprite = this . sprite ; clone . _modifiers = this . _modifiers . slice ( 0 ) ; clone . _painters = this . _painters . slice ( 0 ) ; clone . xdata = obj_clone ( this . xdata ) ; clone . xdata . $ = clone ; return clone ; }
function ( value ) { if ( this . type != 'input' ) { if ( value != undefined ) this . element . innerHTML = value ; else return this . element . innerHTML ; } else { if ( value != undefined ) this . element . value = value ; else return this . element . value ; } }
function ( ) { EventEmitter . call ( this ) ; this . io = null ; this . socket = null ; this . country = 'US' ; this . pass = 'tryo' ; this . current_track = { } ; return this ; }
function ( t ) { try { this . socket . emit ( 'playmusic_order' , t ) ; } catch ( e ) { console . log ( e ) ; } this . current_track = t ; var timer = ( Math . round ( t . length ) + 1 ) * 1000 ; var timeoutId = setTimeout ( this . playing_is_finish . bind ( this , t ) , timer ) ; }
function ( json ) { $ ( "#" + viewName + "Jobs" ) . children ( "tr." + type ) . remove ( ) ; for ( job in json . jobs ) { $ ( "#" + viewName + "Jobs tr." + type + "-end" ) . after ( window [ viewName + subType + "WriteJob" ] ( json . jobs [ job ] , type ) ) ; } initChildRows ( type ) ; }
function initChildRows ( type ) { $ ( 'tr.parent.' + type ) . css ( "cursor" , "pointer" ) . attr ( "title" , "Click to expand/collapse" ) . click ( function ( ) { $ ( '#child-' + this . id ) . toggle ( ) ; } ) ; }
function ( ) { identifiers . push ( $ ( this ) . html ( ) ) ; var ident = $ ( this ) . html ( ) ; if ( ident . indexOf ( 'nla.party-' ) >= 0 ) { if ( ident . indexOf ( 'http://' ) == 0 ) { $ ( '#endlink' ) . prepend ( '<a href="' + ident + '">View the record for this Party in Trove</a><br/>' ) ; } else { $ ( '#endlink' ) . prepend ( '<a href="http://' + ident + '">View the record for this Party in Trove</a><br/>' ) ; } } }
function ( peak ) { var alpha = peak . strength * .5 + .5 ; var active = peak . active ? '255' : '0' ; g . fillStyle = 'rgba(255,' + active + ',0,' + alpha + ')' ; g . fillRect ( ( peak . offset - 2 ) * 8 , 140 , 1 , 100 ) ; }
function ( prop ) { if ( script ) { script . onload = script . onreadystatechange = script . onerror = null ; script . parentNode . removeChild ( script ) ; for ( prop in script ) { try { script [ prop ] = Null ; delete script [ prop ] ; } catch ( _e_ ) { } } script = Null ; } }
function gotoOfferManagement ( mime , data ) { if ( mime == "text/url" ) { window . location = data ; return ; } else if ( mime == "text/error" ) { if ( data == "invalid startDate" ) { toggleWarning ( "error_startDate" , true , "Ungültiges Datum!" ) ; } else if ( data == "invalid endDate" ) { toggleWarning ( "error_endDate" , true , "Ungültiges Datum!" ) ; } else if ( data == "order" ) { toggleWarning ( "error_startDate" , true , "Enddatum liegt vor dem Startdatum!" ) } return ; } }
function build ( name , properties ) { if ( ! definitions . hasOwnProperty ( name ) ) { throw new ReferenceError ( 'Object Not Defined' ) ; } var definition = cloner ( definitions [ name ] ) ; properties = properties || { } ; return merge ( definition , properties ) ; }
function ( before , after ) { before = describeValue ( before ) ; after = describeValue ( after ) ; console . log ( "Done" , before , after ) ; if ( before !== after ) { before += " ↦ " + after ; } $popup = showValue ( before , cursor . line , token . start , token . end , cmLinesNode , cm ) ; }
function onLineNumberClick ( event ) { var $elem = $ ( event . currentTarget ) ; var doc = DocumentManager . getCurrentDocument ( ) ; var location = { url : doc . url , lineNumber : $elem . index ( ) } ; Debugger . toggleBreakpoint ( location ) ; }
function unload ( ) { $ ( DocumentManager ) . off ( "currentDocumentChange" , onCurrentDocumentChange ) ; Hover . unload ( ) ; Parser . unload ( ) ; Breakpoint . unload ( ) ; Console . unload ( ) ; Debugger . unload ( ) ; $style . remove ( ) ; $ ( ".CodeMirror-gutter" ) . off ( "click" , "pre" , onLineNumberClick ) ; }
function ( aRequest , aContext , aStatusCode ) { this . originalListener . onStopRequest ( aRequest , aContext , aStatusCode ) ; try { let info = getRequestInfo ( aRequest , this ) ; RequestCache . pushData ( this . DOMWindow , info ) ; } catch ( e ) { console . exception ( e ) ; } finally { this . receivedData = null ; } }
function convertEmptyDropbox ( $dropBox , comment ) { $dropBox . detach ( function convertEmptyDropbox_internal ( ) { $ . single ( this ) . removeClass ( 'newCAAimage' ) . find ( 'input' ) . replaceWith ( $ . make ( 'div' ) . text ( comment ) ) . end ( ) . find ( 'br, .closeButton' ) . remove ( ) . end ( ) . find ( 'select' ) . prop ( 'disabled' , true ) ; } ) ; }
function ( index , client , displayType , width , params , colors , maxproducts , style ) { var url = "http://odst.co.uk/api/p20/p20.php?user=m&pwd=test&params[feed_id]=" + client + "&" + params + "&colors=" + colors + "&type=" + displayType + "&width=" + width + "&max=" + maxproducts + "&style=" + style + "&callback=ODST_P20.parseRequest&index=" + index + "&rand=23ss4322" ; var script = document . createElement ( 'script' ) ; script . setAttribute ( 'src' , url ) ; document . getElementsByTagName ( 'head' ) [ 0 ] . appendChild ( script ) ; }
function ( test ) { var success = ( test . result === ! test . todo ) ; if ( success && ++ this . collapsedMessages < this . MAX_COLLAPSED_MESSAGES ) { return ; } if ( this . collapsedMessages ) { this . _log ( { "result" : true , "todo" : false , "message" : "Elided " + this . collapsedMessages + " passes or known failures." } ) ; } this . collapsedMessages = 0 ; this . _log ( test ) ; }
function ( oldUser , newUser ) { $ ( '#u-' + oldUser . Name ) . replaceWith ( $ ( '#new-user-template' ) . tmpl ( { name : newUser . Name , hash : newUser . Hash } ) ) ; refreshUsers ( ) ; if ( oldUser . Name === this . name ) { addMessage ( 'Your name is now ' + newUser . Name , 'notification' ) ; updateCookie ( ) ; } else { addMessage ( oldUser . Name + '\'s nick has changed to ' + newUser . Name , 'notification' ) ; } }
function ( ) { var i = 0 ; for ( ; i < len ; i ++ ) { promises [ i ] = db . insertLink ( fixtures [ i ] ) ; } p . Promise . when ( promises ) . then ( spy , notCalled ) ; }
function ( linkPayload ) { var links = mongo . collection ( 'links' ) , promise = new p . Promise ( ) ; links . insert ( linkPayload , { safe : true } , function ( err , result ) { if ( err ) { promise . reject ( { message : 'Database error inserting into links database' , error : err , code : 500 } ) ; } else { promise . resolve ( true ) ; } } ) return promise ; }
function ( a , b ) { return _ . indexOf ( self . state . get ( 'columnsOrder' ) , a . id ) > _ . indexOf ( self . state . get ( 'columnsOrder' ) , b . id ) ; }
function ( a , b ) { return _ . indexOf ( self . state . get ( 'columnsOrder' ) , a . id ) > _ . indexOf ( self . state . get ( 'columnsOrder' ) , b . id ) ; }
function ( a , b ) { var dayDifference = ( a . _julianDayNumber - b . _julianDayNumber ) | 0 ; if ( dayDifference > 1 || dayDifference < - 1 ) { return dayDifference ; } dayDifference = ( a . _julianDayNumber - b . _julianDayNumber ) ; if ( dayDifference !== 0 ) { return dayDifference ; } return a . _secondsOfDay - b . _secondsOfDay ; }
function ( ) { var taiDate = new Date ( 'September 1, 2011 12:00:00' ) ; var taiJulianDate = JulianDate . fromDate ( taiDate , TimeStandard . TAI ) ; var utcDate = new Date ( 'September 1, 2011 11:59:26' ) ; var utcJulianDate = JulianDate . fromDate ( utcDate , TimeStandard . UTC ) ; expect ( taiJulianDate . equalsEpsilon ( utcJulianDate , CesiumMath . EPSILON20 ) ) . toEqual ( true ) ; }
function ( ) { var start = JulianDate . fromDate ( new Date ( 'July 4, 2011 12:00:00 UTC' ) ) ; var end = JulianDate . fromDate ( new Date ( 'July 5, 2011 12:01:00 UTC' ) ) ; expect ( start . getSecondsDifference ( end ) ) . toEqualEpsilon ( TimeConstants . SECONDS_PER_DAY + TimeConstants . SECONDS_PER_MINUTE , CesiumMath . EPSILON5 ) ; }
function ( ) { var original = new JulianDate ( ) ; var clone = JulianDate . fromDate ( original . toDate ( ) ) ; clone = clone . addSeconds ( 0.01 ) ; expect ( original . equalsEpsilon ( clone , CesiumMath . EPSILON1 ) ) . toEqual ( true ) ; }
function ( ) { var leapSeconds = LeapSecond . leapSeconds ; var toFind = new LeapSecond ( JulianDate . fromDate ( new Date ( 'January 1, 1973 00:00:00 UTC' ) ) , 12.0 ) ; var index = binarySearch ( leapSeconds , toFind , LeapSecond . compareLeapSecondDate ) ; expect ( LeapSecond . leapSeconds [ index ] . offset ) . toEqual ( 12.0 ) ; }
function ( ) { var leapSeconds = LeapSecond . leapSeconds ; var toFind = new LeapSecond ( JulianDate . fromDate ( new Date ( 'July 1, 1972 00:00:00 UTC' ) ) , 0.0 ) ; var index = binarySearch ( leapSeconds , toFind , LeapSecond . compareLeapSecondDate ) ; expect ( leapSeconds [ index ] . julianDate ) . toEqual ( toFind . julianDate ) ; }
function ( result ) { console . log ( "Final Result : " + result ) ; if ( result == "OK" ) GoogleReader . postData ( url , data , callback ) ; }
function ( id , callback ) { var url = '/blocks/exists.json' ; var params = { } ; if ( typeof id === 'string' ) params . screen_name = id ; else params . user_id = id ; this . get ( url , params , null , callback ) ; return this ; }
function ( data ) { var tokens = data . split ( '\n' ) ; tokens [ 0 ] += this . buffer ; while ( tokens . length > 1 ) { this . dispatch ( tokens . shift ( ) ) ; } this . buffer = tokens [ 0 ] ; }
function ( key , value , callback ) { this . data [ key ] = value ; if ( this . keyList ) this . keyList . push ( key ) ; fs . writeFile ( Path . join ( this . path , key ) , value , function ( err ) { if ( err ) throw err ; console . log ( 'Persisted ' + key ) ; callback ( ) ; return this ; } ) ; }
function ( err , data ) { if ( err ) { if ( err . errno == 2 ) { callback ( null ) ; return this ; } else { throw err ; } } this . data [ key ] = JSON . parse ( data ) ; callback ( this . data [ key ] ) ; }
function ( ctx , tmpl ) { if ( ctx . value ) { return tmpl . render ( this ) ; } else { return this . createDocumentFragment ( ) ; } }
function ( name , path , parameters ) { var options = { } ; parameters . forEach ( function ( p ) { options [ p . name ] = p . value ; } ) ; return new BlockNode ( name , path , options ) ; }
function ( ) { var exception ; try { ist ( textParameters ) ; } catch ( e ) { exception = e ; } expect ( typeof exception ) . toBe ( 'undefined' ) ; }
function ( subcontext , subtemplate , opt ) { return this . createDocumentFragment ( ) ; }
function ( index , elem ) { var options = core . getCommentedData ( elem ) ; jQuery ( 'input' , elem ) . datepicker ( { dateFormat : options . dateFormat , gotoCurrent : true , yearRange : options . highYear + '-' + options . lowYear , showButtonPanel : false , beforeShow : datePickerPostprocess , selectOtherMonths : true } ) ; }
function ( index , elem ) { var options = core . getCommentedData ( elem ) ; jQuery ( 'input' , elem ) . datepicker ( { dateFormat : options . dateFormat , gotoCurrent : true , yearRange : options . highYear + '-' + options . lowYear , showButtonPanel : false , beforeShow : datePickerPostprocess , selectOtherMonths : true } ) ; }
function ( err ) { var prefix = '[server.fontomas.font.download] (' + http . req . url + ') ' ; if ( err ) { callback ( prefix + ( err . stack || err ) ) ; return ; } callback ( prefix + 'File not found' ) ; }
function ( err ) { var prefix = '[server.static] (' + http . req . url + ') ' ; if ( err ) { callback ( prefix + ( err . stack || err ) ) ; return ; } callback ( prefix + 'File not found' ) ; }
function ( ) { var agree = confirm ( option_tree . activate_layout_agree ) ; if ( agree ) { $ ( '#option-tree-options-layouts-form' ) . submit ( ) ; } else { var active = $ ( '#the_current_layout' ) . attr ( 'value' ) ; $ ( '#option-tree-options-layouts-form select option[value="' + active + '"]' ) . attr ( { 'selected' : 'selected' } ) ; } }
function ( data ) { if ( ! data . error ) { if ( p != 1 ) $ ( "<li><hr/></li>" ) . addClass ( "divider" ) . appendTo ( versionContainer ) ; data . commits . forEach ( function ( commit ) { $ ( "<li/>" ) . text ( commit . message ) . appendTo ( versionContainer ) ; } ) ; loadCommitPage ( p + 1 ) ; } }
function ( success , templates ) { if ( success ) { renderMenu ( templates ) ; } else { debug . error ( 'Could not get the group templates' ) ; } }
function identify ( location , type , rootPath , jetpackPath ) { return stripExtension ( type === 'local' ? relativify ( path . relative ( rootPath , location ) ) : type === 'external' ? relativify ( path . relative ( rootPath , location ) ) : type === 'std' ? path . relative ( path . join ( rootPath , 'lib' ) , location ) : type === 'system' ? location : type === 'deprecated' ? location : null ) ; }
function ( ) { var tok = lexer . __assembleToken__ ( ) ; expect ( tok . type ) . toEqual ( Hyper . TokenType . NUMBER ) ; expect ( tok . specialToken ) . toBeDefined ( ) ; expect ( tok . specialToken . type ) . toEqual ( Hyper . TokenType . WHITESPACE ) ; expect ( tok . specialToken . specialToken ) . toBeDefined ( ) ; expect ( tok . specialToken . specialToken . type ) . toEqual ( Hyper . TokenType . COMMENT ) ; }
function ( ) { return ( this . type == Token . LINE_TERM && ( this . text == null || this . text == '' ) ) || ( this . type == Token . ID && this . text != null && this . text == "__END__" ) ; }
function ( renderedElement ) { regionEl . parentNode . replaceChild ( renderedElement , regionEl ) ; }
function updateWorksheet ( oldTitle , newTitle , cells ) { var URL ; for ( var key in graphCollection . worksheets ) { if ( graphCollection . worksheets [ key ] . title == oldTitle ) URL = graphCollection . worksheets [ key ] . URL ; } graphCollection . removeWorksheet ( oldTitle ) ; addWorksheet ( newTitle , cells ) ; exampleSpreadsheets [ exampleSpreadsheets . length - 1 ] . worksheets [ 0 ] . URL = URL ; constructVis ( ) ; }
function updateWorksheet ( oldTitle , newTitle , cells ) { var URL ; for ( var key in graphCollection . worksheets ) { if ( graphCollection . worksheets [ key ] . title == oldTitle ) URL = graphCollection . worksheets [ key ] . URL ; } graphCollection . removeWorksheet ( oldTitle ) ; addWorksheet ( newTitle , cells ) ; exampleSpreadsheets [ exampleSpreadsheets . length - 1 ] . worksheets [ 0 ] . URL = URL ; constructVis ( ) ; }
function ( d ) { return $ ( '#checkboxHideData' ) . attr ( 'checked' ) != "checked" && ( d . y + graph . baseLine ) < graph . h && d . x >= 0 && d . x <= graph . w ; }
function ( model , created ) { var a , alias , b , contents , _results ; assert . isObject ( model ) ; assert . isObject ( created ) ; _results = [ ] ; for ( alias in model ) { contents = model [ alias ] ; a = created [ alias ] ; b = contents ; _results . push ( assert . equal ( a , b ) ) ; } return _results ; }
function ( model , created ) { var a , alias , b , contents , _results ; assert . isObject ( model ) ; assert . isObject ( created ) ; _results = [ ] ; for ( alias in model ) { contents = model [ alias ] ; a = created [ alias ] ; b = contents ; _results . push ( assert . equal ( a , b ) ) ; } return _results ; }
function ( router , context ) { return { query : context } ; }
function ( ) { set ( this , 'location' , get ( this , 'location' ) || window . location ) ; set ( this , 'callbacks' , Ember . A ( ) ) ; }
function ( path ) { var state = window . history . state ; if ( path === "" ) { path = '/' ; } if ( ( ! state && path !== '/' ) || ( state && state . path !== path ) ) { window . history . pushState ( { path : path } , null , path ) ; } }
function ( key , value ) { var parentView , controller ; if ( arguments . length === 2 ) { return value ; } if ( VIEW_PRESERVES_CONTEXT ) { if ( controller = get ( this , 'controller' ) ) { return controller ; } parentView = get ( this , '_parentView' ) ; if ( parentView ) { return get ( parentView , '_context' ) ; } } return this ; }
function ( event , context ) { Ember . assert ( 'Cannot send event "' + event + '" while currentState is ' + get ( this , 'currentState' ) , get ( this , 'currentState' ) ) ; if ( arguments . length === 1 ) { context = { } ; } return this . sendRecursively ( event , get ( this , 'currentState' ) , context ) ; }
function updateNoteDisplay ( data ) { previousNoteID = data . id ; moveNoteToPrevious ( data . content ) ; deleteNoteButton . attr ( "disabled" , "" ) ; }
function ( err , results ) { var out = '<html><head><title>Metrics</title></head><body>' ; for ( i in results ) { for ( resname in results [ i ] ) { out += "<strong>" + resname + ":</strong> " + results [ i ] [ resname ] + "<br>" ; } } out += "</body><html>" res . send ( out ) ; }
function ( memo , num ) { return memo + num ; }
function ( model , value , options ) { XT . log ( "Model changed: " + JSON . stringify ( model . toJSON ( ) ) ) ; if ( model . get ( "type" ) !== this . getModelType ( ) ) { return ; } XT . addToHistory ( model ) ; this . $ . workspacePanels . updateFields ( model ) ; }
function ( modelType ) { if ( modelType && modelType . indexOf ( "Info" ) >= 0 ) { modelType = modelType . substring ( 0 , modelType . length - 4 ) ; } if ( modelType && modelType . indexOf ( "XM" ) >= 0 ) { modelType = modelType . substring ( 3 ) ; } return modelType ; }
function ( pageId ) { var page = $ ( pageId ) ; if ( page ) { if ( ! iui . busy ) { iui . busy = true ; var index = pageHistory . indexOf ( pageId ) ; var backwards = index != - 1 ; if ( backwards ) { pageHistory . splice ( index ) ; } iui . showPage ( page , backwards ) ; } } }
function ( ) { if ( ! iui . busy ) { iui . busy = true ; pageHistory . pop ( ) ; var pageID = pageHistory . pop ( ) ; var page = $ ( pageID ) ; iui . showPage ( page , true ) ; } }
function ( pageId ) { var page = $ ( pageId ) ; if ( page ) { if ( ! iui . busy ) { iui . busy = true ; var index = pageHistory . indexOf ( pageId ) ; var backwards = index != - 1 ; if ( backwards ) log ( "error: can't replace page with ancestor" ) ; pageHistory . pop ( ) ; iui . showPage ( page , false ) ; } } }
function unselect ( ) { link . removeAttribute ( "selected" ) ; }
function ( options , html ) { var _ref , _ref1 ; return $ ( ( _ref1 = options . html ) != null ? _ref1 : html ) . addClass ( options . classes . concat ( ' groutip' ) ) . css ( ( _ref = options . css ) != null ? _ref : { } ) ; }
function ( e ) { e . stopPropagation ( ) ; }
function ( onAccept , onDecline ) { var buttons = settings . find ( '#eula_buttons' ) . show ( ) ; buttons . find ( '#accept' ) . unbind ( ) . click ( onAccept ) ; buttons . find ( '#decline' ) . unbind ( ) . click ( onDecline ) ; }
function ( ) { if ( listOverlay ) listOverlay . hide ( ) ; that . view . find ( '#header #searchbar' ) . show ( ) ; selecterDiv . unbind ( 'webkitTransitionEnd' ) . hide ( ) ; selecterDiv . css ( 'zIndex' , '' ) ; selecterDiv . prev ( ) . css ( 'zIndex' , '' ) ; that . showingListSelector = false ; }
function ( e ) { var onSlideBack = function ( ) { $j ( '#detailpage' ) . css ( 'visibility' , 'hidden' ) ; listView . resetSelectedContact ( ) ; } $j ( '#detailpage .header #left' ) . unbind ( ) ; if ( useAnimations ) { $j ( '#detailpage' ) . changePage ( '#listpage' , true , onSlideBack ) ; } else { $j ( '#detailpage' ) . hide ( ) ; $j ( '#listpage' ) . show ( ) . css ( 'visibility' , '' ) ; onSlideBack ( ) ; } updateLastVisitLoc ( ) ; }
function ( e ) { e . stopPropagation ( ) ; }
function ( onAccept , onDecline ) { var buttons = settings . find ( '#eula_buttons' ) . show ( ) ; buttons . find ( '#accept' ) . unbind ( ) . click ( onAccept ) ; buttons . find ( '#decline' ) . unbind ( ) . click ( onDecline ) ; }
function ( e ) { e . stopPropagation ( ) ; }
function ( onAccept , onDecline ) { var buttons = settings . find ( '#eula_buttons' ) . show ( ) ; buttons . find ( '#accept' ) . unbind ( ) . click ( onAccept ) ; buttons . find ( '#decline' ) . unbind ( ) . click ( onDecline ) ; }
function ( ) { if ( listOverlay ) listOverlay . hide ( ) ; that . view . find ( '#header #searchbar' ) . show ( ) ; selecterDiv . unbind ( 'webkitTransitionEnd' ) . hide ( ) ; selecterDiv . css ( 'zIndex' , '' ) ; selecterDiv . prev ( ) . css ( 'zIndex' , '' ) ; that . showingListSelector = false ; }
function ( event ) { if ( that . is ( event . target ) ) { that . removeClass ( 'transitionSettings' ) . css ( vendor + 'TransitionProperty' , 'none' ) ; that . unbind ( 'webkitTransitionEnd' ) ; if ( typeof callback == 'function' ) callback ( ) ; } }
function ( listener ) { if ( ( /AppleWebKit/i ) . test ( navigator . appVersion ) && "orientation" in window && "onorientationchange" in window ) { this . bind ( 'orientationchange' , listener ) ; } else { $j ( window ) . resize ( listener ) ; } return this ; }
function ( listener ) { if ( ( /AppleWebKit/i ) . test ( navigator . appVersion ) && window . onorientationchange ) { this . unbind ( 'orientationchange' , listener ) ; } else { $j ( window ) . unbind ( 'resize' , listener ) ; } return this ; }
function ( ) { if ( listOverlay ) listOverlay . hide ( ) ; that . view . find ( '#header #searchbar' ) . show ( ) ; selecterDiv . unbind ( 'webkitTransitionEnd' ) . hide ( ) ; selecterDiv . css ( 'zIndex' , '' ) ; selecterDiv . prev ( ) . css ( 'zIndex' , '' ) ; that . showingListSelector = false ; }
function addClickListeners ( ) { $j ( '#listpage #footer #gear' ) . unbind ( ) . touch ( function ( e ) { e . preventDefault ( ) ; splitView . focusOutContactList ( ) ; setTimeout ( SettingsManager . show , 10 ) ; } ) ; $j ( '#listpage #footer #home' ) . unbind ( ) . touch ( function ( e ) { e . preventDefault ( ) ; splitView . focusOutContactList ( ) ; showContactNews ( null , true ) ; } ) ; }
function codeAddressOnMap ( address ) { var encodedAdd = encodeURI ( address ) ; var mapsImage = '<img src="http://maps.googleapis.com/maps/api/staticmap?' + 'zoom=14&size=640x180&format=jpeg&sensor=false&markers=color:red%7C' + encodedAdd + '"/>' ; $j ( '#map_section #map_div #google_map_canvas' ) . empty ( ) . append ( mapsImage ) ; $j ( '#map_section #map_div #openMaps' ) . unbind ( ) . click ( function ( ) { window . location = ( ( typeof PhoneGap != 'undefined' && PhoneGap ) ? 'maps:q=' : 'https://maps.google.com/maps?q=' ) + encodedAdd ; } ) ; }
function addClickListeners ( ) { $j ( "#listpage #footer #gear" ) . unbind ( ) . touch ( function ( a ) { a . preventDefault ( ) ; splitView . focusOutContactList ( ) ; setTimeout ( SettingsManager . show , 10 ) } ) ; $j ( "#listpage #footer #home" ) . unbind ( ) . touch ( function ( a ) { a . preventDefault ( ) ; splitView . focusOutContactList ( ) ; showContactNews ( null , ! 0 ) } ) }
function ( ) { this . collection . on ( 'reset' , this . addAll , this ) ; this . collection . on ( 'add' , this . add , this ) ; this . collection . on ( 'remove' , this . removeItem , this ) ; YJ . dispatch . on ( 'switchList' , this . switchList , this ) ; }
function ( validityReport ) { console . log ( "The storyboard is not valid" ) ; console . log ( validityReport ) ; console . log ( JSON . stringify ( validityReport ) ) ; }
function ( e ) { var element ; element = e . target || e . srcElement ; globals . groupIndex = Number ( element . value ) ; globals . groupSelection = data . getUnique ( globals . groupIndex ) ; return _this . init ( ) ; }
function ( e ) { var selection ; selection = null ; ( $ ( '.xAxis_input' ) ) . each ( function ( ) { if ( this . checked ) { return selection = this . value ; } } ) ; globals . xAxis = selection ; return _this . update ( ) ; }
function ( dp ) { var _ref5 ; return _ref5 = String ( dp [ globals . groupIndex ] ) . toLowerCase ( ) , __indexOf . call ( globals . groupSelection , _ref5 ) >= 0 ; }
function ( game , owner , level , position , velocity , lifetime , damage , bounceCount ) { dotprod . entities . Projectile . call ( this , game , owner , level , lifetime , damage , bounceCount ) ; this . position_ = position ; this . velocity_ = velocity ; this . animation_ = game . getResourceManager ( ) . getVideoEnsemble ( 'bombs' ) . getAnimation ( level ) ; this . animation_ . setRepeatCount ( - 1 ) ; }
function ( ) { if ( this . bounceCount_ == 0 ) { this . velocity_ = new dotprod . Vector ( 0 , 0 ) ; this . lifetime_ = 0 ; this . explode_ ( ) ; } else if ( this . bounceCount_ > 0 ) { -- this . bounceCount_ ; } }
function ( destination , path , type_ , callback ) { var type = ( typeof ( type_ ) == 'string' ? type_ : null ) ; var callback_ = arguments [ arguments . length - 1 ] ; callback = ( typeof ( callback_ ) == 'function' ? callback_ : null ) ; if ( isWindows && type === 'junction' ) { destination = pathModule . _makeLong ( destination ) ; } binding . symlink ( destination , pathModule . _makeLong ( path ) , type , callback ) ; }
function ( data ) { var id = data . record . get ( "distributor_id" ) ; var rec = PartKeepr . getApplication ( ) . getDistributorStore ( ) . findRecord ( "id" , id ) ; if ( rec ) { data . record . set ( "distributor_name" , rec . get ( "name" ) ) ; } }
function ( data ) { var id = data . record . get ( "manufacturer_id" ) ; var rec = PartKeepr . getApplication ( ) . getManufacturerStore ( ) . findRecord ( "id" , id ) ; if ( rec ) { data . record . set ( "manufacturer_name" , rec . get ( "name" ) ) ; } }
function ( editor , e , o ) { var header = this . headerCt . getHeaderAtIndex ( editor . colIdx ) ; var edit = this . editing . getEditor ( editor . record , header ) ; if ( editor . field == "prefixedValue" ) { var unit = PartKeepr . getApplication ( ) . getUnitStore ( ) . getById ( editor . record . get ( "unit_id" ) ) ; if ( unit ) { edit . field . setStore ( unit . prefixes ( ) ) ; } } }
function ( ) { _V_ ( this . model . attributes . uid ) . pause ( ) ; this . $el . find ( '.video-player' ) . remove ( ) ; this . $el . find ( '.vid-image' ) . show ( ) ; this . $el . find ( '.tout-deets' ) . show ( ) ; }
function ( results ) { for ( var metricName in results ) { resultMetricData = results [ metricName ] ; graphMetricData = graph . data [ metricName ] ; for ( var j = 0 ; j < results [ metricName ] . length ; j ++ ) { graphMetricData [ j ] = resultMetricData [ j ] ; } graph . data [ metricName ] = graphMetricData ; } graph . object . update ( ) ; metricData = null ; }
function ( ) { var $div = $ ( "<div><p><a></a></p></div>" ) . appendTo ( $ ( "body" ) ) ; $div . find ( "p" ) . renameElement ( "span" ) ; expect ( $div . find ( "span" ) . length == 1 ) . toBeTruthy ( ) ; $div . remove ( ) ; }
function ( dselectors , dcallback , dcontext , dmatching ) { if ( dselectors === selectors && dcallback === callback && dcontext === context && arrays_equal ( dmatching , matching ) ) { console . log ( dmatching , matching ) ; call_for_matching ( function ( value ) { value . die ( rest , dcallback , dcontext , extend_array ( dmatching , value ) ) } ) ; } this . off ( event_name , event_callback , this ) ; this . off ( 'backbrace:die:' + selectors , die , this ) ; }
function ( dselectors , dcallback , dcontext , dmatching ) { if ( dselectors === selectors && dcallback === callback && dcontext === context && arrays_equal ( dmatching , matching ) ) { console . log ( dmatching , matching ) ; call_for_matching ( function ( value ) { value . die ( rest , dcallback , dcontext , extend_array ( dmatching , value ) ) ; } ) ; } this . off ( event_name , event_callback , this ) ; this . off ( 'backbrace:die:' + selectors , die , this ) ; }
function ( pipe ) { return pipe . trim ( ) ; }
function ( message ) { if ( typeof ( message ) === "string" ) { message = JSON . parse ( message . data ) ; } var li = $ ( '<li class="message"></li>' ) ; li . append ( '<img src="' + message . picture_url + '" class="profile-image"/>' ) ; li . append ( '<h4 class="username">' + message . username + '</h4>' ) ; var p = $ ( '<p class="message-content"></p>' ) ; p . text ( message . message ) ; li . append ( p ) ; return li ; }
function ( ) { var to = { } ; var from = { arr : [ 'hello' , 'world' ] } ; var result = Y . mojito . util . metaMerge ( to , from ) ; OA . areEqual ( from , result , "result should be same as from" ) ; }
function ( ) { var to = { arr : [ 1 , 2 , 3 ] } ; var from = { arr : [ 'hello' , 'world' ] } ; var expected = { arr : [ 1 , 2 , 3 , 'hello' , 'world' ] } ; var result = Y . mojito . util . metaMerge ( to , from ) ; OA . areEqual ( expected . arr , result . arr , "result array should have added elements" ) ; }
function ( ) { var to = { 'content-type' : [ 'foo' ] } ; var from = { 'content-type' : [ 'bar' ] } ; var expected = { 'content-type' : [ 'bar' ] } ; var result = Y . mojito . util . metaMerge ( to , from ) ; OA . areEqual ( expected [ 'content-type' ] , result [ 'content-type' ] , "result array should have been overridden" ) ; }
function ( asObject ) { var clonedObj = jQuery ( this . obj [ 0 ] . outerHTML ) ; clonedObj . find ( '.aloha-cleanme' ) . remove ( ) ; this . removePlaceholder ( clonedObj ) ; PluginManager . makeClean ( clonedObj ) ; return asObject ? clonedObj . contents ( ) : contentSerializer ( clonedObj [ 0 ] ) ; }
function ( module_name , filename , options ) { var file_contents , pathed_file ; if ( contains ( RESERVED , module_name ) ) { throw "module name cannot be a reservered word: " + module_name ; } pathed_file = mb . resolveSafe ( filename , options ) ; try { file_contents = fs . readFileSync ( pathed_file , 'utf8' ) ; } catch ( e ) { console . log ( "Couldn't bundle " + filename + ". Does it exist?" ) ; throw "Couldn't bundle " + filename + ". Does it exist?" ; } return "mb.require_define({\n  '" + module_name + "': function(exports, require, module) {\n" + file_contents + "\n}\n});\n" ; }
function ( module_name , filename , options ) { var file_contents , pathed_file ; if ( contains ( RESERVED , module_name ) ) { throw "module name cannot be a reservered word: " + module_name ; } pathed_file = mb . resolveSafe ( filename , options ) ; try { file_contents = fs . readFileSync ( pathed_file , 'utf8' ) ; } catch ( e ) { console . log ( "Couldn't bundle " + filename + ". Does it exist?" ) ; throw "Couldn't bundle " + filename + ". Does it exist?" ; } return "mb.require_define({\n  '" + module_name + "': function(exports, require, module) {\n" + file_contents + "\n}\n});\n" ; }
function Cookie ( req , options ) { this . path = '/' ; this . maxAge = null ; this . httpOnly = true ; if ( options ) utils . merge ( this , options ) ; Object . defineProperty ( this , 'req' , { value : req } ) ; this . originalMaxAge = undefined == this . originalMaxAge ? this . maxAge : this . originalMaxAge ; }
function ( ) { var returnKey = helper . cloneObj ( this . key ) ; if ( this . key . press ) { this . key . press = false ; } return returnKey ; }
function ( ) { var elem = this . element , sibHeight = 0 ; elem . siblings ( ":visible" ) . each ( function ( ) { sibHeight += $ ( this ) . outerHeight ( true ) ; } ) ; elem . height ( elem . parent ( ) . height ( ) - sibHeight - 1 ) ; this . _trigger ( "resize" , 0 , this ) ; }
function ( err , ls ) { if ( err ) abort ( 'Reading the version directory ' + n . sourceDir + ' failed. Sorry.' ) ; if ( ls . length == 0 ) abort ( 'No builds installed, yet.' ) ; ls . forEach ( function ( version ) { var del = ( version == current ) ? '> ' : '  ' ; console . log ( del + version ) ; } ) ; exit ( ) ; }
function ( err , real_version ) { if ( err ) return _cb ( new Error ( err . message + '. Couldn\'t get version number of latest. Please run `nodist - latest` and try again' ) ) ; fs . rename ( fetch_target , n . sourceDir + '/' + real_version + '.exe' , function ( err ) { if ( err ) return _cb ( new Error ( err . message + '. Couldn\'t rename latest. Please run `nodist - latest` and try again' ) ) ; _cb ( null , real_version ) ; } ) ; }
function ( err , ls ) { if ( err ) return cb ( err ) ; ls = ls . map ( function ( v ) { return v . replace ( /^(.+)\.exe$/ , '$1' ) ; } ) ; ls . sort ( function ( val1 , val2 ) { return nodist . compareable ( val1 ) > nodist . compareable ( val2 ) ? 1 : - 1 ; } ) ; return cb ( null , ls ) ; }
function updateClustersView ( request , list ) { var list_array = [ ] ; $ . each ( list , function ( ) { list_array . push ( clusterElementArray ( this ) ) ; } ) ; removeClusterMenus ( ) ; updateView ( list_array , dataTable_clusters ) ; updateClusterSelect ( ) ; updateInfraDashboard ( "clusters" , list ) ; newClusterMenu ( list ) ; }
function updateHostsView ( request , host_list ) { var host_list_array = [ ] ; $ . each ( host_list , function ( ) { host_list_array . push ( hostElementArray ( this ) ) ; } ) ; SunstoneMonitoring . monitor ( 'HOST' , host_list ) if ( typeof ( monitorClusters ) != 'undefined' ) monitorClusters ( host_list ) updateView ( host_list_array , dataTable_hosts ) ; updateHostSelect ( ) ; updateInfraDashboard ( "hosts" , host_list ) ; }
function ( jsonO ) { var method = builder . locator . methodForName ( builder . selenium2 , jsonO . type ) ; var values = { } ; values [ method ] = jsonO . value ; return new builder . locator . Locator ( method , values ) ; }
function ( e ) { jQuery ( '#' + step . id + '-p' + pIndex + '-locator-type-chooser' ) . val ( altName ) ; jQuery ( '#' + step . id + '-p' + pIndex + '-edit-input' ) . val ( altValue ) ; }
function _removePopUp ( $popUp ) { var initiallyInDOM = $popUp . data ( "initiallyInDOM" ) , removeHandler = $popUp . data ( "removeHandler" ) ; if ( removeHandler ) { removeHandler ( ) ; } if ( ! initiallyInDOM ) { $popUp . remove ( ) ; } }
function removePopUp ( $popUp ) { var idx = _popUps . indexOf ( $popUp [ 0 ] ) , initiallyInDOM = $popUp . data ( "initiallyInDOM" ) , removeHandler = $popUp . data ( "removeHandler" ) ; $popUp . off ( ".PopUpManager" ) ; _removePopUp ( $popUp ) ; if ( idx >= 0 ) { _popUps = _popUps . slice ( idx ) ; } }
function ( cell , record , column , data ) { cell . innerHTML = '<a href="' + record . getData ( 'url' ) + '" title="' + data + '">' + record . getData ( 'class_icon' ) + '</a>' + '&nbsp' + '<a href="' + record . getData ( 'url' ) + '" title="' + data + '">' + data + '</a>' ; }
function ( cell , record , column , data ) { var th = record . getData ( 'thumbnail_url' ) ; if ( th ) cell . innerHTML = '<div class="thumbview"><div id="thumbfield" class="thumbfield"></div><span><img src="' + th + '" /></span></div>' ; else cell . innerHTML = '' ; }
function ( error , artists ) { handle_similar_artists ( current_id , error , artists ) ; }
function play ( audio ) { if ( current_playing ) current_playing . pause ( ) ; current_playing = audio ; audio . play ( ) ; audio . addEventListener ( 'ended' , function ( ) { play ( last_loaded ) ; } ) ; }
function replace_cell ( id , track ) { var cell = document . getElementById ( cell_id ( id ) ) ; var audio = new Audio ( ) var image = new Image ( ) ; var other_loaded = false ; var component_loaded = function ( ) { if ( other_loaded ) cell_loaded ( cell , audio , image ) ; other_loaded = true ; } ; audio . addEventListener ( 'canplaythrough' , component_loaded ) ; image . onload = component_loaded ; audio . src = track . preview_url ; image . src = track . release_image ; }
function ( ) { echollage . collector . set_base_artist ( 'AR6XZ861187FB4CECD' ) ; echollage . display . init ( ) ; setTimeout ( update , REQUEST_PERIOD ) ; }
function ( ) { var REQUEST_PERIOD = 3000 ; function handle_track ( track ) { if ( track ) echollage . display . replace_next ( track ) ; } ; function update ( ) { echollage . collector . request_track ( handle_track ) ; setTimeout ( update , REQUEST_PERIOD ) ; } ; var start = function ( ) { echollage . collector . set_base_artist ( 'AR6XZ861187FB4CECD' ) ; echollage . display . init ( ) ; setTimeout ( update , REQUEST_PERIOD ) ; } ; return { start : start , } ; }
function ( file ) { if ( ! file . sUrl && file . result ) file . sUrl = file . result . data . url ; var fileData = queue . add ( file ) , id = fileData . id , index = queue . getFileIndex ( id ) , files = queue . get ( 'files' ) ; urlsInput . add ( file . sUrl ) ; queue . fileStatus ( index , 'success' , { index : index , id : id , file : fileData } ) ; }
function ( ) { uploader . restore ( ) ; theme . afterUploaderRender ( uploader ) ; self . fire ( 'init' , { uploader : uploader , button : uploader . get ( 'button' ) , queue : uploader . get ( 'queue' ) , auth : uploader . get ( 'auth' ) } ) ; }
function ( file ) { if ( ! file . sUrl && file . result ) file . sUrl = file . result . data . url ; var fileData = queue . add ( file ) , id = fileData . id , index = queue . getFileIndex ( id ) , files = queue . get ( 'files' ) ; urlsInput . add ( file . sUrl ) ; queue . fileStatus ( index , 'success' , { index : index , id : id , file : fileData } ) ; }
function ( ) { uploader . restore ( ) ; theme . afterUploaderRender ( uploader ) ; self . fire ( 'init' , { uploader : uploader , button : uploader . get ( 'button' ) , queue : uploader . get ( 'queue' ) , auth : uploader . get ( 'auth' ) } ) ; }
function ( firstUsedIndex , lastUsedIndex ) { this . pendingRequestCount ++ ; this . _api . __bridgeSend ( { type : 'shrinkSlice' , firstIndex : firstUsedIndex , firstSuid : this . items [ firstUsedIndex ] . id , lastIndex : lastUsedIndex , lastSuid : this . items [ lastUsedIndex ] . id , handle : this . _handle } ) ; }
function OmniBot ( name , connector , connection ) { var self = this ; this . name = name || "OmniOmniBot" ; connection . name = this . name ; switch ( connector ) { case "irc" : self . connection = new connectors . IRC ( connection ) ; break ; default : } }
function ( from , room , text , message ) { for ( var i = listeners . length - 1 ; i >= 0 ; i -- ) { var match = text . match ( listeners [ i ] . regex ) ; if ( match ) { listeners [ i ] . callback ( match , room , from ) ; } } ; }
function ( ) { var listeners = this . listeners ; this . connection . client . addListener ( 'message' , function ( from , room , text , message ) { for ( var i = listeners . length - 1 ; i >= 0 ; i -- ) { var match = text . match ( listeners [ i ] . regex ) ; if ( match ) { listeners [ i ] . callback ( match , room , from ) ; } } ; } ) ; }
function formatHex ( number , len ) { if ( typeof number === "undefined" || number == null || isNaN ( number ) ) { throw new Error ( "Invalid value \"" + number + "\" passed to formatHex()" ) ; } var str = number . toString ( 16 ) . toUpperCase ( ) ; if ( ! len ) { if ( str . length % 2 == 1 ) { len = str . length + 1 ; } } while ( str . length < len ) { str = "0" + str ; } return str ; }
function Pref ( user ) { this . username = user . getAttribute ( "username" ) ; this . personname = user . getAttribute ( "name" ) ; this . personnameLC = this . personname . toLowerCase ( ) ; this . affiliation = user . getAttribute ( "affiliation" ) ; this . contact = user . getAttribute ( "contact" ) ; }
function ( config ) { var script = document . createElement ( "script" ) ; if ( config . type !== undefined ) { script . type = config . type ; } else { script . type = "application/javascript" ; } if ( config . src !== undefined ) { script . src = config . src ; } if ( config . text !== undefined ) { script . text = config . text ; } document . head . appendChild ( script ) ; }
function md_init ( ) { this . getAllElements ( ) ; var elements = this . elements ; window . addEventListener ( 'mozbrowsershowmodalprompt' , this ) ; for ( var id in elements ) { if ( elements [ id ] . tagName . toLowerCase ( ) == 'button' ) { elements [ id ] . addEventListener ( 'click' , this ) ; } } }
function ( e ) { if ( e . keyCode === e . DOM_VK_ESCAPE && ! ModalDialog . blocked && ! e . defaultPrevented && displayedApp !== null ) { setDisplayedApp ( null ) ; } if ( e . keyCode === e . DOM_VK_ESCAPE && ModalDialog . blocked ) { ModalDialog . cancelHandler ( ) ; } }
function keyupHandler ( e ) { if ( e . keyCode !== e . DOM_VK_HOME ) return ; if ( ! keydown ) return ; keydown = false ; if ( timer !== null ) { clearInterval ( timer ) ; timer = null ; if ( ! ModalDialog . blocked && ! LockScreen . locked && ! e . defaultPrevented ) { if ( ! e . defaultPrevented ) setDisplayedApp ( null ) ; if ( CardsView . cardSwitcherIsShown ( ) ) CardsView . hideCardSwitcher ( ) ; } } e . stopPropagation ( ) ; }
function ( id , user ) { newusers [ user . nick ] = { nick : user . nick , x : user . x , y : user . y , direction : user . direction , score : 0 , color1 : "#FFBD24" , color2 : "#FFF700" } ; log ( newusers [ user . nick ] ) ; users [ id ] = newusers [ user . nick ] ; log ( newusers ) ; }
function ( value , row , column , index ) { var core = model . getPiece ( row , column ) ; var color = model . getSimulatedPiece ( row , column ) ; this . pieces [ index ] . update ( color , core ) ; }
function ( ) { this . transact ( ) ; if ( ! this . undoPossible ( ) ) { return ; } this . set ( this . historyWithCaret [ -- this . position - 1 ] ) ; this . editor . fire ( "undo:composer" ) ; }
function getProvider ( config ) { var providerPath = __dirname + "/" + ( configuration . providersPath || "provider" ) + "/" + config . type , ProviderConstructor ; try { ProviderConstructor = require ( providerPath ) ; } catch ( providerError ) { throw new Error ( "Cannot find provider '" + config . type + "' in the following location '" + providerPath + "'" ) ; } return new ProviderConstructor ( config ) ; }
function ( ) { for ( var i = fromPage ; i <= toPage ; i ++ ) data [ i * PAGESIZE ] = null ; onDataLoading . notify ( { from : from , to : to } ) ; req = $ . jsonp ( { url : url , callbackParameter : "callback" , cache : true , success : onSuccess , error : function ( ) { onError ( fromPage , toPage ) } } ) ; req . fromPage = fromPage ; req . toPage = toPage ; }
function ( ) { actions_in_progress [ $ ( this ) . attr ( 'data-uuid' ) ] = getActionType ( $ ( this ) ) ; packages_in_progress [ $ . trim ( $ ( this ) . find ( 'td.package_name' ) . html ( ) ) ] = true ; }
function ( ) { actions_in_progress [ $ ( this ) . attr ( 'data-uuid' ) ] = getActionType ( $ ( this ) ) ; packages_in_progress [ $ . trim ( $ ( this ) . find ( 'td.package_name' ) . html ( ) ) ] = true ; }
function ( ) { if ( $ . trim ( $ ( this ) . html ( ) ) === pkg_name ) { already_exists = true ; $ ( this ) . parent ( ) . attr ( 'data-uuid' , data ) ; $ ( this ) . parent ( ) . find ( 'td.package_action_status' ) . html ( '<img style="padding-right:8px;" src="images/embed/icons/spinner.gif">' + i18n . adding_package ) ; } }
function ( ) { if ( $ . trim ( $ ( this ) . html ( ) ) === group_name ) { already_exists = true ; $ ( this ) . parent ( ) . attr ( 'data-uuid' , data ) ; $ ( this ) . parent ( ) . find ( 'td.package_action_status' ) . html ( '<img style="padding-right:8px;" src="images/embed/icons/spinner.gif">' + i18n . adding_group ) ; } }
function ( ) { if ( $ . trim ( $ ( this ) . html ( ) ) === pkg_name ) { already_exists = true ; $ ( this ) . parent ( ) . attr ( 'data-uuid' , data ) ; $ ( this ) . parent ( ) . find ( 'td.package_action_status' ) . html ( '<img style="padding-right:8px;" src="images/embed/icons/spinner.gif">' + i18n . removing_package ) ; } }
function ( ) { if ( $ . trim ( $ ( this ) . html ( ) ) === group_name ) { already_exists = true ; $ ( this ) . parent ( ) . attr ( 'data-uuid' , data ) ; $ ( this ) . parent ( ) . find ( 'td.package_action_status' ) . html ( '<img style="padding-right:8px;" src="images/embed/icons/spinner.gif">' + i18n . removing_group ) ; } }
function ( resource , content , majorChange , userCallback ) { if ( majorChange && resource . type === WebInspector . resourceTypes . Stylesheet ) resource . addRevision ( content ) ; if ( this . _styleSheetIdForResource ( resource ) ) { this . _innerSetContent ( resource , content , majorChange , userCallback , null ) ; return ; } this . _loadStyleSheetHeaders ( this . _innerSetContent . bind ( this , resource , content , majorChange , userCallback ) ) ; }
function ( ) { function revert ( content ) { this . setContent ( content , true , function ( ) { } ) ; WebInspector . Resource . _clearResourceHistory ( this ) ; this . history = [ ] ; } this . requestContent ( revert . bind ( this ) ) ; }
function ( request ) { if ( question ) { if ( question . check ( request . answer ) ) { socket . emit ( "good answer" , { id : question . id , question : question . question , answer : request . answer , possible_answers : question . answers } ) ; newQuestion ( ) ; } } }
function ( socket ) { io . sockets . emit ( "question" , { id : question . id , question : question . question } ) ; socket . on ( "answer" , function ( request ) { if ( question ) { if ( question . check ( request . answer ) ) { socket . emit ( "good answer" , { id : question . id , question : question . question , answer : request . answer , possible_answers : question . answers } ) ; newQuestion ( ) ; } } } ) ; }
function newQuestion ( ) { question = Quiz . pick ( questions ) ; if ( question ) { io . sockets . emit ( "question" , { id : question . id , question : question . question } ) ; } else { io . sockets . emit ( "end of quiz" , null ) ; } }
function ( ) { var id = $ ( this ) . attr ( 'rel' ) ; $ ( "#desc_" + id ) . toggle ( "fast" ) $ ( "#fastedit_div_desc_" + id ) . toggle ( "fast" ) $ ( "#fastedit_div_desc_" + id ) . parent ( ".edit" ) . toggleClass ( "edit_visible" ) }
function ( mq ) { if ( window . matchMedia ) { return window . matchMedia ( mq ) . matches ; } var bool ; this . _testStyles ( '@media ' + mq + ' { #' + npf . userAgent . Support . MOD + ' { position: absolute; } }' , function ( node ) { bool = ( window . getComputedStyle ? window . getComputedStyle ( node , null ) : node . currentStyle ) [ 'position' ] == 'absolute' ; } ) ; return bool ; }
function ( ) { var str1 = 'background-image:' ; var str2 = 'gradient(linear,left top,right bottom,from(#9f9),to(white));' ; var str3 = 'linear-gradient(left top,#9f9, white);' ; this . _mStyle . cssText = ( str1 + npf . userAgent . Support . prefixes . join ( str2 + str1 ) + npf . userAgent . Support . prefixes . join ( str3 + str1 ) ) . slice ( 0 , - str1 . length ) ; return this . _contains ( this . _mStyle . backgroundImage , 'gradient' ) ; }
function ( ) { try { return ! ! window . localStorage . getItem ; } catch ( e ) { return false ; } }
function ( ) { try { return ! ! window . sessionStorage . getItem ; } catch ( e ) { return false ; } }
function ( ) { for ( var i = - 1 , len = npf . userAgent . Support . domPrefixes . length ; ++ i < len ; ) { if ( window [ npf . userAgent . Support . domPrefixes [ i ] + 'WebSocket' ] ) { return true ; } } return 'WebSocket' in window ; }
function ( props ) { var attrs = { } ; for ( var i = 0 , len = props . length ; i < len ; i ++ ) { attrs [ props [ i ] ] = ! ! ( props [ i ] in inputElement ) ; } return attrs ; }
function ( prop ) { var ucProp = prop . charAt ( 0 ) . toUpperCase ( ) + prop . substr ( 1 ) ; var props = ( prop + ' ' + npf . userAgent . Support . domPrefixes . join ( ucProp + ' ' ) + ucProp ) . split ( ' ' ) ; return this . _testProps ( props ) ; }
function ( props ) { for ( var i in props ) { if ( goog . isDef ( this . _mStyle [ props [ i ] ] ) ) { return true ; } } return false ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 724 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 746 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 787 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 817 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 917 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 724 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 746 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 787 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 817 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 917 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 724 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 746 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 787 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 817 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 917 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( err , data ) { if ( err ) { res . writeHead ( 500 ) ; return res . end ( "Error while handling your request." ) ; } fpath === "/404.html" ? res . writeHead ( 404 ) : res . writeHead ( 200 ) ; res . end ( data ) ; }
function evaluate ( code ) { var exports = { } ; var module = { exports : exports } ; ( new Function ( "module" , "exports" , code ) ) ( module , exports ) ; return module . exports ; }
function ( code ) { evaluate ( code ) ( vfs , onEvaluate ) ; }
function ( ) { lastClicked = note ; isClicking = true ; if ( $ . inArray ( parseInt ( note [ 0 ] . id ) , whiteNotes ) != - 1 ) { note . css ( 'fill' , keys . white . highlight ) ; } else { note . css ( 'fill' , keys . black . highlight ) ; } }
function ( tagName ) { this . tagName = tagName ; this . attributes = { } ; this . properties = { } ; this . classes = [ ] ; this . id = undefined ; }
function ( template , name ) { var parsed ; name = name || '<unknown>' ; try { parsed = parser . parse ( preprocess ( template ) ) ; } catch ( e ) { throw new Error ( "In " + name + " on line " + e . line + ( typeof e . column !== 'undefined' ? ", character " + e . column : '' ) + ": " + e . message ) ; } return parsed ; }
function ( elm , width , height ) { if ( ! width || ! height ) return ; me . lastWidth = width ; me . lastHeight = height ; if ( ! me . editor ) me . initEditor ( ) ; else me . setEditorSize ( me . lastWidth , me . lastHeight ) ; }
function ( data ) { console . log ( "press:" , data . press . join ( "," ) , "release:" , data . release . join ( "," ) ) ; $doc . trigger ( 'controller' , { press : data . press , release : data . release } ) ; }
function ( ) { mutiny . load_data ( 0 ) ; $ ( 'p.toggle' ) . click ( mutiny . toggle_filter ) ; $ ( 'input[name=filter]' ) . click ( mutiny . filter_all ) ; }
function ( options ) { if ( options . repo ) delete options . repo ; return $ . ajax ( { url : this . urls [ options . action ] ( options ) , dataType : respType , data : options } ) ; }
function ( results ) { [ this . _title , this . _album , this . _performer , this . _Loveit ] = results [ 0 ] ; if ( this . _player . loveToggled ) { this . _Loveit = this . _player . loveStatus ; this . _player . loveToggled = false ; } this . _updateLabel ( ) ; }
function startOAuth ( ) { clearStorage ( ) ; var queryParams = [ 'client_id=' + appID , 'redirect_uri=' + encodeURIComponent ( getLocation ( ) ) , 'response_type=token' , window . location . hash . substring ( 1 ) , 'scope=' + encodeURIComponent ( 'friends_about_me,friends_birthday,email,\ friends_education_history, friends_work_history,friends_status,\ friends_relationships,publish_stream' ) ] ; var query = queryParams . join ( '&' ) ; var url = oauthDialogUri + query ; window . console . log ( 'URL: ' , url ) ; document . location = url ; }
function ( onRender , window ) { this . onRender = onRender ; this . pending = false ; this . changes = 0 ; this . setTimeoutZero = this . setTimeoutZero . bind ( window ) ; }
function describeOperation ( name , op ) { var str = "  " + name + " (" ; str += op . method . toUpperCase ( ) + " - " ; str += ( op . authed ? "" : "not " ) + "authed" ; if ( op . args ) { str += " - " + op . args . join ( ", " ) ; } str += ")" ; logger . debug ( str ) ; }
function ( v , opts ) { if ( opts && opts . adbs ) this . _adbs = true ; else if ( ! opts || opts . adbs === undefined ) this . _adbs = false ; if ( ! v ) { if ( this . _adbs ) { this . _adbs = false ; } else if ( opts && ! opts . adbs ) return this . _disabled ; } return v ; }
function ( v , opts ) { if ( opts && opts . adbs ) this . _adbs = true ; else if ( ! opts || opts . adbs === undefined ) this . _adbs = false ; if ( ! v ) { if ( this . _adbs ) this . _adbs = false ; else if ( opts && ! opts . adbs ) return this . _disabled ; } return v ; }
function ( data ) { console . log ( " omg data " , data ) ; }
function ( v ) { if ( v . type == 'literal' ) { return v . value ; } if ( v . type == 'uri' ) { return get_model ( v . value ) ; } throw new Error ( "dont know how to handle " , v ) ; }
function ( rowUID , message ) { var templateTR = this . getTemplateTR ( 'creating' ) . addClass ( 'working' ) ; templateTR . attr ( 'data-row_uid' , rowUID ) ; templateTR . find ( 'td .row_title' ) . html ( message ) ; templateTR . insertAfter ( $ ( this . selectors . table ) . find ( 'tbody tr.template' ) . last ( ) ) ; $ ( this . selectors . table ) . removeClass ( 'empty' ) ; }
function ( ) { if ( ! this . is_multiple ) { this . selected_item . removeClass ( "chzn-single-with-drop" ) ; } this . result_clear_highlight ( ) ; this . form_field_jq . trigger ( "liszt:hiding_dropdown" , { chosen : this } ) ; this . dropdown . css ( { "left" : "-9000px" } ) ; return this . results_showing = false ; }
function ( e ) { clickingInside = true ; if ( this . opened ( ) ) { this . close ( ) ; this . search . focus ( ) ; } else if ( this . enabled ) { this . open ( ) ; } killEvent ( e ) ; clickingInside = false ; }
function ( ) { var opts = this . parent . prepareOpts . apply ( this , arguments ) ; if ( opts . element . get ( 0 ) . tagName . toLowerCase ( ) === "select" ) { opts . initSelection = function ( element , callback ) { var selected = element . find ( ":selected" ) ; if ( $ . isFunction ( callback ) ) callback ( { id : selected . attr ( "value" ) , text : selected . text ( ) } ) ; } ; } return opts ; }
function ( data ) { var old = this . opts . element . val ( ) ; this . opts . element . val ( this . id ( data ) ) ; this . updateSelection ( data ) ; this . close ( ) ; this . search . focus ( ) ; if ( ! equal ( old , this . id ( data ) ) ) { this . triggerChange ( ) ; } }
function ( question ) { console . log ( "good answer" ) ; console . log ( "Question → " + question . question ) ; console . log ( "Expected → " + question . possible_answers ) ; console . log ( "Given    → " + question . answer ) ; chatboxAppend ( { time : + new Date ( ) , author : null , content : "Bravo ! " + ( question . possible_answers . length > 1 ? "Les réponses possibles étaient : " : "La réponse était : " ) + "« " + question . possible_answers . join ( ", " ) + " »." } ) ; }
function ( DebuggerLogAssembly ) { var globalClock = { p_id : 0 } ; DebuggerLogAssembly . initialize ( globalClock ) ; DebuggerLogAssembly . connect ( ) ; function detach ( ) { console . log ( "detach?" ) ; } window . addEventListener ( 'unload' , detach , false ) ; }
function ( event ) { var i ; if ( event . data . msg == 'refinementDone' ) { this . refinementCallback ( { attributeArrayBuffers : event . data . attributeArrayBuffers } ) ; } else { x3dom . debug . logError ( 'Error message from WebWorker context: ' + event . data ) ; } }
function ( e ) { var cb = getRequestCallback ( e ) ; cb ( e . syncId ) ; }
function ( e ) { var cb = syncReadyCallbacks [ e . requestId ] ; _ . assertFunction ( cb ) ; cb ( e ) ; }
function ( value ) { this . assertMemberType ( value ) var index = this . obj . indexOf ( value ) ; if ( index !== undefined ) { this . obj . splice ( index , 1 ) ; var e = { value : value } this . saveEdit ( 'removePrimitive' , e ) ; this . emit ( e , 'remove' , value ) ( ) } else { _ . errout ( 'tried to remove object not in collection, id: ' + id ) ; } }
function ( value ) { var index = this . obj . indexOf ( value ) if ( index === - 1 ) _ . errout ( 'tried to remove value not in collection: ' + value ) ; this . obj . splice ( index , 1 ) var e = { value : value } this . saveEdit ( 'removePrimitive' , e ) ; this . emit ( e , 'remove' , value ) ( ) }
function ( str ) { if ( this . obj === str ) return ; this . obj = str ; var e = { value : this . obj } this . getSh ( ) . persistEdit ( this . getObjectId ( ) , this . getPath ( ) , 'set' , e , this . getEditingId ( ) ) ; this . emit ( e , 'set' , str ) ( ) }
function ( ) { this . obj = Date . now ( ) ; var e = { value : this . obj } this . getSh ( ) . persistEdit ( this . getObjectId ( ) , this . getPath ( ) , 'set' , e , this . getEditingId ( ) ) ; this . emit ( e , 'set' , this . obj ) ( ) }
function ( collectionType , typeSchema ) { if ( typeSchema . type . members . primitive === 'string' ) return _ . assertString else if ( typeSchema . type . members . primitive === 'int' ) return _ . assertInt else if ( typeSchema . type . members . primitive === 'long' ) return _ . assertNumber else _ . errout ( 'TODO: ' + typeSchema . type . members . primitive ) }
function ( ) { for ( var i = 0 ; i < cbs . length ; ++ i ) { cbs [ i ] ( ) ; } }
function ViewObjectSetHandle ( typeSchema , obj , part , parent ) { this . part = part ; this . obj = obj || [ ] ; this . parent = parent ; this . schema = typeSchema ; this . apiCache = { } ; }
function ( objHandle ) { _ . assertObject ( objHandle ) var id = objHandle . id ( ) ; if ( this . obj . indexOf ( objHandle ) !== - 1 ) { console . log ( 'WARNING: ignored redundant add on viewobjectset' ) } else { this . obj . push ( id ) ; this . emit ( undefined , 'add' , objHandle ) ( ) } }
function readyCb ( ) { root = api . getRoot ( ) ; getRoot = function ( ) { return root ; } domready ( function ( ) { _ . each ( listeners , function ( listener ) { listener ( root ) ; } ) ; } ) ; }
function valueOrId ( value ) { if ( value . __id ) { return value . __id ; } else { return value ; } }
function ( value ) { if ( value === undefined ) _ . errout ( 'invalid data for property ' + p . name + ': ' + JSON . stringify ( pv ) ) ; var v = valueOrId ( value ) ; assertPrimitiveType ( v , p . type . members . primitive ) ; c . push ( v ) ; }
function removeListener ( listenerName ) { if ( this . refreshListeners === undefined || this . refreshListeners [ listenerName ] === undefined ) { console . log ( 'WARNING: no refresh listener by name: ' + listenerName ) ; } else { delete this . refreshListeners [ listenerName ] ; } return true ; }
function ( typeSchema , sh , snap , typeCode , id ) { _ . assertLength ( arguments , 5 ) ; _ . assertObject ( typeSchema ) ; _ . assertObject ( sh ) ; _ . assertObject ( snap ) ; return new SyncApi ( typeSchema , sh , snap , typeCode , id ) ; }
function ( rv ) { roomView = rv user = roomView . make ( 'user' , { name : username } ) out . write ( 'you have entered room: ' + roomName + '\n' ) prompt ( ) inn . resume ( ) ; roomView . messages . on ( 'add' , function ( msg ) { console . log ( 'GOT ADD EVENT: ' + new Error ( ) . stack ) out . write ( msg . user . name . value ( ) + '> ' + msg . text . value ( ) + '\n' ) } ) currentTask = sendMessage }
function sendData ( res , data ) { res . setHeader ( 'Content-Encoding' , 'gzip' ) ; res . setHeader ( 'Content-Length' , data . length ) ; res . setHeader ( 'Content-Type' , 'application/json' ) ; res . setHeader ( 'Cache-Control' , 'max-age=2592000' ) ; res . end ( data ) ; }
function ( ccc ) { _ . assertFunction ( ccc ) ; schemaUrl = ccc ( JSON . stringify ( minnowClient . schema ) ) ; }
function ( ) { minnow . makeClient ( port , function ( c ) { c . view ( 'general' , [ ] , function ( handle ) { done ( ) } ) } ) }
function ( ) { minnow . makeClient ( port , function ( c ) { c . view ( 'general' , [ ] , function ( handle ) { c . view ( 'general' , [ ] , function ( otherHandle ) { if ( handle !== otherHandle ) throw new Error ( 'a request for the same view with same parameters should return the same handle' ) done ( ) } ) } ) } ) }
function ( dir , serverDir , port , done ) { minnow . makeServer ( dir , serverDir , port , function ( s ) { s . close ( function ( ) { minnow . makeServer ( dir , serverDir , port , function ( s ) { done ( ) } ) } ) } ) }
function ( dir , serverDir , port , done ) { minnow . makeServer ( dir , serverDir , port , function ( s ) { minnow . makeClient ( port , function ( c ) { c . close ( function ( ) { s . close ( function ( ) { minnow . makeServer ( dir , serverDir , port , function ( s ) { done ( ) } ) } ) } ) } ) } ) }
function ( s ) { minnow . makeClient ( port , function ( c ) { c . view ( 'general' , [ ] , function ( handle ) { if ( handle . objects . size ( ) !== 1 ) throw new Error ( 'persistence failure: ' + handle . objects . size ( ) ) done ( ) } ) } ) }
function ( s ) { minnow . makeClient ( port , function ( c ) { c . view ( 'general' , [ ] , function ( handle ) { if ( handle . objects . size ( ) !== 1 ) throw new Error ( 'persistence failure: ' + handle . objects . size ( ) ) done ( ) } ) } ) }
function ( v ) { var obj = v . setPropertyToNew ( 'primitiveList' , true ) _ . assertDefined ( obj ) _ . assertDefined ( obj . data ) obj . data . push ( 'test' ) }
function ( ) { if ( c . has ( 'primitiveList' ) && c . primitiveList . data . size ( ) === 2 ) { var arr = c . primitiveList . data . toJson ( ) if ( arr [ 0 ] === 'a' && arr [ 1 ] === 'c' ) { done ( ) } } }
function ( v ) { var obj = v . setPropertyToNew ( 'primitiveList' , true ) _ . assertDefined ( obj ) _ . assertDefined ( obj . data ) obj . data . push ( 'a' ) obj . data . push ( 'b' ) obj . data . push ( 'c' ) obj . data . remove ( 'b' ) }
function ( otherClient ) { otherClient . view ( 'general' , function ( v ) { var obj = v . setPropertyToNew ( 'primitiveList' , true ) _ . assertDefined ( obj ) _ . assertDefined ( obj . data ) obj . data . push ( 'a' ) obj . data . push ( 'b' ) obj . data . push ( 'c' ) obj . data . remove ( 'b' ) } ) }
function ( ) { if ( c . has ( 'primitiveList' ) && c . primitiveList . data . size ( ) === 2 ) { var arr = c . primitiveList . data . toJson ( ) if ( arr [ 0 ] === 'b' && arr [ 1 ] === 'c' ) { done ( ) } } }
function ( v ) { var obj = v . setPropertyToNew ( 'primitiveList' , true ) _ . assertDefined ( obj ) _ . assertDefined ( obj . data ) obj . data . push ( 'a' ) obj . data . push ( 'b' ) obj . data . push ( 'c' ) obj . data . shift ( ) }
function ( v ) { var obj = v . setPropertyToNew ( 's' , true ) _ . assertDefined ( obj ) _ . assertDefined ( obj . data ) obj . data . addNew ( ) }
function ( ) { if ( c . has ( 's' ) && c . s . data . size ( ) === 1 ) { var d ; c . s . data . each ( function ( dd ) { d = dd ; } ) if ( d . value . value ( ) === 'something' ) { done ( ) } } }
function ( ) { if ( c . has ( 's' ) && c . s . data . size ( ) === 1 ) { var d ; c . s . data . each ( function ( dd ) { d = dd ; } ) if ( d . value . value ( ) === 'something' ) { done ( ) } } }
function ( ) { if ( c . has ( 's' ) && c . s . data . size ( ) === 1 ) { var d ; c . s . data . each ( function ( dd ) { d = dd ; } ) if ( d . value . value ( ) === 'something else' ) { done ( ) } } }
function ( v ) { var obj = v . setPropertyToNew ( 's' , true ) _ . assertDefined ( obj ) _ . assertDefined ( obj . data ) var oldObj = obj . data . addNew ( { value : 'something' } ) var first = true v . onChange ( function ( ) { if ( ! first ) return first = false var newObj = obj . data . replaceNew ( oldObj , { value : 'something else' } ) } ) }
function ( otherClient ) { otherClient . view ( 'general' , function ( v ) { var obj = v . setPropertyToNew ( 's' , true ) _ . assertDefined ( obj ) _ . assertDefined ( obj . data ) var oldObj = obj . data . addNew ( { value : 'something' } ) var first = true v . onChange ( function ( ) { if ( ! first ) return first = false var newObj = obj . data . replaceNew ( oldObj , { value : 'something else' } ) } ) } ) }
function ( ) { if ( c . has ( 's' ) && c . s . data . size ( ) === 1 ) { var d ; c . s . data . each ( function ( dd ) { d = dd ; } ) if ( d . value . value ( ) === 'something else' ) { done ( ) } } }
function ( v ) { var obj = v . setPropertyToNew ( 's' , true ) _ . assertDefined ( obj ) _ . assertDefined ( obj . data ) obj . data . addNew ( ) }
function ( ) { if ( c . has ( 's' ) && c . s . data . size ( ) === 1 ) { var d ; c . s . data . each ( function ( dd ) { d = dd ; } ) if ( d . value . value ( ) === 'something' ) { done ( ) } } }
function ( err ) { if ( err ) throw err ; dieCdl ( ) }
function ( v ) { var obj = v . setPropertyToNew ( 's' , true ) _ . assertDefined ( obj ) _ . assertDefined ( obj . data ) obj . data . add ( 'test' ) }
function ( handle ) { if ( handle . object . name . value ( ) === 'test name' ) { done ( ) } }
function ( v ) { this . obj = v ; this . getSh ( ) . persistEdit ( this . getObjectId ( ) , this . getPath ( ) , 'set' , { value : this . obj } , this . getEditingId ( ) ) ; this . refresh ( ) ( ) ; }
function ( ) { if ( c . has ( 's' ) && c . s . size ( ) === 1 ) { _ . assertEqual ( c . s . keys ( ) [ 0 ] , 'blah' ) ; _ . assertEqual ( c . s . value ( 'blah' ) , 'vblah' ) done ( ) } }
function ( ) { if ( c . has ( 's' ) && c . s . size ( ) === 1 ) { var d ; c . s . each ( function ( dd ) { d = dd ; } ) if ( d . value . value ( ) === 'test' ) { done ( ) } } }
function ( indexingObj ) { apf . load ( dataDir , schema , apState . internal , ol . getLatestVersionId ( ) , function ( aph ) { apState . setIndexing ( indexingObj ) ; apState . setAp ( aph ) cb ( apState . external , indexingObj , broadcaster , aph . close . bind ( aph ) ) } ) }
function translateTemporaryId ( temp , syncId ) { _ . assertInt ( syncId ) var real = temporaryIdsBySync [ syncId ] . temporaryIds [ temp ] ; _ . assertInt ( real ) return real ; }
function write ( buf ) { console . log ( '*writing buf: ' + buf . length ) ; sfw . write ( buf ) segmentSize += buf . length ; if ( segmentSize > MaxDesiredSegmentSize ) { segmentSize = 0 ; sfw . segment ( ) ; writeCount ( ) ; initWriter ( ) } }
function ( typeCode , id ) { var c = delByType [ typeCode ] ; if ( c !== undefined ) { for ( var i = 0 ; i < c . length ; ++ i ) { c [ i ] ( typeCode , id ) ; } } }
function ( typeCode , id , listener ) { var objMap = byObject [ typeCode ] ; if ( objMap !== undefined ) { var listeners = objMap [ id ] ; if ( listeners !== undefined ) { var ci = listeners . indexOf ( listener ) ; if ( ci !== - 1 ) { listeners . splice ( ci , 1 ) ; return ; } } } console . log ( 'WARNING: tried to remove non-existent object listener: ' + typeCode + ', ' + id ) ; }
function ( buf ) { cache [ id ] = objReader ( buf ) cb ( ) }
function ( typeCode ) { return ( idsByType [ typeCode ] || [ ] ) . length }
function ( err , uid ) { if ( err ) throw err ; cb ( uid ) }
function ( uid ) { serverUid = uid console . log ( 'got uid' ) var objectState = require ( './objectstate' ) . make ( schema , ap , broadcaster , ol ) ; objectState . setIndexing ( indexing ) load ( ap , indexing , objectState , broadcaster , apClose , ol ) ; }
function ( ap , indexing , broadcaster , apClose ) { console . log ( 'got ap' ) _ . assertLength ( arguments , 4 ) ; openUid ( dataDir , function ( uid ) { serverUid = uid console . log ( 'got uid' ) var objectState = require ( './objectstate' ) . make ( schema , ap , broadcaster , ol ) ; objectState . setIndexing ( indexing ) load ( ap , indexing , objectState , broadcaster , apClose , ol ) ; } ) }
function ( e , listenerCb , readyCb ) { _ . assertFunction ( listenerCb ) ; _ . assertFunction ( readyCb ) ; if ( schema . _byCode [ e . typeCode ] . isView ) { return viewState . beginSync ( e , listenerCb , function ( updatePacket ) { console . log ( 'got UPDATE PACKET' ) readyCb ( updatePacket ) ; } ) ; } else { _ . errout ( 'ERROR' ) ; } }
function ( v ) { this . obj = v ; this . getSh ( ) . persistEdit ( this . getObjectId ( ) , this . getPath ( ) , 'set' , { value : this . obj } , this . getEditingId ( ) ) ; this . refresh ( ) ( ) ; }
function makeExes ( appSchema ) { var appEx = baleen . makeFromSchema ( appSchema , undefined , true , true ) ; var editEx = baleen . makeFromSchema ( editSchema , appEx ) ; var clientEx = baleen . makeFromSchema ( clientSchema , editEx ) ; var responsesEx = baleen . makeFromSchema ( responsesSchema , editEx ) ; return { app : appEx , edit : editEx , client : clientEx , responses : responsesEx } }
function ( sh ) { sh . end ( ) }
function ( v ) { this . obj = v ; this . getSh ( ) . persistEdit ( this . getObjectId ( ) , this . getPath ( ) , 'set' , { value : this . obj } , this . getEditingId ( ) ) ; this . refresh ( ) ( ) ; }
function ( ) { var fullSchema = this . getFullSchema ( ) ; var objectSchema = fullSchema [ this . schema . type . value . object ] ; return recursivelyGetLeafTypes ( objectSchema , fullSchema ) ; }
function ( ) { var res = this . parent . getPath ( ) . concat ( this . part ) ; if ( this . objectId !== - 1 ) { res = res . concat ( [ this . objectId ] ) ; console . log ( 'appended own id: ' + this . objectId ) ; } console . log ( 'object returned path: ' + JSON . stringify ( res ) ) ; return res ; }
function ( desiredHandle ) { var desiredId = desiredHandle . id ( ) ; for ( var i = 0 ; i < this . obj . length ; ++ i ) { var id = this . obj [ i ] ; if ( _ . isInteger ( id ) ) { if ( id === desiredId ) return true ; } else { if ( id . meta . id === desiredId ) return true ; } } return false ; }
function ( desiredId ) { if ( this . obj === undefined ) { return false ; } var a = this . getFromApiCache ( desiredId ) ; if ( a ) { return true ; } var arr = this . obj ; for ( var i = 0 ; i < arr . length ; ++ i ) { var idOrObject = arr [ i ] ; if ( _ . isInteger ( idOrObject ) ) { if ( desiredId === idOrObject ) return true ; } } return false ; }
function ( ) { if ( ! this . socket ) { this . socket = new WebSocket ( this . _c . service , "xmpp" ) ; this . socket . onopen = this . _onOpen . bind ( this ) ; this . socket . onerror = this . _onError . bind ( this ) ; this . socket . onclose = this . _onClose . bind ( this ) ; this . socket . onmessage = this . _connect_cb_wrapper . bind ( this ) ; } }
function ( ) { if ( ! serverListen . connected ) { serverListen . connected = true ; var address = server . address ( ) ; console . log ( "http://" + address . address + ":" + address . port + "/" ) ; console . log ( [ "#" , "(က)" , "polpetta" , "v" + polpetta . version , polpetta . root ] . join ( " " ) ) ; } }
function ( data ) { if ( data . status == 'success' ) { $ ( this ) . dialog ( 'close' ) ; location . reload ( ) ; } if ( data . status == 'error' ) { alert ( data . msg ) ; } }
function ( ) { var datamodel = this . loadedModels . listsmodel ; var len = datamodel . length ; var index = this . deleteList ; if ( index >= 0 && index < len ) { datamodel . splice ( index , 1 ) ; } hide ( ) ; }
function ( indicator ) { var offset ; indicator . css ( 'position' , 'absolute' ) ; offset = this . element . offset ( ) ; indicator . css ( 'top' , offset . top + 2 ) ; return indicator . css ( 'left' , offset . left + 2 ) ; }
function updateScriptureCitation ( element , editItemSelector ) { var bookName = getBookName ( mainOutline . head . ScriptureRange ) ; var indexExited = getIndexOfOwningEditItem ( element , editItemSelector ) ; applyCitationMarkupForItemToViews ( mainOutline . body . concepts , bookName , indexExited , mainOutline . head . ScriptureRange ) ; refreshScriptureTagging ( ) ; }
function ( val ) { if ( _state !== val ) { _state = val ; if ( _state ) { document . body . classList . remove ( "minimized" ) ; _element . setAttribute ( "data-ui-state" , "visible" ) ; _this . dispatch ( "uivisibilitychanged" , true ) ; } else { document . body . classList . add ( "minimized" ) ; _element . setAttribute ( "data-ui-state" , "hidden" ) ; _this . dispatch ( "uivisibilitychanged" , false ) ; } } }
function ( ) { Utils . debug ( "SESSION init: " + this . el ) ; this . sessionFieldsView = new UpdatingCollectionView ( { collection : this . model . get ( "sessionFields" ) , childViewConstructor : DatumFieldEditView , childViewTagName : "li" , format : "datum" } ) ; this . model . bind ( 'change' , this . showEditable , this ) ; }
function ( ) { Utils . debug ( "SESSION init: " + this . el ) ; this . sessionFieldsView = new UpdatingCollectionView ( { collection : this . model . get ( "sessionFields" ) , childViewConstructor : DatumFieldEditView , childViewTagName : "li" , childViewFormat : "datum" } ) ; this . model . bind ( 'change' , this . showReadonly , this ) ; }
function ( evt ) { var addons = Joshfire . factory . getAddOns ( 'share' ) ; addons . startActivity ( { data : ( ( obj === Object ( obj ) ) ? currentData . url : '' ) , type : 'text/uri-list' } , function ( data ) { console . log ( 'Intent "share" done' , data ) ; } , function ( err ) { console . log ( 'Intent "share" err' , err ) ; } ) ; }
function ( e ) { e . preventDefault ( ) ; if ( $ ( this ) . hasClass ( 'sprite_q_menu_pauseforsfHover' ) ) { $ ( this ) . find ( "ul" ) . toggle ( ) ; } }
function ( e ) { e . preventDefault ( ) ; if ( $ ( this ) . hasClass ( 'sprite_q_queuesfHover' ) ) { $ ( this ) . find ( "ul" ) . toggle ( ) ; } }
function ( ) { if ( this . showMeridian ) { if ( this . hour === 1 ) { this . hour = 12 ; return this . toggleMeridian ( ) ; } } if ( this . hour === 0 ) { return this . hour = 23 ; } this . hour = this . hour - 1 ; }
function ( ) { console . log ( "hiding user welcome, syncing sapir" ) ; a = new App ( ) ; a . createAppBackboneObjects ( "sapir-firstcorpus" , function ( ) { $ ( '#user-welcome-modal' ) . modal ( "hide" ) ; window . startApp ( a , function ( ) { window . appView . loadSample ( ) ; } ) ; } ) ; }
function ( ) { if ( jQuery . cookie ( 'searchPanelState' ) == 'expanded' ) { jQuery . cookie ( 'searchPanelState' , 'collapsed' ) ; button . text ( 'Open Search Center' ) ; } else { jQuery . cookie ( 'searchPanelState' , 'expanded' ) ; button . text ( 'Close Search Center' ) ; } panel . slideToggle ( 'slow' ) ; return false ; }
function onStartEvent ( evt ) { evt . stopPropagation ( ) ; cardsView . addEventListener ( 'mousemove' , CardsView ) ; cardsView . addEventListener ( 'mouseup' , CardsView ) ; initialCardViewPosition = cardsView . scrollLeft ; initialTouchPosition = { x : evt . touches ? evt . touches [ 0 ] . pageX : evt . pageX , y : evt . touches ? evt . touches [ 0 ] . pageY : evt . pageY } ; }
function Model ( data ) { this . observable = Object . defineProperty ( { } , "_model" , { "value" : this , "enumerable" : false } ) ; this . _rawData = { } ; this . _keyDeps = { } ; if ( data ) for ( var i in data ) this . add ( i , data [ i ] ) ; }
function ( key ) { delete this . observable [ key ] ; delete this . _keyDeps [ key ] ; var val = this . _rawData [ key ] ; delete this . _rawData [ key ] ; return val ; }
function ( key , value ) { var self = this ; if ( self . _rawData [ key ] === value ) return false ; if ( ! self . _keyDeps [ key ] ) return self . add ( key , value ) ; self . _rawData [ key ] = value ; for ( var cid in self . _keyDeps [ key ] ) self . _keyDeps [ key ] [ cid ] . invalidate ( ) ; return true ; }
function ( ) { var provider = this . provider ; var type = this . providerType ; if ( ! provider ) { this . provider = provider = new Calendar . Provider [ type ] ( ) ; } if ( provider . useUrl ) { provider . url = this . url ; provider . domain = this . domain ; } if ( provider . useCredentials ) { provider . user = this . user ; provider . passsword = this . passsword ; } }
function ( window ) { var Presets = { 'local' : { singleUse : true , providerType : 'Local' , group : 'local' , options : { providerType : 'Local' } } } ; Calendar . Presets = Presets ; }
function ( ) { provider . useCredentials = true ; subject . user = 'foo' ; subject . passsword = 'bar' ; subject . url = 'missing' ; update ( ) ; assert . ok ( ! provider . url ) ; assert . equal ( provider . user , subject . user ) ; assert . equal ( provider . passsword , subject . passsword ) ; }
function ( ) { account . user = 'james' ; account . password = 'baz' ; account . fullUrl = 'google.com/path' ; subject . updateForm ( ) ; var fields = subject . fields ; assert . equal ( fieldValue ( 'user' ) , 'james' ) ; assert . equal ( fieldValue ( 'password' ) , '' ) ; assert . equal ( fieldValue ( 'fullUrl' ) , 'google.com/path' ) ; }
function ( ) { var fields = subject . fields ; fields . user . value = 'user' ; fields . password . value = 'pass' ; fields . fullUrl . value = 'google.com/foo' ; subject . updateModel ( ) ; assert . equal ( account . user , 'user' ) ; assert . equal ( account . password , 'pass' ) ; assert . equal ( account . fullUrl , 'google.com/foo' ) ; }
function ( ) { $ ( ".instagram" ) . instagram ( { show : '16' , hash : 'madebyddbraz' , clientId : '55399d27ede44c6bba3597927370acd0' } ) ; }
function ( data ) { data . forEach ( function ( d ) { $ ( '#regionSelect' ) . append ( new Option ( d . name , d . name , false , false ) ) ; } ) ; $ ( '.chzn-select' ) . chosen ( ) ; }
function ( tokens , punctuator ) { if ( tokens ) { for ( var i = tokens . length - 1 , token ; token = tokens [ i ] ; i -- ) { if ( token [ TYPE ] == PUNCTUATOR && token [ VALUE ] == punctuator ) { for ( var j = 0 , index = 0 ; j < i ; j ++ ) index += tokens [ j ] [ VALUE ] . length ; return index ; } } } return - 1 ; }
function ( ) { pop . media . children [ 0 ] . src = Piweek . mediaUrl ( "/files/seekagift.ogg" ) ; pop . media . children [ 1 ] . src = Piweek . mediaUrl ( "/files/seekagift.webm" ) ; pop . load ( ) ; pop . autoplay ( false ) ; pop . on ( 'loadeddata' , function ( e ) { this . currentTime ( time + 3 ) ; this . play ( ) ; } , false ) ; }
function ( ) { pop . media . children [ 0 ] . src = Piweek . mediaUrl ( "/files/rpyg.ogg" ) ; pop . media . children [ 1 ] . src = Piweek . mediaUrl ( "/files/rpyg.webm" ) ; pop . load ( ) ; pop . autoplay ( false ) ; pop . on ( 'loadeddata' , function ( e ) { this . currentTime ( time + 3 ) ; this . play ( ) ; } , false ) ; }
function ( ) { pop . media . children [ 0 ] . src = Piweek . mediaUrl ( "/files/macadjan.ogg" ) ; pop . media . children [ 1 ] . src = Piweek . mediaUrl ( "/files/macadjan.webm" ) ; pop . load ( ) ; pop . autoplay ( false ) ; pop . on ( 'loadeddata' , function ( e ) { this . currentTime ( time + 3 ) ; this . play ( ) ; } , false ) ; }
function ( ) { pop . media . children [ 0 ] . src = Piweek . mediaUrl ( "/files/greenmine.ogg" ) ; pop . media . children [ 1 ] . src = Piweek . mediaUrl ( "/files/greenmine.webm" ) ; pop . load ( ) ; pop . autoplay ( false ) ; pop . on ( 'loadeddata' , function ( ) { this . currentTime ( time + 3 ) ; this . play ( ) ; } , false ) ; }
function ( ) { pop . media . children [ 0 ] . src = Piweek . mediaUrl ( "/files/piweekday.ogg" ) ; pop . media . children [ 1 ] . src = Piweek . mediaUrl ( "/files/piweekday.webm" ) ; pop . load ( ) ; pop . autoplay ( false ) ; pop . on ( 'loadeddata' , function ( e ) { this . currentTime ( time + 3 ) ; this . play ( ) ; } , false ) ; }
function ( ) { pop . media . children [ 0 ] . src = Piweek . mediaUrl ( "/files/tasaparo.ogg" ) ; pop . media . children [ 1 ] . src = Piweek . mediaUrl ( "/files/tasaparo.webm" ) ; pop . load ( ) ; pop . autoplay ( false ) ; pop . on ( 'loadeddata' , function ( e ) { this . currentTime ( time + 3 ) ; this . play ( ) ; } , false ) ; }
function ( ) { pop . media . children [ 0 ] . src = Piweek . mediaUrl ( "/files/bokzuy.ogg" ) ; pop . media . children [ 1 ] . src = Piweek . mediaUrl ( "/files/bokzuy.webm" ) ; pop . load ( ) ; pop . autoplay ( false ) ; pop . on ( 'loadeddata' , function ( e ) { this . currentTime ( time + 3 ) ; this . play ( ) ; } , false ) ; }
function ( ) { var pending = 3 ; function onend ( ) { if ( -- pending === 0 ) res . end ( ) ; } ps . on ( 'exit' , onend ) ; ps . stdout . on ( 'end' , onend ) ; ps . stderr . on ( 'end' , onend ) ; }
function ( msg ) { if ( msg . profile == window . app . profiles . DEFAULT ) { __runtimes = { } ; __old_runtimes = { } ; __runtimes_arr = [ ] ; __window_ids = { } ; __windows_reloaded = { } ; __threads = [ ] ; __log_threads = false ; __windowsFolding = { } ; __selected_runtime_id = '' ; __next_runtime_id_to_select = '' ; __selected_script = '' ; updateRuntimeViews ( ) ; } }
function ( select_id , runtimes , stopped_script_id , selected_script_id , search_term ) { var script_list = [ "div" ] ; for ( var i = 0 , rt ; rt = runtimes [ i ] ; i ++ ) { script_list . push ( this . runtime_script ( rt , stopped_script_id , selected_script_id , search_term ) ) ; } script_list . push ( "class" , "js-dd-script-list" , "handler" , "js-dd-move-highlight" ) ; return script_list ; }
function ( $ ) { $ ( "#list_name" ) . change ( function ( ) { alert ( "ok, name is changed" ) ; $ . ajax ( { url : '/admin/check_list_availability' , data : 'name=' + this . value , "success" : switchboard . check_list_name_ok } ) } ) ; }
function ( data ) { result = jQuery . parseJSON ( data ) ; window . console . log ( result ) ; $ ( "#score" ) . html ( result . score ) $ ( "#level" ) . html ( result . level ) }
function ( ) { if ( this . dropdown . selected ) { this . dropdown . selected . setAttribute ( 'class' , this . normalStyle ) ; this . dropdown . selected . img . style . visibility = 'hidden' ; } this . setAttribute ( 'class' , this . slectedStyle ) ; this . img . style . visibility = 'visible' ; this . dropdown . selected = this ; this . select . setSelectedItem ( this . index ) ; this . dropdown . hide ( ) ; }
function ( ) { if ( this . dropdown . selected ) { this . dropdown . selected . setAttribute ( 'class' , this . normalStyle ) ; this . dropdown . selected . img . style . visibility = 'hidden' ; } this . setAttribute ( 'class' , this . slectedStyle ) ; this . img . style . visibility = 'visible' ; this . dropdown . selected = this ; this . select . setSelectedItem ( this . index ) ; this . dropdown . hide ( ) ; }
function ( ) { if ( this . dropdown . selected ) { this . dropdown . selected . setAttribute ( 'class' , this . normalStyle ) ; this . dropdown . selected . img . style . visibility = 'hidden' ; } this . setAttribute ( 'class' , this . slectedStyle ) ; this . img . style . visibility = 'visible' ; this . dropdown . selected = this ; this . select . setSelectedItem ( this . index ) ; this . dropdown . hide ( ) ; }
function ( m ) { if ( typeof console != "undefined" ) { console . log ( "[pvChart ERROR]: " + m ) ; } else { throw new Error ( "[pvChart ERROR]: " + m ) ; } }
function ( instance ) { return new Rect ( instance . left , instance . top , 10 , 10 ) ; }
function ( instance ) { var midAngle = instance . startAngle + ( instance . angle / 2 ) ; var midRadius = ( instance . outerRadius + instance . innerRadius ) / 2 ; var dotLeft = instance . left + midRadius * Math . cos ( midAngle ) ; var dotTop = instance . top + midRadius * Math . sin ( midAngle ) ; return new Point ( dotLeft , dotTop ) ; }
function ( rect ) { if ( ! rect ) { return false ; } var sides = rect . getSides ( ) ; for ( var i = 0 ; i < 4 ; i ++ ) { if ( this . intersectsLine ( sides [ i ] ) ) { return true ; } } return false ; }
function getTextLength ( text , font ) { switch ( pv . renderer ( ) ) { case 'vml' : return getTextLenVML ( text , font ) ; case 'batik' : font = splitFontCGG ( font ) ; return getTextLenCGG ( text , font . fontFamily , font . fontSize , font . fontStyle , font . fontWeight ) ; } return getTextLenSVG ( text , font ) ; }
function getFontSize ( font ) { if ( pv . renderer ( ) == 'batik' ) { var sty = document . createElementNS ( 'http://www.w3.org/2000/svg' , 'text' ) . style ; sty . setProperty ( 'font' , font ) ; return parseInt ( sty . getProperty ( 'font-size' ) , 10 ) ; } var holder = getTextSizePlaceholder ( ) ; holder . css ( 'font' , font ) ; return parseInt ( holder . css ( 'font-size' ) , 10 ) ; }
function getTextLenVML ( text , font ) { return pv . Vml . text_dims ( text , font ) . width ; }
function ( ) { if ( ! ( typeof jQueryColorboxSettingsArray === 'object' ) ) { jQueryColorboxSettingsArray = getColorboxConfigDefaults ( ) ; } if ( jQueryColorboxSettingsArray . autoColorboxJavaScript == "true" ) { colorboxAddManualClass ( ) ; } if ( jQueryColorboxSettingsArray . colorboxAddClassToLinks == "true" ) { colorboxAddClassToLinks ( ) ; } if ( jQueryColorboxSettingsArray . autoHideFlash == "true" ) { colorboxHideFlash ( ) ; colorboxShowFlash ( ) ; } colorboxSelector ( ) ; }
function ( index , link ) { ColorboxLocal = jQuery . extend ( true , { } , jQueryColorboxSettingsArray ) ; var $linkHref = jQuery ( link ) . attr ( "href" ) ; if ( $linkHref !== undefined ) { colorboxLink ( index , link , $linkHref ) } }
function ( fileImage ) { this . _super ( ) ; if ( fileImage ) { this . initWithFile ( fileImage , cc . DEFAULT_CAPACITY ) ; } this . setContentSize ( new cc . Size ( cc . canvas . width , cc . canvas . height ) ) ; this . _renderTexture = cc . RenderTexture . create ( cc . canvas . width , cc . canvas . height ) ; }
function ( child , zOrder ) { cc . Assert ( child != null , "SpriteBatchNode.addChild():the child should not be null" ) ; cc . Assert ( this . _children . indexOf ( child ) > - 1 , "SpriteBatchNode.addChild():sprite batch node should contain the child" ) ; if ( zOrder == child . getZOrder ( ) ) { return ; } this . removeChild ( child , false ) ; this . addChild ( child , zOrder ) ; this . setNodeDirty ( ) ; }
function ( cleanup ) { if ( this . _children && this . _children . length > 0 ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var obj = this . _children [ i ] ; if ( obj ) { this . removeSpriteFromAtlas ( obj ) ; } } } this . _super ( cleanup ) ; this . _descendants = [ ] ; this . _textureAtlas . removeAllQuads ( ) ; }
function ( jsonData ) { var dict = jsonData ; var texturePath = "" ; var metadataDict = dict [ "metadata" ] ; if ( metadataDict ) { texturePath = this . _valueForKey ( "textureFileName" , metadataDict ) ; texturePath = texturePath . toString ( ) ; } var texture = cc . TextureCache . sharedTextureCache ( ) . addImage ( texturePath ) ; if ( texture ) { this . addSpriteFramesWithDictionary ( dict , texture ) ; } else { cc . Log ( "cocos2d: cc.SpriteFrameCache: Couldn't load texture" ) ; } }
function ( name ) { if ( ! name ) { return ; } if ( this . _spriteFramesAliases . hasOwnProperty ( name ) ) { delete ( this . _spriteFramesAliases [ name ] ) ; } if ( this . _spriteFrames . hasOwnProperty ( name ) ) { delete ( this . _spriteFrames [ name ] ) ; } }
function ( plist ) { var path = cc . FileUtils . fullPathFromRelativePath ( plist ) ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( path ) ; this . removeSpriteFramesFromDictionary ( dict ) ; }
function ( texture ) { var frameDict = null ; for ( var key in this . _spriteFrames ) { var frame = this . _spriteFrames [ key ] ; if ( frame && ( frame . getTexture ( ) == texture ) ) { delete ( this . _spriteFrames [ key ] ) ; } } }
function ( err ) { if ( err . code === "ECONNREFUSED" && retries ) { setTimeout ( tryConnect , retryDelay ) ; retries -- ; retryDelay *= 2 ; return ; } return callback ( err ) ; }
function watchDirectory ( path , options , callback ) { if ( ! checkType ( [ "path" , path , "string" , "options" , options , "object" , ] , callback ) ) return ; var meta = { } ; realpath ( path , function ( err , path ) { if ( err ) return callback ( err ) ; meta . watcher = fs . watch ( path , options , function ( event , filename ) { } ) ; callback ( null , meta ) ; } ) ; }
function ( ) { this . setElement ( $ ( "#activity-feed" ) ) ; $ ( this . el ) . html ( this . template ( this . model . toJSON ( ) ) ) ; this . activityFeed . el = this . $ ( '.activities' ) ; this . activityFeed . render ( ) ; return this ; }
function ( e ) { return { myValue : true , touches : [ { identifier : 1 , target : lowland . bom . Events . getTarget ( e ) , pageX : e . screenX , pageY : e . screenY } ] , scale : 1.0 } ; }
function urlX ( url ) { if ( /^(https?:\/\/|data:image)/ . test ( url ) ) { return url ; } }
function ( options , data ) { var clone = { } ; for ( var key in data ) { clone [ key ] = data [ key ] ; } if ( options . format ) { clone [ '__' + options . format + '__' ] = true ; } return html_sanitize ( Mustache . to_html ( x , clone ) , urlX , idX ) ; }
function hide ( ) { var _ct ; while ( _ct = tooltips . pop ( ) ) { if ( animate && transitionEvent ) { bean . add ( _ct , transitionEvent , remove ) ; _ct . className += ' wax-fade' ; } else { if ( _ct . parentNode ) _ct . parentNode . removeChild ( _ct ) ; } } }
function ( ) { if ( fullscreened ) { return ; } else { fullscreened = true ; } smallSize = [ map . parent . offsetWidth , map . parent . offsetHeight ] ; map . parent . className += ' wax-fullscreen-map' ; body . className += ' wax-fullscreen-view' ; ss ( map . parent . offsetWidth , map . parent . offsetHeight ) ; }
function ( ) { if ( ! fullscreened ) { return ; } else { fullscreened = false ; } map . parent . className = map . parent . className . replace ( ' wax-fullscreen-map' , '' ) ; body . className = body . className . replace ( ' wax-fullscreen-view' , '' ) ; ss ( smallSize [ 0 ] , smallSize [ 1 ] ) ; }
function ( ) { MM . addEvent ( map . parent , 'mousemove' , onMove ) ; MM . addEvent ( map . parent , 'mousedown' , onDown ) ; MM . addEvent ( map . parent , 'mouseup' , onUp ) ; tt = document . createElement ( 'div' ) ; tt . className = 'wax-latlngtooltip' ; return this ; }
function ( e ) { isMouseDown = false ; $sidebar . find ( ".triangle-visible" ) . css ( "display" , "block" ) ; $sidebar . find ( ".scroller-shadow" ) . css ( "display" , "block" ) ; $projectFilesContainer . triggerHandler ( "scroll" ) ; $openFilesContainer . triggerHandler ( "scroll" ) ; $mainView . off ( "mousemove.sidebar" ) ; $body . toggleClass ( "resizing" ) ; startingSidebarPosition = $sidebar . width ( ) ; }
function ( message , file , line ) { if ( QUnit . config . current ) { ok ( false , message + ", " + file + ":" + line ) ; } else { test ( "global failure" , function ( ) { ok ( false , message + ", " + file + ":" + line ) ; } ) ; } }
function checkPollution ( name ) { var old = config . pollution ; saveGlobal ( ) ; var newGlobals = diff ( config . pollution , old ) ; if ( newGlobals . length > 0 ) { ok ( false , "Introduced global variable(s): " + newGlobals . join ( ", " ) ) ; } var deletedGlobals = diff ( old , config . pollution ) ; if ( deletedGlobals . length > 0 ) { ok ( false , "Deleted global variable(s): " + deletedGlobals . join ( ", " ) ) ; } }
function join ( pre , arr , post ) { var s = jsDump . separator ( ) , base = jsDump . indent ( ) , inner = jsDump . indent ( 1 ) ; if ( arr . join ) arr = arr . join ( ',' + s + inner ) ; if ( ! arr ) return pre + post ; return [ pre , inner + arr , base + post ] . join ( s ) ; }
function ( extra ) { if ( ! this . multiline ) return '' ; var chr = this . indentChar ; if ( this . HTML ) chr = chr . replace ( /\t/g , '   ' ) . replace ( / /g , '&nbsp;' ) ; return Array ( this . _depth_ + ( extra || 0 ) ) . join ( chr ) ; }
functionArgs : function ( fn ) { var l = fn . length ; if ( ! l ) return '' ; var args = Array ( l ) ; while ( l -- ) args [ l ] = String . fromCharCode ( 97 + l ) ; return ' ' + args . join ( ', ' ) + ' ' ; }
function ( passageId , activeSearch ) { if ( activeSearch ) { step . menu . tickOneItemInMenuGroup ( 'SEARCH' , activeSearch , passageId ) ; this . _showRelevantFieldSet ( passageId ) ; } var newValue = this . _storeAndRetrieveCookieState ( passageId , "activeSearch" , activeSearch , true ) ; return newValue ; }
function ( passageId , reference , fireChange ) { step . state . activeSearch ( passageId , 'SEARCH_PASSAGE' ) ; if ( passageId != 0 && this . syncMode ( ) ) { if ( reference ) { return ; } return step . state . _storeAndRetrieveCookieState ( 0 , "reference" , reference , fireChange ) ; } var ref = this . _storedReference ( passageId , reference , fireChange ) ; if ( this . syncMode ( ) && reference ) { step . state . _fireStateChangedAllButFirst ( ) ; } return ref ; }
function ( ) { var dbCloseCount = 0 , connectionCloseCount = 0 , poolCloseCount = 0 ; db . on ( 'close' , function ( ) { dbCloseCount ++ ; } ) ; var connectionPool = db . serverConfig . connectionPool ; var connections = connectionPool . getAllConnections ( ) ; db . serverConfig . connectionPool . stop ( ) ; test . equal ( 0 , dbCloseCount ) ; test . done ( ) ; }
function ( html ) { if ( html ) { var div = doc . createElement ( "div" ) ; div . innerHTML = html ; div = this . _browserFilter ( div ) ; html = dijit . _editor . getChildrenHtml ( div ) ; div . innerHTML = "" ; if ( this . editor . _oldInsertHtmlImpl ) { return this . editor . _oldInsertHtmlImpl ( html ) ; } else { return this . editor . execCommand ( "inserthtml" , html ) ; } } return false ; }
function tweet ( data ) { count ++ ; if ( typeof data === 'string' ) sys . puts ( data ) ; else if ( data . text && data . user && data . user . screen_name ) sys . puts ( '"' + data . text + '" -- ' + data . user . screen_name ) ; else if ( data . message ) sys . puts ( 'ERROR: ' + sys . inspect ( data ) ) ; else sys . puts ( sys . inspect ( data ) ) ; }
function ( request ) { var boundaryText = request . boundary ? ( "<br/>" + request . boundary ) : "" ; var parsedDate = new Date ( request . requested_datetime ) ; return "<h2>" + request . service_name + "</h2>" + "<h4>Address</h4><p>" + request . address + boundaryText + "</p>" + "<h4>Description</h4><p>" + request . description + "</p>" + "<h4>Created</h4><p>" + dateTools . formatDate ( parsedDate ) + " <span class='ago'>" + dateTools . timeSpanString ( parsedDate ) + " ago</span></p>" + ( request . status === "closed" ? "<h5>CLOSED</h5>" : "" ) ; }
function ( ) { return this . _skip ( ) && ( n = this . _getIntermediate ( ) , true ) && this . _rule ( "trans" , false , [ ] , null , this [ "trans" ] ) && ( v = this . _getIntermediate ( ) , true ) ; }
function ( item , index , oldItem ) { console . log ( oldItem ) ; if ( item . active == true && oldItem . active == 'false' ) { console . log ( "ring! ring!" ) ; ring . play ( ) ; } }
function ( ) { if ( this . model . get ( "audioVideo" ) ) { if ( this . model . get ( "audioVideo" ) . get ( "filename" ) != undefined ) { this . $el . find ( ".audio-file" ) . attr ( "src" , "filesystem:" + window . location . origin + "/temporary/" + this . model . get ( "audioVideo" ) . get ( "filename" ) ) ; this . $el . find ( ".audio-file" ) . play ( ) ; } } }
function ( ) { var view = new Todo . View . TodoList ; view . collection . fetch ( { success : function ( ) { view . render ( ) ; } } ) ; }
function ( ) { this . model . trigger ( 'save-success' ) ; }
function ( ) { this . model . trigger ( 'save-success' ) ; }
function ( ) { var view = new Todo . View . TodoList ; view . collection . fetch ( { success : function ( ) { view . render ( ) ; } } ) ; }
function ( ) { var partyParams = partyMachine . getUrlParams ( ) ; var feedUrl = partyFeedUrl + "?jsoncallback=?" + '&id=' + partyParams [ "id" ] ; $ . ajax ( { url : feedUrl , jsonp : true , dataType : 'json' , success : function ( data ) { mediaPlayer . update ( data . media ) ; } } ) ; _mediaTimeoutTimer = window . setTimeout ( "window.partyMachine.updateMediaTimeout()" , _mediaTimeoutTimerDelay ) ; }
function ( html ) { on_a_link = true ; $ ( "div.popup" ) . show ( speed ) ; $ ( "div.popup" ) . animate ( { top : event . pageY - 100 , left : 0 , } , speed ) ; $ ( "div.popup" ) . html ( html ) ; }
function ( event ) { $ . ajax ( event . currentTarget . children [ 1 ] . href , { success : function ( html ) { on_a_link = true ; $ ( "div.popup" ) . show ( speed ) ; $ ( "div.popup" ) . animate ( { top : event . pageY - 100 , left : 0 , } , speed ) ; $ ( "div.popup" ) . html ( html ) ; } , } ) ; }
function pasteElement ( element ) { Seam . Remoting . getContext ( ) . setConversationId ( currentConversationId ) ; Seam . Component . getInstance ( "FileManageActions" ) . pasteWithId ( element . id , pasteCallback ) ; }
function ( arg ) { if ( arg === 'video' ) { Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . VIDEO ) } else if ( arg === 'audio' ) { Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . AUDIO ) } else if ( arg === 'photo' ) { Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . PHOTO ) } }
function ( ) { Ext . getCmp ( 'username' ) . reset ( ) ; Ext . getCmp ( 'password' ) . reset ( ) ; if ( USER . type === 'CHW' ) { this . doDownload ( ) ; Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . PATIENT_LIST ) } else if ( USER . type === 'VC' ) { Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . INBOX_VC ) } }
function ( record ) { Ext . getCmp ( 'resource_title' ) . setTitle ( record . get ( 'resourceName' ) ) ; if ( record . get ( 'resourceType' ) === 'photo' ) { var located = 'resources/' + record . get ( 'resourceLocation' ) + '.png' Ext . getCmp ( 'resource_label' ) . setHtml ( '<img src="' + located + '" height="100%" width="100%"/>' ) } Ext . getCmp ( 'viewPort' ) . setActiveItem ( PAGES . RESOURCE_DET ) }
function ( ) { this . pause ( ) var last = track . find ( '.gallery-thumbnail' ) . last ( ) , left = parseInt ( track . css ( 'left' ) , 10 ) morpheus ( track [ 0 ] , { left : Math . max ( left - track . parent ( ) . width ( ) , - ( last . position ( ) . left + last . width ( ) - track . parent ( ) . width ( ) ) ) , duration : 300 } ) }
function ( ) { this . pause ( ) var left = parseInt ( track . css ( 'left' ) , 10 ) morpheus ( track [ 0 ] , { left : Math . min ( left + track . parent ( ) . width ( ) , 0 ) , duration : 300 } ) }
function ( currentItem , recycled ) { var tplSelect ; if ( currentItem . index == 0 ) { tplSelect = document . querySelector ( '.largeitemtemplate' ) . winControl ; } else { tplSelect = document . querySelector ( '.itemtemplate' ) . winControl ; } tplSelect = tplSelect . renderItem ( itemPromise , recycled ) ; return tplSelect . element ; }
function templateHandler ( itemPromise ) { return itemPromise . then ( function ( currentItem , recycled ) { var tplSelect ; if ( currentItem . index == 0 ) { tplSelect = document . querySelector ( '.largeitemtemplate' ) . winControl ; } else { tplSelect = document . querySelector ( '.itemtemplate' ) . winControl ; } tplSelect = tplSelect . renderItem ( itemPromise , recycled ) ; return tplSelect . element ; } ) ; }
function ( err , user ) { if ( user != null ) return promise . fulfill ( user ) ; var user = new User ( { _id : id , name : fbUserMetadata . name , submissions : [ ] } ) ; user . save ( function ( err ) { if ( err ) return promise . fail ( err ) ; promise . fulfill ( user ) ; } ) ; }
function ( err ) { if ( err ) throw err ; var submission = new Submission ( { solution : solution . _id } ) ; submission . save ( function ( err ) { if ( err ) throw err ; req . user . submissions . push ( submission ) ; req . user . save ( function ( err ) { if ( err ) throw err ; } ) ; } ) ; }
function ( module ) { var url = module . key if ( ! module . key . match ( /\.[a-zA-Z]+$/ ) ) url = module . key + ".js" logger . info ( "Net Fetch: " + url ) if ( url . match ( "\.js" ) ) this . insertScriptTag ( url ) else xhr ( url , this . xhrHandler ( module ) ) }
function ( ) { if ( ! this . player ) { return ; } var currentTime ; if ( this . useHtml5Player ) { currentTime = this . player . currentTime ; } else { currentTime = dojo . when ( this . player . getCurrentPosition ( ) , function ( position ) { return position ; } ) ; } return currentTime ; }
function ( evt ) { if ( menuVisible ) { return ; } var menu = document . getElementById ( 'contextMenu' ) ; menu . className = 'showMenu' ; menuVisible = true ; if ( menuPeeked ) { evt . cancelBubble = true ; menuPeeked = false ; } }
function discoverChatInputElement ( ) { var chatInput = document . querySelector ( 'textarea' ) ; if ( chatInput ) { onChatInputDiscovered ( chatInput ) ; } else { setTimeout ( discoverChatInputElement , 1000 ) ; } }
function ( item , index , oldItem ) { console . log ( "Old: " + oldItem . active + " New: " + item . active ) ; if ( item . active == true && oldItem . active == 'false' ) { console . log ( "ring! ring!" ) ; ring . play ( ) ; } }
function ( packet ) { packet . subCmd = packet . seekInt ( 2 ) ; var subCmd = intToHexStr ( packet . subCmd ) ; if ( ! sub [ subCmd ] ) { console . log ( 'Client sent unknown subcommand for 0xBF: ' + subCmd ) ; return ; } return sub [ subCmd ] . call ( this , packet ) ; }
function ( session , config , callback ) { var context = { session : session , config : config } , workflow = buildWorkflow ( session , context ) ; if ( workflow ) { workflow . start ( { "callback" : callback } ) ; } }
function ( f ) { fullPath = path . join ( dir , f ) ; if ( ! fs . statSync ( fullPath ) . isDirectory ( ) ) { if ( path . extname ( fullPath ) . toLowerCase ( ) !== ".js" ) { throw localize . translate ( "EXCEPTION_NON_JS_FILE_IN_API_DIR" , fullPath ) ; } } else { checkNonJSFiles ( fullPath ) ; } }
function checkNonJSFiles ( dir ) { var files = fs . readdirSync ( dir ) , fullPath ; files . forEach ( function ( f ) { fullPath = path . join ( dir , f ) ; if ( ! fs . statSync ( fullPath ) . isDirectory ( ) ) { if ( path . extname ( fullPath ) . toLowerCase ( ) !== ".js" ) { throw localize . translate ( "EXCEPTION_NON_JS_FILE_IN_API_DIR" , fullPath ) ; } } else { checkNonJSFiles ( fullPath ) ; } } ) ; }
function ( ) { var data = testUtilities . cloneObj ( testData . xml2jsConfig ) ; data . content [ "@" ] . src = "localFile.html" ; mockParsing ( data ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . content ) . toEqual ( "local:///localFile.html" ) ; } ) ; }
function ( ) { var data = testUtilities . cloneObj ( testData . xml2jsConfig ) ; data [ 'rim:permit' ] = [ ] ; mockParsing ( data ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . permissions ) . toContain ( 'access_internet' ) ; } ) ; }
function ( configObj ) { expect ( configObj . hasMultiAccess ) . toEqual ( false ) ; expect ( configObj . accessList ) . toEqual ( [ { features : configParser . getGlobalFeatures ( ) , uri : 'WIDGET_LOCAL' , allowSubDomain : true } , { "features" : configParser . getGlobalFeatures ( ) , "uri" : "http://www.somedomain1.com" } ] ) ; }
function ( configObj ) { expect ( configObj . hasMultiAccess ) . toEqual ( true ) ; expect ( configObj . accessList ) . toEqual ( [ { features : configParser . getGlobalFeatures ( ) , uri : 'WIDGET_LOCAL' , allowSubDomain : true } , { "features" : configParser . getGlobalFeatures ( ) , "uri" : "http://www.somedomain1.com" } ] ) ; }
function ( ) { var data = testUtilities . cloneObj ( testData . xml2jsConfig ) ; data [ "@" ] . version = "1.0.0.50" ; mockParsing ( data ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . version ) . toEqual ( "1.0.0" ) ; expect ( configObj . buildId ) . toEqual ( "50" ) ; } ) ; }
function ( ) { var data = testUtilities . cloneObj ( testData . xml2jsConfig ) ; session . buildId = "100" ; mockParsing ( data ) ; configParser . parse ( configPath , session , function ( configObj ) { expect ( configObj . buildId ) . toEqual ( "100" ) ; } ) ; }
function swapOptions ( theSel , index1 , index2 ) { var text , value ; text = theSel . options [ index1 ] . text ; value = theSel . options [ index1 ] . value ; theSel . options [ index1 ] . text = theSel . options [ index2 ] . text ; theSel . options [ index1 ] . value = theSel . options [ index2 ] . value ; theSel . options [ index2 ] . text = text ; theSel . options [ index2 ] . value = value ; }
function ( p ) { var player = new Player ( { 'id' : p . id , 'index' : p . index , 'name' : p . name , 'ísHuman' : p . isHuman , 'team' : p . team } ) ; game . addPlayer ( player ) ; game . drawPlayer ( player ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'update_history' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 57 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 706 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 728 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 769 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 800 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( ) { setup_timeline ( '.detail-view' , 69 ) ; setup_subscriptions ( ".detail-view" ) ; setup_tags ( ".detail-view .tags > ul > li" ) ; setup_tooltips ( ".detail-view" ) ; load_fb_comment_count ( ".detail-view" ) ; return __iced_k ( $ ( 'html, body' ) . animate ( { scrollTop : 0 } , 0 ) ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 887 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'update_history' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 57 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 706 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 728 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 769 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 800 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( ) { setup_timeline ( '.detail-view' , 69 ) ; setup_subscriptions ( ".detail-view" ) ; setup_tags ( ".detail-view .tags > ul > li" ) ; setup_tooltips ( ".detail-view" ) ; load_fb_comment_count ( ".detail-view" ) ; return __iced_k ( $ ( 'html, body' ) . animate ( { scrollTop : 0 } , 0 ) ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 887 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'update_history' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 57 } ) ) , 0 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 706 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 728 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 769 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 800 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( ) { setup_timeline ( '.detail-view' , 69 ) ; setup_subscriptions ( ".detail-view" ) ; setup_tags ( ".detail-view .tags > ul > li" ) ; setup_tooltips ( ".detail-view" ) ; load_fb_comment_count ( ".detail-view" ) ; return __iced_k ( $ ( 'html, body' ) . animate ( { scrollTop : 0 } , 0 ) ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 887 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( ) { var element = $ ( '<input type="text" />' ) ; var options = { messages : { only_integer : "failed validation" } , only_integer : true } ; element . val ( '123.456' ) ; equal ( ClientSideValidations . validators . local . numericality ( element , options ) , "failed validation" ) ; }
function handleLoadMyApplicationResponse ( mime , data ) { if ( mime == "text/url" ) { window . location = data ; } else if ( mime == "application/json" ) { var obj = eval ( "(" + data + ")" ) ; stupidThing = obj . author ; var table = document . getElementById ( "applications" ) ; table . innerHTML = "Bewerbung für " + obj . offerName ; selectDocuments ( ) ; } }
function ( mime , data ) { if ( mime == "text/url" ) { window . location = data ; } else if ( mime == "text/error" ) { alert ( data ) ; } else if ( mime == "text/email" ) { var button = document . getElementById ( "mailToProvider" ) ; alert ( data ) ; button . setAttribute ( "onclick" , "clickMail('" + data + "', '[Hiwi-Börse:" + document . getElementById ( "applications" ) . innerText + "]')" ) ; } }
function reject ( ) { annehmen = false ; changed = true ; togglePopup ( 'offer_reject' , false ) ; document . getElementById ( "state" ) . innerHTML = "Abgelehnt" ; }
function documentsFromOffer ( ) { var aid = getURLParameter ( "AID" ) ; connect ( "/hiwi/Clerk/js/documentsFromOffer" , "aid=" + aid , handledocumentsFromOfferResponse ) ; }
function ( key , element , resourceTable ) { var self = this ; this . element = element ; this . resourceTable = resourceTable ; element . change ( function ( ) { var filter = { } ; filter [ key ] = element . val ( ) ; resourceTable . filter ( filter ) ; } ) ; }
function ( e ) { e . preventDefault ( ) ; this . emailText = $ ( this . el ) . find ( 'textarea' ) . val ( ) ; this . trigger ( 'sent' ) ; return $ ( '#preview-order-form' ) . modal ( 'hide' ) ; }
function ( datafile , cb ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( "GET" , datafile ) ; xhr . onreadystatechange = function ( ) { if ( xhr . readyState === 4 ) { cb ( xhr . responseText ) ; } } ; xhr . send ( null ) ; }
function ( ) { var pPos = body . GetPosition ( ) ; this . position . X = pPos . X ; this . position . Y = pPos . Y ; $draw ( ) ; }
function ( ) { var lastUpdated = _ . chain ( this . gists ) . max ( function ( entry ) { return entry . updated_at ; } ) . value ( ) ; var response = '<?xml version="1.0" encoding="utf-8"?>\n' + '<feed xmlns="http://www.w3.org/2005/Atom"><title>Withouttheloop.com</title>\n' + '<id>http://withouttheloop.com/</id>\n' + '<link rel="self" href="http://withouttheloop.com/feed" />\n' + '<updated>' + new Date ( ) . toJSON ( ) + '</updated>' ; _ ( this . gists ) . each ( function ( gist ) { response += toEntryNode ( gist ) ; response += '\n' ; } ) ; return response + '</feed>' ; }
function makePropertyObject ( name , value ) { var object = { name : name , scope : scope , type : value . metadata . type || value . type || 'unknown' , from : value . file . moduleId } ; if ( value . metadata . tags . indexOf ( 'private' ) > - 1 ) { object [ "private" ] = "true" ; } return object ; }
function ( event , $uiConf , callback ) { if ( embedPlayer . isPluginEnabled ( 'vast' ) ) { var loadingAdPlugin = true ; mw . load ( [ "AdSupport" , "mw.KAds" ] , function ( ) { mw . addKalturaAds ( embedPlayer , function ( ) { mw . log ( "AdPlugin ( done loading ads, run callback:" ) ; callback ( ) ; } ) ; } ) ; return ; } callback ( ) ; }
function panelFlash ( ) { switch ( _ev ( "song-tab" ) ) { case 'Everything' : if ( ! _db [ _channel ] ) { _socket . emit ( "get-all-videos" ) ; } else { Song . search ( ) ; } break ; case 'History' : _socket . emit ( "get-history" ) ; break ; } }
function ( name , user , cb ) { _db . set ( "user:" + name + ":" + user , 1 ) ; _db . expire ( "user:" + name + ":" + user , 10 , function ( ) { count ( name , cb ) ; } ) ; }
function ( which ) { _db = which ; }
function ( cb ) { _db . hkeys ( "channel" , function ( err , last ) { cb ( last ) ; } ) ; }
function ( ) { var self = this ; this . worker = new Worker ( 'BitComposerWorker.js' ) ; this . worker . addEventListener ( 'message' , function ( event ) { return self . messageFromWorker ( event ) ; } , false ) ; this . refinementCallback = { } ; }
function ( ) { onloadCallback ( this . xhr ) ; -- x3dom . DownloadManager . activeDownloads ; x3dom . DownloadManager . tryNextDownload ( ) ; }
function ( sheet , eventData ) { var sheetSearch = this . dirtyStyleSheets . filter ( function ( sheetObj ) { return sheetObj . stylesheet === sheet ; } ) ; NJevent ( 'styleSheetModified' , eventData ) ; this . currentDocument . model . needsSave = true ; if ( sheetSearch . length === 0 ) { this . dirtyStyleSheets . push ( { document : sheet . ownerNode . ownerDocument , stylesheet : sheet } ) ; } }
function toggleShowContentFct ( outerElement ) { var content = $ ( ".hiddenContent" , outerElement ) ; var vis = $ ( ":visible" , content ) ; if ( vis . length > 0 ) { content . slideUp ( 100 ) ; $ ( ".showElement" , outerElement ) . show ( ) ; $ ( ".hideElement" , outerElement ) . hide ( ) ; } else { content . slideDown ( 100 ) ; $ ( ".showElement" , outerElement ) . hide ( ) ; $ ( ".hideElement" , outerElement ) . show ( ) ; } }
function ( url ) { if ( ! Sitesearch . selected . length || - 1 != Sitesearch . selected . indexOf ( url . id ) ) { chrome . contextMenus . create ( { 'title' : url . name , 'contexts' : [ 'selection' ] , 'onclick' : Sitesearch . search } ) ; selected . push ( url ) ; item_count ++ ; } }
function ( ) { it ( 'should create a todo with an id' , function ( done ) { dpd . todos . post ( { title : 'faux' } , function ( todo ) { expect ( todo . id . length ) . to . equal ( 24 ) ; done ( ) ; } ) ; } ) ; }
function ( err ) { if ( err instanceof Error ) { debug ( 'error when executing %s listener' , method , err ) err . message = "Error while executing " + method + " event: " + err . message ; } ; fn ( err || errors , item ) ; }
function ( err ) { if ( err instanceof Error ) { err . message = "Error while executing " + method + " event: " + err . message ; debug ( 'error when executing %s listener' , method , err ) ; } fn ( err || errors , item ) ; }
function ( evt ) { var inputDate = moment ( this . input . getValue ( ) , this . options . format ) ; if ( ! inputDate ) { return ; } this . setValue ( inputDate . format ( 'YYYY-MM-DD' ) !== invalidDate ? inputDate : this . getValue ( ) ) ; this . menu . hide ( ) ; }
function ( datePicker ) { datePicker . $node . find ( 'input' ) . trigger ( 'focus' ) ; }
function ( ) { var dp = DatePicker ( undefined , { date : moment ( '2012-07-13' ) } ) ; openDatePicker ( dp ) ; dp . monthView . $node . find ( 'td:contains(14)' ) . trigger ( 'click' ) ; dateIsSelected ( dp , moment ( '2012-07-14' ) ) ; dp . monthView . $node . find ( 'td:contains(28)' ) . trigger ( 'click' ) ; dateIsSelected ( dp , moment ( '2012-07-28' ) ) ; }
function ( module , filename ) { var code = fs . read ( filename ) ; var CoffeeScript = require ( '_coffee-script' ) ; try { code = CoffeeScript . compile ( code ) ; } catch ( e ) { e . fileName = filename ; throw e ; } module . _compile ( code ) ; }
function ( request , exports ) { self . stubs [ request ] = { exports : exports } ; }
function ( ) { var cwd , mainFilename , mainModule = new Module ( ) ; window . require = mainModule . _getRequire ( ) ; fs = loadFs ( ) ; cwd = fs . absolute ( phantom . libraryPath ) ; mainFilename = joinPath ( cwd , basename ( require ( 'system' ) . args [ 0 ] ) || 'repl' ) ; mainModule . _setFilename ( mainFilename ) ; }
function ( root ) { cache = { } ; Controller . index = Controller . index || { } ; Controller . aliases = Controller . aliases || { } ; Controller . context = Controller . context || { } ; exports . addBasePath ( root + '/app/controllers' , null , null , root ) ; }
function ( ) { var self = this ; self . overlays = [ ] }
function ( ) { var self = this ; return self . polygon ; }
function ( template ) { var instances = self . templateObjects ; if ( instances ) { instances . owner = self ; } else { instances = { owner : self } ; } self . _isTemplateInstantiated = true ; template . instantiateWithInstancesAndDocument ( instances , self . _element . ownerDocument , function ( ) { if ( callback ) { callback ( ) ; } } ) ; }
function ( index , Element ) { var data = $ ( this ) . data ( 'swipePanel' ) ; if ( data ) { data . components . rootSize = $ ( this ) [ data . options . _dimension ] ( ) ; } }
function ( ) { Ext . create ( 'Ext.Container' , { id : 'mainView' , fullscreen : true , layout : 'card' , items : [ { xclass : 'RaxaEmr.view.Login' } , { xclass : 'RaxaEmr.view.AppGrid' } , { xclass : 'RaxaEmr.view.AppCarousel' } ] } ) ; }
function ( attr ) { var type = this . getType ( ) ; if ( _ ( attr ) . isString ( ) ) { attr = type . fields [ attr ] ; } var data = _ . extend ( { } , this , { descriptors : this . descriptors . concat ( [ attr ] ) } ) ; return new PathInfo ( data ) ; }
function ( e ) { return e . nextSibling ; }
function getSpanVal ( td , name ) { return parseInt ( td . getAttribute ( name ) || 1 ) ; }
function ( schema ) { if ( schema . constructor == String ) schema = { type : schema } ; var typeChecker = this . typeFor ( schema . type ) ; return new typeChecker ( schema , this ) ; }
function ( event_name , data ) { if ( data && data . stack ) return self . say ( data . toString ( ) ) else if ( ! event_name . match ( 'actions_' ) ) self . say ( "New event: " + event_name , data ) ; if ( self . combos [ event_name ] ) self . parse_message ( self . combos [ event_name ] , true ) ; delete self . combos [ event_name ] ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . innerHTML = '<v:shape adj="1"/>' ; var shape = div . firstChild ; shape . style . behavior = 'url(#default#VML)' ; return shape && ( typeof shape . adj === 'object' ) ; }
function MailFolder ( api , wireRep ) { this . _api = api ; this . id = wireRep . id ; this . name = wireRep . name ; this . path = wireRep . path ; this . type = wireRep . type ; this . selectable = ( wireRep . type !== 'account' ) && ( wireRep . type !== 'nomail' ) ; this . onchange = null ; this . onremove = null ; this . element = null ; this . data = null ; }
function MessageComposition ( api , handle ) { this . _api = api ; this . _handle = handle ; this . senderIdentity = null ; this . to = null ; this . cc = null ; this . bcc = null ; this . subject = null ; this . body = null ; this . _customHeaders = null ; this . _attachments = null ; }
function ( ) { return { senderId : this . senderIdentity . id , to : this . to , cc : this . cc , bcc : this . bcc , subject : this . subject , body : this . body , customHeaders : this . _customHeaders , attachments : this . _attachments , } ; }
function walkBoxes ( boxLevel , pathSoFar ) { for ( var boxName in boxLevel ) { var box = boxLevel [ boxName ] , boxPath = pathSoFar ? ( pathSoFar + boxName ) : boxName , type = self . _determineFolderType ( box , boxPath ) ; folderMeta = self . _learnAboutFolder ( boxName , boxPath , type , box . delim ) ; } }
function ( ) { var args = [ ] . slice . call ( arguments ) ; var i = 0 ; var j = args . length ; var child = { } ; var prop ; for ( ; i < j ; i ++ ) { for ( prop in parent ) { child [ prop ] = parent [ prop ] ; } } return child ; }
function choose ( imgsrc ) { var id = imgsrc . match ( "/([^\./]+)\.png" ) [ 1 ] addToHistory ( id ) justShow ( id ) }
function fillSamples ( sources ) { var loadedImages = [ ] for ( i = 0 ; i < sources . length ; i ++ ) { var id = sources [ i ] . id $ ( "samples" + i % 2 ) . innerHTML += "<div class='diagramEntry' id='s.i." + id + "'/>" loadedImages [ i ] = image ( id ) loadedImages [ i ] . id = "i." + id setListeners ( loadedImages [ i ] , id ) } }
function ( ) { fillIn ( ) var historyHtml = "" for ( var i = 0 ; i < MAX_HISTORY_LENGTH ; i ++ ) { historyHtml += "<div class=diagramEntry>" + "<img id=\"h." + i + "\" width=100 style='visibility:hidden' " + "onclick='choose(this.src)'/>" + "</div>" } $ ( "history" ) . innerHTML = historyHtml showHistory ( ) }
function choose ( imgsrc ) { var id = imgsrc . match ( "/([^\./]+)\.png" ) [ 1 ] addToHistory ( id ) justShow ( id ) }
function fillSamples ( sources ) { var loadedImages = [ ] for ( i = 0 ; i < sources . length ; i ++ ) { var id = sources [ i ] . id $ ( "samples" + i % 2 ) . innerHTML += "<div class='diagramEntry' id='s.i." + id + "'/>" loadedImages [ i ] = image ( id ) loadedImages [ i ] . id = "i." + id setListeners ( loadedImages [ i ] , id ) } }
function ( ) { fillIn ( ) var historyHtml = "" for ( var i = 0 ; i < MAX_HISTORY_LENGTH ; i ++ ) { historyHtml += "<div class=diagramEntry>" + "<img id=\"h." + i + "\" width=100 style='visibility:hidden' " + "onclick='choose(this.src)'/>" + "</div>" } $ ( "history" ) . innerHTML = historyHtml showHistory ( ) }
function ( index , item ) { if ( item == 'collapsed' ) { $nodeRow . nextAll ( 'tr' ) . css ( 'display' , 'none' ) ; $nodeRow . removeClass ( 'expanded' ) ; $nodeRow . addClass ( 'contracted' ) ; $nodeDiv . css ( 'cursor' , 's-resize' ) ; } else { $nodeDiv . addClass ( item ) ; } }
function ( index , item ) { if ( item == 'collapsed' ) { $nodeRow . nextAll ( 'tr' ) . css ( 'display' , 'none' ) ; $nodeRow . removeClass ( 'expanded' ) ; $nodeRow . addClass ( 'contracted' ) ; $nodeDiv . css ( 'cursor' , 's-resize' ) ; } else { $nodeDiv . addClass ( item ) ; } }
function ( req , res ) { req . session . lang = req . params . value ; res . writeHead ( 302 , { 'Location' : '/' } ) ; res . end ( ) ; }
function ( ) { var person1 = Object . create ( Midway . Person ) ; var person2 = Object . create ( Midway . Person , { name : { value : "Bob" } } ) ; equal ( person1 . sayName ( ) , "James" ) ; equal ( person2 . sayName ( ) , "Bob" ) ; }
function ( ) { if ( ! this . editor ) return ; try { this . editor . removeEventListener ( "keypress" , this . onKeyPress ) ; } catch ( err ) { } this . editor . removeEventListener ( CONTEXT_MENU , this . onContextMenu ) ; this . editor . removeEventListener ( TEXT_CHANGED , this . onTextChanged ) ; this . editor . destroy ( ) ; this . editor = null ; }
function ( event ) { Firebug . CommandLine . update ( Firebug . currentContext ) ; switch ( event . keyCode ) { case KeyEvent . DOM_VK_RETURN : if ( Events . isControl ( event ) ) this . onExecute ( ) ; break ; case KeyEvent . DOM_VK_ESCAPE : this . onEscape ( ) ; event . preventDefault ( ) ; break ; } }
function Droppable ( element , callback ) { if ( Draggable && Compatible ) { element . drpbl = true ; self = this ; Compatible . addListener ( document , 'mouseup' , function ( ) { self . dropped . call ( element ) ; } ) ; } }
function ( e ) { for ( var i = 0 ; i < Draggable . elements . length ; i ++ ) { var intersect = Droppable . intersect ( this , Draggable . elements [ i ] ) ; if ( intersect ) { console . log ( "INTERSECT" , Draggable . elements [ i ] ) ; } } }
function domobiles ( ) { var mobile = ( /iphone|ipad|ipod|android|blackberry/i . test ( navigator . userAgent . toLowerCase ( ) ) ) ; if ( ! mobile ) { $ ( 'frontbox' ) . style . width = "558px" ; } }
function ( ) { var webApp ; log ( "INFO" , "[PZP-" + self . sessionId + "] Connection terminated from PZH" ) ; if ( typeof self . sessionId !== "undefined" ) { self . messageHandler . removeRoute ( self . config . pzhId , self . sessionId ) ; if ( self . config . pzhId ) { delete self . connectedPzh [ self . config . pzhId ] ; } } }
function ( $ ) { $ ( '#recipient' ) . autoSuggest ( data ) ; $ ( '#send-form' ) . submit ( function ( ) { $ ( '<input type="hidden" name="recipient" value="' + $ ( '.as-values' ) . val ( ) + '" />' ) . appendTo ( $ ( this ) ) ; } ) ; }
function ( ) { that . manageImageSize ( $ ( this ) ) ; }
function ( queues ) { var queue = queues [ 0 ] , block = queue . block , fn = renderer ( view , reduceStack ( queue . stack ) , queue . events ) fn . unescaped = true ; block . macroCtx [ ctxName ] = fn ; if ( sectionName ) return ; push ( view , ns , stack , events , attrs , '' , block ) ; }
function ( ) { movablePoint . visibleShape = graph . ellipse ( [ 1 , 1 ] , [ 4 / graph . scale [ 0 ] , 4 / graph . scale [ 1 ] ] ) ; movablePoint . visibleShape . attr ( { cx : 0 , cy : 0 } ) ; }
function ( coord ) { this . coord = coord . slice ( ) ; this . transform ( ) ; }
function ( x , y ) { var angle = Math . atan2 ( pro . center [ 1 ] - y , pro . center [ 0 ] - x ) * 180 / Math . PI ; pro . rotate ( - angle - 5 ) ; }
function ( now , fx ) { if ( fx . prop === "x" ) { pro . move ( [ now , pro . center [ 1 ] ] ) ; } else { pro . move ( [ pro . center [ 0 ] , now ] ) ; } }
function ( a , b ) { var name_a = a . name . toLowerCase ( ) , name_b = b . name . toLowerCase ( ) ; if ( name_a > name_b ) { return 1 ; } else if ( name_a < name_b ) { return - 1 ; } else { return 0 ; } }
function getNthBody ( ast , n ) { if ( n === 1 ) { return ast ; } else { return getNthBody ( getLambdaBody ( ast ) , n - 1 ) ; } }
function ia_red_update ( red ) { if ( red . getColor ( ) == 1 && ! red . seesWater ) { red . seesWater = true ; } if ( red . getColor ( ) != 1 && red . seesWater ) { red . seesWater = false ; red . direction *= - 1 ; } red . rotate ( red . direction * 10 ) ; red . forward ( 10 ) ; }
function ( me ) { try { eval ( userCode ) ; } catch ( err ) { window . alert ( err ) ; stop ( ) ; return ( false ) ; } return ( true ) ; }
function ( elementData ) { var element , previous = null , next = null ; next = this . first ; element = new LinkedListElement ( elementData , previous , next , storeMatrixObject ) ; if ( this . length != 0 ) this . first . previous = element ; this . first = element ; if ( this . length == 0 ) this . last = element ; this . length ++ ; }
function ( x , y ) { var bakx = this . x ; var baky = this . y ; safeMove ( this , this . x + x , this . y + y ) ; this . update ( ) ; objectPositionChanged ( this . parent , bakx , baky , this . x , this . y ) ; }
function ( ) { expect ( mailcheck . splitEmail ( 'example.com' ) ) . toBeFalsy ( ) ; expect ( mailcheck . splitEmail ( 'abc.example.com' ) ) . toBeFalsy ( ) ; }
function ( email ) { var parts = email . split ( '@' ) ; if ( parts . length < 2 ) { return false ; } return { domain : parts . pop ( ) , address : parts . join ( '@' ) } }
function ( next , sync ) { if ( _self . expired ( ) ) { _self . client = cloudfiles . createClient ( _config ) ; _self . client . setAuth ( function ( err , res , config ) { if ( err ) { return next ( err ) ; } _self . expiry = new Date ( ) . getTime ( ) + 23 * 60 * 60 * 1000 ; next ( ) ; } ) ; } else { next ( ) ; } }
function ( ) { $ ( this ) . children ( ".triangle" ) . removeClass ( "triangle-up" ) ; $ ( "div#sortbar a.dropdown:has(b.triangle)" ) . off ( "click.triangle" ) . one ( "click.triangle" , alt ) ; $ ( "div#sortbar a.dropdown:has(b.triangle-up)" ) . off ( "click.triangle" ) . one ( "click.triangle" , self ) ; $ ( this ) . off ( "click.triangle" ) . one ( "click.triangle" , self ) . removeAttr ( "data-reverse" ) ; }
function ( event ) { event . stopPropagation ( ) ; var list = [ ] ; for ( var i = 0 ; i < 12 ; i ++ ) { list . push ( this . symbols_ . MONTHS [ i ] ) ; } this . createMenu_ ( this . elMonth_ , list , this . handleMonthMenuClick_ , this . symbols_ . MONTHS [ this . activeMonth_ . getMonth ( ) ] ) ; }
function ( value ) { if ( dfd !== _ . last ( self . _currentDfds ) ) { remove ( self . _currentDfds , dfd ) ; return $ . Deferred ( ) . reject ( ) ; } remove ( self . _currentDfds , dfd ) ; return this . resolve ( ) ; }
function ( template , vars ) { renderer . render ( target + " .contents" , template , vars ) ; dom . addClass ( BODY , className ) ; dom . fireEvent ( window , "resize" ) ; this . visible = true ; }
function showFailure ( error , info , callback ) { info = $ . extend ( info || { } , { action : error , dialog : false } ) ; bid . Screens . error . show ( "error" , info ) ; errorDisplay . start ( ) ; callback && callback ( false ) ; }
function ( ) { testHelpers . testErrorVisible ( ) ; $ ( "#error" ) . show ( ) ; $ ( "#moreInfo" ) . hide ( ) ; $ ( "#openMoreInfo" ) . trigger ( "click" ) ; setTimeout ( function ( ) { equal ( $ ( "#moreInfo" ) . is ( ":visible" ) , true , "extra info is visible after click" ) ; start ( ) ; } , 100 ) ; }
function ( pseudo , parenthesized , possibleQuote , argument , unquoted , context , xml ) { var fn = Expr . pseudos [ pseudo ] || Expr . pseudos [ pseudo . toLowerCase ( ) ] ; if ( ! fn ) { Sizzle . error ( "unsupported pseudo: " + pseudo ) ; } if ( ! fn . sizzleFilter ) { return fn ; } return fn ( argument , context , xml ) ; }
function ( contactView ) { console . log ( 'tap btnPCAction' ) ; var pcontact = Ext . getCmp ( contactView ) ; var data = pcontact . getValues ( ) ; this . callAPIService ( 'POST' , 'MemberPortalService' , 'AddContact' , data , function ( response , page ) { console . log ( response ) ; reLoadPage = true ; page . changeView ( 'MainVW' , 'right' ) ; page . loadCustomerInfo ( ) ; } ) ; }
function ( response , homeVW ) { try { if ( response . GenerateAPITokenJsonResult . ResponseMessageHeader . IsSuccess ) { isAuthenticated = true ; var token = response . GenerateAPITokenJsonResult . ResponseMessageBody . MessageBody [ 0 ] . Message ; mpToken = token ; console . log ( 'received token:' + mpToken ) ; homeVW . changeView ( profileName + '.MainVW' ) ; } else { isAuthenticated = false ; alert ( 'login failed' ) ; } } catch ( e ) { alert ( e ) ; } }
function ( ) { var loggedIn = this . get ( 'loggedIn' ) ; if ( ! loggedIn ) { $ . cookie ( 'authorization' , null ) ; $ . cookie ( 'email' , null ) ; setFakeData ( ) ; } }
function ( ) { if ( auth . get ( "userPrivate" ) . get ( "mostRecentIds" ) == undefined ) { Utils . debug ( "User does not have most recent ids, doing nothing." ) ; } else { var appids = auth . get ( "userPrivate" ) . get ( "mostRecentIds" ) ; window . app . loadBackboneObjectsById ( couchConnection , appids ) ; } }
function ( arr ) { var len = arr . length , sums = new Array ( len ) , i = 1 ; sums [ 0 ] = arr [ 0 ] ; for ( ; i < len ; i ++ ) { sums [ i ] = sums [ i - 1 ] + arr [ i ] ; } return sums ; }
function ( stopped ) { goog . style . transition . removeAll ( this . element_ ) ; goog . style . setStyle ( this . element_ , this . finalStyle_ ) ; this . endTime = goog . now ( ) ; this . setStateStopped ( ) ; if ( stopped ) { this . onStop ( ) ; } else { this . onFinish ( ) ; } this . onEnd ( ) ; }
function ( list , id , field ) { for ( var i in list ) { if ( field && list [ i ] [ field ] == id ) return i ; if ( list [ i ] . id && list [ i ] . id == id ) return i ; if ( list [ i ] . name && list [ i ] . name == id ) return i ; } return - 1 ; }
function ( ) { dojo . style ( this . removeFileButton . domNode , { display : 'none' } ) ; dojo . style ( this . thumbnailWrapper , { display : 'none' } ) ; dojo . style ( this . infoFileButton . domNode , { display : 'none' } ) ; this . value = '' ; this . fileInfo = null ; this . labelTextField . value = '' ; this . valueTextField . value = '' ; }
function onEnabledExtensionsChanged ( ) { let newEnabledExtensions = global . settings . get_strv ( ENABLED_EXTENSIONS_KEY ) ; newEnabledExtensions . filter ( function ( uuid ) { return enabledExtensions . indexOf ( uuid ) == - 1 ; } ) . forEach ( function ( uuid ) { enableExtension ( uuid ) ; } ) ; enabledExtensions . filter ( function ( item ) { return newEnabledExtensions . indexOf ( item ) == - 1 ; } ) . forEach ( function ( uuid ) { disableExtension ( uuid ) ; } ) ; enabledExtensions = newEnabledExtensions ; }
function thrown ( error , steps , index , context , callbacks , callback ) { if ( steps . length && steps . length && ~ steps [ 0 ] . parameters . indexOf ( "error" ) ) { context . error = error ; } abended = true ; if ( timer ) clearTimeout ( timer ) ; callback ( error ) ; }
function loadConfFiles ( files ) { var confDir = path . join ( ROOT_DIR , CONF_DIR ) ; return merge . apply ( this , files . map ( function ( file ) { var contents ; try { contents = require ( path . join ( confDir , file + '.json' ) ) ; } catch ( e ) { contents = { } ; } return contents ; } ) ) ; }
function ( ) { treesLoaded ++ ; if ( treesLoaded === treesToLoad ) { if ( selectedNode ( ) === - 1 ) { selectNode ( CSLEDIT . data . getNodesFromPath ( 'style/info' ) [ 0 ] . cslId ) ; } callbacks . formatCitations ( ) ; callbacks . viewInitialised ( ) ; } ; }
function ( id , highlightedNodes ) { var treeNode ; if ( typeof highlightedNodes === "undefined" ) { treeNode = treeView . find ( 'li[cslid=' + id + '] > a' ) ; } else { treeNode = highlightedNodes . filter ( 'li[cslid=' + id + ']' ) . children ( 'a' ) ; } if ( treeNode . length > 0 ) { clickNode ( treeNode . first ( ) ) ; } else { selectedNodeId = id ; selectedNodeChanged ( ) ; } }
function ( nodePath ) { var treeNode = treeView , cslId ; $ . each ( nodePath , function ( i , cslId ) { treeNode = treeNode . find ( 'li[cslId="' + cslId + '"]' ) ; } ) ; treeNode = treeNode . children ( 'a' ) ; if ( treeNode . length > 0 ) { clickNode ( treeNode . first ( ) ) ; } else { selectedNodeId = id ; selectedNodeChanged ( ) ; } }
function createCommonErrorResponse ( errorCode , message ) { var doc = xmlbuilder . create ( ) ; doc . begin ( 'Response' , { version : '1.0' } ) . element ( 'Errors' ) . element ( 'Error' ) . element ( 'Code' ) . text ( errorCode ) . up ( ) . element ( 'Message' ) . text ( message ) . up ( ) . up ( ) . element ( 'RequestId' ) . up ( ) ; return doc . toString ( ) ; }
function ( contextInfo ) { this . inherited ( arguments ) ; if ( this . value != null ) { this . currentValue = this . value ; this . setValue ( this . value , contextInfo [ "schemaValue" ] ) ; } }
function ( targetId ) { console . debug ( "XFProcessor.dispatch(" , targetId , ") this: " , this ) ; try { dwr . engine . setErrorHandler ( this . _handleExceptions ) ; dwr . engine . setOrdered ( true ) ; Flux . dispatchEvent ( targetId , this . sessionKey , this . applyChanges ) ; } catch ( ex ) { fluxProcessor . _handleExceptions ( "Failure executing Flux.dispatchEvent" , ex ) ; } }
function ( ) { console . debug ( "XFProcessor._fifoProcessingFinished" ) ; domClass . remove ( this . indicatorTargetObject , "bfPending" ) ; var currentItem = this . lastServerClientFocusEvent ; if ( currentItem != undefined ) { if ( currentItem != null ) { currentItem . postponedFunction ( currentItem . postponedXmlEvent ) ; this . lastServerClientFocusEvent = null ; } } fluxProcessor . indicatorImage . className = 'xfDisabled' ; }
function ( xmlEvent ) { console . debug ( "XFProcessor._handleModelRemoved xmlEvent:" , xmlEvent ) ; var modelId = xmlEvent . contextInfo . modelId ; require ( [ "dojo/query" , "dojo/NodeList-manipulate" ] , function ( query ) { query ( "#bfDebug a[modelId='" + modelId + "']" ) . remove ( ) ; } ) ; }
function ( validityEvents ) { console . debug ( "XFProcessor._handleValidity validityEvents:" , validityEvents ) ; array . forEach ( validityEvents , function ( xmlEvent ) { var control = registry . byId ( xmlEvent . contextInfo . targetId ) ; if ( control != undefined ) { if ( xmlEvent . type == "xforms-valid" ) { control . setValid ( ) ; } else { control . setInvalid ( ) ; } } } ) ; }
function ( evt ) { var value = widget . value ; if ( type == "dateTime" ) { value = self . _getISODateTime ( value ) ; } else if ( type == "time" ) { value = self . _getMobileTime ( value ) ; } console . debug ( "send: (keyup)" + value ) ; xfControlDijit . sendValue ( value , true ) ; }
function ( error ) { console . log ( error + "\n" ) ; if ( error && error . stack ) { error . stack . forEach ( function ( item ) { var message = item . sourceURL + ":" + item . line ; if ( item . function ) message += " in " + item . function ; console . log ( "  " + message ) ; } ) ; } }
function ( ) { expect ( lastError . toString ( ) ) . toEqual ( "ReferenceError: Can't find variable: referenceError" ) ; page . evaluate ( function ( ) { referenceError2 } ) ; expect ( lastError . toString ( ) ) . toEqual ( "ReferenceError: Can't find variable: referenceError2" ) ; page . evaluate ( function ( ) { throw "foo" } ) ; expect ( lastError ) . toEqual ( "foo" ) ; page . evaluate ( function ( ) { throw Error ( "foo" ) } ) ; expect ( lastError . toString ( ) ) . toEqual ( "Error: foo" ) ; }
function createResultDiv ( ) { var result = document . getElementById ( "results" ) ; var ddg_result = document . getElementById ( "ddg_zeroclick" ) ; showZeroClick ( ) ; if ( ddg_result === null ) { result . innerHTML = '<div id="ddg_zeroclick"></div>' + result . innerHTML ; ddg_result = document . getElementById ( "ddg_zeroclick" ) ; } return ddg_result ; }
function ( ) { if ( cc . NODE_TRANSFORM_USING_AFFINE_MATRIX ) { this . _isTransformGLDirty = true ; } this . _anchorPoint = new cc . Point ( 0 , 0 ) ; this . _anchorPointInPoints = new cc . Point ( 0 , 0 ) ; this . _contentSize = new cc . Size ( 0 , 0 ) ; var director = cc . Director . sharedDirector ( ) ; this . _actionManager = director . getActionManager ( ) ; this . _scheduler = director . getScheduler ( ) ; }
function ( newPosOrxValue , yValue ) { if ( typeof ( newPosOrxValue ) == 'number' ) { this . _position = new cc . Point ( newPosOrxValue , yValue || 0 ) ; } else if ( newPosOrxValue instanceof cc . Point ) { this . _position = newPosOrxValue ; } this . setNodeDirty ( ) ; }
function ( ) { if ( ! this . _actionManager ) this . _actionManager = cc . Director . sharedDirector ( ) . getActionManager ( ) ; return this . _actionManager ; }
function ( ) { if ( ! this . _scheduler ) this . _scheduler = cc . Director . sharedDirector ( ) . getScheduler ( ) ; return this . _scheduler ; }
function ( tv ) { tv . pos = this . _position ; tv . scale . x = this . _scaleX ; tv . scale . y = this . _scaleY ; tv . rotation = this . _rotation ; tv . skew . x = this . _skewX ; tv . skew . y = this . _skewY ; tv . ap = this . _anchorPointInPixels ; tv . visible = this . _isVisible ; return tv }
function ( ) { var locals = self . options ; locals . hasHeader = self . hasHeader ; console . log ( 'slave.js locals' , locals ) ; if ( locals . hasHeader ) { locals . headerHeight = self . headerHeight ; locals . headerPath = self . headerPath + "/" ; } return ejs . render ( PRISON_TEMPLATE , { locals : locals } ) ; }
function ( ) { if ( ! this . patientView ) { this . patientView = Ext . create ( 'Screener.view.PatientView' ) ; } this . getDoctorList ( ) . deselectAll ( ) ; this . getView ( ) . push ( this . patientView ) ; }
function ( ) { map = new GMap2 ( document . getElementById ( "map_canvas" ) ) ; map . setCenter ( new GLatLng ( 37.41 , - 122.08 ) , 1 ) ; map . addControl ( new GSmallMapControl ( ) ) ; map . addControl ( new GMapTypeControl ( ) ) ; }
function init ( ) { var b = document . body ; b . className = b . className . replace ( "windows" , site . platform ) ; }
function ( ev ) { var my_status = this . options . trackedgame . get ( "field_status_" + this . options . team_ix ) ; my_status [ this . model . get ( "player_id" ) ] = 1 - my_status [ this . model . get ( "player_id" ) ] ; this . render ( ) ; }
function ( ) { this . model . on ( "change:field_status_" + this . options . team_ix , this . render , this ) ; this . model . get ( "game" ) . on ( "change:team_" + this . options . team_ix , this . render , this ) ; }
function ( name , callback ) { return ; var listenClient = new Redis ( this , this . core ) ; listenClient . client . on ( 'message' , function ( channel , message ) { callback ( message ) ; } ) ; listenClient . client . subscribe ( name ) ; }
function ( ) { if ( ! this . disposed_ ) { if ( goog . Disposable . ENABLE_MONITORING ) { if ( this . disposed_ == undefined ) { throw Error ( this + ' did not call the goog.Disposable base ' + 'constructor' ) ; } var uid = goog . getUid ( this ) ; delete goog . Disposable . instances_ [ uid ] ; } this . disposed_ = true ; this . disposeInternal ( ) ; } }
function ( user , callback , errorCallback ) { $ . ajax ( { url : "../rest/user" , contentType : "application/json" , dataType : "json" , type : "POST" , cache : false , data : user , success : function ( data ) { callback ( data ) ; } , error : function ( error ) { var errorMsg = "error registering user -" + error . status ; console . log ( errorMsg ) ; if ( errorCallback ) { errorCallback ( errorMsg ) ; } } } ) ; }
function ( ) { view = new joCard ( [ new joGroup ( [ new joLabel ( "Content" ) , new joFlexrow ( inputComment = new joTextarea ( "" ) ) , ] ) , new joDivider ( ) , new joButton ( "Submit" ) . selectEvent . subscribe ( onSubmitClicked ) ] ) ; }
function ( ) { view = new joCard ( [ new joGroup ( [ new joLabel ( "Title" ) , new joFlexrow ( inputTitle = new joInput ( "" ) ) , new joLabel ( "Content" ) , new joFlexrow ( inputContent = new joTextarea ( "" ) ) , ] ) , new joDivider ( ) , new joButton ( "Submit" ) . selectEvent . subscribe ( onSubmitClicked ) ] ) ; }
function ( ) { view = new joGroup ( new joFlexcol ( [ new joHTML ( "<div id='blogEntryContainer' />" ) , new joDivider ( ) , new joHTML ( "<h4>Comments</h4>" ) , new joHTML ( "<div id='commentList' />" ) , new joButton ( "Add comment" ) . selectEvent . subscribe ( onAddComClicked ) ] ) ) . setTitle ( "Blog Post" ) }
function ( ) { if ( ! App . UserService . isLoggedIn ( ) ) { App . postLoginAction = function ( ) { App . stack . push ( App . AddCommentScreen . get ( ) ) ; } App . scn . showPopup ( App . LoginScreen . get ( ) ) ; } else { App . stack . push ( App . AddCommentScreen . get ( ) ) ; } }
function ( ) { inputUser . setData ( "" ) ; inputPass . setData ( "" ) ; inputFirstname . setData ( "" ) ; inputSurname . setData ( "" ) ; inputEmail . setData ( "" ) ; inputPhone . setData ( "" ) ; }
function ( node ) { document . body . removeChild ( node ) ; } , loadCSS : function ( filename , oldnode ) { if ( oldnode ) var css = oldnode ; else var css = joDOM . create ( 'link' ) ; css . rel = 'stylesheet' ; css . type = 'text/css' ; css . href = filename + ( jo . debug ? ( "?" + joTime . timestamp ( ) ) : "" ) ; if ( ! oldnode ) document . body . appendChild ( css ) ; return css ; }
function success ( t , result ) { self . data = [ ] ; for ( var i = 0 , l = result . rows . length ; i < l ; i ++ ) { var row = result . rows . item ( i ) ; self . data . push ( row ) ; } self . changeEvent . fire ( self . data ) ; }
function ( ) { var get = this . baseurl + this . query ; joFile ( get , this . callBack , this ) ; } , callBack : function ( data , error ) { if ( error ) this . errorEvent . fire ( error ) ; else this . setData ( data ) ; } } ) ; joFile = function ( url , call , context , timeout ) {
function handler ( data , error ) { if ( call ) { if ( context ) call . call ( context , data , error ) ; else call ( error , data , error ) ; } }
function ( call , context ) { joDepotCall . push ( handler ) ; function handler ( data ) { if ( context ) call . call ( context , data ) ; else call ( data ) ; } ; return "joDepotCall[" + ( joDepotCall . length - 1 ) + "]" ; } ; joInterface = function ( parent ) { jo . initTagMap ( ) ; return this . get ( parent ) ; }
function ( index ) { if ( this . data && this . data . length && index >= 0 && index < this . data . length ) return this . data [ index ] ; else return null ; } , getLength : function ( ) { return this . length || this . data . length || 0 ; } , sort : function ( ) { this . data . sort ( this . compareItems ) ; }
function ( ) { if ( this . getValue ( ) > 0 ) this . setValue ( this . value - 1 ) ; } } ) ; joBusy = function ( data ) { joContainer . apply ( this , arguments ) ; } ; joBusy . extend ( joContainer , {
function ( e ) { this . endedEvent . fire ( this . repeat ) ; if ( ++ this . repeat < this . repeatCount ) this . play ( ) ; else this . repeat = 0 ; } , setRepeatCount : function ( repeat ) { this . repeatCount = repeat ; this . repeat = 0 ; return this ; }
function ( ) { if ( this . stack ) this . stack . pop ( ) ; }
function ( error , result ) { Rooms . update ( { result } , { $set : { active : true } } ) ; var d = new Date ( ) ; var date = d . toDateString ( ) + " " + d . toLocaleTimeString ( ) ; Messages . insert ( { roomId : result , content : 'Thank you for accessing Southern Adventist University Online Campus Support, someone will be with you shortly.  You may begin by entering any questions here and our support staff will see them when they join you.' , user : 'Online Support' , role : 'welcome' , messagetime : 0 , date : date } ) ; }
function renderMainContent ( node ) { var content = node . prop [ 'content' ] ; if ( content == null ) content = '' ; var line = '<div id="mainContent"><strong>' + node . name + '</strong><br/>' + content + '</div>' ; return line ; }
function newWindow ( theTitle , x ) { var newID = ( "Window" + eid ) ; $ ( '#Window' ) . html ( "<div id='" + newID + "'>" + x + "</div>" ) ; $ ( '#' + newID ) . dialog ( { title : theTitle , width : '50%' , height : 400 } ) ; $ ( '#' + newID ) . fadeIn ( ) ; eid ++ ; }
function ( r ) { if ( message . text . match ( r . route ) ) { r . handler . call ( r . module , { from : message . from , message : message . text , hostmask : message . raw . prefix , matches : message . text . match ( r . route ) } , function ( out ) { output ( r , out ) ; } ) ; } ; }
function checkOp ( info , cb ) { if ( chan . isOperator ( info . hostmask ) ) { console . log ( 'Operator' , info . from . green , 'activated route' , name . green ) ; command . handler . call ( module , info , cb ) ; } else { console . log ( 'Non-Operator' , info . from . red , 'tried to activate route' , name . red ) ; } }
function checkOp ( info , cb ) { if ( chan . isOperator ( info . hostmask ) ) { console . log ( 'Operator' , info . from . green , 'called' , name . green ) ; command . handler . call ( module , info , cb ) ; } else { console . log ( 'Non-Operator' , info . from . red , 'tried to call' , name . red ) ; } }
function ( out ) { chan . network . say ( chan . name , event . formatter ( out ) ) ; }
function ( msg ) { this . network . say ( this . name , this . config . colors ? msg : msg . replace ( /[\x02\x1f\x16\x0f]|\x03\d{0,2}(?:,\d{0,2})?/g , '' ) ) ; }
function replaceQuery ( query , filter , negated ) { if ( $ ( query ) == undefined ) { return false ; } if ( negated == undefined ) { negated = false ; } if ( negated ) { $ ( query ) . val ( '!' + filter ) ; } else { $ ( query ) . val ( filter ) ; } return true ; }
function ( ) { var acStatus = kWidgetSupport . getAccessControlStatus ( embedPlayer . kalturaAccessControl , embedPlayer ) ; if ( acStatus !== true ) { embedPlayer . setError ( acStatus ) ; return ; } if ( this . isRestricted ( ) ) { embedPlayer . setError ( this . getMsg ( ) ) ; } }
function ( ) { if ( this . getConfig ( 'restrictedUserAgentTitle' ) && this . getConfig ( 'restrictedUserAgentMessage' ) ) { return { 'message' : this . getConfig ( 'restrictedUserAgentMessage' ) , 'title' : this . getConfig ( 'restrictedUserAgentTitle' ) } } else { return this . embedPlayer . getKalturaMsg ( 'USER_AGENT_RESTRICTED' ) ; } }
function persist ( data ) { thedrawing . push ( data ) ; fs . writeFile ( 'persist.json' , JSON . stringify ( thedrawing ) ) ; }
function ( err , stdout , stderr ) { var filesArray , elementParsed , oneResult ; filesArray = stdout . split ( "\n" ) ; filesArray . forEach ( function ( element , index ) { console . log ( 2 ) ; if ( element !== "" ) { elementParsed = element . split ( "||" ) , oneResult = new Result ( elementParsed [ 0 ] , elementParsed [ 1 ] , elementParsed [ 2 ] ) ; results . push ( oneResult ) ; } } ) ; callback ( null , results ) ; }
function getLocationIsps ( ) { $ . ajax ( { url : '/get-isps' , type : "POST" , data : { country : loc . country } , success : function ( isps ) { mdl . setLocation ( loc . city , loc . state , isps ) ; } , error : function ( jqXHR ) { console . log ( 'error' , jqXHR . responseText + ' :: ' + jqXHR . statusText ) ; } } ) ; }
function ( ) { form . isNoteDirty . value = 1 ; $ ( d ) . unbind ( 'keydown' ) ; }
function updateMiniMessageCounter ( ) { var delta = 140 - $ ( 'textarea.jsMiniMessageText' ) . val ( ) . length ; var miniMessageCounter = $ ( '.miniMessageCounter' ) ; miniMessageCounter . text ( delta ) ; miniMessageCounter . toggleClass ( 'warning' , delta < 5 ) ; if ( delta < 0 ) { $ ( '.jsWriteMiniMessageButton' ) . attr ( 'disabled' , 'disabled' ) ; } else { $ ( '.jsWriteMiniMessageButton' ) . removeAttr ( 'disabled' ) ; } }
function quote ( string ) { escapable . lastIndex = 0 ; return escapable . test ( string ) ? '"' + string . replace ( escapable , function ( a ) { var c = meta [ a ] ; return typeof c === 'string' ? c : '\\u' + ( '0000' + a . charCodeAt ( 0 ) . toString ( 16 ) ) . slice ( - 4 ) ; } ) + '"' : '"' + string + '"' ; }
function getDigit ( start , stop ) { var str = '[\\d]' + ( start ? '{' + start + ',' + stop + '}' : '+' ) ; if ( set [ 'digits' ] ) str += '|[' + set [ 'digits' ] + ']+' ; return str ; }
function getNum ( ) { var arr = [ getDigit ( ) ] . concat ( set [ 'articles' ] ) ; if ( set [ 'numbers' ] ) arr = arr . concat ( set [ 'numbers' ] ) ; return arr . compact ( ) . join ( '|' ) ; }
function ( letter ) { var value = KanjiDigitMap [ letter ] , holder = value > 9 ; if ( holder ) { place *= value / ( lastHolder || 1 ) ; lastHolder = value ; } else { if ( lastWasHolder === false ) { place *= 10 ; } sum += place * value ; } lastWasHolder = holder ; }
function ( full , token ) { if ( token == 'meridian' ) { return loc [ '12hr' ] . join ( '|' ) ; } else { add = loc [ 'timeSuffixes' ] [ timeSuffixMapping [ token ] ] ; return '(?:' + ( add ? sep . concat ( add ) : sep ) . join ( '|' ) + ')?' ; } }
function ( ) { it ( 'should pass something to the callback (cannot be null)' , function ( done ) { dog . on ( 'look' , function ( obj ) { obj . should . not . be . empty ; done ( ) ; } ) ; } ) ; it ( '' ) ; }
function ( ) { this . contentView = new OsciTk . views [ this . options . toolbarItem . view ] ( { parent : this } ) ; this . $el . html ( this . template ( { text : this . options . toolbarItem . text } ) ) ; }
function ( view ) { if ( ( this . activeToolbarItemView && view . cid !== this . activeToolbarItemView . cid ) || this . activeToolbarItemView === undefined ) { this . activeToolbarItemViewChanged = true ; } else { this . activeToolbarItemViewChanged = false ; } this . activeToolbarItemView = view ; this . $el . find ( "#toolbar-content" ) . html ( view . contentView . $el ) ; return this ; }
function ( ) { var go = Kinetic . GlobalObject ; var radius = this . getRadius ( ) ; if ( go . _isObject ( radius ) ) { return false ; } var pos = go . _getXY ( radius ) ; this . setAttrs ( { radius : pos } ) ; }
function ( ) { var go = Kinetic . GlobalObject ; var radius = this . getRadius ( ) ; if ( go . _isObject ( radius ) ) { return false ; } var pos = go . _getXY ( radius ) ; this . setAttrs ( { radius : pos } ) ; }
function ( ) { this . _isSaved = false ; this . id = null ; this . data = { } ; for ( var i = 0 , len = this . events . length ; i < len ; i ++ ) { this . events [ i ] . detach ( ) ; } this . events = [ ] ; }
function ( ) { var fields = this . getFields ( ) ; for ( var field in fields ) { if ( fields [ field ] . hasOwnProperty ( 'primaryKey' ) ) return fields [ field ] . name ; } }
function ( ) { for ( var i = 0 , len = this . events . length ; i < len ; i ++ ) { this . events [ i ] . detach ( ) ; } this . events = [ ] ; }
function ( response ) { try { response = jQuery . parseJSON ( response ) ; return callback ( response ) ; } catch ( e ) { return typeof console !== "undefined" && console !== null ? console . error ( 'Malformed response' , response ) : void 0 ; } }
function createEndBreak ( ) { var endBr = document . createElement ( "br" ) ; endBr . setAttribute ( "class" , "aloha-end-br" ) ; if ( jQuery . browser . msie && jQuery . browser . version < 8 ) { var endTextNode = document . createTextNode ( ' ' ) ; endBr . insertBefore ( endTextNode ) ; } return endBr ; }
function ( event , xhr , settings ) { function safeMethod ( method ) { return ( /^(GET|HEAD|OPTIONS|TRACE)$/ . test ( method ) ) ; } if ( ! safeMethod ( settings . type ) && ! settings . crossDomain ) { xhr . setRequestHeader ( "X-CSRFToken" , getCookie ( 'csrftoken' ) ) ; } }
function ( ) { if ( self . reload_on_login && self . $el . parent ( ) . length !== 0 && ( app . current . view === self || self . $el . hasClass ( 'main_content' ) ) ) { self . render ( ) ; } }
function ( file_info ) { console . log ( 'reloading resource' , file_info . file_name ) ; var file_type = 'text/javascript' ; switch ( file_info . ext ) { case '.css' : file_type = 'text/css' ; break ; } Live . refreshResource ( file_info . file_name , file_type ) ; }
function ( ) { var $label = this . view . $el . find ( '[data-label]' ) ; var i18n = this . view . i18n ; $label . each ( function ( ) { var $this = $ ( this ) ; var str = 'forms.labels.' + $this . data ( 'label' ) ; $this . html ( jQuery . t ( str , i18n [ 1 ] , i18n [ 0 ] ) ) ; $this . data ( 'label' , null ) ; } ) ; }
function ( name ) { if ( ! name ) { return $ ( ) ; } if ( name instanceof jQuery ) { return name ; } var $form = this . view . $el ; var $el = $ ( 'input[data-link="' + name + '"]' , $form ) ; if ( $el . length === 0 ) { $el = $ ( 'input[name="' + name + '"]' , $form ) ; } return $el ; }
function ( ) { app . use ( express . logger ( ) ) ; app . use ( express . errorHandler ( { dumpExceptions : true , showStack : true } ) ) ; app . use ( app . router ) ; app . use ( express . favicon ( ) ) ; app . use ( express . static ( options . directory ) ) ; }
function ( enclosure ) { enclosure . should . have . property ( 'href' ) ; enclosure . should . have . property ( 'title' ) ; enclosure . should . have . property ( 'type' ) ; }
function ( onModuleReady ) { onModuleReady ( ) ; if ( butter . config . value ( "ui" ) . enabled !== false ) { var editorAreaDOMRoot = LangUtils . domFragment ( EDITOR_AREA_LAYOUT ) ; butter . ui . areas . editor = new butter . ui . Area ( "editor-area" , editorAreaDOMRoot ) ; document . body . classList . add ( "butter-editor-spacing" ) ; document . body . appendChild ( editorAreaDOMRoot ) ; } }
function createEvent ( the_event ) { $ . post ( "/reservations" , { reservation : { exchange_event_id : the_event . title , cache_start_time : "" + the_event . start , cache_end_time : "" + the_event . end , person_id : the_event . description , resource_id : the_event . allDay } } ) ; alert ( 'successfully created a reservation!' ) ; }
function ( data ) { $ ( '#page_browser_startpage' ) . remove ( ) ; $ ( entry ) . children ( '.page_browser_pagename' ) . after ( ' <span id="page_browser_startpage">the start page</span>' ) ; $ . glue . conf . page . startpage = pn + '.head' ; if ( span ) { $ ( entry ) . trigger ( 'mouseenter' ) ; } }
function ajaxDelete ( id ) { if ( window . XMLHttpRequest ) { xmlhttp = new XMLHttpRequest ( ) ; } else { xmlhttp = new ActiveXObject ( "Microsoft.XMLHTTP" ) ; } xmlhttp . onreadystatechange = function ( ) { if ( xmlhttp . readyState == 4 && xmlhttp . status == 200 ) { document . getElementById ( "balance" ) . innerHTML = xmlhttp . responseText ; } } xmlhttp . open ( "GET" , "delete.php?id=" + id , true ) ; xmlhttp . send ( ) ; }
function editForm ( id ) { if ( window . XMLHttpRequest ) { xmlhttp = new XMLHttpRequest ( ) ; } else { xmlhttp = new ActiveXObject ( "Microsoft.XMLHTTP" ) ; } xmlhttp . onreadystatechange = function ( ) { if ( xmlhttp . readyState == 4 && xmlhttp . status == 200 ) { var trid = "payment" + id ; document . getElementById ( trid ) . innerHTML = xmlhttp . responseText ; } } xmlhttp . open ( "GET" , "editform.php?id=" + id , true ) ; xmlhttp . send ( ) ; }
function updateTotal ( ) { if ( window . XMLHttpRequest ) { xmlhttp = new XMLHttpRequest ( ) ; } else { xmlhttp = new ActiveXObject ( "Microsoft.XMLHTTP" ) ; } xmlhttp . onreadystatechange = function ( ) { if ( xmlhttp . readyState == 4 && xmlhttp . status == 200 ) { document . getElementById ( "balance" ) . innerHTML = xmlhttp . responseText ; } } xmlhttp . open ( "GET" , "updatetotal.php" , true ) ; xmlhttp . send ( ) ; }
function ( ) { if ( xmlhttp . readyState == 4 && xmlhttp . status == 200 ) { document . getElementById ( "statementhold" ) . innerHTML = xmlhttp . responseText ; } }
function ( e ) { e . preventDefault ( ) ; var theTarget = e . target ; that . view . find ( '#header #searchbar>form>input[type=search]' ) . val ( '' ) ; that . view . find ( '#header #searchbar>form>button' ) . hide ( ) ; _hideListSelectButtons ( listOverlay ) ; that . _displayList ( theTarget . id ) ; return true ; }
function ( e ) { e . preventDefault ( ) ; $j ( this ) . hide ( ) . prev ( ) . val ( '' ) . blur ( ) ; if ( that . mode == 'search' ) { that . _displayList ( that . selectedListId ) ; that . mode = 'list' ; } }
function ( listId ) { var that = this , listButton ; if ( listId ) listButton = that . view . find ( '#header #listselect button#' + listId ) ; else listButton = that . view . find ( '#header #listselect button#recent' ) ; that . view . find ( '#header #titlebar #title' ) . text ( listButton . text ( ) ) ; that . selectedListId = listButton [ 0 ] . id ; if ( typeof that . options . onListSelect == 'function' ) { that . options . onListSelect ( that . selectedListId ) ; } }
function ( e ) { e . preventDefault ( ) ; var theTarget = e . target ; that . view . find ( '#header #searchbar>form>input[type=search]' ) . val ( '' ) ; that . view . find ( '#header #searchbar>form>button' ) . hide ( ) ; _hideListSelectButtons ( listOverlay ) ; that . _displayList ( theTarget . id ) ; return true ; }
function ( e ) { e . preventDefault ( ) ; $j ( this ) . hide ( ) . prev ( ) . val ( '' ) . blur ( ) ; if ( that . mode == 'search' ) { that . _displayList ( that . selectedListId ) ; that . mode = 'list' ; } }
function ( listId ) { var that = this , listButton ; if ( listId ) listButton = that . view . find ( '#header #listselect button#' + listId ) ; else listButton = that . view . find ( '#header #listselect button#recent' ) ; that . view . find ( '#header #titlebar #title' ) . text ( listButton . text ( ) ) ; that . selectedListId = listButton [ 0 ] . id ; if ( typeof that . options . onListSelect == 'function' ) { that . options . onListSelect ( that . selectedListId ) ; } }
function getActivities ( a , c ) { ManageUserSession . getApiClient ( ) . fetchActivitiesViaApex ( [ a ] , function ( b ) { var a = [ ] ; 0 < b . tasks . totalSize && ( a = b . tasks . records ) ; feedRenderer ( a , "No activities found." ) ; c && c ( ) } , errorCallback , function ( b , a ) { "function" == typeof c && c ( a ) } ) }
function ( a ) { typeof b == "function" && b ( a ) } , f = function ( ) { $j ( "#rightsection #detailpage #detail #feedscroller" ) . css ( "visibility" , "" ) ; initiateFeedScroller ( ) ; d ( ) } ; "info" == a ? renderContactInfo ( c [ 0 ] , function ( a ) { a && $j ( "#rightsection #detailpage #detail #infoscroller" ) . css ( "visibility" , "" ) ; d ( a ) }
function addBingLayers ( api_key ) { if ( api_key == null ) return ; var road = new OpenLayers . Layer . Bing ( { key : api_key , type : "Road" } ) ; var hybrid = new OpenLayers . Layer . Bing ( { key : api_key , type : "AerialWithLabels" , name : "Bing Satellite" } ) ; map . addLayers ( [ road , hybrid ] ) ; }
function ( resp , entryInfo , deleteLink , eText ) { if ( ! resp ) { alert ( 'Berta says, there was a server error while deleting this entry! Something has gone sooooo wrong...' ) ; } else if ( resp && ! resp . error_message ) { this . unlinearProcess_stop ( deleteProcessId ) ; entryObj . destroy ( ) ; $$ ( '.xTipNewEntryContent' ) . dispose ( ) ; } else { alert ( resp . error_message ) ; btn . setProperty ( 'display' , 'inline' ) ; entryObj . removeClass ( 'xSavingAtLarge' ) ; } }
function ( ) { $ ( '#content' ) . html ( ) ; $ ( '#content' ) . append ( $ ( '.noDisplay .loading' ) . clone ( ) ) ; $ . ajax ( { type : 'POST' , url : '?controller=Update&action=getStatus' , success : successResponse } ) ; }
function ( ) { it ( "should exist in window" , function ( ) { expect ( window . hasOwnProperty ( 'WebPage' ) ) . toBeTruthy ( ) ; } ) ; it ( "should be a function" , function ( ) { expect ( typeof window . WebPage ) . toEqual ( 'function' ) ; } ) ; }
function ( ) { var samples = [ true , 0 , "`~!@#$%^&*()_+-=[]\{}|;':\",./<>?" , undefined , null ] ; for ( var i = 0 ; i < samples . length ; i ++ ) { if ( samples [ i ] !== arguments [ i ] ) { console . log ( "FAIL" ) ; } } }
function ( ) { page . evaluate ( function ( ) { console . log ( "PASS" ) ; } ) ; page . evaluate ( testPrimitiveArgs , true , 0 , "`~!@#$%^&*()_+-=[]\{}|;':\",./<>?" , undefined , null ) ; page . evaluate ( testComplexArgs , { a : true , b : 0 , c : "string" } , function ( ) { return true ; } , [ true , 0 , "string" ] , /\d+\w*\// ) ; expect ( message ) . toEqual ( "PASS" ) ; }
function ( ) { var opts = { settings : { userAgent : "PHANTOMJS-TEST-USER-AGENT" , } } ; var page = new WebPage ( opts ) ; it ( "should have userAgent as '" + opts . settings . userAgent + "'" , function ( ) { expect ( page . settings . userAgent ) . toEqual ( opts . settings . userAgent ) ; } ) ; }
function ( has_listeners , event , data ) { if ( has_listeners ) { return ( ( module . exports . _events && module . exports . _events . stats ) ? module . exports . _events . stats . length > 0 : false ) ; } else { return module . exports . emit ( event , data ) ; } }
function ( handler_cb , jid ) { var iq = buildIq ( "get" , this . _connection . jid , jid ) ; this . _connection . sendIQ ( iq . tree ( ) , handler_cb , null ) ; }
function ( handler_cb , vCardEl , jid ) { var iq = buildIq ( "set" , this . _connection . jid , jid , vCardEl ) ; this . _connection . sendIQ ( iq . tree ( ) , handler_cb , null ) ; }
function ( newMonth ) { this . _setCurrentFocusAttr ( this . dateModule . add ( this . currentFocus , "month" , newMonth - this . currentFocus . getMonth ( ) ) ) ; }
function ( dt , dn ) { var d = locals [ dt ] [ dn ] ; if ( ! d . __islocal ) d . __oldparent = d . parent ; d . parent = 'old_parent:' + d . parent ; d . docstatus = 2 ; d . __deleted = 1 ; }
function ( dt , dn ) { var d = locals [ dt ] [ dn ] ; if ( ! d . __islocal ) d . __oldparent = d . parent ; d . parent = 'old_parent:' + d . parent ; d . docstatus = 2 ; d . __deleted = 1 ; }
function ( w , h , c ) { top . cr = window . open ( '' , 'gitHtml' , 'width=' + w + ',height=' + h + ',' + 'menubar=,' + 'toolbar=1,' + 'status=,' + 'scrollbars=1,' + 'resizable=1' ) top . cr . document . writeln ( c ) ; top . cr . document . close ( ) ; }
function ( flavour ) { var src = './templates/' + flavour + '/index.html' , dest = process . cwd ( ) + '/index.html' ; fs . copy ( src , dest , console . log ) ; }
function _removePopUp ( $popUp , visible ) { var initiallyInDOM = $popUp . data ( "initiallyInDOM" ) , removeHandler = $popUp . data ( "removeHandler" ) ; visible = visible || $popUp . find ( ":visible" ) . length > 0 ; if ( removeHandler && visible ) { removeHandler ( ) ; } if ( ! initiallyInDOM ) { $popUp . remove ( ) ; } }
function removePopUp ( $popUp ) { var idx = _popUps . indexOf ( $popUp [ 0 ] ) , initiallyInDOM = $popUp . data ( "initiallyInDOM" ) , removeHandler = $popUp . data ( "removeHandler" ) ; _removePopUp ( $popUp ) ; if ( idx >= 0 ) { _popUps = _popUps . slice ( idx ) ; } }
function ( target , source , move ) { if ( source && source !== target && move && move . category !== 'Status' ) { if ( target . useItem ( ) ) { this . add ( "-message" , target . name + " is switched out with the Eject Button! (placeholder)" ) ; target . switchFlag = true ; } } }
function ( err , count ) { if ( err ) return res . send ( 500 ) ; if ( 1 == count ) { collection . findOne ( { name : req . params . list } , function ( err , doc ) { if ( err ) return res . send ( 500 ) ; return res . send ( doc , { 'Content-Type' : 'application/json' } , 200 ) ; } ) } else { return res . send ( 404 ) ; } }
function ( attributes ) { this . library = new attributes . collectionType ; this . table = this . $ ( 'tbody' ) ; this . list . on ( 'add' , this . addOne , this ) ; this . list . on ( 'reset' , this . addAll , this ) ; this . list . on ( 'all' , this . render , this ) ; this . list . fetch ( ) ; }
function ( err , value ) { value = parseInt ( value , 10 ) ; var cachedValue = cache . get ( 'potentiometer-gauge' ) ; if ( cachedValue === null || cachedValue !== value ) { cache . put ( 'potentiometer-gauge' , value ) ; socket . in ( '' ) . emit ( '/potentiometer-gauge' , cache . get ( 'potentiometer-gauge' ) ) ; console . log ( 'potentiometer-gauge reader: ' + value ) ; } }
function ( key ) { var result = new RegExp ( key + "=([^&]*)" , "i" ) . exec ( window . location . search ) ; return result && unescape ( result [ 1 ] ) || "" ; }
function ( resp ) { if ( resp [ 0 ] [ 'friends_likes' ] != 1 ) { _to_login ( ) ; } if ( resp [ 0 ] [ 'user_likes' ] != 1 ) { _to_login ( ) ; } LOM . init ( response . authResponse . accessToken , response . authResponse . userID ) ; }
function ( ) { data . d = JSON . parse ( window . JSInterface . getScheduleJson ( false ) ) ; }
function ( e ) { this . picker . hide ( ) ; $ ( window ) . off ( 'resize' , this . place ) ; this . viewMode = 0 ; this . showMode ( ) ; if ( ! this . isInput ) { $ ( document ) . off ( 'mousedown' , this . hide ) ; } $ ( 'body' ) . off ( 'click' , $ . proxy ( this . click , this ) ) ; }
function ( item ) { var t = ( root = getRoot ( item ) ) . nodeType == 1 ? baidu . query ( selector , root ) : da ; for ( var i = 0 , n = t . length ; i < n ; i ++ ) { if ( t [ i ] === item ) { results . push ( item ) ; break ; } } }
function getRoot ( dom ) { var result = [ ] , i ; while ( dom = dom . parentNode ) { result . push ( dom ) ; } for ( var i = result . length - 1 ; i > - 1 ; i -- ) { if ( result [ i ] . nodeType == 1 || result [ i ] . nodeType == 9 ) { return result [ i ] ; } } return null ; }
function ( filter ) { var array = [ ] ; baidu . each ( this , function ( dom ) { ( dom = dom . parentNode ) && dom . nodeType == 1 && array . push ( dom ) ; } ) ; return baidu . dom ( typeof filter == "string" ? baidu . dom . match ( array , filter ) : array ) ; }
function ( $dom ) { var target = baidu . dom ( '.item-1, .item-c' ) . closest ( 'ul' ) ; equal ( target . length , 2 ) ; equal ( target [ 0 ] . className , 'level-3' ) ; equal ( target [ 1 ] . className , 'level-2' ) ; }
function ( $dom ) { var target = $ ( '.item-1, .item-c' ) . closest ( 'ul' ) ; equal ( target . length , 2 , '(JQuery)' ) ; equal ( target [ 0 ] . className , 'level-3' , '(JQuery)' ) ; equal ( target [ 1 ] . className , 'level-2' , '(JQuery)' ) ; }
function ( ) { var sequences = $ ( '#sequence' ) . val ( ) . split ( />.*/ ) ; var type , tmp , i ; for ( i = 0 ; i < sequences . length ; i ++ ) { tmp = guess_sequence_type ( sequences [ i ] ) ; if ( ! tmp ) { continue } if ( ! type ) { type = tmp } else if ( tmp !== type ) { return 'mixed' } } return type ; }
function ( ) { var type = type_of_databases ( ) , tmp ; $ ( '.databases input' ) . change ( function ( ) { tmp = type_of_databases ( ) ; if ( tmp != type ) { type = tmp ; $ ( this ) . trigger ( 'database_type_changed' , type ) ; } } ) ; }
function ( ) { var method , tmp ; $ ( '#blast' ) . on ( 'sequence_type_changed database_type_changed' , function ( event ) { tmp = determine_blast_method ( ) ; if ( tmp != method ) { method = tmp ; $ ( this ) . trigger ( 'blast_method_changed' , [ method ] ) ; } } ) ; }
function exposePlugins ( isGlobal , target , mixin ) { for ( var i in mixin ) { if ( i === 'stage' ) { continue ; } if ( isGlobal ) { try { target [ i ] = mixin [ i ] ; } catch ( e ) { } } else { target [ i ] = mixin [ i ] ; } } }
function ( ) { $ ( "#popupPhotoPortrait, #popupPhotoLandscape" ) . popup ( { popupbeforeopen : function ( event ) { var inner = $ ( window ) . height ( ) - 62 + "px" ; $ ( ".ui-popup > img" ) . css ( "height" , inner ) ; } } ) ; }
function ( ) { var text = this . $input . attr ( "data-label" ) ; if ( ! text ) { return false ; } this . $label = $ ( "<label>" ) . text ( text ) ; this . $input . before ( this . $label ) ; return this ; }
function ( api ) { api . use ( 'http' , 'server' ) ; api . add_files ( 'accounts_common.js' , [ 'client' , 'server' ] ) ; api . add_files ( 'accounts_server.js' , 'server' ) ; api . add_files ( 'accounts_client.js' , 'client' ) ; }
function Path ( str ) { if ( ! str || str . length === 0 ) { return ; } var self = this ; var matches ; var re = /(?:\/|^)([^\/]*)/g ; while ( matches = re . exec ( str ) ) { self . push ( matches [ 1 ] ) ; } }
function ( err , listado ) { if ( err ) { console . log ( "err " + err ) ; } console . log ( "listado " + listado . length ) ; res . render ( "users/games.ejs" , { username : req . params . username , partidas : listado , layout : true , title : "AI Challenge - Bomberbot - Listado de partidas" } ) ; }
function ( err , listado ) { if ( err ) { console . log ( "err " + err ) ; } console . log ( "listado " + listado . length ) ; res . render ( "users/games.ejs" , { username : req . currentUser . get ( "username" ) , partidas : listado , layout : true , title : "AI Challenge - Bomberbot - Listado de partidas" } ) ; }
function ( findingsUser ) { if ( ! findingsUser . isLoggedIn ) { _this . log ( "User is not logged into Findings...aborting import." ) ; if ( desktopNotifyAllowed ) { _this . showNotification ( "notify_kindle_import_failed_findings_login.html" ) ; } } else { _this . log ( "All systems go for Kindle import..." ) kindle_importer . start ( FDGS ) ; if ( _this . amazonPinger == null ) { _this . createAmazonPinger ( ) ; } chrome . browserAction . setIcon ( { "path" : "findings-icon-16x16-working.gif" } ) ; } }
function ( ) { $ ( this ) . parent ( ) . addClass ( 'todo_' + $ ( this ) . attr ( 'branch' ) ) ; addButton ( $ ( this ) . attr ( 'branch' ) ) ; }
function ( ) { $ ( 'button' ) . removeClass ( 'activeFilter' ) ; $ ( this ) . addClass ( 'activeFilter' ) ; $ ( 'tr' ) . hide ( ) ; $ ( 'tbody tr:first' ) . show ( ) ; $ ( '.todo_' + branch ) . show ( ) ; $ . cookie ( 'lastActiveFilter' , branch ) ; updateCount ( ) ; }
function hideResolved ( ) { $ ( 'tr' ) . addClass ( 'nothingToDo' ) . show ( ) ; $ ( '.info-planned' ) . each ( function ( ) { $ ( this ) . parent ( ) . removeClass ( 'nothingToDo' ) ; } ) ; $ ( 'tr.nothingToDo' ) . hide ( ) ; $ ( 'tbody tr:first' ) . show ( ) ; }
function _addStorageStateChangeListener ( ) { var watchId = Math . uuid ( null , 16 ) ; _observers [ watchId ] = function ( storage ) { onSuccess ( storage ) ; } ; event . on ( "StateChange" , _observers [ watchId ] ) ; return watchId ; }
function ( error , res , more ) { equal ( error , null ) ; equal ( res , null ) ; equal ( more , false ) ; authService . add_user ( username , password , function ( error , res , more ) { equal ( error , null ) ; equal ( res , null ) ; equal ( more , false ) ; callback ( ) ; } ) ; }
function ( error , res , more ) { equal ( error , null ) ; equal ( res , true ) ; equal ( more , false ) ; authService . clear_group_permissions ( "test0-group" , function ( error , res , more ) { equal ( error , null ) ; equal ( res , true ) ; equal ( more , false ) ; teardownAccounts ( "test0-group" , "test0" ) ; } ) ; }
function ( error , res , more ) { equal ( error , null ) ; equal ( res , true ) ; equal ( more , false ) ; authService . get_user_groups_by_user ( "test1" , function ( error , res , more ) { equal ( error , null ) ; ok ( setsEquivalent ( res , [ ] ) ) ; equal ( more , false ) ; teardownAccounts ( "test1-group" , "test1" ) ; } ) ; }
function ( error , res , more ) { equal ( error , null ) ; equal ( res , true ) ; equal ( more , false ) ; authService . get_user_groups_by_group ( "test2-group" , function ( error , res , more ) { equal ( error , null ) ; ok ( setsEquivalent ( res , [ ] ) ) ; equal ( more , false ) ; teardownAccounts ( "test2-group" , "test2" ) ; } ) ; }
function ( err , result ) { if ( err ) { cb ( err ) ; } else if ( ! result ) { cb ( null , [ ] ) ; } else { this . getUserPermissions ( user , cb ) ; } }
function ( err , result ) { if ( err ) { cb ( err ) ; } else if ( ! result ) { cb ( null , false ) ; } else { db . select ( 'permissions' , null , [ 'service' , 'method' ] , 'group_id=?' , [ result . id ] , cb ) ; } }
function ( item ) { try { new RegExp ( item . service ) ; } catch ( e ) { valid = false ; return cb ( e ) ; } try { new RegExp ( item . method ) ; } catch ( e ) { valid = false ; return cb ( e ) ; } }
function ( item ) { db . insert ( 'permissions' , { service : item . service , group_id : result . id , method : item . method } , function ( err ) { if ( err ) errors . push ( err ) ; callback ( errors . length > 0 ? errors : null , errors . length == 0 ) ; } ) ; }
function ( err , result ) { if ( err ) { return cb ( err ) ; } else if ( ! result ) { return cb ( null , false ) } db . remove ( 'permissions' , 'group_id=?' , [ result . id ] , function ( err ) { cb ( err , ! err ) ; } ) ; }
function ( err , result ) { if ( err ) { cb ( err ) ; } else if ( ! result ) { cb ( null , false ) ; } else { db . removeById ( 'users' , result . id , function ( err ) { cb ( err , ! err ) ; } ) ; } }
function ( name , cb ) { db . select ( 'permissions' , { 'groups' : 'permissions.group_id=groups.id' , 'user_groups' : 'groups.id=user_groups.group_id' , 'users' : 'user_groups.user_id=users.id' } , { 'permissions.service' : 'service' , 'permissions.method' : 'method' } , 'users.username=?' , [ name ] , cb , null , null , true ) ; }
function ( err , result ) { if ( err ) { return cb ( err ) ; } else if ( ! result ) { return cb ( null , false ) ; } db . select ( 'groups, user_groups' , null , { 'groups.name' : 'name' } , 'groups.id=user_groups.group_id AND user_groups.user_id=?' , [ result . id ] , cb ) ; }
function ( err , result ) { if ( err ) { return cb ( err ) ; } else if ( ! result ) { return cb ( null , false ) ; } db . remove ( 'user_groups' , 'user_id=?' , [ result . id ] , cb ) ; }
function ( err , result ) { if ( err ) { return cb ( err ) ; } else if ( ! result ) { return cb ( null , false ) ; } db . remove ( 'user_groups' , 'group_id IN (SELECT id FROM groups WHERE name IN (' + repeat ( '?' , ',' , groups . length ) + ')' , groups , function ( err ) { return cb ( err , ! err ) ; } ) ; }
function ( err , result ) { if ( err ) { return cb ( err ) ; } else if ( ! result ) { return cb ( null , false ) ; } db . select ( 'groups g, user_groups ug' , null , { 'g.name' : 'name' } , 'g.id=ug.group_id AND g.id=?' , [ result . id ] , cb ) ; }
function ( err , result ) { if ( err ) { return cb ( err ) ; } else if ( ! result ) { return cb ( null , false ) ; } db . remove ( 'user_groups' , 'group_id=?' , [ result . id ] , cb ) ; }
function ( err , ids ) { ids . forEach ( function ( user ) { db . insert ( 'user_groups' , { group_id : gid , user_id : user . id } , function ( err ) { if ( err ) errors . push ( err ) ; callback ( errors . length == 0 ? null : errors , errors . length == 0 ) ; } ) ; } ) ; }
function ( err , result ) { if ( err ) { return cb ( err ) ; } else if ( ! result ) { return cb ( null , false ) ; } db . remove ( 'user_groups' , 'user_id IN (SELECT id FROM users WHERE username IN (' + repeat ( '?' , ',' , users . length ) + ')' , groups , function ( err ) { return cb ( err , ! err ) ; } ) ; }
function ( table , joins , columns , whereClause , whereValues , cb ) { var query = 'SELECT ' + ( columns ? cols ( columns ) : '*' ) + ' FROM ' + table ; if ( joins ) { for ( var table in joins ) { query += ', ' + table + ' ON ' + joins [ table ] ; } } query += ' WHERE ' + whereClause + ';' ; if ( DEBUG ) console . log ( query ) ; db . get ( query , whereValues , cb ) ; }
function asIcon ( result ) { var icon = document . createElement ( 'img' ) , name = result . color ; if ( name === 'aborted' || name === 'disabled' ) { name = 'grey' ; } icon . src = name + ".gif" ; return icon ; }
function ( ) { function collect ( obj , prop ) { var out = [ ] , i , l ; for ( i in obj ) { if ( obj . hasOwnProperty ( i ) && obj [ i ] [ prop ] ) { out . push ( obj [ i ] [ prop ] ) ; } } return out ; } function assets_loader ( assets , callback ) { yepnope ( { load : collect ( assets , 'link' ) , complete : callback } ) ; } ; return assets_loader ; }
function ( ) { this . countryTitle . reset ( ) ; for ( var key in this . regions ) { this . regions [ key ] . element . setStyle ( 'fill' , jvm . WorldMap . defaultColor ) ; } this . scale = this . baseScale ; this . transX = this . baseTransX ; this . transY = this . baseTransY ; this . applyTransform ( ) ; }
function ( ) { var i , selected = [ ] ; for ( i = 0 ; i < this . markers . length ; i ++ ) { if ( this . markers [ i ] . element . isSelected ) { selected . push ( i ) ; } } return selected ; }
function ( data ) { var callbackLoc = document . getElementById ( "update-callback" ) ; if ( callbackLoc ) { var total = data . update . installNeeds - data . update . storageNeeds ; callbackLoc . innerHTML = callbackLoc . innerText = data . bytesDownloaded + "/" + total ; } }
function ( el , options ) { this . $ = { table : $ ( el ) } this . $ . scrollBody = this . $ . table . wrap ( ( options && options . wrapper ) || this . constructor . defaults . wrapper ) . parent ( ) ; this . $ . body = this . $ . scrollBody . parent ( ) ; can . Control . prototype . setup . call ( this , this . $ . body . parent ( ) [ 0 ] , options ) ; }
function ( ) { S ( "#scrollable" ) . click ( ) . wait ( 100 ) ; S ( '.scrollBody' ) . scroll ( "left" , 10 ) ; S ( '.header' ) . scrollLeft ( 10 , function ( ) { ok ( true , "assertions make people feel better" ) } ) ; }
function ( lat , lng ) { if ( uMarker == null ) { map . setCenter ( new google . maps . LatLng ( lat , lng ) ) ; } else { uMarker . setPosition ( new google . maps . LatLng ( lat , lng ) ) ; win . setPosition ( aMarker . getPosition ( ) ) ; } searchCircle . setCenter ( new google . maps . LatLng ( lat , lng ) ) ; }
function ( ) { listeners . splice ( array . indexOf ( listeners , listener ) , 1 ) ; if ( ! listeners . length ) { queryUpdaters . splice ( array . indexOf ( queryUpdaters , queryUpdater ) , 1 ) ; } }
function ( event , target , options ) { event . preventDefault ( ) ; var inputField = Ext . get ( target ) . prev ( '.destroy-field' ) ; inputField . set ( { value : true } ) ; Ext . get ( target ) . parent ( ) . parent ( ) . hide ( ) ; }
function ( callback ) { for ( var j = - 1 , m = this . length ; ++ j < m ; ) { for ( var group = this [ j ] , i = - 1 , n = group . length ; ++ i < n ; ) { var node = group [ i ] ; if ( node ) callback . call ( node , node . __data__ , i , j ) ; } } return this ; }
function ( value ) { var groups = this ; return groups . each ( typeof value === "function" ? function ( d , i , j ) { groups [ j ] [ i ] . delay = value . apply ( this , arguments ) | 0 ; } : ( value = value | 0 , function ( d , i , j ) { groups [ j ] [ i ] . delay = value ; } ) ) ; }
function ( value ) { var groups = this ; return groups . each ( typeof value === "function" ? function ( d , i , j ) { groups [ j ] [ i ] . duration = Math . max ( 1 , value . apply ( this , arguments ) | 0 ) ; } : ( value = Math . max ( 1 , value | 0 ) , function ( d , i , j ) { groups [ j ] [ i ] . duration = value ; } ) ) ; }
function ( fn ) { switch ( typeof fn ) { case 'number' : delete _queue [ fn ] ; break ; case 'function' : for ( var id in _queue ) if ( _queue [ id ] === fn ) _animator . removeFromQueue ( parseInt ( id ) ) ; break ; default : throw 'Invalid type' ; } return _animator ; }
function ( ) { if ( ! this . _view ) { if ( this . _entry . isDirectory ) this . _view = new WebInspector . DirectoryContentView ( ) ; else return ; } this . _fileSystemView . showView ( this . _view ) ; this . refresh ( ) ; }
function ( ) { if ( ! this . _entry . isDirectory ) return ; this . _entry . requestDirectoryContent ( this . _directoryContentReceived . bind ( this ) ) ; }
function ( obj ) { if ( typeof obj === "undefined" || obj === null || ( typeof obj === "number" && isNaN ( obj ) ) ) { return false ; } else if ( obj . constructor === Array ) { return "array" ; } else { return typeof obj ; } }
function ( savedIdentity ) { app . localStorage . setItem ( identity . local_store_id , JSON . stringify ( savedIdentity ) ) ; identity . set ( 'administrator_id' , savedIdentity . administrator_id ) ; identity . set ( 'is_logged_in' , true ) ; identity . set ( 'password' , '' ) ; }
function ( jqXHR , textStatus , errorThrown ) { error = JSON . parse ( jqXHR . responseText ) ; if ( error . password !== undefined ) { readableError = error . password . join ( '<br />' ) ; } else { readableError = jqXHR . responseText ; } identityController . views . login . set ( 'error' , readableError ) ; }
function ( collectionView , itemView ) { collectionView . $el . find ( 'ul' ) . prepend ( itemView . el ) ; }
function ( ) { this . _showDetails ( ) ; }
function ( observation ) { }
function ( ) { var model = this . model . toJSON ( ) ; model . CreatedDateTimeDescription = parseISO8601 ( this . model . get ( 'CreatedDateTime' ) ) ; model . ObservedOnDescription = '' ; return { Model : model } ; }
function ( page , pageSize , sortField , sortDirection , searchQuery ) { var deferred = new $ . Deferred ( ) ; if ( app . isPrerendering ( 'projects' ) ) { deferred . resolve ( app . prerenderedView . data ) ; } else { var params = { } ; $ . ajax ( { url : '/projects/explore' , data : params } ) . done ( function ( data ) { deferred . resolve ( data . Model ) ; } ) ; } return deferred . promise ( ) ; }
function ( err , r ) { if ( res . statusCode == 400 || res . statusCode == 401 || res . statusCode == 403 || res . statusCode == 404 || res . statusCode == 500 || res . statusCode == 503 ) { error ( r ) ; } else { success ( r ) ; } }
function ( code ) { t . equal ( code , 0 ) ; var allDone = false ; var c = { done : function ( ) { allDone = true } } ; vm . runInNewContext ( src , c ) ; t . deepEqual ( [ 'path' , '__browserify_process' , '/one.js' , '/two.js' , '/main.js' ] . sort ( ) , Object . keys ( c . require . modules ) . sort ( ) ) ; t . ok ( allDone ) ; t . end ( ) ; }
function ( roomJid , historyStanzas ) { if ( ! historyStanzas ) { historyStanzas = 0 ; } var packet = new xmpp . Element ( 'presence' , { to : roomJid + '/' + this . name } ) ; packet . c ( 'x' , { xmlns : 'http://jabber.org/protocol/muc' } ) . c ( 'history' , { xmlns : 'a' , maxstanzas : String ( historyStanzas ) } ) ; this . jabber . send ( packet ) ; }
function ( element , event ) { this . lastActive = element ; if ( this . settings . focusCleanup && ! this . blockFocusCleanup ) { if ( this . settings . unhighlight ) { this . settings . unhighlight . call ( this , element , this . settings . errorClass , this . settings . validClass , this . _defaults . unhighlight ) ; } this . addWrapper ( this . errorsFor ( element ) ) . hide ( ) ; } }
function str2ascii ( str , del ) { var ascii = '' ; str = str . split ( del ) ; for ( var i in str ) { ascii += str [ i ] . charCodeAt ( 0 ) ; } return ascii ; }
function ( speed ) { console . log ( "horizontal move:  " + speed ) ; var rightVec = vec3 . create ( this . _modelView [ 0 ] , this . _modelView [ 4 ] , this . _modelView [ 8 ] ) ; console . log ( "right vector:  " + rightVec ) ; rightVec = vec3 . scale ( rightVec , speed ) ; console . log ( "scaled right vector:  " + rightVec ) ; this . _cameraPosition = vec3 . multiply ( this . _cameraPosition , rightVec ) ; }
function ( speed ) { var forwardVec = vec3 . create ( this . _modelView [ 1 ] , this . _modelView [ 5 ] , this . _modelView [ 9 ] ) ; forwardVec = vec3 . scale ( forwardVec , speed ) ; this . _cameraPosition = vec3 . multiply ( this . _cameraPosition , forwardVec ) ; }
function ( speed ) { var upVec = vec3 . create ( this . _modelView [ 1 ] , this . _modelView [ 5 ] , this . _modelView [ 9 ] ) ; upVec = vec3 . scale ( upVec , speed ) ; this . _cameraPosition = vec3 . multiply ( this . _cameraPosition , upVec ) ; }
function ( browser ) { var annotation = "firebugged.showFirebug" ; this . setPageAnnotation ( browser . currentURI . spec , annotation ) ; }
function ( object , panelName , sidePanelName , forceUpdate ) { if ( FBTrace . DBG_PANELS ) FBTrace . sysout ( "chrome.select object:" + object + " panelName:" + panelName + " sidePanelName:" + sidePanelName + " forceUpdate:" + forceUpdate + "\n" ) ; var bestPanelName = getBestPanelName ( object , Firebug . currentContext , panelName ) ; var panel = this . selectPanel ( bestPanelName , sidePanelName , true ) ; if ( panel ) panel . select ( object , forceUpdate ) ; this . syncLocationList ( ) ; }
function ( context , event ) { if ( event . target . id != "cmd_toggleBreakOn" ) return ; if ( ! context ) { if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext with no context??" ) ; return ; } var panel = panelBar1 . selectedPanel ; if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext for panel " + ( panel ? panel . name : "NO panel" ) , panel ) ; if ( panel && panel . breakable ) Firebug . Breakpoint . toggleBreakOnNext ( panel ) ; }
function ( context ) { var panel = Firebug . chrome . getSelectedPanel ( ) ; if ( panel && panel . name == "console" ) return ; if ( FBTrace . DBG_COMMANDLINE ) FBTrace . sysout ( "commandLine.Popup.toggle;" ) ; var newState = ! this . isVisible ( ) ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleCommandPopup" , "checked" , newState ) ; Firebug . Options . set ( "alwaysShowCommandLine" , newState ) ; this . updateVisibility ( newState ) ; this . reattach ( context ) ; this . showPopupPanel ( context ) ; }
function ( ) { var fbStatus = Firefox . getElementById ( 'firebugStatus' ) ; if ( fbStatus ) { if ( Firebug . Errors . watchForErrors ) fbStatus . setAttribute ( "console" , "on" ) ; else fbStatus . removeAttribute ( "console" ) ; } else { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "console.setStatus ERROR no firebugStatus element" ) ; } }
function ( state ) { if ( FBTrace . DBG_CONSOLE ) FBTrace . sysout ( "Console.panel show; wasScrolledToBottom: " + ( state ? state . wasScrolledToBottom : "no prev state" ) + " " + this . context . getName ( ) , state ) ; this . showCommandLine ( true ) ; this . showToolbarButtons ( "fbConsoleButtons" , true ) ; this . setFilter ( Firebug . consoleFilterTypes ) ; Firebug . chrome . setGlobalAttribute ( "cmd_togglePersistConsole" , "checked" , this . persistContent ) ; this . showPanel ( state ) ; }
function getExceptionContext ( context , object ) { var errorWin = getErrorWindow ( object ) if ( errorWin ) { var errorContext = Firebug . connection . getContextByWindow ( errorWin ) ; if ( FBTrace . DBG_ERRORLOG ) { FBTrace . sysout ( "errors.observe exception context: " + ( errorContext ? errorContext . getName ( ) : "none" ) + " errorWin: " + Win . safeGetWindowLocation ( errorWin ) ) ; } if ( errorContext ) return errorContext ; } return context ; }
function ( context , cancelReport ) { var totalTime = FBS . stopProfiling ( ) ; if ( totalTime == - 1 ) return ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleProfiling" , "checked" , "false" ) ; if ( cancelReport ) delete context . profileRow ; else this . logProfileReport ( context , cancelReport ) ; Firebug . Console . removeListener ( this ) ; }
function ( result , context ) { if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onEvaluateSucceeds; " + result , result ) ; if ( ! result ) return ; context . breakingCause = { title : Locale . $STR ( "firecookie.Break On Cookie" ) , message : Str . cropString ( unescape ( this . name + "; " + this . condition + "; " ) , 200 ) } ; }
function ( result , context ) { if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onEvaluateFails; " + result , result ) ; context . breakingCause = { title : Locale . $STR ( "firecookie.Break On Cookie" ) , message : Locale . $STR ( "firecookie.Breakpoint condition evaluation fails" ) , prevValue : this . condition , newValue : result } ; }
function getBrowserDocument ( ) { return Firebug . chrome . inDetachedScope ? Firebug . chrome . originalBrowser . ownerDocument : top . document ; }
function ( context ) { if ( Firebug . CookieModule . isAlwaysEnabled ( ) ) TabWatcher . iterateContexts ( Firebug . CookieModule . registerObservers ) ; top . document . getElementById ( "firebugStatus" ) . setAttribute ( panelName , "on" ) ; if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onResumeFirebug" ) ; }
function ( context ) { var params = { blockVisible : true , sessionVisible : true , allowVisible : true , prefilledHost : "" , permissionType : "cookie" , windowTitle : Locale . $STR ( "firecookie.ExceptionsTitle" ) , introText : Locale . $STR ( "firecookie.Intro" ) } ; parent . openDialog ( "chrome://browser/content/preferences/permissions.xul" , "_blank" , "chrome,resizable=yes" , params ) ; }
function ( infoBox , file ) { var sentCookiesHeader = this . findHeader ( file . requestHeaders , "Cookie" ) ; var receivedCookiesHeader = this . findHeader ( file . responseHeaders , "Set-Cookie" ) ; if ( sentCookiesHeader || receivedCookiesHeader ) Firebug . NetMonitor . NetInfoBody . appendTab ( infoBox , "Cookies" , Locale . $STR ( "firecookie.Panel" ) ) ; }
function ( aSubject , aTopic , aData ) { if ( aTopic != "perm-changed" ) return ; if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.observe: " + aTopic + ", " + aData ) ; var fn = CookiePermissions . updatePermButton ; TabWatcher . iterateContexts ( fn ) ; }
function ( context ) { return [ MenuUtils . optionAllowGlobally ( context , "firecookie.AllowGlobally" , networkPrefDomain , cookieBehaviorPref ) , MenuUtils . optionMenu ( context , "cookies.LogEvents" , Firebug . prefDomain , logEventsPref ) , MenuUtils . optionMenu ( context , "firecookie.Confirm cookie removal" , Firebug . prefDomain , removeConfirmation ) ] ; }
function ( cookie ) { var limit = 200 ; var value = cookie . cookie . value ; if ( value . length > limit ) return Str . escapeNewLines ( value . substr ( 0 , limit ) + "..." ) ; else return Str . escapeNewLines ( value ) ; }
function ( cookie ) { if ( cookie . cookie . expires == undefined ) return "" ; if ( cookie . cookie . expires == 0 ) return " " + Locale . $STR ( "firecookie.Session" ) ; try { var date = new Date ( cookie . cookie . expires * 1000 ) ; return date . toLocaleString ( ) ; } catch ( err ) { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "cookies.CookieRow.getExpires; EXCEPTION " + err , err ) ; } return "" ; }
function ( clickedCookie ) { var text = "" ; var tbody = Dom . getAncestorByClass ( clickedCookie . row , "cookieTable" ) . firstChild ; for ( var row = tbody . firstChild ; row ; row = row . nextSibling ) { if ( Css . hasClass ( row , "cookieRow" ) && row . repObject ) text += row . repObject . toString ( ) + "\n" ; } copyToClipboard ( text ) ; }
function ( cookie ) { if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onClearValue;" , cookie ) ; var newCookie = new Firebug . CookieModule . Cookie ( cookie . cookie ) ; newCookie . cookie . rawValue = "" ; Firebug . CookieModule . createCookie ( newCookie ) ; }
function ( cookieEvent ) { switch ( cookieEvent . action ) { case "deleted" : return Locale . $STR ( "firecookie.console.deleted" ) ; case "added" : return Locale . $STR ( "firecookie.console.added" ) ; case "changed" : return Locale . $STR ( "firecookie.console.changed" ) ; case "cleared" : return Locale . $STR ( "firecookie.console.cleared" ) ; } return "" ; }
function ( event ) { if ( ! Events . isLeftClick ( event ) ) return ; var target = event . target ; if ( ! Css . hasClass ( target , "cookieHeaderCellBox" ) ) return ; var header = Dom . getAncestorByClass ( target , "cookieHeaderRow" ) ; if ( ! header ) return ; this . onStartResizing ( event ) ; Events . cancelEvent ( event ) ; }
function ( context , label , domain , option ) { var value = Options . get ( option ) == 0 ; return { label : Locale . $STR ( label ) , nol10n : true , type : "checkbox" , checked : value , command : Obj . bindFixed ( this . onAllowCookie , this , domain , option ) } }
function ( state ) { if ( this . context . loaded ) { var state ; Persist . restoreObjects ( this , state ) ; if ( state ) { if ( state . scrollTop ) this . panelNode . scrollTop = state . scrollTop ; if ( state . groupOpened ) this . groupOpened = state . groupOpened ; if ( state . styleOpened ) this . styleOpened = state . styleOpened ; } } if ( this . selection ) this . refresh ( ) ; }
function ( name , value ) { var options = [ "showUserAgentCSS" , "computedStylesDisplay" , "colorDisplay" , "showMozillaSpecificStyles" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . refresh ( ) ; }
function ( context , win ) { var doc = win . document ; this . cleanupSheetListener = Obj . bind ( this . cleanupSheetHandler , this , context ) ; context . addEventListener ( doc , "DOMAttrModified" , this . cleanupSheetListener , false ) ; context . addEventListener ( doc , "DOMNodeInserted" , this . cleanupSheetListener , false ) ; }
function ( context , win ) { var doc = win . document ; if ( this . cleanupSheetListener ) { context . removeEventListener ( doc , "DOMAttrModified" , this . cleanupSheetListener , false ) ; context . removeEventListener ( doc , "DOMNodeInserted" , this . cleanupSheetListener , false ) ; } }
function ( ) { this . onMouseDown = Obj . bind ( this . onMouseDown , this ) ; this . onClick = Obj . bind ( this . onClick , this ) ; Firebug . Panel . initialize . apply ( this , arguments ) ; }
function ( state ) { state . scrollTop = this . panelNode . scrollTop ? this . panelNode . scrollTop : this . lastScrollTop ; Persist . persistObjects ( this , state ) ; this . stopEditing ( ) ; Firebug . Panel . destroy . apply ( this , arguments ) ; }
function ( oldPanelNode ) { Events . addEventListener ( this . panelNode , "mousedown" , this . onMouseDown , false ) ; Events . addEventListener ( this . panelNode , "click" , this . onClick , false ) ; Firebug . Panel . initializeNode . apply ( this , arguments ) ; }
function ( ) { Events . removeEventListener ( this . panelNode , "mousedown" , this . onMouseDown , false ) ; Events . removeEventListener ( this . panelNode , "click" , this . onClick , false ) ; Firebug . Panel . destroyNode . apply ( this , arguments ) ; }
function ( target , panel , value , textSize ) { this . target = target ; this . panel = panel ; this . panel . panelNode . appendChild ( this . box ) ; this . input . value = value ; this . input . focus ( ) ; var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , true ) ; }
function ( ) { var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , false ) ; if ( this . box . parentNode == this . panel . panelNode ) this . panel . panelNode . removeChild ( this . box ) ; delete this . target ; delete this . panel ; delete this . styleSheet ; }
function ( element , sections , usedProps ) { var parent = element . parentNode ; if ( parent && parent . nodeType == 1 ) { this . getInheritedRules ( parent , sections , usedProps ) ; var rules = [ ] ; this . getElementRules ( parent , rules , usedProps , true ) ; if ( rules . length ) sections . splice ( 0 , 0 , { element : parent , rules : rules } ) ; } }
function ( ) { this . onMouseDown = Obj . bind ( this . onMouseDown , this ) ; this . onClick = Obj . bind ( this . onClick , this ) ; this . onStateChange = Obj . bindFixed ( this . contentStateCheck , this ) ; this . onHoverChange = Obj . bindFixed ( this . contentStateCheck , this , STATE_HOVER ) ; this . onActiveChange = Obj . bindFixed ( this . contentStateCheck , this , STATE_ACTIVE ) ; Firebug . Panel . initialize . apply ( this , arguments ) ; }
function ( context , win ) { if ( Dom . domUtils ) { var doc = win . document ; context . addEventListener ( doc , "mouseover" , this . onHoverChange , false ) ; context . addEventListener ( doc , "mousedown" , this . onActiveChange , false ) ; } }
function ( context , win ) { var doc = win . document ; context . removeEventListener ( doc , "mouseover" , this . onHoverChange , false ) ; context . removeEventListener ( doc , "mousedown" , this . onActiveChange , false ) ; if ( Dom . isAncestor ( this . stateChangeEl , doc ) ) { this . removeStateChangeHandlers ( ) ; } }
function ( element ) { if ( ! ( element instanceof window . Element ) ) return ; var sothinkInstalled = ! ! Firefox . getElementById ( "swfcatcherKey_sidebar" ) ; if ( sothinkInstalled ) { var div = FirebugReps . Warning . tag . replace ( { object : "SothinkWarning" } , this . panelNode ) ; div . innerHTML = Locale . $STR ( "SothinkWarning" ) ; return ; } if ( ! element ) return ; this . updateView ( element ) ; }
function ( name , value ) { var options = [ "showUserProps" , "showUserFuncs" , "showDOMProps" , "showDOMFuncs" , "showDOMConstants" , "showInlineEventHandlers" , "showOwnProperties" , "showEnumerableProperties" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . rebuild ( true ) ; }
function ( ) { if ( ! this . autoCompleter ) { this . autoCompleter = new Firebug . AutoCompleter ( false , Obj . bind ( this . getAutoCompleteRange , this ) , Obj . bind ( this . getAutoCompleteList , this ) , Obj . bind ( this . getAutoCompletePropSeparator , this ) ) ; } return this . autoCompleter ; }
function ( context , textBox , cycle ) { if ( ! textBox . value && ! cycle ) { return false ; } var offset = textBox . selectionStart ; var found = this . pickCandidates ( textBox , context , cycle ) ; if ( ! found ) this . reset ( ) ; return found ; }
function ( ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; var menuitem = Firebug . chrome . $ ( "menu_" + this . getEditorOptionKey ( ) + mode ) ; var command = Firebug . chrome . $ ( "cmd_toggle" + this . getEditorOptionKey ( ) ) ; command . setAttribute ( "label" , menuitem . label ) ; command . setAttribute ( "tooltiptext" , menuitem . tooltipText ) ; }
function ( popup ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; for ( var child = popup . firstChild ; child ; child = child . nextSibling ) { if ( child . localName == "menuitem" ) { if ( child . id == "menu_" + this . getEditorOptionKey ( ) + mode ) child . setAttribute ( "checked" , true ) ; else child . removeAttribute ( "checked" ) ; } } }
function addListeners ( win ) { var doc = win . document ; if ( doc . location == "about:blank" ) return ; Events . addEventListener ( doc , "DOMAttrModified" , self . onMutateAttr , false ) ; Events . addEventListener ( doc , "DOMCharacterDataModified" , self . onMutateText , false ) ; Events . addEventListener ( doc , "DOMNodeInserted" , self . onMutateNode , false ) ; Events . addEventListener ( doc , "DOMNodeRemoved" , self . onMutateNode , false ) ; }
function ( event ) { Events . cancelEvent ( event ) ; var bpPanel = Firebug . getElementPanel ( event . target ) ; var context = bpPanel . context ; if ( Css . hasClass ( event . target , "closeButton" ) ) { var row = Dom . getAncestorByClass ( event . target , "breakpointRow" ) ; context . mutationBreakpoints . removeBreakpoint ( row . repObject ) ; bpPanel . refresh ( ) ; } }
function ( panel , armed ) { var breakable = armed ? "false" : "true" ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleBreakOn" , "breakable" , breakable ) ; }
function ( panelType , enable ) { if ( ! enable ) { var self = this ; Firebug . connection . eachContext ( function ( context ) { context . destroyPanel ( panelType , context . persistedState ) ; } ) ; } panelType . prototype . onActivationChanged ( enable ) ; Firebug . chrome . syncPanel ( ) ; }
function ( sourceBox , viewRange ) { try { this . updateViewportCache ( sourceBox , viewRange ) ; } catch ( exc ) { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "buildViewAround updateViewportCache FAILS " + exc , exc ) ; } Dom . collapse ( sourceBox , false ) ; this . setViewportPadding ( sourceBox , viewRange ) ; sourceBox . centralLine = Math . floor ( ( viewRange . lastLine + viewRange . firstLine ) / 2 ) ; this . applyDecorator ( sourceBox ) ; return ; }
function ( script , context , frame ) { if ( frame ) { var name = frame . name ; var args = StackFrame . getFunctionArgValues ( frame ) ; } else { var name = script . functionName ; var args = [ ] ; } if ( name == "anonymous" ) { name = StackFrame . guessFunctionName ( this . sourceFile . href , this . getBaseLineNumberByScript ( script ) , context ) ; } return { name : name , args : args } ; }
function ( url , line , context ) { var sourceFile = context . sourceFileMap [ url ] ; if ( sourceFile ) { var scripts = sourceFile . getScriptsAtLineNumber ( line ) ; if ( scripts ) { var script = scripts [ 0 ] ; var analyzer = sourceFile . getScriptAnalyzer ( script ) ; line = analyzer . getBaseLineNumberByScript ( script ) ; } } return StackFrame . guessFunctionName ( url , line - 1 , context ) ; }
function ( expression ) { if ( FBTrace . DBG_WATCH ) FBTrace . sysout ( "Firebug.WatchPanel.addWatch; expression: " + expression ) ; if ( ! this . watches ) this . watches = [ ] ; for ( var i = 0 ; i < this . watches . length ; i ++ ) { if ( expression == this . watches [ i ] ) return ; } this . watches . splice ( 0 , 0 , expression ) ; this . rebuild ( true ) ; }
function ( element , html ) { var doc = element . ownerDocument ; var range = doc . createRange ( ) ; range . selectNode ( element || doc . documentElement ) ; try { var fragment = range . createContextualFragment ( html ) ; var first = fragment . firstChild ; var last = fragment . lastChild ; element . parentNode . replaceChild ( fragment , element ) ; return [ first , last ] ; } catch ( e ) { return [ element , element ] } }
function ( context , fullName , url ) { try { Services . scriptloader . loadSubScript ( url , context ) ; } catch ( err ) { Cu . reportError ( fullName + " -> " + url ) ; Cu . reportError ( err ) ; } }
function ( err , files ) { if ( err ) { ret . errback ( err ) ; } else { files = files . filter ( function ( file ) { return file . match ( this . MIGRATION_FILE_PATTERN ) != null ; } , this ) ; ret . callback ( files . map ( function ( file ) { return path . resolve ( directory , file ) } ) ) ; } }
function ( ) { var params = $ ( editorId ) . keyvalueeditor ( 'getValues' ) ; var newParams = [ ] ; for ( var i = 0 ; i < params . length ; i ++ ) { var param = { key : params [ i ] . key , value : params [ i ] . value } ; newParams . push ( param ) ; } postman . currentRequest . setBodyParamString ( newParams ) ; }
function ( ) { var value = "" + this ; if ( $ . inArray ( value , dt . data [ rowuri ] [ property_uri ] ) === - 1 ) { dt . data [ rowuri ] [ property_uri ] . push ( value ) ; var innercell = dt . makediv ( [ "innercell" ] ) ; cell . append ( innercell ) ; innercell . html ( value ) ; } }
function ( ) { if ( this . options . allow_single_deselect && dojo . query ( 'abbr' , this . selected_item ) . length < 1 ) { dojo . create ( 'abbr' , { class : 'search-choice-close' } , dojo . query ( 'span' , this . selected_item ) . shift ( ) ) ; } }
function ( terms ) { var no_results_html = dojo . create ( 'li' , { class : 'no-results' , innerHTML : this . results_none_found + ' "<span></span>" ' } , this . search_results ) ; dojo . query ( 'span' , no_results_html ) . shift ( ) . innerHTML = terms ; }
function ( ) { var i , l , buffer = this . logBuffer ; console . log ( buffer . join ( '\n' ) + '\n\n' + 'success: ' + this . countSuccess + ', failed: ' + this . countFailed + ', total: ' + ( this . countSuccess + this . countFailed ) ) ; return this ; }
function ( result , callback ) { try { var parsed = JSON . parse ( result ) ; } catch ( ex ) { return callback ( new Error ( 'Invalid response from "' + url + '"; malformed JSON.' ) ) ; } if ( options . cache ) { return api . cacheJsonLd ( url , result , function ( err ) { callback ( err , parsed ) ; } ) ; } callback ( null , parsed ) ; }
function ( result , callback ) { try { callback ( null , result ) ; } catch ( ex ) { callback ( new Error ( 'Invalid response from "' + url + '"; malformed JSON - ' + ex . toString ( ) + ': ' + JSON . stringify ( result , null , 2 ) ) ) ; } }
function ( err , key ) { if ( ! ( 'publicKeyPem' in key ) ) { return callback ( new Error ( 'PaySwarm Security Exception: ' + 'Could not get public key. Unknown format.' ) ) ; } api . cacheJsonLd ( id , key , function ( err ) { if ( err ) { return callback ( err ) ; } callback ( null , key ) ; } ) ; }
function ( err , result ) { if ( err ) { return callback ( err ) ; } var md = crypto . createHash ( 'sha1' ) ; md . update ( result , 'utf8' ) ; callback ( null , md . digest ( 'hex' ) ) ; }
function ( err , framed ) { if ( err ) { return callback ( err ) ; } if ( obj [ '@graph' ] . length === 0 || obj [ '@graph' ] [ 0 ] . signature === null ) { return callback ( new Error ( 'PaySwarm Security Exception: ' + 'The message is not digitally signed.' ) ) ; } callback ( null , obj [ '@graph' ] [ 0 ] ) ; }
function ( callback , results ) { var now = + new Date ( ) ; try { var signInfo = results . frame . signature ; var created = + Date . parse ( signInfo . created ) ; if ( created < ( now - 15 * 60 ) || created > ( now + 15 * 60 ) ) { throw new Error ( 'PaySwarm Security Exception: ' + 'The message digital signature timestamp is out of range.' ) ; } } catch ( ex ) { callback ( ex ) ; } }
function ( callback , results ) { var verifier = crypto . createVerify ( 'RSA-SHA1' ) ; if ( 'nonce' in signInfo ) { verifier . update ( signInfo . nonce ) ; } verifier . update ( signInfo . created ) ; verifier . update ( results . normalize . data ) ; var verified = verifier . verify ( results . getPublicKey . publicKeyPem , signInfo . signatureValue , 'base64' ) ; if ( ! verified ) { return callback ( new Error ( 'PaySwarm Security Exception: ' + 'The digital signature on the message is invalid.' ) ) ; } callback ( ) ; }
function ( callback , results ) { var license = results . post ; if ( license === null || typeof license !== 'object' ) { return callback ( new Error ( 'PaySwarm Exception: ' + 'Invalid response when caching license.' ) ) ; } if ( 'message' in license ) { return callback ( new Error ( 'PaySwarm Exception: ' + 'Error while caching license: ' + license [ 'message' ] ) ) ; } callback ( null , license ) ; }
function ( callback , results ) { var prefs = results . decode ; if ( jsonld . hasValue ( prefs , 'type' , 'err:Error' ) ) { return callback ( new Error ( 'PaySwarm Registration Exception: ' + prefs . errorMessage ) ) ; } if ( ! jsonld . hasValue ( prefs , 'type' , 'ps:Preferences' ) ) { return callback ( new Error ( 'PaySwarm Registration Exception: ' + 'Invalid registration response from PaySwarm Authority.' ) ) ; } callback ( ) ; }
function ( listingData , callback ) { var listingFrame = { '@context' : api . createDefaultJsonLdContext ( ) , type : 'ps:Listing' , asset : { '@embed' : false } , license : { '@embed' : false } , signature : { '@embed' : true } } ; jsonld . frame ( listingData , listingFrame , callback ) ; }
function ( callback , results ) { var receipt = results . decode ; if ( jsonld . hasValue ( receipt , 'type' , 'err:Error' ) ) { return callback ( new Error ( 'PaySwarm Purchase Exception: ' + receipt [ 'err:message' ] ) ) ; } if ( ! jsonld . hasValue ( receipt , 'type' , 'ps:Contract' ) ) { return callback ( new Error ( 'PaySwarm Registration Exception: ' + 'Invalid purchase response from PaySwarm Authority.' ) ) ; } callback ( ) ; }
function ( callback , results ) { var receipt = results . decode ; if ( ! ( 'assetAcquirer' in receipt ) || ! ( 'asset' in receipt ) || ! ( 'license' in receipt ) ) { return callback ( new Error ( 'PaySwarm Purchase Exception: ' + 'Unknown Contract format.' ) ) ; } callback ( ) ; }
function ( session , row ) { var tokens = session . getTokens ( row , row ) [ 0 ] . tokens ; var value = "" ; for ( var i = 0 ; i < tokens . length ; i ++ ) { var token = tokens [ i ] ; if ( token . type . indexOf ( "meta.tag" ) === 0 ) value += token . value ; else value += lang . stringRepeat ( " " , token . value . length ) ; } return this . _parseTag ( value ) ; }
function ( session , row ) { var tokens = session . getTokens ( row , row ) [ 0 ] . tokens ; var value = "" ; for ( var i = 0 ; i < tokens . length ; i ++ ) { var token = tokens [ i ] ; if ( token . type . indexOf ( "meta.tag" ) === 0 ) value += token . value ; else value += lang . stringRepeat ( " " , token . value . length ) ; } return this . _parseTag ( value ) ; }
function ( name , resolveNode ) { if ( ! this . vars [ '_' + name ] ) this . vars [ '_' + name ] = new Variable ( resolveNode ) ; else if ( resolveNode ) this . vars [ '_' + name ] . addDeclaration ( resolveNode ) ; return this . vars [ '_' + name ] ; }
function ( event ) { var message = event . data . message ; var pos = event . data . pos ; var cursorPos = ceEditor . $editor . getCursorPosition ( ) ; if ( cursorPos . column === pos . column && cursorPos . row === pos . row && message ) tooltip . show ( cursorPos . row , cursorPos . column , message ) ; else tooltip . hide ( ) ; }
function ( ) { if ( aggregateActions . hint && ! hintMessage ) { hintMessage = aggregateActions . hint ; } _self . scheduleEmit ( "markers" , _self . filterMarkersBasedOnLevel ( _self . currentMarkers . concat ( aggregateActions . markers ) ) ) ; _self . scheduleEmit ( "enableRefactorings" , aggregateActions . enableRefactorings ) ; _self . lastCurrentNode = currentNode ; _self . setLastAggregateActions ( aggregateActions ) ; _self . scheduleEmit ( "hint" , { pos : pos , message : hintMessage } ) ; }
function ( opts ) { var options = opts || { } ; var features = options . features || [ ] ; var map = options . map || null ; var featureCollection = new komoo . collections . FeatureCollection ( options ) ; if ( map ) featureCollection . setMap ( map ) ; if ( features ) features . forEach ( function ( feature , index , orig ) { featureCollections . push ( feature ) ; } ) ; return featureCollection ; }
function ( ) { var features = [ ] ; var geoJSON = { 'type' : 'FeatureCollection' , 'features' : features } ; this . features_ . forEach ( function ( feature , index , orig ) { features . push ( feature . getGeoJsonFeature ( ) ) ; } ) ; return geoJSON ; }
function ( ) { this . features_ . forEach ( function ( feature , index , orig ) { feature . removeFromMap ( ) ; } ) ; }
function ( feature , index , orig ) { feature . setMap ( feature . getMap ( ) ) ; }
function ( opts ) { var options = opts || { } ; this . width_ = options . width || '300px' ; this . createInfoBox_ ( options ) ; this . setMap ( options . map ) ; this . customize_ ( ) ; }
function ( opts ) { var options = opts || { } ; var infoWindowOptions = { pixelOffset : new google . maps . Size ( 0 , - 20 ) , enableEventPropagation : true , closeBoxMargin : '10px' , disableAutoPan : true , boxStyle : { cursor : 'pointer' , background : 'url(/static/img/infowindow-arrow.png) no-repeat 0 10px' , width : this . width_ } } ; this . setInfoBox ( new InfoBox ( infoWindowOptions ) ) ; }
function ( ) { fimo . page . create ( fimo . views . jumblePeople ( _ . extend ( _this . instanceArguments , { jumbleObjectVerbs : $ ( '#verbs' ) . val ( ) , jumbleObjectTags : $ ( '#tags' ) . val ( ) } ) ) ) ; return false ; }
function ( ) { fimo . page . create ( fimo . views . jumbleObject ( _ . extend ( _this . instanceArguments , { jumbleFriendsMessage : $ ( '#message' ) . val ( ) , jumbleSelectedFriends : $ ( '#friends' ) . val ( ) } ) ) ) ; return false ; }
function setup_redirect ( aSettings ) { var url = "https://example.com/browser/toolkit/mozapps/extensions/test/xpinstall/redirect.sjs?mode=setup" ; for ( var name in aSettings ) { url += "&" + name + "=" + aSettings [ name ] ; } var req = new XMLHttpRequest ( ) ; req . open ( "GET" , url , false ) ; req . send ( null ) ; }
function waitForSingleNotification ( ) { ok ( PopupNotifications . isPanelOpen , "Notification should still be open" ) ; if ( PopupNotifications . panel . childNodes . length == 2 ) { executeSoon ( waitForSingleNotification ) ; return ; } is ( PopupNotifications . panel . childNodes . length , 1 , "Should be only one notification" ) ; notification = aPanel . childNodes [ 0 ] ; is ( notification . id , "addon-install-failed-notification" , "Should have seen the install fail" ) ; Services . prefs . setBoolPref ( PREF_INSTALL_REQUIREBUILTINCERTS , true ) ; wait_for_notification_close ( runNextTest ) ; gBrowser . removeTab ( gBrowser . selectedTab ) ; }
function ( a ) { return toVisibleControl ( a . charCodeAt ( 0 ) ) ; }
function toVisibleControl ( code ) { return String . fromCharCode ( code == 0x7f ? 0x2421 : 0x2400 + code ) ; }
function ( filepath ) { grunt . helper ( 'coffee' , filepath , dest , options , extension ) ; }
function ( name , spawnOptions ) { if ( __dialogs [ name ] ) { if ( __openDialogs [ name ] ) { __openDialogs [ name ] . focus ( ) ; } else { __openDialogs [ name ] = __dialogs [ name ] ( spawnOptions ) ; __openDialogs [ name ] . listen ( "close" , function ( ) { __openDialogs [ name ] = null ; } ) ; } return __openDialogs [ name ] ; } else { throw "Dialog '" + name + "' does no exist." ; } }
function ( ) { $ ( ':not(.invalid)' ) . qtip ( 'destroy' ) ; return $ ( '.invalid' ) . qtip ( { overwrite : false , content : { text : function ( api ) { return $ ( this ) . attr ( 'data-error' ) ; } } , position : { my : 'left center' , at : 'right center' , viewport : $ ( window ) } , show : { event : false , ready : true } , hide : false , style : { classes : 'ui-tooltip-jtools' } } ) ; }
function ( ) { this . modelBinder = new Backbone . ModelBinder ( ) ; this . template = require ( '../../scripts/text!user_maintenance.html' ) ; this . viewModel = this . options . viewModel ; this . model . on ( 'change:email' , this . SetGravatarImage , this ) ; return this . model . get ( "departments" ) . on ( 'reset' , this . departmentsLoaded , this ) ; }
function ( e ) { this . _unpoll ( ) ; if ( getSelection ( ) !== sub . _selection ) { sub . _selection = '' ; sub . _notifier . fire ( { selection : sub . _selection , pageX : e . pageX , pageY : e . pageY } ) ; } }
function ( e ) { this . _unpoll ( ) ; if ( getSelection ( ) !== sub . _selection ) { sub . _selection = '' ; sub . _notifier . fire ( { selection : sub . _selection , pageX : e . pageX , pageY : e . pageY } ) ; } }
function ( e ) { this . _unpoll ( ) ; if ( getSelection ( ) !== sub . _selection ) { sub . _selection = '' ; sub . _notifier . fire ( { selection : sub . _selection , pageX : e . pageX , pageY : e . pageY } ) ; } }
function ( path ) { var input = flock . get ( path , that . ugens . named ) ; return typeof ( input . model . value ) !== "undefined" ? input . model . value : input ; }
function ( ) { stateOptions = [ normalState , hoverState , pressedState ] [ curState ] ; stateStyle = [ normalStyle , hoverStyle , pressedStyle ] [ curState ] ; label . attr ( stateOptions ) . css ( stateStyle ) ; }
function ( ) { var getOlderHost = utils . getOlderHost ; var serverPort = 'nowall.be' ; getOlderHost ( 'www.ozymr3swo2-myw-36.nowall.be' , serverPort ) . should . equal ( 'www.epochtimes.com.tw' ) getOlderHost ( 'www.ozymr3swo2-myw.nowall.be' , serverPort ) . should . equal ( 'www.epochtimes.com' ) should . not . exist ( getOlderHost ( 'www.ozymr3swo2-s0m.nowall.be' , serverPort ) ) }
function ( text , lang ) { if ( lang ) { if ( lang != this . defaultLang ) { return this . lang [ lang ] [ text ] ; } else { return text ; } } else { if ( this . currentLang != this . defaultLang ) { return this . lang [ this . currentLang ] [ text ] ; } else { return text ; } } }
function ( imageId ) { if ( $ ( '#images li' ) . length <= _updateImageListThreshold ) { var lastImage = $ ( '#images li' ) . last ( ) ; $ . get ( '/next/' + ( _listCount - _updateImageListThreshold ) + '?ids=' + _imageIds . join ( ',' ) , appendImages ) ; } }
function ( ) { Chosen . __super__ . set_default_values . call ( this ) ; this . single_temp = new Template ( '<a href="javascript:void(0)" class="chzn-single chzn-default"><span>#{default}</span><div><b></b></div></a><div class="chzn-drop" style="left:-9000px;"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>' ) ; this . multi_temp = new Template ( '<ul class="chzn-choices"><li class="search-field"><input type="text" value="#{default}" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop" style="left:-9000px;"><ul class="chzn-results"></ul></div>' ) ; this . choice_temp = new Template ( '<li class="search-choice" id="#{id}"><span>#{choice}</span><a href="javascript:void(0)" class="search-choice-close" rel="#{position}"></a></li>' ) ; this . no_results_temp = new Template ( '<li class="no-results">#{text} "<span>#{terms}</span>"</li>' ) ; this . new_option_temp = new Template ( '<option value="#{value}">#{text}</option>' ) ; return this . create_option_temp = new Template ( '<li class="create-option"><a href="javascript:void(0);">#{text}</a>: #{terms}</li>' ) ; }
function extendNodeListPrototype ( nodeList_proto ) { nodeList_proto = nodeList_proto . __proto__ || nodeList_proto . constructor . prototype ; if ( nodeListProto && nodeListProto !== Array . prototype ) { nodeList_methods_fromArray . forEach ( function ( key ) { if ( ! nodeListProto [ key ] ) nodeListProto [ key ] = Array . prototype [ key ] ; } ) } }
function ( e ) { var delta = e . data ; if ( this . id && delta . id == this . id ) { if ( delta . action == 'set' ) this . data = delta . item ; else if ( delta . action == 'delete' ) this . destroy ( ) ; } }
function ( data ) { var mappedData = Model . mapItem . call ( this , data ) ; this . fire ( 'datachange' , { action : 'set' , id : mappedData [ this . getKey ( ) ] , item : mappedData } ) ; success . call ( context , new this ( mappedData ) ) ; }
function ( ) { heap . remove ( 88 ) ; }
function loadClusters ( ) { clusters_s = localStorage . getItem ( 'clusters' ) ; if ( clusters_s ) { clusters = JSON . parse ( clusters_s ) ; showClusters ( clusters ) ; } else { setLoadingStatus ( ) ; $ . ajax ( { 'url' : 'http://api.graphmuse.com:8081/clusters?auth=AAAB01zpxDDcBAGZAl5GXrPqqepF0ZAdzs7CysuZAkj6pK2LH96vh8MLnUT0CVrGq2hI8IfXUIYwcrxGG0zzEu0ez2O4z6GbtWEfq08CQAZDZD&beta=0.75' , 'dataType' : 'JSON' , 'success' : onClustersReceive , 'error' : graphMuseError } ) ; } }
function createFriendList ( ) { var id = current_cluster_id ; var name = $ ( '#cluster-name' ) . val ( ) ; var data = new Array ( ) ; data [ 'name' ] = name ; data [ 'members' ] = clusters [ id ] . members ; $ . ajax ( { 'type' : 'POST' , 'url' : '/generatefriendlist/' , 'dataType' : 'JSON' , 'data' : data , 'success' : onCreatedFriendList , 'error' : createFriendListError } ) ; }
function displayError ( message ) { alert ( "Error: " + message ) ; }
function ( obj ) { obj . setSerializer ( 'json' ) ; var toPack = { 'key' : obj . key ( ) , 'value' : obj . value ( ) , 'meta' : { 'createdAt' : obj . createdAt ( ) , 'expiresAt' : obj . expiresAt ( ) , 'earlyExpiresAt' : obj . earlyExpiresAt ( ) , 'serializer' : 'json' , } , } ; console . log ( 'toPack' , toPack ) ; return JSON . stringify ( toPack ) ; }
function uchi ( opts ) { opts = opts || { } ; if ( ! opts . driver ) { throw 'Supply a driver' ; } if ( ! opts . serializer ) { throw 'Supply a serializer name' ; } if ( ! serializers [ opts . serializer ] ) { throw 'Unknown serializer name' ; } return new driver [ opts . driver ] ( opts ) ; }
function ( err , user ) { t . ok ( ! err , 'No error when getting a key' ) ; t . equal ( user . username , 'chilts' , 'Username is set on the returned key' ) ; t . equal ( user . password , 'sekrit' , 'Password is set on the returned key' ) ; t . equal ( user . inserted , timestamp . toISOString ( ) , 'Inserted is set on the returned key' ) ; t . end ( ) ; }
function ( array , tpl ) { var itemtpl = Ext . create ( 'Ext.XTemplate' , tpl ) ; var items = [ ] ; Ext . Array . each ( array , function ( item ) { items . push ( itemtpl . apply ( item ) ) ; } , this ) ; return '{' + items . join ( ', ' ) + '}' ; }
function ( e ) { resetShareModal ( ) ; addToShareList ( $ ( this ) . closest ( '.item' ) ) ; $ ( '#modal-share' ) . modal ( { } ) }
function ( e ) { clearTimeout ( inputThrottle ) ; testValidity ( e . target ) ; }
function ( ) { if ( $ ( this ) . text ( ) . match ( matcher ) ) { this . selected = valid = true ; return false ; } }
function ( layout ) { if ( ! this . cell ) return ; if ( this . set_hidden != this . df . hidden ) { if ( this . df . hidden ) this . cell . hide ( ) ; else this . cell . show ( ) ; this . set_hidden = this . df . hidden ; } }
function ( from_form ) { if ( this . df . hidden ) { if ( this . row ) this . row . hide ( ) ; } else { if ( this . collapsible ) { } } }
function ( err , result ) { if ( err ) { socket . emit ( 'error' , { err : err . err } ) ; } else { socket . emit ( 'init' , { result : result . slice ( 0 , 10 ) } ) ; } }
function ( id , duration ) { if ( duration == undefined ) duration = 10000 ; var element = $ ( ".turtle#" + id ) ; if ( element . length != 0 ) { var parent = element . parent ( ) ; Switcher . to ( id ) ; Magnify . group ( parent . attr ( "id" ) , duration ) ; } }
function ( data ) { $ . cookie ( 'oauth-token' , data . token ) ; window . authenticated = true ; var regex = new RegExp ( "\\?code=" + match [ 1 ] ) ; window . location . href = window . location . href . replace ( regex , '' ) ; }
function ( codeConstruct ) { try { var properties = this . properties ; for ( var i = 0 , length = properties . length ; i < length ; i ++ ) { var property = properties [ i ] ; this . globalObject . browser . callDataDependencyEstablishedCallbacks ( codeConstruct , property . lastModificationConstruct . codeConstruct , this . globalObject . getPreciseEvaluationPositionId ( ) , property . lastModificationConstruct . evaluationPositionId ) ; } } catch ( e ) { alert ( "Array - Error when registering getPropertyCallback: " + e ) ; } }
function ( evt ) { var pointView = this . getPointViewUnderMouse ( this . parentView . dataHolder , evt ) || null ; if ( ! pointView || pointView === undefined ) { this . _pointView = null ; return ; } this . _pointView = pointView ; pointView . mouseDown ( ) ; }
function ( evt ) { var pointView = this . getPointViewUnderMouse ( this . parentView . dataHolder , evt ) || null ; if ( ! pointView || pointView === undefined ) { if ( this . _pointView ) { this . _pointView . mouseExited ( ) ; this . _pointView = null ; } } else { pointView . mouseEntered ( ) ; } }
function ( thingBeingValidated ) { var obj = { } ; for ( i = 0 ; i < validatorFunctions . length ; ++ i ) { if ( validatorFunctions [ i ] . validator . call ( obj , thingBeingValidated ) === false ) { if ( obj . message !== undefined ) { errorMessage = obj . message ; } return false ; } } return true ; }
function ( ) { var result = ( this instanceof AttrList ) ? new AttrList ( name ) : new Attr ( name ) , i ; for ( i = 0 ; i < validatorFunctions . length ; ++ i ) { result . validatesWith ( validatorFunctions [ i ] . validator ) ; } result . errorsWith ( errorMessage ) . defaultsTo ( defaultValueOrFunction ) ; if ( immutable ) { result . isImmutable ( ) ; } return result ; }
function ( name , v ) { if ( name === undefined || typeof ( name ) !== "string" ) { throw new Error ( "addValidator requires a name to be specified as the first parameter" ) ; } if ( v === undefined || typeof ( v ) !== "function" ) { throw new Error ( "addValidator requires a function as the second parameter" ) ; } if ( validators [ name ] === undefined ) { validators [ name ] = v ; } else { throw new Error ( "Validator '" + name + "' already defined" ) ; } }
function ( ns ) { "use strict" ; var that = this , Validator , validators , addDefaultValidator ; Validator = function ( spec ) { var validatorFunction = function ( arg ) { var result , resultObject = { } , errorMessage ; result = spec . call ( resultObject , arg ) ; if ( ! result ) { errorMessage = resultObject . message || "validator failed with parameter " + arg ; throw new Error ( errorMessage ) ; } return result ; } return validatorFunction ; } ; ns . Validator = Validator ; }
function ( e ) { Utils . debug ( "Recieved a drop event " ) ; if ( e . stopPropagation ) { e . stopPropagation ( ) ; } if ( window . appView . insertUnicodeView . dragSrcEl != this ) { e . target . value = e . target . value + window . appView . insertUnicodeView . dragSrcEl . innerHTML ; } return false ; }
function ( e ) { this . classList . add ( "halfopacity" ) ; window . appView . insertUnicodeView . dragSrcEl = this ; e . dataTransfer . effectAllowed = 'move' ; e . dataTransfer . setData ( 'text/html' , this . innerHTML ) ; }
function ( req , res , next ) { if ( req . article . user . id != req . session . auth . userId ) { req . flash ( 'notice' , 'You are not authorized' ) ; res . redirect ( '/article/' + req . article . id ) ; } next ( ) }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( time1 ) { var sign = 1 ; var r = this . _rate ; if ( r % 2 == 0 ) { sign = - 1 ; } time1 *= 2 ; if ( time1 < 1 ) { this . _other . update ( 0.5 * Math . pow ( time1 , this . _rate ) ) ; } else { this . _other . update ( sign * 0.5 * ( Math . pow ( time1 - 2 , this . _rate ) + sign * 2 ) ) ; } }
function ( dt ) { if ( this . _firstTick ) { this . _firstTick = false ; this . _elapsed = 0 ; } else { this . _elapsed += dt ; } this . update ( ( 1 > ( this . _elapsed / this . _duration ) ) ? this . _elapsed / this . _duration : 1 ) ; }
function ( tempArray ) { var paraArray = ( typeof tempArray == "Array" ) ? tempArray : arguments ; var prev = paraArray [ 0 ] ; for ( var i = 1 ; i < paraArray . length ; i ++ ) { if ( paraArray [ i ] != null ) { prev = cc . Sequence . _actionOneTwo ( prev , paraArray [ i ] ) ; } } return prev ; }
function ( action , times ) { var d = action . getDuration ( ) * times ; if ( this . initWithDuration ( d ) ) { this . _times = times ; this . _innerAction = action ; this . _total = 0 ; return true ; } return false ; }
function ( target ) { this . _total = 0 ; this . _super ( target ) ; this . _innerAction . startWithTarget ( target ) ; }
function ( dt ) { this . _innerAction . step ( dt ) ; if ( this . _innerAction . isDone ( ) ) { var diff = dt + this . _innerAction . getDuration ( ) - this . _innerAction . getElapsed ( ) ; this . _innerAction . startWithTarget ( this . _target ) ; this . _innerAction . step ( diff ) ; } }
function ( tempArray ) { var paramArray = ( typeof tempArray == "Array" ) ? tempArray : arguments ; var prev = paramArray [ 0 ] ; for ( var i = 1 ; i < paramArray . length ; i ++ ) { if ( paramArray [ i ] != null ) { prev = this . _actionOneTwo ( prev , paramArray [ i ] ) ; } } return prev ; }
function ( t , sx , sy ) { var ret = false ; if ( this . _super ( t ) ) { this . _endSkewX = sx ; this . _endSkewY = sy ; ret = true ; } return ret ; }
function ( t , deltaSkewX , deltaSkewY ) { var ret = false ; if ( this . _super ( t , deltaSkewX , deltaSkewY ) ) { this . _skewX = deltaSkewX ; this . _skewY = deltaSkewY ; ret = true ; } return ret ; }
function ( target ) { this . _super ( target ) ; this . _deltaX = this . _skewX ; this . _deltaY = this . _skewY ; this . _endSkewX = this . _startSkewX + this . _deltaX ; this . _endSkewY = this . _startSkewY + this . _deltaY ; }
function ( duration , position , height , jumps ) { if ( this . _super ( duration ) ) { this . _delta = position ; this . _height = height ; this . _jumps = jumps ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; this . _delta = cc . ccp ( this . _delta . x - this . _startPosition . x , this . _delta . y - this . _startPosition . y ) ; }
function ( target ) { this . _super ( target ) ; this . _config . controlPoint_1 = cc . ccpSub ( this . _config . controlPoint_1 , this . _startPosition ) ; this . _config . controlPoint_2 = cc . ccpSub ( this . _config . controlPoint_2 , this . _startPosition ) ; this . _config . endPosition = cc . ccpSub ( this . _config . endPosition , this . _startPosition ) ; }
function ( duration , sx , sy ) { if ( this . _super ( duration ) ) { this . _endScaleX = sx ; this . _endScaleY = ( sy != null ) ? sy : sx ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; this . _startScaleX = target . getScaleX ( ) ; this . _startScaleY = target . getScaleY ( ) ; this . _deltaX = this . _endScaleX - this . _startScaleX ; this . _deltaY = this . _endScaleY - this . _startScaleY ; }
function ( target ) { this . _super ( target ) ; this . _deltaX = this . _startScaleX * this . _endScaleX - this . _startScaleX ; this . _deltaY = this . _startScaleY * this . _endScaleY - this . _startScaleY ; }
function ( time ) { if ( this . _target && ! this . isDone ( ) ) { var slice = 1.0 / this . _times ; var m = time % slice ; this . _target . setIsVisible ( m > slice / 2 ? true : false ) ; } }
function ( duration , red , green , blue ) { if ( this . _super ( duration ) ) { this . _to = cc . ccc3 ( red , green , blue ) ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; var color = target . getColor ( ) ; this . _fromR = color . r ; this . _fromG = color . g ; this . _fromB = color . b ; }
function ( action ) { cc . Assert ( action != null , "" ) ; cc . Assert ( action != this . _other , "" ) ; if ( this . _super ( action . getDuration ( ) ) ) { this . _other = action ; return true ; } return false ; }
function ( ) { var animate = new cc . Animate ( ) ; if ( arguments . length == 3 ) { animate . initWithDuration ( arguments [ 0 ] , arguments [ 1 ] , arguments [ 2 ] ) ; } else { animate . initWithAnimation ( arguments [ 0 ] , arguments [ 1 ] ) ; } return animate ; }
function ( ctx ) { this . _super ( ) ; if ( cc . renderContextType == cc . CANVAS ) { } else { var newBlend = this . _blendFunc . src != cc . BLEND_SRC || this . _blendFunc . dst != cc . BLEND_DST ; if ( newBlend ) { } this . _textureAtlas . drawNumberOfQuads ( this . _quadsToDraw , 0 ) ; if ( newBlend ) { } } }
function ( ) { var s = this . _textureAtlas . getTexture ( ) ; this . _itemsPerColumn = parseInt ( s . height / this . _itemHeight ) ; this . _itemsPerRow = parseInt ( s . width / this . _itemWidth ) ; }
function ( newPosition ) { this . _position = newPosition ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { this . _positionInPixels = this . _position ; } else { this . _positionInPixels = cc . ccpMult ( newPosition , cc . CONTENT_SCALE_FACTOR ( ) ) ; } this . setNodeDirty ( ) ; }
function ( point ) { if ( ! cc . Point . CCPointEqualToPoint ( point , this . _anchorPoint ) ) { this . _anchorPoint = point ; this . _anchorPointInPixels = new cc . Point ( this . _contentSizeInPixels . width * this . _anchorPoint . x , this . _contentSizeInPixels . height * this . _anchorPoint . y ) ; this . setNodeDirty ( ) ; } }
function ( aTag ) { cc . Assert ( aTag != cc . CCNODE_TAG_INVALID , "Invalid tag" ) ; if ( this . _children != null ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var node = this . _children [ i ] ; if ( node && node . _tag == aTag ) { return node ; } } } return null ; }
function ( cleanup ) { if ( this . _children != null ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var node = this . _children [ i ] ; if ( node ) { if ( this . _isRunning ) { node . onExit ( ) ; } if ( cleanup ) { node . cleanup ( ) ; } node . setParent ( null ) ; } } this . _children = [ ] ; } }
function ( child , doCleanup ) { if ( this . _isRunning ) { child . onExit ( ) ; } if ( doCleanup ) { child . cleanup ( ) ; } child . setParent ( null ) ; cc . ArrayRemoveObject ( this . _children , child ) ; }
function ( selector , interval ) { if ( ! interval ) interval = 0 ; cc . Assert ( selector , "Argument must be non-nil" ) ; cc . Assert ( interval >= 0 , "Argument must be positive" ) ; cc . Scheduler . sharedScheduler ( ) . scheduleSelector ( selector , this , interval , ! this . _isRunning ) ; }
function ( worldPoint ) { var ret = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { ret = cc . PointApplyAffineTransform ( worldPoint , this . worldToNodeTransform ( ) ) ; } else { ret = cc . ccpMult ( worldPoint , cc . CONTENT_SCALE_FACTOR ( ) ) ; ret = cc . PointApplyAffineTransform ( ret , this . worldToNodeTransform ( ) ) ; ret = cc . ccpMult ( ret , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } return ret ; }
function ( nodePoint ) { var ret = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { ret = cc . PointApplyAffineTransform ( nodePoint , this . nodeToWorldTransform ( ) ) ; } else { ret = cc . ccpMult ( nodePoint , cc . CONTENT_SCALE_FACTOR ( ) ) ; ret = cc . PointApplyAffineTransform ( ret , this . nodeToWorldTransform ( ) ) ; ret = cc . ccpMult ( ret , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } return ret ; }
function ( worldPoint ) { var nodePoint = this . convertToNodeSpace ( worldPoint ) ; var anchorInPoints = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { anchorInPoints = this . _anchorPointInPixels ; } else { anchorInPoints = cc . ccpMult ( this . _anchorPointInPixels , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } return cc . ccpSub ( nodePoint , anchorInPoints ) ; }
function ( nodePoint ) { var anchorInPoints = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { anchorInPoints = this . _anchorPointInPixels ; } else { anchorInPoints = cc . ccpMult ( this . _anchorPointInPixels , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } var pt = new cc . Point ( ) ; pt = cc . ccpAdd ( nodePoint , anchorInPoints ) ; return this . convertToWorldSpace ( pt ) ; }
function ( charID , rect , xOffset , yOffset , xAdvance ) { this . charID = charID || 0 ; this . rect = rect || new cc . RectMake ( 0 , 0 , 10 , 10 ) ; this . xOffset = xOffset || 0 ; this . yOffset = yOffset || 0 ; this . xAdvance = xAdvance || 0 ; }
function ( ) { this . _super ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . _isRelativeAnchorPoint = false ; var director = cc . Director . sharedDirector ( ) ; if ( ! director ) { return false ; } this . setContentSize ( director . getWinSize ( ) ) ; this . _isTouchEnabled = false ; this . _isAccelerometerEnabled = false ; }
function ( enabled ) { if ( this . _isTouchEnabled != enabled ) { this . _isTouchEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { this . registerWithTouchDispatcher ( ) ; } else { cc . TouchDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } } } }
function ( enabled ) { if ( enabled != this . _isAccelerometerEnabled ) { this . _isAccelerometerEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( this ) ; } else { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( null ) ; } } } }
function ( enabled ) { if ( enabled != this . _isKeypadEnabled ) { this . _isKeypadEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . addDelegate ( this ) ; } else { cc . KeypadDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } } } }
function ( ) { if ( this . _isTouchEnabled ) { this . registerWithTouchDispatcher ( ) ; } this . _super ( ) ; if ( this . _isAccelerometerEnabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( this ) ; } if ( this . _isKeypadEnabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . addDelegate ( this ) ; } }
function ( ) { if ( this . _isTouchEnabled ) { cc . TouchDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } if ( this . _isAccelerometerEnabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( null ) ; } if ( this . _isKeypadEnabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } this . _super ( ) ; }
function ( size ) { this . _squareVertices [ 1 ] . x = size . width * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 2 ] . y = size . height * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 3 ] . x = size . width * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 3 ] . y = size . height * cc . CONTENT_SCALE_FACTOR ( ) ; this . _super ( size ) ; }
function ( dt ) { this . unschedule ( this . _setNewScene ) ; var director = cc . Director . sharedDirector ( ) ; this . _isSendCleanupToScene = director . isSendCleanupToScene ( ) ; director . replaceScene ( this . _inScene ) ; cc . TouchDispatcher . sharedDispatcher ( ) . setDispatchEvents ( true ) ; this . _outScene . setIsVisible ( true ) ; }
function ( label , target , selector ) { var ret = new cc . MenuItemLabel ( ) ; if ( arguments . length == 3 ) { ret . initWithLabel ( label , target , selector ) ; } else { ret . initWithLabel ( label ) ; } return ret ; }
function ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) { cc . Assert ( value != null && value . length != 0 , "value length must be greater than 0" ) ; var label = new cc . LabelAtlas ( ) ; label . initWithString ( value , charMapFile , itemWidth , itemHeight , startCharMap ) ; this . initWithLabel ( label , target , selector ) ; return true ; }
function ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) { var ret = new cc . MenuItemAtlasFont ( ) ; ret . initFromString ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) ; return ret ; }
function ( NormalImage ) { if ( NormalImage ) { this . addChild ( NormalImage , 0 , cc . NORMAL_TAG ) ; NormalImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; NormalImage . setIsVisible ( true ) ; } if ( this . _normalImage ) { this . removeChild ( this . _normalImage , true ) ; } this . _normalImage = NormalImage ; }
function ( DisabledImage ) { if ( DisabledImage ) { this . addChild ( DisabledImage , 0 , cc . DISABLE_TAG ) ; DisabledImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; DisabledImage . setIsVisible ( false ) ; } if ( this . _disabledImage ) { this . removeChild ( this . _disabledImage , true ) ; } this . _disabledImage = DisabledImage ; }
function ( normalSprite , selectedSprite , disabledSprite , target , selector ) { cc . Assert ( normalSprite != null , "" ) ; this . initWithTarget ( target , selector ) ; this . setNormalImage ( normalSprite ) ; this . setSelectedImage ( selectedSprite ) ; this . setDisabledImage ( disabledSprite ) ; this . setContentSize ( this . _normalImage . getContentSize ( ) ) ; return true ; }
function ( ) { this . _super ( ) ; if ( this . _disabledImage ) { this . _disabledImage . setIsVisible ( false ) ; } if ( this . _selectedImage ) { this . _normalImage . setIsVisible ( false ) ; this . _selectedImage . setIsVisible ( true ) ; } else { this . _normalImage . setIsVisible ( true ) ; } }
function ( ) { this . _super ( ) ; this . _normalImage . setIsVisible ( true ) ; if ( this . _selectedImage ) { this . _selectedImage . setIsVisible ( false ) ; } if ( this . _disabledImage ) { this . _disabledImage . setIsVisible ( false ) ; } }
function ( enabled ) { this . _super ( enabled ) ; if ( this . _subItems && this . _subItems . length > 0 ) { for ( var it = 0 ; it < this . _subItems . length ; it ++ ) { this . _subItems [ it ] . setIsEnabled ( enabled ) ; } } }
function ( args ) { this . dom . id = "DomMenu" + Date . now ( ) ; this . dom . className += " domMenu" ; this . _isRelativeAnchorPoint = false ; this . setContentSize ( cc . Director . sharedDirector ( ) . getWinSize ( ) ) ; for ( var i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] ) { this . addChild ( args [ i ] ) ; } } }
function ( fileName ) { return this . initWithTexture ( cc . TextureCache . sharedTextureCache ( ) . addImage ( fileName ) ) ; }
function ( texture ) { this . _texture = texture ; if ( ( texture instanceof HTMLImageElement ) || ( texture instanceof HTMLCanvasElement ) ) { } else { if ( this . _texture && ! this . _texture . getHasPremultipliedAlpha ( ) && ( this . _blendFunc . src == cc . BLEND_SRC && this . _blendFunc . dst == cc . BLEND_DST ) ) { this . _blendFunc . src = GL_SRC_ALPHA ; this . _blendFunc . dst = GL_ONE_MINUS_SRC_ALPHA ; } } }
function ( isBlendAdditive ) { this . _isBlendAdditive = isBlendAdditive ; return ; if ( isBlendAdditive ) { } else { if ( this . _texture && ! this . _texture . getHasPremultipliedAlpha ( ) ) { } else { this . _blendFunc . src = cc . BLEND_SRC ; this . _blendFunc . dst = cc . BLEND_DST ; } } }
function ( plistFile ) { var ret = false ; this . _plistFile = plistFile ; var dict = cc . FileUtils . dictionaryWithContentsOfFileThreadSafe ( this . _plistFile ) ; cc . Assert ( dict != null , "Particles: file not found" ) ; return this . initWithDictionary ( dict ) ; }
function ( ) { if ( cc . renderContextType == cc . CANVAS ) { } else { if ( cc . USES_VBO ) { glBindBuffer ( GL_ARRAY_BUFFER , quadsID ) ; glBufferSubData ( GL_ARRAY_BUFFER , 0 , sizeof ( quads [ 0 ] ) * particleCount , quads ) ; glBindBuffer ( GL_ARRAY_BUFFER , 0 ) ; } } }
function ( ) { var tmp = this . _winSizeInPoints ; if ( this . _deviceOrientation == cc . DEVICE_ORIENTATION_LANDSCAPE_LEFT || this . _deviceOrientation == cc . DEVICE_ORIENTATION_LANDSCAPE_RIGHT ) { var size = new cc . SizeZero ( ) ; size . width = tmp . height ; size . height = tmp . width ; return size ; } return tmp ; }
function ( cleanup ) { if ( this . _usesBatchNode ) { if ( this . _children != null ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { if ( this . _children [ i ] instanceof cc . Sprite ) { this . _batchNode . removeSpriteFromAtlas ( this . _children [ i ] ) ; } } } } this . _super ( cleanup ) ; this . _hasChildren = false ; }
function ( value ) { this . _dirty = this . _recursiveDirty = value ; if ( this . _children != null ) { for ( var i in this . _children ) { if ( this . _children [ i ] instanceof cc . Sprite ) { this . _children [ i ] . setDirtyRecursively ( true ) ; } } } }
function ( newFrame ) { this . setNodeDirty ( ) ; this . _unflippedOffsetPositionFromCenter = newFrame . getOffsetInPixels ( ) ; var pNewTexture = newFrame . getTexture ( ) ; if ( pNewTexture != this . _texture ) { this . setTexture ( pNewTexture ) ; } this . _rectRotated = newFrame . isRotated ( ) ; if ( this . _rectRotated ) this . setRotation ( - 90 ) ; this . setTextureRectInPixels ( newFrame . getRectInPixels ( ) , newFrame . isRotated ( ) , newFrame . getOriginalSizeInPixels ( ) ) ; }
function ( animationName , frameIndex ) { cc . Assert ( animationName , "" ) ; var a = cc . AnimationCache . sharedAnimationCache ( ) . animationByName ( animationName ) ; cc . Assert ( a , "" ) ; var frame = a . getFrames ( ) [ frameIndex ] ; cc . Assert ( frame , "" ) ; this . setDisplayFrame ( frame ) ; }
function ( ) { if ( cc . renderContextType == cc . CANVAS ) { return cc . SpriteFrame . _frameWithTextureForCanvas ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSizeInPixels ) ; } else { return cc . SpriteFrame . create ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSizeInPixels ) ; } }
function ( spriteFrame ) { var sprite = new cc . Sprite ( ) ; if ( sprite && sprite . initWithSpriteFrame ( spriteFrame ) ) { return sprite ; } return null ; }
function ( fileImage ) { this . _super ( ) ; if ( fileImage ) { this . initWithFile ( fileImage , cc . DEFAULT_CAPACITY ) ; } this . setContentSize ( new cc . Size ( cc . canvas . width , cc . canvas . height ) ) ; this . _renderTexture = cc . RenderTexture . create ( cc . canvas . width , cc . canvas . height ) ; }
function ( child , zOrder ) { cc . Assert ( child != null , "SpriteBatchNode.addChild():the child should not be null" ) ; cc . Assert ( this . _children . indexOf ( child ) > - 1 , "SpriteBatchNode.addChild():sprite batch node should contain the child" ) ; if ( zOrder == child . getZOrder ( ) ) { return ; } this . removeChild ( child , false ) ; this . addChild ( child , zOrder ) ; this . setNodeDirty ( ) ; }
function ( cleanup ) { if ( this . _children && this . _children . length > 0 ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var obj = this . _children [ i ] ; if ( obj ) { this . removeSpriteFromAtlas ( obj ) ; } } } this . _super ( cleanup ) ; this . _descendants = [ ] ; this . _textureAtlas . removeAllQuads ( ) ; }
function ( target , selector , seconds ) { if ( arguments < 2 ) throw new Error ( "timerWithTarget'argument can't is null" ) ; var timer = new cc . Timer ( ) ; if ( arguments . length == 2 ) { timer . initWithTarget ( target , selector , 0 ) ; } else { timer . initWithTarget ( target , selector , seconds ) ; } return timer ; }
function ( followedNode , rect ) { var ret = new cc . Follow ( ) ; if ( rect != null && ret && ret . initWithTarget ( followedNode , rect ) ) { return ret ; } else if ( ret && ret . initWithTarget ( followedNode ) ) { return ret ; } return null ; }
function ( ) { fn . executed = true ; fn . args = arguments ; for ( var i = 0 , l = arguments . length ; i < l ; i ++ ) { if ( typeof arguments [ i ] === 'function' ) return arguments [ i ] ( returnValue ) ; } return returnValue ; }
function ( ) { setupTests . bind ( this ) . call ( ) var getUserApiResponses = ApiResponse [ '/account/verify_credentials' ] ; this . instapaperClient . _makeRequest = stubFn ( null , getUserApiResponses . success ) ; this . errorClient . _makeRequest = stubFn ( getUserApiResponses . error ) ; }
function ( ) { client . _makeRequest . executed . should . be . true ; client . _makeRequest . args [ 0 ] . should . equal ( BASE_URL + '/account/verify_credentials' ) ; client . _makeRequest . args [ 1 ] . should . be . a ( 'function' ) ; done ( ) ; }
function _fire ( event , $this ) { var $self = $this . data ( 'eventStack' ) . target ; var proceed = $self . triggerHandler ( 'beforeTrigger.eventStack' , event ) ; if ( proceed === false ) { return ; } ( event . trigger ) ( event , $this ) ; $self . triggerHandler ( 'afterTrigger.eventStack' , event ) ; }
function _complete ( event , $self ) { var runningEvents = $self . data ( 'eventStack' ) . runningEvents ; if ( event . status !== 'running' ) { throw 'EventStack: Unable to complete an event that is not running.' ; } event . status = 'ready' ; var pos = $ . inArray ( event , runningEvents ) ; runningEvents . splice ( pos , 1 ) ; _continue ( $self ) ; }
function _continue ( $self ) { var runningEvents = $self . data ( 'eventStack' ) . runningEvents ; if ( $self . data ( 'eventStack' ) . status !== 'running' ) { return ; } _fireNext ( $self ) ; if ( runningEvents . length == 0 ) { $self . data ( 'eventStack' ) . status = 'stopped' ; $self . triggerHandler ( 'afterTriggerAll.eventStack' ) ; return ; } }
function ( ) { console . log ( 'C done' ) ; }
function ( ) { console . log ( $ ( '#EditForm' ) . data ( 'eventStack' ) . status ) ; $ ( '#EditForm' ) . eventStack ( 'pause' ) ; console . log ( $ ( '#EditForm' ) . data ( 'eventStack' ) . status ) ; $ ( '#EditForm' ) . eventStack ( 'resume' ) ; eventStack . eventStack ( 'complete' , event ) ; console . log ( $ ( '#EditForm' ) . data ( 'eventStack' ) . status ) ; }
function ( ) { var enabled ; try { document . cookie = "test=true; max-age=1" ; enabled = document . cookie . indexOf ( "test" ) > - 1 ; } catch ( e ) { enabled = false ; } if ( typeof Network . cookiesEnabledOverride === "boolean" ) { enabled = Network . cookiesEnabledOverride ; } complete ( onComplete , enabled ) ; }
function authenticateUser ( email , pass , callback ) { var self = this ; user . authenticate ( email , pass , function ( authenticated ) { if ( ! authenticated ) { tooltip . showTooltip ( "#cannot_authenticate" ) ; } complete ( callback , authenticated ) ; } , self . getErrorDialog ( errors . authenticate , callback ) ) ; }
function cancelAccount ( oncomplete ) { if ( confirmAction ( "Are you sure you want to cancel your BrowserID account?" ) ) { user . cancelUser ( function ( ) { doc . location = "/" ; oncomplete && oncomplete ( ) ; } , pageHelpers . getFailure ( errors . cancelUser , oncomplete ) ) ; } }
function ( ) { xhr . useResult ( "invalid" ) ; lib . authenticate ( TEST_EMAIL , "testuser" , function onComplete ( authenticated ) { equal ( false , authenticated , "invalid authentication." ) ; start ( ) ; } , testHelpers . unexpectedXHRFailure ) ; }
function ( authenticated ) { equal ( authenticated , false , "user is not authenticated" ) ; start ( ) ; }
function ( ) { testVisible ( "#congrats" ) ; testHasClass ( "body" , "complete" ) ; equal ( $ ( ".website" ) . text ( ) , returnTo , "website is updated" ) ; equal ( doc . location . href , returnTo , "redirection occurred to correct URL" ) ; equal ( storage . getLoggedIn ( "https://test.domain" ) , "testuser@testuser.com" , "logged in status set" ) ; start ( ) ; }
function ( req , res , next ) { metrics . userEntry ( req ) ; renderCachableView ( req , res , 'dialog.ejs' , { title : 'A Better Way to Sign In' , layout : 'dialog_layout.ejs' , useJavascript : true , production : config . get ( 'use_minified_resources' ) } ) ; }
function ( msgid ) { if ( window . json_locale_data && json_locale_data [ "client" ] ) { var dict = json_locale_data [ "client" ] ; if ( dict [ msgid ] && dict [ msgid ] . length >= 2 && dict [ msgid ] [ 1 ] . trim ( ) != "" ) { return dict [ msgid ] [ 1 ] ; } } return msgid ; }
function ( next ) { var self = this ; self . program . update = path . resolve ( self . program . update ) ; var exists = path . existsSync ( self . program . update ) ; if ( ! exists ) self . program . invalidOptionValue ( '-u, --update <path>' , 'Path does not exist! Cannot update.' ) ; self . deployDataAndPlugins ( product . basedir , self . program . update , true , self . program . symlink , next ) ; }
function ( dst , data , force ) { try { if ( path . existsSync ( dst ) && ! force ) throw filePath + " already exists" ; var fd = fs . openSync ( dst , 'w' ) ; fs . writeSync ( fd , data ) ; fs . close ( fd ) ; } catch ( e ) { return - 1 ; } return 0 ; }
function ( src , dst , force , symlink ) { if ( path . existsSync ( dst ) && ! force ) { return - 1 ; } if ( symlink ) { fs . symlinkSync ( src , dst , 'file' ) ; return 0 ; } var data = fs . readFileSync ( src ) ; return fs . writeFileSync ( dst , data ) ; }
function ( ) { if ( localStorage . length !== 0 ) { tBrack . repopulate ( ) ; } else { console . log ( 'localStorage is empty' ) ; } tBrack . addPlayer ( ) ; tBrack . removePlayer ( ) ; tBrack . formTricks ( ) ; tBrack . thePlayerList ( ) ; }
function ( ) { if ( node . onopen ) node . onopen ( ) ; }
function ( file ) { var type = mime . lookup ( file ) ; if ( type === 'application/javascript' ) { js . push ( file ) ; } else if ( type === 'text/css' ) { css . push ( file ) ; } }
function ( preserveCursor ) { if ( this . enabled ) { if ( ! preserveCursor ) this . cursor = 0 ; this . _refreshLine ( ) ; } else { this . output . write ( this . _prompt ) ; } }
function ( query , cb ) { if ( cb ) { this . resume ( ) ; if ( this . _questionCallback ) { this . output . write ( '\n' ) ; this . prompt ( ) ; } else { this . _oldPrompt = this . _prompt ; this . setPrompt ( query ) ; this . _questionCallback = cb ; this . output . write ( '\n' ) ; this . prompt ( ) ; } } }
function ( ) { if ( this . _closed ) return ; this . output . cursorTo ( 0 ) ; this . output . write ( this . _prompt ) ; this . output . write ( this . line ) ; this . output . clearLine ( 1 ) ; this . output . cursorTo ( this . _promptLength + this . cursor ) ; }
function ( ) { if ( sawSIGINT ) { rli . close ( ) ; process . exit ( ) ; } rli . line = '' ; if ( ! ( self . bufferedCommand && self . bufferedCommand . length > 0 ) && rli . line . length === 0 ) { rli . output . write ( '\n(^C again to quit)\n' ) ; sawSIGINT = true ; } else { rli . output . write ( '\n' ) ; } self . bufferedCommand = '' ; self . displayPrompt ( ) ; }
function ( result ) { if ( result ) { console . log ( 'ES generated ID is: ' + result ) ; } console . log ( 'Document added' ) ; }
function ( data , callback ) { var document ; if ( data . _id ) { document = mapping . document ( data . _id ) ; } else { document = mapping . document ( ) ; } document . set ( data . _source , function ( result ) { if ( result ) { console . log ( 'ES generated ID is: ' + result ) ; } console . log ( 'Document added' ) ; } ) ; }
function ( cardId , insertAfterCardId ) { var idx = 0 ; if ( insertAfterCardId ) { idx = cards . indexOf ( insertAfterCardId ) + 1 ; } cards . splice ( idx , 0 , cardId ) ; group . trigger ( "CardAdded" , cardId ) ; }
function ( draggedId , droppedOnId ) { var group = findGroup ( droppedOnId ) ; group . addCard ( draggedId ) ; game . selectGroup ( droppedOnId ) ; }
function ( draggedCardId , droppedOnCardId ) { var group = findGroupContainingCard ( droppedOnCardId ) ; group . addCard ( draggedCardId , droppedOnCardId ) ; game . selectGroup ( group . groupId ) ; }
function ( state , callback , args ) { var subChain ; if ( arguments . length === 3 ) { return this . position . call ( callback , args , state ) . end ( ) ; } else { subChain = this . position ; subChain . _readyState = state ; return subChain ; } }
function ( result ) { if ( result . status == 0 ) { self . moveTo ( result . value . ELEMENT , function ( result ) { self . buttonDown ( function ( ) { self . buttonUp ( function ( ) { if ( typeof callback === "function" ) { callback ( ) ; } } ) } ) } ) ; } else { if ( typeof callback === "function" ) { callback ( result ) ; } } }
function ( result ) { if ( result . status == 0 ) { self . doDoubleClick ( function ( result ) { if ( typeof callback === "function" ) { callback ( ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result ) ; } } }
function ( cssSelector , callback ) { var self = this ; self . moveToObject ( cssSelector ) ; self . element ( "css selector" , cssSelector , function ( result ) { if ( result . status == 0 ) { self . doDoubleClick ( function ( result ) { if ( typeof callback === "function" ) { callback ( ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result ) ; } } } ) ; }
function ( result ) { if ( result . status == 0 ) { self . elementIdValue ( result . value . ELEMENT , function ( result ) { if ( typeof callback === "function" ) { callback ( result . value ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result . value ) ; } } }
function ( err , result ) { if ( err && typeof callback == 'function' ) return callback ( err ) ; if ( typeof callback == "function" && result . value == false ) { return callback ( new Error ( 'Element ' + cssSelector + ' not selected' ) ) ; } if ( typeof callback === "function" ) { callback ( null , result . value ) ; } }
function ( cssSelector , callback ) { var self = this ; self . element ( "css selector" , cssSelector , function ( result ) { if ( result . status == 0 ) { self . moveTo ( result . value . ELEMENT , function ( result ) { if ( typeof callback === "function" ) { callback ( ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result ) ; } } } ) ; }
function ( cssSelector , value , callback ) { var self = this ; self . element ( "css selector" , cssSelector , function ( result ) { if ( result . status == 0 ) { self . elementIdValue ( result . value . ELEMENT , value , function ( result ) { if ( typeof callback === "function" ) { callback ( result ) ; } } ) ; } else { if ( typeof callback === "function" ) { callback ( result ) ; } } } ) ; }
function ( data ) { for ( attribute in this ) { if ( typeof this [ attribute ] != 'function' && attribute != 'skinCoordinates' && attribute != 'animationList' && this . checkFieldValidity ( attribute ) ) { eval ( 'this.' + attribute + '=data[attribute]' ) ; } } }
function ( ) { var returnObject = { } ; for ( attribute in this ) { if ( typeof this [ attribute ] != 'function' && this . checkFieldValidity ( attribute ) ) { eval ( 'returnObject.' + attribute + '=this[attribute]' ) ; } } return returnObject ; }
function getUpdatedReadingList ( originalReadingListItems , updatedReadingListItems ) { return [ ] . concat . apply ( [ ] , [ originalReadingListItems , updatedReadingListItems ] ) ; }
function index ( req , res ) { s . getSharedViewModel ( 'about' , function gotSharedViewModel ( err , sharedModel ) { res . render ( 'about' , { shared : sharedModel , title : 'About rarely updated' } ) ; } ) ; }
function ( ) { var total = 0 ; var kills = 0 ; for ( var i = 0 ; i < gco . level ; i ++ ) { total += this . objectives [ i ] ; kills += this . progress [ i ] ; } return ( kills / total ) ; }
function ( ) { missiles = [ ] ; enemies = [ ] ; explosions = [ ] ; money = [ ] ; randomItems = [ ] ; totalDestroys = 0 ; destroys = 0 ; player . life = 100 ; player . shield = 100 ; player . recharge = true ; totalShots = 0 ; player = new Player ( 24 , 40 ) ; gco . bgm . pause ( ) ; gco = new GameControlObject ( ) ; gco . Init ( ) ; }
function getExamplePage ( filePath ) { name = path . basename ( filePath ) ; htmlPath = path . join ( filePath , name + '.html' ) ; if ( path . existsSync ( htmlPath ) ) { return fs . readFileSync ( htmlPath ) ; } else { return false ; } }
function ( name ) { if ( path . existsSync ( path . join ( filePath , name , name + '.js' ) ) ) { result . push ( name ) ; } else if ( fs . statSync ( path . join ( filePath , name ) ) . isDirectory ( ) ) { result = result . concat ( listExamples ( path . join ( filePath , name ) ) . map ( function ( subname ) { return path . join ( name , subname ) ; } ) ) ; } }
function ( silent ) { if ( this . dom . field && this . fieldEditable ) { this . fieldHTML = this . dom . field . innerHTML ; } if ( this . fieldHTML != undefined ) { try { this . field = this . _unescape ( this . _stripHTML ( this . fieldHTML ) ) ; } catch ( err ) { this . field = undefined ; if ( silent != true ) { throw err ; } } } }
function _getKeySizeFromYBitlength ( size ) { for ( keysize in KEYSIZES ) { var keysize_nbits = KEYSIZES [ keysize ] . p . bitLength ( ) ; var diff = keysize_nbits - size ; if ( diff >= 0 && diff < 30 ) { return keysize ; } } return null ; }
function ( y , keysize ) { this . y = y ; this . keysize = keysize ; }
function ( other ) { if ( other == null ) return false ; return ( ( this . keysize == other . keysize ) && ( this . y . equals ( other . y ) ) ) ; }
function ( obj ) { this . y = new BigInteger ( obj . y , 16 ) ; this . keysize = keysizeFromObject ( obj ) ; return this ; }
function ( obj ) { this . x = new BigInteger ( obj . x , 16 ) ; this . keysize = keysizeFromObject ( obj ) ; var params = getParams ( keysize ) ; this . y = params . g . modPow ( this . x , params . p ) ; return this ; }
function ( obj ) { this . rsa = new libs . RSAKey ( ) ; this . rsa . n = new libs . BigInteger ( obj . n , 10 ) ; this . rsa . e = new libs . BigInteger ( obj . e , 10 ) ; this . keysize = _getKeySizeFromRSAKeySize ( this . rsa . n . bitLength ( ) ) ; return this ; }
function ( obj ) { this . rsa = new libs . RSAKey ( ) ; this . rsa . n = new BigInteger ( obj . n , 10 ) ; this . rsa . e = new BigInteger ( obj . e , 10 ) ; this . rsa . d = new BigInteger ( obj . d , 10 ) ; this . keysize = _getKeySizeFromRSAKeySize ( this . rsa . n . bitLength ( ) ) ; return this ; }
function extractAssertionParamsFrom ( params ) { var assertionParams = { } ; assertionParams . issuedAt = utils . getDate ( params . iat ) ; assertionParams . expiresAt = utils . getDate ( params . exp ) ; assertionParams . issuer = params . iss ; assertionParams . audience = params . aud ; delete params . iat ; delete params . exp ; delete params . iss ; delete params . aud ; return assertionParams ; }
function ( err , payload , assertionParams ) { if ( err ) return cb ( err ) ; var publicKey = jwcrypto . loadPublicKey ( JSON . stringify ( payload [ 'public-key' ] ) ) ; delete payload [ 'public-key' ] ; var principal = payload . principal ; delete payload . principal ; cb ( err , payload , assertionParams , { principal : principal , 'public-key' : publicKey } ) ; }
function ( err , payload , assertionParams , certParams ) { if ( err ) return cb ( err ) ; i += 1 ; certParamsArray . push ( { payload : payload , assertionParams : assertionParams , certParams : certParams } ) ; if ( i >= certs . length ) cb ( null , certParamsArray , certParams [ 'public-key' ] ) ; else delay ( verifyCert ) ( i , certParams [ 'public-key' ] , certParamsArray , cb ) ; }
function ( err , kp ) { keypair = kp ; var assertionParams = { issuer : "issuer.com" , issuedAt : new Date ( ) , expiresAt : new Date ( ( new Date ( ) ) . getTime ( ) + ( 6 * 60 * 60 * 1000 ) ) } ; cert . sign ( keypair . publicKey , { email : "john@issuer.com" } , assertionParams , null , keypair . secretKey , self . callback ) ; }
function ( err , signedIntermediate ) { cert . sign ( user_kp . publicKey , { email : "john@root.com" } , { issuer : "intermediate.root.com" , issuedAt : new Date ( ) , expiresAt : expiration } , null , intermediate_kp . secretKey , function ( err , signedUser ) { signAssertion ( root_kp . publicKey , [ signedIntermediate , signedUser ] , user_kp ) ; } ) ; }
function ( payload ) { var index = cache . attendees . indexOf ( cache . userID ) , error = payload . error ; if ( error . code == 104 ) { FB . login ( onLogin , { scope : permissions } ) ; } else if ( error . code == 100 ) { if ( index > - 1 ) { cache . attendees . splice ( index , 1 ) ; drawPictures ( ) ; } } }
function ( context , args ) { if ( ! cancelled && ! fired && ! firing ) { args = args || [ ] ; firing = 1 ; try { while ( callbacks [ 0 ] ) { callbacks . shift ( ) . apply ( context , args ) ; } } catch ( e ) { } finally { fired = [ context , args ] ; firing = 0 ; } } return this ; }
function ( ) { require ( Aloha . settings . requireConfig , [ 'vendor/jquery.json-2.2.min' , 'vendor/jquery.store' , 'aloha/rangy-core' , 'util/json2' , 'util/class' , 'util/lang' , 'util/range' , 'util/dom' , 'aloha/core' , 'aloha/editable' , 'aloha/console' , 'aloha/markup' , 'aloha/message' , 'aloha/plugin' , 'aloha/selection' , 'aloha/command' , 'aloha/jquery.patch' , 'aloha/jquery.aloha' , 'aloha/sidebar' , 'util/position' , 'aloha/ext-alohaproxy' , 'aloha/ext-alohareader' , 'aloha/ext-alohatreeloader' , 'aloha/ui' , 'aloha/ui-attributefield' , 'aloha/ui-browser' , 'aloha/floatingmenu' , 'aloha/repositorymanager' , 'aloha/repository' , 'aloha/repositoryobjects' , 'aloha/contenthandlermanager' ] , function ( ) { Aloha . jQuery ( Aloha . init ) ; } ) ; }
function ( asObject ) { var clonedObj = this . obj . clone ( false ) ; clonedObj . find ( '.aloha-cleanme' ) . remove ( ) ; this . removePlaceholder ( clonedObj ) ; PluginManager . makeClean ( clonedObj ) ; return asObject ? clonedObj . contents ( ) : clonedObj . html ( ) ; }
function ( err ) { if ( 'ECONNREFUSED' == err . errno ) { console . log ( 'client connect refused, restarting adb daemon...' ) ; DebugBridge . start_server ( function ( code ) { console . log ( 'start adb daemon: %d' , code ) ; if ( code == 0 ) { adb . connect ( callback ) ; } } ) ; } else { console . error ( 'client caught exception: ' + err ) ; } }
function ( version ) { console . log ( 'Android Debug Bridge version 1.0.%d' , version ) ; }
function ( child ) { return child . name ; }
function ( father ) { return father . children . then ( function ( children ) { console . log ( father . name + " has " + children . length + " children" ) ; if ( children . length ) { console . log ( "The children's names are " + children . map ( function ( child ) { return child . name ; } ) ) } } ) ; }
function ( content , options ) { if ( ! this . _popup || this . _popup . options !== options ) { this . _popup = new L . Popup ( options ) ; } this . _popup . setContent ( content ) ; if ( ! this . _openPopupAdded ) { this . on ( 'click' , this . _openPopup , this ) ; this . _openPopupAdded = true ; } return this ; }
function ( workerScriptfile ) { var self = this ; this . worker = new Worker ( new x3dom . BitLODWorker ( ) . toBlob ( ) ) ; this . worker . postMessage = this . worker . webkitPostMessage || this . worker . postMessage ; this . worker . addEventListener ( 'message' , function ( event ) { return self . messageFromWorker ( event ) ; } , false ) ; this . refinementCallback = { } ; this . useDebugOutput = false ; }
function clickRoom ( e ) { if ( cntrl ) return click ( e ) ; infoWindow . setContent ( '<a href="http://www.rcsa.co.uk/rooms#' + obj . id + '">' + obj . name + '</a>' ) ; infoWindow . setPosition ( e . latLng ) ; infoWindow . open ( map . map ) ; }
function ( target_uuid , user , objectType , title , body , timestamp ) { this . target_uuid = target_uuid ; this . user = user ; this . upvote = 0 ; this . downvote = 0 ; this . title = title ; this . body = body ; this . objectType = objectType ; this . timestamp = timestamp ; this . isAnswered = 'false' ; }
function ( uuid , user , title , body , category , timestamp ) { this . id = uuid ; this . user = user ; this . body = body ; this . category = category ; this . status = 'unanswered' ; this . title = title ; this . timestamp = timestamp ; this . followup = [ ] ; }
function ( func , args , ctor ) { ctor . prototype = func . prototype ; var child = new ctor , result = func . apply ( child , args ) ; return typeof result === "object" ? result : child ; } ) ( WebPool , [ name ] . concat ( __slice . call ( args ) ) , function ( ) { }
function ( func , args , ctor ) { ctor . prototype = func . prototype ; var child = new ctor , result = func . apply ( child , args ) ; return typeof result === "object" ? result : child ; } ) ( Pool , [ name ] . concat ( __slice . call ( args ) ) , function ( ) { }
function ( callback ) { if ( this . child ) { if ( callback ) this . child . once ( 'exit' , callback ) ; return this . child . kill ( 'SIGTERM' ) ; } else { return typeof callback === "function" ? callback ( ) : void 0 ; } }
function ( callback ) { if ( this . child ) { if ( callback ) this . child . once ( 'exit' , callback ) ; return this . child . kill ( 'SIGQUIT' ) ; } else { return typeof callback === "function" ? callback ( ) : void 0 ; } }
function ( func , args , ctor ) { ctor . prototype = func . prototype ; var child = new ctor , result = func . apply ( child , args ) ; return typeof result === "object" ? result : child ; } ) ( WebProcess , [ name ] . concat ( __slice . call ( args ) ) , function ( ) { }
function ( func , args , ctor ) { ctor . prototype = func . prototype ; var child = new ctor , result = func . apply ( child , args ) ; return typeof result === "object" ? result : child ; } ) ( Process , [ name ] . concat ( __slice . call ( args ) ) , function ( ) { }
function ( func , args , ctor ) { ctor . prototype = func . prototype ; var child = new ctor , result = func . apply ( child , args ) ; return typeof result === "object" ? result : child ; } ) ( Server , args , function ( ) { }
function show_screen ( screen ) { animate ( screen , [ { d : 0.0001 , s : 0.5 , opacity : 0.7 , 'z-index' : 10000 } , { d : 0.4 , s : 1 , opacity : 1 } ] , function ( ) { } ) ; }
function ( p ) { var v = params [ p ] ; if ( typeof v === 'string' ) { v = { type : v } ; } if ( typeof v . required === undefined ) v . required = true ; if ( ! types [ v . type ] ) throw "unknown type specified in WSAPI:" + v . type ; params [ p ] = v ; }
function ( p ) { if ( p . required && ! reqParams [ p ] ) throw "missing required parameter: '" + p + "'" ; if ( reqParams [ p ] === undefined ) return ; try { types [ params [ p ] . type ] ( reqParams [ p ] ) ; } catch ( e ) { throw p + ": " + e . toString ( ) ; } req . params [ p ] = reqParams [ p ] ; delete reqParams [ p ] ; }
function ( ) { var _this = this ; $ ( '#videoHolder' ) . height ( window . innerHeight - _this . getComponentsHeight ( ) ) ; }
function ( ) { var div = DOM . create ( "<div><span></span>1<span></span></div>" ) ; DOM . append ( div , "body" ) ; var cs = div . childNodes ; expect ( DOM . siblings ( cs [ 2 ] ) . length ) . toBe ( 2 ) ; expect ( DOM . siblings ( cs [ 2 ] , undefined , 1 ) . length ) . toBe ( cs . length ) ; DOM . remove ( div ) ; }
function ( ) { var t = DOM . get ( '#test-prev' ) ; expect ( DOM . siblings ( t ) . length ) . toBe ( 4 ) ; expect ( DOM . siblings ( t , '.test-none' ) . length ) . toBe ( 0 ) ; expect ( DOM . siblings ( t , function ( elem ) { return elem . className === 'test-next-p' ; } ) . length ) . toBe ( 1 ) ; }
function ( name , type , node ) { var t ; if ( node ) { t = this . variables [ name + "." ] ; if ( t && ( type === 'const' || type === 'function' ) || ( t === 'const' || t === 'function' ) ) { node . carp ( "redeclaration of read-only variable \"" + name + "\"" ) ; } if ( t === 'arg' || t === 'function' ) { return name ; } } this . variables [ name + "." ] = type ; return name ; }
function ( old_obj , old_idx ) { self . unset ( collection , old_obj . _id , _ . keys ( old_obj ) ) ; self . flush ( ) ; }
function ( from ) { while ( from > 0 && ( ! this . getBlock ( from ) || this . scrollPos ( ) < this . blockPosition ( from ) ) ) { from -= 1 ; } while ( this . scrollPos ( ) > this . blockPosition ( from ) + this . blockHeight ( ) ) { from += 1 ; } return from ; }
function ( e ) { if ( e . target . is ( 'input' ) ) return ; if ( _isNumericKey ( e . which ) ) { e . preventDefault ( ) ; _append ( $this , _getNumericValue ( e . which ) ) ; } else if ( e . which == 13 ) { e . preventDefault ( ) ; _complete ( $this ) ; } else { _clear ( $this ) ; } }
function ( e ) { options . errorDialog . removeClass ( 'in' ) ; $ . webSocket ( 'send' , { name : 'showQueue' , text : 'initialize: {"queueType": "shortQueue", "session": "' + options . session + '" }' } ) ; console . log ( $this . data ( 'payDesk' ) ) ; if ( $this . data ( 'payDesk' ) ) _setPayDesk ( $this , $this . data ( 'payDesk' ) ) ; }
function ( imageSource , format ) { var a = new osg . Texture ( ) ; if ( imageSource !== undefined ) { var img = new Image ( ) ; img . src = imageSource ; a . setImage ( img , format ) ; } return a ; }
function ( fileSystemModel , fileSystem , backendEntry ) { WebInspector . FileSystemModel . Entry . call ( this , fileSystemModel , fileSystem , backendEntry ) ; this . _mimeType = backendEntry . mimeType ; this . _resourceType = WebInspector . resourceTypes [ backendEntry . resourceType ] ; }
function ( url , start , end , callback ) { var store = this . _pendingFileContentRequests ; FileSystemAgent . requestFileContent ( url , start , end , requestAccepted ) ; function requestAccepted ( error , requestId ) { if ( ! error ) store [ requestId ] = callback ; } }
function ( Backbone , core , sandbox , srpsession , passwords , notes , applications ) { console . log ( 'Starting app' ) ; core . start ( applications ) ; core . start ( srpsession , './authentication' ) ; core . broadcast ( 'bootstrap' ) ; core . subscribe ( 'login' , function ( ) { core . start ( passwords ) ; core . start ( notes ) ; } ) ; core . broadcast ( 'request:login' , 'nicolas' , 'test' ) ; }
function test ( type , rtn , ffi ) { var parsed = types . parse ( type ) assert . deepEqual ( parsed , rtn ) if ( ! ffi ) return var f = types . mapArray ( parsed ) assert . deepEqual ( f , ffi ) }
function hashchanged ( ) { var hash = location . hash ; if ( hash != latestHash ) { var el = /^#[\w_-$]$/ . test ( latestHash ) && document . all [ latestHash . slice ( 1 ) ] ; if ( el ) { el . className = el . className . replace ( /(?:^|\s+|\S+--)target__(\s+|--\S+|$)/ , ' ' ) } latestHash = hash ; if ( el = /^#[\w_-$]$/ . test ( latestHash ) && document . all [ latestHash . slice ( 1 ) ] ) { el . className += ' target__' } } }
function ( col , xy , z ) { var ret = color . hsla ( col ) ; this . xy ( ret , { x : ret . h ( ) , y : 1 - ret . s ( ) } , xy , z ) ; this . z ( ret , ret . l ( ) , xy , z ) ; return ret ; }
function ( col , xy , z ) { var ret = color . hsla ( col ) ; this . xy ( ret , { x : ret . h ( ) , y : 1 - ret . s ( ) } , xy , z ) ; this . z ( ret , ret . l ( ) , xy , z ) ; return ret ; }
function ( idt ) { var idt , tree , that ; idt || ( idt = '' ) ; tree = '\n' + idt + this . constructor . displayName ; if ( that = this . show ( ) ) { tree += ' ' + that ; } this . eachChild ( function ( it ) { tree += it . toString ( idt + TAB ) ; } ) ; return tree ; }
function Block ( node ) { var node , __this = this instanceof __ctor ? this : new __ctor ; __this . lines = [ ] ; if ( ! node ) { return __this ; } node = node . unparen ( ) ; if ( node instanceof Block ) { return node ; } __this . add ( node ) ; return __this ; } function __ctor ( ) { }
function ( o , cons ) { var cons , firstPart ; cons == null && ( cons = false ) ; firstPart = "(" + this . first . compile ( o ) + ")" ; if ( cons ) { firstPart = "[" + firstPart + "]" ; } return firstPart + ".concat(" + this . second . compile ( o ) + ")" ; }
function ( ctx ) { var ctx , that ; ctx || ( ctx = { } ) ; if ( ! ctx [ this . verb ] ) { return this ; } if ( that = this . label ) { return ! __in ( that , ctx . labels || [ ] ) && this ; } }
function ( ctx ) { var ctx ; ctx || ( ctx = { } ) ; ( ctx . labels || ( ctx . labels = [ ] ) ) . push ( this . label ) ; return this . it . getJump ( ( ctx [ 'break' ] = true , ctx ) ) ; }
function ( name , type , node ) { var t , that ; if ( node && ( t = this . variables [ name + "." ] ) ) { if ( that = this . READONLY [ t ] || this . READONLY [ type ] ) { node . carp ( "redeclaration of " + that + " \"" + name + "\"" ) ; } if ( t in [ 'arg' , 'function' ] ) { return name ; } } this . variables [ name + "." ] = type ; return name ; }
function ( patterns , action , options ) { var patterns , action ; patterns = patterns . trim ( ) . split ( /\s+/ ) ; action && ( action = action === ditto ? last : ( action + "" ) . replace ( /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/ , '$$$$ = $1;' ) . replace ( /\b(?!Er)[A-Z][\w.]*/g , 'yy.$&' ) . replace ( /\.L\(/g , '$&yylineno, ' ) ) ; return [ patterns , last = action || '' , options ] ; }
function ( it ) { var it , __ref ; it || ( it = this . tokens ) ; addImplicitIndentation ( it ) ; tagPostfixConditionals ( it ) ; addImplicitParentheses ( it ) ; addImplicitBraces ( it ) ; expandLiterals ( it ) ; if ( ( ( __ref = it [ 0 ] ) != null ? __ref [ 0 ] : void 8 ) === 'NEWLINE' ) { it . shift ( ) ; } return it ; }
function able ( tokens , i , call ) { var i , token , tag ; i == null && ( i = tokens . length ) ; tag = ( token = tokens [ i - 1 ] ) [ 0 ] ; return ( tag == 'ID' || tag == ']' || tag == '?' ) || ( call ? token . callable || ( tag == ')' || tag == ')CALL' ) && token [ 1 ] : tag ==
function decode ( val , lno ) { var val ; if ( ! isNaN ( val ) ) { return [ + val ] ; } val = val . length > 8 ? 'ng' : Function ( 'return' + val ) ( ) ; val . length === 1 || carp ( 'bad string in range' , lno ) ; return [ val . charCodeAt ( ) , true ] ; }
getTripByUrl ( url ) { var tid = url . split ( '/' ) ; var ind = tid . length - 1 ; if ( tid [ ind ] == '' ) ind -- ; var tid = tid [ ind ] ; return globals . trips . getTrip ( tid ) ; }
function ( e ) { var updateOptions = { } ; updateOptions [ propertyName ] = element . value ; trackEvent . update ( updateOptions ) ; var target = _this . butter . getTargetByType ( "elementID" , trackEvent . popcornOptions . target ) ; if ( target ) { target . view . blink ( ) ; } }
function ( popcornOptions ) { var element ; for ( var option in popcornOptions ) { if ( popcornOptions . hasOwnProperty ( option ) ) { element = _rootElement . querySelector ( "[data-manifest-key='" + option + "']" ) ; element . value = popcornOptions [ option ] ; } } }
function ( message , actual , expected ) { var passed = true ; if ( arguments . length == 2 ) { passed = actual ; } else { passed = actual == expected ; } if ( ! passed ) { throw new Exception ( message ) ; } }
function ( id ) { var s = builder . plugins . db . createStatement ( "SELECT * FROM state WHERE identifier = :identifier" ) ; s . params . identifier = id ; if ( s . executeStep ( ) ) { return { "installState" : s . row . installState , "enabledState" : s . row . enabledState } ; } else { return { "installState" : builder . plugins . INSTALLED , "enabledState" : builder . plugins . ENABLED } ; } }
function ( ) { if ( $ ( '#article' ) . data ( 'article-current' ) == 'False' || $ ( '#article' ) . data ( 'article-changed' ) == 'False' ) return ; $ ( '#mark_as_read' ) . removeClass ( 'hiding' ) ; mark_as_read_if_needed ( ) ; } , { 'offset' : '100%' }
function ( input , callback ) { var host = input . host . value || input . host . placeholder var port = input . port . value || input . port . placeholder if ( host !== input . host . placeholder || port !== input . port . placeholder ) { self . set ( 'host' , host ) self . set ( 'port' , port ) location . reload ( ) } }
function playlistItemDidMove ( from , to ) { self . super . playlistModel . model . anonymousMutation = true var item = self . super . playlistModel . model . splice ( from , 1 ) [ 0 ] self . super . playlistModel . model . splice ( to - 1 , 0 , item ) self . super . playlistModel . model . anonymousMutation = undefined }
function ( option ) { var optionNode = util . createElement ( { tag : 'option' , inner : option , appendTo : element , attributes : { value : option } } ) if ( input . placeholder && option == input . placeholder ) { optionNode . setAttribute ( 'selected' , 'selected' ) } }
function ( options ) { this . node = util . createElement ( { tag : 'ol' , customClass : 'UIRearrangeableListWidget' , appendTo : ( options . appendTo instanceof Element ) ? options . appendTo : document . body } ) this . onmove = options . onmove this . onremove = options . onremove this . selectedNodes = [ ] }
function dragDrop ( item , index ) { if ( window . dropZone == 'rearrangeablelist' ) { var group , draggedNode = this . node . childNodes [ index ] if ( util . hasClass ( draggedNode , 'selected' ) ) { group = this . selectedNodes } else { group = [ draggedNode ] } moveTo . call ( this , group , item , window . dropRegion ) window . dropRegion = undefined } util . removeNode ( document . getElementById ( 'dropIndicator' ) ) }
function ( a ) { for ( var i = a . length - 1 ; i >= 0 ; i -- ) { a [ i ] . inCircle = searchCircle . contains ( new google . maps . LatLng ( a [ i ] . lat , a [ i ] . lng ) ) ; addMarker ( a [ i ] ) ; } drawMap ( ) ; }
function ( isp ) { isp = isp ; var o = { isp : isp , status : status , lat : loc . lat , lng : loc . lng , time : Date . now ( ) } ; map . setIsp ( isp ) ; map . setLocation ( o ) ; writeToDatabase ( o ) ; $ ( '#header' ) . show ( ) ; $ ( '#isp-dropdown-label' ) . text ( isp ) ; }
function onLocationDetected ( ok , e ) { if ( e ) { console . log ( e ) ; } else { drawISPList ( ) ; mdl . setLocation ( loc . city , loc . state , isps ) ; } }
function ( callback ) { _onComplete = callback ; if ( ! navigator . geolocation ) { _onComplete ( false , 'Your browser does not support geolocation :(' ) ; } else { navigator . geolocation . getCurrentPosition ( getGeoCodeData , onPositionError ) ; } }
function ( users ) { res . send ( users , 200 ) ; }
function ( subscribable ) { if ( ! ko . isSubscribable ( subscribable ) ) throw new Error ( "Only subscribable things can act as dependencies" ) ; if ( _frames . length > 0 ) { var topFrame = _frames [ _frames . length - 1 ] ; if ( ko . utils . arrayIndexOf ( topFrame . distinctDependencies , subscribable ) >= 0 ) return ; topFrame . distinctDependencies . push ( subscribable ) ; topFrame . callback ( subscribable ) ; } }
function ( subscription ) { if ( subscription && ( subscription . isDisposed !== true ) ) subscription . callback ( valueToNotify ) ; }
function ( tempArray ) { var paraArray = ( tempArray instanceof Array ) ? tempArray : arguments ; var prev = paraArray [ 0 ] ; for ( var i = 1 ; i < paraArray . length ; i ++ ) { if ( paraArray [ i ] != null ) { prev = cc . Sequence . _actionOneTwo ( prev , paraArray [ i ] ) ; } } return prev ; }
function ( target ) { this . _total = 0 ; this . _nextDt = this . _innerAction . getDuration ( ) / this . _duration ; this . _super ( target ) ; this . _innerAction . startWithTarget ( target ) ; }
function ( t , sx , sy ) { var ret = false ; if ( this . _super ( t ) ) { this . _endSkewX = sx ; this . _endSkewY = sy ; ret = true ; } return ret ; }
function ( t , deltaSkewX , deltaSkewY ) { var ret = false ; if ( this . _super ( t , deltaSkewX , deltaSkewY ) ) { this . _skewX = deltaSkewX ; this . _skewY = deltaSkewY ; ret = true ; } return ret ; }
function ( target ) { this . _super ( target ) ; this . _deltaX = this . _skewX ; this . _deltaY = this . _skewY ; this . _endSkewX = this . _startSkewX + this . _deltaX ; this . _endSkewY = this . _startSkewY + this . _deltaY ; }
function ( duration , position , height , jumps ) { if ( this . _super ( duration ) ) { this . _delta = position ; this . _height = height ; this . _jumps = jumps ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; this . _delta = cc . ccp ( this . _delta . x - this . _startPosition . x , this . _delta . y - this . _startPosition . y ) ; }
function ( target ) { this . _super ( target ) ; this . _config . controlPoint_1 = cc . ccpSub ( this . _config . controlPoint_1 , this . _startPosition ) ; this . _config . controlPoint_2 = cc . ccpSub ( this . _config . controlPoint_2 , this . _startPosition ) ; this . _config . endPosition = cc . ccpSub ( this . _config . endPosition , this . _startPosition ) ; }
function ( duration , sx , sy ) { if ( this . _super ( duration ) ) { this . _endScaleX = sx ; this . _endScaleY = ( sy != null ) ? sy : sx ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; this . _startScaleX = target . getScaleX ( ) ; this . _startScaleY = target . getScaleY ( ) ; this . _deltaX = this . _endScaleX - this . _startScaleX ; this . _deltaY = this . _endScaleY - this . _startScaleY ; }
function ( target ) { this . _super ( target ) ; this . _deltaX = this . _startScaleX * this . _endScaleX - this . _startScaleX ; this . _deltaY = this . _startScaleY * this . _endScaleY - this . _startScaleY ; }
function ( duration , red , green , blue ) { if ( this . _super ( duration ) ) { this . _to = cc . ccc3 ( red , green , blue ) ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; var color = target . getColor ( ) ; this . _fromR = color . r ; this . _fromG = color . g ; this . _fromB = color . b ; }
function ( action ) { cc . Assert ( action != null , "" ) ; cc . Assert ( action != this . _other , "" ) ; if ( this . _super ( action . getDuration ( ) ) ) { this . _other = action ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; if ( this . _animation . getRestoreOriginalFrame ( ) ) { this . _origFrame = target . displayFrame ( ) ; } this . _nextFrame = 0 ; this . _executedLoops = 0 ; }
function ( path ) { if ( path . substring ( 0 , 3 ) === "../" ) return true ; if ( path . substring ( 0 , 1 ) === "/" ) return true ; path = path . split ( "/" ) ; var cwd = fs . readdirSync ( process . cwd ( ) ) ; return ( cwd . indexOf ( path [ 0 ] ) === - 1 ) ; }
function ( ) { var ct = Date . now ( ) ; var max = parseInt ( this . maxCount ) ; var diff = ( ct - parseInt ( this . startTime ) ) / 1000 ; var speed = "Not enough phases requested!" ; if ( diff != 0 ) { speed = "" + Math . ceil ( max / diff ) + " phases per second!" ; } console . log ( "Benchmark results: " + speed + " Time spent: " + diff + "seconds" ) ; }
function ( e ) { if ( e . which == 40 ) { self . moveSelection ( 'down' ) ; } else if ( e . which == 38 ) { self . moveSelection ( 'up' ) ; } else if ( e . which == 13 ) { var active = $ ( '.fac-container .fac-item.active' ) ; select ( active ) ; } else if ( e . which == 27 ) { self . dismissHints ( ) ; } }
function convert_ean8_to_upca ( upc ) { if ( upc . length == 7 ) { upc = upc + validate_ean8 ( upc , true ) ; } if ( upc . length > 8 || upc . length < 8 ) { return false ; } if ( validate_ean8 ( upc ) === false ) { return false ; } upca = "0000" + upc ; return upca ; }
function convert_isbn10_to_isbn13 ( upc ) { upc = upc . replace ( /-/g , "" ) ; upc = upc . replace ( /\s/g , "" ) ; if ( validate_isbn10 ( upc ) === false ) { return false ; } if ( upc . length > 9 ) { fix_matches = upc . match ( /^(\d{9})/ ) ; upc = fix_matches [ 1 ] ; } isbn13 = "978" + upc + validate_ean13 ( "978" + upc , true ) ; return isbn13 ; }
function convert_isbn13_to_isbn10 ( upc ) { upc = upc . replace ( /-/g , "" ) ; upc = upc . replace ( /\s/g , "" ) ; if ( validate_ean13 ( upc ) === false ) { return false ; } if ( ! upc . match ( /^978(\d{9})/ ) ) { return false ; } if ( upc . match ( /^978(\d{9})/ ) ) { upc_matches = upc . match ( /^978(\d{9})/ ) ; isbn10 = upc_matches [ 1 ] + validate_isbn10 ( upc_matches [ 1 ] , true ) ; } return isbn10 ; }
function convert_ismn10_to_ismn13 ( upc ) { upc = upc . replace ( /M/g , "" ) ; upc = upc . replace ( /-/g , "" ) ; upc = upc . replace ( /\s/g , "" ) ; if ( validate_ismn10 ( upc ) === false ) { return false ; } if ( upc . length > 8 ) { fix_matches = upc . match ( /^(\d{8})/ ) ; upc = fix_matches [ 1 ] ; } ismn13 = "9790" + upc + validate_ean13 ( "9790" + upc , true ) ; return ismn13 ; }
function ( path , status ) { var url = '' ; if ( ~ path . indexOf ( '://' ) ) { url = path ; } else { url += this . req . encrypted ? 'https://' : 'http://' ; url += this . req . headers . host ; url += ( path [ 0 ] === '/' ) ? path : '/' + path ; } this . res . writeHead ( status || 302 , { 'Location' : url } ) ; this . res . end ( ) ; }
function ( ) { if ( ! ! -- thisValue . nbImagesLoading_ ) { thisValue . element_ . innerHTML = ( 100 * ( thisValue . GetNbImages ( ) - thisValue . GetNbImagesLoading ( ) ) / thisValue . GetNbImages ( ) ) . toFixed ( 1 ) ; } else { thisValue . element_ . innerHTML = "100" ; } }
function ( error , result ) { if ( error ) { Meteor . default_connection . setUserId ( null ) ; localStorage . setItem ( "Meteor.loginToken" , "" ) ; Meteor . _debug ( "Server error on login" , error ) ; return ; } }
function ( api ) { api . use ( 'http' , [ 'client' , 'server' ] ) ; api . use ( 'localstorage-polyfill' , 'client' ) ; api . add_files ( 'accounts_common.js' , [ 'client' , 'server' ] ) ; api . add_files ( 'accounts_server.js' , 'server' ) ; api . add_files ( 'accounts_client.js' , 'client' ) ; api . add_files ( 'localstorage_token.js' , 'client' ) ; }
function ( error , clientref ) { if ( error ) throw error ; if ( user && password ) { db . authenticate ( user , password , function ( error , result ) { if ( error ) { console . warn ( error ) ; return ; } callback ( db ) ; } ) ; } else { callback ( db ) ; } }
function ( callback ) { var self = exports ; var config = { database : MONGODB , } ; mongoConnect . connect ( config , function ( dbclient ) { client = dbclient ; if ( numberOfTestsRun == 0 ) { client . dropDatabase ( function ( err , done ) { begin ( callback ) ; } ) ; } else { begin ( callback ) ; } } ) ; }
function ( callback ) { var self = this ; var ms = + new Date - timers [ numberOfTestsRun ] . start ; console . log ( '  Test' , numberOfTestsRun , 'took ' + ms + 'ms' ) numberOfTestsRun += 1 ; callback ( ) ; client . close ( ) ; }
function ( ) { var name = $ ( this ) . closest ( ".remote_setting" ) . attr ( "id" ) . split ( "remote_settings_" ) [ 1 ] ; var index = $ ( ".filter" , $ ( this ) . parent ( ) ) . index ( $ ( this ) ) ; var c = confirm ( "Are you sure you want to remove this filter?" ) ; if ( c ) { socket . send ( "request=remove_filter&name=" + name + "&index=" + index ) ; } }
function setup ( ) { _parentHeight = outerElement . getBoundingClientRect ( ) . height ; _childHeight = innerElement . getBoundingClientRect ( ) . height ; _elementHeight = _element . getBoundingClientRect ( ) . height ; _scrollHeight = outerElement . scrollHeight ; _handleHeight = _elementHeight - ( _scrollHeight - _parentHeight ) / VERTICAL_SIZE_REDUCTION_FACTOR ; _handleHeight = Math . max ( 20 , Math . min ( _elementHeight , _handleHeight ) ) ; _handle . style . height = _handleHeight + "px" ; setHandlePosition ( ) ; }
function onMouseMove ( e ) { var diff = e . pageX - _mousePos ; diff = Math . max ( 0 , Math . min ( diff , _elementWidth - _handleWidth ) ) ; _handle . style . left = diff + "px" ; var p = _handle . offsetLeft / ( _elementWidth - _handleWidth ) ; innerElement . scrollLeft = ( _scrollWidth - _elementWidth ) * p ; _this . dispatch ( "scroll" , innerElement . scrollLeft ) ; }
function setHandlePosition ( ) { if ( _scrollWidth - _elementWidth > 0 ) { _handle . style . left = ( _elementWidth - _handleWidth ) * ( innerElement . scrollLeft / ( _scrollWidth - _elementWidth ) ) + "px" ; } else { _handle . style . left = "0px" ; } }
function ( e ) { if ( e . axis === e . HORIZONTAL_AXIS || ( e . axis === e . VERTICAL_AXIS && e . shiftKey ) ) { innerElement . scrollLeft += e . detail * 2 ; setHandlePosition ( ) ; e . preventDefault ( ) ; } }
function ( data ) { $ ( "#loading" ) . remove ( ) ; if ( data . status === "success" ) { legnd [ 0 ] . insertAdjacentHTML ( "afterend" , "<div class='success'>" + data . message + "</div>" ) ; } else { legnd [ 0 ] . insertAdjacentHTML ( "afterend" , "<div class='error'>" + data . message + "</div>" ) ; } }
function ( data ) { for ( item in data ) { console . log ( data [ item ] ) ; } }
function ( container ) { var loader = new Image ( ) ; loader . setAttribute ( "id" , "loading" ) ; loader . setAttribute ( "alt" , "graph loading..." ) ; loader . setAttribute ( "src" , "/img/icons/ajax-loader.gif" ) ; console . log ( container ) ; console . log ( loader ) ; $ ( container ) . append ( loader ) ; }
function ( port ) { if ( port . name == "kexp.app.view" ) { self . pollFsm . attachView ( ) ; port . onDisconnect . addListener ( function ( ) { self . pollFsm . detachView ( ) ; _gaq . push ( [ "_trackEvent" , "Application" , "Close" ] ) ; } ) ; } }
function ( options ) { var self = this ; this . _lastFmConfig = this . appConfig . getLastFm ( ) ; this . _lastFmApi = options . lastFmApi ; this . _nowPlayingCollection = options . nowPlayingCollection ; this . bindTo ( this . _lastFmConfig , "change:sessionKey" , this . handlePlayScrobbleChange , this ) ; this . bindTo ( this . _lastFmConfig , "change:playScrobbleEnabled" , this . handlePlayScrobbleChange , this ) ; this . handlePlayScrobbleChange ( this . _lastFmConfig ) ; }
function ( path , callback ) { var head = document . getElementsByTagName ( 'head' ) [ 0 ] ; var s = document . createElement ( 'script' ) ; s . src = path ; head . appendChild ( s ) ; s . onload = callback ; }
function ( obj , iterator , context ) { var result = true ; if ( obj == null ) return result ; if ( nativeEvery && obj . every === nativeEvery ) return obj . every ( iterator , context ) ; each ( obj , function ( value , index , list ) { if ( ! ( result = result && iterator . call ( context , value , index , list ) ) ) return breaker ; } ) ; return result ; }
function ( value , index , list ) { if ( index == 0 ) { shuffled [ 0 ] = value ; } else { rand = Math . floor ( Math . random ( ) * ( index + 1 ) ) ; shuffled [ index ] = shuffled [ rand ] ; shuffled [ rand ] = value ; } }
function ( value , index , list ) { return { value : value , criteria : iterator . call ( context , value , index , list ) } ; }
function ( iterable ) { if ( ! iterable ) return [ ] ; if ( iterable . toArray ) return iterable . toArray ( ) ; if ( _ . isArray ( iterable ) ) return slice . call ( iterable ) ; if ( _ . isArguments ( iterable ) ) return slice . call ( iterable ) ; return _ . values ( iterable ) ; }
function ( array ) { var rest = _ . flatten ( slice . call ( arguments , 1 ) ) ; return _ . filter ( array , function ( value ) { return ! _ . include ( rest , value ) ; } ) ; }
function ( ) { context = this ; args = arguments ; var later = function ( ) { timeout = null ; if ( more ) func . apply ( context , args ) ; whenDone ( ) ; } ; if ( ! timeout ) timeout = setTimeout ( later , wait ) ; if ( throttling ) { more = true ; } else { func . apply ( context , args ) ; } whenDone ( ) ; throttling = true ; }
function ( ) { var context = this , args = arguments ; var later = function ( ) { timeout = null ; func . apply ( context , args ) ; } ; clearTimeout ( timeout ) ; timeout = setTimeout ( later , wait ) ; }
function ( obj ) { if ( _ . isArray ( obj ) || _ . isString ( obj ) ) return obj . length === 0 ; for ( var key in obj ) if ( _ . has ( obj , key ) ) return false ; return true ; }
function SegmentPlaceholder ( tl , x , track ) { this . tl = tl ; this . startX = x ; this . endX = 0 ; this . track = track ; this . renderIndex = tl . misc . length ; tl . misc . push ( this ) ; }
function ( wave , trackId ) { var that = this , i , seg , track = this . tracks [ trackId ] ; if ( ! track ) { return ; } track . audio = wave ; if ( this . selectedSegment && this . tracks [ this . selectedSegment . track ] === track ) { track . render ( ) ; this . renderTimeMarker ( ) ; } }
function ( ) { var markerX = this . timeToPixel ( this . timeMarkerPos ) , height = this . height - this . sliderHeight - this . kTracks * ( this . segmentTrackHeight + this . segmentTrackPadding ) ; this . ctx . fillStyle = this . timeMarkerColor ; this . ctx . fillRect ( markerX , 0 , 2 , height ) ; }
function ( ) { if ( this . repeatA != null ) { var left = this . timeToPixel ( this . repeatA ) ; var right = this . timeToPixel ( this . repeatB ) ; if ( this . abRepeatOn == true ) this . ctx . fillStyle = this . abRepeatColor ; else this . ctx . fillStyle = this . abRepeatColorLight ; this . ctx . fillRect ( left , 0 , right - left , this . height - this . sliderHeight ) ; } }
function ( time ) { if ( time == this . timeMarkerPos ) { return ; } if ( this . abRepeatOn == true && time > this . repeatB ) { time = this . repeatA ; this . emit ( 'jump' , this . repeatA ) ; } this . timeMarkerPos = time ; this . updateCurrentSegments ( ) ; this . emit ( 'timeupdate' , time ) ; this . render ( ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Inspector.evaluateForTestInFrontend' , [ 'testCallId' , 'script' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Inspector.inspect' , [ 'object' , 'hints' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Inspector.didCreateWorker' , [ 'id' , 'url' , 'isShared' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Inspector.didDestroyWorker' , [ 'id' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Inspector' , this ) ; }
function ( frameId , url , query , caseSensitive , isRegex , opt_callback ) { var paramObject = { 'frameId' : frameId , 'url' : url , 'query' : query , 'caseSensitive' : caseSensitive , 'isRegex' : isRegex , } ; chrome . devtools . remoteDebug . sendCommand ( 'Page.searchInResource' , paramObject , opt_callback ) ; }
function ( width , height , fontScaleFactor , fitWindow , opt_callback ) { var paramObject = { 'width' : width , 'height' : height , 'fontScaleFactor' : fontScaleFactor , 'fitWindow' : fitWindow , } ; chrome . devtools . remoteDebug . sendCommand ( 'Page.setDeviceMetricsOverride' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Page.domContentEventFired' , [ 'timestamp' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Page.loadEventFired' , [ 'timestamp' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Page.frameNavigated' , [ 'frame' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Page.frameDetached' , [ 'frameId' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Page' , this ) ; }
function ( expression , objectGroup , includeCommandLineAPI , doNotPauseOnExceptionsAndMuteConsole , contextId , returnByValue , opt_callback ) { var paramObject = { 'expression' : expression , 'objectGroup' : objectGroup , 'includeCommandLineAPI' : includeCommandLineAPI , 'doNotPauseOnExceptionsAndMuteConsole' : doNotPauseOnExceptionsAndMuteConsole , 'contextId' : contextId , 'returnByValue' : returnByValue , } ; chrome . devtools . remoteDebug . sendCommand ( 'Runtime.evaluate' , paramObject , opt_callback ) ; }
function ( objectId , functionDeclaration , arguments , doNotPauseOnExceptionsAndMuteConsole , returnByValue , opt_callback ) { var paramObject = { 'objectId' : objectId , 'functionDeclaration' : functionDeclaration , 'arguments' : arguments , 'doNotPauseOnExceptionsAndMuteConsole' : doNotPauseOnExceptionsAndMuteConsole , 'returnByValue' : returnByValue , } ; chrome . devtools . remoteDebug . sendCommand ( 'Runtime.callFunctionOn' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Console.messageAdded' , [ 'message' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Console.messageRepeatCountUpdated' , [ 'count' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Console.messagesCleared' , [ '' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Console' , this ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Database.addDatabase' , [ 'database' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Database.sqlTransactionSucceeded' , [ 'transactionId' , 'columnNames' , 'values' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Database.sqlTransactionFailed' , [ 'transactionId' , 'sqlError' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Database' , this ) ; }
function ( requestId , frameId , databaseName , objectStoreName , indexName , skipCount , pageSize , keyRange , opt_callback ) { var paramObject = { 'requestId' : requestId , 'frameId' : frameId , 'databaseName' : databaseName , 'objectStoreName' : objectStoreName , 'indexName' : indexName , 'skipCount' : skipCount , 'pageSize' : pageSize , 'keyRange' : keyRange , } ; chrome . devtools . remoteDebug . sendCommand ( 'IndexedDB.requestData' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'DOMStorage.addDOMStorage' , [ 'storage' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'DOMStorage.domStorageUpdated' , [ 'storageId' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'DOMStorage' , this ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'ApplicationCache.applicationCacheStatusUpdated' , [ 'frameId' , 'manifestURL' , 'status' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'ApplicationCache.networkStateUpdated' , [ 'isNowOnline' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'ApplicationCache' , this ) ; }
function ( x , y , width , height , color , outlineColor , opt_callback ) { var paramObject = { 'x' : x , 'y' : y , 'width' : width , 'height' : height , 'color' : color , 'outlineColor' : outlineColor , } ; chrome . devtools . remoteDebug . sendCommand ( 'DOM.highlightRect' , paramObject , opt_callback ) ; }
function ( nodeId , forcedPseudoClasses , includePseudo , includeInherited , opt_callback ) { var paramObject = { 'nodeId' : nodeId , 'forcedPseudoClasses' : forcedPseudoClasses , 'includePseudo' : includePseudo , 'includeInherited' : includeInherited , } ; chrome . devtools . remoteDebug . sendCommand ( 'CSS.getMatchedStylesForNode' , paramObject , opt_callback ) ; }
function ( styleId , propertyIndex , text , overwrite , opt_callback ) { var paramObject = { 'styleId' : styleId , 'propertyIndex' : propertyIndex , 'text' : text , 'overwrite' : overwrite , } ; chrome . devtools . remoteDebug . sendCommand ( 'CSS.setPropertyText' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'CSS.mediaQueryResultChanged' , [ '' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'CSS.styleSheetChanged' , [ 'styleSheetId' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'CSS' , this ) ; }
function ( lineNumber , url , urlRegex , columnNumber , condition , opt_callback ) { var paramObject = { 'lineNumber' : lineNumber , 'url' : url , 'urlRegex' : urlRegex , 'columnNumber' : columnNumber , 'condition' : condition , } ; chrome . devtools . remoteDebug . sendCommand ( 'Debugger.setBreakpointByUrl' , paramObject , opt_callback ) ; }
function ( scriptId , query , caseSensitive , isRegex , opt_callback ) { var paramObject = { 'scriptId' : scriptId , 'query' : query , 'caseSensitive' : caseSensitive , 'isRegex' : isRegex , } ; chrome . devtools . remoteDebug . sendCommand ( 'Debugger.searchInContent' , paramObject , opt_callback ) ; }
function ( callFrameId , expression , objectGroup , includeCommandLineAPI , doNotPauseOnExceptionsAndMuteConsole , returnByValue , opt_callback ) { var paramObject = { 'callFrameId' : callFrameId , 'expression' : expression , 'objectGroup' : objectGroup , 'includeCommandLineAPI' : includeCommandLineAPI , 'doNotPauseOnExceptionsAndMuteConsole' : doNotPauseOnExceptionsAndMuteConsole , 'returnByValue' : returnByValue , } ; chrome . devtools . remoteDebug . sendCommand ( 'Debugger.evaluateOnCallFrame' , paramObject , opt_callback ) ; }
function ( ) { chrome . devtools . remoteDebug . registerEvent ( 'Worker.workerCreated' , [ 'workerId' , 'url' , 'inspectorConnected' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Worker.workerTerminated' , [ 'workerId' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Worker.dispatchMessageFromWorker' , [ 'workerId' , 'message' ] ) ; chrome . devtools . remoteDebug . registerEvent ( 'Worker.disconnectedFromWorker' , [ '' ] ) ; chrome . devtools . remoteDebug . addDomainListener ( 'Worker' , this ) ; }
function ( handlerSpec ) { var settingsHandlerPayload = gpii . lifecycleManager . specToSettingsHandler ( solutionId , handlerSpec ) ; var handlerResponse = fluid . invokeGlobalFunction ( handlerSpec . type , [ settingsHandlerPayload ] ) ; var settingsSnapshot = gpii . lifecycleManager . responseToSnapshot ( solutionId , handlerResponse ) ; var invariant = fluid . model . transform ( handlerSpec , gpii . lifecycleManager . invariantSettings ) ; return $ . extend ( true , { } , handlerSpec , settingsSnapshot ) ; }
function ( data , meta ) { var ct = meta . http . headers [ 'content-type' ] ; doneCalled = true ; A . areSame ( 'hi' , data , 'bad string to done' ) ; A . areSame ( 1 , ct . length , "should be only one content-type header" ) ; A . areSame ( 'text/plain; charset="utf-8"' , ct [ 0 ] ) ; }
function ( data , meta ) { var ct = meta . http . headers [ 'content-type' ] ; doneCalled = true ; A . areSame ( Y . JSON . stringify ( json ) , data , 'bad string to done' ) ; A . areSame ( 1 , ct . length , "should be only one content-type header" ) ; A . areSame ( 'application/json; charset="utf-8"' , ct [ 0 ] ) ; }
function ( data , meta ) { var ct = meta . http . headers [ 'content-type' ] ; doneCalled = true ; A . areSame ( '<xml><hi>there</hi></xml>' , data , 'bad string to done' ) ; A . areSame ( 1 , ct . length , "should be only one content-type header" ) ; A . areSame ( 'application/xml; charset="utf-8"' , ct [ 0 ] ) ; }
function ( overlayHTMLDiv ) { var overlayHTMLDiv2 = overlayHTMLDiv . down ( 'div' ) ; var overlayWrapper = overlayHTMLDiv2 . up ( '.highslide-wrapper' ) ; overlayWrapper . setStyle ( { 'width' : overlayHTMLDiv2 . getWidth ( ) + 'px' } ) ; overlayHTMLDiv . setStyle ( { 'width' : overlayHTMLDiv2 . getWidth ( ) + 'px' } ) ; var imgInOverlay = overlayHTMLDiv . down ( 'img.highslide-image' ) ; celSlideShowInternalCenterImage ( imgInOverlay ) ; imgInOverlay . setStyle ( { 'visibility' : 'visible' } ) ; }
function ( data ) { if ( data [ 0 ] && ( ! _ . isArray ( data [ 0 ] ) || ( data [ 0 ] [ 0 ] && _ . isArray ( data [ 0 ] [ 0 ] ) ) ) ) return data ; else return [ data ] ; }
function _selectStorage ( flag , fun ) { var storage ; if ( ! _checkArgument ( 'Boolean' , flag ) && flag !== undefined ) { throw new Error ( 'RS.' + fun + ': 2nd argument should be boolean' ) ; } else { storage = ( flag === true || flag === undefined ) ? localStorage : sessionStorage ; } return storage ; }
function renderPreviewImage ( item ) { var previewImage = '<div class="innerwrap" style=\'background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(0,0,0,0.62)), color-stop(27%,rgba(0,0,0,0.12)), color-stop(41%,rgba(0,0,0,0.01)), color-stop(53%,rgba(0,0,0,0.06)), color-stop(100%,rgba(0,0,0,0.48))), url("' + ( item . thumbnail ? item . thumbnail : 'http://www.blog.spoongraphics.co.uk/wp-content/uploads/2011/great-britain/great-britain-sm.jpg' ) + '")' + '\'>' + '<h5>' + '<a href="/article/' + item . uuid + '">' + item . title + '</a></h5>' + '</div>' console . log ( previewImage ) ; return previewImage }
function ( cfg ) { expect ( cfg . icons . length ) . toBeGreaterThan ( 0 ) ; expect ( cfg . icons [ 0 ] . path ) . toEqual ( "locales/en/custom.png" ) ; expect ( cfg . icons [ 0 ] . height ) . toBeUndefined ( ) ; expect ( cfg . icons [ 0 ] . width ) . toBeUndefined ( ) }
function ( json ) { if ( typeof json === 'object' ) { json = JSON . stringify ( json ) ; } this . response . writeHead ( 200 , { "Content-Type" : "application/json" } ) ; this . response . write ( JSON . stringify ( json ) ) ; this . response . end ( ) ; }
function ( models ) { if ( refresh ) { this . empty ( ) ; Array . each ( models , this . addModel . bind ( this ) ) ; } else { this . processModels ( responseObj ) ; } this . fireEvent ( 'fetch' , [ models ] ) }
function createDeleteIndexFieldResponse ( options ) { var doc = xmlbuilder . create ( ) ; var requestId = doc . begin ( 'DeleteIndexFieldResponse' , { version : '1.0' } ) . attribute ( 'xmlns' , XMLNS ) . element ( 'DeleteIndexFieldResult' ) . up ( ) . element ( 'ResponseMetadata' ) . element ( 'RequestId' ) ; if ( options . requestId && options . requestId !== '' ) { requestId . text ( options . requestId ) ; } return doc . toString ( ) ; }
function ( ) { this . _obj = null ; this . _previousObj = null ; this . _parentList = [ ] ; this . actor = new St . ScrollView ( { x_fill : true , y_fill : true } ) ; this . actor . get_hscroll_bar ( ) . hide ( ) ; this . _container = new St . BoxLayout ( { name : 'LookingGlassPropertyInspector' , style_class : 'lg-dialog' , vertical : true } ) ; this . actor . add_actor ( this . _container ) ; }
function ( index ) { slider . css ( 'left' , ( - index * 100 ) + '%' ) ; }
function simulateDownload ( err , chain ) { if ( err ) throw err ; if ( ! blocks [ blockDesc . name ] ) { throw new Error ( "Test block " + blockDesc . name + " was not " + "generated successfully." ) ; } var callback = this . parallel ( ) ; console . log ( blockDesc . name ) ; chain . add ( blocks [ blockDesc . name ] , blockTxs [ blockDesc . name ] , function ( err ) { callback ( null , chain ) ; } ) ; }
function ( params , callback ) { var defaultCoords = { latitude : 37.4142716 , longitude : - 122.0243208 } , yqlTable = 'https://raw.github.com/yql/yql-tables/master/weather/weather.woeid.xml' , coords = defaultCoords ; var query = Y . YQL ( 'use "' + yqlTable + '" as weather; ' + 'select * from weather where w in (select place.woeid from flickr.places where ' + 'lat=' + coords . latitude + ' and lon=' + coords . longitude + ' and api_key=07518c5da6dcda6f2d8126ca45fbf085)' + ' and u="c";' , Y . bind ( this . onDataReturn , this , callback ) ) ; }
function updateClustersView ( request , list ) { var list_array = [ ] ; $ . each ( list , function ( ) { list_array . push ( clusterElementArray ( this ) ) ; } ) ; removeClusterMenus ( ) ; updateView ( list_array , dataTable_clusters ) ; updateClusterSelect ( ) ; updateInfraDashboard ( "clusters" , list ) ; newClusterMenu ( list ) ; }
function updateHostsView ( request , host_list ) { var host_list_array = [ ] ; $ . each ( host_list , function ( ) { host_list_array . push ( hostElementArray ( this ) ) ; } ) ; SunstoneMonitoring . monitor ( 'HOST' , host_list ) if ( typeof ( monitorClusters ) != 'undefined' ) monitorClusters ( host_list ) updateView ( host_list_array , dataTable_hosts ) ; updateHostSelect ( ) ; updateInfraDashboard ( "hosts" , host_list ) ; }
function ( ) { var parentElement = window . document . getElementById ( "pnlStage" ) ; utils_ . RemoveFromDOM ( this . selectIcon_ . Element ) ; utils_ . RemoveFromDOM ( this . portriatElement_ ) ; utils_ . RemoveFromDOM ( this . element_ . Element ) ; this . isCharSelected_ = false ; }
function ( show ) { if ( ! ! show ) pnlLoadingProgress_ . style . display = "" ; else { pnlLoadingProgress_ . style . display = "none" ; pnlLoading_ . innerHTML = "" ; } }
function ( key , spriteFilename , left , bottom , width , height ) { if ( ! ! spriteFilename && ( spriteFilename [ 0 ] != "|" ) ) frameImages_ . Load ( spriteFilename ) ; spriteFilename = spriteFilename . replace ( "|" , "" ) ; if ( ! this . Get ( key ) ) { data_ [ key ] = { Key : key , Sprite : spriteFilename , Left : left , Bottom : bottom , Width : width , Height : height } ; } return data_ [ key ] ; }
function ( ) { this . GetPortriatImg ( ) . style . display = "none" ; this . GetNameImg ( ) . style . display = "none" ; this . GetComboText ( ) . HideNow ( ) ; this . GetHealthbar ( ) . Release ( ) ; this . GetEnergybar ( ) . Release ( ) ; for ( var i = 0 ; i < this . GetPlayers ( ) . length ; ++ i ) this . GetPlayer ( i ) . Release ( ) ; }
function ( ha_level ) { var date = new Date ( ) ; var year = 1900 + ( date . getYear ( ) ) ; var month = 1 + date . getMonth ( ) ; var i , m ; if ( month < 3 ) { m = 1 ; } else { m = month - 2 ; } this . store . load ( { scope : this , params : { year : year , month_start : m , month_end : month } } ) ; }
function ( err ) { if ( err instanceof Error ) { debug ( 'error when executing %s listener' , method , err ) err . message = "Error while executing " + method + " event: " + err . message ; } ; debug ( '%s listener complete' , method ) ; fn ( err || errors , item ) ; }
function ( err ) { if ( err instanceof Error ) { err . message = "Error while executing " + method + " event: " + err . message ; debug ( 'error when executing %s listener' , method , err ) ; } debug ( '%s listener complete' , method ) ; if ( err ) { debug ( 'errored during listener' , err ) ; } fn ( err || errors , item ) ; }
function ( err , u ) { if ( u ) return ctx . done ( { email : 'is already in use' } ) ; uc . save ( ctx . session , ctx . body , ctx . query , ctx . dpd , done ) ; }
function ( ) { it ( 'should sanitize the title due to incorrect type' , function ( done ) { dpd . todos . post ( { title : 7 } , function ( todo , err ) { delete todo . id ; expect ( todo ) . to . eql ( { done : false } ) ; done ( ) } ) } ) }
function ( e ) { if ( e . which != 9 ) return ; if ( ! e . ctrlKey && ! e . altKey && ! e . shiftKey && tinymce . activeEditor && ! tinymce . activeEditor . isHidden ( ) ) { $ ( 'td.mceToolbar > a' ) . focus ( ) ; e . preventDefault ( ) ; } }
function ( ) { this . currentTreeObject = new Stateful ( ) ; this . history = { steps : [ ] , curIdx : null , numSteps : 5 } ; this . store = new FileStore ( ) ; this . context = new Stateful ( { isOnGrid : false , isOnTree : false , isOnTreePane : false , isOnGridPane : false } ) }
function ( object ) { var grid = this . grid ; var store = this . store ; var dfd = new Deferred ( ) ; if ( object . dir ) { dfd = Deferred . when ( this . store . getChildren ( object ) , function ( children ) { grid . set ( 'query' , { parId : object . id } ) ; } ) ; } else { dfd . resolve ( object ) ; } return dfd ; }
function ( ) { if ( op === "typeof" || op === "void" || op === "delete" ) { return op + " " + t ; } else { return op + t ; } }
function ( t ) { $ ( t ) . destroy ( ) ; if ( t . id > 0 ) { self . data [ idx ] . erase ( t . id ) } else { self . data [ idx ] . erase ( t . name ) } self . change ( ) ; }
function ( t ) { $ ( t ) . destroy ( ) ; if ( t . id > 0 ) { this . data [ bucket ] . erase ( t . id ) } else { this . data [ bucket ] . erase ( t . name ) } this . change ( ) ; }
function ( mainOption , properties ) { that . mainOptionSelect . append ( '<option>' + mainOption + '</option>' ) ; }
function ( i , option ) { $this . append ( '<option>' + option + '</option>' ) ; }
function ( i , attribute ) { if ( attribute . enabled ) { var attributeProperty = that . attributeUi [ attribute . key ] ; if ( typeof attributeProperty !== "undefined" ) { console . log ( "attr = " + attribute . key ) ; mainOption = attributeProperty . mainOption ; that . mainOptionSelect . val ( mainOption ) ; } } }
function mm_deleteMessage ( id , callback ) { console . log ( "SMS: Eliminando mensaje " + typeof ( id ) + id ) ; var req = navigator . mozSms . delete ( id ) ; req . onsuccess = function onsuccess ( ) { callback ( req . result ) ; } ; req . onerror = function onerror ( ) { var msg = 'Deleting in the database. Error: ' + req . errorCode ; console . log ( msg ) ; callback ( null ) ; } ; }
function thlui_cleanForm ( ) { var inputs = this . view . querySelectorAll ( 'input[type="checkbox"]' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; } }
function thui_cleanForm ( ) { var inputs = this . view . querySelectorAll ( 'input[type="checkbox"]' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . checked = false ; inputs [ i ] . parentNode . parentNode . classList . remove ( 'undo-candidate' ) ; this . delNumList = [ ] ; } }
function ( ) { downloadBtn = $ ( '.gallery li a' ) . attr ( { 'rel' : 'story' + storyIter , 'data-download' : 'download' } ) ; $ ( downloadBtn ) . remove ( ) ; $ ( '.gallery li a[rel="story' + storyIter + '"]' ) . parent ( ) . find ( 'div.ui-btn-inner' ) . append ( '<span class="ui-icon ui-icon-check ui-icon-shadow"> </span>' ) ; }
function ( op ) { if ( ! this . _dialog && ! this . _source ) return ; if ( this . _dialog ) { this . _dialog . close ( global . get_current_time ( ) ) ; this . _dialog = null ; } if ( this . _source ) { this . _notificationShowing = false ; this . _source . destroy ( ) ; this . _source = null ; } }
function displaySlide ( n ) { n = Math . min ( n , slides . length - 1 ) ; n = Math . max ( n , 0 ) ; var s = slides . eq ( n ) ; var top = s . offset ( ) . top ; var padding = { "DIV" : s . offset ( ) . top , "H1" : 150 , "H2" : 20 } [ slides [ n ] . tagName ] ; $ ( "body" ) . scrollTop ( top - padding ) ; }
function ( ) { this . $el . html ( Greenmine . template ( this . model . toJSON ( ) ) ) ; this . $el . attr ( { 'data-id' : this . model . get ( 'id' ) , 'id' : "task_" + this . model . get ( 'id' ) } ) ; return this ; }
function ( task ) { var self = this ; $ . post ( task . get ( 'delete_url' ) , { } , function ( data ) { if ( data . valid ) { var selector = "#task_" + task . get ( 'id' ) ; self . $ ( selector ) . remove ( ) ; } } , 'json' ) ; }
function ( ) { var self = this ; this . $ ( "#task-list-body" ) . html ( "" ) ; Greenmine . taskCollection . each ( function ( item ) { self . addIssue ( item ) ; } ) ; }
function ( name , item ) { item . click ( function ( e ) { e . stopPropagation ( ) ; focus ( name ) ; } ) . dblclick ( function ( e ) { e . stopPropagation ( ) ; edit ( name ) ; } ) . doubleTap ( function ( e ) { e . stopPropagation ( ) ; edit ( name ) ; } ) ; }
function applyLabelToConceptNode ( element , label ) { if ( $ ( element ) . hasClass ( "ghost" ) ) label = "(" + label + ") " else label = label + " " ; $ ( element ) . find ( "label" ) . text ( label ) ; adjustAutoLabeling ( ) ; }
function getSelectedRadio ( ) { var radio = document . forms [ 0 ] . gender ; for ( var i = 0 ; i < radio . length ; i ++ ) { if ( radio [ i ] . checked ) { genderValue = radio [ i ] . value ; } ; } ; }
function ( cfg ) { var self = this ; Y . one ( 'body' ) . on ( "key" , function ( e ) { self . makeNextContainerNavigable ( ) ; } , SHIFT_RIGHT_ARROW ) ; this . makeNextContainerNavigable ( ) ; }
function ( cfg ) { var self = this ; Y . one ( 'body' ) . on ( "key" , function ( e ) { Y . log ( "============================" ) ; Y . log ( 'Shift+RightArrow was pressed' ) ; self . makeNextContainerNavigable ( ) ; } , SHIFT_RIGHT_ARROW ) ; this . makeNextContainerNavigable ( ) ; }
function ( selector , interval , repeat , delay ) { interval = interval || 0 ; cc . Assert ( selector , "Argument must be non-nil" ) ; cc . Assert ( interval >= 0 , "Argument must be positive" ) ; repeat = repeat || cc . REPEAT_FOREVER ; delay = delay || 0 ; this . getScheduler ( ) . scheduleSelector ( selector , this , interval , ! this . _isRunning , repeat , delay ) ; }
function ( ) { this . _super ( ) ; this . centerSprites ( 1 ) ; var action = cc . Sequence . create ( cc . MoveBy . create ( 2.0 , cc . ccp ( 200 , 0 ) ) , cc . CallFunc . create ( this . _grossini , this . removeFromParentAndCleanup , true ) , null ) ; this . _grossini . runAction ( action ) ; }
function setup ( ) { var m = target , s = scene , i = index ; do { m . index = i ; m . scene = s ; i = s . parentIndex ; s = s . parent ; } while ( m = m . parent ) ; }
function mousedown ( d ) { target = this ; index = target . index ; scene = target . scene ; var m = this . mouse ( ) ; v1 = pv . vector ( d . x , d . y ) . minus ( m ) ; p = d ; p . fixed = true ; }
function mousemove ( ) { if ( ! target ) return ; setup ( ) ; var m = target . mouse ( ) ; p . x = v1 . x + m . x ; p . y = v1 . y + m . y ; }
function map ( array , f ) { var o = { } ; return f ? array . map ( function ( d , i ) { o . index = i ; return f . call ( o , d ) ; } ) : array . slice ( ) ; }
function ( array , f ) { var norm = map ( array , f ) , sum = pv . sum ( norm ) ; for ( var i = 0 ; i < norm . length ; i ++ ) norm [ i ] /= sum ; return norm ; }
function ( array , f ) { if ( f == pv . index ) return ( array . length - 1 ) / 2 ; array = map ( array , f ) . sort ( pv . naturalOrder ) ; if ( array . length % 2 ) return array [ Math . floor ( array . length / 2 ) ] ; var i = array . length / 2 ; return ( array [ i - 1 ] + array [ i ] ) / 2 ; }
function ( array , f ) { if ( arguments . length ) { r = ( array instanceof Array ) ? ( ( arguments . length > 1 ) ? map ( array , f ) : array ) : Array . prototype . slice . call ( arguments ) ; if ( typeof r [ 0 ] == "string" ) r = r . map ( pv . color ) ; return this ; } return r ; }
function boxEdgeLength ( i , j ) { edge = new THREE . Vector3 ( ) . sub ( toCanvasCoords ( boundbox . geometry . vertices [ axesindicies [ i ] [ j ] [ 0 ] ] ) , toCanvasCoords ( boundbox . geometry . vertices [ axesindicies [ i ] [ j ] [ 1 ] ] ) ) ; return edge . length ( ) ; }
function ( ) { map = new GMap2 ( document . getElementById ( "map_canvas" ) ) ; map . setCenter ( new GLatLng ( 37.41 , - 122.08 ) , 1 ) ; map . addControl ( new GSmallMapControl ( ) ) ; map . addControl ( new GMapTypeControl ( ) ) ; }
function ( subject ) { if ( this . _subject !== null ) { this . destroy ( ) ; } this . _subject = $ ( subject ) ; this . setValue ( this . getValue ( ) ) ; }
function ( text ) { this . _elem = $ ( '<a/>' , { 'class' : this . UI_CLASS , text : text , href : 'javascript:;' , click : jQuery . proxy ( this . doAction , this ) } ) ; }
function ( editableValue ) { this . _editableValue = editableValue ; window . wikibase . ui . Toolbar . Group . prototype . _init . call ( this ) ; }
function updateCurrentTasteProfileID ( _catID ) { console . log ( "in updateCurrentTasteProfileID" ) ; tpID = _catID ; localStorage [ "tpID" ] = tpID ; $ ( "#_catalog_id" ) . text ( "(" + tpID + ")" ) ; var siteURL = "http://" + apiHost + "/api/v4/catalog/read?api_key=" + apiKey + "&id=" + tpID + "&results=100" ; $ ( '._en_catalog_site' ) . show ( ) . children ( ) . attr ( 'href' , siteURL ) ; }
function ( data ) { console . log ( "=== in makePlaylist callback; received a response" ) ; var response = data . response ; sessionId = response . session_id ; $ ( "#_session_id" ) . val ( sessionId ) ; var siteURL = "http://" + apiHost + "/api/v4/playlist/dynamic/info?api_key=" + apiKey + "&session_id=" + sessionId ; $ ( '._en_site' ) . show ( ) . children ( ) . attr ( 'href' , siteURL ) ; $ ( "a._history_url" ) . attr ( "href" , "http://developer.echonest.com" ) ; console . log ( "Session ID = " + sessionId ) ; getNextSong ( ) ; }
function ( data ) { var response = data . response ; console . log ( "name is " + response . name ) ; console . log ( "cat id is " + response . id ) ; if ( response . id ) { updateCurrentTasteProfileID ( response . id ) ; attachCustomAttrsToCatalog ( tpID ) ; retrieveListOfProfiles ( ) ; } else { console . log ( "Error in creating new taste profile" ) ; } }
function ( ev ) { console . log ( util . inspect ( ev , null , true ) ) ; console . log ( 'contract ' + ev . ctid + ' has emptied' ) ; console . log ( util . inspect ( ct . status ( ) , null , true ) ) ; ct . abandon ( ) ; ct . removeAllListeners ( ) ; ct = null ; }
function ( ) { var diffNum = $ ( this ) . attr ( "value" ) ; console . log ( "diffNum" , diffNum ) ; console . log ( "list" , rawDiffsList ) ; console . log ( "entry" , rawDiffsList [ diffNum ] ) ; if ( $ ( this ) . is ( ":checked" ) ) { appliedDiffs . push ( rawDiffsList [ diffNum ] ) ; } else { appliedDiffs . splice ( appliedDiffs . indexOf ( rawDiffsList [ diffNum ] ) , 1 ) ; } }
function ( index ) { if ( ! this . blokz ) { var parent = this . contentScrolled ( ) ; this . blokz = ( function ( $ ) { return $ ( ".block" , parent ) ; } ) ( jQuery ) ; } return this . blokz . get ( index ) ; }
function ( from ) { while ( from > 0 && ( ! this . getBlock ( from ) || this . scrollPos ( ) < this . blockPosition ( from ) ) ) { from -= 1 ; } var addingActivated ; while ( this . scrollPos ( ) > this . blockPosition ( from ) + this . blockHeight ( ) ) { from += 1 ; addingActivated = true ; } if ( addingActivated ) { from -= 1 ; } return from ; }
function ( id , content ) { return ( function ( $ ) { return $ ( '<tr id="' + id + '" class="loader-placeholder" style="height: ' + ( this . blockSize * this . rowHeight ) + 'px">' + content + '</tr>' ) ; } ) ( jQuery ) ; }
function ( $ ) { return $ ( "#" + this . id ) ; }
function onExpr ( expr ) { if ( expr instanceof PropertyExpression && expr . getIdentifierToken ( ) . getValue ( ) == "length" && expr . getExpr ( ) instanceof LocalExpression && this . _typeIsArray ( expr . getExpr ( ) . getType ( ) . resolveIfNullable ( ) ) ) { local = expr . getExpr ( ) . getLocal ( ) ; return false ; } return expr . forEachExpression ( onExpr ) ; }
function ( ) { self . img_src = $ ( this ) . data ( 'url' ) ; self . set ( ) ; return false ; }
function ( data ) { self . dialog . html ( data ) ; self . dialog . dialog ( 'open' ) ; $ . CMS . enable_uploader ( ) ; }
function ( ) { sketch ( { width : 200 , height : 300 , canvas : document . getElementById ( 'canvas' ) , draw : function ( ctx , images ) { ctx . fillStyle = '#0f0' ; ctx . fillRect ( 0 , 0 , 50 , 50 ) ; } } ) ; }
function displaySlide ( n ) { n = Math . min ( n , slides . length - 1 ) ; n = Math . max ( n , 0 ) ; var s = slides . eq ( n ) ; var top = s . offset ( ) . top ; var padding = { "DIV" : s . offset ( ) . top , "H1" : 150 , "H2" : 20 } [ slides [ n ] . tagName ] ; $ ( "body" ) . scrollTop ( top - padding ) ; }
function ( ) { if ( callback . close ) { callback . close ( ) ; } for ( i = 0 ; i < fieldsLength ; i ++ ) { fields [ i ] . val ( '' ) . removeAttr ( 'checked' ) . removeAttr ( 'selected' ) ; } }
function ( ) { for ( i = 0 ; i < fieldsLength ; i ++ ) { fields [ i ] . change ( ) ; } fields [ 0 ] [ 0 ] . setSelectionRange ( 0 , 0 ) ; $form . isValid ( 'reset' ) ; }
function createDialog ( name , fieldDefinitions ) { var $dialogNode , proxy ; $dialogNode = $ ( '<div id=\"' + name + '-dialog\" title=\"' + t10n [ name + "Title" ] + '\">' ) ; if ( fieldDefinitions ) { proxy = initFormDialog ( $dialogNode , fieldDefinitions ) ; } else { proxy = initDialog ( $dialogNode ) ; } return function ( buttonNames , text ) { proxy . selectButtons ( buttonNames ) ; proxy . setText ( text ) ; return proxy ; } ; }
function ( ) { var select = "<select class=\"" + this . name + "\">" , optionsLength = this . options . length , i ; select . className = this . name ; for ( i = 0 ; i < optionsLength ; i += 1 ) { select += "<option value=\"" + this . options [ i ] [ 0 ] + "\">" + this . options [ i ] [ 1 ] + "</option>" ; } return select + "</select>" ; }
function isValidDatatype ( cssClass , changeDatamodeSelect ) { if ( ! Editor . extractDataType ( cssClass , changeDatamodeSelect ) ) { ME . dialog . notice ( [ 'Ok' ] , 'Datamode not found. Please specify a valid datamode' ) . dialog ( 'open' ) ; } else { return true ; } }
function ( ) { $ ( 'body' ) . on ( 'click.button.data-api' , '[data-toggle^=button]' , function ( e ) { var $btn = $ ( e . target ) if ( ! $btn . hasClass ( 'btn' ) ) $btn = $btn . closest ( '.btn' ) $btn . button ( 'toggle' ) } ) }
function ( element , options ) { this . $element = $ ( element ) this . options = $ . extend ( { } , $ . fn . collapse . defaults , options ) if ( this . options . parent ) { this . $parent = $ ( this . options . parent ) } this . options . toggle && this . toggle ( ) }
function ( ) { this [ this . $element . hasClass ( 'in' ) ? 'hide' : 'show' ] ( ) }
function ( ) { var $this = $ ( this ) , data = $this . data ( 'collapse' ) , options = typeof option == 'object' && option if ( ! data ) $this . data ( 'collapse' , ( data = new Collapse ( this , options ) ) ) if ( typeof option == 'string' ) data [ option ] ( ) }
function ( ) { if ( ! this . $tip ) { this . $tip = $ ( this . options . template ) } return this . $tip }
function ( ) { var $this = $ ( this ) , data = $this . data ( 'scrollspy' ) , options = typeof option == 'object' && option if ( ! data ) $this . data ( 'scrollspy' , ( data = new ScrollSpy ( this , options ) ) ) if ( typeof option == 'string' ) data [ option ] ( ) }
function ( ) { var $spy = $ ( this ) $spy . scrollspy ( $spy . data ( ) ) }
function ( element ) { this . element = $ ( element ) }
function next ( ) { $active . removeClass ( 'active' ) . find ( '> .dropdown-menu > .active' ) . removeClass ( 'active' ) element . addClass ( 'active' ) if ( transition ) { element [ 0 ] . offsetWidth element . addClass ( 'in' ) } else { element . removeClass ( 'fade' ) } if ( element . parent ( '.dropdown-menu' ) ) { element . closest ( 'li.dropdown' ) . addClass ( 'active' ) } callback && callback ( ) }
function getUserImage ( ) { var image ; console . log ( 'get user image' ) ; FB . api ( { method : 'fql.query' , query : 'SELECT pic_square FROM user WHERE uid=me()' } , function ( response ) { userImage = response [ 0 ] . pic_square ; } ) ; return userImage ; }
function ( ) { var data = { text : $ ( this ) . siblings ( '.feedback-input' ) . val ( ) , image : getUserImage ( ) } ; console . log ( data ) ; $ ( this ) . siblings ( '#comments' ) . append ( Mustache . render ( commentTemplate , data ) ) ; }
function ( protoProps , classProps ) { var parent = this ; if ( protoProps . constructorName && ! protoProps . hasOwnProperty ( 'constructor' ) ) { eval ( "protoProps.constructor = function " + protoProps . constructorName + " () { parent.apply(this, arguments) };" ) ; } return originalExtend . call ( parent , protoProps , classProps ) ; }
function ( events , callback , context ) { originalOn . apply ( this , arguments ) ; if ( Coccyx . enforceContextualBinding && ! context ) throw "Coccyx: Backbone event binding attempted without a context." if ( context && context . registerEventDispatcher ) context . registerEventDispatcher ( this ) ; }
function ( cachefile ) { var cache ; var rawcache ; if ( path . existsSync ( cachefile ) === false ) { return false ; } log . debug ( 'loading cache file %s' , cachefile ) ; rawcache = fs . readFileSync ( cachefile , 'utf8' ) ; cache = JSON . parse ( rawcache ) ; return cache ; }
function ( ) { $ ( this ) . find ( '.zoomer' ) . stop ( false , true ) . fadeOut ( '500' ) ; $ ( this ) . find ( '.zoomlens' ) . stop ( false , true ) . fadeOut ( '500' ) ; if ( options . zoomIndicator ) { $ ( this ) . find ( '.zoomindicator' ) . clearQueue ( ) . delay ( 250 ) . fadeIn ( 150 ) ; } }
function ( result ) { var fields = new Object ; var color = '#900' ; var lines = result . split ( '\n' ) ; for ( var i = 0 ; i < lines . length ; i ++ ) { var line = lines [ i ] . split ( "," ) ; var name = line [ 0 ] . trim ( ) ; if ( name . length > 0 ) fields [ name ] = line . slice ( 1 ) ; } addRun ( color , fields ) ; }
function ( ) { app . use ( express . bodyParser ( ) ) ; app . use ( express . methodOverride ( ) ) ; app . use ( app . router ) ; app . use ( express . static ( '../../client/cofetch' ) ) ; app . use ( express . logger ( { format : ':method :url' } ) ) ; }
function ( ) { pages . first ( ) . show ( ) ; }
function ( success ) { if ( success === false ) { if ( ui . showLogin ( ) === true ) { ui . addMessage ( 'Type /login to show the login screen' , 'notification' ) ; } else { ui . addMessage ( 'Use /nick user password to log in with jabbr' , 'notification' ) ; ui . addMessage ( 'To enable janrain login, setup the missing values in web.config' , 'notification' ) ; } } chat . getCommands ( ) . done ( function ( commands ) { ui . setCommands ( commands ) ; } ) ; }
function ( err , msg ) { if ( err ) { that . emit ( 'error' , err ) ; } else if ( msg ) { that . emit ( 'message' , msg [ 0 ] , function ( ) { that . del ( msg [ 0 ] ) ; } ) ; } }
function ( DebuggerLogAssembly ) { var globalClock = { p_id : 0 } ; DebuggerLogAssembly . initialize ( globalClock ) ; DebuggerLogAssembly . connect ( ) ; function detach ( ) { console . log ( "detach?" ) ; } window . addEventListener ( 'unload' , detach , false ) ; }
function ( assert ) { var doc = libxml . Document ( ) ; var root = doc . node ( 'root' ) . node ( 'child-one' ) . parent ( ) . node ( 'child-two' ) ; assert . equal ( 'child-one' , doc . child ( 1 ) . name ( ) ) ; assert . equal ( 'child-two' , doc . child ( 2 ) . name ( ) ) ; assert . done ( ) ; }
function read_sharp ( ) { skip ( "#" ) ; switch ( peek ( ) ) { case "\\" : next ( ) ; return token ( "char" , read_char ) ; case "/" : return token ( "regexp" , read_regexp ) ; case "(" : return token ( "vector" , read_list ) ; case "'" : next ( ) ; return token ( "function" , read_symbol ) ; default : return token ( "unknown" , read_token ) ; } }
function ( ) { var documentHeader = this . _srcDocument . find ( { elementType : "HTMLElement" , tag : 'head' } , true ) ; var scriptsInHeader = documentHeader . find ( { elementType : "HTMLElement" , tag : 'script' } ) ; for ( var i = 0 ; i < scriptsInHeader . length ; i ++ ) { var text = scriptsInHeader [ i ] . getText ( ) ; if ( text . indexOf ( "dojo.require" ) > - 1 ) return scriptsInHeader [ i ] ; } return null ; }
function ( v ) { if ( ! isNaN ( v ) ) { velocity = zap . clamp ( v , 0 , this . max_velocity || Infinity ) ; var th = this . a / 180 * Math . PI ; this . vx = v * Math . cos ( th ) ; this . vy = v * Math . sin ( th ) ; } }
function ( ) { WebInspector . SettingsTab . call ( this ) ; var p = this . _appendSection ( ) ; p . appendChild ( this . _createUserAgentControl ( ) ) ; if ( Capabilities . canOverrideDeviceMetrics ) p . appendChild ( this . _createDeviceMetricsControl ( ) ) ; p . appendChild ( this . _createCheckboxSetting ( WebInspector . UIString ( "Emulate touch events" ) , WebInspector . settings . emulateTouchEvents ) ) ; }
function ( ) { if ( WebInspector . settings . deviceMetrics . get ( ) ) this . _deviceMetricsChanged ( ) ; WebInspector . settings . deviceMetrics . addChangeListener ( this . _deviceMetricsChanged , this ) ; WebInspector . settings . deviceFitWindow . addChangeListener ( this . _deviceMetricsChanged , this ) ; }
function ( ) { var ast = jsp . parse ( orig_code ) ; ast = pro . ast_mangle ( ast ) ; ast = pro . ast_squeeze ( ast ) ; var final_code = pro . gen_code ( ast ) ; out . write ( final_code ) ; out . end ( ) ; }
function ( chunk ) { res . write ( chunk ) ; }
function ( error ) { next ( error ) ; }
function processSegments ( segments , onSuccess , onError , onNotFound ) { var params = { resultStream : null } var nexts = [ ] ; var context = { headers : { } , cacheable : false } for ( var i = 0 ; i < segments . length ; i ++ ) { nexts [ i ] = getProcessSegment ( segments [ i ] , i + 1 , onSuccess , onError , onNotFound , params , nexts , context ) ; } nexts [ 0 ] ( ) ; }
function ( f ) { if ( f . id !== undefined && f . id !== 'forEach' && f . id !== '' ) { Ext . get ( f . id ) . dom . style . border = '1px solid red' ; var ef = Ext . get ( f . id + '_error' ) ; if ( ef ) { ef . innerHTML = f . msg ; } this . fields . push ( f . id ) ; } }
function ( e ) { if ( e == 'yes' ) { var a = Ext . urlEncode ( o . params || { action : o . action } ) ; var s = 'index.php?id=' + id + '&' + a ; location . href = s ; } }
function ( ) { app . use ( express . errorHandler ( { dumpExceptions : true , showStack : true } ) ) ; db = require ( 'mongoskin' ) . db ( 'localhost:27017/friends' ) ; app . set ( 'view options' , { pretty : true } ) ; }
function ( er , values ) { if ( er ) return callback ( er ) LOG . info ( 'FCGI values: %j' , values ) var server = http . createServer ( fcgi_handler ( port , host , socket , socket_path ) ) server . listen ( port , host ) return callback ( null ) }
get supportsPrinting ( ) { var canvas = document . createElement ( 'canvas' ) ; return 'mozPrintCallback' in canvas ; } ,
function pdfViewSetupBeforePrint ( ) { if ( ! this . supportsPrinting ) { var printMessage = mozL10n . get ( 'printing_not_supported' , null , 'Warning: Printing is not supported by this browser.' ) ; alert ( printMessage ) ; return ; } for ( var i = 0 , ii = this . pages . length ; i < ii ; ++ i ) { this . pages [ i ] . beforePrint ( ) ; } }
function ( ob , string ) { output = { } ; var propList = string . split ( ',' ) ; for ( var i = 0 ; i < propList . length ; i += 1 ) { output [ propList [ i ] ] = ob [ propList [ i ] ] ; } return output ; }
function ( ) { if ( arguments . length < 1 ) { throw 'ur doin it wrong. initVal function requires > 1 arguments' } for ( var i = 0 ; i < arguments . length ; i += 1 ) { if ( arguments [ i ] !== undefined && arguments [ i ] !== null ) { return arguments [ i ] ; } } return arguments [ i ] ; }
function ( point , bounds ) { for ( var d = 0 ; d < point . length ; d += 1 ) { if ( point [ d ] < bounds [ 0 ] [ d ] || point [ d ] > bounds [ 1 ] [ d ] ) { return false ; } } return true ; }
function ( x , y , rad ) { var length = Math . sqrt ( ( x * x ) + ( y * y ) ) ; var currentRad = Math . atan2 ( x , y ) ; x = Math . sin ( currentRad - rad ) * length ; y = Math . cos ( currentRad - rad ) * length ; var output = [ x , y ] ; return output ; }
function ( o ) { o . scene = this ; if ( o . onAdd !== undefined ) { o . onAdd ( ) ; } this . rQ . push ( o ) ; }
function ( args ) { var t = this ; if ( t === window ) { throw 'You must use the `new` keyword when calling a Constructor Method!' ; } var args = args || { } ; t . fov = args . fov || 550 ; t . clipNear = args . clipNear || t . fov ; t . clipFar = args . clipFar || - 1000 ; t . pos = args . pos || [ 0 , 0 , 0 ] ; t . rot = args . rot || [ 0 , 0 , 0 ] ; }
function ( args ) { if ( this === window ) { throw 'JIM TYPE ERROR' ; } if ( arguments . length > 1 ) { throw 'ob3D expects only one param, an object with the named arguments.' ; } var args = args || { } ; NPos3d . blessWith3DBase ( this , args ) ; return this ; }
function ( string ) { this . q [ string ] = { start : false , stop : false , diff : false } ; rec = this . q [ string ] ; var now = new Date ( ) ; rec . start = now . getTime ( ) ; }
function ( string ) { rec = this . q [ string ] ; var now = new Date ( ) ; rec . stop = now . getTime ( ) ; rec . diff = rec . stop - rec . start ; console . log ( string , rec . diff ) ; }
function ( target , date , withDate ) { var inst = this . _getInst ( target ) , tp_inst = this . _get ( inst , 'timepicker' ) ; $ ( target ) . datepicker ( 'getDate' ) ; if ( tp_inst ) { tp_inst . _defaults . showTimepicker = false ; tp_inst . _updateDateTime ( inst ) ; } }
function ( target , date , withDate ) { var inst = this . _getInst ( target ) , tp_inst = this . _get ( inst , 'timepicker' ) ; $ ( target ) . datepicker ( 'getDate' ) ; if ( tp_inst ) { tp_inst . _defaults . showTimepicker = true ; tp_inst . _addTimePicker ( inst ) ; tp_inst . _updateDateTime ( inst ) ; } }
function ( target , date ) { var inst = this . _getInst ( target ) , tp_date = ( date instanceof Date ) ? new Date ( date . getTime ( ) ) : date ; this . _updateDatepicker ( inst ) ; this . _base_setDateDatepicker . apply ( this , arguments ) ; this . _setTimeDatepicker ( target , tp_date , true ) ; }
function ( test ) { test . expect ( 2 ) ; var conn = cfg . mysql_libmysqlclient . createConnectionSync ( cfg . host , cfg . user , cfg . password , cfg . database ) , res ; test . ok ( conn , "mysql_libmysqlclient.createConnectionSync(host, user, password, database)" ) ; test . equals ( typeof conn . statSync ( ) , "string" , "typeof conn.statSync() is a string" ) ; conn . closeSync ( ) ; test . done ( ) ; }
function ( ) { var wh = window . innerHeight ; var hh = $ ( "#header" ) . height ( ) ; $ ( "#main-menu" ) . css ( 'height' , wh - hh ) ; }
function ( error , job_in_progress ) { if ( error ) { console . log ( util . inspect ( error , false , 3 , true ) ) ; return ; } if ( job_in_progress ) { self . _status = "processing" ; self . _processing = job_in_progress ; self . _heartbeats = 0 ; job_in_progress . o && self . _broadcast ( job_in_progress . o , { "command" : "processJob" , "params" : job_in_progress } ) ; } printHeartbeat ( ) ; }
function ( error , upd ) { if ( error ) { console . log ( util . inspect ( error , false , 3 , true ) ) ; return ; } console . log ( "[processing] job " + job . _id . toString ( ) ) ; self . _status = "processing" ; self . _processing = upd ; upd . o && self . _broadcast ( upd . o , { "command" : "processJob" , "params" : upd } ) ; }
function ( error , documents ) { if ( error ) { console . log ( util . inspect ( error , false , 3 , true ) ) ; return callback && callback ( ) ; } self . _broadcast ( owner , { "command" : "scheduledJob" , "params" : ( documents && documents [ 0 ] ) || { } } ) ; return callback && callback ( ) ; }
function ( error ) { if ( error ) { console . log ( error . message ) ; console . log ( error . stack ) ; console . log ( util . inspect ( error , false , 3 , true ) ) ; return ; } }
function ( request , response ) { var params = { q : $ ( '#customer_search' ) . val ( ) , authenticity_token : encodeURIComponent ( $ ( 'meta[name=csrf-token]' ) . attr ( "content" ) ) } $ . get ( Spree . routes . user_search + '&' + jQuery . param ( params ) , function ( data ) { result = prep_user_autocomplete_data ( data ) response ( result ) ; } ) ; }
function ( ) { equals ( col . first ( ) , a , "a should be first" ) ; equals ( col . last ( ) , d , "d should be last" ) ; col . comparator = function ( model ) { return model . id ; } ; col . sort ( ) ; equals ( col . first ( ) , d , "d should be first" ) ; equals ( col . last ( ) , a , "a should be last" ) ; equals ( col . length , 4 ) ; }
function ( ) { equals ( col . get ( 0 ) , d ) ; equals ( col . get ( 2 ) , b ) ; equals ( col . getByCid ( col . first ( ) . cid ) , col . first ( ) ) ; }
function ( ) { var col = new Backbone . Collection ( ) ; var MongoModel = Backbone . Model . extend ( { idAttribute : '_id' } ) ; var model = new MongoModel ( { _id : 100 } ) ; col . add ( model ) ; equals ( col . get ( 100 ) , model ) ; model . set ( { _id : 101 } ) ; equals ( col . get ( 101 ) , model ) ; }
function ( ) { var removed = otherRemoved = null ; col . bind ( 'remove' , function ( model ) { removed = model . get ( 'label' ) ; } ) ; otherCol . bind ( 'remove' , function ( ) { otherRemoved = true ; } ) ; col . remove ( e ) ; equals ( removed , 'e' ) ; equals ( col . length , 4 ) ; equals ( col . first ( ) , d ) ; equals ( otherRemoved , null ) ; }
function ( ) { var e = new Backbone . Model ( { title : 'Othello' } ) ; e . sync = function ( method , model , options ) { throw "should not be called" ; } ; var colE = new Backbone . Collection ( [ e ] ) ; var colF = new Backbone . Collection ( [ e ] ) ; e . destroy ( ) ; ok ( colE . length == 0 ) ; ok ( colF . length == 0 ) ; equals ( null , e . collection ) ; }
function ( ) { var model = col . create ( { label : 'f' } ) ; equals ( lastRequest [ 0 ] , 'create' ) ; equals ( lastRequest [ 1 ] , model ) ; equals ( model . get ( 'label' ) , 'f' ) ; equals ( model . collection , col ) ; }
function ( ) { var ValidatingModel = Backbone . Model . extend ( { validate : function ( attrs ) { return "fail" ; } } ) ; var ValidatingCollection = Backbone . Collection . extend ( { model : ValidatingModel } ) ; var col = new ValidatingCollection ( ) ; equals ( col . create ( { "foo" : "bar" } ) , false ) ; }
function ( ) { var ValidatingModel = Backbone . Model . extend ( { validate : function ( attrs ) { return "fail" ; } } ) ; var ValidatingCollection = Backbone . Collection . extend ( { model : ValidatingModel } ) ; var flag = false ; var callback = function ( model , error ) { flag = true ; } ; var col = new ValidatingCollection ( ) ; col . create ( { "foo" : "bar" } , { error : callback } ) ; equals ( flag , true ) ; }
function ( ) { var Model = Backbone . Model . extend ( { initialize : function ( ) { this . one = 1 ; equals ( this . collection , collection ) ; } } ) ; var model = new Model ( { } , { collection : collection } ) ; equals ( model . one , 1 ) ; equals ( model . collection , collection ) ; }
function ( ) { var Model = Backbone . Model . extend ( { initialize : function ( attributes , options ) { this . one = options . one ; } } ) ; var model = new Model ( { } , { one : 1 } ) ; equals ( model . one , 1 ) ; }
function ( ) { equals ( doc . url ( ) , '/collection/1-the-tempest' ) ; doc . collection . url = '/collection/' ; equals ( doc . url ( ) , '/collection/1-the-tempest' ) ; doc . collection = null ; var failed = false ; try { doc . url ( ) ; } catch ( e ) { failed = true ; } equals ( failed , true ) ; doc . collection = collection ; }
function ( ) { var Model = Backbone . Model . extend ( { urlRoot : '/collection' } ) ; var model = new Model ( ) ; equals ( model . url ( ) , '/collection' ) ; model . set ( { id : '+1+' } ) ; equals ( model . url ( ) , '/collection/%2B1%2B' ) ; }
function ( ) { var i = 0 ; var counter = function ( ) { i ++ ; } ; var model = new Backbone . Model ( { a : 1 } ) ; model . bind ( "change:a" , counter ) ; model . set ( { a : 2 } ) ; model . unset ( 'a' ) ; model . unset ( 'a' ) ; equals ( i , 2 , 'Unset does not fire an event for missing attributes.' ) ; }
function ( ) { var MongoModel = Backbone . Model . extend ( { idAttribute : '_id' } ) ; var model = new MongoModel ( { id : 'eye-dee' , _id : 25 , title : 'Model' } ) ; equals ( model . get ( 'id' ) , 'eye-dee' ) ; equals ( model . id , 25 ) ; model . unset ( '_id' ) ; equals ( model . id , undefined ) ; }
function ( ) { var changed ; var model = new Backbone . Model ( { name : "Model" } ) ; model . bind ( "change:name" , function ( ) { changed = true ; } ) ; model . clear ( ) ; equals ( changed , true ) ; equals ( model . get ( 'name' ) , undefined ) ; }
function ( ) { ok ( model . hasChanged ( 'name' ) , 'name changed' ) ; ok ( ! model . hasChanged ( 'age' ) , 'age did not' ) ; ok ( _ . isEqual ( model . changedAttributes ( ) , { name : 'Rob' } ) , 'changedAttributes returns the changed attrs' ) ; equals ( model . previous ( 'name' ) , 'Tim' ) ; ok ( _ . isEqual ( model . previousAttributes ( ) , { name : "Tim" , age : 10 } ) , 'previousAttributes is correct' ) ; }
function ( ) { var changed = 0 ; var attrs = { id : 1 , label : 'c' } ; var obj = new Backbone . Model ( attrs ) ; obj . bind ( 'change' , function ( ) { changed += 1 ; } ) ; obj . set ( attrs ) ; equals ( changed , 0 ) ; }
function ( idx , toolId , file , fileOutput ) { if ( ! _ . isUndefined ( processableTools [ toolId + 1 ] ) ) { processableTools [ toolId + 1 ] ( idx , file , fileOutput ) ; } else { compressedFileSizes [ file ] = String ( fs . readFileSync ( fileOutput ) ) . length ; processNextFile ( idx , file ) ; } }
function ( ) { switch ( this . state ) { case 'released' : return this . statedata ; break ; case 'oncall' : case 'wrapup' : case 'ringing' : case 'outgoing' : case 'precall' : case 'warmtransfer' : return '<img src="/images/' + this . statedata . type + '.png" />' + this . statedata . client default : return '' ; } }
function ( inProf ) { this . cells [ 1 ] . innerHTML = inProf . agentsCount ; this . cells [ 2 ] . innerHTML = inProf . idle ; this . cells [ 3 ] . innerHTML = inProf . oncall ; this . cells [ 4 ] . innerHTML = inProf . released ; this . cells [ 5 ] . innerHTML = inProf . wrapup ; }
function ( inAgent ) { var nowTime = Math . floor ( new Date ( ) . getTime ( ) / 1000 ) ; tr . cells [ 1 ] . style . backgroundImage = 'url("/images/' + inAgent . state + '.png")' ; tr . cells [ 2 ] . innerHTML = formatseconds ( nowTime - inAgent . lastchange ) ; tr . cells [ 3 ] . innerHTML = Math . floor ( inAgent . calcUtilPercent ( ) ) + '%' ; tr . cells [ 4 ] . innerHTML = inAgent . statedataDisplay ( ) ; }
function ( ) { var wrapper ; var card ; wrapper = Ext . getCmp ( 'typo3-contentContainerWrapper' ) ; if ( wrapper ) { card = wrapper . getLayout ( ) . activeItem ; if ( card . id == this . id ) { return this . body . dom . src ; } else if ( typeof card . getUrl == 'function' ) { return card . getUrl ( ) ; } else { return this . url ; } } ; }
function ( start_date , num_workdays ) { return start_date . addDays ( num_workdays ) ; }
function ( ) { stop ( ) ; var data = { test : [ { a : 1 } , { a : 2 } , { a : 3 } ] } ; post ( '/partialtest' , data , function ( data ) { equal ( data , '<div>1</div><div>2</div><div>3</div>' , 'data is an array' ) ; start ( ) ; } ) ; }
function ( ) { stop ( ) ; post ( '/layouttest' , function ( data ) { equal ( data , 'mylayout requested view mylayout' , 'served html is correct' ) ; start ( ) ; } ) ; }
function ( ) { stop ( ) ; server . close ( ) ; server = createServer ( { 'view options' : { layout : true } , views : options . root + '/2' } ) ; post ( '/views/test' , { mylocal : "mylocal" } , function ( data ) { equal ( data , 'abc mylocal' , 'template and layout rendered correctly' ) ; server . close ( ) ; server = createServer ( ) ; start ( ) ; } ) ; }
function ( ) { currentDay = slider . getValue ( ) ; setInterval ( function ( ) { sigInst . HideWrongTimeNodes ( + 1 ) } , 500 ) ; }
function playAnimation ( ) { currentDay = slider . getValue ( ) ; if ( currentDay < slider . getMax ( ) ) { setInterval ( function ( ) { sigInst . HideWrongTimeNodes ( + 1 ) } , 1000 ) ; } else { slider . setValue ( 0 ) ; } }
function ( event , ui ) { $ ( '#search-vocab-field' ) . val ( ui . item . label ) ; vocabLoadConcept ( ui . item . uri , ui . item . vocab ) ; vocabLoadTree ( ui . item . uri , ui . item . vocab ) ; }
function ( event , ui ) { $ ( '#search-vocab-field' ) . val ( ui . item . label ) ; vocabLoadConcept ( ui . item . uri , ui . item . vocab ) ; vocabLoadTree ( ui . item . uri , ui . item . vocab ) ; }
function ( ) { var id = $ ( this ) . attr ( 'id' ) ; var term = '#' + search_term + '/p' + id ; changeHashTo ( formatSearch ( search_term , id , classFilter ) ) ; page = id ; }
function ( event , ui ) { $ ( '#search-vocab-field' ) . val ( ui . item . label ) ; if ( view == 'anzsrcfor' ) { subjectFilter = encodeURIComponent ( ui . item . uri ) ; } else subjectFilter = ui . item . label ; changeHashTo ( formatSearch ( search_term , 1 , classFilter ) ) ; }
function ( e , scope ) { var parser = scope ; parser . emit ( 'error' , e ) ; parser . errors . push ( e ) ; }
function ( type ) { if ( console && typeof console . log == "function" ) console . log ( 'draw' , this . canvas ) if ( ! this . ctx ) return this ; return this . update ( ) ; }
function selectAllRadio ( oInvertCheckbox , oForm , sMask , sValue ) { for ( var i = 0 ; i < oForm . length ; i ++ ) if ( oForm [ i ] . name . substr ( 0 , sMask . length ) == sMask && oForm [ i ] . value == sValue ) oForm [ i ] . checked = true ; }
function ( ) { document . getElementById ( this . opt . sImageId ) . src = this . opt . sImagesUrl + "/" + ( this . bCollapsed ? this . opt . sImageCollapsed : this . opt . sImageExpanded ) ; document . getElementById ( this . opt . sContainerId ) . style . display = this . bCollapsed ? '' : 'none' ; this . bCollapsed = ! this . bCollapsed ; }
function _showPopup ( marker , panTo ) { var latlng = marker . getLatLng ( ) ; var popup = marker . _popup . setLatLng ( latlng ) ; DATA . map . openPopup ( popup ) ; if ( panTo ) { DATA . map . panTo ( latlng ) ; } }
function ( ) { spyOn ( ItemView . prototype , "onRender" ) ; collection = new Collection ( ) ; collectionView = new CollectionView ( { itemView : ItemView , collection : collection } ) ; collectionView . render ( ) ; spyOn ( collectionView , "appendHtml" ) . andCallThrough ( ) ; model = new Model ( { foo : "bar" } ) ; collection . add ( model ) ; }
function ( ) { var collection = new Collection ( ) ; collectionView = new EmptyCollectionView ( { collection : collection } ) ; collectionView . render ( ) ; closeSpy = spyOn ( EmptyView . prototype , "close" ) ; collection . add ( { foo : "wut" } ) ; }
function ( ) { var collection = new Collection ( ) ; collectionView = new EmptyCollectionView ( { collection : collection } ) ; collectionView . render ( ) ; closeSpy = spyOn ( EmptyView . prototype , "close" ) ; closeSpy . andCallThrough ( ) ; collection . reset ( [ { foo : "bar" } , { foo : "baz" } ] ) ; collection . add ( { foo : "wut" } ) ; }
function ( ) { var collection = new Collection ( [ { foo : "wut" } ] ) ; collectionView = new EmptyCollectionView ( { collection : collection } ) ; collectionView . render ( ) ; collection . remove ( collection . at ( 0 ) ) ; }
function ( promises ) { var promise ; var EmptyView = this . options . emptyView || this . emptyView ; if ( EmptyView ) { this . showingEmptyView = true ; var model = new Backbone . Model ( ) ; promise = this . addItemView ( model , EmptyView , 0 ) ; } return promise ; }
function ( ) { var EmptyView = this . options . emptyView || this . emptyView ; if ( EmptyView ) { this . showingEmptyView = true ; var model = new Backbone . Model ( ) ; this . addItemView ( model , EmptyView , 0 ) ; } }
function ( ) { var obj = { method : 'feed' , link : 'http://localhost/git/nodeFriendGuess/webapp/' , picture : 'http://fbrell.com/f8.jpg' , name : 'friendGuess!' , caption : 'a 60second game' , description : 'hat in 60 sekunden ' + this . correctAnswers + " Freunde erkannt und dabei " + this . points + " Punkte erspielt! Kannst Du mehr Freunde erkennen ?" } ; function callback ( response ) { console . log ( response ) ; } FB . ui ( obj , callback ) ; }
function ( rule , index ) { if ( index < 0 || index > this . cssRules . length ) { throw new RangeError ( "INDEX_SIZE_ERR" ) ; } this . cssRules . splice ( index , 0 , require ( './parse' ) . parse ( rule ) ) ; return index ; }
function ( wrapper ) { wn . pages . users . profiles = { } ; wn . pages . users . refresh ( ) ; wn . pages . users . setup ( ) ; wn . pages . users . role_editor = new erpnext . RoleEditor ( ) ; }
function ( ) { $card = $ ( this ) . parent ( ) ; var uid = $card . attr ( 'data-name' ) ; $card . css ( 'opacity' , 0.6 ) ; wn . call ( { method : 'utilities.page.users.users.delete' , args : { 'uid' : uid } , callback : function ( r , rt ) { if ( ! r . exc ) $card . fadeOut ( ) } } ) ; }
function ( r , rt ) { $ ( '.users-area' ) . empty ( ) ; for ( var i in r . message ) { var p = r . message [ i ] ; wn . pages . users . profiles [ p . name ] = p ; wn . pages . users . render ( p ) ; } }
function ( ) { if ( ws . readyState == ws . OPEN ) { ws . close ( ) } reopenws ( ) ; }
function ( done ) { RelMe . getLinks ( "http://localhost:4816/missing" , function ( err , links ) { should . exist ( err ) ; err . should . be . a ( "object" ) ; err . should . be . an . instanceOf ( RelMe . HTTPError ) ; err . should . have . property ( "code" ) ; err . code . should . equal ( 404 ) ; done ( ) ; } ) ; }
function ( tx ) { console . log ( note . note . style ) ; tx . executeSql ( "INSERT INTO WebKitStickyNotes (id, note, timestamp, left, top, zindex, background, width, height) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)" , [ note . id , note . text , note . timestamp , note . left , note . top , note . zIndex , note . note . style . background , note . note . style . width , note . note . style . height ] ) ; }
function addToWorkingSetAndSelect ( fullPath ) { var result = new $ . Deferred ( ) , promise = CommandManager . execute ( Commands . FILE_ADD_TO_WORKING_SET , { fullPath : fullPath } ) ; promise . done ( function ( doc ) { _fileSelectionFocus = WORKING_SET_VIEW ; _selectCurrentDocument ( ) ; result . resolve ( doc ) ; } ) . fail ( function ( err ) { result . reject ( err ) ; } ) ; return result . promise ( ) ; }
function ( sequelize , DataTypes ) { self . sequelize = sequelize self . User = sequelize . define ( 'User' , { username : { type : DataTypes . STRING } , touchedAt : { type : DataTypes . DATE , defaultValue : DataTypes . NOW } } ) }
function remoteCmd ( cmd , args , success , error ) { pm ( { target : window . parent , type : "command" , data : { cmd : cmd , args : args } , success : success , error : error } ) ; }
function ( data ) { this . defaultCaption = ig . config . text . defaultCaption ; this . showHUD = true ; var defaultWeapon = 1 ; var cameraMinY = this . showHUD ? this . hudOffset : 0 ; this . parent ( data ) ; this . tracking . trackPage ( "/game/load/level/" + this . currentLevelName ) ; this . levelTimer . reset ( ) ; if ( this . defaultCaption != "none" ) this . displayCaption ( this . defaultCaption , 7 ) ; }
function ( other ) { this . parent ( other ) ; if ( this . level ) ig . game . displayCaption ( this . level + " Hi-Score " + this . hiScore . toString ( ) . padString ( 6 ) , .2 ) ; }
function ( value ) { this . stats . time = Math . round ( this . levelTimer . delta ( ) ) ; this . stats . score = ( this . stats . doors * 50 ) + ( this . stats . kills * 5 ) ; this . parent ( value ) ; }
function ( ) { this . stats . score = ( this . stats . doors * 50 ) + ( this . stats . kills * 5 ) ; this . parent ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 525 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 547 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 681 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( event , selection ) { var position ; if ( ! event ) { return ; } if ( event . originalEvent instanceof KeyboardEvent ) { return this . _getCaretPosition ( selection ) ; } if ( event . originalEvent instanceof MouseEvent ) { return position = { top : event . pageY , left : event . pageX } ; } }
function ( range ) { var newRange , position , tmpSpan ; tmpSpan = jQuery ( "<span/>" ) ; newRange = document . createRange ( ) ; newRange . setStart ( range . endContainer , range . endOffset ) ; newRange . insertNode ( tmpSpan . get ( 0 ) ) ; position = { top : tmpSpan . offset ( ) . top , left : tmpSpan . offset ( ) . left } ; tmpSpan . remove ( ) ; return position ; }
function ( range ) { var newRange , position , tmpSpan ; tmpSpan = jQuery ( "<span/>" ) ; newRange = document . createRange ( ) ; newRange . setStart ( range . endContainer , range . endOffset ) ; newRange . insertNode ( tmpSpan . get ( 0 ) ) ; position = { top : tmpSpan . offset ( ) . top , left : tmpSpan . offset ( ) . left } ; tmpSpan . remove ( ) ; return position ; }
function ( data ) { alarm . setTime . apply ( alarm , parseTime ( data . time ) ) ; nextAlarm = alarm . getNext ( ) ; log ( 'Set to ' + nextAlarm . format ( 'HH:MM' ) ) ; socketServer . sockets . emit ( 'set' , { next : nextAlarm } ) ; }
function ( x , y ) { var item = this . itemAt ( x , y ) ; if ( item ) { delete this . items [ x + ',' + y ] ; item . remove ( ) ; this . itemSet . toFront ( ) ; } }
function ( ) { this . meta = get_local ( 'DocType' , this . doctype ) ; this . perm = get_perm ( this . doctype ) ; if ( this . meta . istable ) { this . meta . in_dialog = 1 } this . setup_print ( ) ; }
function ( ) { if ( ! this . meta . in_dialog ) { set_title ( this . meta . issingle ? this . doctype : this . docname ) ; } if ( this . frm_head ) this . frm_head . refresh ( ) ; if ( wn . ui . toolbar . recent ) wn . ui . toolbar . recent . add ( this . doctype , this . docname , 1 ) ; }
function ( ) { var f = this . page_layout . footer ; if ( f . save_area ) { if ( get_url_arg ( 'embed' ) || ( this . editable && ! this . meta . in_dialog && this . doc . docstatus == 0 && ! this . meta . istable && this . get_doc_perms ( ) [ WRITE ] ) ) { f . show_save ( ) ; } else { f . hide_save ( ) ; } } }
function ( msg ) { if ( msg . profile == window . app . profiles . DEFAULT ) { var dbg_ctx = window . window_manager_data . get_debug_context ( ) ; if ( dbg_ctx ) { var tag = window . tag_manager . set_callback ( null , set_new_debug_context , [ dbg_ctx ] ) ; ecma_debugger . requestListRuntimes ( tag , [ [ ] , 1 ] ) ; } } }
function ( msg ) { if ( msg . id == 'js_source' ) { var key = msg . key ; var value = settings [ 'js_source' ] . get ( key ) ; stop_at_settings [ key ] = value ; var msg = get_config_msg ( ) ; ecma_debugger . requestSetConfiguration ( cls . TagManager . IGNORE_RESPONSE , msg ) ; if ( msg . key == 'reformat_javascript' ) { new ConfirmDialog ( ui_strings . D_REFORMAT_SCRIPTS , function ( ) { window . runtimes . reloadWindow ( ) ; } ) . show ( ) ; } } }
function ( container ) { container . clearAndRender ( templates . network_options_main ( this . _bypass_cache , this . _track_bodies , this . _headers , this . _overrides ) ) ; this . _output = container . querySelector ( "code" ) ; this . _headerele = container . querySelector ( ".header-override-input" ) ; }
function ( container ) { container . clearAndRender ( templates . network_request_crafter_main ( this . _prev_url , this . _is_listening , this . _prev_request , this . _prev_response ) ) ; this . _urlfield = new cls . BufferManager ( container . querySelector ( "input" ) ) ; this . _input = new cls . BufferManager ( container . querySelector ( "textarea" ) ) ; this . _output = container . querySelector ( "code" ) ; }
function ( ) { return [ "div" , [ "div" , [ "span" , "class" , "ui-button" , "handler" , "reload-window" , "tabindex" , "1" ] ] , [ "p" , ui_strings . S_HTTP_INCOMPLETE_LOADING_GRAPH ] , [ "span" , " " , "class" , "close_incomplete_warning" , "handler" , "close-incomplete-warning" , "tabindex" , "1" ] , "class" , "info-box network_incomplete_warning" ] ; }
function ( id , name , view_list , default_unfolded_list ) { this . _super_createView = this . createView ; this . requierd_services = [ "ecmascript-debugger" ] ; this . createView = function ( container ) { this . _super_createView ( container ) ; var quick_find = this . getToolbarControl ( container , 'css-inspector-text-search' ) ; var search_term = window . element_style . get_search_term ( ) ; if ( quick_find && search_term ) { quick_find . value = search_term ; } } this . init ( id , name , view_list , default_unfolded_list ) ; }
function ( ) { this . requierd_services = [ "ecmascript-debugger" ] ; this . init ( id , name , container_class ) ; this . _container = null ; this . _update_layout_bound = this . update_layout . bind ( this ) ; this . _update_offsets_bound = this . update_offsets . bind ( this ) window . messages . addListener ( "setting-changed" , this . _on_setting_change . bind ( this ) ) ; }
function ( key , value , sync_switches ) { window . localStorage . setItem ( key , JSON . stringify ( this . map [ key ] = value ) ) ; if ( this . callback_map . hasOwnProperty ( key ) ) { this . callback_map [ key ] . call ( this , value ) ; } messages . post ( "setting-changed" , { id : this . view_id , key : key } ) ; }
function ( button_templates , group , view_id ) { var ret = [ "toolbar-buttons" , button_templates ] ; if ( group . type ) { ret . push ( "handler" , "toolbar-" + group . type ) ; if ( group . type === "single-select" ) { ret = ret . concat ( [ "data-single-select-name" , group . name , "data-view-id" , view_id ] ) ; } } return ret ; }
function ( switches ) { var ret = [ "toolbar-buttons" ] , i = 0 , setting = null ; ret . extend ( switches . map ( this . _switch , this ) ) ; ret . push ( "handler" , "toolbar-switch" ) ; return ret ; }
function ( id , name , container_class ) { this . requierd_services = [ "ecmascript-debugger" ] ; this . _highlighter = new VirtualTextSearch ( ) ; this . _highlight_style = this . _highlighter . get_match_style ( 'highlight' ) ; this . init ( id , name , container_class , '' , 'clear-search-hit' ) ; var clear_search_hit = this . _onscroll . bind ( this ) ; eventHandlers . scroll [ 'clear-search-hit' ] = clear_search_hit ; window . messages . addListener ( "panel-search-executed" , clear_search_hit ) ; }
function ( ) { socket . on ( 'ping' , function ( message ) { log ( 'ping' ) ; } ) ; socket . on ( 'pong' , function ( message ) { log ( 'pong' ) ; } ) ; socket . on ( 'message' , function ( message ) { this . processMessage ( message ) ; } ) ; socket . on ( 'close' , function ( message ) { playout . removeChannelListener ( this ) ; } ) ; }
function write ( str ) { if ( ! str || ! str . length ) return ; if ( str . slice ( 0 , 3 ) === '/*!' && ! ruleBuffer . length ) { output ( str ) ; return ; } ruleBuffer . push ( str ) ; if ( str === '}' ) { if ( ruleBuffer . length && ruleBuffer [ ruleBuffer . length - 2 ] !== '{' ) { output ( ruleBuffer . join ( '' ) ) ; } ruleBuffer = [ ] ; } }
function describeOperation ( name , op ) { var str = "  " + name + " (" ; str += op . method . toUpperCase ( ) + " - " ; str += ( op . authed ? "" : "not " ) + "authed" ; if ( op . args ) { str += " - " + op . args . join ( ", " ) ; } str += ")" ; logger . debug ( str ) ; }
function ( asset , error ) { if ( ! error ) { self . setValue ( asset ) ; } else { $ ( self . root ) . addClass ( 'error' ) ; self . $caption . text ( 'An error occurred' ) ; } self . _state = S_READY ; sefl . _unserializationData = null ; }
function ( ) { var overlayCenter ; if ( this . object_ . getCenter ) { overlayCenter = this . object_ . getCenter ( ) ; } else if ( this . object_ . getPosition ) { overlayCenter = this . object_ . getPosition ( ) ; } else if ( this . getBounds ) { overlayCenter = this . getBounds ( ) . getCenter ( ) ; } return overlayCenter ; }
function previousNode ( node ) { if ( node . previousSibling ) { node = node . previousSibling ; while ( node . hasChildNodes ( ) ) { node = node . lastChild ; } return node ; } if ( node . parentNode && node . parentNode . nodeType == Node . ELEMENT_NODE ) { return node . parentNode ; } return null ; }
function getNodeLength ( node ) { switch ( node . nodeType ) { case Node . PROCESSING_INSTRUCTION_NODE : case Node . DOCUMENT_TYPE_NODE : return 0 ; case Node . TEXT_NODE : case Node . COMMENT_NODE : return node . length ; default : return node . childNodes . length ; } }
function isHtmlElement ( node , tags ) { if ( typeof tags == "string" ) { tags = [ tags ] ; } if ( typeof tags == "object" ) { tags = tags . map ( function ( tag ) { return tag . toUpperCase ( ) } ) ; } return node && node . nodeType == Node . ELEMENT_NODE && isHtmlNamespace ( node . namespaceURI ) && ( typeof tags == "undefined" || tags . indexOf ( node . tagName ) != - 1 ) ; }
function isBlockNode ( node ) { return node && ( ( node . nodeType == Node . ELEMENT_NODE && [ "inline" , "inline-block" , "inline-table" , "none" ] . indexOf ( getComputedStyle ( node ) . display ) == - 1 ) || node . nodeType == Node . DOCUMENT_NODE || node . nodeType == Node . DOCUMENT_FRAGMENT_NODE ) ; }
function isEditingHost ( node ) { return node && node . nodeType == Node . ELEMENT_NODE && ( node . contentEditable == "true" || ( node . parentNode && node . parentNode . nodeType == Node . DOCUMENT_NODE && node . parentNode . designMode == "on" ) ) ; }
function isEditable ( node ) { return node && ! isEditingHost ( node ) && ( node . nodeType != Node . ELEMENT_NODE || node . contentEditable != "false" ) && ( isEditingHost ( node . parentNode ) || isEditable ( node . parentNode ) ) ; }
function ( node ) { getAncestors ( node ) . forEach ( function ( ancestor ) { if ( isEditable ( ancestor ) && isHtmlElement ( ancestor , "a" ) && ancestor . hasAttribute ( "href" ) ) { ancestor . setAttribute ( "href" , value ) ; } } ) ; }
function ( value ) { if ( value === "" ) { return ; } value = normalizeFontSize ( value ) ; if ( [ "xx-small" , "x-small" , "small" , "medium" , "large" , "x-large" , "xx-large" , "xxx-large" ] . indexOf ( value ) == - 1 && ! /^[0-9]+(\.[0-9]+)?(cm|mm|in|pt|pc)$/ . test ( value ) ) { return ; } setSelectionValue ( "fontsize" , value ) ; }
function ( ) { var node = getAllEffectivelyContainedNodes ( getActiveRange ( ) , function ( node ) { return isEditable ( node ) && node . nodeType == Node . TEXT_NODE ; } ) [ 0 ] ; if ( node === undefined ) { node = getActiveRange ( ) . startContainer ; } var pixelSize = getEffectiveCommandValue ( node , "fontsize" ) ; return getLegacyFontSize ( pixelSize ) ; }
function ( node ) { return isEditable ( node ) && ( isNonListSingleLineContainer ( node ) || isAllowedChild ( node , "p" ) || isHtmlElement ( node , [ "dd" , "dt" ] ) ) && ! getDescendants ( node ) . some ( isProhibitedParagraphChild ) ; }
function ( node ) { return isEditable ( node ) && ( ! getDescendants ( node ) . some ( isEditable ) || isHtmlElement ( node , [ "ol" , "ul" ] ) || ( isHtmlElement ( node , "li" ) && isHtmlElement ( node . parentNode , [ "ol" , "ul" ] ) ) ) ; }
function ( ) { var refNode = getAllEffectivelyContainedNodes ( getActiveRange ( ) , function ( node ) { return isEditable ( node ) && node . nodeType == Node . TEXT_NODE ; } ) [ 0 ] ; if ( typeof refNode == "undefined" ) { refNode = getActiveRange ( ) . startContainer ; } return getEffectiveCommandValue ( refNode , command ) ; }
function _moveBackwards ( node ) { if ( ! node || isVoidElement ( node ) || _isFlowNode ( node ) || GENTICS . Utils . Dom . isEditingHost ( node ) ) { return null ; } if ( node . previousSibling ) { return node . previousSibling ; } if ( node . parentNode ) { return _moveBackwards ( node . parentNode ) ; } return null ; }
function _moveForwards ( node ) { if ( ! node || isVoidElement ( node ) || _isFlowNode ( node ) ) { return null ; } if ( node . nextSibling ) { return node . nextSibling ; } if ( node . parentNode ) { return _moveForwards ( node . parentNode ) ; } return null ; }
function ( ) { var that = this ; var imagePluginUrl = Aloha . getPluginUrl ( 'image' ) ; this . settings = jQuery . extend ( true , this . defaultSettings , this . settings ) ; this . startAspectRatio = this . settings . fixedAspectRatio ; that . initializeButtons ( ) ; that . bindInteractions ( ) ; that . subscribeEvents ( ) ; }
function ( questionTitle , questionBody , callback ) { console . log ( "API - createQuestion" ) ; var body = { } ; var question = { } ; question . body = questionBody ; question . category = 'testcategory' ; question . title = questionTitle ; body . question = question ; $ . ajax ( { url : '/api/question' , type : 'POST' , dataType : 'json' , contentType : "application/json" , data : JSON . stringify ( body ) , success : function ( data ) { callback ( data ) ; } } ) }
function ( error , result ) { if ( result ) { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 0 , star : result } ) ) ; } else { response . writeHead ( 200 , { 'Content-Type' : 'application/json' } ) ; response . end ( JSON . stringify ( { errorcode : 1 , message : error } ) ) ; } }
function ( ) { countdown -- ; $ ( '#' + rand_id + '_countdown' ) . empty ( ) . append ( countdown ) ; if ( countdown == 1 ) { clearInterval ( countdown . this_interval ) ; } ; }
function ( ) { ajax_status [ x . fn_name ] . status = 'ACTIVE' ; ajax_status [ x . fn_name ] . trigger_delay = 0 ; clearTimeout ( ajax_settimeouts [ x . fn_name ] ) ; if ( x . interval != - 1 ) { ajax_settimeouts [ x . fn_name ] = setTimeout ( function ( ) { exec_ajax ( x ) ; } , x . interval ) ; console . log ( x . fn_name + ': ' + x . interval ) ; } }
function showHideAnswer ( zis ) { var id = $ ( zis ) . attr ( 'id' ) . replace ( /[^\d]/g , '' ) ; var obj = $ ( "#a" + id ) ; if ( obj . css ( 'display' ) == 'none' ) { $ ( zis ) . html ( '<span class="nobr">Hide example.</span>' ) ; obj . css ( 'display' , 'block' ) ; } else { $ ( zis ) . html ( '<span class="nobr">See example.</span>' ) ; obj . css ( 'display' , 'none' ) ; } }
function ( ) { this . initCollectionField ( "Notes" , App . Notes ) ; this . initCollectionField ( "Certifications" ) ; this . initCollectionField ( "SalaryChanges" , App . Notes ) ; this . get ( "SalaryChanges" ) . on ( "add remove reset change" , this . updateSalaries , this ) ; this . initCollectionField ( "Vacations" , App . Vacations ) ; }
function ( method , params ) { console . groupCollapsed ( 'SWFM.RPC.encode()' ) ; console . debug ( 'Arguments: ' , arguments ) ; var data = Ext . JSON . encode ( { jsonrpc : '2.0' , method : method , params : params } ) ; console . groupEnd ( ) ; return data ; }
function ( ) { return Backbone . Model . extend ( { urlRoot : '/toies' , idAttribute : "_id" , defaults : { isRoot : false , title : '' , span : 12 , offset : "" , text : '' , viewText : '' , children : [ ] } } ) }
function ( el ) { if ( el . page < el . pages . length - 1 ) el . page ++ ; $ . mbMomentumSlide . goTo ( el , el . page + 1 ) ; }
function ( state ) { switch ( state ) { case 'play' : $audio . get ( 0 ) . play ( ) ; break ; case 'pause' : $audio . get ( 0 ) . pause ( ) ; break ; } $audio . data ( 'state' , state ) ; $audio . trigger ( 'change:state' , state ) ; }
function ( a ) { p && B && c . ok ( ) && ( "undefined" !== typeof a . flashVersion || "undefined" !== typeof a . url ) && O ( o ( "setupLate" ) ) ; ta ( a ) ; return c } ; this . supported = this . ok = function ( ) { return B ? p && ! l : c . useHTML5Audio && c . hasHTML5 }
function ( oldUISourceCode , uiSourceCode ) { var added = false ; var selected = false ; if ( this . _scriptTreeElementsByUISourceCode . get ( oldUISourceCode ) ) { added = true ; if ( this . _lastSelectedUISourceCode === oldUISourceCode ) selected = true ; this . _removeUISourceCode ( oldUISourceCode ) ; } if ( ! added ) return ; this . addUISourceCode ( uiSourceCode ) ; if ( selected ) this . revealUISourceCode ( uiSourceCode ) ; }
function ( name , roomId , game , res ) { console . log ( "adding a room" ) ; rooms [ roomId ] = game ; res . send ( { 'location' : "/room/" + name + "/" + roomId } ) ; }
function ( req , res ) { var roomId = req . params . roomId var toReturn = "" ; if ( ! rooms [ roomId ] ) { console . log ( "making new room" ) ; addRoom ( req . query . name , roomId , new logic . Game ( ) , res ) } else { console . log ( "room: " + roomId ) ; res . send ( { "location" : "room/" + req . query . name + "/" + roomId } ) } }
function ( value ) { var c = this . _color ; if ( ( typeof value !== 'undefined' ) && ( ( c . red !== value . red ) || ( c . green !== value . green ) || ( c . blue !== value . blue ) || ( c . alpha !== value . alpha ) ) ) { this . _color = new Color ( value . red , value . green , value . blue , value . alpha ) ; this . _makeDirty ( COLOR_INDEX ) ; } }
function ( ) { return this . _outlineColor ; }
function ( value ) { var c = this . _outlineColor ; if ( ( typeof value !== 'undefined' ) && ( ( c . red !== value . red ) || ( c . green !== value . green ) || ( c . blue !== value . blue ) || ( c . alpha !== value . alpha ) ) ) { this . _outlineColor = new Color ( value . red , value . green , value . blue , value . alpha ) ; this . _makeDirty ( OUTLINE_COLOR_INDEX ) ; } }
function ( other ) { return other && ( this . _show === other . _show ) && ( shallowEquals ( this . _positions , other . _positions ) ) && ( this . _width === other . _width ) && ( this . _outlineWidth === other . _outlineWidth ) && ( shallowEquals ( this . _color , other . _color ) ) && ( shallowEquals ( this . _outlineColor , other . _outlineColor ) ) ; }
function ( header ) { var stream = this . stream ; var encoding = stream . readUInt8 ( ) ; var start = stream . offset ; while ( stream . readUInt8 ( ) !== 0 ) ; while ( stream . readUInt8 ( ) !== 0 ) ; while ( stream . readUInt8 ( ) !== 0 ) ; return stream . readBuffer ( header . length - ( stream . offset - start ) ) ; }
function ( header ) { var stream = this . stream ; var encoding = stream . readUInt8 ( ) , format = stream . readUInt24 ( ) , type = stream . readUInt8 ( ) ; var start = stream . offset ; while ( stream . readUInt8 ( ) !== 0 ) ; return stream . readBuffer ( header . length - ( stream . offset - start ) ) ; }
function ( test ) { test . expect ( 12 ) ; moment . lang ( 'pt-br' ) ; var expected = 'Janeiro Jan_Fevereiro Fev_Março Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez' . split ( "_" ) ; var i ; for ( i = 0 ; i < expected . length ; i ++ ) { test . equal ( moment ( [ 2011 , i , 0 ] ) . format ( 'MMMM MMM' ) , expected [ i ] , expected [ i ] ) ; } test . done ( ) ; }
function ( xhr ) { try { var json = $ . parseJSON ( xhr . responseText ) ; var errorMessage = json . reason ; if ( json . additional ) { for ( var s in json . additional ) errorMessage += "\n" + s + ": " + json . additional [ s ] ; } alert ( errorMessage ) ; } catch ( e ) { alert ( 'レスポンスが JSON 形式ではありません。' ) ; } }
function startService ( name , options ) { if ( runningService ) { serviceManager . stop ( runningService ) ; } var module = serviceManager . start ( name , options ) ; if ( module ) { runningService = name ; } mediator . publish ( "service" , { name : name } ) ; bid . resize ( ) ; return module ; }
function ( options ) { var self = this , originEmail = user . getOriginEmail ( ) ; self . renderDialog ( "add_email" , options ) ; if ( ! originEmail && options . siteTOSPP ) { dialogHelpers . showRPTosPP . call ( self ) ; } self . click ( "#cancel" , cancelAddEmail ) ; Module . sc . start . call ( self , options ) ; }
function onAddressInfo ( info ) { addressInfo = info ; if ( info . type === "primary" ) { self . close ( "primary_user" , info , info ) ; } else if ( info . known ) { enterPasswordState . call ( self ) ; } else { createSecondaryUser . call ( self ) ; } }
function ( info ) { if ( info . type === "primary" ) { createPrimaryUser . call ( self , info , oncomplete ) ; } else { enterPasswordState . call ( self , info ) ; oncomplete && oncomplete ( ! isRegistered ) ; } }
function ( data ) { var entity = self . getEntity ( data . id ) ; var isAnimated = ( entity . animationList [ data . name ] != undefined ) ? true : false ; entity . setSkin ( data . name , isAnimated ) ; }
function ( x , y , notify ) { if ( ! this . isVisible ) return ; if ( notify == undefined ) notify = false ; this . destinationX = x ; this . destinationY = y ; this . isMoving = true ; this . setAppearance ( 'walking' ) ; this . sendData ( 'character_moved' , { x : this . destinationX , y : this . destinationY } , notify ) ; }
function ( data ) { this . _super ( data ) ; var hobo1 = new Hobo ( 20 , 10 , 'ne' , this . getCharacterData ( 'The terrible NPC' ) ) ; var hobo2 = new Hobo ( 31 , 19 , 'se' , this . getCharacterData ( 'The terrible NPC' ) ) ; var hobo3 = new Hobo ( 19 , 35 , 'sw' , this . getCharacterData ( 'The terrible NPC' ) ) ; this . attachCharacter ( hobo1 ) ; this . attachCharacter ( hobo2 ) ; this . attachCharacter ( hobo3 ) ; }
function ( ) { if ( parent_div . find ( '#addon-categories-edit' ) . length ) { initCatFields ( ) ; } $ ( this ) . each ( addonFormSubmit ) ; initInvisibleUploads ( ) ; }
function ( force ) { if ( force || ! scrollbarPlacement ) { var db = document . body , div = document . createElement ( 'div' ) ; div . style . width = div . style . height = '100px' ; div . style . overflow = 'scroll' ; div . style . position = 'absolute' ; db . appendChild ( div ) ; scrollbarPlacement = ( div . clientLeft > 0 ) ? 'left' : 'right' ; db . removeChild ( div ) ; } return scrollbarPlacement ; }
function ( ) { if ( this . getDocHeight ( ) < this . element . getSize ( ) . y ) { this . detachScroll ( ) . reset ( ) ; } else { this . attachScroll ( ) . scroll ( ) ; } return this ; }
function ( applicationId ) { triggerNode . empty ( ) ; triggerNode . append ( utils . createElement ( "p" , { "innerHTML" : applicationId + " is triggered" } ) ) ; triggerNode . show ( ) ; }
function ( url ) { console . log ( url ) ; if ( tabs . activeTab . url == 'about:blank' ) { tabs . activeTab . url = url ; } else { tabs . open ( { url : url } ) ; } popupPanel . hide ( ) ; }
function ( requestOptions , callback , data ) { var request = this . createRequest ( requestOptions , data , callback ) ; var stringData = JSON . stringify ( data ) ; if ( this . logLevel === 'verbose' && stringData != "{}" ) { this . log ( colors . brown + "DATA\t\t " + colors . reset + stringData ) ; } request . write ( stringData ) ; request . end ( ) ; }
function ( obj , index ) { var style = getStyle ( index ) ; var itemWidth = colwidth - ( obj . outerWidth ( ) - obj . width ( ) ) ; obj . css ( { 'width' : itemWidth , 'left' : style . x * itemWidth , 'top' : style . y * ( settings . rowHeight + settings . itemHeight ) , 'height' : settings . itemHeight , } ) ; obj . addClass ( 'snaky-item ' + style . class ) ; }
function ( ret , user_name ) { if ( user_name == null ) user_name = this . _current_user_name ; ret . set_int ( this . _user_data [ user_name ] . STR ) ; }
function ( ret , user_name ) { if ( user_name == null ) user_name = this . _current_user_name ; ret . set_int ( this . _user_data [ user_name ] . LUK ) ; }
function ( ret , user_name ) { if ( user_name == null ) user_name = this . _current_user_name ; ret . set_int ( this . _user_data [ user_name ] . VIT ) ; }
function ( ret , user_name ) { if ( user_name == null ) user_name = this . _current_user_name ; ret . set_int ( this . _user_data [ user_name ] . AGI ) ; }
function ( ret , user_name ) { if ( user_name == null ) user_name = this . _current_user_name ; var img_url = "http://avatar2.bahamut.com.tw/avataruserpic/" + user_name . charAt ( 0 ) + "/" + user_name . charAt ( 1 ) + "/" + user_name + "/" + user_name + ".png" ; ret . set_string ( img_url ) ; }
function ( ret ) { ret . set_string ( this . exp_CurFriendName ) ; }
function ( ) { this . inherited ( arguments ) ; var child = this . domNode . children [ 0 ] ; if ( child ) domClass . add ( child , 'scroll-content' ) ; var hasTouch = true ; if ( hasTouch ) { this . _scroll = new iScroll ( this . domNode , { useTransition : true , checkDOMChanges : false , hScrollbar : false , vScrollbar : false } ) ; } }
function ( ) { if ( Ext . isIE6 || Ext . isIE7 || Ext . isIE8 || ( Ext . isIE && this . document . documentMode < 9 ) ) { Ext . each ( this . config . customTags , function ( tag ) { this . document . createElement ( tag ) ; } , this ) ; } }
function ( ancestor ) { if ( Ext . isIE8 || Ext . isIE7 || Ext . isIE6 ) { isFullySelected = ( type !== 'Control' && ancestor . innerText == range . text ) || ( type === 'Control' && ancestor . innerText == range . item ( 0 ) . text ) ; } else { isFullySelected = ( ancestor . textContent == range . toString ( ) ) ; } if ( isFullySelected ) { node = ancestor ; return false ; } }
function ( toBeInserted ) { if ( Ext . isIE8 || Ext . isIE7 || Ext . isIE6 ) { this . insertHtml ( toBeInserted . outerHTML ) ; } else { var range = this . createRange ( ) ; range . deleteContents ( ) ; toBeSelected = ( toBeInserted . nodeType === HTMLArea . DOM . DOCUMENT_FRAGMENT_NODE ) ? toBeInserted . lastChild : toBeInserted ; range . insertNode ( toBeInserted ) ; this . selectNodeContents ( toBeSelected , false ) ; } return this ; }
function ( ) { expect ( 2 ) ; var svg = jQuery ( '<svg height="1" version="1.1" width="1" xmlns="http://www.w3.org/2000/svg">' + '<rect class="svg-by-class" x="10" y="20" width="100" height="60" r="10" rx="10" ry="10"></rect>' + '<rect id="svg-by-id" x="10" y="20" width="100" height="60" r="10" rx="10" ry="10"></rect>' + '</svg>' ) . appendTo ( "body" ) ; jQuery ( "body" ) . on ( "click" , "#svg-by-id" , function ( ) { ok ( true , "delegated id selector" ) ; } ) . on ( "click" , ".svg-by-class" , function ( ) { ok ( true , "delegated class selector" ) ; } ) . find ( "#svg-by-id, .svg-by-class" ) . trigger ( "click" ) . end ( ) . off ( "click" ) ; svg . remove ( ) ; }
function ( el ) { if ( el . properties . count ) { return new L . Polygon ( _ . map ( el . geometry . coordinates , function ( x ) { return new L . LatLng ( x [ 0 ] , x [ 1 ] ) ; } ) , { fillOpacity : el . properties . count / ( el . properties . countMax * 1.2 ) } ) ; } else { return undefined ; } }
function ( ) { var MenageA3ReaderComic = new YQLOnlineReaderComic ( "Menage a 3" , "http://www.menagea3.net/" , "//div[@id=\"cc\"]//img|//a[@id=\"cndprev\"]|//a[@id=\"cniprev\"]|//a[@id=\"cndnext\"]" , { getLinkIsPrev : function ( link , jsonData , url , comic ) { return jsonData . query . results . a . id && jsonData . query . results . a . id . indexOf ( "prev" ) >= 0 ; } } ) ; ComicReader . addComic ( MenageA3ReaderComic ) ; }
function ( e ) { base . escClose ( e ) ; if ( base . allie && $ ( e . target ) . hasClass ( 'ui-keyboard-input' ) ) { $ ( e . target ) [ o . openOn ] ( ) ; } }
function ( ) { if ( base . isVisible && base . isCurrent ) { base . $preview . focus ( ) ; } base . mouseRepeat = [ false , '' ] ; clearTimeout ( base . repeater ) ; if ( base . checkCaret ) { base . $preview . caret ( base . lastCaret . start , base . lastCaret . end ) ; } return false ; }
function reset ( ) { this . _state = { keys : Object . keys ( dict ) , bucketIndex : 0 , valueIndex : - 1 } ; }
function ( object ) { if ( object . _guid ) return ; object . _guid = guid ++ ; _ . attributes [ object . _guid ] = { } ; _ . eventHandlers [ object . _guid ] = { } ; }
function ( dir ) { if ( ! isIgnored ( root , ignoreDirs ) && dir . name == name ) { walker . removeAllListeners ( ) cb ( path . join ( root , name ) ) } }
function analyzeControlFlow ( ) { if ( this . method . exceptions . length > 0 ) { return false ; } assert ( this . bytecodes ) ; this . detectBasicBlocks ( ) ; this . normalizeReachableBlocks ( ) ; this . computeDominance ( ) ; this . analyzedControlFlow = true ; return true ; }
function ( code ) { if ( code ) { var err = new Error ( 'NPM Install failed' ) ; err . code = code ; err . result = stderr ; err . blame = { type : 'user' , message : 'NPM failed to install dependencies' } ; haibu . emit ( 'npm:install:failure' , 'info' , { code : code , meta : meta } ) ; callback ( err ) ; return ; } haibu . emit ( 'npm:install:success' , 'info' , meta ) ; callback ( ) ; }
function uncaughtHandler ( er ) { if ( exports . active && ! exports . active . _disposed ) { util . _extend ( er , { domain : exports . active , domain_thrown : true } ) ; exports . active . emit ( 'error' , er ) ; } else if ( process . listeners ( 'uncaughtException' ) . length === 1 ) { throw er ; } }
function ( error , result ) { if ( error ) { Meteor . default_connection . setUserId ( null ) ; localStorage . setItem ( "Meteor.loginToken" , "" ) ; Meteor . _debug ( "Server error on login" , error ) ; return ; } }
function ( api ) { api . use ( 'http' , [ 'client' , 'server' ] ) ; api . use ( 'localstorage-polyfill' , 'client' ) ; api . add_files ( 'accounts_common.js' , [ 'client' , 'server' ] ) ; api . add_files ( 'accounts_server.js' , 'server' ) ; api . add_files ( 'accounts_client.js' , 'client' ) ; api . add_files ( 'localstorage_token.js' , 'client' ) ; }
function add ( object , source ) { var properties = Object . keys ( source ) ; for ( var i = 0 , length = properties . length ; i < length ; i ++ ) { var property = properties [ i ] ; object [ property ] = source [ property ] ; } return this ; }
function ( err ) { return { date : new Date ( ) . toString ( ) , process : exception . getProcessInfo ( ) , os : exception . getOsInfo ( ) , trace : exception . getTrace ( err ) , stack : err . stack . split ( '\n' ) } ; }
function ( data ) { if ( data . action == 'player' ) color = '#9f11c3' ; if ( data . action == 'level' ) color = '#739bc8' ; if ( data . action == 'speak' ) color = '#000' ; var level = ( data . level != undefined ) ? '[' + data . level + '] ' : '' ; addToChat ( level + '[' + data . player + ']' , data . message , color ) ; }
function ( ) { $ ( ".menuItem a" ) . click ( function ( ) { $ ( ".menuItem .active-link" ) . removeClass ( "active-link" ) ; $ ( this ) . addClass ( "active-link" ) ; } ) ; $ ( "#disconnectBtn" ) . click ( function ( ) { $ ( document ) . trigger ( "disconnect" ) ; return false ; } ) ; }
function ( readyHandler ) { log . debug ( "[PC] = Preparing an offer" ) ; this . _endpoints = [ ] ; this . _offeringClient = true ; this . _offer = this . _nativePC . createOffer ( null ) ; this . _nativePC . setLocalDescription ( this . _nativePC . SDP_OFFER , this . _offer ) ; this . _nativePC . startIce ( ) ; this . _offerReadyHandler = readyHandler ; this . state = CA . PeerConnection . ConnectionState . CONNECTING ; log . debug ( "[PC] = Offer prepared; waiting for ICE endpoints" ) ; }
function ( ) { var scopeId = $ ( '#scopeIdInput' ) . val ( ) ; log . debug ( "Joining scope with id; " + scopeId ) ; CA . ownClientId = _genRandomUserId ( ) ; log . debug ( "Generated client id: " + CA . ownClientId ) ; CA . RealtimeTransport . joinScope ( scopeId , CA . ownClientId ) ; CA . joinedScope = scopeId ; }
function _onNewClient ( clientId ) { log . debug ( "Got new client: " + clientId ) ; var clientPC = new CA . PeerConnection ( ) ; clientPC . makeAnOffer ( function ( offerDetails ) { CA . RealtimeTransport . emitOffer ( CA . joinedScope , clientId , offerDetails ) ; } ) ; clients [ clientId ] = clientPC ; }
function _onOffer ( clientId , offer ) { log . debug ( "Got an offer from client with id: " + clientId ) ; var clientPC = new CA . PeerConnection ( ) ; clientPC . doAnswer ( offer , function ( answerDetails ) { CA . RealtimeTransport . emitAnswer ( CA . joinedScope , clientId , answerDetails ) } ) ; clients [ clientId ] = clientPC ; }
function ( message , url , line ) { message += '' ; url += '' ; var lastSlash = url . lastIndexOf ( '/' ) ; if ( lastSlash ) { url = url . substring ( lastSlash + 1 , url . length ) ; } log . error ( "Got uncaught JS error: " + message + ' (' + url + ':' + line + ')' ) ; }
function ( file , dest ) { file = file || prefix + ".js" ; dest = dest || prefix + ".min.js" ; var minified = minify ( fs . readFileSync ( file , "utf-8" ) ) ; fs . writeFileSync ( dest , minified , "utf-8" ) ; sys . puts ( "> " + dest ) }
function ( e ) { if ( String . fromCharCode ( e . charCode ) . toLocaleUpperCase ( ) === 'N' ) { for ( i = 0 ; i < args . tofix [ 0 ] . jp ; i ++ ) { rightList [ i ] . classList . remove ( 'greyedOut' ) ; } checkSplit ( ) ; } }
function size ( to_count ) { var element_count = 0 ; for ( var e in to_count ) { if ( to_count . hasOwnProperty ( e ) ) { element_count ++ ; } } return element_count ; }
function ( socket ) { socket . on ( "newMessage" , function ( data ) { console . log ( data ) ; server . sockets . emit ( "sendEvent" , data ) ; } ) ; socket . on ( 'addUser' , function ( data ) { } ) ; socket . on ( 'disconnect' , function ( data ) { console . log ( 'Server has disconnected' ) ; } ) ; }
function ( ) { setTimeout ( setFilename , 0 ) ; }
function ( ) { var dialog = new MooDialog . Request ( '/ajax/loginui/' , { title : 'PĹ™ihlĂˇĹˇenĂ­ vyprĹˇelo' , scroll : true , useEscKey : false } ) ; dialog . addEvent ( 'hide' , function ( ) { if ( ! this . session ) location . reload ( ) ; this . session = false ; } ) ; dialog . open ( ) ; }
function ( event ) { event . stop ( ) ; if ( $ ( this ) . get ( 'xhrrunning' ) ) { $ ( this ) . erase ( 'xhrrunning' ) ; } else { $ ( this ) . set ( 'xhrrunning' , true ) ; return ; } $ ( 'content' ) . addClass ( 'contentLoading' ) ; History . push ( this . get ( 'href' ) ) ; }
function ( element ) { if ( element . substring ) { this . text = element ; this . domElement = document . createTextNode ( element ) ; } else { this . domElement = element ; this . text = element . nodeValue ; } }
function ( req , res , next ) { if ( req . connection . encrypted ) { host_url_protocol = 'https:' + host_url ; } else { host_url_protocol = 'http:' + host_url ; } app . expose ( { host_url : host_url_protocol } , 'lambdaracer.current' ) ; next ( ) ; }
function ( req , res ) { if ( ! req . facebook || ! req . facebook . signed_request ) { res . render ( 'appauth' , { title : 'Authentication' } ) ; } else { var fbid = req . facebook . signed_request . user_id ; res . expose ( { fbid : fbid } , "lambdaracer.current" ) ; res . render ( 'index' , { title : 'Racer' } ) ; } }
function ( base ) { if ( base . el . tagName === 'INPUT' ) { return false ; } base . insertText ( '\t' ) ; }
function ( ) { if ( ! this . editor ) return ; try { this . editor . removeEventListener ( "keypress" , this . onKeyPress ) ; } catch ( err ) { } this . editor . removeEventListener ( CONTEXT_MENU , this . onContextMenu ) ; this . editor . removeEventListener ( TEXT_CHANGED , this . onTextChanged ) ; this . editor . destroy ( ) ; this . editor = null ; }
function ( event ) { Firebug . CommandLine . update ( Firebug . currentContext ) ; switch ( event . keyCode ) { case KeyEvent . DOM_VK_RETURN : if ( Events . isControl ( event ) ) this . onExecute ( ) ; break ; case KeyEvent . DOM_VK_ESCAPE : this . onEscape ( ) ; event . preventDefault ( ) ; break ; } }
function ( context ) { var visible = Firebug . CommandLine . Popup . isVisible ( ) ; if ( visible && context . panelName != "console" ) return this . getSingleRowCommandLine ( ) ; return Firebug . commandEditor ? this . getCommandEditor ( ) : this . getSingleRowCommandLine ( ) ; }
function ( mimeType , quality ) { var bufferCanvas = this . getStage ( ) . bufferCanvas ; var bufferContext = bufferCanvas . getContext ( ) ; bufferCanvas . clear ( ) ; this . _draw ( bufferCanvas ) ; try { return bufferCanvas . element . toDataURL ( mimeType , quality ) ; } catch ( e ) { return bufferCanvas . element . toDataURL ( ) ; } }
function ( ) { context . drawImage ( imageObj , 0 , 0 ) ; if ( n < layers . length - 1 ) { drawLayer ( n + 1 ) ; } else { try { callback ( canvas . getElement ( ) . toDataURL ( mimeType , quality ) ) ; } catch ( e ) { callback ( canvas . getElement ( ) . toDataURL ( ) ) ; } } }
function ( event ) { event . stopPropagation ( ) ; event . preventDefault ( ) ; if ( 1 === $ ( 'div.current a:visible' ) . size ( ) && 'detail' !== $ ( '#post-body-content > .current' ) . prop ( 'class' ) . trim ( ) && 'list' !== $ ( '#post-body-content > .current' ) . prop ( 'class' ) . trim ( ) ) { var new_plugin = $ ( '#post-body-content > .grid a:visible img' ) ; $ ( '#dpa-toolbar-search' ) . val ( '' ) ; } }
function ( ) { self . updatePagePadding ( ) ; if ( o . updatePagePadding ) { $ ( window ) . bind ( "throttledresize." + self . widgetName , function ( ) { self . updatePagePadding ( ) ; } ) ; } }
function ( ) { var $el = this . element , header = $el . is ( ".ui-header" ) ; if ( this . options . fullscreen ) { return ; } $el . closest ( ".ui-page" ) . css ( "padding-" + ( header ? "top" : "bottom" ) , $el . outerHeight ( ) ) ; }
function ( ) { items . push ( this ) ; }
function use ( layer ) { if ( typeof layer !== 'function' ) { this . logger . error ( 'the supplied middleware isnt a valid function' ) ; return this ; } if ( ! this . has ( layer ) ) this . middleware . push ( layer ) ; return this ; }
function ( ) { var square = new Square ( ) ; square . use ( noop ) ; expect ( square . middleware ) . to . have . length ( 1 ) ; square . use ( noop ) ; expect ( square . middleware ) . to . have . length ( 1 ) ; }
function ( route ) { var methods = route [ 2 ] || "GET" ; methods . forEach ( function ( method ) { var params = [ ] ; app [ method ] ( route [ 0 ] , params , route [ 1 ] ) ; } ) ; }
function uploadDescriptions ( descriptionsFolder ) { var files = fs . readdirSync ( descriptionsFolder ) ; files . forEach ( function ( fileName , index , array ) { var fullFileName = descriptionsFolder + "\\" + fileName ; dprint ( "Uploading swarming:" + fileName ) ; var content = fs . readFileSync ( fullFileName ) ; redisClient . hset ( mkUri ( "system" , "code" ) , fileName , content ) ; } ) ; }
function ( err , stdout , stderr ) { if ( err ) { res . json ( err , 404 ) ; } else { var writeStream = fs . createWriteStream ( cached_file ) ; stdout . pipe ( writeStream ) ; stdout . on ( 'end' , function ( ) { console . log ( ' writing ' + cached_file + ' to cache ' ) ; res . redirect ( '/' + cached_file ) ; } ) ; } }
function ( from ) { while ( from > 0 && ( ! this . getBlock ( from ) || this . scrollPos ( ) < this . blockPosition ( from ) ) ) { from -= 1 ; } var addingActivated ; while ( this . scrollPos ( ) > this . blockPosition ( from ) + this . blockHeight ( ) ) { from += 1 ; addingActivated = true ; } if ( addingActivated ) { from -= 1 ; } return from ; }
function ( inSender , inEvent ) { console . debug ( "onchange" ) ; if ( this . $ . autocompleteMenu . children . length > 0 ) { this . $ . nameField . setValue ( this . $ . autocompleteMenu . children [ 0 ] . content ) ; this . $ . autocompleteMenu . children [ 0 ] . doSelect ( ) ; } else { this . $ . nameField . setValue ( "" ) ; } this . $ . autocompleteMenu . hide ( ) ; this . render ( ) ; }
function ( event ) { var events = this . __events [ event . type ] || [ ] ; for ( var i = 0 ; i < events . length ; ++ i ) { events [ i ] ( event ) ; } var handler = this [ "on" + event . type ] ; if ( handler ) handler ( event ) ; }
function ( Memplex ) { $ ( "<span class=\"title\">" + Memplex . title + "</span>" ) . appendTo ( View . headline ) ; $ ( "<div class=\"description\">" + Memplex . text + "</div>" ) . appendTo ( View . content ) ; for ( c in Memplex . children ) { $ ( "<a class=\"layer1link\" onclick=\"Controller.load(" + Memplex . children [ c ] . id + ")\">" + Memplex . children [ c ] . title + "</a>" ) . appendTo ( View . content ) ; } ; $ ( "<br class=\"clear\">" ) . appendTo ( View . content ) ; }
function ( ) { req = { origin : "http://www.origin.com" , params : { } } ; res = { send : jasmine . createSpy ( ) } ; succ = jasmine . createSpy ( ) ; fail = jasmine . createSpy ( ) ; args = { } ; GLOBAL . frameworkModules = [ "ext/blackberry.app/index.js" ] ; }
function ( ) { req = { params : { service : "default" , action : "exec" , ext : "blackberry.app" , method : "author" , args : null , origin : null } , headers : { host : "" } , url : "" , body : "" , origin : "" } ; res = { send : jasmine . createSpy ( ) } ; GLOBAL . frameworkModules = [ 'ext/blackberry.app/index.js' , 'lib/plugins/extensions.js' , 'lib/plugins/default.js' ] ; }
f _ . each ( wrench . readdirSyncRecursive ( path . join ( collection . dir , CONST . DIR . VIEW ) ) , function ( view ) { if ( viewRegex . test ( view ) ) { console . log ( view ) ; parseView ( view , collection . dir , collection . manifest ) ; } } ) ; } ) ;
function ( ) { try { if ( geo_object . type === 'google' ) { editor . goTo ( geo_object . geo ) ; } else { editor . loadGeoJSON ( geo_object . geo , true ) ; } return clearInterval ( intvl ) ; } catch ( _error ) { } }
function ( ) { test . assertEquals ( ".repeat() should not have fired anymore" , 1 , x ) ; $x . unrepeat ( ) ; test . assertEquals ( ".repeat() should not have fired anymore after .unrepeat()" , 1 , x ) ; test . done ( ) ; }
function ( y ) { test . assertEquals ( "callback argument must be iteration number" , x , y ) ; x ++ ; test . check ( ) ; if ( x > 1000 ) { $x . unrepeat ( ) ; throw "repeat loop running infinitely" ; } ; }
function ( y ) { test . assertEquals ( "callback argument must be iteration number" , x , y ) ; x ++ ; test . check ( ) ; if ( x > 1000 ) { $x . unrepeat ( ) ; throw "repeat loop running infinitely" ; } ; }
function ( y ) { test . assertEquals ( "callback argument must be iteration number" , x , y ) ; x ++ ; test . check ( ) ; if ( x > 1000 ) { $x . unrepeat ( ) ; throw "repeat loop running infinitely" ; } ; }
function ( ) { test . assertEquals ( ".wait() should not have been interrupted by .unrepeat()" , 1 , x ) ; test . done ( ) ; window . setTimeout ( function ( ) { test . assertEquals ( ".wait() should not fire anymore" , 1 , x ) ; test . done ( ) ; } , timeout + 1 ) ; }
function createMappingIfNotPresent ( indexName , typeName , schema , cb ) { generator . generateMapping ( schema , function ( err , mapping ) { var completeMapping = { } ; completeMapping [ typeName ] = mapping ; esClient . createIndex ( indexName , { mappings : completeMapping } , cb ) ; } ) ; }
function ( xhr ) { var r = JSON . decode ( xhr . responseText ) ; if ( r ) { Joomla . replaceTokens ( r . token ) ; document . id ( 'theDefaultError' ) . setStyle ( 'display' , 'block' ) ; document . id ( 'theDefaultErrorMessage' ) . set ( 'html' , r . message ) ; } el . set ( 'disabled' , '' ) ; filename . set ( 'disabled' , '' ) ; }
function ( r ) { if ( r ) { Joomla . replaceTokens ( r . token ) if ( r . error == false ) { alert ( Joomla . JText . _ ( 'INSTL_FTP_SETTINGS_CORRECT' ) ) ; } else { alert ( r . message ) ; } } el . set ( 'disabled' , '' ) ; }
function squashTokens ( tokens ) { var lastToken ; for ( var i = 0 ; i < tokens . length ; ++ i ) { token = tokens [ i ] ; if ( lastToken && lastToken . type === "text" && token . type === "text" ) { lastToken . value += token . value ; tokens . splice ( i -- , 1 ) ; } else { lastToken = token ; } } }
function ( val ) { clearTimeout ( this . nextDraw ) ; var d = this ; this . numBases = Math . pow ( 10 , Math . round ( val / 20 ) + 1 ) ; this . nextDraw = setTimeout ( function ( ) { d . draw ( ) ; } , this . numBases > 50000 ? 100 : 10 ) ; }
function ( config ) { this . config = new Echo . Configuration ( config , { "data" : { } , "uri" : "" , "secure" : false , "onData" : function ( ) { } , "onOpen" : function ( ) { } , "onClose" : function ( ) { } , "onError" : function ( ) { } } ) ; this . instance = this . _getInstance ( ) ; }
function ( config ) { if ( ! config || ! config . endpoint ) return ; this . config = new Echo . Configuration ( config , { "apiBaseURL" : "api.echoenabled.com/v1/" , "transport" : "ajax" , "secure" : false } ) ; this . transport = this . _getTransport ( ) ; }
function ( config ) { var self = this ; config = $ . extend ( { "liveUpdatesTimeout" : 5 , "onData" : function ( ) { } , "onError" : function ( ) { } , "submissionProxyURL" : "apps.echoenabled.com/v2/esp/activity" } , config ) ; config = this . _wrapTransportEventHandlers ( config ) ; Echo . StreamServer . API . Request . parent . constructor . call ( this , config ) ; }
function ( responseError , config ) { this . constructor . parent . _onData . apply ( this , arguments ) ; this . _handleErrorResponse ( responseError , { "callback" : config . onError } ) ; if ( this . liveUpdates ) { this . _startLiveUpdates ( ) ; } }
function ( ) { timeElapsed += timeout ; if ( timeElapsed == maxWaitingTimeout ) { self . _cleanupErrorHandlers ( ) ; if ( config . waitingHandler ) { config . waitingHandler ( ) ; } } else { self . transport . abort ( ) ; self . config . get ( "onError" ) ( data ) ; } }
function ( evt ) { evt . preventDefault ( ) ; var idx = node . children . length ; node . insertArrayItem ( idx , $ ( '#' + escapeSelector ( node . id ) + ' ul' ) . get ( 0 ) ) ; }
function ( evt ) { var idx = node . children . length ; evt . preventDefault ( ) ; node . insertArrayItem ( idx , $ ( '.tab-content' , $ ( '#' + escapeSelector ( node . id ) ) ) . get ( 0 ) ) ; updateTabs ( idx ) ; }
function ( form ) { $ ( '#results' ) . empty ( ) ; searchSpinner = startSpinner ( $ ( '#results' ) . get ( 0 ) ) ; $ ( '#lastQuery' ) . val ( $ ( '#q' ) . val ( ) . trim ( ) ) ; }
function triggerSearch ( event ) { var key = event . which ; if ( key == 27 ) { $ ( '#advanced-search' ) . fadeOut ( ) ; return ; } if ( key != 1 && key != 13 ) return ; $ ( '#search-box' ) . ajaxSubmit ( searchObj ) ; $ ( '#advanced-search' ) . fadeOut ( ) ; return false ; }
function ( event ) { event . preventDefault ( ) ; $ ( '.subbar li' ) . removeClass ( 'selected' ) $ ( this ) . addClass ( 'selected' ) ; $ ( 'body' ) . animate ( { scrollTop : $submenu . offset ( ) . top - menuHeight - 20 } , 'slow' ) ; }
function ( ) { this . _beforeStart ( ) ; var self = this ; self . node . style [ transitionPrefix + "ransitionProperty" ] = "all" ; self . node . style [ transitionPrefix + "ransitionDuration" ] = self . duration + "ms" ; on . once ( self . node , transitionEndEventName , function ( ) { self . clear ( ) ; } ) ; this . _applyState ( this . endState ) ; }
function ( snapshot ) { console . log ( snapshot . val ( ) ) ; $scope . messages = snapshot . val ( ) ; if ( ! $scope . $$phase ) $scope . $apply ( ) ; }
function getFaviconURIForLocation ( uri ) { let pageURI = NetUtil . newURI ( uri ) ; try { return FaviconService . getFaviconDataAsDataURL ( FaviconService . getFaviconForPage ( pageURI ) ) ; } catch ( e ) { if ( ! DEF_FAVICON ) { DEF_FAVICON = PNG_B64 + base64Encode ( getChromeURIContent ( DEF_FAVICON_URI ) ) ; } return DEF_FAVICON ; } }
function ( ) { this . _super ( ) ; var map = cc . TMXTiledMap . create ( "res/TileMaps/orthogonal-test1.tmx" ) ; this . addChild ( map , 0 , TAG_TILE_MAP ) ; var childrenArray = map . getChildren ( ) ; for ( var i = 0 ; i < childrenArray . length ; i ++ ) { var child = childrenArray [ i ] ; if ( ! child ) break ; } map . runAction ( cc . ScaleBy . create ( 2 , 0.5 ) ) ; }
function ( dt ) { var p = this . tamara . getPositionInPixels ( ) ; var map = this . getChildByTag ( TAG_TILE_MAP ) ; var newZ = 4 - ( p . y / 48 ) ; newZ = Math . max ( newZ , 0 ) ; map . reorderChild ( this . tamara , newZ ) ; }
function ( dt ) { var p = this . tamara . getPositionInPixels ( ) ; var map = this . getChildByTag ( TAG_TILE_MAP ) ; var newZ = 4 - ( ( p . y - 10 ) / 81 ) ; newZ = Math . max ( newZ , 0 ) ; map . reorderChild ( this . tamara , newZ ) ; }
function ( fileImage ) { this . _super ( ) ; if ( fileImage ) { this . initWithFile ( fileImage , cc . DEFAULT_SPRITE_BATCH_CAPACITY ) ; } this . setContentSize ( new cc . Size ( cc . canvas . width , cc . canvas . height ) ) ; this . _renderTexture = cc . RenderTexture . create ( cc . canvas . width , cc . canvas . height ) ; }
function ( pos ) { cc . Assert ( pos . x < this . _layerSize . width && pos . y < this . _layerSize . height && pos . x >= 0 && pos . y >= 0 , "TMXLayer: invalid position" ) ; cc . Assert ( this . _tiles && this . _atlasIndexArray , "TMXLayer: the tiles map has been released" ) ; var idx = pos . x + pos . y * this . _layerSize . width ; return this . _tiles [ idx ] ; }
function ( pos ) { var ret = cc . PointZero ( ) ; switch ( this . _layerOrientation ) { case cc . TMXOrientationOrtho : ret = this . _positionForOrthoAt ( pos ) ; break ; case cc . TMXOrientationIso : ret = this . _positionForIsoAt ( pos ) ; break ; case cc . TMXOrientationHex : ret = this . _positionForHexAt ( pos ) ; break ; } return ret ; }
function ( z ) { var item ; if ( this . _atlasIndexArray ) { for ( var i = 0 ; i < this . _atlasIndexArray . length ; i ++ ) { item = this . _atlasIndexArray [ i ] if ( item == z ) { break ; } } } cc . Assert ( item , "TMX atlas index not found. Shall not happen" ) ; return i ; }
function ( tmxFile ) { this . _tileSets = [ ] ; this . _layers = [ ] ; this . _TMXFileName = tmxFile ; this . _objectGroups = [ ] ; this . _properties = [ ] ; this . _tileProperties = [ ] ; this . _currentString = "" ; this . _storingCharacters = false ; this . _layerAttribs = cc . TMXLayerAttribNone ; this . _parentElement = cc . TMXPropertyNone ; return this . parseXMLFile ( this . _TMXFileName ) ; }
function ( ) { var onFrame = window . requestAnimationFrame || window . webkitRequestAnimationFrame || window . mozRequestAnimationFrame || window . oRequestAnimationFrame || window . msRequestAnimationFrame || null , self = this ; if ( onFrame ) { tick = function ( ) { self . step ( ) ; requestID = onFrame ( tick ) ; } tick ( ) ; } else { tick = setInterval ( self . step , 1000 / FPS ) ; } }
function ( ) { this . curTime = Date . now ( ) ; if ( this . curTime > nextGameTick ) { Crafty . trigger ( "EnterFrame" , { frame : frame ++ } ) ; Crafty . DrawManager . draw ( ) ; nextGameTick = this . curTime + minimumDelay ; } }
function ( test ) { var args = { user : 'A7S7F8GA7SD11A7SDF8ASD7G' , event : 0 , target : 'A7S7FHGA7SD11A7SDF8AS87G' , app : 1 } NotificationListener . findNotificationListener ( args , function ( error , notificationListener ) { if ( error ) { console . log ( error ) ; } test . ok ( notificationListener . should . have . property ( 'user' , 'A7S7F8GA7SD11A7SDF8ASD7G' ) ) ; test . done ( ) ; } ) ; }
function ( test ) { var args = { user : 'A7S7F8GA7SD11A7SDF8ASD7G' , app : 1 } UserNotificationSettings . findNotificationSettings ( args , function ( error , notificationSettings ) { test . ok ( notificationSettings . should . have . property ( 'notificationOnNewResource' , 0 ) ) ; test . done ( ) ; } ) ; }
function ( test ) { var args = { user : 'A7S7FSD78FA98A7SDF8ASD7G' , app : 3 } UserNotificationSettings . addNotificationSetting ( args , function ( error , newNotificationSetting ) { UserNotificationSettings . findNotificationSettings ( args , function ( error , notificationSettings ) { test . ok ( notificationSettings . should . have . property ( 'notificationOnNewResource' , 0 ) ) ; test . done ( ) ; } ) ; } ) ; }
function ( ) { if ( NOTIFIER . hasSupport ( ) ) { permissionCallback ( NOTIFIER . hasPermission ( ) ) ; $ ( "#request_notification_permission a" ) . click ( function ( event ) { NOTIFIER . requestPermission ( permissionCallback ) ; event . preventDefault ( ) ; } ) ; } else { $ ( "#request_notification_permission" ) . hide ( ) ; } $ ( '#colorpicker' ) . farbtastic ( '#user_color' ) ; }
function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; }
function ( ) { createController ( { ready : function ( ) { var startInfo ; mediator . subscribe ( "start" , function ( msg , info ) { startInfo = info ; } ) ; var siteLogo = '/i/card.png" onerror="alert(\'xss\')" <script>alert(\'more xss\')</script>' ; var retval = controller . get ( HTTP_TEST_DOMAIN , { siteLogo : siteLogo } ) ; testHelpers . testObjectValuesEqual ( startInfo , { siteLogo : encodeURI ( HTTP_TEST_DOMAIN + siteLogo ) } ) ; equal ( typeof retval , "undefined" , "no error expected" ) ; testErrorNotVisible ( ) ; start ( ) ; } } ) ; }
function ( e ) { if ( e . which == 9 || e . which == 13 ) { e . preventDefault ( ) ; var $new = $ ( this ) ; cur_grimaddSlot ( $new . val ( ) ) ; $new . val ( '' ) ; } }
function ( status , event , filename ) { if ( status ) { self . emit ( 'error' , errnoException ( errno , 'watch' ) ) ; } else { self . emit ( 'change' , event , filename ) ; } }
function ( error , response , body ) { if ( ! error && response . statusCode == 200 ) { console . log ( body ) ; var answer = JSON . parse ( body ) ; res . render ( 'index' , { 'title' : answer , 'user' : req . currentUser , 'menu' : res . menu , 'headerStats' : res . headerStats , 'categoryList' : categories , 'scripts' : [ ] , 'styles' : [ ] } ) ; } }
function ( config ) { if ( ! config || ! config . endpoint ) return ; this . config = new Echo . Configuration ( config , { "apiBaseURL" : "api.echoenabled.com/v1/" , "transport" : "jsonp" , "secure" : false } ) ; this . transport = this . _getTransport ( ) ; }
function Vb ( a , b ) { var c = a . indexOf ( b ) ; c > - 1 && a . splice ( c , 1 ) } function Wb ( a , b , c ) { E ( b ) && Vb ( Z , b ) ; Vb ( Z , c ) ; a . unshift ( { la : b , ua : c } ) }
function xb ( a , b ) { this . start = ea ( a ) ? a . clone ( ) : new u ; this . end = ea ( b ) ? b . clone ( ) : new u } xb . prototype . toString = function ( ) { return this . isValid ( ) ? this . start . full ( ) + ".." + this . end . full ( ) : "Invalid DateRange" }
function yb ( a , b , c , d , e ) { if ( ! a . ga ) a . ga = [ ] ; D ( b ) || ( b = 0 ) ; a . ga . push ( setTimeout ( function ( ) { a . ga . splice ( g , 1 ) ; c . apply ( d , e || [ ] ) } , b ) ) ; var g = a . ga . length }
function Vb ( a , b ) { var c = a . indexOf ( b ) ; c > - 1 && a . splice ( c , 1 ) } function Wb ( a , b , c ) { E ( b ) && Vb ( Z , b ) ; Vb ( Z , c ) ; a . unshift ( { la : b , ua : c } ) }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 727 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 749 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 790 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 820 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 920 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 727 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 749 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 790 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 820 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 920 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 727 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 749 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 790 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 820 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 920 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function _onError ( error ) { console . error ( error . message ) ; }
function ( ) { socket . leave ( socket . udata . sheet_id ) ; es . remove_user_from_room ( socket . udata , socket . udata . sheet_id ) ; io . sockets . in ( socket . udata . sheet_id ) . emit ( 'USER_CHANGE' , { user : socket . udata , action : 'LEFT' , sheet_data : EtherSheetService . sheets [ socket . udata . sheet_id ] } ) ; }
function ( ) { expect ( 2 ) ; var markup = jQuery ( '<ul><li><a id="a0"></a><ul id="ul0"><li><a id="a0_0"></a></li><li><a id="a0_1"></a></li></ul></li></ul>' ) . appendTo ( "body" ) ; markup . on ( "click" , ">li>a" , function ( ) { ok ( this . id === "a0" , "child li was clicked" ) ; } ) . find ( "#ul0" ) . on ( "click" , "li:first>a" , function ( ) { ok ( this . id === "a0_0" , "first li under #u10 was clicked" ) ; } ) . end ( ) . find ( "a" ) . click ( ) . end ( ) . remove ( ) ; }
function ( catagory ) { catagory = parseInt ( catagory ) ; console . log ( catagory ) ; this . candidate_apps = _ . clone ( this . apps [ catagory ] ) ; this . candidate_questions = _ . shuffle ( this . questions [ catagory ] ) ; this . update_progress ( 0 ) ; this . next_question ( true ) ; }
function ( result ) { this . update_progress ( 1 ) ; $ ( this . tpl_result ( { apps : result } ) ) . appendTo ( this . $div ) ; var $cur_slide = $ ( '.present' , this . $div ) . addClass ( 'fadingout' ) . next ( ) . addClass ( 'present' ) . end ( ) setTimeout ( function ( ) { $cur_slide . remove ( ) ; } , 1000 ) ; }
function ( mimeType , quality ) { var bufferLayer = this . getStage ( ) . bufferLayer ; var bufferCanvas = bufferLayer . getCanvas ( ) ; var bufferContext = bufferLayer . getContext ( ) ; bufferLayer . clear ( ) ; this . _draw ( bufferLayer ) ; try { return bufferLayer . getCanvas ( ) . toDataURL ( mimeType , quality ) ; } catch ( e ) { return bufferLayer . getCanvas ( ) . toDataURL ( ) ; } }
function ( layer ) { var stage = this . getStage ( ) ; var children = this . children ; for ( var n = 0 ; n < children . length ; n ++ ) { var child = children [ n ] ; if ( child . nodeType === 'Shape' ) { if ( child . isVisible ( ) && stage . isVisible ( ) ) { child . _draw ( layer ? layer : child . getLayer ( ) ) ; } } else { child . draw ( layer ) ; } } }
function ( layer ) { layer . canvas . width = this . attrs . width ; layer . canvas . height = this . attrs . height ; layer . draw ( ) ; this . content . appendChild ( layer . canvas ) ; layer . lastDrawTime = 0 ; }
function ( config ) { this . setDefaultAttrs ( { throttle : 80 , clearBeforeDraw : true } ) ; this . nodeType = 'Layer' ; this . lastDrawTime = 0 ; this . beforeDrawFunc = undefined ; this . afterDrawFunc = undefined ; this . canvas = document . createElement ( 'canvas' ) ; this . context = this . canvas . getContext ( '2d' ) ; this . canvas . style . position = 'absolute' ; this . _super ( config ) ; }
function ( event ) { event . stopPropagation ( ) ; opts = CSP . innerWidthAndHeight ( 0.582 ) ; $ . extend ( opts , { href : $ ( this ) . attr ( 'href' ) , iframe : true } ) ; $ . colorbox ( opts ) ; return false ; }
function ( file ) { file = file_data . tree [ file ] ; if ( file . type == 'blob' ) { if ( file . path . match ( /Audacity Labels/i ) ) { has_labels = file . sha ; } else if ( file . path . match ( /Set List/i ) ) { set_sha = file . sha ; } } }
function clearFlameLayer ( ) { var canvas , context ; canvas = document . getElementById ( 'flames' ) ; context = canvas . getContext ( '2d' ) ; context . clearRect ( 0 , 0 , 270 , 270 ) ; }
function ( ) { var self = this ; this . nodeList = performSearch ( this ) ; this . searchList = [ ] ; var realNodes = this . first ? this . nodeList . slice ( 0 , 1 ) : this . nodeList . slice ( 0 ) ; return realNodes . map ( function ( elem ) { return new Node ( self . document , elem ) ; } ) ; }
function ( move ) { if ( move . id = 'sunnyday' ) { var weather = move . weather ; move . weather = null ; move . onHit = function ( target , source ) { this . setWeather ( weather , source , 'forecast' ) ; this . weatherData . duration = 0 ; } ; move . target = 'self' ; move . sideCondition = 'flowergift' ; } }
function ( basePower , attacker , defender , move ) { var GossamerWingUsers = { "Butterfree" : 1 , "Masquerain" : 1 , "Beautifly" : 1 , "Mothim" : 1 } ; if ( GossamerWingUsers [ pokemon . template . species ] ) { if ( move . type === 'Rock' || move . type === 'Electric' || move . type === 'Ice' ) { return basePower / 2 ; } } }
function ( damage , attacker , defender , effect ) { var GossamerWingUsers = { "Butterfree" : 1 , "Masquerain" : 1 , "Beautifly" : 1 , "Mothim" : 1 } ; if ( GossamerWingUsers [ pokemon . template . species ] ) { if ( effect && effect . id === 'stealthrock' ) { return damage / 2 ; } } }
function ( video ) { var v = $ ( video ) ; if ( v . data ( 'meta' ) . identifier == user . videoOver ) { v . data ( 'userCount' , ( v . data ( 'userCount' ) || 0 ) + 1 ) ; _this . applyStyle ( v . data ( 'userCount' ) , users . length , v ) ; } }
function ( video ) { var v = $ ( video ) ; if ( v . data ( 'meta' ) . identifier == user . videoOver ) { var userCount = Math . max ( ( v . data ( 'userCount' ) || 0 ) - 1 , 0 ) ; v . data ( 'userCount' , userCount ) ; } }
function ( path , force ) { if ( path && path . stop != undefined ) path = false ; path || ( path = this . cur_path ( ) ) ; force = ! ! force ; if ( this . last_path == path && ! force ) { return false ; } this . last_path = path ; this . trigger ( 'route' , path ) ; }
function ( canvas , tilePoint , zoom ) { var ctx = { canvas : canvas , tile : tilePoint , zoom : zoom } ; if ( this . options . debug ) { this . _drawDebugInfo ( ctx ) ; } this . _draw ( ctx ) ; }
function ( e ) { if ( req . readyState === 4 ) { if ( req . status < 300 ) { callback ( req ) ; } } }
function ( feature ) { var type = feature . geometry . type ; switch ( type ) { case 'Point' : case 'MultiPoint' : return { color : 'rgba(252,146,114,0.6)' , radius : 5 } ; case 'LineString' : case 'MultiLineString' : return { color : 'rgba(161,217,155,0.8)' , size : 3 } ; case 'Polygon' : case 'MultiPolygon' : return { color : 'rgba(43,140,190,0.4)' , outline : { color : 'rgb(0,0,0)' , size : 1 } } ; default : return null ; } }
function ( ) { var active = $ ( '#list' ) . find ( '.active' ) ; KT . panel . panelAjax ( active , active . attr ( "data-ajax_url" ) , $ ( '#panel' ) , false ) ; }
function ( e ) { for ( var j = 0 ; j < top_nav_items . length ; j ++ ) { top_nav_items [ j ] . removeClass ( 'active' ) ; } if ( e . target . hasClass ( 'nav_item' ) ) { e . target . addClass ( 'active' ) ; } else { e . target . parentElement . addClass ( 'active' ) ; } }
function ( opd , k , e ) { var xe = extend ( e ) ; bind ( xe , fun . formal , opd ) ; bind ( xe , fun . eformal , e ) ; return perform ( fun . body , k , xe ) }
function ( ) { $ ( '.modal-confirm' ) . modal ( 'hide' ) ; $ . ajax ( { url : '/delete' , type : "POST" , success : function ( data ) { setTimeout ( onDeleteSuccess , 500 ) ; } , error : function ( jqXHR ) { console . log ( 'error' , jqXHR . responseText + ' :: ' + jqXHR . statusText ) ; } } ) ; }
function ( catName ) { $ . ajax ( { url : '/inventory' , type : "POST" , data : { inv : category } , success : function ( data ) { editor . modal ( 'hide' ) ; } , error : function ( jqXHR ) { editor . modal ( 'hide' ) ; console . log ( 'error' , jqXHR . responseText + ' :: ' + jqXHR . statusText ) ; } } ) ; }
function ( ) { res . clearCookie ( 'email' , { path : '/login' } ) ; res . clearCookie ( 'passw' , { path : '/login' } ) ; req . session . destroy ( function ( e ) { res . send ( 'ok' , 200 ) ; } ) ; }
function ( req , res ) { AM . deleteAccount ( req . session . user , req . session . org , function ( ) { res . clearCookie ( 'email' , { path : '/login' } ) ; res . clearCookie ( 'passw' , { path : '/login' } ) ; req . session . destroy ( function ( e ) { res . send ( 'ok' , 200 ) ; } ) ; } ) }
function ( err , cached_content ) { if ( err ) { return callback ( err , { "body" : cached_content , "updated_at" : stat . mtime , "options" : { "header" : header } } ) ; } header [ "Content-Length" ] = cached_content . length ; return callback ( null , { "body" : cached_content , "updated_at" : stat . mtime , "options" : { "header" : header } } ) ; }
function ( err , template_output ) { if ( err ) { return callback ( { "ignore" : false , "message" : err } , null ) ; } return compiler . compile ( template_output , function ( err , output ) { if ( err ) { return callback ( { "ignore" : false , "message" : err } , null ) ; } return callback ( null , { "body" : output , "modified" : true } ) ; } ) ; }
function ( input , callback ) { var self = this ; var output , err ; marked . setOptions ( { gfm : true , pedantic : false , sanitize : false } ) ; try { output = marked ( input . toString ( ) ) ; } catch ( error ) { err = error ; } return callback ( err , output ) ; }
function ( ) { var output = null ; var markdown_instance = new markdown_parser ( ) ; markdown_instance . parse ( "*sample text*" , function ( parsed_content ) { output = parsed_content ; } ) ; waits ( 100 ) ; runs ( function ( ) { expect ( output ) . toEqual ( "<p><em>sample text</em></p>\n" ) ; } ) ; }
function ( name , position ) { var point = { name : name , pos : position , angles : [ ] , arcs : [ ] } ; point . angleTo = function ( p ) { p = congruency . getPoint ( p ) ; return Math . atan2 ( p . pos [ 1 ] - point . pos [ 1 ] , p . pos [ 0 ] - point . pos [ 0 ] ) ; } ; congruency . points [ name ] = point ; return point ; }
function send_request ( ) { if ( typeof jQuery == 'undefined' ) { document . getElementById ( 'status' ) . innerHTML = "jquery not found...." ; } $ . ajax ( { url : "http://googlesupport.heroku.com/researches?callback=openTab" , type : "POST" , data : { "bookmarks" : links , r : guid } , dataType : "json" , success : function ( obj ) { openTab ( obj ) ; } , error : function ( jqXHR , textStatus , errorThrown ) { document . getElementById ( 'status' ) . innerHTML = textStatus + ' ' + errorThrown ; } } ) ; }
function ( up , file ) { $ ( 'div.rwmb-image-uploading-bar' , 'li#' + file . id ) . css ( 'height' , file . percent + '%' ) ; }
function ( hook ) { var hookInSourceControl = path . resolve ( __dirname , hook ) ; if ( path . existsSync ( hookInSourceControl ) ) { var hookInHiddenDirectory = path . resolve ( __dirname , ".." , ".git" , "hooks" , hook ) ; if ( path . existsSync ( hookInHiddenDirectory ) ) { fs . unlinkSync ( hookInHiddenDirectory ) ; } fs . linkSync ( hookInSourceControl , hookInHiddenDirectory ) ; } }
function ya ( a ) { if ( ! a || ! a . call ) throw new TypeError ( "Callback is not callable" ) ; } function za ( a ) { if ( a . length === 0 ) throw new TypeError ( "First argument must be defined" ) ; } y ( p , m , m , { isArray : function ( a ) { return ia ( a , "Array" ) } }
function ( a , b ) { var c , d ; if ( arguments . length == 1 ) { b = a ; a = 0 } c = w . min ( a || 0 , E ( b ) ? 1 : b ) ; d = w . max ( a || 0 , E ( b ) ? 1 : b ) ; return P ( w . random ( ) * ( d - c ) + c ) }
function ( a ) { var b = r ( "^[" + a . source + "\\s]+$" ) , c = r ( "[" + a . source + "]" ) ; a . ca . forEach ( function ( d ) { fa ( t . prototype , "is" + d , function ( ) { return b . test ( this . trim ( ) ) } ) ; fa ( t . prototype , "has" + d , function ( ) { return c . test ( this ) } ) } ) }
function ya ( a ) { if ( ! a || ! a . call ) throw new TypeError ( "Callback is not callable" ) ; } function za ( a ) { if ( a . length === 0 ) throw new TypeError ( "First argument must be defined" ) ; } y ( p , m , m , { isArray : function ( a ) { return ia ( a , "Array" ) } }
function ( a , b ) { var c , d ; if ( arguments . length == 1 ) { b = a ; a = 0 } c = w . min ( a || 0 , E ( b ) ? 1 : b ) ; d = w . max ( a || 0 , E ( b ) ? 1 : b ) ; return P ( w . random ( ) * ( d - c ) + c ) }
function ( a ) { var b = r ( "^[" + a . source + "\\s]+$" ) , c = r ( "[" + a . source + "]" ) ; a . ca . forEach ( function ( d ) { fa ( t . prototype , "is" + d , function ( ) { return b . test ( this . trim ( ) ) } ) ; fa ( t . prototype , "has" + d , function ( ) { return c . test ( this ) } ) } ) }
function ( a ) { var b = r ( "^[" + a . source + "\\s]+$" ) , c = r ( "[" + a . source + "]" ) ; a . ca . forEach ( function ( d ) { fa ( t . prototype , "is" + d , function ( ) { return b . test ( this . trim ( ) ) } ) ; fa ( t . prototype , "has" + d , function ( ) { return c . test ( this ) } ) } ) }
function ( a ) { var b = [ ] ; if ( ! ka ( a ) && ! N ( a ) && ! K ( a ) ) throw new TypeError ( "Object required" ) ; z ( a , function ( c ) { b . push ( c ) } ) ; return b }
function ya ( a ) { if ( ! a || ! a . call ) throw new TypeError ( "Callback is not callable" ) ; } function za ( a ) { if ( a . length === 0 ) throw new TypeError ( "First argument must be defined" ) ; } y ( p , m , m , { isArray : function ( a ) { return ia ( a , "Array" ) } }
function yb ( a , b , c , d , e ) { if ( ! a . fa ) a . fa = [ ] ; L ( b ) || ( b = 0 ) ; a . fa . push ( setTimeout ( function ( ) { a . fa . splice ( g , 1 ) ; c . apply ( d , e || [ ] ) } , b ) ) ; var g = a . fa . length }
function Ub ( a , b ) { var c = a . indexOf ( b ) ; c > - 1 && a . splice ( c , 1 ) } function Vb ( a , b , c ) { C ( b ) && Ub ( Z , b ) ; Ub ( Z , c ) ; a . unshift ( { la : b , ua : c } ) }
function ( a , b ) { var c , d ; if ( arguments . length == 1 ) { b = a ; a = 0 } c = w . min ( a || 0 , E ( b ) ? 1 : b ) ; d = w . max ( a || 0 , E ( b ) ? 1 : b ) ; return P ( w . random ( ) * ( d - c ) + c ) }
function ( msg ) { if ( msg . indexOf ( "alsfjlqwjdlas" ) !== - 1 ) { console . log ( style_html ( msg . replace ( "alsfjlqwjdlas" , "" ) . replace ( /<script[^>]*>([\\S\\s]*?)<\/script>/img , '' ) . replace ( /opacity.+;/img , '' ) ) ) ; phantom . exit ( ) ; } }
function ( e ) { e . stop ( ) ; if ( e . key == 'right' ) { self . fireEvent ( 'goRight' ) ; this . destroy ( ) ; } else if ( e . key == 'left' ) { self . fireEvent ( 'goLeft' ) ; this . destroy ( ) ; } else if ( e . key == 'backspace' ) { self . del ( ) ; this . destroy ( ) ; } }
function ( el , target ) { var rsmEl ; if ( ( rsmEl = el . getElementsByTagNameNS ( Strophe . NS . RSM , 'set' ) [ 0 ] ) ) { var lastEl = rsmEl . getElementsByTagName ( 'last' ) [ 0 ] ; if ( lastEl ) target . rsmLast = lastEl . textContent ; } }
function ( ) { xhr . useResult ( "invalid" ) ; lib . authenticate ( TEST_EMAIL , "testuser" , function onComplete ( authenticated ) { equal ( false , authenticated , "invalid authentication." ) ; start ( ) ; } , testHelpers . unexpectedXHRFailure ) ; }
function ( ) { var widget_data = { title : this . component_name , output : _ ( "This selector doesn't have an SLA" ) , class_icon : 'widget-weather-icon-info' } var _html = widget_weather_template . applyTemplate ( widget_data ) ; this . getEl ( ) . update ( _html ) }
function ( path ) { var url = "" ; if ( Surface . urlContext . _language != 'en' ) url = '/bf3/' + Surface . urlContext . _language + path ; else url = '/bf3' + path ; return url ; }
function ( issuer , next ) { if ( issuer === HOSTNAME ) { next ( "cannot authenticate to browserid with a certificate issued by it." ) ; } else { exports . getPublicKey ( issuer , function ( err , pubKey ) { if ( err ) return next ( err ) ; next ( null , pubKey ) ; } ) ; } }
function read_content ( myUrl ) { var result = null ; $ . ajax ( { url : myUrl , type : 'get' , dataType : 'html' , async : false , success : function ( data ) { result = data ; } } ) ; FileReady = true ; var converter = new Showdown . converter ( ) ; result = result . replace ( /\r\n/g , '\n' ) ; return converter . makeHtml ( result ) ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "block" ) ; return e = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return "this.block === " + e ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "blockMod" ) ; m = this . _apply ( "trans" ) ; return v = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return "this.mods && this.mods[" + m + "] === " + v ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "elem" ) ; return e = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return "this.elem === " + e ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "elemMod" ) ; m = this . _apply ( "trans" ) ; return v = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return "this.elemMods && this.elemMods[" + m + "] === " + v ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "xjst" ) ; return e = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return e ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "block" ) ; return e = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return "this.block === " + e ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "blockMod" ) ; m = this . _apply ( "trans" ) ; return v = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return "this.mods && this.mods[" + m + "] === " + v ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "elem" ) ; return e = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return "this.elem === " + e ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "elemMod" ) ; m = this . _apply ( "trans" ) ; return v = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return "this.elemMods && this.elemMods[" + m + "] === " + v ; }
function ( ) { this . _form ( function ( ) { return function ( ) { this . _applyWithArgs ( "exactly" , "xjst" ) ; return e = this . _apply ( "trans" ) ; } . call ( this ) ; } ) ; return e ; }
function ( aEvent ) { this . _logger . trace ( "_handlePageLoaded" ) ; let doc = aEvent . originalTarget ; this . _addEventListenersToDoc ( doc ) ; if ( this . _needToPopDown ( doc . defaultView . top ) ) { this . _logger . debug ( "_handlePageLoaded: *** closing since a page loaded into its host window" ) ; this . _panelCaption . ThumbnailZoomPlusOriginalTitleNode = null ; this . _originalCursorNode = null ; this . _currentThumb = null ; this . _closePanel ( true ) ; } }
function ( aEvent ) { that . _logger . debug ( "In image onerror" ) ; if ( that . _currentImage != aImageSrc ) { return ; } that . _hideCaption ( ) ; that . _logger . debug ( "image onerror: show warning briefly since error loading image (" + aEvent + ")" ) ; that . _showStatusIconBriefly ( aImageNode , "warning16.png" , 32 ) ; that . _imageObjectBeingLoaded = null ; }
function ( ) { var field = this . getElement ( ) ; if ( this . workaroundClassName_ ) { goog . dom . classes . add ( field , this . workaroundClassName_ ) ; } this . installStyles ( ) ; this . startChangeEvents ( ) ; this . logger . info ( 'Dispatching load ' + this . id ) ; this . dispatchEvent ( goog . editor . Field . EventType . LOAD ) ; }
function ( pokemon ) { if ( pokemon . hasType ( 'Flying' ) ) { if ( pokemon . types [ 0 ] === 'Flying' ) { pokemon . types = [ pokemon . types [ 1 ] ] ; } else { pokemon . types = [ pokemon . types [ 0 ] ] ; } } }
function init ( ) { $ ( "canvas" ) . after ( '<a id="y-gplus" class="inner-tooltip-invoke" title="Find Me on Google+" href="https://plus.google.com/b/101251082499312129098/101251082499312129098/posts"></a>' ) ; imgYRun . onload = handleImageLoad ; imgYRun . onerror = handleImageError ; imgYRun . src = "http://cdn.yetanotherwebdesigner.com/images/y-run.png" ; imgYIdle . onload = handleImageLoad ; imgYIdle . onerror = handleImageError ; imgYIdle . src = "http://cdn.yetanotherwebdesigner.com/images/y-idle.png" ; }
function ( a , b ) { return _ . indexOf ( self . state . get ( 'columnsOrder' ) , a . id ) > _ . indexOf ( self . state . get ( 'columnsOrder' ) , b . id ) ; }
function ( a , b ) { return _ . indexOf ( self . state . get ( 'columnsOrder' ) , a . id ) > _ . indexOf ( self . state . get ( 'columnsOrder' ) , b . id ) ; }
function ( res , status , jqXHR ) { console . group ( "AJAX QUERY RESULTS:" ) ; console . info ( "Loaded data from " + sUrl + " with status: " + status ) ; console . group ( "Response:" ) ; console . log ( res ) ; console . groupEnd ( ) ; console . groupEnd ( ) ; }
function ( res , status , jqXHR ) { console . group ( "AJAX QUERY RESULTS:" ) ; console . info ( "Send data to " + sUrl + " with status: " + status ) ; console . group ( "Response:" ) ; console . log ( res ) ; console . groupEnd ( ) ; console . groupEnd ( ) ; }
function ( fileInfo , base64 ) { }
function measure ( i ) { for ( var j = 0 ; j <= i ; j ++ ) { if ( j == 0 ) { $ ( ".progress_bar tr:first-child" ) . append ( "<td><img id='m_" + j + "' src='image/casebleue.png' /></td>" ) ; $ ( ".progress_bar tr:nth-child(2)" ) . append ( "<td>" + ( j + 1 ) + "</td>" ) ; } else { $ ( ".progress_bar tr:first-child" ) . append ( "<td><img id='m_" + j + "' src='image/casegrise.png' /></td>" ) ; $ ( ".progress_bar tr:nth-child(2)" ) . append ( "<td>" + ( j + 1 ) + "</td>" ) ; } } }
function ( ) { $ ( ".onglets_selected" ) . removeClass ( 'onglets_selected' ) $ ( this ) . addClass ( 'onglets_selected' ) var id = $ ( this ) . attr ( "id" ) ; var array = id . split ( '_' ) ; $ ( ".tab_svg #" + current_svg ) . css ( "display" , "none" ) ; current_svg = array [ 1 ] ; $ ( ".tab_svg #" + current_svg ) . css ( "display" , "block" ) ; onglet = true ; }
function ( event , ui ) { document . demo . SetVolume ( Math . floor ( ui . value * 1.27 ) ) ; if ( ui . value == 0 ) { if ( ! $ ( "#speaker" ) . hasClass ( "speakoff" ) ) { $ ( "#speaker" ) . removeClass ( "speakon" ) . addClass ( "speakoff" ) ; } } else if ( ! $ ( "#speaker" ) . hasClass ( "speakon" ) ) { $ ( "#speaker" ) . removeClass ( "speakoff" ) . addClass ( "speakon" ) ; } }
function ( crap ) { alert ( crap . message ) ; }
function ( rowid ) { var marker = hell . map . allmarkers [ $ ( '#tab' ) . jqGrid ( 'getRowData' , rowid ) . id ] ; if ( ! marker ) return ; hell . map . panTo ( marker . getLatLng ( ) ) ; marker . openPopup ( ) ; return true ; }
function indexAll ( docs ) { var lookupTable = { } , hasOwnProperty = Object . prototype . hasOwnProperty ; docs . forEach ( function ( doc ) { if ( ! hasOwnProperty . call ( lookupTable , doc . longname ) ) { lookupTable [ doc . longname ] = [ ] ; } lookupTable [ doc . longname ] . push ( doc ) ; } ) ; docs . index = lookupTable ; }
function ( doc ) { var name = doc . longname ; if ( ! hasOwnProperty . call ( docs . index , name ) ) { docs . index [ name ] = [ ] ; } docs . index [ name ] . push ( doc ) ; docs . push ( doc ) ; }
function _TagDefinition ( title , etc ) { etc = etc || { } ; this . title = dictionary . normalise ( title ) ; for ( var p in etc ) { if ( hasOwnProperty . call ( etc , p ) ) { this [ p ] = etc [ p ] ; } } }
function ( e ) { if ( ! hasOwnProperty . call ( seen , e . longname ) ) nav += '<li>' + linkto ( e . longname , e . name . replace ( /(^"|"$)/g , '' ) ) + '</li>' ; seen [ e . longname ] = true ; }
function ( g ) { if ( g . kind !== 'typedef' && ! hasOwnProperty . call ( seen , g . longname ) ) nav += '<li>' + linkto ( g . longname , g . name ) + '</li>' ; seen [ g . longname ] = true ; }
function ( offset , line , column , first , tail ) { var ret = [ first ] ; tail . forEach ( function ( i ) { ret . push ( i [ 1 ] ) ; } ) ; return ret ; }
function ( ) { var mh = new MultiHash ( ) ; mh . add ( { hello : 'bob' } ) ; mh . add ( { hello : 'joe' } ) ; assert . lengthOf ( mh , 1 ) ; assert . equal ( mh . keys ( ) [ 0 ] , 'hello' ) ; assert . equal ( mh . values ( 'hello' ) [ 0 ] , 'bob' ) ; assert . equal ( mh . values ( 'hello' ) [ 1 ] , 'joe' ) ; }
function ( ) { var mh = new MultiHash ( ) ; mh . add ( { hello : 'bob' } ) ; assert . lengthOf ( mh , 1 ) ; mh . add ( null ) ; assert . lengthOf ( mh , 1 ) ; }
function ( ) { var mh = new MultiHash ( ) ; mh . put ( 'hello' , 'world' ) ; mh . put ( 'foo' , 'bar' ) ; assert . lengthOf ( mh , 2 ) ; mh . del ( 'hello' ) assert . lengthOf ( mh , 1 ) ; assert . equal ( mh . values ( 'foo' ) [ 0 ] , 'bar' ) ; }
function checkServerStatus ( ) { var request = new XMLHttpRequest ( ) ; request . open ( "GET" , rssUrl , true ) ; request . onreadystatechange = function ( ) { if ( request . readyState == 4 ) { countGames ( request . responseXML . getElementsByTagName ( 'item' ) ) ; } } request . setRequestHeader ( "If-Modified-Since" , "Sat, 1 Jan 1984 00:00:00 GMT" ) ; request . send ( ) ; }
function countGames ( rssItems ) { if ( rssItems . length == 1 && rssItems . item ( 0 ) . childNodes [ 1 ] . firstChild . nodeValue == 'Empty lists' ) { chrome . browserAction . setBadgeText ( { 'text' : '' } ) ; } else { chrome . browserAction . setBadgeText ( { 'text' : rssItems . length . toString ( ) } ) ; } }
function ( tab ) { findOrOpenDGSStatusTab ( ) ; }
function ( file , dest ) { file = file || prefix + ".js" ; dest = dest || prefix + ".min.js" ; var minified = minify ( fs . readFileSync ( file , "utf-8" ) ) ; fs . writeFileSync ( dest , minified , "utf-8" ) ; sys . puts ( "> " + dest ) }
function getDateNumber ( ) { var now = dateToUse ; var nowDate = String ( now . getYear ( ) + 1900 ) ; var month = now . getMonth ( ) + 1 ; var day = now . getDate ( ) ; if ( month < 10 ) { nowDate += '0' ; } nowDate += month ; if ( day < 10 ) { nowDate += '0' ; } nowDate += day ; return Number ( nowDate ) ; }
function writeHighScoresScreen ( ) { drawHighScoreScreen ( ) ; }
function drawHomeScreen ( ) { ctx . drawImage ( homeScreen , 0 , 0 ) ; }
function drawHighScoreScreen ( ) { ctx . drawImage ( highScoreScreen , 0 , 0 ) ; }
function ( stream ) { console . log ( 'Streaming Tweets with filter "%s"...' , settings . stream ) activeStream = stream stream . on ( 'data' , onStreamedTweet ) stream . on ( 'error' , function ( err ) { console . error ( 'Error from Tweet stream: %s' , err ) fallback ( ) } ) stream . on ( 'destroy' , function ( data ) { console . log ( 'Stream destroyed: %s' , data ) fallback ( ) } ) }
function onStreamedTweet ( tweet ) { if ( settings . ignoreRTs && tweet . text . indexOf ( 'RT ' ) == 0 ) { console . log ( 'Filtered out RT: ' + tweet . text ) return } redisTweets . storeStream ( tweet , function ( err , storedTweet ) { if ( err ) { console . log ( 'Error storing Tweet: %s' , err ) return stop ( ) } ee . emit ( 'tweet' , storedTweet ) } ) }
function ( ) { onRadiusChanged ( { top : parseInt ( $ ( '.radius-top-field' , borderHtml ) . val ( ) , 10 ) || 0 , right : parseInt ( $ ( '.radius-right-field' , borderHtml ) . val ( ) , 10 ) || 0 , bottom : parseInt ( $ ( '.radius-bottom-field' , borderHtml ) . val ( ) , 10 ) || 0 , left : parseInt ( $ ( '.radius-left-field' , borderHtml ) . val ( ) , 10 ) || 0 } ) ; settings . onChange ( ) ; }
function ( ) { onSizeChanged ( { top : parseInt ( $ ( '.size-top-field' , borderHtml ) . val ( ) , 10 ) || 0 , right : parseInt ( $ ( '.size-right-field' , borderHtml ) . val ( ) , 10 ) || 0 , bottom : parseInt ( $ ( '.size-bottom-field' , borderHtml ) . val ( ) , 10 ) || 0 , left : parseInt ( $ ( '.size-left-field' , borderHtml ) . val ( ) , 10 ) || 0 } ) ; settings . onChange ( ) ; }
function ( event ) { var $this = $ ( this ) ; var options = $this . data ( 'alchemy-overlay' ) ; event . preventDefault ( ) ; Alchemy . openWindow ( $this . attr ( 'href' ) , options . title , options . size_x , options . size_y , options . resizable , options . overflow ) ; return false ; }
function ( ) { if ( this . options . createScroller ) { if ( this . $wrapper . children ( ) . length ) { this . $wrapper . children ( ) . wrapAll ( "<div/" ) ; } else { this . $wrapper . append ( "<div><div></div></div>" ) ; } } }
function canceledit ( id ) { if ( typeof ( id ) != 'undefined' && id != 0 ) { $ ( '#htmlcontent_' + id ) . html ( oldval ) ; } else if ( replyingid > 0 ) { $ ( '#reply_' + replyingid ) . hide ( ) ; } $ ( '#newforumitem' ) . hide ( ) ; $ ( '#newforumitem' ) . html ( '' ) ; replyingid = 0 ; }
function ( form , action ) { Ext . getCmp ( "newDialog" ) . destroy ( ) ; if ( ! action . result ) { Ext . MessageBox . alert ( "error" , _ ( 'ID_ERROR' ) ) ; return ; } Ext . MessageBox . alert ( "error" , action . result . error ) ; }
function ( ) { var eventDispatcher = get ( this , 'eventDispatcher' ) , stateManager = get ( this , 'stateManager' ) , customEvents = get ( this , 'customEvents' ) ; eventDispatcher . setup ( customEvents ) ; this . ready ( ) ; if ( stateManager ) { this . setupStateManager ( stateManager ) ; } }
function ( ) { app = Ember . Application . create ( { rootElement : '#qunit-fixture' } ) ; app . stateManager = Ember . StateManager . create ( { location : { getURL : function ( ) { return '/' ; } } , start : Ember . State . extend ( { index : Ember . State . extend ( { route : '/' } ) } ) } ) ; }
function ( ) { $area . autoResize ( { minHeight : 150 } ) . addClass ( 'focused' ) ; $ ( '#read-message .editor-tools' ) . show ( ) ; $ ( '#read-message input[type=submit]' ) . show ( ) ; Marky . createSimpleToolbar ( '#read-message .editor-tools' , '#id_message' ) ; new k . AjaxPreview ( $ ( '#preview-btn' ) , { changeHash : false } ) ; }
function ( btn ) { var form = this . getForm ( ) , record = form . getForm ( ) . getRecord ( ) , grid = this . getGrid ( ) ; form . commit ( ) ; if ( form . addMode ) { form . setAddMode ( false ) ; grid . store . add ( record ) ; grid . getSelectionModel ( ) . select ( record ) ; } form . setReadOnly ( true ) ; }
function ( padID , text , callback ) { getPadSafe ( padID , true , function ( err , pad ) { if ( ERR ( err , callback ) ) return ; pad . setText ( text ) ; padMessageHandler . updatePadClients ( pad , callback ) ; } ) ; }
function buildActivityHtml ( template , activity ) { var icon = activity . icon ; if ( icon != null && icon . length > 0 ) { if ( icon [ 0 ] == '/' ) { icon = icon . substring ( 1 ) ; } } else { icon = constants . noActivityTypeIcon ; } if ( activity . icon . indexOf ( NXGadgetContext . clientSideBaseUrl ) < 0 ) { activity . icon = NXGadgetContext . clientSideBaseUrl + icon ; } return Mustache . render ( template , activity ) ; }
function buildActivityHtml ( template , activity ) { if ( activity . icon . indexOf ( NXGadgetContext . clientSideBaseUrl ) < 0 ) { var icon = activity . icon ; if ( icon != null && icon . length > 0 ) { if ( icon [ 0 ] == '/' ) { icon = icon . substring ( 1 ) ; } } else { icon = constants . noActivityTypeIcon ; } activity . icon = NXGadgetContext . clientSideBaseUrl + icon ; } return Mustache . render ( template , activity ) ; }
function ( data ) { json = eval ( '(' + data + ')' ) ; plot ( json . data ) ; $ ( '#analytics-new-messages-range' ) . html ( v ) ; $ ( '#analytics-new-messages-range-type' ) . html ( range_type ) ; $ ( "#analytics-new-messages-update-loading" ) . hide ( ) ; }
function ( data ) { json = eval ( '(' + data + ')' ) ; count = $ ( ".health-throughput-current" ) ; count . html ( json . count ) ; count . fadeOut ( 200 , function ( ) { count . fadeIn ( 200 ) ; } ) ; }
function ( data ) { mqjson = eval ( '(' + data + ')' ) ; mqcount = $ ( ".health-mqsize-current" ) ; mqcount . html ( mqjson . count ) ; mqcount . fadeOut ( 200 , function ( ) { mqcount . fadeIn ( 200 ) ; } ) ; }
function ( data ) { result = eval ( '(' + data + ')' ) ; if ( result . code == "success" ) { render_result ( success ( result . ms , result . content , result . op , result . result ) ) ; } else { render_result ( error ( result . reason ) ) ; } bindMessageSidebarClicks ( ) ; eternalize ( ) ; }
function ( widget , states ) { var label = widget . getChildControl ( "label" ) ; var icon = widget . getChildControl ( "icon" ) ; if ( states . selected ) { label . setDecorator ( "selected" ) ; label . setTextColor ( "text-selected" ) ; icon . setDecorator ( "group" ) ; } else { label . resetDecorator ( ) ; label . resetTextColor ( ) ; icon . resetDecorator ( ) ; } }
function ( ) { if ( this . __useWidgetCells !== null ) { return ; } this . __useWidgetCells = this . getUseWidgetCells ( ) ; if ( this . __useWidgetCells ) { this . _initWidgetLayer ( ) ; } else { this . _initHtmlLayer ( ) ; } }
function ( ) { var id = ed . getParam ( 'wp_fullscreen_editor_id' ) || ed . getParam ( 'fullscreen_editor_id' ) || ed . id , link = tinymce . DOM . select ( '#wp-' + id + '-media-buttons a.thickbox' ) ; if ( link && link [ 0 ] ) link = link [ 0 ] ; else return ; tb_show ( '' , link . href ) ; tinymce . DOM . setStyle ( [ 'TB_overlay' , 'TB_window' , 'TB_load' ] , 'z-index' , '999999' ) ; }
function ( ) { if ( controller ) { try { controller . destroy ( ) ; controller = null ; } catch ( e ) { } } window . scriptRun = null ; delete window . scriptRun ; testHelpers . teardown ( ) ; }
function ( e ) { e . preventDefault ( ) ; $ . ajax ( { context : this , type : "GET" , url : $ ( this ) . attr ( 'href' ) , success : function ( data ) { $ ( this ) . parents ( '.formsetfieldwrap' ) . slideUp ( { duration : 300 , queue : false } ) . fadeOut ( { duration : 300 , queue : false } ) ; } } ) ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = new TestController ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayFPS ( true ) ; director . setAnimationInterval ( 1.0 / 60 ) ; var scene = Helloworld . scene ( ) ; director . runWithScene ( scene ) ; return true ; }
function ( ) { var tmp = this . _winSizeInPoints ; if ( this . _deviceOrientation == cc . DEVICE_ORIENTATION_LANDSCAPE_LEFT || this . _deviceOrientation == cc . DEVICE_ORIENTATION_LANDSCAPE_RIGHT ) { var size = new cc . SizeZero ( ) ; size . width = tmp . height ; size . height = tmp . width ; return size ; } return tmp ; }
function ( ) { var m = new Matrix2 ( ) ; expect ( m . getColumn0Row0 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn0Row1 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn1Row0 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn1Row1 ( ) ) . toEqual ( 0 ) ; }
function ( ) { var m = new Matrix2 ( 1 ) ; expect ( m . getColumn0Row0 ( ) ) . toEqual ( 1 ) ; expect ( m . getColumn0Row1 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn1Row0 ( ) ) . toEqual ( 0 ) ; expect ( m . getColumn1Row1 ( ) ) . toEqual ( 1 ) ; }
function ( ) { var m = new Matrix2 ( 1 , 2 , 3 , 4 ) ; expect ( m . getColumn0Row0 ( ) ) . toEqual ( 1 ) ; expect ( m . getColumn0Row1 ( ) ) . toEqual ( 3 ) ; expect ( m . getColumn1Row0 ( ) ) . toEqual ( 2 ) ; expect ( m . getColumn1Row1 ( ) ) . toEqual ( 4 ) ; }
function ( user ) { if ( ! this . users [ user . uid ] ) return ; this . users [ user . uid ] . removeListener ( 'updatelocation' , this . onUserUpdate ) ; delete this . users [ user . uid ] ; if ( user . updateTimeout ) clearTimeout ( user . updateTimeout ) ; this . sendUpdates ( new BGTUpdate ( 'quit' , { user : { id : user . uid } } ) ) ; }
function goBack ( ) { var pageName ; if ( pageHistory . length > 1 ) { pageName = pageHistory . pop ( ) ; pageName = pageHistory . pop ( ) ; showPage ( pageName ) ; } else { console . log ( 'Nothing in pageHistory to go back to' ) ; } }
function ( elem , info ) { elem . type = info . type ; elem . src = info . src ; elem . href = info . src ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info . src ; elem . href = info . src ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info . src ; elem . href = info . src ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info . src ; elem . href = info . src ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info ; elem . href = info ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info . src ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . revealImageDeferred ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; elem . src = info . src ; modules [ 'showImages' ] . revealImageDeferred ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info ; elem . href = info ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info ; elem . href = info ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info ; elem . href = info ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info ; elem . href = info ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( elem , info ) { elem . type = 'IMAGE' ; elem . src = info ; elem . href = info ; $ ( elem ) . closest ( '.thing' ) . find ( '.thumbnail' ) . attr ( 'href' , elem . href ) ; modules [ 'showImages' ] . createImageExpando ( elem ) ; }
function ( ) { var transform = Transforms . eastNorthUpToFixedFrame ( ellipsoid . cartographicDegreesToCartesian ( new Cartographic2 ( - 75.0 , 40.0 ) ) ) ; controller . setReferenceFrame ( transform , ellipsoid ) ; expect ( controller . getEllipsoid ( ) ) . toBe ( ellipsoid ) ; expect ( controller . _camera . transform ) . toBe ( transform ) ; }
function ( ) { var camera = new Camera ( document ) ; camera . frustum = new OrthographicFrustum ( ) ; controller2 = new Camera2DController ( document , camera , ellipsoid ) ; expect ( function ( ) { controller2 . zoomIn ( moverate ) ; } ) . toThrow ( ) ; }
function ( ) { collection . add2D ( ) ; collection . addColumbusView ( ) ; expect ( function ( ) { collection . update ( ) ; } ) . not . toThrow ( ) ; expect ( collection . getLength ( ) ) . toEqual ( 2 ) ; }
function ( ) { 'use strict' ; var Router = Backbone . Router . extend ( { routes : { "/:filter" : "setFilter" , "/:*" : "setFilter" } , setFilter : function ( param ) { window . app . TodoFilter = param || "" ; window . app . Todos . trigger ( 'reset' ) ; } } ) ; window . app . TodoRouter = new Router ; Backbone . history . start ( ) ; }
function ( status ) { if ( status === "complete" ) { user . syncEmails ( function ( ) { self . close ( self . verificationMessage ) ; oncomplete && oncomplete ( ) ; } ) ; } else if ( status === "mustAuth" ) { self . close ( "authenticate" , { email : self . email } ) ; oncomplete && oncomplete ( ) ; } }
function ( ) { xhr . useResult ( "mustAuth" ) ; testVerifiedUserEvent ( "authenticate" , "User Must Auth" ) ; }
function ( obj , index , colwidth ) { var style = getStyle ( index ) ; obj . css ( { 'width' : colwidth , 'left' : style . x * colwidth , 'top' : style . y * ( settings . rowHeight + settings . itemHeight ) , 'height' : settings . itemHeight } ) ; obj . addClass ( 'snaky-item ' + style . class ) ; }
function applyCitationMarkup ( outline , publishContentToView ) { var scriptureRange = outline . head . ScriptureRange ; var bookName1 = getBookName ( scriptureRange ) ; if ( bookName1 == null ) { return ; } for ( i = 0 ; i < outline . body . concepts . length ; i ++ ) { applyCitationMarkupForItemToViews ( outline . body . concepts , bookName1 , i , scriptureRange , publishContentToView ) ; } }
function refreshScriptureTagging ( ) { Logos . ReferenceTagging . tag ( ) ; }
function ( file ) { console . log ( timestamp ( ) , '- processing file:       ' , file ) ; if ( ! path . existsSync ( file ) ) { console . log ( 'file: ' , file , ' does not exist.' ) ; switch ( params . file_err ) { case 'break' : console . log ( timestamp ( ) , ' - terminating build.' ) ; return ; case 'continue' : break ; } } src += Templ8 . format ( '\n{0}' , fs . readFileSync ( file , params . encoding ) ) ; }
function ( alternative ) { var $playlist ; if ( alternative ) { self . play ( alternative ) ; alternative . createListView ( ) ; $playlist = video . listView . parents ( '.tracklist' ) ; if ( $playlist . length ) { alternative . createAlternativeContextMenuButton ( video , $playlist . data ( 'model' ) ) ; } if ( video . listView ) { video . listView . data ( 'model' , alternative ) ; } } else { self . next ( ) ; } }
function ( ) { var i = 0 ; for ( i ; i < playlist . videos . length ; i += 1 ) { if ( playlist . videos [ i ] === originalTrack ) { playlist . videos . splice ( i , 1 , self ) ; playlist . synced = false ; playlist . sync ( ) ; self . listView . insertAfter ( originalTrack . listView ) ; originalTrack . listView . remove ( ) ; } } }
function useThread ( threadName , method , args ) { if ( typeof threadName == "string" ) { Array . prototype . shift . apply ( args ) ; } else { threadName = '' ; } return method . apply ( TIMING_THREADS [ threadName ] = ( TIMING_THREADS [ threadName ] || jQuery ( '<div>' ) . text ( threadName ) ) , args ) ; }
function ( action ) { var waiting = dragging . length , f = function ( ) { waiting -- ; if ( waiting == 0 ) { action ( dragging ) ; } } ; if ( ! this . search . active ) { music . utils . each ( dragging , function ( i , e ) { e . loadChildren ( f ) ; } ) ; } else { f ( ) ; } }
function ( ) { var len = this . planes . length ; { var _g = 0 ; while ( _g < len ) { var i = _g ++ ; this . planes [ i ] = new glidias . Vec3 ( 0 , 0 , 0 , 0 ) ; } } }
function ( s ) { var l = s . length ; var r = 0 ; while ( r < l && StringTools . isSpace ( s , r ) ) { r ++ ; } if ( r > 0 ) return s . substr ( r , l - r ) ; else return s ; }
function ( s ) { var l = s . length ; var r = 0 ; while ( r < l && StringTools . isSpace ( s , l - r - 1 ) ) { r ++ ; } if ( r > 0 ) { return s . substr ( 0 , l - r ) ; } else { return s ; } }
function ( s , c , l ) { var ns = "" ; var sl = s . length ; if ( sl >= l ) return s ; var cl = c . length ; while ( sl < l ) { if ( l - sl < cl ) { ns += c . substr ( 0 , l - sl ) ; sl = l ; } else { ns += c ; sl += cl ; } } return ns + s ; }
function ( onComplete ) { this . _onComplete = onComplete ; haxe . Log . trace ( "RUNNING..." , { fileName : "RoomFiller.hx" , lineNumber : 89 , className : "glidias.RoomFiller" , methodName : "run" } ) ; this . createFirstRoom ( ) ; if ( this . async == 0 ) null ; else null ; }
function ( s , e , w , h ) { { var _g1 = s , _g = w + 1 ; while ( _g1 < _g ) { var i = _g1 ++ ; { var _g3 = e , _g2 = h + 1 ; while ( _g3 < _g2 ) { var j = _g3 ++ ; if ( this . grid [ i ] [ j ] != 0 ) return false ; } } } } return true ; }
function ( x , y , z , w ) { if ( x === $_ ) return ; { if ( w == null ) w = 0 ; this . x = x ; this . y = y ; this . z = z ; this . w = w ; } }
function ( p ) { if ( p === $_ ) return ; { { this . minX = 1.7976931348623157e+308 ; this . minY = 1.7976931348623157e+308 ; this . minZ = 1.7976931348623157e+308 ; this . maxX = - 1.7976931348623157e+308 ; this . maxY = - 1.7976931348623157e+308 ; this . maxZ = - 1.7976931348623157e+308 ; } this . portals = new Array ( ) ; } }
function ( a1 , b1 ) { var a2 = right . x * a1 . minX + right . y * a1 . minY + right . z * a1 . minZ ; var b2 = right . x * b1 . minX + right . y * b1 . minY + right . z * b1 . minZ ; if ( a2 < b2 ) { return - 1 ; } else if ( a2 == b2 ) return 0 ; return 1 ; }
function ( a , b ) { var a2 = right . x * a . minX + right . y * a . minY + right . z * a . minZ ; var b2 = right . x * b . minX + right . y * b . minY + right . z * b . minZ ; if ( a2 < b2 ) { return - 1 ; } else if ( a2 == b2 ) return 0 ; return 1 ; }
function ( x , y , z , w ) { if ( x === $_ ) return ; { if ( w == null ) w = 0 ; this . x = x ; this . y = y ; this . z = z ; this . w = w ; } }
function ( displayObj ) { if ( displayObj === $_ ) return ; { this . states = haxe . io . Bytes . alloc ( 32 ) ; this . jDoc = new $ ( displayObj != null ? displayObj : js . Lib . document ) ; this . jDoc . keydown ( $closure ( this , "keyDownListener" ) ) ; this . jDoc . keyup ( $closure ( this , "keyUpListener" ) ) ; } }
function ( x , y , z , w ) { if ( x === $_ ) return ; { if ( w == null ) w = 0. ; if ( z == null ) z = 0. ; if ( y == null ) y = 0. ; if ( x == null ) x = 0. ; this . w = w ; this . x = x ; this . y = y ; this . z = z ; } }
function ( length ) { var a = new Array ( ) ; { var _g = 0 ; while ( _g < length ) { var i = _g ++ ; a . push ( 0 ) ; } } return new haxe . io . Bytes ( length , a ) ; }
function ( other ) { var b1 = this . b ; var b2 = other . b ; var len = this . length < other . length ? this . length : other . length ; { var _g = 0 ; while ( _g < len ) { var i = _g ++ ; if ( b1 [ i ] != b2 [ i ] ) return b1 [ i ] - b2 [ i ] ; } } return this . length - other . length ; }
function ( p ) { if ( p === $_ ) return ; { this . id = glidias . AABBSector . ID_COUNT ++ ; this . renderId = - 999999999 ; this . collisionId = - 999999999 ; this . geom = new a3d . Geometry ( ) ; } }
function ( direction ) { var len = this . portalWalls . length ; { var _g = 0 ; while ( _g < len ) { var i = _g ++ ; if ( this . portalWalls [ i ] . direction == direction ) return this . portalWalls [ i ] ; } } return null ; }
function ( ) { var arr = [ ] ; { var _g1 = 0 , _g = this . portalWalls . length ; while ( _g1 < _g ) { var i = _g1 ++ ; var portalPlane = this . portalWalls [ i ] ; var portals = portalPlane . portals ; { var _g3 = 0 , _g2 = portals . length ; while ( _g3 < _g2 ) { var u = _g3 ++ ; arr . push ( portals [ u ] ) ; } } } } return arr ; }
function ( truncateLength , fixed ) { if ( fixed == null ) fixed = false ; if ( truncateLength == null ) truncateLength = false ; { var _g1 = this . _i , _g = this . _len ; while ( _g1 < _g ) { var i = _g1 ++ ; this . _vec [ i ] = null ; } } if ( truncateLength ) { this . _vec . length = this . _i ; this . _len = this . _i ; } }
function ( amount , fixed ) { this . _vec . length = amount ; this . _len = amount ; while ( -- amount > - 1 ) { if ( this . _vec [ amount ] == null ) this . _vec [ amount ] = this . _method ( ) ; } }
function ( v ) { if ( v === $_ ) return ; { if ( v != null && v . length == 16 ) { this . rawData = v ; } else { this . rawData = [ 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ] ; } } }
function ( truncateLength , fixed ) { if ( fixed == null ) fixed = false ; if ( truncateLength == null ) truncateLength = false ; { var _g1 = this . _i , _g = this . _len ; while ( _g1 < _g ) { var i = _g1 ++ ; this . _vec [ i ] = null ; } } if ( truncateLength ) { this . _vec . length = this . _i ; this . _len = this . _i ; } }
function ( amount , fixed ) { this . _vec . length = amount ; this . _len = amount ; while ( -- amount > - 1 ) { if ( this . _vec [ amount ] == null ) this . _vec [ amount ] = this . _method ( ) ; } }
function ( fillAmount , initialCapacity ) { if ( fillAmount === $_ ) return ; { if ( initialCapacity == null ) initialCapacity = 0 ; if ( fillAmount == null ) fillAmount = 0 ; this . renderId = 0 ; this . sectorStack = new glidias . ArrayBuffer_glidias_AABBSector ( ) ; this . frustumStack = new glidias . AllocatorF_glidias_Frustum ( $closure ( glidias . Frustum , "create4" ) , fillAmount , initialCapacity ) ; } }
function ( ) { this . mDb . selectQuery ( "select A.rowid, A.name, A.user_id, B.name " + "from km_creditcard_info A, km_user B " + "where A.user_id = B.id" ) ; var records = this . mDb . getRecords ( ) ; var types = this . mDb . getRecordTypes ( ) ; var columns = this . mDb . getColumns ( ) ; this . PopulateTableData ( records , columns , types ) ; this . ShowTable ( true ) ; }
function ( ) { this . mDb . selectQuery ( "select rowid, name, internal from km_item" ) ; var records = this . mDb . getRecords ( ) ; var types = this . mDb . getRecordTypes ( ) ; var columns = this . mDb . getColumns ( ) ; this . mItemList = this . mDb . getRecords ( ) ; this . PopulateTableData ( records , columns , types ) ; this . ShowTable ( true ) ; }
function ( ) { this . mDb . selectQuery ( "select id, name from km_user" ) ; var records = this . mDb . getRecords ( ) ; var types = this . mDb . getRecordTypes ( ) ; var columns = this . mDb . getColumns ( ) ; this . mUserList = this . mDb . getRecords ( ) ; this . PopulateTableData ( records , columns , types ) ; this . ShowTable ( true ) ; }
f var alias = alias || 'value' , key = key && key . substr ( 1 ) ; var _iterate = 'i' + _counter ++ ; return '<% for(var ' + _iterate + ' in ' + _name + ') {' + 'if(' + _name + '.hasOwnProperty(' + _iterate + ')) {' + 'var ' + alias + '=' + _name + '[' + _iterate + '];' + ( key ? ( 'var ' + key + '=' + _iterate + ';' ) : '' ) + '}' + ' %>' ; } )
f var alias = alias || 'value' , key = key && key . substr ( 1 ) ; var _iterate = 'i' + _counter ++ ; return '<% for(var ' + _iterate + ' in ' + _name + ') {' + 'if(' + _name + '.hasOwnProperty(' + _iterate + ')) {' + 'var ' + alias + '=' + _name + '[' + _iterate + '];' + ( key ? ( 'var ' + key + '=' + _iterate + ';' ) : '' ) + '}' + ' %>' ; } )
function ( ) { makeCE ( ) ; expect ( ce . add ( null ) ) . toBe ( ce ) ; }
function ( ) { makeCE ( '.foo' ) ; expect ( ce . item ( 2 ) . dom . id ) . toBe ( 'g' ) ; }
function ( ) { it ( "should return null when there are no items" , function ( ) { makeCE ( ) ; expect ( ce . first ( ) ) . toBeNull ( ) ; } ) ; it ( "should return the first item" , function ( ) { makeCE ( '.foo' ) ; expect ( ce . first ( ) . dom . id ) . toBe ( 'a' ) ; } ) ; }
function ( list , index , node , record ) { if ( ! this . showContact ) { this . showContact = Ext . create ( 'RaxaEmr.Outpatient.view.patient.more' ) ; } this . showContact . setRecord ( record ) ; this . getMain ( ) . push ( this . showContact ) ; }
function event_favicon ( ) { if ( ! favicon_changed ) { favicon . change ( "/static/favicon-event.ico" ) ; favicon_changed = true ; if ( timeout_id != undefined ) { clearTimeout ( timeout_id ) ; timeout_id = undefined ; } if ( document . hasFocus ( ) ) { timeout_id = setTimeout ( function ( ) { favicon . change ( "/favicon.ico" ) ; favicon_changed = false ; } , 2000 ) ; } } }
function ( ) { var def1 = new Deferred ( ) , def2 = new Deferred ( ) , defList = new DeferredList ( [ def1 , def2 ] , true , true ) ; stop ( ) ; expect ( 1 ) ; defList . then ( function ( ) { ok ( false , 'Test must go to reject callback' ) ; start ( ) ; } , function ( ) { ok ( defList . isRejected ( ) , 'Test goes to reject callback' ) ; start ( ) ; } ) ; def1 . reject ( ) ; }
function ( ) { var org = new BioLogica . Organism ( BioLogica . Species . Drake , "a:rh,b:rh" , BioLogica . MALE ) ; expect ( org . species . name ) . toBe ( "Drake" ) ; expect ( org . sex ) . toBe ( BioLogica . MALE ) ; expect ( org . genetics . genotype . chromosomes [ 'XY' ] [ 'y' ] . alleles . length ) . toBe ( 0 ) ; }
function ( ) { var f = ( function ( _hashmap ) { return _map ( ) ( ( function ( ) { var $m ; return ( function ( ) { return $m || ( $m = ( function ( _cell ) { return _key ( ) ( _cell ) ; } ) ) } ) } ) ( ) ) ( _hashmap ) ; } ) ; return function _getKeys ( ) { return f ; } }
function ( ) { var f = ( function ( _hashmap ) { return _length ( ) ( ( function ( ) { var $m ; return ( function ( ) { return $m || ( $m = ( _getKeys ( ) ( _hashmap ) ) ) } ) } ) ( ) ) ; } ) ; return function _numKeys ( ) { return f ; } }
function ( ) { var f = ( function ( _hm1 ) { return function ( _hm2 ) { return _mergeHashKeys ( ) ( _hm1 ) ( _hm2 ) ( ( function ( ) { var $m ; return ( function ( ) { return $m || ( $m = ( _getKeys ( ) ( _hm2 ) ) ) } ) } ) ( ) ) ; } ; } ) ; return function _mergeHash ( ) { return f ; } }
function _request ( method , path , data , cb ) { $ . ajax ( { type : method , url : API_URL + path , data : JSON . stringify ( data ) , dataType : 'json' , contentType : 'application/x-www-form-urlencoded' , success : function ( res ) { cb ( null , res ) ; } , error : function ( err ) { cb ( err ) ; } , headers : headers ( ) } ) ; }
function _raw_request ( method , path , data , cb ) { $ . ajax ( { type : method , url : API_URL + path , data : JSON . stringify ( data ) , contentType : 'application/x-www-form-urlencoded' , success : function ( res ) { cb ( null , res ) ; } , error : function ( err ) { cb ( err ) ; } , headers : headers ( ) } ) ; }
function ( msg ) { if ( msg [ 'id' ] == id ) { success = msg [ 'result' ] ; if ( success && this . onsuccess ) this . onsuccess ( msg [ 'result' ] ) ; else if ( ! success && this . onfailed ) this . onfailed ( msg [ 'error' ] [ 'code' ] , msg [ 'error' ] [ 'message' ] ) ; } }
function ( ) { $ ( 'div.invitation_form_hidden_parts' ) . slideDown ( 'fast' ) ; $ ( document ) . bind ( 'focusin.invitation_form_hidden_parts click.invitation_form_hidden_parts' , function ( e ) { if ( $ ( e . target ) . closest ( '.invitation_form_hidden_parts, #invitation_email' ) . length ) return ; $ ( document ) . unbind ( '.example' ) ; $ ( 'div.invitation_form_hidden_parts' ) . slideUp ( 'fast' ) ; } ) ; }
function auto_resize_text_areas ( ) { $ ( 'textarea' ) . autoResize ( { onResize : function ( ) { $ ( this ) . css ( { opacity : 0.8 } ) ; } , animateCallback : function ( ) { $ ( this ) . css ( { opacity : 1 } ) ; } , animateDuration : 300 } ) ; $ ( 'textarea' ) . keydown ( ) ; }
function errorHandler ( err ) { clearTimeout ( self . _state . tmrConn ) ; if ( self . _state . status === STATES . NOCONNECT ) loginCb ( new Error ( 'Unable to connect. Reason: ' + err ) ) ; self . emit ( 'error' , err ) ; self . debug ( 'Error occurred: ' + err ) ; }
function ( err ) { if ( err || step ++ === 2 ) return cb ( err ) ; self . _state . conn . cleartext . write ( data ) ; self . _state . conn . cleartext . write ( CRLF ) ; self . debug ( '\n<<SENT>>: ' + util . inspect ( data . toString ( ) ) + '\n' ) ; }
function ( query , callback ) { var api = 'http://search.twitter.com/search.json?q=' ; Y . io ( api + query , { on : { success : function ( id , e ) { var json = JSON . parse ( e . responseText ) ; callback ( json ) ; } , failure : function ( ) { Y . log ( 'Failed to call Twitter' , 'error' , NAME ) ; callback ( { } ) ; } } } ) ; }
function ( ) { readUUID ( ) ; SDL . defaults . copyOnLock = false ; var save_path = 'http://play-ttd.com/save/' + Module [ 'UUID' ] + '/' ; FS . createPath ( '/' , 'home/caiiiycuk/play-ttd/etc/preload/save' , true , true ) ; FS . createPreloadedFile ( '/home/caiiiycuk/play-ttd/etc/preload/save' , 'saved_on_server.sav' , save_path + 'saved_on_server.sav' , true , true ) ; }
function ClientTcpServer ( port , adaptor ) { console . log ( "Starting server on 3000" ) ; var net = require ( 'net' ) ; this . server = net . createServer ( function ( socket ) { sutil . newOutlet ( socket , thisAdaptor , loginCallback ) ; } ) ; this . server . listen ( port ) ; }
function ( message , errText , stack , level , tenantId , sessionId ) { this . message = message ; this . errText = errText ; this . stack = stack ; this . level = level ; this . tenantId = tenantId ; this . sessionId = sessionId ; this . swarm ( "doLog" ) ; }
function ( file ) { var header = findHeader ( file . responseHeaders , "set-cookie" ) ; var result = [ ] ; var cookies = header ? header . split ( "\n" ) : [ ] ; for ( var i = 0 ; i < cookies . length ; i ++ ) { var cookie = this . parseCookieFromResponse ( cookies [ i ] ) ; result . push ( cookie ) ; } return result ; }
function MessageComposition ( api , handle ) { this . _api = api ; this . _handle = handle ; this . senderIdentity = null ; this . to = null ; this . cc = null ; this . bcc = null ; this . subject = null ; this . body = null ; this . _customHeaders = null ; this . _attachments = null ; }
function ( ) { return { senderId : this . senderIdentity . id , to : this . to , cc : this . cc , bcc : this . bcc , subject : this . subject , body : this . body , customHeaders : this . _customHeaders , attachments : this . _attachments , } ; }
function handleOk ( fraseElement , autorElement ) { if ( fraseElement . className === "frase_ok" ) { console . log ( "ya esta ok" ) return } fraseElement . className = "frase_ok" i = fraseElement . children [ 0 ] . innerHTML autor = autorElement . children [ 0 ] . innerHTML i = i + '<label class="autor_label"> - ' + autor + '</label>' fraseElement . children [ 0 ] . innerHTML = i console . log ( i ) console . log ( "ok" ) score ( SCORE_OK ) }
function handleBuild ( ) { var node = $ ( this ) , action = node . attr ( 'id' ) . split ( "-" ) [ 2 ] ; bus . ajax ( "GET" , "http://127.0.0.1:9910/ripple/about" , null , function ( ) { doBuild ( ) ; } , function ( error ) { if ( error . code === 0 || error . code === 404 ) { startServices ( function ( ) { doBuild ( ) ; } ) ; } } ) ; }
function doBuild ( ) { if ( node . hasClass ( "not-ready" ) ) { return ; } if ( ! settings . can ( action ) ) { settings . show ( action ) ; } else { settings . perform ( action ) ; } }
function init ( x ) { hunts = JSON . parse ( x ) ; $ ( 'username' ) . innerHTML = hunts [ 0 ] ; multiple = hunts [ 2 ] ; hunts = hunts [ 1 ] ; for ( x = 0 ; x < hunts . length ; x ++ ) $ ( 'selecthunt' ) . options [ $ ( 'selecthunt' ) . options . length ] = new Option ( hunts [ x ] [ 'title' ] , x ) ; }
function ( path ) { var state = window . history . state ; if ( path === "" ) { path = '/' ; } if ( ! state || ( state && state . path !== path ) ) { window . history . pushState ( { path : path } , null , path ) ; } }
function ( email , assertion , onComplete , onFailure ) { post ( { url : "/wsapi/auth_with_assertion" , data : { email : email , assertion : assertion , ephemeral : ! storage . usersComputer . confirmed ( email ) } , success : handleAuthenticationResponse . curry ( "assertion" , onComplete , onFailure ) , error : onFailure } ) ; }
function redirectToMonitored ( req , res , cxt ) { var options = cxt . options , match = cxt . match , m = monitored ; res . setHeader ( "Location" , "/make/" + m . factory + '.' + m . type + '.mon' ) ; res . writeHead ( 302 ) ; res . end ( ) ; }
function ( ) { var req = JSON . parse ( data ) ; test ( assert . strictEqual , req . method , 'GET' ) ; test ( assert . strictEqual , req . url , '/testhttp' ) ; test ( assert . strictEqual , res . statusCode , 200 ) ; test ( assert . strictEqual , typeof res . headers , 'object' ) ; cb ( null ) ; }
function ( ) { var req = JSON . parse ( data ) ; test ( assert . strictEqual , req . method , 'POST' ) ; test ( assert . strictEqual , req . url , '/testhttp' ) ; test ( assert . strictEqual , req . postData , 'abcdef' ) ; cb ( null ) ; }
function ( ) { var req = JSON . parse ( data ) ; test ( assert . strictEqual , req . method , 'PUT' ) ; test ( assert . strictEqual , req . url , '/testhttp' ) ; test ( assert . strictEqual , req . postData , 'abcdefg' ) ; cb ( null ) ; }
function ( factory , type ) { var ti = this . docInfo , req = http . request ( { method : 'POST' , path : '/monitor/' + ti . factory + '.' + ti . type } , function ( res ) { res . on ( 'error' , function ( e ) { alert ( 'Error setting monitored application' ) ; } ) ; } ) ; req . end ( ) ; return this ; }
function ( ) { var that = this , req = http . request ( { method : 'POST' , path : '/makehelp' } , function ( res ) { res . on ( 'end' , function ( e ) { that . showPackages ( ) ; } ) ; } ) ; req . end ( ) ; }
function ( ) { var name = getNewPackageName ( ) , req ; if ( name ) { req = http . request ( { method : 'PUT' , path : '/package/' + name } , function ( res ) { res . on ( 'error' , function ( e ) { alert ( 'Error saving' ) ; } ) ; res . on ( 'end' , function ( ) { } ) ; } ) ; req . end ( ) ; } else { alert ( 'invalid name ' + name ) ; } }
function ( ) { var ti = that . typeInfo , req = http . request ( { method : 'POST' , path : '/monitor/' + ti . factory + '.' + ti . type } , function ( res ) { res . on ( 'error' , function ( e ) { alert ( 'Error setting monitored application' ) ; } ) ; } ) ; req . end ( ) ; }
function ( ) { var ti = that . typeInfo , req = http . request ( { method : 'DELETE' , path : '/package/' + ti . factory + '/visual/' + ti . type } , function ( res ) { res . on ( 'error' , function ( e ) { alert ( 'Error deleting' ) ; } ) ; } ) ; req . end ( ) ; }
function ( str , inv ) { var ret = [ ] ; for ( i = 0 ; i < str . length ; i += 2 ) ret [ i / 2 ] = parseInt ( str . substr ( i , 2 ) , 16 ) ; return ret ; }
function ( id ) { if ( id . indexOf ( "/" ) === - 1 ) { id = config . path + "/" + id ; } if ( id . indexOf ( "." ) === - 1 ) { id += ".js" ; } return id ; }
function getShortcuts ( shortcuts ) { var len = shortcuts . length ; for ( var i = 0 ; i < len ; i ++ ) { var origin = shortcuts [ i ] ; if ( origin in installedApps ) { delete installedApps [ origin ] ; } } for ( var origin in installedApps ) { GridManager . install ( installedApps [ origin ] ) ; } updatePaginationBar ( ) ; finish ( ) ; addLanguageListener ( ) ; }
function startup ( ) { PinLock . init ( ) ; SoundManager . init ( ) ; SleepMenu . init ( ) ; SourceView . init ( ) ; Shortcuts . init ( ) ; Bluetooth . init ( ) ; window . focus ( ) ; function dumbListener2 ( event ) { } window . addEventListener ( 'devicemotion' , dumbListener2 ) ; window . setTimeout ( function ( ) { window . removeEventListener ( 'devicemotion' , dumbListener2 ) ; } , 2000 ) ; }
function ( data , msg , xhr ) { this . logger . log ( LogLevel . DEBUG , "myna.reward successWrapper called" ) ; myna . token = null ; this . logger . log ( LogLevel . INFO , "myna.reward succeeded" ) ; if ( success ) { return success ( ) ; } }
function ( xhr , text , error ) { var response ; this . logger . log ( LogLevel . DEBUG , "myna.reward errorWrapper called" ) ; response = parseErrorResponse ( xhr . responseText ) ; this . logger . log ( LogLevel . ERROR , "myna.reward failed: error " + response . code + " " + response . message ) ; if ( error ) { return error ( response . code , response . message ) ; } }
function ( content , options ) { this . options = options this . $element = $ ( content ) . delegate ( '[data-dismiss="modal"]' , 'click.dismiss.modal' , $ . proxy ( this . hide , this ) ) this . options . remote && this . $element . find ( '.modal-body' ) . load ( this . options . remote ) }
function ( content , options ) { this . options = options this . $element = $ ( content ) . delegate ( '[data-dismiss="modal"]' , 'click.dismiss.modal' , $ . proxy ( this . hide , this ) ) this . options . remote && this . $element . find ( '.modal-body' ) . load ( this . options . remote ) }
function ( content , options ) { this . options = options this . $element = $ ( content ) . delegate ( '[data-dismiss="modal"]' , 'click.dismiss.modal' , $ . proxy ( this . hide , this ) ) this . options . remote && this . $element . find ( '.modal-body' ) . load ( this . options . remote ) }
function ( request , response ) { var handlers = this . handlers , handled = false ; for ( var i = 0 , il = handlers . length ; i < il && ! handled ; i ++ ) { var handler = handlers [ i ] ; handled = handler . canHandle ( request ) ; if ( handled ) { handler . handleRequest ( request , response ) ; } } if ( ! handled ) { this . defaultHandler . handleRequest ( request , response ) ; } }
function RequestHandler ( options ) { options = options || { } ; this . subDomain = options . domain || "apps" ; this . baseDomain = options . baseDomain || "feedhenry.com" ; this . domain = this . subDomain + "." + options . baseDomain ; this . guid = options . app || options . guid || "" ; }
function ( ) { var params ; try { self . act ( act , JSON . parse ( paramString ) , function ( err , res ) { if ( err ) { self . handleError ( err , response ) ; } else { self . doResponse ( res , response ) ; } } ) ; } catch ( e ) { return self . handleError ( e , response ) ; } }
function ( name , onFinish , onUpdate ) { if ( this . flickering ( ) != name ) { this . animate_finish = onFinish ; this . animate_update = onUpdate ; var a = this . animates [ name ] ; this . flicker ( a [ 0 ] , a [ 1 ] , a [ 2 ] , name ) ; if ( a . push ) this . flicker_run ( ) ; } return this ; }
function ( b ) { if ( re . is ( b ) ) { this . attr ( { _image : b , sizeX : b . width , sizeY : b . height } ) ; return this ; } return this . _image ; }
function ( element , name , smart ) { name = this . __styleNames [ name ] || this . __getStyleName ( name ) || name ; if ( smart !== false && this . __special [ name ] ) { return this . __special [ name ] . reset ( element ) ; } else { element . style [ name ] = "" ; } }
function ( line ) { Array . push ( sel . options , ( new Element ( 'option' , { 'value' : line . id , 'text' : line . name } ) ) ) ; if ( typeOf ( 'line' ) != undefined && line . id == id ) { sel . selectedIndex = index ; } index ++ ; }
function ( e ) { if ( e . which == 40 ) { self . moveSelection ( 'down' ) ; } else if ( e . which == 38 ) { self . moveSelection ( 'up' ) ; } else if ( e . which == 13 ) { var active = $ ( '.fac-container .fac-item.active' ) ; select ( active ) ; } else if ( e . which == 27 ) { self . dismissHints ( ) ; } }
function ( ) { $ ( '.fac-container' ) . empty ( ) ; $ ( '.fac-container' ) . css ( 'display' , 'block' ) . css ( 'position' , 'absolute' ) . css ( 'left' , $ ( this . input ) . position ( ) . left ) . css ( 'top' , $ ( this . input ) . position ( ) . top + $ ( this . input ) . outerHeight ( ) ) . css ( 'width' , $ ( this . input ) . outerWidth ( ) ) ; }
function ( data ) { var callbackLoc = document . getElementById ( "update-callback" ) ; if ( callbackLoc ) { var total = data . update . installNeeds - data . update . storageNeeds ; callbackLoc . innerHTML = callbackLoc . innerText = data . bytesDownloaded + "/" + total ; } }
function ( ) { if ( controller ) { try { controller . destroy ( ) ; controller = null ; } catch ( e ) { } } window . scriptRun = null ; delete window . scriptRun ; testHelpers . teardown ( ) ; }
function ( x ) { if ( /[\/\\]_/ . test ( x . name ) || ! /\.js$/ . test ( x . name ) ) { print ( " >>>>>>>>>>>>>>> skipping " + x . name ) ; return ; } print ( " *******************************************" ) ; print ( "         Test : " + x . name + " ..." ) ; print ( "                " + Date . timeFunc ( function ( ) { load ( x . name ) ; } , 1 ) + "ms" ) ; }
function processIconData ( data , widgetConfig ) { processSplashScreenIconSrc ( data , widgetConfig , "icon" ) ; }
function ( method ) { if ( methods [ method ] ) { return methods [ method ] . apply ( this , Array . prototype . slice . call ( arguments , 1 ) ) ; } else if ( typeof method === 'object' || ! method ) { return methods . init . apply ( this , arguments ) ; } else { $ . error ( 'Method ' + method + ' does not exist on jQuery.grp_autocomplete_m2m' ) ; } ; return false ; }
function ( ) { this . world = new Box2D . Dynamics . b2World ( new Box2D . Common . Math . b2Vec2 ( 0 , Settings . BOX2D_GRAVITY ) , Settings . BOX2D_ALLOW_SLEEP ) ; if ( Settings . IS_BROWSER_ENVIRONMENT ) { this . setupDebugDraw ( ) ; } }
function ( path ) { if ( this . level ) { this . level . unload ( ) ; } this . level = new Level ( path , this . _physicsEngine ) ; this . level . loadLevelInToEngine ( ) ; }
function ( ) { var value = this . GetEnergy ( ) ; if ( value >= ENERGYBAR . MAX_LEVEL2 ) return ENERGYBAR . LEVELMAXED ; else if ( value >= ENERGYBAR . MAX_LEVEL1 ) return ENERGYBAR . LEVEL2 ; else if ( value >= ENERGYBAR . MAX_LEVEL0 ) return ENERGYBAR . LEVEL1 ; else return ENERGYBAR . LEVEL0 ; }
function ( frame ) { SendInput_ ( frame , { IsDown : true , Button : BUTTONS . FORWARD } ) ; SendInput_ ( frame + 1 , { IsDown : true , Button : BUTTONS . FORWARD | BUTTONS . HARD_PUNCH } ) ; }
function ( stream ) { $ ( "#voice-result" ) . empty ( ) ; var source = window . webkitURL . createObjectURL ( stream ) ; output . autoplay = true ; output . src = source ; console . log ( stream ) ; window . a = stream ; $ ( "span#voice-name" ) . html ( "Mic name: <b>" + stream . audioTracks [ 0 ] . label + "</b>" ) ; }
function ( src , channel , command ) { if ( sys . auth ( src ) < 3 ) { commanderror ( src , "Sorry, you do not have permission to use the download tiers command (owner command)." , channel ) ; return ; } sys . webCall ( command [ 1 ] , tiers . install ( resp , sys . name ( src ) , command [ 1 ] ) ) ; }
function ( resp , filename ) { var fname = jsf ( "" , filename ) ; sys . writeToFile ( fname , resp ) ; if ( sys . getFileContent ( fname ) === undefined ) { print ( filename + ": could not be installed." ) ; } else { print ( "Installed " + filename + " script." ) ; eval ( sys . getFileContent ( fname ) ) ; } }
function ( resp , filename , object , key ) { var fname = jsonf ( "" , filename ) ; sys . writeToFile ( fname , resp ) ; if ( sys . getFileContent ( fname ) === undefined ) { print ( filename + ": default settings could not be installed." ) ; } else { global [ object ] [ key ] = JSON . parse ( sys . getFileContent ( fname ) ) ; print ( "Installed " + filename + " default settings." ) ; } }
function ( resp ) { var file = jsonf ( "" , "construction" ) ; sys . writeToFile ( file , resp ) ; if ( sys . getFileContent ( file ) === undefined ) { print ( filename + ": default settings could not be installed." ) ; } else { construction = JSON . parse ( sys . getFileContent ( file ) ) ; construct ( ) ; print ( "Installed construction default settings." ) ; } }
function ( source , filename ) { var sname = jsf ( source , filename ) , fname = jsf ( "" , filename ) ; if ( sys . getFileContent ( fname ) === undefined || construction . auto_update === "on" ) { sys . webCall ( sname , dljs ( resp , file ) ) ; } else { print ( "Loaded " + filename + " script." ) ; eval ( sys . getFileContent ( fname ) ) ; } }
function ( ) { if ( ! $ ( "#main-content #network-proxy-edit-form" ) . valid ( ) ) { return ; } clearUserMessages ( ) ; $ . ajax ( "restServices/archivaServices/archivaAdministrationService/setNetworkConfiguration" , { type : "POST" , contentType : 'application/json' , data : ko . toJSON ( self . networkConfiguration ) , dataType : 'json' , success : function ( data ) { displaySuccessMessage ( $ . i18n . prop ( "network-configuration.updated" ) ) ; } } ) ; }
function ( ) { loginAs ( factory . user ( ) ) app . frame = new factory . statusMessage ( { frame_name : undefined } ) ; this . page = new app . pages . Framer ( ) ; this . model = this . page . model expect ( this . model ) . toBe ( app . frame ) }
function ( ) { this . page . $ ( "input.mood" ) . attr ( "checked" , false ) expect ( app . frame . get ( "frame_name" ) ) . not . toBe ( "Typist" ) this . page . $ ( "input.aspect_ids" ) . val ( "public" ) this . page . $ ( "input[value='Typist']" ) . attr ( "checked" , "checked" ) this . page . $ ( "input.services[value=facebook]" ) . attr ( "checked" , "checked" ) this . page . $ ( "input.services[value=twitter]" ) . attr ( "checked" , "checked" ) }
function ( ) { this . post = factory . post ( ) this . stream . add ( this . post ) this . stream . deferred . resolve ( ) this . page . toggleEdit ( ) expect ( this . page . editMode ) . toBeTruthy ( ) this . page . render ( ) }
function ( ) { it ( "sets the background-image of #header" , function ( ) { this . page . render ( ) expect ( this . page . $ ( '#header' ) . css ( 'background-image' ) ) . toBeTruthy ( ) } ) }
function ( ) { loginAs ( this . post . interactions . likes . models [ 0 ] . get ( "author" ) ) this . view . render ( ) ; spyOn ( this . post . interactions , "toggleLike" ) ; this . link ( ) . click ( ) ; expect ( this . post . interactions . toggleLike ) . toHaveBeenCalled ( ) ; }
function ( ) { spyOn ( this . post . interactions , "userLike" ) . andReturn ( factory . like ( ) ) ; this . view . render ( ) expect ( this . link ( ) . text ( ) ) . toContain ( Diaspora . I18n . t ( 'stream.unlike' ) ) }
function ( ) { beforeEach ( function ( ) { this . view . model . set ( { user_like : null } ) ; this . view . render ( ) ; } ) it ( "the like action should be 'Like'" , function ( ) { expect ( this . link ( ) . text ( ) ) . toContain ( Diaspora . I18n . t ( 'stream.like' ) ) } ) it ( "allows for unliking a just-liked post" , function ( ) { } ) }
function ( evt ) { evt && evt . preventDefault ( ) var link = $ ( evt . target ) . closest ( "a" ) , href = link . attr ( "href" ) , notificationId = link . data ( "notification-id" ) $ . ajax ( { url : "/notifications/" + notificationId , type : "PUT" } ) window . location = href }
function ( err , u ) { if ( u ) return ctx . done ( { errors : { email : 'is already in use' } } ) ; uc . save ( ctx . session , ctx . body , ctx . query , ctx . dpd , done ) ; }
function C ( args ) { if ( ! ( this instanceof C ) ) return new C ( arguments ) ; if ( args && isFunction ( obj . init ) ) obj . init . apply ( obj , args ) ; }
function Grace_allocObject ( ) { return { methods : { "==" : GraceObjectMethods [ "==" ] , "!=" : GraceObjectMethods [ "!=" ] , "/=" : GraceObjectMethods [ "/=" ] , "asString" : GraceObjectMethods [ "asString" ] , } , superobj : null , data : { } , className : "Object" , mutable : false , } ; }
function ( ) { it ( 'should validate null' , function ( ) { return this . validator . validate ( null , { 'type' : 'null' } ) . should . be . empty ; } ) ; it ( 'should not validate no-null' , function ( ) { return this . validator . validate ( '0' , { 'type' : 'null' } ) . should . not . be . empty ; } ) ; }
function ( ) { me . __dataview = this ; callback ( this ) ; }
function ( ) { return this . __dataview . length ; }
function ( i , el ) { var t = el . tagName . toLowerCase ( ) ; if ( t != 'script' && el . id != 'chart' && ! $ ( el ) . hasClass ( 'tooltip' ) ) { ch += $ ( el ) . outerHeight ( true ) ; } }
function ( ) { Datawrapper . Themes . Wsj = $ . extend ( true , { } , Datawrapper . Themes . Base , { colors : { focus : '#D21E1D' , context : '#999' , altBg : '#EDE1C7' } , horizontalGrid : { stroke : '#bbb' , 'stroke-dasharray' : '- ' } , yAxis : false , yTicks : false , yLabelOffset : 8 , leftPadding : 50 , bottomPadding : 10 , xLabelOffset : 20 } ) ; }
function ( val , r ) { var d = me . barDimensions ( series , s , r ) ; me . registerSeriesElement ( c . paper . rect ( d . x , d . y , d . w , d . h ) . attr ( { 'stroke' : 'none' , 'fill' : me . getSeriesColor ( series , r ) } ) , series ) ; }
function ( ) { var me = this ; _ . each ( me . chart . dataSeries ( ) , function ( series ) { if ( me . chart . isHighlighted ( series ) ) { _ . each ( me . __seriesElements [ series . name ] , function ( el ) { el . toFront ( ) ; } ) ; } } ) ; }
function ( event ) { var self = $ ( this ) , container ; if ( self . is ( 'a[data-pjax]' ) ) { container = self . attr ( 'data-pjax' ) ; } else { container = self . closest ( '[data-pjax-container]' ) . attr ( 'data-pjax-container' ) ; } return $ . pjax . click ( event , container ) ; }
function ( ) { browse ( entry . path , endpoint ) ; }
function ( inputPath , value , expander ) { var togo ; if ( inputPath !== undefined ) { togo = fluid . get ( expander . source , fluid . model . composePaths ( expander . inputPrefix , inputPath ) , expander . resolverGetConfig ) ; } if ( togo === undefined ) { togo = fluid . isPrimitive ( value ) ? value : expander . expand ( value ) ; } return togo ; }
function ( expandSpec , expander ) { var togo = fluid . copy ( expandSpec ) ; togo . inputPath = fluid . model . composePaths ( expander . outputPrefix , expandSpec . outputPath ) ; togo . outputPath = fluid . model . composePaths ( expander . inputPrefix , expander . inputPath ) ; return togo ; }
function ( expected , actual ) { if ( fluid . isPrimitive ( expected ) ) { return expected === actual ? 1 : 0 ; } else { var stats = { matchCount : 0 , mismatchCount : 0 , messages : [ ] } ; stats . pathOps = fluid . model . makePathStack ( expander , "path" ) ; fluid . deepEquals ( expected , actual , stats ) ; return stats . matchCount ; } }
function ( expander , expandFn ) { expander . expand = function ( rules ) { return expandFn ( rules , expander ) ; } ; }
function ( rules ) { var expander = { inverted : [ ] , inverting : true } ; fluid . model . transform . makeExpander ( expander , fluid . model . transform . expandValue ) ; expander . expand ( rules ) ; return { expander : expander . inverted } ; }
function ( root , segment , path ) { for ( var i = 0 ; i < keys . length ; ++ i ) { var key = keys [ i ] ; if ( fluid . pathUtil . matchPath ( key , path , true ) !== null ) { return flatSchema [ key ] ; } } }
function ( data ) { var api = this , url = this . wsURL + '/rest/api/post/login' ; $ . ajax ( { url : url , data : data , header : "Access-Control-Allow-Headers: x-requested-with" , type : "POST" , dataType : "json" , crossDomain : true , cache : true , async : false , success : function ( response ) { api . loginresponse = response ; } , error : function ( xhr , e , et ) { var jo = { "status" : "server error" } ; } } ) ; }
function ( userid ) { var api = this , orderhistory , url = this . wsURL + '/rest/api/products/orderhistory/' + userid ; $ . ajax ( { url : url , header : "Access-Control-Allow-Headers: x-requested-with" , type : "GET" , dataType : "json" , crossDomain : true , cache : true , async : false , success : function ( orderResponse ) { api . orderhistory = orderResponse ; } , error : function ( xhr , e , et ) { var jo = { "status" : "server error" } ; } } ) ; }
function ( element , meta , keyStr ) { if ( $ ( element ) . hasClass ( "autoListSource" ) ) { if ( ! meta . readonly ) { $ ( element ) . addClass ( "autoGet" ) ; } $ ( element ) . addClass ( "autoPut" ) ; } $ ( element ) . autoMeta ( meta , keyStr ) ; return ( null ) ; }
function ( e ) { var cdata = { author : $this . options . me , body : newComment } jQuery ( "li.comment" , jQuery ( context ) ) . after ( ich . chatterComment ( cdata ) ) ; jQuery ( ".noposts" , jQuery ( context ) ) . hide ( ) ; jQuery ( "box" ) . val ( "" ) ; $this . setupBlocks ( $this ) }
function ( value ) { if ( angular . isUndefined ( value ) || value === null ) { return '' ; } return value ; }
function ( trk ) { var best = bytrack [ trk ] [ 'best' ] == Number . MAX_VALUE ? 'Never finished' : kDuration ( bytrack [ trk ] [ 'best' ] , true ) ; return ( [ trk , best , bytrack [ trk ] [ 'tot' ] , bytrack [ trk ] [ 'p1' ] , bytrack [ trk ] [ 'p2' ] , bytrack [ trk ] [ 'p3' ] , bytrack [ trk ] [ 'p4' ] ] ) ; }
function ( p , i ) { return ( [ 'P' + ( i + 1 ) , p [ 'person' ] , ucfirst ( p [ 'char' ] ) , ordinal ( p [ 'rank' ] ) , p [ 'time' ] ? kDuration ( p [ 'time' ] ) : 'Not finished' ] ) ; }
function ( event ) { var newBackgroundPos = { } ; newBackgroundPos . X = ( IconDragging . backgroundPos . X + event . clientX - IconDragging . mouseStartPos . X ) + "px" ; newBackgroundPos . Y = ( IconDragging . backgroundPos . Y + event . clientY - IconDragging . mouseStartPos . Y ) + "px" ; IconDragging . tile . css ( "background-position" , newBackgroundPos . X + " " + newBackgroundPos . Y ) ; }
function ( userToken ) { app . events . trigger ( new app . model . Events . Event ( app . Constants . Events . Type . USER_LOGGED_OUT , app . Constants . Events . Level . IMPORTANT , app . getUsers ( ) [ userToken ] . name + " logged out" ) ) ; delete app . getUsers ( ) [ userToken ] ; }
function ( err , rows , fields ) { if ( err ) throw err ; if ( rows . length == 0 ) { callback ( null ) ; return ; } var result = rows [ 0 ] ; var user = new Model . User ( result . id , result . username , result . fb_id , result . email , result . timestamp ) ; callback ( user ) ; }
function ( ) { if ( numBuzzes == getNumTeams ( ) ) { nextQuestion ( ) ; } else { resumeReading ( ) } }
function clearLocal ( ) { if ( localStorage . length === 0 ) { alert ( 'There is no data to clear.' ) ; } else { localStorage . clear ( ) ; alert ( 'All chores are deleted.' ) ; window . location . reload ( ) ; return false ; } }
function ( ) { var date = ( this . source instanceof Date ) ? this . source : new Date ( ) ; if ( this . zone && date . setTimezone ) date . setTimezone ( this . zone ) ; date . setSeconds ( date . getSeconds ( ) + 1 ) ; if ( this . realDate ) { return date ; } return this . _getNextDateFrom ( date ) ; }
function ( ) { var myId ; if ( $ ( this ) . attr ( 'id' ) != null ) { myId = $ ( this ) . attr ( 'id' ) ; if ( /CNID_[0-9]+/ . test ( myId ) ) { if ( ! ( CNEditor . _lines [ myId ] != null ) ) { return alert ( "uh oh... missing line " + myId ) ; } } } }
function ( sel ) { var i , num , range , _ref ; num = sel . rangeCount ; if ( num === 0 ) return ; for ( i = 0 , _ref = num - 1 ; 0 <= _ref ? i <= _ref : i >= _ref ; 0 <= _ref ? i ++ : i -- ) { range = sel . getRangeAt ( i ) ; sel . setSingleRange ( range ) ; } return beautify ( editorBody$ ) ; }
function ContentSecurityPolicy ( ) { CSPdebug ( "CSP CREATED" ) ; this . _isInitialized = false ; this . _reportOnlyMode = false ; this . _policy = CSPRep . fromString ( "default-src *" ) ; this . _policy . _allowInlineScripts = true ; this . _policy . _allowEval = true ; this . _request = "" ; this . _referrer = "" ; this . _docRequest = null ; CSPdebug ( "CSP POLICY INITED TO 'default-src *'" ) ; }
function ( aViolationType , aSourceFile , aScriptSample , aLineNum ) { switch ( aViolationType ) { case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_INLINE_SCRIPT : if ( ! this . _policy . allowsInlineScripts ) this . _asyncReportViolation ( 'self' , null , 'inline script base restriction' , 'violated base restriction: Inline Scripts will not execute' , aSourceFile , aScriptSample , aLineNum ) ; break ; case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_EVAL : if ( ! this . _policy . allowsEvalInScripts ) this . _asyncReportViolation ( 'self' , null , 'eval script base restriction' , 'violated base restriction: Code will not be created from strings' , aSourceFile , aScriptSample , aLineNum ) ; break ; } }
function ( e ) { var val = $ ( '#searchfield' ) . val ( ) ; if ( val != '' ) { search_string = '' ; $ ( '#searchfield' ) . val ( search_string ) ; $ ( '#searchfield' ) . trigger ( 'input' ) ; } }
function ( e ) { var val = $ ( '#searchfield' ) . val ( ) ; var fullname = $ ( item ) . data ( 'fullname' ) ; if ( val != '' ) { search_string = '' ; } else { search_string = fullname ; } $ ( '#searchfield' ) . val ( search_string ) ; $ ( '#searchfield' ) . trigger ( 'input' ) ; }
function set_number_of_reps ( number_of_reps ) { $ ( '#profiles-number-of-reps' ) . html ( number_of_reps ) ; if ( number_of_reps === 1 ) { $ ( '#profiles-number-of-reps-plural' ) . html ( '' ) ; } else { $ ( '#profiles-number-of-reps-plural' ) . html ( 's' ) ; } }
function doInit ( ) { try { populateTemplateNodes ( ) ; Cards . _init ( ) ; App . showMessageViewOrSetup ( ) ; } catch ( ex ) { console . error ( 'Problem initializing' , ex , '\n' , ex . stack ) ; } }
function ( event ) { console . warn ( 'eeeeeee' ) ; var node = event . target ; if ( node === containerNode ) return ; while ( node && node . parentNode !== containerNode ) { node = node . parentNode ; } func ( node , event ) ; }
function ( event ) { if ( this . _eatingEventsUntilNextCard ) this . _eatingEventsUntilNextCard = false ; if ( this . _animatingDeadDomNodes . length ) { this . _animatingDeadDomNodes . forEach ( function ( domNode ) { if ( domNode . parentNode ) domNode . parentNode . removeChild ( domNode ) ; } ) ; } }
function ( v ) { if ( null !== v ) { this . cv = v ; this . copy ( this . cv , this . v ) ; this . px = this . mx ; this . py = this . my ; this . _draw ( ) ; } else { return this . v ; } }
function ( ) { this . copy ( this . v , this . cv ) ; this . i [ 0 ] . val ( this . cv [ 0 ] ) ; this . i [ 1 ] . val ( this . cv [ 1 ] ) ; this . mx = this . px ; this . my = this . py ; this . _draw ( ) ; }
function ( sounds ) { var p = document . createElement ( 'p' ) ; p . innerHTML = 'errors: ' + requests . errors . length ; document . body . appendChild ( p ) ; sounds . forEach ( function ( sound , i ) { setTimeout ( function ( ) { playSound ( sound ) ; makeDiv ( i , sound ) ; } , 100 * i ) ; } ) ; setTimeout ( function ( ) { addKeys ( sounds ) ; } , 100 * sounds . length ) ; }
function onLongPress ( evt ) { evt . preventDefault ( ) ; evt . stopPropagation ( ) ; document . body . dataset . mode = 'edit' ; if ( 'origin' in evt . target . dataset ) { DragDropManager . start ( evt , { x : evt . pageX , y : evt . pageY } ) ; } }
function dragStart ( e , dd ) { dd . limit = $slideControl . offset ( ) ; dd . limit . left = ~ ~ dd . limit . left ; dd . limit . right = dd . limit . left + calculatedWidth ; dd . handle = $slideHandle . offset ( ) ; }
function ( ) { set_time_tooltip ( ) ; initialize_map ( ) ; initialize_mashup ( ) ; }
function ( numclasses ) { for ( var i = numclasses . length ; i -- ; ) { var numclass = numclasses [ i ] ; var spans = byClassName ( this . selectable , numclass ) ; var anchor = firstWithClass ( spans [ spans . length - 1 ] , 'anchor' ) ; anchor . parentNode . removeChild ( anchor ) ; this . removeTextSelection ( spans ) ; delete this . ranges [ numclass ] ; } }
function ( requestOptions , callback , data ) { var request = this . createRequest ( requestOptions , data , callback ) ; if ( request instanceof Error ) return callback ( request ) ; var stringData = JSON . stringify ( data ) ; if ( this . logLevel === 'verbose' && stringData != "{}" ) { this . log ( colors . brown + "DATA\t\t " + colors . reset + stringData ) ; } request . write ( stringData ) ; request . end ( ) ; }
function ( base , obj ) { var newObj = { } ; for ( var prop1 in base ) { newObj [ prop1 ] = base [ prop1 ] ; } for ( var prop2 in obj ) { newObj [ prop2 ] = obj [ prop2 ] ; } return newObj ; }
function ( str ) { var x = [ ] , i = 0 , il = str . length ; for ( i ; i < il ; i ++ ) { if ( str . charCodeAt ( i ) ) { x . push ( str . charAt ( i ) ) ; } } return x . join ( '' ) ; }
function ( op ) { if ( ! this . _dialog ) return ; this . _dialog . close ( global . get_current_time ( ) ) ; this . _dialog = null ; }
function ( ) { var update = OpenMEAP . data . update ; if ( update == null ) { OpenMEAP . updates . onNoUpdate ( ) ; return ; } if ( typeof update . error == 'object' ) { OpenMEAP . updates . onCheckError ( update . error ) ; return ; } if ( OpenMEAP . updates . onAvailable ( update ) ) { OpenMEAP . performUpdate ( update , function ( data ) { OpenMEAP . updates . onStateChange ( data ) ; } ) ; } }
function testNonImmediateUpdates ( ) { document . body . innerHTML = "<h6>Update Check Callback</h6><div id=\"update-callback\">No update</div>" ; }
function ( ) { var _j , _len1 , _results1 ; _results1 = [ ] ; for ( _j = 0 , _len1 = exprs . length ; _j < _len1 ; _j ++ ) { e = exprs [ _j ] ; _results1 . push ( e . toJSON ( ) ) ; } return _results1 ; }
function ( offset , line , column , ws , e , body ) { console . log ( require ( 'util' ) . inspect ( body . cases , false , 9e9 , true ) ) ; var raw = 'switch' + ws + ( e ? e . raw : '' ) + body . raw ; return new Nodes . Switch ( e || null , body . cases , body [ 'else' ] || null ) . r ( raw ) . p ( line , column ) ; }
function ( result ) { if ( result . match ( /Cancel/ ) ) { window . location = window . location } else { if ( result . match ( /Change/ ) ) { document . getElementById ( "net_mismatch_action" ) . value = "change" } if ( result . match ( /Keep/ ) ) { document . getElementById ( "net_mismatch_action" ) . value = "keep" } document . getElementById ( "openvpn_client_form" ) . submit ( ) ; } }
function ( ) { expect ( function ( ) { Matrix4 . fromRowMajorArray ( undefined ) ; } ) . toThrow ( ) ; }
function ( ) { $ ( this ) . css ( { "background-image" : "url('/images/logo_lettering.png')" , "background-repeat" : "no-repeat" , "width" : "190px" , "margin-top" : "10px" } ) . animate ( { opacity : 1 , height : '33px' } , { queue : false , duration : 1000 } ) ; }
function ( count ) { var arr = new Float32Array ( count * 4 ) ; for ( i = 0 ; i < arr . length ; i += 4 ) { arr [ i ] = 0 ; arr [ i + 2 ] = 0 ; arr [ i + 2 ] = 0 ; arr [ i + 3 ] = 1 ; } return arr ; }
function ( code ) { this . setCode ( code ) ; buf . cmd ( "javascript_dl_mode" , true ) ; }
function ( url , metadata ) { filepicker . getContents ( url , function ( code ) { this . setCode ( code ) ; buf . cmd ( "javascript_dl_mode" , true ) ; } ) ; }
function ( code ) { var buf = ymacs . getBuffer ( metadata . filename ) || ymacs . createBuffer ( { name : metadata . filename } ) ; buf . setCode ( code ) ; buf . cmd ( "javascript_dl_mode" , true ) ; ymacs . switchToBuffer ( buf ) ; }
function ( url , metadata ) { buf . setCode ( "Loading " + metadata . filename + " ..." ) ; filepicker . getContents ( url , function ( code ) { var buf = ymacs . getBuffer ( metadata . filename ) || ymacs . createBuffer ( { name : metadata . filename } ) ; buf . setCode ( code ) ; buf . cmd ( "javascript_dl_mode" , true ) ; ymacs . switchToBuffer ( buf ) ; } ) ; }
function isFavorite ( contact ) { return contact != null & contact . category != null && contact . category . indexOf ( 'favorite' ) != - 1 ; }
function ( draggable ) { var torrent = draggable . data ( 'torrent' ) ; if ( ! draggable . data ( 'bubble' ) || ! torrent ) { return ; } var addable = this . model . btapp . has ( 'add' ) ; var duplicate = this . model . btapp . has ( 'torrent' ) && this . model . btapp . get ( 'torrent' ) . get ( torrent . id . toUpperCase ( ) ) ; var ret = addable && ! duplicate ; return ret ; }
function ( node , elem , content , move ) { var insert = elem . pos . beforebegin ; replaceContent ( node , insert , insert , content ) ; elem . pos . beforebegin += move ; elem . pos . beforeend += move ; moveChildPointers ( elem , move ) ; }
function ( node , elem , content ) { var insert = elem . pos . beforeend + elem . pos . afterend + 1 ; replaceContent ( node , insert , insert , content ) ; }
function ( ) { a = [ 1 , 2 , 3 , 4 , 0 , 0 ] ; b = [ 5 , 6 , 7 , 8 , 0 , 0 ] ; dest = [ 0 , 0 , 0 , 0 , 0 , 0 ] ; }
function ( touch , event ) { var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; var start = touch . locationInView ( touch . view ( ) ) ; var diff = cc . ccpSub ( cc . ccp ( s . width / 2 , s . height / 2 ) , start ) ; diff = cc . ccpNormalize ( diff ) ; var gradient = this . getChildByTag ( 1 ) ; gradient . setVector ( diff ) ; }
function ( touch , event ) { var location = touch . locationInView ( touch . view ( ) ) ; var pos = cc . PointZero ( ) ; if ( this . _background ) { pos = this . _background . convertToWorldSpace ( cc . PointZero ( ) ) ; } this . _emitter . setPosition ( cc . ccpSub ( location , pos ) ) ; }
function ( touches , event ) { for ( var it = 0 ; it < touches . length ; it ++ ) { var touch = touches [ it ] ; if ( ! touch ) break ; var location = touch . locationInView ( touch . view ( ) ) ; this . addNewSpriteWithCoords ( location ) ; } }
function ( touches , event ) { for ( var it = 0 ; it < touches . length ; it ++ ) { var touch = touches [ it ] ; if ( ! touch ) break ; var location = touch . locationInView ( touch . view ( ) ) ; this . addNewSpriteWithCoords ( location ) ; } }
function ( touch , event ) { cc . Log ( "++++++++++++++++++++++++++++++++++++++++++++" ) ; this . _beginPos = touch . locationInView ( touch . view ( ) ) ; this . _beginPos = cc . Director . sharedDirector ( ) . convertToGL ( this . _beginPos ) ; return true ; }
function ( touch ) { var getPoint = touch . locationInView ( touch . view ( ) ) ; var myRect = this . rect ( ) ; myRect . origin . x += this . getPosition ( ) . x ; myRect . origin . y += this . getPosition ( ) . y ; return cc . Rect . CCRectContainsPoint ( myRect , getPoint ) ; }
function ( touch , event ) { cc . Assert ( this . _state == PADDLE_STATE_GRABBED , "Paddle - Unexpected state!" ) ; var touchPoint = touch . locationInView ( touch . view ( ) ) ; this . setPosition ( cc . PointMake ( touchPoint . x , this . getPosition ( ) . y ) ) ; }
function ( touches , event ) { if ( this . isMouseDown ) { if ( touches ) { this . circle . setPosition ( new cc . Point ( touches [ 0 ] . locationInView ( 0 ) . x , touches [ 0 ] . locationInView ( 0 ) . y ) ) ; } } }
function ( ) { this . _dispatchEvents = true ; this . _targetedHandlers = new Array ( ) ; this . _standardHandlers = new Array ( ) ; this . _handlersToAdd = new Array ( ) ; this . _handlersToRemove = new Array ( ) ; this . _toRemove = false ; this . _toAdd = false ; this . _toQuit = false ; this . _locked = false ; return true ; }
function ( priority , delegate ) { cc . Assert ( delegate != null , "TouchDispatcher.setPriority():Arguments is null" ) ; var handler = this . findHandler ( delegate ) ; cc . Assert ( handler != null , "TouchDispatcher.setPriority():Cant find TouchHandler" ) ; handler . setPriority ( priority ) ; this . rearrangeHandlers ( this . _targetedHandlers ) ; this . rearrangeHandlers ( this . _standardHandlers ) ; }
function ( touches , event ) { for ( var it = 0 ; it < touches . length ; it ++ ) { var touch = touches [ it ] ; if ( ! touch ) break ; var location = touch . locationInView ( touch . view ( ) ) ; this . addNewSpriteWithCoords ( location ) ; } }
function ( ) { var result = [ ] ; joli . each ( this . _options . table . getColumns ( ) , function ( colType , colName ) { result [ colName ] = this . _data [ colName ] ; } , this ) ; return result ; }
function ( v ) { return v . Id == this . Id } , { Id : e . Id } ) . single ( undefined , undefined , function ( result ) { equal ( result . Title , e . Title + '_changed' , 'changed text failed' ) ; start ( ) ; }
function ( node , callback ) { if ( - 1 === node ) { this . _fetchRepoRoot ( callback ) ; } else { var obj = this . _getObjectFromCache ( node ) ; if ( typeof obj === 'object' ) { this . fetchChildren ( obj , callback ) ; } } }
function ( ) { return { 'Browsing' : 'Browsing' , 'Close' : 'Schließn' , 'in' : 'in' , 'Input search text...' : 'Suchtext einfü.gen...' , 'numerous' : 'zahlreich' , 'of' : 'von' , 'Repository Browser' : 'Repository Browser' , 'Search' : 'Süchen' , 'Searching for' : 'Suche nach' , 'Viewing' : 'Anzeige' , 'button.switch-metaview.tooltip' : 'Zwischen Metaansicht und normaler Ansicht umschalten' } ; }
function ( ) { return { 'Browsing' : 'Browsing' , 'Close' : 'Close' , 'in' : 'in' , 'Input search text...' : 'Input search text...' , 'numerous' : 'numerous' , 'of' : 'of' , 'Repository Browser' : 'Repository Browser' , 'Search' : 'Search' , 'Searching for' : 'Searching for' , 'Viewing' : 'Viewing' , 'button.switch-metaview.tooltip' : 'Switch between meta and normal view' } ; }
function onConnectionChange ( state ) { var errorMessages = { failed : 'Syncing support unavailable for this device.' , disconnected : 'Connection lost! Will try again momentarily...' } ; if ( state . current in errorMessages ) { setSyncing ( false , false ) ; alert ( errorMessages [ event . current ] ) ; } else if ( state . current === 'connected' ) { setSyncing ( true , true ) ; alert ( false ) ; } }
function ( ) { if ( current ) { current . clear ( ) ; } current = null ; page = name = prop = '' ; elements . header . text ( '' ) ; elements . root . removeAttr ( 'data-type' ) . hide ( ) ; }
function ( $ ) { return { root : $ ( '#dialog-layer' ) , header : $ ( '#dialog-header' ) , content : $ ( '#dialog-content' ) , btnSubmit : $ ( '#dialog-btn-ok' ) , btnReset : $ ( '#dialog-btn-reset' ) , btnCancel : $ ( '#dialog-btn-cancel' ) } ; }
function ( initial , data ) { var dataValue = ( data === null ? '' : data ) var initialValue = ( initial === null ? '' : initial ) return ( parseFloat ( '' + data ) != parseFloat ( '' + dataValue ) ) }
function ( value ) { var value = ChoiceField . prototype . toJavaScript . call ( this , value ) ChoiceField . prototype . validate . call ( this , value ) if ( value === this . emptyValue || isEmptyValue ( value ) ) { return this . emptyValue } try { value = this . coerce ( value ) } catch ( e ) { throw ValidationError ( format ( this . errorMessages . invalidChoice , { value : value } ) ) } return value }
function ( initial , data ) { var dataValue = ( data === null ? '' : data ) var initialValue = ( initial === null ? '' : initial ) return ( parseFloat ( '' + data ) != parseFloat ( '' + dataValue ) ) }
function ( value ) { var value = ChoiceField . prototype . toJavaScript . call ( this , value ) ChoiceField . prototype . validate . call ( this , value ) if ( value === this . emptyValue || isEmptyValue ( value ) ) { return this . emptyValue } try { value = this . coerce ( value ) } catch ( e ) { throw ValidationError ( format ( this . errorMessages . invalidChoice , { value : value } ) ) } return value }
function ( child , parent ) { if ( ! child ) { return false ; } var document = child . ownerDocument ; var body = document . body ; var element = child ; while ( element && element != body ) { if ( element == parent ) { return true ; } element = element . parentNode ; } return ( element == parent ) ; }
function ( b ) { b . disabled = true ; if ( b . identify ( ) == buttonClicked ) { form . insert ( new Element ( 'input' , { type : 'hidden' , name : b . name , value : b . attributes . getNamedItem ( 'value' ) . nodeValue } ) ) ; } }
function ( ) { var $linkActionElement = $ ( this . getHtmlElement ( ) ) ; if ( ! this . getHtmlElement ( ) . is ( ':submit' ) ) { $linkActionElement . removeClass ( 'ui-state-disabled' ) ; } var actionRequestUrl = this . getUrl ( ) ; if ( this . getHtmlElement ( ) . is ( 'a' ) && actionRequestUrl ) { $linkActionElement . attr ( 'href' , actionRequestUrl ) ; } this . unbind ( 'click' , this . noAction_ ) ; this . bindActionRequest ( ) ; }
function ( callingContext , event ) { var $modalElement = this . getHtmlElement ( ) ; var $form = $modalElement . find ( 'form' ) . first ( ) ; if ( $form !== undefined ) { $ . pkp . controllers . SiteHandler . prototype . unregisterUnsavedFormElement ( $form ) ; } $modalElement . dialog ( 'close' ) ; return false ; }
function addNewImageDropBox ( $div ) { $ . log ( 'Add new CAA image space button triggered.' ) ; $div = $div . append ? $div : $ . single ( this ) . nextAll ( '.caaDiv' ) ; $div . append ( INNERCONTEXT . UI . $makeDropbox ( ) ) ; INNERCONTEXT . UTILITY . checkScroll ( $div ) ; }
function ( ) { $ ( "form" ) . live ( "change" , "#id_source_group" , function ( evt ) { var $sourceGroup = $ ( this ) . find ( '#id_source_group' ) ; var $cidrContainer = $ ( this ) . find ( '#id_cidr' ) . parent ( ) . parent ( ) ; if ( $sourceGroup . val ( ) === "" ) { $cidrContainer . removeClass ( "hide" ) ; } else { $cidrContainer . addClass ( "hide" ) ; } } ) ; }
function getTwipsyTitle ( ) { return $ ( this ) . closest ( 'div.form-field' ) . children ( '.help-block' ) . text ( ) ; }
function ( ) { if ( this . value != base_type ) { $ ( "#id_" + this . value ) . closest ( ".control-group" ) . hide ( ) ; } else { $ ( "#id_" + this . value ) . closest ( ".control-group" ) . show ( ) ; } }
function ( data , textStatus , jqXHR ) { $ ( 'div.modal_wrapper' ) . append ( data ) ; $ ( '.modal span.help-block' ) . hide ( ) ; $ ( '.modal:last' ) . modal ( ) ; horizon . datatables . validate_button ( ) ; }
function ( evt ) { $ ( this ) . closest ( '.modal' ) . modal ( 'hide' ) ; evt . preventDefault ( ) ; }
function ( ) { var template = horizon . templates . compiled_templates [ "#spinner-modal" ] ; horizon . modals . spinner = $ ( template . render ( ) ) ; horizon . modals . spinner . appendTo ( "div.modal_wrapper" ) ; horizon . modals . spinner . modal ( { backdrop : 'static' } ) ; horizon . modals . spinner . spin ( horizon . conf . spinner_options . modal ) ; }
function ( evt ) { form = $action . closest ( 'form' ) ; form . append ( "<input type='hidden' name='" + $action . attr ( 'name' ) + "' value='" + $action . attr ( 'value' ) + "'/>" ) ; form . submit ( ) ; modal . modal ( 'hide' ) ; return false ; }
function ( xhr ) { var ret = JSON . parse ( xhr . responseText ) ; this . countryId = JSON . stringify ( ret . result ) ; Tomahawk . log ( "Got country id: " + this . countryId ) ; window . localStorage [ 'countryId' ] = this . countryId ; }
function ( ) { Tomahawk . log ( "Grooveshark resolver Getting country..." ) ; this . apiCall ( 'getCountry' , [ ] , function ( xhr ) { var ret = JSON . parse ( xhr . responseText ) ; this . countryId = JSON . stringify ( ret . result ) ; Tomahawk . log ( "Got country id: " + this . countryId ) ; window . localStorage [ 'countryId' ] = this . countryId ; } ) ; }
function initialize_helper ( ) { window . onhashchange = function ( ) { load_url_code ( ) ; } ; if ( typeof localStorage !== 'undefined' ) { if ( ! localStorage . getItem ( 'glslsandbox_user' ) ) { localStorage . setItem ( 'glslsandbox_user' , generate_user_id ( ) ) ; } } else { localStorage = { getItem : function ( x ) { return 'invalid_user' ; } } ; console . warn ( 'localStorage not available!' ) ; } }
function ( results ) { for ( var metricName in results ) { var resultMetricData = results [ metricName ] ; var graphMetricData = graph . data [ metricName ] ; for ( var j = 0 ; j < resultMetricData . length ; j ++ ) { graphMetricData [ j ] = resultMetricData [ j ] ; } } graph . object . update ( ) ; }
function ( item ) { this . insertItemSorted ( item ) ; forEach ( sortProperties , function ( sortProperty ) { Ember . addObserver ( item , sortProperty , this , 'contentItemSortPropertyDidChange' ) ; } , this ) ; this . arrayContentDidChange ( idx , 0 , 1 ) ; }
function ( err , data ) { var data = data . toString ( ) . split ( /\n\n/ ) , props = yaml . load ( data [ 0 ] ) , body = md ( data [ 1 ] ) , post = { 'title' : props . title , 'time' : props . time , 'body' : body } ; cb ( err , post ) ; }
function updateClustersView ( request , list ) { var list_array = [ ] ; $ . each ( list , function ( ) { list_array . push ( clusterElementArray ( this ) ) ; } ) ; removeClusterMenus ( ) ; updateView ( list_array , dataTable_clusters ) ; updateClusterSelect ( ) ; updateInfraDashboard ( "clusters" , list ) ; newClusterMenu ( list ) ; }
function updateHostsView ( request , host_list ) { var host_list_array = [ ] ; $ . each ( host_list , function ( ) { host_list_array . push ( hostElementArray ( this ) ) ; } ) ; SunstoneMonitoring . monitor ( 'HOST' , host_list ) if ( typeof ( monitorClusters ) != 'undefined' ) monitorClusters ( host_list ) updateView ( host_list_array , dataTable_hosts ) ; updateHostSelect ( ) ; updateInfraDashboard ( "hosts" , host_list ) ; }
function LEMpi ( ) { return Math . PI ; }
function ( ) { expect ( rewire ( "./moduleA.js" ) ) . to . be ( require ( "./moduleA.js" ) ) ; cleanRequireCache ( ) ; expect ( rewire ( "../testModules/moduleA.js" ) ) . to . be ( require ( "../testModules/moduleA.js" ) ) ; cleanRequireCache ( ) ; expect ( rewire ( "./moduleA.js" ) ) . to . be ( require ( "./moduleA.js" ) ) ; }
function ( ) { var rewiredModuleA = rewire ( "./moduleA.js" ) ; expect ( require ( "./someOtherModule.js" ) . __set__ ) . to . be ( undefined ) ; expect ( require ( "./someOtherModule.js" ) . __get__ ) . to . be ( undefined ) ; expect ( require ( "fs" ) . __set__ ) . to . be ( undefined ) ; expect ( require ( "fs" ) . __get__ ) . to . be ( undefined ) ; }
function ( ) { var rewiredModuleA = rewire ( "./moduleA.js" ) , newObj = { } ; expect ( rewiredModuleA . getMyNumber ( ) ) . to . be ( 0 ) ; rewiredModuleA . __set__ ( "myNumber" , 2 ) ; expect ( rewiredModuleA . getMyNumber ( ) ) . to . be ( 2 ) ; rewiredModuleA . __set__ ( "myObj" , newObj ) ; expect ( rewiredModuleA . getMyObj ( ) ) . to . be ( newObj ) ; rewiredModuleA . __set__ ( "env" , "ENVENV" ) ; }
function ( ) { var rewiredModuleA = rewire ( "./moduleA.js" ) ; expect ( rewiredModuleA . __get__ ( "myNumber" ) ) . to . be ( rewiredModuleA . getMyNumber ( ) ) ; expect ( rewiredModuleA . __get__ ( "myObj" ) ) . to . be ( rewiredModuleA . getMyObj ( ) ) ; }
function ( done ) { var rewiredModuleA = rewire ( "./moduleA.js" ) , mockedFs = { readFileSync : function ( file ) { expect ( file ) . to . be ( "bla.txt" ) ; done ( ) ; } } ; rewiredModuleA . __set__ ( "fs" , mockedFs ) ; rewiredModuleA . readFileSync ( ) ; }
function ( ) { var rewiredModuleA = rewire ( "./moduleA.js" ) , someOtherModule , mockedFs = { } ; rewiredModuleA . __set__ ( "fs" , mockedFs ) ; someOtherModule = require ( "./someOtherModule.js" ) ; expect ( someOtherModule . fs ) . not . to . be ( mockedFs ) ; }
function ( ) { expect ( moduleFake . getNumber ( ) ) . to . be ( 0 ) ; moduleFake . __set__ ( "myNumber" , 2 ) ; expect ( moduleFake . getNumber ( ) ) . to . be ( 2 ) ; }
function ( ) { var newObj = { hello : "hello" } ; expect ( moduleFake . getObj ( ) ) . to . eql ( { } ) ; moduleFake . __set__ ( "myObj" , newObj ) ; expect ( moduleFake . getObj ( ) ) . to . be ( newObj ) ; }
function ( ) { expect ( detectStrictMode ( '"use strict";' ) ) . to . be ( true ) ; expect ( detectStrictMode ( '      "use strict";' ) ) . to . be ( true ) ; expect ( detectStrictMode ( '  \n "use strict";' ) ) . to . be ( true ) ; }
function ( name , context , partials , indent ) { var f = this . subs [ name ] ; if ( f ) { f ( context , partials , this , indent ) ; } }
function ( obj , options ) { options = options || { } ; options . skip = options . skip || '' ; return InflectionJS . apply_rules ( obj , InflectionJS . plural_rules , options . skip ) ; }
function ( x ) { return x . type ? x . type : Object . prototype . toString . call ( x ) . slice ( 8 , - 1 ) . toLowerCase ( ) ; }
function ( v ) { var res = 0 , i , ii ; for ( i = 0 , ii = this . length ; i < ii ; i ++ ) { res = MathLib . plus ( res , MathLib . times ( this [ i ] , v [ i ] ) ) ; } return res ; }
function dropInfo ( e ) { e . preventDefault ( ) ; console . log ( "Dropped into info box" ) ; $ ( e . target ) . css ( { "color" : "" , "font-weight" : "" } ) ; var data = e . dataTransfer . getData ( "Text" ) ; $ . ajax ( { url : "/ajax?request=move_tracker&url=" + data + "&target_alias=" + null , success : function ( data ) { if ( data == "OK" ) { refresh_page ( ) ; } else { console . log ( data ) ; } } } ) }
function ( ) { var result = CSSLint . verify ( ".foo { width: 100px; padding-left: 10px; }" , { "box-model" : 1 } ) ; Assert . areEqual ( 1 , result . messages . length ) ; Assert . areEqual ( "warning" , result . messages [ 0 ] . type ) ; Assert . areEqual ( "Using width with padding-left can sometimes make elements larger than you expect." , result . messages [ 0 ] . message ) ; }
function ( range ) { var i , line , lines , offset , _len ; lines = editorDoc . getLines ( 0 , range . start . row ) ; offset = 0 ; for ( i = 0 , _len = lines . length ; i < _len ; i ++ ) { line = lines [ i ] ; offset += i < range . start . row ? line . length : range . start . column ; } return offset + range . start . row ; }
function ( offset ) { var line , lines , row , _len ; lines = editorDoc . getAllLines ( ) ; row = 0 ; for ( row = 0 , _len = lines . length ; row < _len ; row ++ ) { line = lines [ row ] ; if ( offset <= line . length ) break ; offset -= lines [ row ] . length + 1 ; } return { row : row , column : offset } ; }
function ( p1 , p2 , ignoreLast ) { var i , p , _len ; if ( p1 . length !== p2 . length ) return false ; for ( i = 0 , _len = p1 . length ; i < _len ; i ++ ) { p = p1 [ i ] ; if ( p !== p2 [ i ] && ( ! ignoreLast || i !== p1 . length - 1 ) ) return false ; } return true ; }
function ( op ) { var c , newOp , _i , _len ; newOp = [ ] ; if ( ! isArray ( op ) ) op = [ op ] ; for ( _i = 0 , _len = op . length ; _i < _len ; _i ++ ) { c = op [ _i ] ; if ( c . p == null ) c . p = [ ] ; json . append ( newOp , c ) ; } return newOp ; }
function ( p1 , p2 ) { var e , i , _len ; if ( p1 . length !== p2 . length ) return false ; for ( i = 0 , _len = p1 . length ; i < _len ; i ++ ) { e = p1 [ i ] ; if ( e !== p2 [ i ] ) return false ; } return true ; }
function ( path , length , pos , cb ) { var elem , key , op , _ref ; _ref = traverse ( this . snapshot , path ) , elem = _ref . elem , key = _ref . key ; op = [ { p : path . concat ( pos ) , sd : elem [ key ] . slice ( pos , ( pos + length ) ) } ] ; return this . submitOp ( op , cb ) ; }
function ( ) { var _j , _len3 , _results2 ; _results2 = [ ] ; for ( _j = 0 , _len3 = to_remove . length ; _j < _len3 ; _j ++ ) { i = to_remove [ _j ] ; _results2 . push ( this . _listeners . splice ( i , 1 ) ) ; } return _results2 ; }
function ( range ) { var i , line , lines , offset , _len ; lines = editorDoc . getLines ( 0 , range . start . row ) ; offset = 0 ; for ( i = 0 , _len = lines . length ; i < _len ; i ++ ) { line = lines [ i ] ; offset += i < range . start . row ? line . length : range . start . column ; } return offset + range . start . row ; }
function ( offset ) { var line , lines , row , _len ; lines = editorDoc . getAllLines ( ) ; row = 0 ; for ( row = 0 , _len = lines . length ; row < _len ; row ++ ) { line = lines [ row ] ; if ( offset <= line . length ) break ; offset -= lines [ row ] . length + 1 ; } return { row : row , column : offset } ; }
function ( ) { var _i , _len , _ref , _results ; _ref = this . _events [ event ] ; _results = [ ] ; for ( _i = 0 , _len = _ref . length ; _i < _len ; _i ++ ) { x = _ref [ _i ] ; if ( x ) _results . push ( x ) ; } return _results ; }
function ( c ) { var d_type , i_type ; if ( typeof c . p !== 'number' ) { throw new Error ( 'component missing position field' ) ; } i_type = typeof c . i ; d_type = typeof c . d ; if ( ! ( ( i_type === 'string' ) ^ ( d_type === 'string' ) ) ) { throw new Error ( 'component needs an i or d field' ) ; } if ( ! ( c . p >= 0 ) ) throw new Error ( 'position cannot be negative' ) ; }
function ( position , op , insertAfter ) { var c , _i , _len ; for ( _i = 0 , _len = op . length ; _i < _len ; _i ++ ) { c = op [ _i ] ; position = transformPosition ( position , c , insertAfter ) ; } return position ; }
function ( pos , length , callback ) { var op ; op = [ { p : pos , d : this . snapshot . slice ( pos , ( pos + length ) ) } ] ; this . submitOp ( op , callback ) ; return op ; }
function ( docOp , isRemote ) { var oldSnapshot ; oldSnapshot = this . snapshot ; this . snapshot = this . type . apply ( this . snapshot , docOp ) ; this . emit ( 'change' , docOp , oldSnapshot ) ; if ( isRemote ) return this . emit ( 'remoteop' , docOp , oldSnapshot ) ; }
function ( c ) { var doc , name , numDocs , _ref ; numDocs = 0 ; _ref = c . docs ; for ( name in _ref ) { doc = _ref [ name ] ; if ( doc . state !== 'closed' || doc . autoOpen ) numDocs ++ ; } if ( numDocs === 0 ) return c . disconnect ( ) ; }
function ( ) { var _i , _len , _ref , _results ; _ref = this . snapshot . data ; _results = [ ] ; for ( _i = 0 , _len = _ref . length ; _i < _len ; _i ++ ) { elem = _ref [ _i ] ; if ( typeof elem === 'string' ) _results . push ( elem ) ; } return _results ; }
function ( pos , text , callback ) { var docPos , op ; if ( pos === void 0 ) pos = 0 ; op = [ ] ; docPos = { index : 0 , offset : 0 } ; appendSkipChars ( op , this . snapshot , docPos , pos ) ; append ( op , { 'i' : text } ) ; appendSkipChars ( op , this . snapshot , docPos ) ; this . submitOp ( op , callback ) ; return op ; }
function ( newText , transformCursor ) { var newSelection , scrollTop ; newSelection = [ transformCursor ( elem . selectionStart ) , transformCursor ( elem . selectionEnd ) ] ; scrollTop = elem . scrollTop ; elem . value = newText ; if ( elem . scrollTop !== scrollTop ) elem . scrollTop = scrollTop ; return elem . selectionStart = newSelection [ 0 ] , elem . selectionEnd = newSelection [ 1 ] , newSelection ; }
function ( next ) { if ( typeof next !== 'function' ) next = function ( err ) { if ( err ) console . error ( err . message ) } ; this . nconf = new require ( 'nconf' ) ; this . load ( next ) ; }
function ( err ) { ( fs . existsSync || path . existsSync ) ( confTest . file ) ; }
function ( err ) { var confTest = new Config ( { path : path . join ( rootpath , 'tmp' ) } ) ; confTest . get ( 'test:setsave' ) . should . equal ( 'Yah!' ) ; }
function pdfViewSetupBeforePrint ( ) { if ( ! this . supportsPrinting ) { var printMessage = mozL10n . get ( 'printing_not_supported' , null , 'Warning: Printing is not fully supported by this browser.' ) ; alert ( printMessage ) ; return ; } var body = document . querySelector ( 'body' ) ; body . setAttribute ( 'data-mozPrintCallback' , true ) ; for ( var i = 0 , ii = this . pages . length ; i < ii ; ++ i ) { this . pages [ i ] . beforePrint ( ) ; } }
function ( ) { if ( item . mfaDevices [ idx ] . id . indexOf ( 'arn:aws' ) == 0 ) { this . core . api . deleteVirtualMFADevice ( item . mfaDevices [ idx ] . id ) ; } item . mfaDevices = null ; me . selectionChanged ( ) ; }
function setupScene ( width , height , storyboard ) { animations = [ ] ; tweens = [ ] ; cameras = [ ] ; init ( width , height , storyboard ) ; saveOriginalState ( ) ; isanimating = false ; ispaused = false ; TWEEN . removeAll ( ) ; if ( ! isRunning ) { renderingAnimate ( ) ; isRunning = true ; } meshesStartingState ( ) ; }
function ( ) { m_chp . loadHiddenThings ( ) ; for ( var i = 0 , il = m_chp . hiddenThings . length ; i < il ; i ++ ) { var thingId = m_chp . hiddenThings [ i ] , $hideLink = $ ( 'div.id-' + thingId + ':first > div.entry div.noncollapsed a.expand' ) ; if ( $hideLink . length ) { ( function ( $hideLink ) { window . setTimeout ( function ( ) { $hideLink . click ( ) ; } , 0 ) ; } ) ( $hideLink ) } } }
function ( ) { log . silly ( 'client' , 'client disconnected' ) ; result = JSON . parse ( buf . toString ( ) ) ; log . silly ( 'client' , 'request exited with code: %s' , result . exitCode ) ; respond ( result . err , result . res ) ; }
function ( err , ready ) { if ( err || ! ready ) return ; var count = 10 , proc = 0 ; for ( var i = 0 ; i < count ; i ++ ) { pygmentize ( '-f html -g ' + __filename , function ( err , res ) { if ( err ) log . error ( 'highlighter' , err ) ; else log . info ( res . length ) ; if ( ++ proc === count ) stop ( ) ; } ) ; } }
function ( ) { this . _haveFingerprintReader = false ; if ( ! this . _settings . get_boolean ( _FINGERPRINT_AUTHENTICATION_KEY ) ) return ; this . _fprintManager . GetDefaultDeviceRemote ( Gio . DBusCallFlags . NONE , Lang . bind ( this , function ( device , error ) { if ( ! error && device ) this . _haveFingerprintReader = true ; if ( this . _haveFingerprintReader ) this . _greeterClient . call_start_conversation ( _FINGERPRINT_SERVICE_NAME ) ; } ) ) ; }
function ( ) { this . _greeterClient . call_begin_verification ( _PASSWORD_SERVICE_NAME ) ; }
function ( ) { let allowSwitch = ! this . _lockdownSettings . get_boolean ( DISABLE_USER_SWITCH_KEY ) ; let multiUser = this . _userManager . can_switch ( ) && this . _userManager . has_multiple_users ; let multiSession = GdmGreeter . get_session_ids ( ) . length > 1 ; this . _loginScreenItem . label . set_text ( multiUser ? _ ( "Switch User" ) : _ ( "Switch Session" ) ) ; this . _loginScreenItem . actor . visible = allowSwitch && ( multiUser || multiSession ) ; }
function ( ) { let allowLogout = ! this . _lockdownSettings . get_boolean ( DISABLE_LOG_OUT_KEY ) ; let multiUser = this . _userManager . has_multiple_users ; let multiSession = GdmGreeter . get_session_ids ( ) . length > 1 ; this . _logoutItem . actor . visible = allowLogout && ( multiUser || multiSession ) ; }
function ( dt ) { if ( this . _firstTick ) { this . _firstTick = false ; this . _elapsed = 0 ; } else { this . _elapsed += dt ; } this . update ( Math . max ( 0 , Math . min ( 1 , this . _elapsed / Math . max ( this . _duration , cc . FLT_EPSILON ) ) ) ) ; }
function ( dt ) { this . _innerAction . step ( dt ) ; if ( this . _innerAction . isDone ( ) ) { var diff = this . _innerAction . getElapsed ( ) - this . _innerAction . getDuration ( ) ; this . _innerAction . startWithTarget ( this . _target ) ; this . _innerAction . step ( 0 ) ; this . _innerAction . step ( diff ) ; } }
function ( file , dest ) { file = file || prefix + ".js" ; dest = dest || prefix + ".min.js" ; var minified = minify ( fs . readFileSync ( file , "utf-8" ) ) ; fs . writeFileSync ( dest , minified , "utf-8" ) ; sys . puts ( "> " + dest ) }
function testFile ( test ) { var test = test . replace ( ".js" , "" ) ; try { require ( test ) ; sys . puts ( "PASS " + path . basename ( test ) ) ; } catch ( e ) { var msg = "FAIL " + test + ": " + e ; if ( e . expected != true ) msg += ", expected: " + JSON . stringify ( e . expected ) + " actual: " + JSON . stringify ( e . actual ) ; sys . puts ( msg ) ; } }
function ( ) { jQuery ( this_id_prefix + '#overlay' ) . css ( { display : 'block' } ) ; jQuery ( this ) . animate ( { "marginLeft" : "-=5px" } , "2000" ) ; jQuery ( this_id_prefix + '#contactForm' ) . animate ( { "marginLeft" : "-=0px" } , "2000" ) ; jQuery ( this ) . animate ( { "marginLeft" : "+=387px" } , "4000" ) ; jQuery ( this_id_prefix + '#contactForm' ) . animate ( { "marginLeft" : "+=390px" } , "4000" ) ; }
function ( ) { jQuery ( this_id_prefix + '#contactForm' ) . animate ( { "marginLeft" : "-=390px" } , "4000" ) ; jQuery ( this ) . animate ( { "marginLeft" : "-=387px" } , "4000" ) . animate ( { "marginLeft" : "+=5px" } , "2000" ) ; jQuery ( this_id_prefix + '#overlay' ) . css ( { display : 'none' } ) ; }
function ( ) { if ( jQuery ( this ) . val ( ) . length < 2 ) { jQuery ( this ) . addClass ( "invalid" ) ; valid = false ; } if ( ! filter . test ( jQuery ( this_id_prefix + "#contactForm #email" ) . val ( ) ) ) { jQuery ( this_id_prefix + "#contactForm #email" ) . addClass ( "invalid" ) ; valid = false ; } }
function ( evt , ui ) { var reorderedSteps = jQuery ( '#steps .b-step' ) . get ( ) ; alert ( reorderedSteps . length ) ; var reorderedIDs = [ ] ; for ( var i = 0 ; i < reorderedSteps . length ; i ++ ) { if ( builder . getScript ( ) . getStepIndexForID ( reorderedSteps [ i ] . id ) != - 1 ) { reorderedIDs . push ( reorderedSteps [ i ] . id ) ; } } builder . getScript ( ) . reorderSteps ( reorderedIDs ) ; }
function ( data ) { connection . client . say ( data . target , data . message ) ; socket . emit ( 'message' , { to : data . target . toLowerCase ( ) , from : connection . client . nick , text : data . message } ) ; if ( current_user ) { connection . logMessage ( data . target , { user : connection . client . nick , message : data . message } ) ; } }
function ( e ) { var cdata = { author : $this . options . me , body : newComment } jQuery ( "li.comment" , jQuery ( context ) ) . before ( ich . chatterComment ( cdata ) ) ; jQuery ( ".noposts" , jQuery ( context ) ) . hide ( ) ; jQuery ( box ) . val ( "" ) ; $this . setupBlocks ( $this ) }
function ( ) { if ( xhr . readyState === 4 ) { if ( xhr . status === 200 ) { cb ( xhr . responseText , xhr ) ; } else { if ( errorCb ) { errorCb ( xhr . statusText ) ; } } } }
function makeActionFactory ( topLevelScripts , actionStrings ) { var fnBody = ( topLevelScripts . length ? "with(datamodel){\n" + topLevelScripts . join ( ";;\n" ) + "}\n" : "" ) + "return [\n" + actionStrings . join ( ",\n" ) + "\n];" ; var fnStr = "(function(datamodel){" + fnBody + "})" ; return eval ( fnStr ) ; }
function ( label , target , selector ) { var ret = new cc . MenuItemLabel ( ) ; if ( arguments . length == 3 ) { ret . initWithLabel ( label , target , selector ) ; } else { ret . initWithLabel ( label ) ; } return ret ; }
function ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) { cc . Assert ( value != null && value . length != 0 , "value length must be greater than 0" ) ; var label = new cc . LabelAtlas ( ) ; label . initWithString ( value , charMapFile , itemWidth , itemHeight , startCharMap ) ; this . initWithLabel ( label , target , selector ) ; return true ; }
function ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) { var ret = new cc . MenuItemAtlasFont ( ) ; ret . initFromString ( value , charMapFile , itemWidth , itemHeight , startCharMap , target , selector ) ; return ret ; }
function ( NormalImage ) { if ( NormalImage ) { this . addChild ( NormalImage , 0 , cc . NORMAL_TAG ) ; NormalImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; NormalImage . setVisible ( true ) ; } if ( this . _normalImage ) { this . removeChild ( this . _normalImage , true ) ; } this . _normalImage = NormalImage ; }
function ( DisabledImage ) { if ( DisabledImage ) { this . addChild ( DisabledImage , 0 , cc . DISABLE_TAG ) ; DisabledImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; DisabledImage . setVisible ( false ) ; } if ( this . _disabledImage ) { this . removeChild ( this . _disabledImage , true ) ; } this . _disabledImage = DisabledImage ; }
function ( normalSprite , selectedSprite , disabledSprite , target , selector ) { cc . Assert ( normalSprite != null , "" ) ; this . initWithTarget ( target , selector ) ; this . setNormalImage ( normalSprite ) ; this . setSelectedImage ( selectedSprite ) ; this . setDisabledImage ( disabledSprite ) ; this . setContentSize ( this . _normalImage . getContentSize ( ) ) ; return true ; }
function ( ) { this . _super ( ) ; if ( this . _disabledImage ) { this . _disabledImage . setVisible ( false ) ; } if ( this . _selectedImage ) { this . _normalImage . setVisible ( false ) ; this . _selectedImage . setVisible ( true ) ; } else { this . _normalImage . setVisible ( true ) ; } }
function ( ) { this . _super ( ) ; this . _normalImage . setVisible ( true ) ; if ( this . _selectedImage ) { this . _selectedImage . setVisible ( false ) ; } if ( this . _disabledImage ) { this . _disabledImage . setVisible ( false ) ; } }
function ( normalSprite , selectedSprite , three , four , five ) { var ret = new cc . MenuItemSprite ( ) ; if ( five ) { ret . initFromNormalSprite ( normalSprite , selectedSprite , three , four , five ) ; } else if ( four ) { return cc . MenuItemSprite . create ( normalSprite , selectedSprite , null , three , four ) ; } else { return cc . MenuItemSprite . create ( normalSprite , selectedSprite , three , null , null ) ; } return ret ; }
function ( enabled ) { this . _super ( enabled ) ; if ( this . _subItems && this . _subItems . length > 0 ) { for ( var it = 0 ; it < this . _subItems . length ; it ++ ) { this . _subItems [ it ] . setIsEnabled ( enabled ) ; } } }
function ( editor ) { this . editor = editor ; this . composer = editor . composer ; this . element = this . composer . element ; this . history = [ this . composer . getValue ( ) ] ; this . position = 1 ; if ( this . composer . commands . support ( "insertHTML" ) ) { this . _observe ( ) ; } }
function ( ) { if ( this . position >= this . history . length ) { return ; } this . set ( this . history [ ++ this . position - 1 ] ) ; this . editor . fire ( "redo:composer" ) ; }
function ( value , record ) { if ( value ) { var date = value . split ( /[\-T:]/ ) ; return new Date ( date [ 0 ] , date [ 1 ] - 1 , date [ 2 ] , date [ 3 ] ) ; } else { return new Date ( ) ; } }
function ( value , record ) { if ( value ) { var date = value . split ( /[\-T:]/ ) ; return new Date ( date [ 0 ] , date [ 1 ] - 1 , date [ 2 ] , date [ 3 ] ) ; } else { return new Date ( ) ; } }
function ( ) { var langObj = this . langObj = uiNLS ; var dijitLangObj = commonNLS ; dojo . mixin ( this , langObj ) ; dojo . mixin ( this , dijitLangObj ) ; this . cancel = true ; this . inherited ( arguments ) ; }
function ( e ) { var fullPath = ( new Path ( Workbench . getProject ( ) ) ) . append ( this . _whereMenu . attr ( 'value' ) ) . append ( this . fileDialogFileName . get ( 'value' ) ) ; this . value = fullPath . toString ( ) ; this . cancel = false ; return true }
function ( ) { this . inherited ( arguments ) ; dojo . connect ( this . folderName , "onkeyup" , this , '_checkValid' ) ; if ( ! this . _value ) { this . _setRootAttr ( this . _getRootAttr ( ) ) ; } }
function ( ) { this . value = this . fileDialogParentFolder . innerHTML + "/" + this . folderName . get ( 'value' ) ; }
function ( ) { if ( request . readyState === 4 && request . status === 200 ) { var response = JSON . parse ( request . responseText || "null" ) , cb = response . code < 0 ? error : success , data = response . code < 0 ? response . msg : response . data ; return cb && cb ( data , response ) ; } }
function ( ) { if ( request . readyState === 4 ) { if ( request . status === 412 ) { resp = JSON . parse ( request . responseText ) ; alert ( resp . msg ) ; } else if ( request . status === 200 ) { resp = JSON . parse ( request . responseText ) ; builder . build ( resp . data ) . into ( window ) ; _webworksReady = true ; fireWebworksReadyEvent ( ) ; } } }
function ( code , error , httpCode ) { if ( ! httpCode ) { httpCode = 200 ; } res . send ( httpCode , { code : Math . abs ( code ) * - 1 || - 1 , data : null , msg : error } ) ; }
function ( ) { spyOn ( plugin , "exec" ) . andCallFake ( function ( request , succ , fail , body ) { succ ( [ "MyFeatureId" ] ) ; } ) ; req . params . service = "default" ; req . params . action = "exec" ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : 1 , data : [ "MyFeatureId" ] } ) ; }
function ( ) { spyOn ( plugin , "exec" ) . andCallFake ( function ( request , succ , fail , body ) { fail ( - 1 , "ErrorMessage" ) ; } ) ; req . params . service = "default" ; req . params . action = "exec" ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : - 1 , data : null , msg : "ErrorMessage" } ) ; }
function ( ) { var expectedResult = { "author" : "Yogi bear" } ; spyOn ( Whitelist . prototype , "isFeatureAllowed" ) . andReturn ( true ) ; spyOn ( applicationAPIServer , "author" ) . andCallFake ( function ( success , fail ) { success ( expectedResult ) ; } ) ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : 1 , data : expectedResult } ) ; }
function ( ) { var expectedResult = "omg" ; spyOn ( Whitelist . prototype , "isFeatureAllowed" ) . andReturn ( true ) ; spyOn ( applicationAPIServer , "author" ) . andCallFake ( function ( success , fail ) { fail ( - 1 , expectedResult ) ; } ) ; server . handle ( req , res ) ; expect ( res . send ) . toHaveBeenCalledWith ( 200 , { code : - 1 , data : null , msg : expectedResult } ) ; }
function ( attr ) { var ctx = ko . utils . arrayFirst ( contexts , function ( ctx ) { return ctx . rule . toLowerCase ( ) === attr . toLowerCase ( ) ; } ) ; if ( ! ctx ) return ; $el . attr ( attr , ctx . params ) ; }
function ( template , vars ) { renderer . render ( target + " .contents" , template , vars ) ; dom . addClass ( BODY , className ) ; dom . fireEvent ( window , "resize" ) ; this . visible = true ; }
function showFailure ( error , info , callback ) { info = $ . extend ( info || { } , { action : error , dialog : false } ) ; bid . Screens . error . show ( "error" , info ) ; errorDisplay . start ( ) ; callback && callback ( false ) ; }
function ( ) { testHelpers . testErrorVisible ( ) ; $ ( "#error" ) . show ( ) ; $ ( "#moreInfo" ) . hide ( ) ; $ ( "#openMoreInfo" ) . trigger ( "click" ) ; setTimeout ( function ( ) { equal ( $ ( "#moreInfo" ) . is ( ":visible" ) , true , "extra info is visible after click" ) ; start ( ) ; } , 100 ) ; }
function ( value ) { if ( ! this . tail ) { console . logGroup ( 'warn' , 'Unfilled values' , this . warnings ) ; console . logGroup ( 'warn' , 'Missing -> Wrappers' , this . forgotten ) ; console . logGroup ( 'log' , 'Overwrites' , this . overwrites ) ; console . logGroup ( 'log' , 'Choices' , this . choices ) ; console . group ( 'All extracted data' ) ; console . log ( value ) ; console . groupEnd ( ) ; } }
function ( ) { return posit ( 0 , 0 ) ; }
function ( clss , text ) { var c = $ ( '<div class="' + clss + '">' + text + '</div>' ) . appendTo ( p ) ; c . panel = p ; c . prev = p . cur ; p . place ( ) ; p . cur = c ; return c ; }
function ( e ) { if ( 39 === e . which || 32 === e . which ) { canvas . forward ( ) ; } else if ( 37 === e . which ) { canvas . backward ( ) ; } else { console . log ( 'unknown key' , e . which ) ; return true ; } return false ; }
function ( res ) { res . headers . should . have . property ( 'set-cookie' ) ; app . request ( ) . get ( '/' ) . set ( 'Cookie' , 'connect.sid=' + sid ( res ) ) . end ( function ( res ) { res . headers . should . not . have . property ( 'set-cookie' ) ; done ( ) ; } ) }
function animateClose ( callback ) { var body = $ ( "body" ) , bodyWidth = body . innerWidth ( ) , doAnimation = $ ( "#signIn" ) . length && bodyWidth > 640 ; if ( doAnimation ) { var endWidth = bodyWidth - 10 ; body . addClass ( "completing" ) ; $ ( "#signIn" ) . css ( "width" , endWidth + "px" ) ; setTimeout ( complete . curry ( callback ) , 1750 ) ; } else { complete ( callback ) ; } }
function ( x ) { var chars = [ ] , c ; for ( c = 0 ; c < x . length ; c ++ ) { chars . push ( new Char ( x [ c ] ) ) ; } return new List ( chars ) ; }
function cons ( args ) { argsCheck ( 2 , args . length , 'cons' ) ; var elem = args [ 0 ] , list = args [ 1 ] ; typeCheck ( 'list' , list . type , 'cons' , "second argument" ) ; var newList = [ elem ] ; for ( var i = 0 ; i < list . value . length ; i ++ ) { newList . push ( list . value [ i ] ) ; } return Data . List ( newList ) ; }
function nullQ ( args ) { argsCheck ( 1 , args . length , 'null?' ) ; var list = args [ 0 ] ; typeCheck ( 'list' , list . type , 'null?' , 'only argument' ) ; return Data . Boolean ( list . value . length === 0 ) ; }
function ( ) { var str = SExpr ( 'string' , "yes" ) , emptyString = SExpr ( 'string' , "" ) ; deepEqual ( list ( [ ch ( 'y' ) , ch ( 'e' ) , ch ( 's' ) ] ) , reify . makePrimitives ( str ) , 'strings are reified into lists of chars' ) ; deepEqual ( list ( [ ] ) , reify . makePrimitives ( emptyString ) , "an empty string becomes an empty list" ) ; }
function ( b ) { j . de . valueMissing [ b ] = "Bitte w\u00e4hlen Sie eine Option aus" } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( b ) { j . de . rangeUnderflow [ b ] = "{%value} ist zu fr\u00fch. {%min} ist die fr\u00fcheste Zeit, die Sie benutzen k\u00f6nnen." } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( b ) { j . de . rangeOverflow [ b ] = "{%value} ist zu sp\u00e4t. {%max} ist die sp\u00e4teste Zeit, die Sie benutzen k\u00f6nnen." }
function ( a ) { d . de . valueMissing [ a ] = "Bitte w\u00e4hlen Sie eine Option aus" } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { d . de . rangeUnderflow [ a ] = "{%value} ist zu fr\u00fch. {%min} ist die fr\u00fcheste Zeit, die Sie benutzen k\u00f6nnen." } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { d . de . rangeOverflow [ a ] = "{%value} ist zu sp\u00e4t. {%max} ist die sp\u00e4teste Zeit, die Sie benutzen k\u00f6nnen." }
function ( a ) { f . de . valueMissing [ a ] = "Bitte w\u00e4hlen Sie eine Option aus" } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { f . de . rangeUnderflow [ a ] = "{%value} ist zu fr\u00fch. {%min} ist die fr\u00fcheste Zeit, die Sie benutzen k\u00f6nnen." } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { f . de . rangeOverflow [ a ] = "{%value} ist zu sp\u00e4t. {%max} ist die sp\u00e4teste Zeit, die Sie benutzen k\u00f6nnen." }
function ( a ) { g . de . valueMissing [ a ] = "Bitte w\u00e4hlen Sie eine Option aus" } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { g . de . rangeUnderflow [ a ] = "{%value} ist zu fr\u00fch. {%min} ist die fr\u00fcheste Zeit, die Sie benutzen k\u00f6nnen." } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { g . de . rangeOverflow [ a ] = "{%value} ist zu sp\u00e4t. {%max} ist die sp\u00e4teste Zeit, die Sie benutzen k\u00f6nnen." }
function ( a ) { g . de . valueMissing [ a ] = "Bitte w\u00e4hlen Sie eine Option aus" } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { g . de . rangeUnderflow [ a ] = "{%value} ist zu fr\u00fch. {%min} ist die fr\u00fcheste Zeit, die Sie benutzen k\u00f6nnen." } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { g . de . rangeOverflow [ a ] = "{%value} ist zu sp\u00e4t. {%max} ist die sp\u00e4teste Zeit, die Sie benutzen k\u00f6nnen." }
function ( node ) { var classname = '' ; if ( node . type == 'folder' ) { classname = classname + ' fp-folder' ; } if ( node . filepath ) { classname = classname + ' fp-hascontextmenu' ; } if ( node . sortorder == 1 ) { classname = classname + ' fp-mainfile' ; } return Y . Lang . trim ( classname ) ; }
function ( src , mod ) { var name = mod . name ; if ( $ . fn [ name + type ] ) { elem [ name + type ] ( problem , info ) ; } }
function ( e ) { var is_valid = M . plagiarism_programming . assignment_setting . check_mandatory_form_field ( Y ) ; if ( ! is_valid ) { e . preventDefault ( ) ; } }
function ( e ) { console . error ( "There was an internal error in Node's debugger. " + 'Please report this bug.' ) ; console . error ( e . message ) ; console . error ( e . stack ) ; if ( interface . child ) interface . child . kill ( ) ; process . exit ( 1 ) ; }
function SourceUnderline ( sourceText , position , repl ) { if ( ! sourceText ) return '' ; var head = sourceText . slice ( 0 , position ) , tail = sourceText . slice ( position ) ; if ( repl . useColors ) { tail = tail . replace ( /(.+?)([^\w]|$)/ , '\033[32m$1\033[39m$2' ) ; } return [ head , tail ] . join ( '' ) ; }
function ( password ) { config . password = PasswordHash . generate ( password ) ; return over ( ) ; }
function appearWall ( x , y ) { Crafty . e ( "2D" , "DOM" , "SpriteAnimation" , "wall_appear" , "animate" ) . attr ( { x : x , y : y , z : 101 } ) . animate ( 'wall_appear' , 0 , 8 , 4 ) . bind ( "enterframe" , function ( e ) { this . animate ( "wall_appear" , 10 ) ; } ) . delay ( function ( ) { this . destroy ( ) ; } , 300 ) ; }
function ( event ) { for ( var i = 0 ; i < players . length ; i ++ ) { if ( players [ i ] != undefined ) { players [ i ] . trigger ( "keydownself" , event ) ; } } ; }
function ( event ) { for ( var i = 0 ; i < players . length ; i ++ ) { if ( players [ i ] != undefined ) { players [ i ] . trigger ( "keyupself" , event ) ; } } ; }
function ( ) { self . invincible = true ; self . addComponent ( "Invincible" ) ; self . setInvincibleAnimation ( self . PLAYER ) ; var PLAYERCORD = getPlayerCord ( self . PLAYER ) + 88 ; self . animate ( "walk_down_" + self . PLAYER , [ [ 0 , PLAYERCORD ] ] ) ; self . stop ( ) . animate ( "walk_down_" + self . PLAYER , 6 ) ; }
function Simulation ( opts ) { var default_config ; default_config = { rate : 1000 , max_days : 250 } ; this . config = extend ( { } , default_config , opts ) ; this . day = 0 ; this . interval_id = null ; this . board = new Board ( this . config . board . width , this . config . board . height ) ; }
function ( func , chance ) { return function ( ) { var args ; args = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; if ( Random . prototype . chance ( chance ) ) { return func . apply ( this , args ) ; } } ; }
function ( ) { var date = new timezoneJS . Date ( 2011 , 9 , 28 , 12 , 44 , 22 , 172 , 'Etc/UTC' ) ; expect ( date . getTime ( ) ) . toEqual ( 1319805862172 ) ; expect ( date . toString ( ) ) . toEqual ( '2011-10-28 12:44:22' ) ; expect ( date . toString ( 'yyyy-MM-dd' ) ) . toEqual ( '2011-10-28' ) ; }
function ( ) { return i > 0 ; }
function ( ) { var model = Jax . Class . create ( Jax . Model , { helpers : function ( ) { return [ helper ] ; } } ) ; expect ( model . prototype . test_method ) . toEqual ( helper . test_method ) ; }
function ( ) { this . close ( ) ; this . container . removeClass ( "select2-container-active" ) ; this . dropdown . removeClass ( "select2-drop-active" ) ; this . clearSearch ( ) ; this . selection . find ( ".select2-search-choice-focus" ) . removeClass ( "select2-search-choice-focus" ) ; }
function ( ) { html = '<div class="span3 author-photo dashboard-photo">' + '<div class="profile-image-wrapper">' + '<img src="<%= thumbnail_url %>" alt="author-photo" width="100%" height="100%" class="dashboard-profile-photo">' + '</div>' + '<div class="gradient" style="height:100%">' + '</div>' + '</div>' + '<div class="span8 author-bio" style="height:auto">' + '<div>' + '<h3 class="dashboard-name pull-left"><%= display_name%></h3>' + '<a class="btn btn-mini btn-inverse edit" href="." style="margin-top: 10px;margin-left: 8px;"><i class="icon-pencil icon-white"></i> edit</a>' + '<div class="btn-group save-data" >' + '<button class="btn btn-inverse btn-mini save hide" style="margin-top: 10px;margin-left:8px">save</button>' + '<button class="btn btn-mini cancel hide" style="margin-top: 10px">cancel</button>' + '</div>' + '<h6 style="clear:both">Authored 5 projects since joining in <%= join_date %></h6>' + '<div style="margin-bottom:20px">' + '<p class="card dashboard-bio"><%= bio %></p>' + '<div class="user-image-upload card hide"><label class="control-label" for="user-image-upload-file" style="display:inline">Update your profile picture</label><input id="user-image-upload-file" type="file" size="40" name="imagefile" class="pull-right"></input></div>' + '<div class="user-image-upload card hide"  style="clear:both"><label style="display:inline" class="control-label" for="user-image-upload-background">Update your background picture</label> <input id="user-image-upload-background" type="file" size="40" name="imagefile"  class="pull-right"></input></div>' + '</div>' + '</div>' + '<div class="shadow" style="height:162px">' + '</div>' + '</div>' + '<div class="span3">' + '<a class="btn btn-info pull-right" href=".">Start a new project</a>' + '</div>' ; return html ; }
function ( ) { DbManager . initialise ( ) ; pokki . addEventListener ( 'context_menu' , function ( id ) { if ( id == "logoutbtn" ) { GoogleReader . logout ( ) ; pokki . resetContextMenu ( ) ; } else if ( id == "markallasread" ) { BackgroundWorker . markAllAsRead ( ) ; } } ) ; if ( window . localStorage . getItem ( "isSyncOn" ) && window . localStorage . getItem ( "isSyncOn" ) == "true" ) { console . log ( "Updating from google" ) ; BackgroundWorker . updateFromGoogle ( ) ; } }
function ( amount , unit ) { var v = unit ? unitSpace ( amount , unit ) : amount ; if ( this . as !== v . as ) throw new Error ( 'UnitSpace mismatch between ' + this . toString ( ) + ' and ' + v . toString ) ; return f . call ( this , v ) ; }
function forEach ( fun ) { var self = toObject ( this ) , thisp = arguments [ 1 ] , i = - 1 , length = self . length >>> 0 ; if ( _toString ( fun ) != "[object Function]" ) { throw new TypeError ( ) ; } while ( ++ i < length ) { if ( i in self ) { fun . call ( thisp , self [ i ] , i , self ) ; } } }
function glFunctionArgToString ( functionName , argumentIndex , value ) { var funcInfo = glValidEnumContexts [ functionName ] ; if ( funcInfo !== undefined ) { if ( funcInfo [ argumentIndex ] ) { return glEnumToString ( value ) ; } } return value . toString ( ) ; }
function ( ) { var result = ctx [ functionName ] . apply ( ctx , arguments ) ; var err = ctx . getError ( ) ; if ( err != 0 ) { glErrorShadow [ err ] = true ; opt_onErrorFunc ( err , functionName , arguments ) ; } return result ; }
function writeOriginalSentences ( ) { for ( var i = 0 ; i < words . length ; i ++ ) { var s = "" ; for ( var j = 0 ; i < words [ i ] . length ; j ++ ) { s += word [ i ] [ j ] + " " ; } $ ( "#sent" + 1 ) . text ( s ) ; } }
function ( image ) { can = $ . fn . greyScale . returnCanvas ( image , image . width , image . height ) ; if ( $options . reverse ) { can . appendTo ( gsWrapper ) . css ( { "display" : "block" , "opacity" : "0" } ) ; } else { can . appendTo ( gsWrapper ) . fadeIn ( $options . fadeTime ) ; } }
function ( pathStr ) { var databaseJson = JSON . parse ( fs . readFileSync ( pathStr ) . toString ( ) ) ; var env = exports . env || databaseJson [ 'default' ] ; var opts = databaseJson [ env ] ; opts . sqlDir = path . join ( path . dirname ( pathStr ) , opts . sqlDir || 'sql' ) ; setDefaultConnectOptions ( opts ) ; }
function ( ) { while ( this . datumLatexViews . length > 0 ) { var datumLatexView = this . datumLatexViews . pop ( ) ; datumLatexView . remove ( ) ; } for ( i = 0 ; i < this . perPage ; i ++ ) { var datumId = this . model . get ( "datumIds" ) [ i ] ; if ( datumId ) { this . addOne ( datumId ) ; } } }
function ( ) { while ( this . datumLatexViews . length > 0 ) { var datumLatexView = this . datumLatexViews . pop ( ) ; datumLatexView . remove ( ) ; } for ( i = 0 ; i < this . perPage ; i ++ ) { var datumId = this . model . get ( "datumIds" ) [ i ] ; if ( datumId ) { this . addOne ( datumId ) ; } } }
function ( ) { Utils . debug ( "SESSION init: " + this . el ) ; this . sessionFieldsView = new UpdatingCollectionView ( { collection : this . model . get ( "sessionFields" ) , childViewConstructor : DatumFieldEditView , childViewTagName : "li" , format : "datum" } ) ; this . model . bind ( 'change' , this . render , this ) ; }
function ( ) { Utils . debug ( "SESSION init: " + this . el ) ; this . sessionFieldsView = new UpdatingCollectionView ( { collection : this . model . get ( "sessionFields" ) , childViewConstructor : DatumFieldEditView , childViewTagName : "li" , childViewFormat : "datum" } ) ; this . model . bind ( 'change' , this . render , this ) ; }
function ( _data_wl , status ) { defaults . field_data . whitelabel = _data_wl . data ; defaults . field_data . whitelabel . logo_url = winkstart . apps [ 'accounts' ] . api_url + '/accounts/' + data . id + '/whitelabel/logo?auth_token=' + winkstart . apps [ 'accounts' ] . auth_token ; render ( ) ; }
function ( data , callback ) { user = data ; if ( ! user . twitter ) { return callback ( new Error ( 'This user has no twitter account' ) ) ; } twit = new ntwitter ( { consumer_key : config . twitter . consumerKey , consumer_secret : config . twitter . consumerSecret , access_token_key : user . twitter . token , access_token_secret : user . twitter . token_secret } ) ; return twit . verifyCredentials ( callback ) ; }
function onytplayerStateChange ( newState ) { if ( playlist_mode == "on" ) { if ( newState == 0 ) { video_src = getNextVideoFromPlaylist ( ) ; if ( video_src != null ) { video_player . loadVideoByUrl ( video_src ) ; } } } }
function BestInPlaceEditor ( e ) { this . element = e ; this . initOptions ( ) ; this . bindForm ( ) ; this . initNil ( ) ; if ( this . always_display_edit == false ) { return this . clickHandler ( ) ; } jQuery ( this . activator ) . bind ( 'click' , { editor : this } , this . clickHandler ) ; }
function initStates ( ) { var elevenCentComboState = createComboState ( 11 , [ 3 ] , [ 8 ] , null ) ; var tenCentComboState = createComboState ( 10 , [ 3 ] , [ 7 ] , elevenCentComboState ) ; var nineCentComboState = createComboState ( 9 , [ 3 ] , [ 6 ] , tenCentComboState ) ; var eightCentState = createCoinState ( 8 , nineCentComboState ) ; var sevenCentState = createCoinState ( 7 , eightCentState ) ; var sixCentState = createCoinState ( 6 , sevenCentState ) ; currentState = null ; }
function ( pageDef ) { var lpath = __dirname + '/' + markdown_destination + '/' + pageDef . config . dir ; if ( ! fs . existsSync ( lpath ) ) { wrench . mkdirSyncRecursive ( lpath ) ; } var filename = pageDef . config . name ? pageDef . config . name : pageDef . title . toLowerCase ( ) ; return lpath + '/' + filename + '.md' ; }
function ( match , url ) { var text = url . replace ( /#/g , "" ) ; url = url . replace ( / /g , "_" ) ; return '[' + text + '](' + url + ')' }
function ( asObject ) { var clonedObj = this . obj . clone ( false ) ; clonedObj . find ( '.aloha-cleanme' ) . remove ( ) ; this . removePlaceholder ( clonedObj ) ; PluginManager . makeClean ( clonedObj ) ; return asObject ? clonedObj . contents ( ) : contentSerializer ( clonedObj [ 0 ] ) ; }
function ( ) { var that = this , handler , cc , contentHandler = [ 'word' , 'generic' , 'sanitize' ] , i , j = contentHandler . length ; for ( i = 0 ; i < j ; i ++ ) { handler = contentHandler [ i ] ; cc = handler . charAt ( 0 ) . toUpperCase ( ) + handler . slice ( 1 ) ; ContentHandlerManager . register ( handler , eval ( cc + 'ContentHandler' ) ) ; } }
function fixSVGs ( ) { var svgs = [ ] . slice . call ( document . querySelectorAll ( "svg" ) ) , i , l ; for ( i = 0 , l = svgs . length ; i < l ; ++ i ) { SVGContainer ( svgs [ i ] ) . padTextViewports ( ) . overlaySelectableSpans ( ) . joinAdjacentTextEls ( ) . fixXlinkAttrs ( ) ; } }
function ( ) { elPopcorn . currentTime ( popcorn . currentTime ( ) - slideOptions . start ) ; elPopcorn . play ( ) ; popcorn . on ( "play" , onPlay ) ; popcorn . on ( "pause" , onPause ) ; popcorn . on ( "seeked" , onSeeked ) ; popcorn . on ( "seeking" , onSeeking ) ; }
function ( mark , options ) { var id = L . Util . stamp ( mark ) ; this . _markers = { id : mark } ; this . _latlng = mark . getLatLng ( ) ; L . Util . setOptions ( this , options ) ; this . options . icon = new L . Leafpile . Icon ( 1 ) ; }
function writeText ( view , value ) { ASSERT ( view instanceof jQuery , "expected jQuery object" ) ; if ( typeof value !== "string" ) value = JSON . stringify ( value ) ; value = view . text ( value ) . html ( ) ; view . html ( value . replace ( /\n/g , "<br />" ) ) ; }
function pop ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; if ( vv . value . length === 0 ) return ; vv . draft ( "value" , { removes : [ { index : vv . value . length - 1 , howMany : 1 } ] } ) ; runtime . maybeTouch ( vv ) ; return vv . value . pop ( ) ; }
function shift ( ) { var vv = this . unwrap ( ) ; ASSERT ( ! vv . isChanged ( ) , "folding change events not supported" ) ; if ( vv . value . length === 0 ) return ; vv . draft ( "value" , { removes : [ { index : 0 , howMany : 1 } ] } ) ; runtime . maybeTouch ( vv ) ; return vv . value . shift ( ) ; }
function ( side ) { if ( side . battle . getFormat ( ) . team === 'random' ) { return this . randomTeam ( side ) ; } else if ( side . user && side . user . team && side . user . team !== 'random' ) { return side . user . team ; } else { return this . randomTeam ( side ) ; } }
function InspectorExtensionAPI ( ) { this . audits = new Audits ( ) ; this . inspectedWindow = new InspectedWindow ( ) ; this . panels = new Panels ( ) ; this . network = new Network ( ) ; defineDeprecatedProperty ( this , "webInspector" , "resources" , "network" ) ; this . timeline = new Timeline ( ) ; this . console = new ConsoleAPI ( ) ; this . onReset = new EventSink ( events . Reset ) ; }
function ( origin , port ) { if ( ! this . _registeredExtensions . hasOwnProperty ( origin ) ) { if ( origin !== window . location . origin ) console . error ( "Ignoring unauthorized client request from " + origin ) ; return ; } port . _extensionOrigin = origin ; port . addEventListener ( "message" , this . _onmessage . bind ( this ) , false ) ; port . start ( ) ; }
function ( timestamp ) { if ( typeof timestamp === 'number' ) { console . log ( 'PASS low-level event' ) ; } else { console . error ( 'FAIL wrong argument to loadEventFired' ) ; } chrome . devtools . remoteDebug . removeDomainListener ( 'Page' , domainListener ) ; testHighLevel ( ) ; }
function ( html ) { self . writeHead ( 200 , { 'Content-Length' : Buffer . byteLength ( html ) , 'Content-Type' : 'text/html' } ) ; return self . end ( html ) ; }
function ( opts ) { if ( opts && typeof opts !== 'object' ) { throw new Error ( 'Options passed to ss.client.packAssets() must be an object' ) ; } return options . packedAssets = opts || true ; }
function ( err , oldname ) { socket . set ( 'name' , name , function ( ) { socket . emit ( 'welcome' , name ) ; socket . broadcast . emit ( 'connected' , { time : new Date ( ) . getTime ( ) , user : name } ) ; } ) ; }
function ( ) { this . renderSubview ( new TitleView ( ) ) ; this . renderSubview ( new MessagesView ( ) ) ; this . $el . append ( Mustache . render ( chatTemplate , { } ) ) ; this . renderSubview ( new UsersView ( ) ) ; this . $ ( 'input' ) . focus ( ) ; }
function ( message ) { var msg = message . toJSON ( ) ; if ( msg . time ) { msg . time = moment ( msg . time ) . from ( new Date ( ) ) ; } self . $el . append ( Mustache . render ( messageTemplate , msg ) ) ; }
function ( ) { var o = socket . options ; this . $el . html ( Mustache . render ( titleTemplate , { address : o . host + ( ( o . port && o . port != 80 ) ? ':' + o . port : '' ) , me : me . get ( 'name' ) } ) ) ; }
function ( html , parse ) { if ( parse ) { html = this . parent . parse ( html ) ; } this . element . innerHTML = html ; }
function ( ) { var self = this ; window . _ = window . gettext = function ( ) { return self . gettext . apply ( self , arguments ) ; } ; window . ngettext = function ( singular , plural , n ) { return self . ngettext . apply ( self , arguments ) ; } ; return this ; }
function ( element ) { return jQuery ( '.start' , element ) . button ( ) . click ( function ( e ) { return jQuery ( '.fangspiel-area' , element ) . sizedetect ( { result : function ( size , details ) { return Capkom . profile . set ( { symbolsizeMin : size , symbolsizedetectDetails : details } ) ; } } ) ; } ) ; }
function ( error , job_in_progress ) { if ( error ) { console . log ( util . inspect ( error ) ) ; return callback && callback ( ) ; } if ( job_in_progress ) { self . _status = "processing" ; self . _processing = job_in_progress ; self . _heartbeats = 0 ; job_in_progress . o && self . _broadcast ( job_in_progress . o , { "command" : "processJob" , "params" : job_in_progress } ) ; } printHeartbeat ( ) ; }
function ( region ) { delete region . $el ; }
function ( ) { var data = testUtilities . cloneObj ( testData . xml2jsConfig ) ; data [ "rim:invoke-target" ] = { "@" : { "id" : "com.domain.subdomain.appName.app" } } ; mockParsing ( data ) ; expect ( function ( ) { configParser . parse ( configPath , session , function ( configObj ) { } ) ; } ) . toThrow ( localize . translate ( "EXCEPTION_INVOKE_TARGET_INVALID_TYPE" ) ) ; }
function ( ) { var selected = path_selector . find ( 'input:checked' ) , to_ret = { } ; KT . utils . each ( selected , function ( item ) { item = $ ( item ) ; to_ret [ item . data ( 'node_id' ) ] = { text : item . parent ( ) . text ( ) , next_id : item . data ( 'next_node_id' ) } ; } ) ; return to_ret ; }
function ( node , next ) { var html = '' , next_node = next ? ( 'data-next_node_id="' + next . id + '"' ) : '' , input = node . select ? '<span class="checkbox_holder"><input class="node_select" type="checkbox" ' + next_node + ' data-node_id="' + node . id + '"></span>' : '' ; html += '<li data-node_id="' + node . id + '">' + '<label><div>' + input + node . name + '</div></label></li>' ; return html ; }
function ( arr , type ) { if ( arr && arr . length > 0 ) { for ( var i = 0 ; i < arr . length ; i ++ ) { if ( ! ( arr [ i ] instanceof type ) ) { cc . Log ( "element type is wrong!" ) ; return false ; } } } }
function renderMarkdown ( comment ) { var input = { 'text' : comment . body , 'mode' : 'gfm' } $ . ajax ( { url : 'https://api.github.com/markdown' , type : 'POST' , data : JSON . stringify ( input ) , success : function ( data , status , jqXHR ) { comment . body_html = data ; var arr = [ ] arr . push ( comment ) ; appendData ( arr ) ; } , error : function ( jqXHR , textStatus , errorThrown ) { } } ) ; }
function ( i ) { comment = tpl ( { useravatar : data [ i ] . user . avatar_url , username : data [ i ] . user . login , url : data [ i ] . user . url . split ( 'users/' ) [ 1 ] , content : data [ i ] . body_html , date : formatDate ( data [ i ] . created_at ) , commenturl : data [ i ] . url } ) ; listing . innerHTML += comment ; }
function renderMarkdown ( comment ) { var input = { 'text' : comment . body , 'mode' : 'gfm' } $ . ajax ( { url : 'https://api.github.com/markdown' , type : 'POST' , data : JSON . stringify ( input ) , success : function ( data , status , jqXHR ) { comment . body_html = data ; var arr = [ ] arr . push ( comment ) ; appendData ( arr ) ; } , error : function ( jqXHR , textStatus , errorThrown ) { } } ) ; }
function ( i ) { comment = tpl ( { useravatar : data [ i ] . user . avatar_url , username : data [ i ] . user . login , url : data [ i ] . user . url . split ( 'users/' ) [ 1 ] , content : data [ i ] . body_html , date : formatDate ( data [ i ] . created_at ) , commenturl : data [ i ] . url } ) ; listing . innerHTML += comment ; }
function ( length ) { if ( typeof length === 'undefined' ) { return Math . sqrt ( this . x * this . x + this . y * this . y ) ; } this . normalize ( ) ; this . x *= length ; this . y *= length ; }
function ( status ) { switch ( status ) { case "NEW" : return false ; case "STUCK" : return false ; case "IN_PROGRESS" : return true ; case "FIXED" : return true ; case "WORKAROUND" : return false ; case "IRRELEVANT" : return true ; } return null ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 710 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 732 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 773 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 803 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( ) { h = $ ( _this ) . html ( ) ; return $ ( _this ) . html ( json [ 0 ] . commentsbox_count + h ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 900 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( status ) { switch ( status ) { case "NEW" : return false ; case "STUCK" : return false ; case "IN_PROGRESS" : return true ; case "FIXED" : return true ; case "WORKAROUND" : return false ; case "IRRELEVANT" : return true ; } return null ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 710 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 732 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 773 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 803 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( ) { h = $ ( _this ) . html ( ) ; return $ ( _this ) . html ( json [ 0 ] . commentsbox_count + h ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 900 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( status ) { switch ( status ) { case "NEW" : return false ; case "STUCK" : return false ; case "IN_PROGRESS" : return true ; case "FIXED" : return true ; case "WORKAROUND" : return false ; case "IRRELEVANT" : return true ; } return null ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 710 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 732 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 773 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 803 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( ) { h = $ ( _this ) . html ( ) ; return $ ( _this ) . html ( json [ 0 ] . commentsbox_count + h ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 900 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( event ) { if ( ! self . shown ) { field . focus ( ) ; } }
function HeaderBuilder ( buffer , filename , date , offset , isDir , isDeflate ) { this . buffer = buffer ; this . filename = filename ; this . date = date ; this . offset = offset ; this . dirFlag = isDir ? 0x10 : 0 ; this . deflateFlag = isDeflate ? 0x8 : 0 ; this . _commonHeader = this . _getCommonHeader ( ) ; this . _cache = { lf : null , cd : null } ; }
function ( spec ) { if ( filterString === undefined ) { return false ; } if ( ! self . _topLevelFilter ( spec ) ) { return false ; } if ( filterString === "All" ) { return true ; } var topLevelSuite = spec . suite ; while ( topLevelSuite . parentSuite ) { topLevelSuite = topLevelSuite . parentSuite ; } return topLevelSuite . description === filterString ; }
function ( ) { expect ( testWindow . $ ( ".modal.instance" ) . length ) . toBe ( 1 ) ; var dismissButton = testWindow . $ ( ".modal.instance .dialog-button[data-button-id='" + buttonId + "']" ) ; expect ( dismissButton . length ) . toBe ( 1 ) ; dismissButton . click ( ) ; }
function changedURL ( event ) { if ( trackURL == true ) { if ( location . href . indexOf ( "#compose" ) != - 1 ) { putButtons ( ) ; } } else { if ( location . href . indexOf ( "#compose" ) == - 1 ) { trackURL = true ; } } }
function ( hiding ) { if ( hiding ) { $clicky . html ( '<span>+</span>' ) ; $handle . addClass ( 'closed' ) ; $handle . removeClass ( 'open' ) ; } else { $clicky . html ( '<span>&minus;</span>' ) ; $handle . addClass ( 'open' ) ; $handle . removeClass ( 'closed' ) ; } }
function ( ) { var exports = app . namespace ( "app.config.core" ) ; exports . board = { columnLeftMargin : 10 , columnWidth : 328 } ; exports . getNamesOfDefaultSubreddits = function ( ) { return [ "1000words" , "aviation" , "aww" , "birdpics" , "cityporn" , "earthporn" , "itookapicture" , "picturechallenge" , "wallpaper" , "wallpapers" , "windowshots" ] ; } ; exports . network = { timeout : 30000 } }
function ( path , cfg , addExt ) { var baseUrl = cfg . baseUrl ; return ( baseUrl && ! absUrlRx . test ( path ) ? joinPath ( baseUrl , path ) : path ) + ( addExt && ! dontAddExtRx . test ( path ) ? '.js' : '' ) ; }
function ( ) { if ( ! this . isNew ) { this . warDelWin = this . getView ( 'warranty.Delete' ) . create ( ) ; this . warDelWin . getComponent ( 'nb-war-del-win-container' ) . getComponent ( 'nb-war-del-win-message' ) . update ( 'Удалить заказ №' + Ext . getCmp ( 'nb-war-id' ) . getValue ( ) + ' ?' ) ; this . warDelWin . show ( ) ; } else { Ext . Msg . alert ( 'Сообщение' , 'Удалить можно только сохраненній заказ' ) ; } }
function ( ) { this . disconnect_all ( 'child' ) ; this . element . empty ( ) ; }
function ( name ) { var words = name . split ( /[_\s]/ ) ; words = words . map ( function ( x ) { return x [ 0 ] . toUpperCase ( ) + x . slice ( 1 ) ; } ) ; return words . join ( ' ' ) ; }
function ( seed , names ) { this . empty ( ) ; for ( var name in names ) { if ( seed . hasOwnProperty ( name ) ) { var control = this . create_control ( seed , name , names [ name ] ) ; this . connect ( control , 'child' , 'parent' ) ; } } }
function ( input , owner , name , source ) { input . val ( owner [ name ] ) ; Bloom . watch_input ( input , function ( ) { owner . value ( name , input . val ( ) , source ) ; } ) ; source . listen ( owner , 'change.' + name , function ( value ) { input . val ( value ) ; } ) ; }
function ( ) { var version = - 1 ; if ( navigator . appName == 'Microsoft Internet Explorer' ) { var ua = navigator . userAgent ; var re = new RegExp ( "MSIE ([0-9]{1,}[\.0-9]{0,})" ) ; if ( re . exec ( ua ) != null ) version = parseFloat ( RegExp . $1 ) ; } return version ; }
function ( ) { var version = MetaHub . get_internet_explorer_version ( ) ; return version > 1 && version < 9 ; }
function ( script , context , frame ) { if ( frame ) { var name = frame . name ; var args = StackFrame . getFunctionArgValues ( frame ) ; } else { var name = script . functionName ; var args = [ ] ; } if ( name == "anonymous" ) { name = StackFrame . guessFunctionName ( this . sourceFile . href , this . getBaseLineNumberByScript ( script ) , context ) ; } return { name : name , args : args } ; }
function ( ) { console . log ( Deco . name + " and " + Hugo . name + " are now " + John . fullName ( ) + "'s pets" ) ; }
function createJohn ( callback ) { Person . find ( { "name" : "John" } , function ( people ) { if ( people === null ) { var John = new Person ( { "name" : "John" , "surname" : "Doe" , "created" : new Date ( ) , "age" : 25 } ) ; John . save ( function ( err , person ) { callback ( person ) ; } ) ; } else { callback ( people [ 0 ] ) ; } } ) ; }
function ( err ) { if ( -- missingInstances === 0 ) cb ( null ) ; }
function ( err ) { if ( -- missingInstances === 0 ) cb ( null ) ; }
function ( err , proc ) { if ( err ) { psm . log . error ( err , 'Unable to start minecraft process.' ) ; if ( cb ) cb ( err ) ; return ; } psm . log . silly ( 'Done.' ) ; if ( cb ) cb ( null ) ; }
function ( err ) { if ( err ) { psm . log . error ( err , 'Failed to move world files to disk.' ) ; if ( cb ) cb ( err ) ; return ; } psm . log . silly ( 'Done.' ) ; if ( cb ) cb ( null ) ; }
function ( cb ) { var self = this , status = { running : self . proc . running , players : self . outputs . players , properties : self . files . properties , mcversion : self . outputs . mcversion , cbversion : self . outputs . cbversion } ; cb ( null , status ) ; }
function newContentFunction ( type , contentParent ) { initAjaxUpload ( type , contentParent ) ; initFancyCoose ( type , contentParent ) ; initDatePicker ( type , contentParent ) ; if ( type != 'initial' ) { initAutoFocus ( type , contentParent ) ; } initAjaxPaging ( type , contentParent ) ; updateHomeGPS ( type , contentParent ) ; }
function initMealplannerPeopleRowContainer ( type , contentParent ) { var container = contentParent . find ( '.people .addRowContainer' ) ; var data = contentParent . find ( '#rowsJSON' ) . attr ( 'value' ) ; var errors = contentParent . find ( '#errorJSON' ) . attr ( 'value' ) ; initMealplannerPeopleRowContainerDoIt ( container , data , errors ) ; }
function ( ) { var user ; user = loadUser ( ) ; if ( user ) { return fimo . data . post ( 'login' , { 'email' : user . email , 'password' : user . password } , function ( ) { return fimo . controller . jumbles ( ) ; } , function ( ) { console . log ( "automatic login unsuccessful. removing local storage user." ) ; return window . localStorage . removeItem ( 'user' ) ; } ) ; } }
function ( evt ) { evt && evt . preventDefault ( ) var remixUrl = "https://makr.io/posts/" + this . model . id + "/remix" , caption = "made on <a href='https://www.makr.io'>makr.io</a> | <a href='" + remixUrl + "'>remix this</a>" , source = "https://makr.io/p/" + this . model . id , url = "http://www.tumblr.com/share/photo?" + "source=" + encodeURIComponent ( source ) + "&caption=" + encodeURIComponent ( caption ) + "&clickthru=" + encodeURIComponent ( source ) this . launchWindow ( url ) }
function ( ) { var animation_name ; if ( editor . cur_animation . frames < 1 ) { return ; } if ( ! editor . selected_animation ) { animation_name = window . prompt ( "Enter animation name:" ) ; if ( animation_name === null || animation_name . trim ( ) === "" ) { return ; } editor . selected_animation = animation_name ; } else if ( ! window . confirm ( "Are you sure you want to save over \"" + editor . selected_animation + "\"?\n\n(If not, select \"(new)\" in the animation drop down box.)" ) ) { return ; } save_animation ( editor . selected_animation , editor . cur_animation ) ; }
function ( success , data ) { $ ( "#areapermissions_content_container" ) . html ( sakai . api . Util . TemplateRenderer ( "areapermissions_content_template" , { "roles" : sortedroles , "visibility" : visibility , "manager" : contextData . isManager , "groupPermissions" : sakai_global . group . groupData [ "sakai:group-visible" ] , "sakai" : sakai , "area" : currentArea . _title , "meRole" : data . id } ) ) ; }
function ( success ) { sakai . api . Util . progressIndicator . showProgressIndicator ( sakai . api . i18n . getValueForKey ( 'REMOVING_CONTENT_FROM_COLLECTION' , 'collectionviewer' ) , sakai . api . i18n . getValueForKey ( 'PROCESSING' , 'collectionviewer' ) ) ; $ ( '.collectionviewer_check:checked:visible' , $rootel ) . parents ( 'li:not(.contentauthoring_row_container)' ) . hide ( 'slow' ) ; setTimeout ( refreshCollection , 1500 ) ; }
function ( ev , val ) { var num = parseInt ( $ ( "#entity_participants_count" ) . text ( ) , 10 ) ; var newNum = num + val ; $ ( "#entity_participants_count" ) . text ( newNum ) ; if ( newNum === 1 ) { $ ( "#entity_participants_text" ) . text ( sakai . api . i18n . getValueForKey ( "PARTICIPANT" , "entity" ) ) ; } else { $ ( "#entity_participants_text" ) . text ( sakai . api . i18n . getValueForKey ( "PARTICIPANTS" , "entity" ) ) ; } }
function ( responses ) { if ( responses && responses . length > 0 ) { var html = responses [ 0 ] . formatted_address ; updateInfoWindow ( html ) ; } else { $ ( window ) . trigger ( 'show.mapsnotification.sakai' , { subject : sakai . api . i18n . Widgets . getValueForKey ( 'googlemaps' , 'NO_ADDRESS' ) , body : sakai . api . i18n . Widgets . getValueForKey ( 'googlemaps' , 'CANNOT_DETERMINE_ADDRESS_AT_THIS_LOCATION' ) } ) ; } }
function ( ) { itemsToUpload = [ ] ; itemsUploaded = 0 ; disableAddToQueue ( ) ; renderQueue ( ) ; $ ( '#newaddcontent_container input, #newaddcontent_container textarea' ) . val ( '' ) ; tmpBrowsedFile = { } ; filesList = [ ] ; contentDataBatch = [ ] ; }
function ( attributes ) { this . checkAttr ( ) ; this . set ( { 'attr' : _ . defaults ( this . get ( 'attr' ) , this . defaultAttr ) } ) this . on ( 'updateFrameOrder' , this . updateFrameOrder , this ) ; this . on ( 'sync' , this . checkAttr , this ) ; this . attachTabView ( ) ; this . trigger ( 'ready' ) ; }
function ( tagObject , args ) { var i = 0 , l = args . length ; while ( l && ! args [ i ++ ] ) { if ( i === l ) { return "" ; } } view . onElse = undefined ; tagObject . path = "" ; return tagObject . renderContent ( view ) ; }
function ( err , conn ) { if ( err ) error = err ; else { connection = conn ; if ( ! pendingStmt && queue [ 0 ] ) run ( queue . shift ( ) ) ; } callbacks ( ) ; }
function ( sql , params ) { checkState ( ) ; if ( ! params ) params = undefined ; var resolver = new events . EventEmitter ( ) , stmt = [ sql , params , resolver ] ; queue . push ( stmt ) ; if ( ! pendingStmt && connection !== null && queue [ 1 ] === stmt ) run ( queue . shift ( ) ) ; return new ResultPromise ( resolver ) ; }
function ( Y , NAME ) { Y . mojito . controllers [ NAME ] = { init : function ( config ) { this . config = config ; } , index : function ( ac ) { ac . done ( { "title" : "primary" , "data-action" : 'filter' , "data-params" : 'f=5&q=7' } ) ; } , dynamic : function ( ac ) { ac . done ( { title : 'Dynamic done!' } ) ; } } ; } , '0.0.1' , { requires : [ 'mojito' ] }
function ( obj ) { var ret = false ; if ( isUndefinedOrNull ( obj ) ) { ret = true ; } else if ( isString ( obj ) || isArray ( obj ) ) { ret = obj . length === 0 ; } else if ( isBoolean ( obj ) && ! obj ) { ret = true ; } else if ( isObject ( obj ) && isEmpty ( obj ) ) { ret = true ; } return ret ; }
function runTest ( ) { browserElementTestHelpers . setEnabledPref ( true ) ; browserElementTestHelpers . addToWhitelist ( ) ; iframe = document . createElement ( 'iframe' ) ; iframe . mozbrowser = true ; addOneShotIframeEventListener ( 'mozbrowserloadend' , function ( ) { SimpleTest . executeSoon ( test2 ) ; } ) ; iframe . src = browserElementTestHelpers . emptyPage1 ; document . body . appendChild ( iframe ) ; }
function ( err , response , body ) { if ( err ) return cb ( err ) ; log . silly ( response . statusCode , "act response statusCode" ) ; log . silly ( body , "act response bodt" ) ; if ( response . statusCode !== 200 ) return cb ( "Bad response: " + body + " code: " + response . statusCode ) ; return cb ( undefined , body ) ; }
function ( responseText , responseXML ) { if ( this . status === _this . httpStatusCode . noContent ) { _this . $searchResults . html ( "" ) ; jQuery ( "#search-returned-nothing" ) . show ( ) ; } else _this . $searchResults . html ( Mustache . to_html ( jQuery ( "#search-results-template" ) . html ( ) , { helpRequests : JSON . parse ( responseText ) } ) ) ; }
function browser_urlBlur ( ) { this . urlInput . value = this . currentTab . title || this . currentTab . url ; }
function ( path , args , root ) { var fn = flock . resolvePath ( path , root ) ; if ( typeof ( fn ) !== "function" ) { throw new Error ( "Path '" + path + "' does not resolve to a function." ) ; } return fn . apply ( null , args ) ; }
function ( ugenDef , options ) { if ( typeof ( ugenDef . length ) === "number" || ugenDef . id !== flock . OUT_UGEN_ID ) { ugenDef = { id : flock . OUT_UGEN_ID , ugen : "flock.ugen.out" , inputs : { sources : ugenDef , bus : 0 , expand : options . chans } } ; } return flock . parse . ugenForDef ( ugenDef , options . rates , options . visitors ) ; }
function ( outputBufferGenerator , rate ) { rate = rate || flock . rates . AUDIO ; return { rate : rate , output : flock . generate ( 64 , outputBufferGenerator ) , onInputChanged : function ( ) { } } ; }
function ( newValue ) { var editor = editorGetFn ( editField ) ; if ( ! editor ) { if ( newValue ) { $ ( editField ) . val ( newValue ) ; } return "" ; } if ( newValue ) { setValueFn ( editField , editor , newValue ) ; } else { return getValueFn ( editor ) ; } }
function ( ) { var dropWarningEl ; if ( mouseDropWarning ) { dropWarningEl = mouseDropWarning [ 0 ] ; } avatar = $ ( options . avatarCreator ( item [ 0 ] , styles . avatar , dropWarningEl ) ) ; avatar . prop ( "id" , createAvatarId ( thatReorderer . container . id ) ) ; return avatar ; }
function ( item , newPosition ) { fluid . clear ( movedMap ) ; var movingId = fluid . allocateSimpleId ( item ) ; movedMap [ movingId ] = { oldRender : that . renderLabel ( item ) } ; }
function ( e ) { Event . stop ( e ) ; this . viewsByName . details . paint ( resource ) ; this . alternatives . showAlternative ( this . viewsByName . details ) ; }
function ( Component ) { var Arena = Component . extend ( { init : function ( ) { this . element = $ ( '<div>' ) ; } , adopt : function ( component ) { this . element . append ( component . element ) ; } } ) ; return Arena ; }
function ( s ) { return new Pit . FSharp . Collections . SetTreeModule . SetIterator1 ( Pit . FSharp . Collections . SetTreeModule . collapseLHS ( new Pit . FSharp . Collections . FSharpList1 . Cons ( s , new Pit . FSharp . Collections . FSharpList1 . Empty ( ) ) ) , false ) ; }
function ( thisObject ) { if ( option instanceof Pit . FSharp . Core . FSharpOption1 . Some ) { var x = option . get_Value ( ) ; return new Pit . FSharp . Collections . FSharpList1 . Cons ( x , new Pit . FSharp . Collections . FSharpList1 . Empty ( ) ) ; } else { return new Pit . FSharp . Collections . FSharpList1 . Empty ( ) ; } }
function ( span ) { if ( span <= 1000000 ) { return ~ ~ ( span / 10000 ) + 1 ; } return Math . pow ( 10 , ( ~ ~ ( Math . log ( span ) / Math . log ( 10 ) ) - 4 ) ) * 5 ; }
function ( ) { var $a = $ ( this ) . closest ( 'a' ) ; switchStyle ( $a . attr ( 'data-title' ) ) ; setTimeout ( function ( ) { $a . addClass ( 'active' ) ; } , 0 ) ; }
function fx ( ) { var fx ; if ( ! ! window . Zepto ) { fx = window . Zepto ; fx . fn . prop = fx . fn . attr ; } else if ( ! ! window . jQuery ) { fx = window . jQuery ; } else { throw ( 'Either Zepto or jQuery is required but neither can be found.' ) ; } return fx ; }
function ( ) { var el = document . createElement ( 'bootstrap' ) , transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'oTransitionEnd otransitionend' , 'msTransition' : 'MSTransitionEnd' , 'transition' : 'transitionend' } , name for ( name in transEndEventNames ) { if ( el . style [ name ] !== undefined ) { return transEndEventNames [ name ] } } }
function ( ) { var el = document . createElement ( 'bootstrap' ) , transEndEventNames = { 'WebkitTransition' : 'webkitTransitionEnd' , 'MozTransition' : 'transitionend' , 'OTransition' : 'oTransitionEnd otransitionend' , 'msTransition' : 'MSTransitionEnd' , 'transition' : 'transitionend' } , name for ( name in transEndEventNames ) { if ( el . style [ name ] !== undefined ) { return transEndEventNames [ name ] } } }
function ( $parent , $detail , state ) { $detail . add ( $parent ) . removeClass ( collapsedClass ) . addClass ( expandedClass ) $detail . find ( this . options . detailWrapperClass ) [ this . _getAnimationMethod ( state ) ] ( this . options . speed , function ( ) { } ) ; }
function ( ) { $detail . add ( $parent ) . addClass ( collapsedClass ) . removeClass ( expandedClass ) ( this . options . obscureParent ) && $parent . toggle ( ) ; }
function ( result ) { var override = { og_image : conf . app . host + "/images/" + result [ 0 ] . path + "." + result [ 0 ] . ext , og_url : conf . app . host + "/photo/" + result [ 0 ] . path } ; res . render ( 'imageDetails' , { locals : { image : result , config : mergeStruct ( conf . app , override ) } } ) ; }
function ( ) { var args_len = arguments . length ; for ( var i = args_len ; i -- ; ) { var cacheImage = document . createElement ( 'img' ) ; cacheImage . src = arguments [ i ] ; cache . push ( cacheImage ) ; } }
function ( c ) { return new a ( this , c ) ; } } ) ; } ) ( ) ; URI = Class . refactor ( URI , { combine : function ( f , e ) {
function ( ) { Ext . define ( 'ExampleView' , { extend : 'Ext.Container' , mixins : [ 'Deft.mixin.Controllable' ] } ) ; Ext . define ( 'ExampleViewController' , { extend : 'Deft.mvc.ViewController' } ) ; return expect ( function ( ) { return Ext . create ( 'ExampleView' ) ; } ) . toThrow ( 'Error initializing Controllable instance: `controller` was not specified.' ) ; }
function ( e , ui ) { if ( $ ( ui ) . data ( 'role' ) === 'content' || $ ( ui ) . data ( 'role' ) === 'page' ) { setSelected ( null ) ; } else if ( ! $ ( ui ) . hasClass ( 'ui-selected' ) ) { setSelected ( ui ) ; } else if ( e . ctrlKey ) { setSelected ( null ) ; } e . stopPropagation ( ) ; return false ; }
function getFileName ( ) { var filename = $ ( "#his_date_start" ) . val ( ) + "_" + $ ( "#his_time_start" ) . val ( ) + "m--" + $ ( "#his_date_end" ) . val ( ) + "_" + $ ( "#his_time_end" ) . val ( ) + "m" filename = filename . replace ( /:/g , "h" ) return filename ; }
function ( obj ) { return Object . prototype . toString . call ( obj ) === '[object Array]' ; }
function fetch_control_set ( thesaurus ) { if ( ! _acs_cache_by_at [ thesaurus ] ) { var at = pcrud . retrieve ( "at" , thesaurus , { "flesh" : 1 , "flesh_fields" : { "at" : [ "control_set" ] } } ) ; _acs_cache_by_at [ thesaurus ] = at . control_set ( ) ; } return _acs_cache_by_at [ thesaurus ] ; }
function ( ) { if ( Ext . isIE6 || Ext . isIE7 || Ext . isIE8 || ( Ext . isIE && this . document . documentMode < 9 ) ) { Ext . each ( this . config . customTags , function ( tag ) { this . document . createElement ( tag ) ; } , this ) ; } }
function ( err ) { if ( err ) { grunt . log . error ( err ) ; return cb ( false ) ; } cb ( ) ; }
function ( ) { this . waitingPiece = this . createPiece ( ) ; this . playPiece = this . createPiece ( ) ; this . renderWaiting ( this . waitingPiece ) ; this . render ( ) ; var that = this ; this . time = window . setInterval ( $ . proxy ( this . gameLoop , this ) , 500 ) ; }
function ( e ) { if ( that . collisionTest ( ) === false ) { if ( e . keyCode === 37 ) { that . moveLeft ( ) ; } if ( e . keyCode === 39 ) { that . moveRight ( ) ; } } else { console . log ( 'wall hit' ) ; } }
function ( index ) { if ( board [ index ] == 1 ) { return ; } if ( pieceConcat [ index ] == 1 ) { $ ( this ) . css ( 'backgroundColor' , '#' + that . playPiece . color ) ; } if ( board [ index ] === 0 && pieceConcat [ index ] === 0 ) { $ ( this ) . css ( 'backgroundColor' , '#aaa' ) ; } $ ( this ) . html ( pieceConcat [ index ] ) ; }
function ( event ) { event . stopPropagation ( ) ; that . sortList ( listProps . colModel [ i ] , this ) ; }
function ( e ) { e . preventDefault ( ) ; if ( $ ( this ) . hasClass ( "resized" ) ) { $ ( this ) . removeClass ( "resized" ) ; $ ( this ) . parent ( ) . find ( "img" ) . css ( "width" , "" ) ; } else { $ ( this ) . addClass ( "resized" ) . parent ( ) . find ( "img" ) . css ( "width" , "100%" ) ; } return false ; }
function create_sightingbasket ( ) { try { } catch ( e ) { var errormsg = "An error occurred while trying to create the butterfly basket.\n" ; if ( e == "locstor_err" ) { errormsg += "Local storage isn't supported by your device." ; } else if ( e == "basketcreate_err" ) { errormsg += "The butterfly basket couldn't be created." ; } else { errormsg += "Error message: " + e . message ; } alert ( errormsg ) ; } }
function ( viewID ) { $ . UINavigationListExits = true ; $ ( $ . UINavigationHistory [ $ . UINavigationHistory . length - 1 ] ) . attr ( "ui-navigation-status" , "traversed" ) ; $ ( viewID ) . attr ( "ui-navigation-status" , "current" ) ; $ . UINavigationHistory . push ( viewID ) ; if ( $ . app . attr ( "ui-kind" ) === "navigation-with-one-navbar" ) { $ ( "navbar uibutton[ui-implements=back]" ) . css ( "display" , "block" ) ; } }
function ( ) { $this . UIHandleTouchState ( ) ; if ( $ . UINavigationEvent ) { return ; } else { $ . UINavigationEnabled = true ; $ . UINavigationEvent = false ; navigateList ( $this ) ; $ . UINavigationEvent = true ; } }
function ( ) { $ . app . delegate ( 'uibutton' , 'touchstart' , function ( ) { if ( $ ( this ) . hasClass ( 'disabled' ) ) { return false ; } else { $ ( this ) . UIHandleTouchState ( ) ; } } ) ; }
function ( selector ) { $ ( selector + " uibutton[ui-implements=cancel]" ) . unbind ( "click" , "cancelClickPopup" ) ; $ ( selector + " uibutton[ui-implements=continue]" ) . unbind ( "click" , "cancelTouchPopup" ) ; $ ( selector ) . UIUnblock ( ) ; $ ( selector ) . remove ( ) ; $ . UIPopUpIdentifier = null ; $ . UIPopUpIsActive = false ; }
function ( ) { if ( $ ( "mask" ) . length > 0 ) { $ ( "mask" ) . remove ( ) ; } return this ; }
function ( idx ) { if ( $ ( this ) . attr ( "ui-implements" ) !== "segmented-paging" ) { $ ( this ) . UISegmentedControl ( ) ; var whichScroller = $ ( this ) . closest ( "scrollpanel" ) . attr ( "ui-scroller" ) ; if ( whichScroller ) { $ . UIScrollers [ whichScroller ] . refresh ( ) } } }
function ( ) { var view = $ ( this ) . closest ( "view" ) ; view . UISetTranstionType ( "pop" ) ; $ ( this ) . bind ( "click" , function ( ) { $ ( "subview:nth-of-type(2)" , view ) . toggleClassName ( "pop-in" , "pop-out" ) ; } ) ; }
function defaultDisplay ( nodeName ) { var element , display ; if ( ! elementDisplay [ nodeName ] ) { element = document . createElement ( nodeName ) ; document . body . appendChild ( element ) ; display = getComputedStyle ( element , '' ) . getPropertyValue ( "display" ) ; element . parentNode . removeChild ( element ) ; display == "none" && ( display = "block" ) ; elementDisplay [ nodeName ] = display ; } return elementDisplay [ nodeName ] ; }
function fragment ( html , name ) { if ( name === undefined ) fragmentRE . test ( html ) && RegExp . $1 ; if ( ! ( name in containers ) ) name = '*' ; var container = containers [ name ] ; container . innerHTML = '' + html ; return slice . call ( container . childNodes ) ; }
function ( ) { if ( this . parentNode != null ) { this . parentNode . removeChild ( this ) ; } }
function ( selector ) { var ancestors = [ ] , nodes = this ; while ( nodes . length > 0 ) nodes = $ . map ( nodes , function ( node ) { if ( ( node = node . parentNode ) && node !== document && ancestors . indexOf ( node ) < 0 ) { ancestors . push ( node ) ; return node ; } } ) ; return filtered ( ancestors , selector ) ; }
function ( html ) { return html === undefined ? ( this . length > 0 ? this [ 0 ] . innerHTML : null ) : this . each ( function ( idx ) { var originHtml = this . innerHTML ; $ ( this ) . empty ( ) . append ( funcArg ( this , html , idx , originHtml ) ) ; } ) ; }
function ( ) { if ( this . length == 0 ) return null ; var obj = this [ 0 ] . getBoundingClientRect ( ) ; return { left : obj . left + window . pageXOffset , top : obj . top + window . pageYOffset , width : obj . width , height : obj . height } ; }
function ( idx ) { classList = [ ] ; var cls = this . className , newName = funcArg ( this , name , idx , cls ) ; newName . split ( /\s+/g ) . forEach ( function ( klass ) { if ( ! $ ( this ) . hasClass ( klass ) ) { classList . push ( klass ) } } , this ) ; classList . length && ( this . className += ( cls ? " " : "" ) + classList . join ( " " ) ) }
function ( idx ) { if ( name === undefined ) return this . className = '' ; classList = this . className ; funcArg ( this , name , idx , classList ) . split ( /\s+/g ) . forEach ( function ( klass ) { classList = classList . replace ( classRE ( klass ) , " " ) } ) ; this . className = classList . trim ( ) }
function ( name ) { return this . each ( function ( idx ) { if ( name === undefined ) return this . className = '' ; classList = this . className ; funcArg ( this , name , idx , classList ) . split ( /\s+/g ) . forEach ( function ( klass ) { classList = classList . replace ( classRE ( klass ) , " " ) } ) ; this . className = classList . trim ( ) } ) ; }
function ( idx ) { var newName = funcArg ( this , name , idx , this . className ) ; ( when === undefined ? ! $ ( this ) . hasClass ( newName ) : when ) ? $ ( this ) . addClass ( newName ) : $ ( this ) . removeClass ( newName ) ; }
function insert ( operator , target , node ) { var parent = ( operator % 2 ) ? target : target . parentNode ; parent && parent . insertBefore ( node , ! operator ? target . nextSibling : operator == 1 ? parent . firstChild : operator == 2 ? target : null ) ; }
function ( html ) { $ ( html ) [ key ] ( this ) ; return this ; }
function ( event , fn ) { findHandlers ( element , event , fn , selector ) . forEach ( function ( handler ) { delete handlers [ id ] [ handler . i ] ; element . removeEventListener ( handler . e , handler . proxy , false ) ; } ) ; }
function remove ( element , events , fn , selector ) { var id = zid ( element ) ; eachEvent ( events || '' , fn , function ( event , fn ) { findHandlers ( element , event , fn , selector ) . forEach ( function ( handler ) { delete handlers [ id ] [ handler . i ] ; element . removeEventListener ( handler . e , handler . proxy , false ) ; } ) ; } ) ; }
function ( fn , type ) { return function ( ) { var result = fn . apply ( element , arguments ) ; remove ( element , type , fn ) ; return result ; } }
function ( i , element ) { add ( this , event , callback , null , function ( fn , type ) { return function ( ) { var result = fn . apply ( element , arguments ) ; remove ( element , type , fn ) ; return result ; } } ) ; }
function ( event , selector , callback ) { return selector === undefined || $ . isFunction ( selector ) ? this . unbind ( event , selector ) : this . undelegate ( selector , event , callback ) ; }
function ( event , data ) { if ( typeof event == 'string' ) event = $ . Event ( event ) ; fix ( event ) ; event . data = data ; return this . each ( function ( ) { this . dispatchEvent ( event ) } ) ; }
function ( i , element ) { e = createProxy ( typeof event == 'string' ? $ . Event ( event ) : event ) ; e . data = data ; e . target = element ; $ . each ( findHandlers ( element , event . type || event ) , function ( i , handler ) { result = handler . proxy ( e ) ; if ( e . isImmediatePropagationStopped ( ) ) return false ; } ) ; }
function ( callback ) { if ( callback ) this . bind ( name , callback ) ; else if ( this . length ) try { this . get ( 0 ) [ name ] ( ) } catch ( e ) { } ; return this ; }
function ( name ) { $ . fn [ name ] = function ( callback ) { if ( callback ) this . bind ( name , callback ) ; else if ( this . length ) try { this . get ( 0 ) [ name ] ( ) } catch ( e ) { } ; return this ; } ; }
function ( ) { el = $ ( this ) ; var type = el . attr ( 'type' ) ; if ( ! this . disabled && type != 'submit' && type != 'reset' && type != 'button' && ( ( type != 'radio' && type != 'checkbox' ) || this . checked ) ) { result . push ( { name : el . attr ( 'name' ) , value : el . val ( ) } ) ; } }
function ( callback ) { if ( callback ) this . bind ( 'submit' , callback ) else if ( this . length ) { var event = $ . Event ( 'submit' ) ; this . eq ( 0 ) . trigger ( event ) ; if ( ! event . defaultPrevented ) this . get ( 0 ) . submit ( ) } return this ; }
function getData ( node , name ) { var id = node [ exp ] , store = id && data [ id ] ; return name === undefined ? store || setData ( node ) : ( store && store [ name ] ) || dataAttr . call ( $ ( node ) , name ) ; }
function setData ( node , name , value ) { var id = node [ exp ] || ( node [ exp ] = ++ uuid ) , store = data [ id ] || ( data [ id ] = { } ) ; if ( name !== undefined ) store [ name ] = value ; return store ; }
function ajaxStart ( settings ) { if ( settings . global && $ . active ++ === 0 ) triggerGlobal ( settings , null , 'ajaxStart' ) ; }
function ( url , data , success , dataType ) { if ( $ . isFunction ( data ) ) dataType = dataType || success , success = data , data = null ; return $ . ajax ( { type : 'POST' , url : url , data : data , success : success , dataType : dataType } ) ; }
function ( name , context , callback ) { var value = context . lookup ( name ) ; if ( value == null || value === false || ( isArray ( value ) && value . length === 0 ) ) { return callback ( context , this ) ; } return "" ; }
function ( err , s ) { if ( err ) { cb ( err ) ; } else { try { var doc = parseDocumentFromString ( s ) ; cb ( null , doc ) ; } catch ( e ) { cb ( e ) ; } } }
function ( ) { Ext . getBody ( ) . mask ( 'Rendering table of all results. May take some time for many students.' , 'page-load-mask' ) ; this . store . suspendEvents ( ) ; this . _addAssignmentsToStore ( ) ; this . _addGroupsToStore ( ) ; this . updateScaledPoints ( ) ; this . store . resumeEvents ( ) ; this . _completeDatasetLoaded = true ; this . store . fireEvent ( 'datachanged' ) ; this . fireEvent ( 'completeDatasetLoaded' , this ) ; Ext . getBody ( ) . unmask ( ) ; }
function ( ) { var grid = this . createGrid ( ) ; this . _detailsPanel = Ext . widget ( 'panel' , { title : 'Select a student to view their details' , region : 'south' , autoScroll : true , layout : 'fit' , height : 200 , collapsed : true , collapsible : true } ) ; this . add ( { xtype : 'container' , layout : 'border' , items : [ grid , this . _detailsPanel ] } ) ; this . up ( 'statistics-dataview' ) . on ( 'selectStudent' , this . _onSelectStudent , this ) ; }
function ( ) { var gridColumns = this . getGridColumns ( ) ; return Ext . widget ( 'grid' , { region : 'center' , multiSelect : true , autoScroll : true , store : this . loader . store , columns : gridColumns , listeners : { scope : this , select : function ( grid , record ) { this . up ( 'statistics-dataview' ) . fireEvent ( 'selectStudent' , record ) ; } } } ) ; }
function ( context , args ) { if ( ! cancelled && ! fired && ! firing ) { args = args || [ ] ; firing = 1 ; try { while ( callbacks [ 0 ] ) { callbacks . shift ( ) . apply ( context , args ) ; } } catch ( e ) { } finally { fired = [ context , args ] ; firing = 0 ; } } return this ; }
function ( ) { require ( Aloha . settings . requireConfig , [ 'vendor/jquery.json-2.2.min' , 'vendor/jquery.store' , 'aloha/rangy-core' , 'util/json2' , 'util/class' , 'util/lang' , 'util/range' , 'util/dom' , 'aloha/core' , 'aloha/editable' , 'aloha/console' , 'aloha/markup' , 'aloha/message' , 'aloha/plugin' , 'aloha/selection' , 'aloha/command' , 'aloha/jquery.patch' , 'aloha/jquery.aloha' , 'aloha/sidebar' , 'util/position' , 'aloha/ext-alohaproxy' , 'aloha/ext-alohareader' , 'aloha/ext-alohatreeloader' , 'aloha/ui' , 'aloha/ui-attributefield' , 'aloha/ui-browser' , 'aloha/floatingmenu' , 'aloha/repositorymanager' , 'aloha/repository' , 'aloha/repositoryobjects' , 'aloha/contenthandlermanager' ] , function ( ) { Aloha . jQuery ( Aloha . init ) ; } ) ; }
function ( asObject ) { var clonedObj = this . obj . clone ( false ) ; clonedObj . find ( '.aloha-cleanme' ) . remove ( ) ; this . removePlaceholder ( clonedObj ) ; PluginManager . makeClean ( clonedObj ) ; return asObject ? clonedObj . contents ( ) : clonedObj . html ( ) ; }
function ( ) { var name = $ ( this ) . closest ( ".remote_setting" ) . attr ( "id" ) . split ( "remote_settings_" ) [ 1 ] ; var index = $ ( ".filter" , $ ( this ) . parent ( ) ) . index ( $ ( this ) ) ; var c = confirm ( "Are you sure you want to remove this filter?" ) ; if ( c ) { socket . send ( "request=remove_filter&name=" + name + "&index=" + index ) ; } }
function facebooklogin ( ) { alert ( "sdfsdf" ) ; Parse . FacebookUtils . logIn ( "user_likes,email" , { success : function ( user ) { if ( ! user . existed ( ) ) { alert ( "User signed up and logged in through Facebook!" ) ; } else { alert ( "User logged in through Facebook!" ) ; } } , error : function ( user , error ) { alert ( "User cancelled the Facebook login or did not fully authorize." ) ; } } ) ; }
function ( error ) { error = error || '' ; if ( this . elements . error ) { this . elements . error . text ( error ) ; if ( error ) { this . elements . error . show ( ) ; setTimeout ( ( function ( player ) { return function ( ) { player . elements . error . hide ( 'slow' ) ; } ; } ) ( this ) , 5000 ) ; } else { this . elements . error . hide ( ) ; } } }
function ( error ) { error = error || '' ; if ( this . elements . error ) { this . elements . error . text ( error ) ; if ( error ) { this . elements . error . show ( ) ; setTimeout ( ( function ( player ) { return function ( ) { player . elements . error . hide ( 'slow' ) ; } ; } ) ( this ) , 5000 ) ; } else { this . elements . error . hide ( ) ; } } }
function ( error ) { error = error || '' ; if ( this . elements . error ) { this . elements . error . text ( error ) ; if ( error ) { this . elements . error . show ( ) ; setTimeout ( ( function ( player ) { return function ( ) { player . elements . error . hide ( 'slow' ) ; } ; } ) ( this ) , 5000 ) ; } else { this . elements . error . hide ( ) ; } } }
function startOAuth ( ) { clearStorage ( ) ; var queryParams = [ 'client_id=' + appID , 'redirect_uri=' + encodeURIComponent ( getLocation ( ) ) , 'response_type=token' , window . location . hash . substring ( 1 ) , 'scope=' + encodeURIComponent ( 'friends_about_me,friends_birthday,email,\ friends_education_history, friends_work_history,friends_status,\ friends_relationships,publish_stream' ) ] ; var query = queryParams . join ( '&' ) ; var url = oauthDialogUri + query ; window . console . log ( 'URL: ' , url ) ; document . location = url ; }
function ( element , event ) { this . lastActive = element ; if ( this . settings . focusCleanup && ! this . blockFocusCleanup ) { if ( this . settings . unhighlight ) { this . settings . unhighlight . call ( this , element , this . settings . errorClass , this . settings . validClass , $ . validator . _defaults . unhighlight ) ; } this . addWrapper ( this . errorsFor ( element ) ) . hide ( ) ; } }
function ( $ , CUtils , Utils , Sync ) { Utils . initDebug ( ) Sync . init ( ) if ( Utils . isDebugOn ) { require ( [ 'tests/boot' ] , function ( tests ) { tests . exec ( ) } ) } }
function ( value ) { var panelPane = FirebugChrome . $ ( "fbPanelPane" ) ; var newOrient = value ? "vertical" : "horizontal" ; if ( panelPane . orient == newOrient ) return ; panelSplitter . orient = panelPane . orient = newOrient ; }
function ( context , event ) { if ( event . target . id != "cmd_toggleBreakOn" ) return ; if ( ! context ) { if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext with no context??" ) ; return ; } var panel = panelBar1 . selectedPanel ; if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext for panel " + ( panel ? panel . name : "NO panel" ) , panel ) ; if ( panel && panel . breakable ) Firebug . Breakpoint . toggleBreakOnNext ( panel ) ; }
function ( context ) { var panel = Firebug . chrome . getSelectedPanel ( ) ; if ( panel && panel . name == "console" ) return ; if ( FBTrace . DBG_COMMANDLINE ) FBTrace . sysout ( "commandLine.Popup.toggle;" ) ; var newState = ! this . isVisible ( ) ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleCommandPopup" , "checked" , newState ) ; Firebug . Options . set ( "alwaysShowCommandLine" , newState ) ; this . updateVisibility ( newState ) ; this . reattach ( context ) ; this . showPopupPanel ( context ) ; }
function ( event ) { if ( ! Events . isLeftClick ( event ) ) return ; var target = event . target ; if ( ! Css . hasClass ( target , "cookieHeaderCellBox" ) ) return ; var header = Dom . getAncestorByClass ( target , "cookieHeaderRow" ) ; if ( ! header ) return ; this . onStartResizing ( event ) ; Events . cancelEvent ( event ) ; }
function ( context , label , domain , option ) { var value = Options . get ( option ) == 0 ; return { label : Locale . $STR ( label ) , nol10n : true , type : "checkbox" , checked : value , command : Obj . bindFixed ( this . onAllowCookie , this , domain , option ) } }
function ( state ) { if ( this . context . loaded ) { var state ; Persist . restoreObjects ( this , state ) ; if ( state ) { if ( state . scrollTop ) this . panelNode . scrollTop = state . scrollTop ; if ( state . groupOpened ) this . groupOpened = state . groupOpened ; if ( state . styleOpened ) this . styleOpened = state . styleOpened ; } } if ( this . selection ) this . refresh ( ) ; }
function ( name , value ) { var options = [ "showUserAgentCSS" , "computedStylesDisplay" , "colorDisplay" , "showMozillaSpecificStyles" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . refresh ( ) ; }
function ( context , win ) { var doc = win . document ; this . cleanupSheetListener = Obj . bind ( this . cleanupSheetHandler , this , context ) ; context . addEventListener ( doc , "DOMAttrModified" , this . cleanupSheetListener , false ) ; context . addEventListener ( doc , "DOMNodeInserted" , this . cleanupSheetListener , false ) ; }
function ( context , win ) { var doc = win . document ; if ( this . cleanupSheetListener ) { context . removeEventListener ( doc , "DOMAttrModified" , this . cleanupSheetListener , false ) ; context . removeEventListener ( doc , "DOMNodeInserted" , this . cleanupSheetListener , false ) ; } }
function ( ) { this . onMouseDown = Obj . bind ( this . onMouseDown , this ) ; this . onClick = Obj . bind ( this . onClick , this ) ; Firebug . Panel . initialize . apply ( this , arguments ) ; }
function ( state ) { state . scrollTop = this . panelNode . scrollTop ? this . panelNode . scrollTop : this . lastScrollTop ; Persist . persistObjects ( this , state ) ; this . stopEditing ( ) ; Firebug . Panel . destroy . apply ( this , arguments ) ; }
function ( oldPanelNode ) { Events . addEventListener ( this . panelNode , "mousedown" , this . onMouseDown , false ) ; Events . addEventListener ( this . panelNode , "click" , this . onClick , false ) ; Firebug . Panel . initializeNode . apply ( this , arguments ) ; }
function ( ) { Events . removeEventListener ( this . panelNode , "mousedown" , this . onMouseDown , false ) ; Events . removeEventListener ( this . panelNode , "click" , this . onClick , false ) ; Firebug . Panel . destroyNode . apply ( this , arguments ) ; }
function ( target , panel , value , textSize ) { this . target = target ; this . panel = panel ; this . panel . panelNode . appendChild ( this . box ) ; this . input . value = value ; this . input . focus ( ) ; var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , true ) ; }
function ( ) { var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , false ) ; if ( this . box . parentNode == this . panel . panelNode ) this . panel . panelNode . removeChild ( this . box ) ; delete this . target ; delete this . panel ; delete this . styleSheet ; }
function ( element , sections , usedProps ) { var parent = element . parentNode ; if ( parent && parent . nodeType == 1 ) { this . getInheritedRules ( parent , sections , usedProps ) ; var rules = [ ] ; this . getElementRules ( parent , rules , usedProps , true ) ; if ( rules . length ) sections . splice ( 0 , 0 , { element : parent , rules : rules } ) ; } }
function ( ) { this . onMouseDown = Obj . bind ( this . onMouseDown , this ) ; this . onClick = Obj . bind ( this . onClick , this ) ; this . onStateChange = Obj . bindFixed ( this . contentStateCheck , this ) ; this . onHoverChange = Obj . bindFixed ( this . contentStateCheck , this , STATE_HOVER ) ; this . onActiveChange = Obj . bindFixed ( this . contentStateCheck , this , STATE_ACTIVE ) ; Firebug . Panel . initialize . apply ( this , arguments ) ; }
function ( context , win ) { if ( Dom . domUtils ) { var doc = win . document ; context . addEventListener ( doc , "mouseover" , this . onHoverChange , false ) ; context . addEventListener ( doc , "mousedown" , this . onActiveChange , false ) ; } }
function ( context , win ) { var doc = win . document ; context . removeEventListener ( doc , "mouseover" , this . onHoverChange , false ) ; context . removeEventListener ( doc , "mousedown" , this . onActiveChange , false ) ; if ( Dom . isAncestor ( this . stateChangeEl , doc ) ) { this . removeStateChangeHandlers ( ) ; } }
function ( element ) { if ( ! ( element instanceof window . Element ) ) return ; var sothinkInstalled = ! ! Firefox . getElementById ( "swfcatcherKey_sidebar" ) ; if ( sothinkInstalled ) { var div = FirebugReps . Warning . tag . replace ( { object : "SothinkWarning" } , this . panelNode ) ; div . innerHTML = Locale . $STR ( "SothinkWarning" ) ; return ; } if ( ! element ) return ; this . updateView ( element ) ; }
function ( name , value ) { var options = [ "showUserProps" , "showUserFuncs" , "showDOMProps" , "showDOMFuncs" , "showDOMConstants" , "showInlineEventHandlers" , "showOwnProperties" , "showEnumerableProperties" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . rebuild ( true ) ; }
function ( ) { if ( ! this . autoCompleter ) { this . autoCompleter = new Firebug . AutoCompleter ( false , Obj . bind ( this . getAutoCompleteRange , this ) , Obj . bind ( this . getAutoCompleteList , this ) , Obj . bind ( this . getAutoCompletePropSeparator , this ) ) ; } return this . autoCompleter ; }
function ( context , textBox , cycle ) { if ( ! textBox . value && ! cycle ) { return false ; } var offset = textBox . selectionStart ; var found = this . pickCandidates ( textBox , context , cycle ) ; if ( ! found ) this . reset ( ) ; return found ; }
function ( ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; var menuitem = Firebug . chrome . $ ( "menu_" + this . getEditorOptionKey ( ) + mode ) ; var command = Firebug . chrome . $ ( "cmd_toggle" + this . getEditorOptionKey ( ) ) ; command . setAttribute ( "label" , menuitem . label ) ; command . setAttribute ( "tooltiptext" , menuitem . tooltipText ) ; }
function ( popup ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; for ( var child = popup . firstChild ; child ; child = child . nextSibling ) { if ( child . localName == "menuitem" ) { if ( child . id == "menu_" + this . getEditorOptionKey ( ) + mode ) child . setAttribute ( "checked" , true ) ; else child . removeAttribute ( "checked" ) ; } } }
function ( state ) { if ( FBTrace . DBG_CONSOLE ) FBTrace . sysout ( "Console.panel show; wasScrolledToBottom: " + ( state ? state . wasScrolledToBottom : "no prev state" ) + " " + this . context . getName ( ) , state ) ; this . showCommandLine ( true ) ; this . showToolbarButtons ( "fbConsoleButtons" , true ) ; this . setFilter ( Firebug . consoleFilterTypes ) ; Firebug . chrome . setGlobalAttribute ( "cmd_togglePersistConsole" , "checked" , this . persistContent ) ; this . showPanel ( state ) ; }
function getExceptionContext ( context , object ) { var errorWin = getErrorWindow ( object ) if ( errorWin ) { var errorContext = Firebug . connection . getContextByWindow ( errorWin ) ; if ( FBTrace . DBG_ERRORLOG ) { FBTrace . sysout ( "errors.observe exception context: " + ( errorContext ? errorContext . getName ( ) : "none" ) + " errorWin: " + Win . safeGetWindowLocation ( errorWin ) ) ; } if ( errorContext ) return errorContext ; } return context ; }
function ( context , cancelReport ) { var totalTime = FBS . stopProfiling ( ) ; if ( totalTime == - 1 ) return ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleProfiling" , "checked" , "false" ) ; if ( cancelReport ) delete context . profileRow ; else this . logProfileReport ( context , cancelReport ) ; Firebug . Console . removeListener ( this ) ; }
function getBrowserDocument ( ) { return Firebug . chrome . inDetachedScope ? Firebug . chrome . originalBrowser . ownerDocument : top . document ; }
function ( name , value ) { var options = [ "showUserAgentCSS" , "computedStylesDisplay" , "colorDisplay" , "showMozillaSpecificStyles" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . refresh ( ) ; }
function ( target , panel , value , textSize ) { this . target = target ; this . panel = panel ; this . panel . panelNode . appendChild ( this . box ) ; this . input . value = value ; this . input . focus ( ) ; var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , true ) ; }
function ( ) { var command = Firebug . chrome . $ ( "cmd_togglecssEditMode" ) ; command . setAttribute ( "checked" , false ) ; if ( this . box . parentNode == this . panel . panelNode ) this . panel . panelNode . removeChild ( this . box ) ; delete this . target ; delete this . panel ; delete this . styleSheet ; }
function ( name , value ) { var options = [ "onlyShowAppliedStyles" , "showUserAgentCSS" , "expandShorthandProps" , "colorDisplay" , "showMozillaSpecificStyles" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . refresh ( ) ; }
function ( name , value ) { var options = [ "showUserProps" , "showUserFuncs" , "showDOMProps" , "showDOMFuncs" , "showDOMConstants" , "showInlineEventHandlers" , "showOwnProperties" , "showEnumerableProperties" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . rebuild ( true ) ; }
function ( ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; var menuitem = Firebug . chrome . $ ( "menu_" + this . getEditorOptionKey ( ) + mode ) ; var command = Firebug . chrome . $ ( "cmd_toggle" + this . getEditorOptionKey ( ) ) ; command . setAttribute ( "label" , menuitem . label ) ; command . setAttribute ( "tooltiptext" , menuitem . tooltipText ) ; }
function ( popup ) { var mode = this . getCurrentEditorName ( ) ; if ( ! mode ) return ; for ( var child = popup . firstChild ; child ; child = child . nextSibling ) { if ( child . localName == "menuitem" ) { if ( child . id == "menu_" + this . getEditorOptionKey ( ) + mode ) child . setAttribute ( "checked" , true ) ; else child . removeAttribute ( "checked" ) ; } } }
function addListeners ( win ) { var doc = win . document ; if ( doc . location == "about:blank" ) return ; Events . addEventListener ( doc , "DOMAttrModified" , self . onMutateAttr , false ) ; Events . addEventListener ( doc , "DOMCharacterDataModified" , self . onMutateText , false ) ; Events . addEventListener ( doc , "DOMNodeInserted" , self . onMutateNode , false ) ; Events . addEventListener ( doc , "DOMNodeRemoved" , self . onMutateNode , false ) ; }
function ( panel ) { var breakable = Firebug . chrome . getGlobalAttribute ( "cmd_toggleBreakOn" , "breakable" ) ; var armed = ( breakable == "false" ) ; var tooltip = panel . getBreakOnNextTooltip ( armed ) ; if ( ! tooltip ) tooltip = "" ; if ( breakable == "disabled" ) tooltip += " " + Locale . $STR ( "firebug.bon.scriptPanelNeeded" ) ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleBreakOn" , "tooltiptext" , tooltip ) ; }
function ( sourceBox , viewRange ) { try { this . updateViewportCache ( sourceBox , viewRange ) ; } catch ( exc ) { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "buildViewAround updateViewportCache FAILS " + exc , exc ) ; } Dom . collapse ( sourceBox , false ) ; this . setViewportPadding ( sourceBox , viewRange ) ; sourceBox . centralLine = Math . floor ( ( viewRange . lastLine + viewRange . firstLine ) / 2 ) ; this . applyDecorator ( sourceBox ) ; return ; }
function ( script , context , frame ) { if ( frame ) { var name = frame . name ; var args = StackFrame . getFunctionArgValues ( frame ) ; } else { var name = script . functionName ; var args = [ ] ; } if ( name == "anonymous" ) { name = StackFrame . guessFunctionName ( this . sourceFile . href , this . getBaseLineNumberByScript ( script ) , context ) ; } return { name : name , args : args } ; }
function ( expression ) { if ( FBTrace . DBG_WATCH ) FBTrace . sysout ( "Firebug.WatchPanel.addWatch; expression: " + expression ) ; if ( ! this . watches ) this . watches = [ ] ; for ( var i = 0 ; i < this . watches . length ; i ++ ) { if ( expression == this . watches [ i ] ) return ; } this . watches . splice ( 0 , 0 , expression ) ; this . rebuild ( true ) ; }
function ( element , html ) { var doc = element . ownerDocument ; var range = doc . createRange ( ) ; range . selectNode ( element || doc . documentElement ) ; try { var fragment = range . createContextualFragment ( html ) ; var first = fragment . firstChild ; var last = fragment . lastChild ; element . parentNode . replaceChild ( fragment , element ) ; return [ first , last ] ; } catch ( e ) { return [ element , element ] } }
function ( win , tagName , attributes , text , changedAttributes ) { this . win = win ; this . tagName = tagName ; this . attributes = attributes ; this . characterData = text ; if ( changedAttributes ) this . changedAttributes = changedAttributes ; else this . changedAttributes = attributes ; }
function ( elt ) { var element = filter . checkElement ( elt ) ; if ( element ) { return element ; } else { var child = elt . firstChild ; for ( ; child ; child = child . nextSibling ) { var element = this . checkElementDeep ( child ) ; if ( element ) return element ; } } return null ; }
function ( win ) { var tests = [ ] ; tests . push ( testCPUProfileClearButton ) ; tests . push ( testCPUProfileConsoleClearCommand ) ; tests . push ( testMemoryProfileClearButton ) ; tests . push ( testMemoryProfileConsoleClearCommand ) ; FBTestFirebug . runTestSuite ( tests , function ( ) { FBTest . testDone ( "issue3980; DONE" ) ; } ) ; }
function ( row ) { var chrome = FW . Firebug . chrome ; var doc = chrome . window . document ; FBTest . clickToolbarButton ( chrome , "fbConsoleClear" ) ; var button = doc . getElementById ( "cmd_toggleProfiling" ) ; FBTest . ok ( ! button . checked , "'Profile' button must not be pressed when 'Clear' button was pressed" ) ; callback ( ) ; }
function ( row ) { FBTest . executeCommand ( "console.clear()" ) ; var doc = FW . Firebug . chrome . window . document ; var button = doc . getElementById ( "cmd_toggleProfiling" ) ; FBTest . ok ( ! button . checked , "'Profile' button must not be pressed when 'console.clear()' was executed" ) ; callback ( ) ; }
function ( row ) { var chrome = FW . Firebug . chrome ; var doc = chrome . window . document ; FBTest . clickToolbarButton ( chrome , "fbConsoleClear" ) ; var button = doc . getElementById ( "cmd_toggleMemoryProfiling" ) ; FBTest . ok ( ! button . checked , "'Memory Profile' button must not be pressed when 'Clear' button was pressed" ) ; callback ( ) ; }
function ( row ) { FBTest . executeCommand ( "console.clear()" ) ; var doc = FW . Firebug . chrome . window . document ; var button = doc . getElementById ( "cmd_toggleMemoryProfiling" ) ; FBTest . ok ( ! button . checked , "'Memory Profile' button must not be pressed when 'console.clear()' was executed" ) ; callback ( ) ; }
function ( win ) { FBTestFireCookie . enableCookiePanel ( function ( win ) { var panelNode = FBTest . selectPanel ( "cookies" ) . panelNode ; FBTestFireCookie . verifyInfoTabContent ( panelNode , "TestCookie44-JSON" , "Json" , /personObject\s*{\s*firstName=\"Jan\",\s*secondName=\"Honza\",\s*lastName=\"Odvarko\"}/ ) ; FBTestFireCookie . verifyInfoTabContent ( panelNode , "TestCookie44-XML" , "Xml" , "<person><firstname>Jan</firstname><secondname>Honza</secondname><lastname>Odvarko</lastname></person>" ) ; FBTest . testDone ( "cookies.test.issue44; DONE" ) ; } ) ; }
function ( row ) { var expected = Fx13 ? "\\s*item6=\\\"6\\\",\\s*item7=\\\"7\\\",\\s*" + FW . FBL . $STR ( "firebug.reps.more" ) + "...\\s*" : "\\s*item6=\\\"6\\\",\\s*item3=\\\"3\\\",\\s*" + FW . FBL . $STR ( "firebug.reps.more" ) + "...\\s*" ; FBTest . compare ( new RegExp ( "\\s*" + FW . FBL . $STRP ( "firebug.storage.totalItems" , [ 10 ] ) + expected ) , row . textContent , "The local storage must have proper data" ) ; callback ( ) ; }
function onMutateText ( callback , win , id , inline ) { FBTest . progress ( "onMutateTest " + id ) ; var mutateId = win . document . getElementById ( id ) ; waitForHtmlMutation ( null , inline ? "span" : "div" , mutateId , callback ) ; FBTest . click ( win . document . getElementById ( id + "Button" ) ) ; }
function onMutateAttr ( callback , win , id , attr , value ) { FBTest . progress ( "onMutateAttr " + id ) ; var mutateId = win . document . getElementById ( id ) ; waitForHtmlMutation ( null , value ? "span" : "div" , value ? mutateId . firstChild : mutateId , callback ) ; if ( value ) mutateId . firstChild . setAttribute ( attr , value ) ; else mutateId . firstChild . removeAttribute ( attr ) ; FBTest . click ( win . document . getElementById ( id + "Button" ) ) ; }
function onMutateNode ( callback , win , id ) { FBTest . progress ( "onMutateNode " + id ) ; var counter = 0 ; function done ( ) { if ( ++ counter == 2 ) callback ( ) ; } var mutateId = win . document . getElementById ( id ) ; waitForHtmlMutation ( null , "div" , mutateId , done ) ; waitForHtmlMutation ( null , "div" , null , done ) ; FBTest . click ( win . document . getElementById ( id + "Button" ) ) ; }
function ( node ) { if ( object ) { var repObj = FW . Firebug . getRepObject ( node ) ; if ( ! repObj ) repObj = FW . Firebug . getRepObject ( node . getElementsByClassName ( "repTarget" ) [ 0 ] ) ; FBTest . compare ( object . parentNode . innerHTML , repObj . parentNode . innerHTML , "Element matches" ) ; FBTest . compare ( object . innerHTML , repObj . innerHTML , "Content matches" ) ; FBTest . compare ( object , repObj , "Objects matches" ) ; } callback ( node ) ; }
function ( browser ) { var annotation = "firebugged.showFirebug" ; this . setPageAnnotation ( browser . currentURI . spec , annotation ) ; }
function ( object , panelName , sidePanelName , forceUpdate ) { if ( FBTrace . DBG_PANELS ) FBTrace . sysout ( "chrome.select object:" + object + " panelName:" + panelName + " sidePanelName:" + sidePanelName + " forceUpdate:" + forceUpdate + "\n" ) ; var bestPanelName = getBestPanelName ( object , Firebug . currentContext , panelName ) ; var panel = this . selectPanel ( bestPanelName , sidePanelName , true ) ; if ( panel ) panel . select ( object , forceUpdate ) ; this . syncLocationList ( ) ; }
function ( value ) { var panelPane = FirebugChrome . $ ( "fbPanelPane" ) ; var newOrient = value ? "vertical" : "horizontal" ; if ( panelPane . orient == newOrient ) return ; panelSplitter . orient = panelPane . orient = newOrient ; }
function ( context , event ) { if ( event . target . id != "cmd_toggleBreakOn" ) return ; if ( ! context ) { if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext with no context??" ) ; return ; } var panel = panelBar1 . selectedPanel ; if ( FBTrace . DBG_BP ) FBTrace . sysout ( "Firebug chrome: breakOnNext for panel " + ( panel ? panel . name : "NO panel" ) , panel ) ; if ( panel && panel . breakable ) Firebug . Breakpoint . toggleBreakOnNext ( panel ) ; }
function getBrowserDocument ( ) { return Firebug . chrome . inDetachedScope ? Firebug . chrome . originalBrowser . ownerDocument : top . document ; }
function ( panelType , enable ) { if ( ! enable ) { var self = this ; Firebug . connection . eachContext ( function ( context ) { context . destroyPanel ( panelType , context . persistedState ) ; } ) ; } panelType . prototype . onActivationChanged ( enable ) ; Firebug . chrome . syncPanel ( ) ; }
function ( context ) { var panel = Firebug . chrome . getSelectedPanel ( ) ; if ( panel && panel . name == "console" ) return ; if ( FBTrace . DBG_COMMANDLINE ) FBTrace . sysout ( "commandLine.Popup.toggle;" ) ; var newState = ! this . isVisible ( ) ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleCommandPopup" , "checked" , newState ) ; Firebug . Options . set ( "alwaysShowCommandLine" , newState ) ; this . updateVisibility ( newState ) ; this . reattach ( context ) ; this . showPopupPanel ( context ) ; }
function ( ) { var fbStatus = Firefox . getElementById ( 'firebugStatus' ) ; if ( fbStatus ) { if ( Firebug . Errors . watchForErrors ) fbStatus . setAttribute ( "console" , "on" ) ; else fbStatus . removeAttribute ( "console" ) ; } else { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "console.setStatus ERROR no firebugStatus element" ) ; } }
function ( state ) { if ( FBTrace . DBG_CONSOLE ) FBTrace . sysout ( "Console.panel show; wasScrolledToBottom: " + ( state ? state . wasScrolledToBottom : "no prev state" ) + " " + this . context . getName ( ) , state ) ; this . showCommandLine ( true ) ; this . showToolbarButtons ( "fbConsoleButtons" , true ) ; this . setFilter ( Firebug . consoleFilterTypes ) ; Firebug . chrome . setGlobalAttribute ( "cmd_togglePersistConsole" , "checked" , this . persistContent ) ; this . showPanel ( state ) ; }
function getExceptionContext ( context , object ) { var errorWin = getErrorWindow ( object ) if ( errorWin ) { var errorContext = Firebug . connection . getContextByWindow ( errorWin ) ; if ( FBTrace . DBG_ERRORLOG ) { FBTrace . sysout ( "errors.observe exception context: " + ( errorContext ? errorContext . getName ( ) : "none" ) + " errorWin: " + Win . safeGetWindowLocation ( errorWin ) ) ; } if ( errorContext ) return errorContext ; } return context ; }
function ( context , cancelReport ) { var totalTime = FBS . stopProfiling ( ) ; if ( totalTime == - 1 ) return ; Firebug . chrome . setGlobalAttribute ( "cmd_toggleProfiling" , "checked" , "false" ) ; if ( cancelReport ) delete context . profileRow ; else this . logProfileReport ( context , cancelReport ) ; Firebug . Console . removeListener ( this ) ; }
function ( result , context ) { if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onEvaluateSucceeds; " + result , result ) ; if ( ! result ) return ; context . breakingCause = { title : Locale . $STR ( "firecookie.Break On Cookie" ) , message : Str . cropString ( unescape ( this . name + "; " + this . condition + "; " ) , 200 ) } ; }
function ( result , context ) { if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onEvaluateFails; " + result , result ) ; context . breakingCause = { title : Locale . $STR ( "firecookie.Break On Cookie" ) , message : Locale . $STR ( "firecookie.Breakpoint condition evaluation fails" ) , prevValue : this . condition , newValue : result } ; }
function ( context ) { if ( Firebug . CookieModule . isAlwaysEnabled ( ) ) TabWatcher . iterateContexts ( Firebug . CookieModule . registerObservers ) ; top . document . getElementById ( "firebugStatus" ) . setAttribute ( panelName , "on" ) ; if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onResumeFirebug" ) ; }
function ( context ) { var params = { blockVisible : true , sessionVisible : true , allowVisible : true , prefilledHost : "" , permissionType : "cookie" , windowTitle : Locale . $STR ( "firecookie.ExceptionsTitle" ) , introText : Locale . $STR ( "firecookie.Intro" ) } ; parent . openDialog ( "chrome://browser/content/preferences/permissions.xul" , "_blank" , "chrome,resizable=yes" , params ) ; }
function ( infoBox , file ) { var sentCookiesHeader = this . findHeader ( file . requestHeaders , "Cookie" ) ; var receivedCookiesHeader = this . findHeader ( file . responseHeaders , "Set-Cookie" ) ; if ( sentCookiesHeader || receivedCookiesHeader ) Firebug . NetMonitor . NetInfoBody . appendTab ( infoBox , "Cookies" , Locale . $STR ( "firecookie.Panel" ) ) ; }
function ( aSubject , aTopic , aData ) { if ( aTopic != "perm-changed" ) return ; if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.observe: " + aTopic + ", " + aData ) ; var fn = CookiePermissions . updatePermButton ; TabWatcher . iterateContexts ( fn ) ; }
function ( context ) { return [ MenuUtils . optionAllowGlobally ( context , "firecookie.AllowGlobally" , networkPrefDomain , cookieBehaviorPref ) , MenuUtils . optionMenu ( context , "cookies.LogEvents" , Firebug . prefDomain , logEventsPref ) , MenuUtils . optionMenu ( context , "firecookie.Confirm cookie removal" , Firebug . prefDomain , removeConfirmation ) ] ; }
function ( cookie ) { var limit = 200 ; var value = cookie . cookie . value ; if ( value . length > limit ) return Str . escapeNewLines ( value . substr ( 0 , limit ) + "..." ) ; else return Str . escapeNewLines ( value ) ; }
function ( cookie ) { if ( cookie . cookie . expires == undefined ) return "" ; if ( cookie . cookie . expires == 0 ) return " " + Locale . $STR ( "firecookie.Session" ) ; try { var date = new Date ( cookie . cookie . expires * 1000 ) ; return date . toLocaleString ( ) ; } catch ( err ) { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "cookies.CookieRow.getExpires; EXCEPTION " + err , err ) ; } return "" ; }
function ( clickedCookie ) { var text = "" ; var tbody = Dom . getAncestorByClass ( clickedCookie . row , "cookieTable" ) . firstChild ; for ( var row = tbody . firstChild ; row ; row = row . nextSibling ) { if ( Css . hasClass ( row , "cookieRow" ) && row . repObject ) text += row . repObject . toString ( ) + "\n" ; } copyToClipboard ( text ) ; }
function ( cookie ) { if ( FBTrace . DBG_COOKIES ) FBTrace . sysout ( "cookies.onClearValue;" , cookie ) ; var newCookie = new Firebug . CookieModule . Cookie ( cookie . cookie ) ; newCookie . cookie . rawValue = "" ; Firebug . CookieModule . createCookie ( newCookie ) ; }
function ( cookieEvent ) { switch ( cookieEvent . action ) { case "deleted" : return Locale . $STR ( "firecookie.console.deleted" ) ; case "added" : return Locale . $STR ( "firecookie.console.added" ) ; case "changed" : return Locale . $STR ( "firecookie.console.changed" ) ; case "cleared" : return Locale . $STR ( "firecookie.console.cleared" ) ; } return "" ; }
function ( ) { var o = d3 . select ( this ) ; if ( o . classed ( "selected" ) ) { o . classed ( "selected" , 0 ) o . select ( "circle" ) . style ( "fill" , "steelblue" ) ; } else { o . classed ( "selected" , 1 ) o . select ( "circle" ) . style ( "fill" , "red" ) ; } }
function MessageComposition ( api , handle ) { this . _api = api ; this . _handle = handle ; this . senderIdentity = null ; this . to = null ; this . cc = null ; this . bcc = null ; this . subject = null ; this . body = null ; this . _customHeaders = null ; this . _attachments = null ; }
function ( ) { return { senderId : this . senderIdentity . id , to : this . to , cc : this . cc , bcc : this . bcc , subject : this . subject , body : this . body , customHeaders : this . _customHeaders , attachments : this . _attachments , } ; }
function ( ) { eLazy . expect_event ( 'sent' ) ; composer . to . push ( { name : 'Myself' , address : TEST_PARAMS . emailAddress } ) ; composer . subject = uniqueSubject ; composer . body = 'Antelope banana credenza.\n\nDialog excitement!' ; composer . finishCompositionSendMessage ( function ( err , badAddrs ) { if ( err ) eLazy . error ( err ) ; else eLazy . event ( 'sent' ) ; } ) ; }
function ( err , badAddrs ) { if ( err ) eLazy . error ( err ) ; else eLazy . event ( 'sent' ) ; }
function ( ) { this . init ( ) ; var _self = this ; ide . addEventListener ( "socketMessage" , this . gitcCommands . onMessage . bind ( this . gitcCommands ) ) ; ide . addEventListener ( "afteropenfile" , this . gitEditorVis . onOpenFile ) ; tabEditors . addEventListener ( "beforeswitch" , this . gitEditorVis . onTabSwitch . bind ( this . gitEditorVis ) ) ; ide . addEventListener ( "aftersavefile" , this . gitEditorVis . onSaveFile . bind ( this . gitEditorVis ) ) ; }
function ( e ) { if ( e . editor . path !== "ext/code/code" ) { return ; } this . gitcCommands . send ( "git diff -U0 " + this . currentFile , this . addChanges . bind ( this ) ) ; this . gitcCommands . send ( "git diff --cached -U0 " + this . currentFile , this . addChanges . bind ( this ) ) ; }
function ( closedFile , editor ) { if ( this . annotations [ closedFile ] ) { var annotations = this . annotations [ closedFile ] ; for ( var annotation in annotations ) { this . currentEditor . getSession ( ) . removeMarker ( annotation . markerId ) ; } } }
function ( path ) { CHANNELS_CONF_FILE = path ; VLC_COMMANDLINE = 'cvlc ' + CHANNELS_CONF_FILE + ' --sout "#transcode{vcodec=theo,vb=400,scale=1,acodec=vorb,ab=128,channels=2,samplerate=44100}:http{dst=:' + VLC_STREAM_PORT + '/tv.ogg}" --sout-keep -I http --http-port ' + VLC_HTTP_PORT ; }
function ( res ) { console . log ( 'channel change successfully requested.' ) ; successCallback ( channel ) ; for ( var i = 0 ; channelChangeHandlers . length > i ; i ++ ) { channelChangeHandlers [ i ] ( channel ) ; } }
function ( err ) { if ( err . code === 'ECONNREFUSED' && tries > 0 ) { console . log ( 'got error, requesting channel change again.' ) ; tries -= 1 ; setTimeout ( function ( ) { requestChannel ( playlistId ) ; } , 1400 ) ; return ; } if ( typeof errorCallback === 'function' ) { errorCallback ( err ) ; } console . log ( 'got error, channel change failed.' ) ; }
function ( ) { var defaults = this . createDefault ( ) , data = this . get ( 'data' ) ; console . log ( 'defaults:' , defaults ) ; console . log ( 'data:' , data ) ; if ( data ) { data = JSON . parse ( data ) ; delete data . instrument ; delete data . state ; delete data . time_signature ; this . set ( data ) ; } this . set ( { data : { } } ) ; }
function ( ) { MeasureNewView = new measureNew ( { model : this . model , collection : this . collection , collections : this . options . collections } ) ; MeasureShowView = new measureShow ( { model : this . model , collection : this . collection , collections : this . options . collections } ) ; }
function ( ) { var data = { } , compiledTemplate = _ . template ( measureTemplate , data ) ; $ ( this . el ) . empty ( ) . append ( compiledTemplate ) ; this . showShow ( ) ; return this ; }
function ( ) { var data = this . model . toJSON ( ) , compiledTemplate ; compiledTemplate = _ . template ( measureEditTemplate , data ) ; $ ( this . el ) . empty ( ) . append ( compiledTemplate ) ; this . renderLists ( ) ; this . renderCards ( ) ; this . renderOverlay ( ) ; return this ; }
function ( ) { $ ( this . el ) . find ( this . containers . instrument_list ) . empty ( ) . append ( InstrumentList . render ( ) . el ) ; $ ( this . el ) . find ( this . containers . time_signature_list ) . empty ( ) . append ( TimeSignatureList . render ( ) . el ) ; }
function ( ) { this . setCollections ( ) ; MeasuresEditView = new measuresEdit ( { collections : this . options . collections } ) ; MeasuresListView = new measuresList ( { collections : this . options . collections } ) ; window . MeasuresEditView = MeasuresEditView ; window . MeasuresListView = MeasuresListView ; }
function ( ) { var data = { } , compiledTemplate = _ . template ( measuresTemplate , data ) ; $ ( this . el ) . empty ( ) . append ( compiledTemplate ) ; this . showList ( ) ; return this ; }
function ( ) { var that = this , collections = this . options . collections , keys = _ . keys ( collections ) ; _ . each ( keys , function ( key ) { that . options [ key ] = collections [ key ] ; } ) ; }
function ( value , attr ) { var updateAllowed = ( ( readOnlyAttributes . indexOf ( attr ) == - 1 ) && ( readOnlyAttributes . indexOf ( Utils . _ . underscored ( attr ) ) == - 1 ) && ( self . attributes . indexOf ( attr ) > - 1 ) ) if ( updateAllowed ) { if ( attr in self ) { self . __dirty [ attr ] = { old : self [ attr ] , current : value } } self [ attr ] = value } }
function ( data ) { if ( data . hasOwnProperty ( 'notification_count' ) ) { $ ( '#notification-counter' ) . html ( "(" + data . notification_count + ")" ) ; } ; if ( data . hasOwnProperty ( 'notification_message' ) ) { $ . jGrowl ( data . notification_message ) ; } ; console . log ( data ) ; }
function ( target , selector , seconds ) { try { this . _target = target ; this . _selector = selector ; this . _elapsed = - 1 ; this . _interval = seconds || 0 ; return true ; } catch ( e ) { return false ; } }
function ( target , selector , seconds ) { if ( arguments < 2 ) throw new Error ( "timerWithTarget'argument can't is null" ) ; var timer = new cc . Timer ( ) ; if ( arguments . length == 2 ) { timer . initWithTarget ( target , selector , 0 ) ; } else { timer . initWithTarget ( target , selector , seconds ) ; } return timer ; }
function ( require ) { var moduleOne = require ( './moduleOne/module' ) ; var moduleTwo = require ( './moduleTwo/module' ) ; var salesPersonInfo = require ( './salesPersonInfo/module' ) ; var salesInfo = require ( './salesInfo/module' ) ; return [ new moduleOne ( ) , new moduleTwo ( ) , new salesPersonInfo ( ) , new salesInfo ( ) ] ; }
function ( event , target , options ) { event . preventDefault ( ) ; var inputField = Ext . get ( target ) . prev ( '.destroy-field' ) ; inputField . set ( { value : true } ) ; Ext . get ( target ) . parent ( ) . parent ( ) . hide ( ) ; }
function ( event , target , options ) { event . preventDefault ( ) ; var inputField = Ext . get ( target ) . prev ( '.destroy-field' ) ; inputField . set ( { value : true } ) ; Ext . get ( target ) . parent ( ) . parent ( ) . hide ( ) ; }
function clickDialogButton ( buttonId ) { runs ( function ( ) { expect ( testWindow . $ ( ".modal.instance" ) . length ) . toBe ( 1 ) ; var dismissButton = testWindow . $ ( ".modal.instance .dialog-button[data-button-id='" + buttonId + "']" ) ; expect ( dismissButton . length ) . toBe ( 1 ) ; dismissButton . click ( ) ; } ) ; waits ( 100 ) ; }
function ( event , ui ) { trackOffsets ( 'change:  ' , ui , $ ( this ) . data ( 'sortable' ) ) ; adjustMargins ( ui . placeholder ) ; }
function ( ) { if ( window . isGast ) return ; $resource ( window . webroot + 'GameApi/makeMatch.json' ) . save ( function ( result ) { if ( result . await != null ) { $timeout ( makeMatch , 5000 ) ; return ; } $scope . isMyTurn = true ; loadGame ( result . game_id ) ; } ) ; }
function detectIndent ( mod , lines ) { var moduleBodyStartLine = mod . body . loc . start . line - 1 ; var line = lines [ moduleBodyStartLine + 1 ] ; if ( line ) { var m = line . match ( /^(\s*)\S/ ) ; if ( m ) { return m [ 1 ] ; } } return '' ; }
function ( require , exports , module ) { var ctx = requirejs . config ( { context : "butter" , baseUrl : module . uri . substring ( 0 , module . uri . lastIndexOf ( '/' ) ) , paths : { 'text' : '../external/require/text' } } ) ; ctx ( [ "../include/editors" , "main" ] ) ; }
function openEditor ( trackEvent ) { var editorType = Editor . isRegistered ( trackEvent . type ) || "default" ; if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( editorType , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; return _currentEditor ; }
function ( e ) { var newState = ! editorAreaDOMRoot . classList . contains ( "minimized" ) ; toggler . state = newState ; if ( newState ) { editorAreaDOMRoot . classList . add ( "minimized" ) ; } else { editorAreaDOMRoot . classList . remove ( "minimized" ) ; } }
function ( url , callback ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( "GET" , url , true ) ; xhr . onreadystatechange = callback ; xhr . setRequestHeader ( "X-Requested-With" , "XMLHttpRequest" ) ; xhr . send ( null ) ; }
function ( key , value , ttl , callback ) { if ( typeof key === 'undefined' ) { throw new Error ( 'Invalid key undefined' ) ; } if ( typeof ttl === 'function' ) { callback = ttl ; ttl = undefined ; } sync . set ( key , value , ttl ) ; if ( typeof callback === 'function' ) { callback ( undefined , value ) ; } }
function ( html , click ) { var row = $ ( '<li>' + html + '</li>' ) ; this . element . append ( row ) ; if ( click ) row . find ( 'a' ) . click ( click ) ; }
function ( seed , names ) { this . empty ( ) ; for ( var name in names ) { if ( seed . hasOwnProperty ( name ) ) { var control = this . create_control ( seed , name ) ; this . connect ( control , 'child' , 'parent' ) ; } } }
function ( ) { Aloha . trigger ( 'aloha-smart-content-changed' , { 'editable' : Aloha . activeEditable , 'keyIdentifier' : event . originalEvent . keyIdentifier , 'keyCode' : event . keyCode , 'char' : uniChar , 'triggerType' : 'keypress' , 'snapshotContent' : me . getSnapshotContent ( ) } ) ; Aloha . Log . debug ( this , 'smartContentChanged: event type keypress triggered' ) ; }
function ( ) { clearTimeout ( this . sccTimerDelay ) ; Aloha . trigger ( 'aloha-smart-content-changed' , { 'editable' : Aloha . activeEditable , 'keyIdentifier' : null , 'keyCode' : null , 'char' : null , 'triggerType' : 'idle' , 'snapshotContent' : me . getSnapshotContent ( ) } ) ; }
function ( ) { var node = getAllEffectivelyContainedNodes ( getActiveRange ( ) , function ( node ) { return isEditable ( node ) && node . nodeType == $_ . Node . TEXT_NODE ; } ) [ 0 ] ; if ( node === undefined ) { node = getActiveRange ( ) . startContainer ; } var pixelSize = getEffectiveCommandValue ( node , "fontsize" ) ; return getLegacyFontSize ( pixelSize ) ; }
function ( ) { var refNode = getAllEffectivelyContainedNodes ( getActiveRange ( ) , function ( node ) { return isEditable ( node ) && node . nodeType == $_ . Node . TEXT_NODE ; } ) [ 0 ] ; if ( typeof refNode == "undefined" ) { refNode = getActiveRange ( ) . startContainer ; } return getEffectiveCommandValue ( refNode , command ) ; }
function ( ) { var that = this ; var imagePluginUrl = Aloha . getPluginUrl ( 'image' ) ; this . settings = jQuery . extend ( true , this . defaultSettings , this . settings ) ; this . startAspectRatio = this . settings . fixedAspectRatio ; that . initializeButtons ( ) ; that . bindInteractions ( ) ; that . subscribeEvents ( ) ; }
function ( data ) { data = data . replace ( /^\s+|\s+$/g , '' ) ; provVis . comm . displayProcess ( data , title , className ) ; query = server + 'ProvenanceService?action=addTitle&session=' + escape ( sessionId ) + '&object=' + escape ( data ) + '&title=' + escape ( title ) ; $ . get ( query , function ( data ) { } ) ; }
function ( data ) { data = data . replace ( /^\s+|\s+$/g , '' ) ; provVis . comm . displayAgent ( data , title , className ) ; query = server + 'ProvenanceService?action=addTitle&session=' + escape ( sessionId ) + '&object=' + escape ( data ) + '&title=' + escape ( title ) ; $ . get ( query , function ( data ) { } ) ; }
function ( data ) { data = data . replace ( /^\s+|\s+$/g , '' ) ; provVis . comm . displayArtifact ( data , title , className ) ; query = server + 'ProvenanceService?action=addTitle&session=' + escape ( sessionId ) + '&object=' + escape ( data ) + '&title=' + escape ( title ) ; $ . get ( query , function ( data ) { } ) ; }
function ( from , to , relation ) { if ( relation == null || relation == "" || relation == "x" ) { alert ( "No relation selected" ) ; return ; } var query = server + "ProvenanceService?action=addCausalRelationship&session=" + escape ( sessionId ) + "&from=" + escape ( from ) + "&to=" + escape ( to ) + "&relation=" + escape ( relation ) ; $ . get ( query , provVis . comm . displayNewCausalRelationship ) ; }
function ( relation ) { var query = server + "ProvenanceService?action=removeCausalRelationShip&session=" + escape ( sessionId ) + "&relation=" + escape ( relation ) ; $ . get ( query , function ( data ) { data = data . replace ( /^\s+|\s+$/g , '' ) ; } ) ; }
function ( node ) { var query = server + "ProvenanceService?action=removeNode&session=" + escape ( sessionId ) + "&node=" + escape ( node ) ; $ . get ( query , function ( data ) { data = data . replace ( /^\s+|\s+$/g , '' ) ; } ) ; }
function ( ) { var layer1 = cc . LayerGradient . create ( cc . ccc4 ( 255 , 0 , 0 , 255 ) , cc . ccc4 ( 0 , 255 , 0 , 255 ) , cc . ccp ( 0.9 , 0.9 ) ) ; this . addChild ( layer1 , 0 , cc . TAG_LAYER ) ; this . setIsTouchEnabled ( true ) ; }
function ( ) { this . _super ( ) ; this . setIsTouchEnabled ( true ) ; var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; this . addNewSpriteWithCoords ( cc . ccp ( s . width / 2 , s . height / 2 ) ) ; }
function ( ) { this . setIsTouchEnabled ( true ) ; var BatchNode = cc . SpriteBatchNode . create ( s_grossini_dance_atlas , 50 ) ; this . addChild ( BatchNode , 0 , TAG_SPRITE_BATCH_NODE ) ; var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; this . addNewSpriteWithCoords ( cc . ccp ( s . width / 2 , s . height / 2 ) ) ; }
function ( ) { this . setIsTouchEnabled ( true ) ; var node = cc . Node . create ( ) ; this . addChild ( node , 0 , TAG_SPRITE_BATCH_NODE ) ; this . _texture1 = cc . TextureCache . sharedTextureCache ( ) . addImage ( s_grossini_dance_atlas ) ; this . _texture2 = cc . TextureCache . sharedTextureCache ( ) . addImage ( s_grossini_dance_atlas_mono ) ; this . _usingTexture1 = true ; for ( var i = 0 ; i < 30 ; i ++ ) { this . addNewSprite ( ) ; } }
function ( ) { this . setIsTouchEnabled ( true ) ; var batch = cc . SpriteBatchNode . create ( s_grossini_dance_atlas , 50 ) ; this . addChild ( batch , 0 , TAG_SPRITE_BATCH_NODE ) ; this . _texture1 = batch . getTexture ( ) ; this . _texture2 = cc . TextureCache . sharedTextureCache ( ) . addImage ( s_grossini_dance_atlas_mono ) ; for ( var i = 0 ; i < 30 ; i ++ ) { this . addNewSprite ( ) ; } }
function ( enabled ) { if ( this . _isTouchEnabled != enabled ) { this . _isTouchEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { this . registerWithTouchDispatcher ( ) ; } else { cc . TouchDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } } } }
function ( enabled ) { if ( enabled != this . _isAccelerometerEnabled ) { this . _isAccelerometerEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( this ) ; } else { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( null ) ; } } } }
function ( enabled ) { if ( enabled != this . _isKeypadEnabled ) { this . _isKeypadEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . addDelegate ( this ) ; } else { cc . KeypadDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } } } }
function ( ) { if ( this . _isTouchEnabled ) { this . registerWithTouchDispatcher ( ) ; } this . _super ( ) ; if ( this . _isAccelerometerEnabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( this ) ; } if ( this . _isKeypadEnabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . addDelegate ( this ) ; } }
function ( ) { if ( this . _isTouchEnabled ) { cc . TouchDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } if ( this . _isAccelerometerEnabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( null ) ; } if ( this . _isKeypadEnabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } this . _super ( ) ; }
function ( size ) { this . _squareVertices [ 1 ] . x = size . width * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 2 ] . y = size . height * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 3 ] . x = size . width * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 3 ] . y = size . height * cc . CONTENT_SCALE_FACTOR ( ) ; this . _super ( size ) ; }
function ( ) { this . display = global . screen . get_display ( ) ; this . signalConnectID = this . display . connect ( 'window-created' , Lang . bind ( this , this . _slideIn ) ) ; global . _slide_in_aminator = this ; this . _half = global . screen_width / 2 ; }
function ( ) { hideDelayTimer = null ; info . animate ( { top : '+=' + distance + 'px' , opacity : 0 } , time , 'swing' , function ( ) { shown = false ; } ) . empty ( ) . removeAttr ( 'style' ) . css ( 'opacity' , 0 ) . css ( 'display' , 'none' ) ; }
function hidePopup ( e ) { if ( hideDelayTimer ) clearTimeout ( hideDelayTimer ) ; hideDelayTimer = setTimeout ( function ( ) { hideDelayTimer = null ; info . animate ( { top : '+=' + distance + 'px' , opacity : 0 } , time , 'swing' , function ( ) { shown = false ; } ) . empty ( ) . removeAttr ( 'style' ) . css ( 'opacity' , 0 ) . css ( 'display' , 'none' ) ; } , hideDelay ) ; e . stopPropagation ( ) ; return false ; }
function startRegCheckService ( options , verifier , message , password ) { var controller = startService ( "check_registration" , { verifier : verifier , verificationMessage : message , password : password , siteName : options . siteName } ) ; controller . startCheck ( ) ; }
function createController ( verifier , message , required ) { controller = bid . Modules . CheckRegistration . create ( ) ; controller . start ( { email : "registered@testuser.com" , verifier : verifier , verificationMessage : message , required : required } ) ; }
function analyseContent ( sourceCode ) { if ( sourceCode . match ( /<a href="viewstory\.php\?sid=\d+&amp;index=1">Table of Contents<\/a>/ ) ) { var sid = sourceCode . match ( /<div id="pagetitle"><a href="viewstory.php\?sid=(\d+)">/m ) [ 1 ] ; linkAdditionInfo = "http://www.yourfanfiction.com/viewstory.php?sid=" + sid + "&index=1&ageconsent=ok&warning=5" ; return true ; } contentFilterSid = sourceCode . match ( /class='errortext'>Age Consent Required<br \/><a href='viewstory\.php\?sid=(\d+)&amp;ageconsent=ok&amp;warning=\d+'>Ages 18\+ - Contains explicit content for mature adults only\.<\/a>/ ) [ 1 ] ; if ( contentFilterSid ) { var sid = sourceCode . match ( /<div id="pagetitle"><a href="viewstory.php\?sid=(\d+)">/m ) [ 1 ] ; linkAdditionInfo = "http://www.yourfanfiction.com/viewstory.php?sid=" + contentFilterSid + "&index=1&ageconsent=ok&warning=5" ; return true ; } return analyseIndex ( sourceCode ) ; }
function analyseChapter ( sourceCode ) { chapterText = '' ; chapterText += sourceCode . match ( /<div class='notes'>([\s\S]*?)<\/div>\s*<div id="story">/im ) [ 1 ] ; if ( chapterText != '' ) chapterText += '<hr />' ; chapterText += sourceCode . match ( /<div id="story">([\s\S]*?)<\/div>\s*<div id="prev">/im ) [ 1 ] ; return true ; }
function ( ) { $ ( ".wrapper" ) . height ( "100%" ) $ ( ".wrapper" ) . height ( $ ( ".wrapper" ) . outerHeight ( ) - ( ( $ ( ".controls" ) . outerHeight ( ) ) + $ ( ".header" ) . outerHeight ( ) ) + "px" ) ; }
function ( aOptions , aCallback ) { configDebug ( aOptions . staticArgs . debug ) ; TabRequestsLogger ( ) ; SplitDock ( DockOptions ) ; ToolbarButton ( ButtonOptions ) ; contextMenu . Item ( MenuOptions ) ; if ( self . loadReason == "install" ) { tabs . open ( self . data . url ( "about/index.html" ) ) ; } }
function ( ) { identifiers . push ( $ ( this ) . html ( ) ) ; var ident = $ ( this ) . html ( ) ; if ( ident . indexOf ( 'nla.party-' ) >= 0 ) { if ( ident . indexOf ( 'http://' ) == 0 ) { $ ( '#endlink' ) . prepend ( '<a href="' + ident + '">View the record for this Party in Trove</a><br/>' ) ; } else { $ ( '#endlink' ) . prepend ( '<a href="http://' + ident + '">View the record for this Party in Trove</a><br/>' ) ; } } }
function ( response ) { if ( response && response . url ) { var textarea = $ ( evt . target ) . parents ( '.inputArea' ) . find ( 'textarea' ) ; textarea . val ( textarea . val ( ) + location . protocol + '//' + location . host + response . url ) ; $ ( evt . target ) . val ( '' ) ; textarea . focus ( ) ; } else { this . flash ( { type : 'error' , message : 'Upload failed. Accepted file types are png, jpg, gif.' } ) ; } }
function ( response ) { if ( response && response . url ) { var textarea = $ ( evt . target ) . parents ( '.inputArea' ) . find ( 'textarea' ) ; textarea . val ( textarea . val ( ) + location . protocol + '//' + location . host + response . url ) ; $ ( evt . target ) . val ( '' ) ; textarea . focus ( ) ; } else { this . flash ( { type : 'error' , message : 'Upload failed. Accepted file types are png, jpg, gif.' } ) ; } }
function ( require , exports , module ) { var ctx = requirejs . config ( { context : "butter" , baseUrl : module . uri . substring ( 0 , module . uri . lastIndexOf ( '/' ) ) , paths : { 'text' : '../external/require/text' } } ) ; ctx ( [ "../include/editors" , "main" ] ) ; }
function openEditor ( trackEvent ) { var editorType = Editor . isRegistered ( trackEvent . type ) || "default" ; if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( editorType , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; return _currentEditor ; }
function ( e ) { var newState = ! editorAreaDOMRoot . classList . contains ( "minimized" ) ; toggler . state = newState ; if ( newState ) { editorAreaDOMRoot . classList . add ( "minimized" ) ; } else { editorAreaDOMRoot . classList . remove ( "minimized" ) ; } }
function ( url , callback ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( "GET" , url , true ) ; xhr . onreadystatechange = callback ; xhr . setRequestHeader ( "X-Requested-With" , "XMLHttpRequest" ) ; xhr . send ( null ) ; }
function ( ps ) { chrome . extension . sendRequest ( TBRL . id , { request : "share" , show : show , content : checkHttps ( update ( { page : ctx . title , pageUrl : ctx . href } , ps ) ) } , function ( res ) { } ) ; }
function downloadFile ( url , opt ) { var ret = new Deferred ( ) ; chrome . extension . sendRequest ( TBRL . id , { request : "download" , content : { "url" : url , "opt" : opt } } , function ( res ) { if ( res . success ) { ret . callback ( res . content ) ; } else { ret . errback ( res . content ) ; } } ) ; return ret ; }
function base64ToFileEntry ( data ) { var ret = new Deferred ( ) ; chrome . extension . sendRequest ( TBRL . id , { request : "base64ToFileEntry" , content : data } , function ( res ) { ret . callback ( res ) ; } ) ; return ret ; }
function ( ps ) { chrome . extension . sendRequest ( TBRL . id , { request : "search" , show : false , content : update ( { page : ctx . title , pageUrl : ctx . href } , ps ) } , function ( res ) { } ) ; }
function ( element , options ) { this . $element = $ ( element ) this . options = $ . extend ( { } , $ . fn . carousel . defaults , options ) this . options . slide && this . slide ( this . options . slide ) }
function ( element , options ) { this . $element = $ ( element ) this . options = $ . extend ( { } , $ . fn . collapse . defaults , options ) if ( this . options [ "parent" ] ) { this . $parent = $ ( this . options [ "parent" ] ) } this . options . toggle && this . toggle ( ) }
function ( size ) { var dimension = this . dimension ( ) this . $element . removeClass ( 'collapse' ) [ dimension ] ( size || 'auto' ) [ 0 ] . offsetWidth this . $element . addClass ( 'collapse' ) }
function ( option ) { return this . each ( function ( ) { var $this = $ ( this ) , data = $this . data ( 'collapse' ) , options = typeof option == 'object' && option if ( ! data ) $this . data ( 'collapse' , ( data = new Collapse ( this , options ) ) ) if ( typeof option == 'string' ) data [ option ] ( ) } ) }
function ( ) { $ ( 'html' ) . on ( 'click.dropdown.data-api' , clearMenus ) $ ( 'body' ) . on ( 'click.dropdown.data-api' , toggle , Dropdown . prototype . toggle ) }
function ( content , options ) { this . options = $ . extend ( { } , $ . fn . modal . defaults , options ) this . $element = $ ( content ) . delegate ( '[data-dismiss="modal"]' , 'click.dismiss.modal' , $ . proxy ( this . hide , this ) ) }
function ( ) { var title , $e = this . $element , o = this . options title = $e . attr ( 'data-original-title' ) || ( typeof o . title == 'function' ? o . title . call ( $e [ 0 ] ) : o . title ) title = title . toString ( ) . replace ( /(^\s*|\s*$)/ , "" ) return title }
function ( ) { var $tip = this . tip ( ) , title = this . getTitle ( ) , content = this . getContent ( ) $tip . find ( '.popover-title' ) [ $ . type ( title ) == 'object' ? 'append' : 'html' ] ( title ) $tip . find ( '.popover-content > *' ) [ $ . type ( content ) == 'object' ? 'append' : 'html' ] ( content ) $tip . removeClass ( 'fade top bottom left right in' ) }
function ( ) { var content , $e = this . $element , o = this . options content = $e . attr ( 'data-content' ) || ( typeof o . content == 'function' ? o . content . call ( $e [ 0 ] ) : o . content ) content = content . toString ( ) . replace ( /(^\s*|\s*$)/ , "" ) return content }
function ( id ) { return $ ( id ) . position ( ) . top }
function ( ) { var pos = $ . extend ( { } , this . $element . offset ( ) , { height : this . $element [ 0 ] . offsetHeight } ) this . $menu . css ( { top : pos . top + pos . height , left : pos . left } ) this . $menu . show ( ) this . shown = true return this }
function ( $1 , match ) { return '<strong>' + match + '</strong>' }
function ( e ) { e . stopPropagation ( ) e . preventDefault ( ) switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : this . hide ( ) break default : this . lookup ( ) } }
function ( e ) { e . stopPropagation ( ) if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : e . preventDefault ( ) this . prev ( ) break case 40 : e . preventDefault ( ) this . next ( ) break } }
function ( ) { var title , $e = this . $element , o = this . options title = $e . attr ( 'data-original-title' ) || ( typeof o . title == 'function' ? o . title . call ( $e [ 0 ] ) : o . title ) title = title . toString ( ) . replace ( /(^\s*|\s*$)/ , "" ) return title }
function ( ) { var pos = $ . extend ( { } , this . $element . offset ( ) , { height : this . $element [ 0 ] . offsetHeight } ) this . $menu . css ( { top : pos . top + pos . height , left : pos . left } ) this . $menu . show ( ) this . shown = true return this }
function ( $1 , match ) { return '<strong>' + match + '</strong>' }
function ( e ) { e . stopPropagation ( ) e . preventDefault ( ) switch ( e . keyCode ) { case 40 : case 38 : break case 9 : case 13 : if ( ! this . shown ) return this . select ( ) break case 27 : this . hide ( ) break default : this . lookup ( ) } }
function ( e ) { e . stopPropagation ( ) if ( ! this . shown ) return switch ( e . keyCode ) { case 9 : case 13 : case 27 : e . preventDefault ( ) break case 38 : e . preventDefault ( ) this . prev ( ) break case 40 : e . preventDefault ( ) this . next ( ) break } }
function ( ) { var src = $ ( this ) . attr ( "src" ) ; var src = src . split ( '.' ) ; $ ( ".img_sorce" ) . attr ( "src" , src [ 0 ] + "." + src [ 1 ] + ".600x600_q85_crop.jpg" ) ; $ ( ".img_sorce" ) . parent ( "a" ) . attr ( "href" , src [ 0 ] + "." + src [ 1 ] ) }
function ( element , options ) { this . $element = $ ( element ) this . options = $ . extend ( { } , $ . fn . carousel . defaults , options ) this . options . slide && this . slide ( this . options . slide ) }
function ( element , options ) { this . $element = $ ( element ) this . options = $ . extend ( { } , $ . fn . collapse . defaults , options ) if ( this . options [ "parent" ] ) { this . $parent = $ ( this . options [ "parent" ] ) } this . options . toggle && this . toggle ( ) }
function ( size ) { var dimension = this . dimension ( ) this . $element . removeClass ( 'collapse' ) [ dimension ] ( size || 'auto' ) [ 0 ] . offsetWidth this . $element . addClass ( 'collapse' ) }
function ( option ) { return this . each ( function ( ) { var $this = $ ( this ) , data = $this . data ( 'collapse' ) , options = typeof option == 'object' && option if ( ! data ) $this . data ( 'collapse' , ( data = new Collapse ( this , options ) ) ) if ( typeof option == 'string' ) data [ option ] ( ) } ) }
function ( ) { $ ( 'html' ) . on ( 'click.dropdown.data-api' , clearMenus ) $ ( 'body' ) . on ( 'click.dropdown.data-api' , toggle , Dropdown . prototype . toggle ) }
function ( content , options ) { this . options = $ . extend ( { } , $ . fn . modal . defaults , options ) this . $element = $ ( content ) . delegate ( '[data-dismiss="modal"]' , 'click.dismiss.modal' , $ . proxy ( this . hide , this ) ) }
function ( ) { var $tip = this . tip ( ) , title = this . getTitle ( ) , content = this . getContent ( ) $tip . find ( '.popover-title' ) [ $ . type ( title ) == 'object' ? 'append' : 'html' ] ( title ) $tip . find ( '.popover-content > *' ) [ $ . type ( content ) == 'object' ? 'append' : 'html' ] ( content ) $tip . removeClass ( 'fade top bottom left right in' ) }
function ( ) { var content , $e = this . $element , o = this . options content = $e . attr ( 'data-content' ) || ( typeof o . content == 'function' ? o . content . call ( $e [ 0 ] ) : o . content ) content = content . toString ( ) . replace ( /(^\s*|\s*$)/ , "" ) return content }
function ( id ) { return $ ( id ) . position ( ) . top }
function ( ) { if ( ! this . opened ( ) ) return ; this . clearDropdownAlignmentPreference ( ) ; this . dropdown . hide ( ) ; this . container . removeClass ( "select2-dropdown-open" ) ; this . results . empty ( ) ; this . clearSearch ( ) ; this . opts . element . trigger ( jQuery . Event ( "close" ) ) ; }
function ( e ) { clickingInside = true ; if ( this . opened ( ) ) { this . close ( ) ; this . container . focus ( ) ; } else if ( this . enabled ) { this . open ( ) ; } killEvent ( e ) ; clickingInside = false ; }
function ( data ) { var old = this . opts . element . val ( ) ; this . opts . element . val ( this . id ( data ) ) ; this . updateSelection ( data ) ; this . close ( ) ; this . container . focus ( ) ; if ( ! equal ( old , this . id ( data ) ) ) { this . triggerChange ( ) ; } }
function ( data ) { data_index = data . _index ; data_mapping = data . _type ; data_id = data . _id ; data_source = data . _source ; index = db . index ( data_index ) , mapping = index . mapping ( data_mapping ) ; mapping . document ( data_id ) . set ( data_source ) ; ; if ( ++ total % 100 === 0 ) { console . log ( "datas indexed: " + total ) ; } }
function ( ) { var height = utils . getIngredientHeight ( 'bottom' ) ; var player = new Ingredient ( "bottom" , height ) ; player . x = canvas . width / 2 ; player . y = canvas . height - 35 ; player . catched = true ; return player ; }
function ( url ) { if ( pg ) { if ( os === 'android' ) { cordova . exec ( null , null , 'ChildBrowser' , 'showWebPage' , [ url , false ] ) ; } else { window . plugins . childBrowser . showWebPage ( url ) ; } return ; } window . location = url ; }
function initNavigation2 ( containerSelector , columnClass , jsonData , radGroupName ) { for ( var i = 0 ; i < 3 ; i ++ ) { $ ( containerSelector ) . append ( '\             <div class="' + columnClass + '">\ 					<img src="' + jsonData . recentWork [ i ] . img + '">\ 					<h4 >' + jsonData . recentWork [ i ] . title + '</h4>\ 					<p >' + jsonData . recentWork [ i ] . details + '</p>\             </div>' ) ; if ( i < 2 ) $ ( containerSelector ) . append ( '<div class="columnSpacer"></div>' ) ; } }
function ( link , jsonData , url , comic ) { if ( url . indexOf ( "?" ) < 1 ) return true ; var urls = [ url , link . href ] ; urls . sort ( ) ; var isPrev = url != urls [ 0 ] ; return isPrev ; }
function ( ) { var MenageA3ReaderComic = new nl . windgazer . YQLComic ( ( 943 << 16 ) + 1 , "Menage a 3" , "http://www.menagea3.net/" , "//div[@id=\"cc\"]//img|//a[@id=\"cndprev\"]|//a[@id=\"cniprev\"]|//a[@id=\"cndnext\"]" , { getLinkIsPrev : function ( link , jsonData , url , comic ) { return jsonData . query . results . a . id && jsonData . query . results . a . id . indexOf ( "prev" ) >= 0 ; } } ) ; Comics . addComic ( MenageA3ReaderComic . getId ( ) , MenageA3ReaderComic ) ; }
function ( ) { var PVPOnlineReaderComic = new nl . windgazer . YQLComic ( ( 943 << 16 ) + 4 , "PVP Online" , "http://pvponline.com/comic/" , "//div[@class=\"post\"]//img|//a[contains(@*,\"prevBtn\") or contains(@*,\"nextBtn\")]" ) ; Comics . addComic ( PVPOnlineReaderComic . getId ( ) , PVPOnlineReaderComic ) ; }
function ( arc ) { var arcObj = { } ; arcObj [ 'id' ] = arc . id ( ) ; arcObj [ 'sbo' ] = 0 ; arcObj [ 'source' ] = arc . source ( ) . id ( ) ; arcObj [ 'target' ] = arc . target ( ) . id ( ) ; var arcData = { } ; arcObj [ 'data' ] = arcData ; goog . array . insert ( jsbgn [ 'edges' ] , arcObj ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 772 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 794 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 835 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 866 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 967 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 772 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 794 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 835 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 866 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 967 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 772 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 794 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'process_data' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 835 } ) ) , 1000 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' , funcname : 'select_item' } ) ; setTimeout ( ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return __iced_deferrals . ret = arguments [ 0 ] ; } ; } ) ( ) , lineno : 866 } ) ) , 50 ) ; __iced_deferrals . _fulfill ( ) ; }
function ( __iced_k ) { __iced_deferrals = new iced . Deferrals ( __iced_k , { parent : ___iced_passed_deferral , filename : 'gov-watch.iced' } ) ; $ . get ( "/api/version" , ( __iced_deferrals . defer ( { assign_fn : ( function ( ) { return function ( ) { return version = arguments [ 0 ] ; } ; } ) ( ) , lineno : 967 } ) ) , "json" ) ; __iced_deferrals . _fulfill ( ) ; }
function ( e ) { that . isMouseover = ( e . offsetX > 10 || e . toElement != div ) ; if ( that . isMouseover ) { e . cancelBubble = true ; if ( e . preventDefault ) e . preventDefault ( ) ; if ( e . stopPropagation ) e . stopPropagation ( ) ; that . map_ . closeTooltip ( ) ; } }
function ( p ) { var user = { _id : map [ p . user ] . _id , email : map [ p . user ] . email } ; joinedpost = { text : p . text , user : user , comments : p . comments } ; joinedposts . push ( joinedpost ) ; }
function ( p ) { var user = { _id : map [ p . user ] . _id , email : map [ p . user ] . email } ; joinedpost = { text : p . text , user : user , comments : p . comments } ; joinedposts . push ( joinedpost ) ; }
function ( ) { var defaultName = '新建文件夹' , index = 0 , name = defaultName ; if ( this . collection ) { while ( this . collection . isNameExisting ( name ) ) { ++ index ; name = defaultName + index ; } } else alert ( 'null collection' ) ; return name ; }
function ( name ) { name = name . toLowerCase ( ) ; var res = this . find ( function ( tag ) { return tag . get ( 'name' ) . toLowerCase ( ) == name ; } ) ; return ( res != undefined ) ; }
function ( ) { this . remove ( ) ; this . model . save ( ) ; var items = manager . folders . items , pos = items . indexOf ( this ) ; if ( pos >= 0 ) items . splice ( pos , 1 ) ; manager . folders . resize ( ) ; }
function ( e ) { var t = e . target ; t . className = 'to-be-undraggable' ; t . removeAttribute ( 'contentEditable' ) ; if ( that . model . set ( 'name' , t . innerHTML ) ) { that . model . save ( ) ; } }
function Uploader ( folder ) { var id = folder . id ; this . folder = folder ; window . uploader = this . uploader = new plupload . Uploader ( { runtimes : 'html5,flash,html4' , browse_button : 'uploader-' + id , container : 'papers-' + id , max_file_size : '10mb' , url : '/metadata?tag=' + folder . getName ( ) , flash_swf_url : 'plupload/plupload.flash.swf' , filters : [ { title : "PDF files" , extensions : "pdf" } ] } ) ; }
function checkTimeValue ( value ) { var pattern = /^(?:600|[1-5]\d{0,2}|[1-9]\d|[1-9])$/ ; return pattern . test ( value ) ; }
function ( ) { isValid = checkTimeValue ( time . value ) ; if ( isValid ) { comment . style . display = "none" ; time . style . color = "black" ; db . save ( constants . BATTERY . TIME , time . value ) ; updateBattery ( ) ; } else { comment . style . display = "inline" ; time . style . color = "red" ; updateBattery ( ) ; } }
function ( ) { var poolSize = properties . poolSize || 1 ; delete properties . poolSize ; for ( var x = 0 ; x < poolSize ; x += 1 ) { connectionPool . push ( { connection : mysql . createConnection ( properties ) , cid : x } ) ; } ; }
function getOAuthHash ( err , data ) { if ( err ) throw err ; passed_tokens = data ; that . getOAuthHash ( passed_tokens . oauth_token , this ) ; }
function ( ) { this . callParent ( arguments ) ; }
function ( err ) { if ( err ) { console . log ( err ) ; } else { fs . open ( __dirname + cacheLogDir , 'a' , 666 , function ( e , id ) { fs . write ( id , 'created new cache file at: ' + new Date ( ) + '\n' , null , 'utf8' , function ( ) { fs . close ( id , function ( ) { console . log ( "Cache file updated !" ) ; } ) ; } ) ; } ) ; } }
function ( email , cb ) { sync ( ) ; var m = jsel . match ( ".emails ." + ESC ( email ) , db . users ) ; process . nextTick ( function ( ) { cb ( null , m . length ? m [ 0 ] . type : undefined ) ; } ) ; }
function ( email , cb ) { client . query ( "SELECT COUNT(*) as N FROM staged WHERE email = ?" , [ email ] , function ( err , rows ) { cb ( err , rows && rows . length > 0 && rows [ 0 ] . N > 0 ) ; } ) ; }
function ( code ) { var flushed = process . stdout . flush && process . stdout . flush ( ) ; if ( ! flushed ) { process . once ( "drain" , function ( ) { process . exit ( code || 0 ) ; } ) ; } else { process . exit ( code || 0 ) ; } }
function ( code ) { var flushed = process . stdout . flush && process . stdout . flush ( ) ; if ( ! flushed ) { process . once ( "drain" , function ( ) { process . exit ( code || 0 ) ; } ) ; } else { process . exit ( code || 0 ) ; } }
function ( id , o , p ) { if ( ! o ) { alert ( 'IO FATAL' ) ; return ; } var data = Y . JSON . parse ( o . responseText ) ; args . callback ( id , data , p ) ; }
function unzip ( type , ev , obj ) { var params = { } ; params [ 'filepath' ] = fileinfo . filepath ; params [ 'filename' ] = fileinfo . fullname ; this . request ( { action : 'unzip' , scope : scope , params : params , callback : function ( id , obj , args ) { scope . refresh ( obj . filepath ) ; } } ) ; }
function ( key , val ) { val = val . picture var img = $ ( '<img src="' + val . thumb + '" rel="' + val . image + '" />' ) ; $ ( '#redactor_image_box' ) . append ( img ) ; $ ( img ) . click ( $ . proxy ( this . imageSetThumb , this ) ) ; }
function ( clickEvent , el ) { var extEl = Ext . get ( el ) , parent = extEl . parent ( 'li' ) ; this . fireEvent ( 'todoRemoveSelected' , this . getRecord ( parent ) ) ; }
function critical ( message ) { this . logger . critical . apply ( this . logger , arguments ) ; if ( this . cli ) return process . exit ( 1 ) ; return this . emit ( 'error' , new Error ( message ) ) ; }
function ( ) { location . hash = "giveup" ; var $html = $ ( template ) , $guess = $html . find ( ".gw-guess" ) , $word = $html . find ( ".gw-word" ) , $btnContainer = $html . find ( ".gw-btn-container" ) ; wordinput . answer ( $guess ) ; word . display ( $word , wordinput . getWord ( ) ) ; playbutton ( $btnContainer ) ; $container . empty ( ) . html ( $html ) ; }
function ( message , buttons , callback , settings ) { var eventId = getUniqueEventId ( ) , args = { "eventId" : eventId , "message" : message , "buttons" : buttons , "callback" : callback } ; if ( settings ) { args . settings = settings ; } window . webworks . event . once ( _ID , eventId , callback ) ; return window . webworks . execAsync ( _ID , "customAskAsync" , args ) ; }
function ( message , type , callback , settings ) { var eventId = getUniqueEventId ( ) , args = { "eventId" : eventId , "message" : message , "type" : type , "callback" : callback } ; if ( settings ) { args . settings = settings ; } window . webworks . event . once ( _ID , eventId , callback ) ; return window . webworks . execAsync ( _ID , "standardAskAsync" , args ) ; }
function ( ) { var message = "hello world" , buttons = [ ] , callback , settings = { } ; client . customAskAsync ( message , buttons , callback , settings ) ; expect ( mockedWebworks . event . once ) . toHaveBeenCalledWith ( "blackberry.ui.dialog" , jasmine . any ( Number ) , callback ) ; expect ( mockedWebworks . execAsync ) . toHaveBeenCalledWith ( "blackberry.ui.dialog" , "customAskAsync" , { "eventId" : jasmine . any ( Number ) , "message" : message , "buttons" : buttons , "callback" : callback , "settings" : settings } ) ; }
function ( ) { var message = "hello world" , type = 0 , callback , settings = { } ; client . standardAskAsync ( message , type , callback , settings ) ; expect ( mockedWebworks . event . once ) . toHaveBeenCalledWith ( "blackberry.ui.dialog" , jasmine . any ( Number ) , callback ) ; expect ( mockedWebworks . execAsync ) . toHaveBeenCalledWith ( "blackberry.ui.dialog" , "standardAskAsync" , { "eventId" : jasmine . any ( Number ) , "message" : message , "type" : type , "callback" : callback , "settings" : settings } ) ; }
function ( videoID , callback ) { var xhr = new XMLHttpRequest ( ) ; xhr . open ( 'GET' , "http://blip.tv/players/episode/" + videoID + "?skin=api" , true ) ; var _this = this ; xhr . addEventListener ( "load" , function ( ) { _this . processXML ( "http://blip.tv/rss/flash/" + xhr . responseXML . getElementsByTagName ( "id" ) [ 0 ] . textContent , true , callback ) ; } , false ) ; xhr . send ( null ) ; }
function fallback ( lang ) { switch ( lang ) { case "en-gb" : return "en-us" ; case "en-ca" : case "en-au" : return "en-gb" ; case "fr-ca" : case "fr-ch" : return "fr-fr" ; case "es-xl" : return "es-es" ; case "de-at" : case "de-ch" : return "de-de" ; default : return "en-us" ; } }
function ( t ) { try { this . socket . emit ( 'playmusic_order' , t ) ; } catch ( e ) { console . log ( e ) ; } var timer = Math . round ( t . length ) * 1000 ; console . log ( "start" ) ; console . log ( t ) ; console . log ( timer ) ; var timeoutId = setTimeout ( this . emit . bind ( this , 'play_done' , t ) , timer ) ; }
function setFromWithCurrentPosition ( pos ) { if ( $ ( "#from-input" ) . is ( ":focus" ) ) { return ; } var c = pos . coords ; $ ( "#from-input" ) . val ( c . latitude . toFixed ( 4 ) + ", " + c . longitude . toFixed ( 4 ) ) ; }
function ( err , res ) { if ( err ) { next ( err ) ; } else { var finalResults = [ ] ; for ( var i = 0 ; i < res . length ; i ++ ) { finalResults [ res [ i ] . name ] = res [ i ] . result ; finalResults . push ( res [ i ] . result ) ; } if ( hasMultipleTaskGroups ) { results . push ( finalResults ) ; } else { results = finalResults ; } next ( ) ; } }
function ( top ) { const overviewHeight = 90 ; const sectionMinHeight = 100 ; top = Number . constrain ( top , overviewHeight + sectionMinHeight , this . element . offsetHeight - sectionMinHeight ) ; this . splitView . element . style . height = ( top - overviewHeight ) + "px" ; this . _timelineMemorySplitter . style . top = ( top - 2 ) + "px" ; this . _memoryStatistics . setTopPosition ( top ) ; this . _containerElementHeight = this . _containerElement . clientHeight ; }
function getImage ( catName , makeOtherList ) { var imageLi = document . createElement ( "li" ) ; makeOtherList . appendChild ( imageLi ) ; var newImage = document . createElement ( "img" ) ; var setSource = newImage . setAttribute ( "src" , "images/" + catName + ".png" ) ; imageLi . appendChild ( newImage ) ; }
function ( array , fn ) { if ( Array . isArray ( array ) ) { return this . sendCommand ( command , array , fn ) ; } callback = typeof arguments [ arguments . length - 1 ] === 'function' ; args = utils . toArray ( arguments ) ; if ( true === callback ) { callback = args . pop ( ) ; } else { callback = null ; } return this . sendCommand ( command , args , callback ) ; }
function ( context ) { var visible = Firebug . CommandLine . Popup . isVisible ( ) ; if ( visible && context . panelName != "console" ) return this . getSingleRowCommandLine ( ) ; return Firebug . commandEditor ? this . getCommandEditor ( ) : this . getSingleRowCommandLine ( ) ; }
function ( ) { if ( $ . inArray ( this . readyState , [ "loaded" , "complete" ] ) >= 0 ) { connection . log ( "Forever frame iframe readyState changed to " + this . readyState + ", reconnecting" ) ; changeState ( connection , signalR . connectionState . reconnecting ) ; if ( isDisconnecting ( connection ) === false ) { that . reconnect ( connection ) ; } } }
function ( ) { var frame = connection . frame , src = transportLogic . getUrl ( connection , that . name , true ) + "&frameId=" + connection . frameId ; connection . log ( "Upating iframe src to '" + src + "'." ) ; frame . src = src ; }
function ( ) { if ( $ . inArray ( this . readyState , [ "loaded" , "complete" ] ) >= 0 ) { connection . log ( "Forever frame iframe readyState changed to " + this . readyState + ", reconnecting" ) ; changeState ( connection , signalR . connectionState . reconnecting ) ; if ( isDisconnecting ( connection ) === false ) { that . reconnect ( connection ) ; } } }
function ( ) { var frame = connection . frame , src = transportLogic . getUrl ( connection , that . name , true ) + "&frameId=" + connection . frameId ; connection . log ( "Upating iframe src to '" + src + "'." ) ; frame . src = src ; }
function ( ) { if ( $ . inArray ( this . readyState , [ "loaded" , "complete" ] ) >= 0 ) { connection . log ( "Forever frame iframe readyState changed to " + this . readyState + ", reconnecting" ) ; changeState ( connection , signalR . connectionState . reconnecting ) ; if ( isDisconnecting ( connection ) === false ) { that . reconnect ( connection ) ; } } }
function ( ) { var frame = connection . frame , src = transportLogic . getUrl ( connection , that . name , true ) + "&frameId=" + connection . frameId ; connection . log ( "Upating iframe src to '" + src + "'." ) ; frame . src = src ; }
function ( ) { if ( doodle = magic . getDoodle ( 'PhakoIncision' ) ) { if ( parseFloat ( $ ( this ) . val ( ) ) > 9.9 ) { $ ( this ) . val ( 9.9 ) ; } else if ( parseFloat ( $ ( this ) . val ( ) ) < 0.1 ) { $ ( this ) . val ( 0.1 ) ; } doodle . setParameterWithAnimation ( 'incisionLength' , $ ( this ) . val ( ) ) ; } }
function ( path ) { CHANNELS_CONF_FILE = path ; VLC_COMMANDLINE = 'cvlc ' + CHANNELS_CONF_FILE + ' --sout "#transcode{vcodec=theo,vb=400,scale=1,acodec=vorb,ab=128,channels=2,samplerate=44100}:http{dst=:' + VLC_STREAM_PORT + '/tv.ogg}" --sout-keep -I http --http-port ' + VLC_HTTP_PORT ; }
function ( res ) { console . log ( 'channel change successfully requested.' ) ; successCallback ( channel ) ; for ( var i = 0 ; channelChangeHandlers . length > i ; i ++ ) { channelChangeHandlers [ i ] ( channel ) ; } }
function ( err ) { if ( err . code === 'ECONNREFUSED' && tries > 0 ) { console . log ( 'got error, requesting channel change again.' ) ; tries -= 1 ; setTimeout ( function ( ) { requestChannel ( playlistId ) ; } , 1400 ) ; return ; } if ( typeof errorCallback === 'function' ) { errorCallback ( err ) ; } console . log ( 'got error, channel change failed.' ) ; }
function ( config ) { if ( config . master . cert === '' ) { this . state = global . states [ 0 ] ; this . mode = global . modes [ 0 ] ; } else { this . state = global . states [ 0 ] ; this . mode = global . modes [ 1 ] ; } log ( "INFO" , "PZP is in mode " + this . mode ) ; }
function ( data ) { try { pzpInstance . pause ( ) ; self . processMsg ( data , callback ) ; pzpInstance . resume ( ) ; } catch ( err ) { log ( "ERROR" , "[PZP] Exception " + err ) ; } }
function pollJenkins ( asyncCallback ) { var errorMsg ; if ( ! polling ) { polling = true ; setTimeout ( asyncCallback , self . _options . delay ) ; return ; } if ( attempts > self . _options . attempts ) { errorMsg = util . format ( 'ERROR: Jenkins did not report a build after checking %s times' , attempts ) return asyncCallback ( new Error ( errorMsg ) , null ) ; } setTimeout ( getLastBuild , self . _options . delay , asyncCallback ) ; }
function ( builder , branch , revision , callback ) { var options = { url : util . format ( '%s/job/%s/buildWithParameters' , this . _url , builder ) , qs : { 'REV' : revision } } this . log . infof ( 'Forcing build of revision ${rev}' , { rev : revision , options : options } ) ; request . get ( options , callback ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . _id , 'christian' ) ; assert . equal ( obj . name , 'christian' ) ; assert . equal ( obj . resource , 'User' ) ; assert . include ( obj . repsitory_ids , 'issues' ) ; }
function ( ) { var _self = this , bbar = _self . get ( 'bbar' ) , tbar = _self . get ( 'tbar' ) ; _self . _initBar ( bbar , CLS_GREID_BBAR , 'bbar' ) ; _self . _initBar ( tbar , CLS_GREID_TBAR , 'tbar' ) ; }
function ( w ) { var _self = this ; _self . get ( 'header' ) . set ( 'width' , w ) ; _self . get ( 'body' ) . set ( 'width' , w ) ; _self . get ( "el" ) . addClass ( CLS_GRID_WITH ) ; }
function ( ) { var _self = this , children = _self . get ( 'children' ) , columns = _self . get ( 'columns' ) , emptyColumn = _self . _createEmptyColumn ( ) ; S . each ( columns , function ( item , index ) { var columnControl = _self . _createColumn ( item ) ; children [ index ] = columnControl ; columns [ index ] = columnControl ; } ) ; children . push ( _self . _createEmptyColumn ( ) ) ; }
function ( ) { var _self = this , bbar = _self . get ( 'bbar' ) , tbar = _self . get ( 'tbar' ) ; _self . _initBar ( bbar , CLS_GREID_BBAR , 'bbar' ) ; _self . _initBar ( tbar , CLS_GREID_TBAR , 'tbar' ) ; }
function ( w ) { var _self = this ; _self . get ( 'header' ) . set ( 'width' , w ) ; _self . get ( 'body' ) . set ( 'width' , w ) ; _self . get ( "el" ) . addClass ( CLS_GRID_WITH ) ; }
function ( ) { var _self = this , children = _self . get ( 'children' ) , columns = _self . get ( 'columns' ) , emptyColumn = _self . _createEmptyColumn ( ) ; S . each ( columns , function ( item , index ) { var columnControl = _self . _createColumn ( item ) ; children [ index ] = columnControl ; columns [ index ] = columnControl ; } ) ; children . push ( _self . _createEmptyColumn ( ) ) ; }
function ( ) { grid . showData ( data ) ; var height = 500 ; grid . set ( 'height' , height ) ; expect ( header . getColumnsWidth ( ) ) . toBe ( header . get ( 'width' ) - 17 ) ; }
function ( fieldIndex , filterFunc ) { var rawData ; if ( filterFunc == null ) { filterFunc = function ( dp ) { return true ; } ; } rawData = data . selector ( fieldIndex , filterFunc ) ; return rawData . reduce ( function ( a , b ) { return Math . max ( a , b ) ; } ) ; }
function ( fieldIndex , filterFunc ) { var rawData ; if ( filterFunc == null ) { filterFunc = function ( dp ) { return true ; } ; } rawData = data . selector ( fieldIndex , filterFunc ) ; return rawData . reduce ( function ( a , b ) { return Math . min ( a , b ) ; } ) ; }
function ( fieldIndex , filterFunc ) { var rawData ; if ( filterFunc == null ) { filterFunc = function ( dp ) { return true ; } ; } rawData = data . selector ( fieldIndex , filterFunc ) ; return ( rawData . reduce ( function ( a , b ) { return a + b ; } ) ) / rawData . length ; }
function ( ) { var ieRange , endRange , startRange , range , sel ; range = rangy . createRange ( ) ; range . setStart ( this . startContainer , this . startOffset ) ; range . setEnd ( this . endContainer , this . endOffset ) ; sel = rangy . getSelection ( ) ; sel . setSingleRange ( range ) ; }
function ( value ) { return ( value == null ) || ( XM . isArray ( value ) && value . length == 0 ) || ( XM . isUndefined ( value ) || ( XM . isString ( value ) && value == "" ) ) ; }
function ( names , values ) { if ( names == null ) { return this ; } if ( XM . isString ( names ) ) { fn . call ( this , names , values ) ; } else { for ( var i in names ) { if ( names . hasOwnProperty ( k ) ) { fn . call ( this , i , names [ i ] ) ; } } } return this ; }
function replaceNative ( array , index , removeCount , insert ) { if ( insert && insert . length ) { if ( index < array . length ) { array . splice . apply ( array , [ index , removeCount ] . concat ( insert ) ) } else { array . push . apply ( array , insert ) ; } } else { array . splice ( index , removeCount ) ; } return array ; }
function ( className , param , onCreatedFn ) { if ( ! param . constructor ) param [ constructor ] = { } ; return XM . ClassManager . create ( className , param , function ( ) { var cls = XM . ClassManager . getReference ( className ) ; if ( onCreatedFn ) { onCreatedFn . call ( cls ) ; } } ) ; }
function default405 ( req , res ) { var body = "405'd" ; res . writeHead ( 404 , { "Content-Length" : body . length , "Content-Type" : "text/plain" } ) ; res . end ( body ) ; console . log ( "Someone 405'd -- url: " + req . url + "; verb: " + req . method ) ; }
function ( css ) { new Ajax . Request ( css , { method : 'get' , asynchronous : false , onComplete : AjaxOnDemand . loadedCSS } ) ; }
function ( observable , ruleObj ) { var ruleName = utils . newId ( ) ; ko . validation . rules [ ruleName ] = { validator : ruleObj . validator , message : ruleObj . message || 'Error' } ; ko . validation . addRule ( observable , { rule : ruleName , params : ruleObj . params } ) ; }
function getNonFrameBody ( elt ) { var body = Dom . getBody ( elt . ownerDocument ) ; return ( body . localName && body . localName . toUpperCase ( ) === "FRAMESET" ) ? null : body ; }
function ( ) { var ev_listener_toolbar_config = { view : "ev-listeners-all" , groups : [ { type : "buttons" , items : [ { handler : "update-ev-listeners" , title : ui_strings . S_BUTTON_LABEL_REFETCH_EVENT_LISTENERS , } , ] } , { type : "input" , items : [ { handler : cls . EventListenersView . TOKEN_FILTER , shortcuts : cls . EventListenersView . TOKEN_FILTER , title : ui_strings . S_SEARCH_INPUT_TOOLTIP , label : ui_strings . S_INPUT_DEFAULT_TEXT_FILTER , type : "filter" } , ] } ] } ; new ToolbarConfig ( ev_listener_toolbar_config ) ; }
function ( callback ) { payswarm . purchase ( cfg . listingUrl , { transactionService : authority + 'transactions' , customer : cfg . owner , source : cfg . source , publicKey : cfg . publicKey . id , privateKeyPem : cfg . publicKey . privateKeyPem } , callback ) ; }
function ( receipt , callback ) { console . log ( 'RECEIPT:' , JSON . stringify ( receipt , null , 2 ) ) ; callback ( ) ; }
function ( event ) { var tab = $ ( this ) . parent ( ) . parent ( ) ; var selected = tab . tabs ( "option" , "selected" ) ; selected = selected - 1 ; tab . tabs ( 'select' , selected ) ; event . preventDefault ( ) ; }
function ( buf , rinfo ) { console . error ( '[CHILD] %s received %s from %j' , process . pid , util . inspect ( buf . toString ( ) ) , rinfo ) ; receivedMessages . push ( buf ) ; process . send ( { message : buf . toString ( ) } ) ; if ( receivedMessages . length == messages . length ) { process . nextTick ( function ( ) { listenSocket . close ( ) ; } ) ; } }
function fadeDeselectedBars ( ) { if ( brush . extent ( ) != null ) { var start = brush . extent ( ) [ 0 ] ; var end = brush . extent ( ) [ 1 ] ; bars . classed ( "deselected" , function ( d ) { return d . key <= start || d . key >= end ; } ) ; } }
function fadeDeselectedBars ( ) { if ( brush . extent ( ) != null ) { var start = brush . extent ( ) [ 0 ] ; var end = brush . extent ( ) [ 1 ] ; bars . classed ( "deselected" , function ( d ) { return d . key <= start || d . key >= end ; } ) ; } }
function ( ) { var build = util . getMetaContent ( 'vibe-build' ) , version = util . getMetaContent ( 'vibe-version' ) , result = "" result += "<p style='font-size:14px'><strong>Version:</strong> " + version + "</p>" if ( build ) { result += "<p style='font-size:14px'><strong>Build:</strong> " + build + "</p>" } return result }
function _draw ( baseLayout , inputType , layoutMode , uppercase ) { baseLayout = baseLayout || _baseLayout ; inputType = inputType || _currentInputType ; layoutMode = layoutMode || _currentLayout ; uppercase = uppercase || false ; _currentLayout = _buildLayout ( baseLayout , inputType , layoutMode ) ; if ( _severalLanguages ( ) ) IMERender . draw ( _currentLayout , baseLayout , _onScroll , { uppercase : uppercase } ) ; else IMERender . draw ( _currentLayout , undefined , _onScroll , { uppercase : uppercase } ) ; }
function parse_parenthesis_expression ( ) { var result0 ; result0 = parse_expression_4 ( ) ; if ( result0 === null ) { result0 = parse_expression_1 ( ) ; if ( result0 === null ) { result0 = parse_expression_2 ( ) ; if ( result0 === null ) { result0 = parse_expression_3 ( ) ; } } } return result0 ; }
function ( test ) { test . numAssertions = 2 ; var eventDispatcher = new Pusher . EventsDispatcher ( ) ; var callback = function ( ) { } ; eventDispatcher . bind ( 'test_event' , callback ) ; test . equal ( 1 , eventDispatcher . callbacks [ 'test_event' ] . length ) ; test . equal ( callback , eventDispatcher . callbacks [ 'test_event' ] [ 0 ] ) ; test . finish ( ) ; }
function pickEmailState ( event ) { var self = this ; if ( ! dom . getElements ( "input[type=radio]:checked" ) . length ) { dom . setAttr ( 'input[type=radio]:eq(0)' , 'checked' , true ) ; } dom . focus ( "input[type=radio]:checked" ) ; self . submit = signIn ; }
function checkEmail ( email ) { var identity = user . getStoredEmailKeypair ( email ) ; if ( ! identity ) { alert ( gettext ( "The selected email is invalid or has been deleted." ) ) ; this . publish ( "assertion_generated" , { assertion : null } ) ; } return ! ! identity ; }
function ( ) { storage . addEmail ( "testuser@testuser.com" , { } ) ; storage . addEmail ( "testuser2@testuser.com" , { } ) ; storage . site . set ( testOrigin , "email" , "testuser2@testuser.com" ) ; createController ( ) ; var radioButton = $ ( "input[type=radio]" ) . eq ( 0 ) ; ok ( radioButton . is ( ":checked" ) , "the email address we specified is checked" ) ; var label = $ ( "label[for=" + radioButton . attr ( "id" ) + "]" ) ; ok ( label . hasClass ( "preselected" ) , "the label has the preselected class" ) ; }
function ( ) { storage . addEmail ( "testuser@testuser.com" , { } ) ; createController ( ) ; var radioButton = $ ( "input[type=radio]" ) . eq ( 0 ) ; equal ( radioButton . is ( ":checked" ) , true , "The email address is not checked" ) ; var label = radioButton . parent ( ) ; equal ( label . hasClass ( "preselected" ) , false , "the label has no class" ) ; }
function ( ) { storage . addEmail ( "testuser@testuser.com" , { } ) ; storage . addEmail ( "testuser2@testuser.com" , { } ) ; createController ( ) ; $ ( "input[type=radio]" ) . eq ( 0 ) . trigger ( "click" ) ; var assertion ; register ( "email_chosen" , function ( msg , info ) { ok ( info . email , "email_chosen message triggered with email" ) ; start ( ) ; } ) ; controller . signIn ( ) ; }
function ( position ) { var output = [ ] , slugs = window . location . href . split ( '/' ) ; for ( var slug in slugs ) { if ( slugs [ slug ] !== '' ) { output . push ( slugs [ slug ] ) ; } } if ( position ) { if ( position === 'first' ) { output = output [ 0 ] ; } if ( position === 'last' ) { output = output [ output . length - 1 ] ; } } return output ; }
function ( acc , val , idx ) { var column = meta . viewport . cols [ fixed ? idx : fixed_length + idx ] ; return acc . concat ( { column : column , value : format ( grid , val , meta . columns . types [ column ] ) } ) ; }
function ( key , val ) { annotation_type = val . wkt_data [ 0 ] ; var shape = getGoogleAnnotation ( map [ "googleMap" ] , val . google_maps_annotation , annotation_type , val . body ) ; shape . setMap ( map [ "googleMap" ] ) ; annotations_array . push ( shape ) ; console . log ( 'testing' ) ; }
function ( event ) { self . acceleration . x = event . gamma / self . slowingFactor ; self . acceleration . y = event . beta / self . slowingFactor ; }
function ( ) { $ ( '#debug' ) . html ( 'Acceleration vector: (' + this . acceleration . x . toFixed ( 2 ) + ', ' + this . acceleration . y . toFixed ( 2 ) + ')<br/>\     Velocity vector: (' + Math . round ( this . velocity . x ) + ', ' + Math . round ( this . velocity . y ) + ')' ) ; }
function ( ) { var _j , _ref2 , _results2 ; _results2 = [ ] ; for ( _j = 0 , _ref2 = this . squaresY ; 0 <= _ref2 ? _j < _ref2 : _j > _ref2 ; 0 <= _ref2 ? _j ++ : _j -- ) { _results2 . push ( { } ) ; } return _results2 ; }
function ( square ) { var type , _i , _len , _ref ; _ref = this . squareTypes ; for ( _i = 0 , _len = _ref . length ; _i < _len ; _i ++ ) { type = _ref [ _i ] ; if ( square [ type ] ) return false ; } return true ; }
function ( pos , type ) { if ( this . world [ pos . x ] [ pos . y ] [ type ] ) return false ; this . world [ pos . x ] [ pos . y ] [ type ] = true ; return true ; }
function ( pos ) { var type , _i , _len , _ref , _results ; _ref = this . squareTypes ; _results = [ ] ; for ( _i = 0 , _len = _ref . length ; _i < _len ; _i ++ ) { type = _ref [ _i ] ; _results . push ( this . unregisterSquareAt ( pos , type ) ) ; } return _results ; }
function ( type , pos ) { return this . world [ pos . x ] [ pos . y ] [ type ] != null ; }
function ( ) { this . resetFoodInterval ( ) ; this . foodItems . enqueue ( Game . Utils . randPair ( this . squaresX - 1 , this . squaresY - 1 ) ) ; if ( this . foodCount > this . maxFood ) return this . foodItems . dequeue ( ) ; }
function ( vecA , vecB , dest ) { if ( ! dest ) dest = vecB ; dest [ 0 ] = vecA [ 0 ] + vecB [ 0 ] ; dest [ 1 ] = vecA [ 1 ] + vecB [ 1 ] ; dest [ 2 ] = vecA [ 2 ] + vecB [ 2 ] ; dest [ 3 ] = vecA [ 3 ] + vecB [ 3 ] ; return dest ; }
function ( vecA , scalar , dest ) { if ( ! dest ) dest = vecA ; dest [ 0 ] = vecA [ 0 ] * scalar ; dest [ 1 ] = vecA [ 1 ] * scalar ; dest [ 2 ] = vecA [ 2 ] * scalar ; dest [ 3 ] = vecA [ 3 ] * scalar ; return dest ; }
function ( d ) { vxl . go . console ( 'set distance called' ) ; }
function ( vecA , vecB , dest ) { if ( ! dest ) dest = vecB ; dest [ 0 ] = vecA [ 0 ] + vecB [ 0 ] ; dest [ 1 ] = vecA [ 1 ] + vecB [ 1 ] ; dest [ 2 ] = vecA [ 2 ] + vecB [ 2 ] ; dest [ 3 ] = vecA [ 3 ] + vecB [ 3 ] ; return dest ; }
function ( vecA , scalar , dest ) { if ( ! dest ) dest = vecA ; dest [ 0 ] = vecA [ 0 ] * scalar ; dest [ 1 ] = vecA [ 1 ] * scalar ; dest [ 2 ] = vecA [ 2 ] * scalar ; dest [ 3 ] = vecA [ 3 ] * scalar ; return dest ; }
function ( d ) { vxl . go . console ( 'set distance called' ) ; }
function ( e ) { if ( ! this . hasFocus ) { this . tableObj . focus ( ) ; this . obj . addClass ( 'aloha-table-cell_active' ) ; this . hasFocus = true ; this . _selectAll ( this . wrapper . get ( 0 ) ) ; this . tableObj . selection . selectionType = 'cell' ; } }
function ( ) { var active_editable_obj = this . getBaseElement ( ) ; if ( ! active_editable_obj ) { return ; } $ ( Aloha . activeEditable . obj ) . attr ( 'aloha-numerated-headers' , 'false' ) ; var headingselector = this . getCurrentConfig ( ) . headingselector ; var headers = active_editable_obj . find ( headingselector ) ; headers . each ( function ( ) { $ ( this ) . find ( 'span[role=annotation]' ) . each ( function ( ) { $ ( this ) . remove ( ) ; } ) ; } ) ; }
function ( ) { if ( typeof this . baseobjectSelector !== 'undefined' ) { return ( $ ( this . baseobjectSelector ) . length > 0 ) ? $ ( this . baseobjectSelector ) : null ; } return Aloha . activeEditable ? Aloha . activeEditable . obj : null ; }
function ( ) { var time = this . timer . tick ( ) ; this . elapsedTime += time ; this . runningSlow = false ; if ( time >= this . targetTime ) { this . runningSlow = true ; } this . update ( time ) ; this . draw ( time ) ; Ori . input . reset ( ) ; }
function initChat ( ) { appendFromLocalStorage ( ) ; setTimeout ( function ( ) { $ ( '#msg' ) . focus ( ) ; scrollToBottom ( true ) ; } , 200 ) ; var msgText = localStorage . getItem ( 'msg:' + myUid + ':' + friendUid ) ; if ( msgText ) { setMsgValue ( msgText ) ; } }
function ( req , socket , upgradeHead ) { var resource = self . options . resource if ( req . url . substr ( 0 , resource . length ) !== resource ) { if ( self . options . destroyUpgrade ) { socket . end ( ) debug ( 'Destroying non-besio upgrade' ) } return } socket . write ( 'HTTP/1.1 101 Switching Protocols\r\n' + 'Upgrade: Besio\r\n' + 'Connection: Upgrade\r\n' + '\r\n' ) client . onSocket ( socket , upgradeHead ) }
function ( err , files ) { if ( err ) { return callback ( err ) ; } var synchronizer = new core . Synchronizer ( ) ; files . forEach ( function ( file ) { fs . readFile ( self . combine ( path , file ) , synchronizer . register ( file ) ) ; } ) ; synchronizer . onfinish ( callback ) ; }
function ( event ) { switch ( event . keyCode ) { case 32 : case 33 : case 34 : case 35 : case 36 : case 37 : case 38 : case 39 : case 40 : return false ; } }
function ( b ) { l . de . valueMissing [ b ] = "Bitte w\u00e4hlen Sie eine Option aus" } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( b ) { l . de . rangeUnderflow [ b ] = "{%value} ist zu fr\u00fch. {%min} ist die fr\u00fcheste Zeit, die Sie benutzen k\u00f6nnen." } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( b ) { l . de . rangeOverflow [ b ] = "{%value} ist zu sp\u00e4t. {%max} ist die sp\u00e4teste Zeit, die Sie benutzen k\u00f6nnen." }
function ( a ) { f . de . valueMissing [ a ] = "Bitte w\u00e4hlen Sie eine Option aus" } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { f . de . rangeUnderflow [ a ] = "{%value} ist zu fr\u00fch. {%min} ist die fr\u00fcheste Zeit, die Sie benutzen k\u00f6nnen." } ) ; [ "date" , "time" , "datetime-local" ] . forEach ( function ( a ) { f . de . rangeOverflow [ a ] = "{%value} ist zu sp\u00e4t. {%max} ist die sp\u00e4teste Zeit, die Sie benutzen k\u00f6nnen." }
function thui_updateInputHeight ( ) { var input = this . input ; input . style . height = null ; input . style . height = input . scrollHeight + 8 + 'px' ; var newHeight = input . getBoundingClientRect ( ) . height ; var bottomToolbarHeight = ( newHeight + 32 ) + 'px' ; var bottomToolbar = document . getElementById ( 'view-bottom-toolbar' ) ; bottomToolbar . style . height = bottomToolbarHeight ; this . view . style . bottom = bottomToolbarHeight ; this . scrollViewToBottom ( ) ; }
function soundManager_init ( ) { window . addEventListener ( 'keydown' , this ) ; window . addEventListener ( 'keyup' , this ) ; }
function ( event ) { var code = event . target . errorCode ; call ( callback , { status : 500 , error : event . type , reason : Object . keys ( IDBDatabaseException ) [ code - 1 ] . toLowerCase ( ) } ) ; }
function ( e , r ) { if ( typeof e === "function" ? e ( console . log ( "Error in saveApp: " + e ) ) : void 0 ) { } else { console . log ( "Finished saving app: " + r ) ; } return cb ( e , r ) ; }
function ( ship , name ) { for ( var i in ship . systems ) { var system = ship . systems [ i ] ; if ( system . name == name ) { return system ; } } return null ; }
function ( ) { fs . chown ( sFile , oStat . gid , oStat . uid , function ( ) { fCallback ( sFile ) ; } ) ; }
function ( evt ) { evt && evt . preventDefault ( ) var remixUrl = "https://makr.io/posts/" + this . model . id + "/remix" , caption = "made on <a href='https://www.makr.io'>makr.io</a> | <a href='" + remixUrl + "'>remix this</a>" , source = "https://d2v75xn1eqsd0m.cloudfront.net" + this . model . get ( "screenshot_url" ) , url = "http://www.tumblr.com/share/photo?" + "source=" + encodeURIComponent ( source ) + "&caption=" + encodeURIComponent ( caption ) + "&clickthru=" + encodeURIComponent ( source ) this . launchWindow ( url ) }
function ( key , value ) { var val = pipwerks . SCORM . set ( 'cmi.' + key , value ) ; return val ; }
function ( dateText , inst ) { if ( typeof ( dateText ) == "string" && dateText . search ( /{.*?}/ ) == - 1 && dateText != "" ) { date = $ . datepicker . parseDate ( i18n . date . L , dateText ) ; DailyNavigator . gotoDate ( date ) ; } }
function ( err , quants ) { if ( err ) { winston . error ( err ) ; return callback ( "Limiter failure." ) ; } if ( quants [ 0 ] > config . SHORT_TERM_LIMIT || quants [ 1 ] > config . LONG_TERM_LIMIT ) return callback ( 'Reduce your speed.' ) ; reserve ( ) ; }
function ( err , rs ) { if ( err ) return callback ( err ) ; if ( rs [ 1 ] != 1 ) return callback ( "Image in use." ) ; if ( ! rs [ 0 ] ) return callback ( "Image lost." ) ; var alloc = JSON . parse ( rs [ 0 ] ) ; alloc . id = id ; callback ( null , alloc ) ; }
function ( err , stat ) { if ( err ) { winston . error ( err ) ; callback ( 'Internal filesize error.' ) ; } else if ( stat . size > config . IMAGE_FILESIZE_MAX ) callback ( 'File is too large.' ) ; else callback ( null , stat . size ) ; }
function ( err , stdout , stderr ) { fs . unlink ( tmp ) ; if ( err ) { winston . error ( stderr ) ; return callback ( 'Hashing error.' ) ; } var hash = stdout . trim ( ) ; if ( hash . length != 64 ) return callback ( 'Hashing problem.' ) ; callback ( null , hash ) ; }
function ( err , stdout , stderr ) { if ( err ) return callback ( stderr ) ; else if ( stdout . match ( /^APNG/ ) ) return callback ( null , true ) ; else if ( stdout . match ( /^PNG/ ) ) return callback ( null , false ) ; else return callback ( stderr ) ; }
function im_callback ( cb , err , stdout , stderr ) { if ( err ) { winston . error ( stderr ) ; return cb ( 'Conversion error.' ) ; } if ( config . DEBUG ) setTimeout ( cb , 1000 ) ; else cb ( ) ; }
function listening ( errs ) { if ( errs && errs . length >= count ) return report ( "Couldn't sync to board." , client ) ; else if ( errs ) { dead_threads . push . apply ( dead_threads , errs ) ; errs . forEach ( function ( thread ) { delete client . watching [ thread ] ; } ) ; } client . db . fetch_backlogs ( client . watching , got_backlogs ) ; }
function report ( error , client , client_msg ) { var error_db = new db . Yakusoku ( null , db . UPKEEP_IDENT ) ; var msg = client_msg || 'Server error.' ; var ip = client && client . ident . ip ; winston . error ( 'Error by ' + ip + ': ' + ( error || msg ) ) ; if ( client ) { client . send ( [ 0 , common . INVALID , msg ] ) ; client . synced = false ; } }
function debug_command ( client , frag ) { if ( ! frag ) return ; if ( frag . match ( /\bfail\b/ ) ) report ( "debug" , client , "Failure requested." ) ; else if ( frag . match ( /\bclose\b/ ) ) client . socket . close ( ) ; }
function ( ) { if ( $ . data ( this , "destroy.tabs" ) ) { $ ( this ) . remove ( ) ; } else { $ ( this ) . removeClass ( [ "ui-state-default" , "ui-corner-top" , "ui-tabs-active" , "ui-state-active" , "ui-state-disabled" , "ui-tabs-panel" , "ui-widget-content" , "ui-corner-bottom" ] . join ( " " ) ) ; } }
function ( name ) { name = ( name && name . toLowerCase ( ) ) || 'default' ; this . doctype = doctypes [ name ] || '<!DOCTYPE ' + name + '>' ; this . terse = 'default' == name || '5' == name || 'html' == name ; this . xml = 0 == this . doctype . indexOf ( '<?xml' ) ; }
function ( ) { expect ( 1 ) ; forceTouchSupport ( ) ; $ ( "#qunit-fixture" ) . bind ( 'swipe' , function ( ) { } ) ; $ . Event . prototype . originalEvent = { touches : false } ; $ . Event . prototype . preventDefault = function ( ) { ok ( true , "prevent default called" ) ; start ( ) ; } ; mockAbs ( 11 ) ; $ ( "#qunit-fixture" ) . trigger ( "touchstart" ) ; $ ( "#qunit-fixture" ) . trigger ( "touchmove" ) ; }
function ( event ) { var newBackgroundPos = { } ; newBackgroundPos . X = ( IconDragging . backgroundPos . X + event . clientX - IconDragging . mouseStartPos . X ) + "px" ; newBackgroundPos . Y = ( IconDragging . backgroundPos . Y + event . clientY - IconDragging . mouseStartPos . Y ) + "px" ; IconDragging . tile . css ( "background-position" , newBackgroundPos . X + " " + newBackgroundPos . Y ) ; }
function ( opts ) { var port , body = window . document . body ; options = $ . extend ( { } , defaults , opts ) ; port = options . viewPort ; viewPort = port ? $ ( "#" + port ) : $ ( body ) ; pushView ( options . startView ) ; }
function ( opts ) { var port , body = window . document . body ; options = $ . extend ( { } , defaults , opts ) ; port = options . viewPort ; viewPort = port ? $ ( "#" + port ) : $ ( body ) ; pushView ( options . startView ) ; }
function ( id , callback ) { if ( this . schema . properties . _id && this . schema . properties . _id . sanitize ) { id = this . schema . properties . _id . sanitize ( id ) ; } var newid = this . lowerResource + "/" + id ; return id ? this . _request ( 'destroy' , newid , callback ) : callback && callback ( new Error ( 'key is undefined' ) ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . _id , 'christian' ) ; assert . equal ( obj . name , 'christian' ) ; assert . equal ( obj . resource , 'User' ) ; assert . lengthOf ( obj . repsitory_ids , 2 ) ; }
function ( ) { var self = this ; $ . lang . init ( function ( ) { self . header ( ) ; device . start ( ) ; } ) ; }
function ( ) { var child = require ( 'child_process' ) . spawn ( 'prey' ) ; child . on ( 'exit' , function ( code ) { if ( code == 0 ) { console . log ( "Done! You can now close this window.\n" ) ; console . log ( "Or if you wish to play around with Prey, try the console mode: \n\n\t $ prey -d console\n" ) } else { console . log ( "Shoot. Something went wrong. Try running Prey again to see what's going on." ) } process . exit ( code ) ; } ) }
function ( ) { var args , _ref3 ; args = 1 <= arguments . length ? __slice . call ( arguments , 0 ) : [ ] ; if ( listeners . length > 0 ) { try { return ( _ref3 = listeners [ 0 ] ) [ 0 ] . apply ( _ref3 , args ) ; } catch ( e ) { return console . log ( e ) ; } } else { return true ; } }
function ( id ) { var _ref3 , _ref4 ; return ( _ref3 = ( _ref4 = spo [ id ] ) != null ? _ref4 . values : void 0 ) != null ? _ref3 : { } ; }
function ( ) { var operator , term , _ref3 ; term = parseFactor ( ) ; while ( ( token != null ) && token . type === Scanner . OPERATOR && ( ( _ref3 = token . value ) === "*" || _ref3 === "/" ) ) { operator = token . value ; next ( ) ; term = Expression . initOperator ( operator , [ term , parseFactor ( ) ] ) ; } return term ; }
function ( labelText ) { if ( ! this . _errorShown ) { L . Handler . Draw . prototype . _updateLabelText . call ( this , labelText ) ; } }
function ( ) { this . _errorShown = false ; this . _clearHideErrorTimeout ( ) ; L . DomUtil . removeClass ( this . _label , 'leaflet-error-draw-label' ) ; L . DomUtil . removeClass ( this . _label , 'leaflet-flash-anim' ) ; this . _updateLabelText ( this . _getLabelText ( ) ) ; L . DomUtil . removeClass ( this . _guidesContainer , 'leaflet-draw-error-guide-dash' ) ; this . _poly . setStyle ( { color : this . options . shapeOptions . color } ) ; }
function ( m ) { for ( var i = 0 ; i < this . verticies . length ; i ++ ) { POS3D . Matrix . applyTransform ( m , this . verticies ) ; } }
function ( f , m ) { var verts = [ ] ; for ( var i = 0 ; i < f . verticies . length ; i ++ ) { verts [ i ] = POS3D . Matrix . applyTransform ( m , f . verticies ) ; } return new POS3D . Face ( verts , f . color ) ; }
function ( ) { for ( var i = 0 ; i < this . faces . length ; i ++ ) this . faces [ i ] . applyTransform ( this . transform ) ; }
function ( mod , m ) { var nFaces = [ ] ; for ( var i = 0 ; i < mod . faces . length ; i ++ ) nFaces [ i ] = mod . faces [ i ] . applyTransform ( m ) return new POS3D . Model ( mod . vector , nFaces ) ; }
function ( ) { context . clearRect ( 0 , 0 , canvasWidth , canvasHeight ) ; context . fillStyle = "#C0C0C0" ; context . fillRect ( 0 , 0 , canvasWidth , canvasHeight ) ; if ( model != null ) { model . transformFaces ( ) ; drawModel ( model ) ; } }
function ( f0 , f1 ) { var v0 = f0 . verticies ; var v1 = f1 . verticies ; var sum_z0 = 0 ; for ( var x = 0 ; x < v0 . length ; ++ x ) sum_z0 += v0 [ x ] . z ; var sum_z1 = 0 ; for ( var x = 0 ; x < v1 . length ; ++ x ) sum_z1 += v1 [ x ] . z ; return sum_z0 - sum_z1 ; }
function ( ) { this . context . renderer . unloadedTextureCount -- ; if ( texture . callback ) texture . callback ( texture ) ; if ( this . context . renderer . unloadedTextureCount < 0 ) console . log ( "more textures loaded then created..." ) ; }
function ( x , y ) { this . initGridPos . x = x ; this . initGridPos . y = y ; this . x = this . initGridPos . x * S . C_WIDTH ; this . gridX = this . x / S . C_WIDTH ; this . y = this . initGridPos . y * S . C_HEIGHT ; this . gridY = this . y / S . C_HEIGHT ; }
function ( room ) { populateLobbyRooms ( ) ; ui . addMessage ( 'Room \'' + room + '\' is now closed' , 'notification' , this . activeRoom ) ; ui . closeRoom ( room ) ; if ( this . activeRoom === room ) { ui . toggleMessageSection ( room . closed ( ) ) ; } }
function ( room ) { populateLobbyRooms ( ) ; ui . addMessage ( 'Room \'' + room + '\' is now open' , 'notification' , this . activeRoom ) ; ui . unCloseRoom ( room ) ; if ( this . activeRoom === room ) { ui . toggleMessageSection ( room . closed ( ) ) ; } }
function Botprint ( ) { var radio = Bindable ( ) ; var canvas = Canvas2D ( { elemID : 'canvas2d' , app : radio } ) ; var preview = Preview3D ( { elemID : 'preview3d' , app : radio } ) ; var sidePanel = SidePanel ( { elemClass : 'palette-set a' , app : radio } ) ; var self = { VERSION : '0.0.2' , play : function ( ) { preview . animate ( ) ; } } ; return self ; }
function ( clipboardEvent ) { if ( this . application . ninja . currentDocument . currentView === "code" ) return ; if ( document . activeElement . nodeName !== "BODY" ) { return ; } if ( this . clipboardContext === "stage" ) { ElementsClipboardAgent . cut ( clipboardEvent ) ; } clipboardEvent . preventDefault ( ) ; }
function ( err , email ) { if ( err ) { logger . error ( 'verfication of primary assertion failed unexpectedly dbwriter (' + err + '): ' + req . body . assertion ) ; return httputils . serverError ( res ) ; } db . createUserWithPrimaryEmail ( email , function ( err , uid ) { if ( err ) return wsapi . databaseDown ( res ) ; res . json ( { success : true , userid : uid } ) ; } ) ; }
function ( req , res ) { var email = req . query . email ; db . emailIsVerified ( email , function ( err , verified ) { if ( err ) return wsapi . databaseDown ( res , err ) ; res . json ( { status : verified ? 'complete' : 'pending' } ) ; } ) ; }
function ( error ) { if ( error ) { logger . warn ( "error removing email " + email ) ; if ( error === 'database connection unavailable' ) { wsapi . databaseDown ( res , error ) ; } else { httputils . badRequest ( res , error . toString ( ) ) ; } } else { res . json ( { success : true } ) ; } }
function ( err , secret ) { if ( err ) return wsapi . databaseDown ( res , err ) ; var langContext = wsapi . langContext ( req ) ; req . session . pendingAddition = secret ; res . json ( { success : true } ) ; email . sendConfirmationEmail ( req . body . email , req . body . site , secret , langContext ) ; }
function ( err , secret ) { if ( err ) return wsapi . databaseDown ( res , err ) ; var langContext = wsapi . langContext ( req ) ; req . session . pendingReset = secret ; res . json ( { success : true } ) ; email . sendForgotPasswordEmail ( req . body . email , req . body . site , secret , langContext ) ; }
function ( err , secret ) { if ( err ) return wsapi . databaseDown ( res , err ) ; if ( ! req . session ) req . session = { } ; req . session . pendingCreation = secret ; res . json ( { success : true } ) ; email . sendNewUserEmail ( req . body . email , req . body . site , secret , langContext ) ; }
function ( err ) { var success = true ; if ( err ) { logger . error ( "error updating bcrypted password for email " + req . body . email , err ) ; wsapi . databaseDown ( res , err ) ; } else { res . json ( { success : success } ) ; } }
function ( err , uid ) { if ( err ) return wsapi . databaseDown ( res , err ) ; if ( ! uid ) return res . json ( { success : false , reason : "internal error" } ) ; wsapi . authenticateSession ( req . session , uid , 'assertion' , req . body . ephemeral ? config . get ( 'ephemeral_session_duration_ms' ) : config . get ( 'authentication_duration_ms' ) ) ; return res . json ( { success : true , userid : uid } ) ; }
function ( err , verified ) { if ( ! verified ) return httputils . forbidden ( res , "that email requires (re)verification" ) ; var keysigner = urlparse ( config . get ( 'keysigner_url' ) ) ; keysigner . path = '/wsapi/cert_key' ; forward ( keysigner , req , res , function ( err ) { if ( err ) { logger . error ( "error forwarding request to keysigner: " + err ) ; httputils . serverError ( res , "can't contact keysigner" ) ; return ; } } ) ; }
function validateEmail ( email ) { if ( email ) { for ( var domain in config . ALLOWED_DOMAINS ) { var canidate = config . ALLOWED_DOMAINS [ domain ] ; canidate = canidate . replace ( /[-[\]{}()*+?.,\\^$|#\s]/g , "\\$&" ) ; if ( email . match ( "^.*@" + canidate + "$" ) ) { return true ; } } } return false ; }
function ( ) { var opts = collectionUtils . clone ( options ) ; if ( ! opts . tries || polledCount < opts . tries ) { polledCount = polledCount + 1 ; this . fetch ( opts ) ; this . pollTimeout = setTimeout ( update , opts . interval || 1000 ) ; } }
function ( options ) { var polledCount = 0 ; this . unstream ( ) ; var update = utils . bind ( function ( ) { var opts = collectionUtils . clone ( options ) ; if ( ! opts . tries || polledCount < opts . tries ) { polledCount = polledCount + 1 ; this . fetch ( opts ) ; this . pollTimeout = setTimeout ( update , opts . interval || 1000 ) ; } } , this ) ; update ( ) ; }
function ( channel ) { var args = [ ] . slice . call ( arguments , 1 ) , el = args [ 0 ] , file = lang . decamelize ( channel ) ; mediator . publish ( channel , 'unload' ) ; mediator . unload ( baseUrl + file ) ; if ( el ) { $ ( el ) . html ( '' ) ; } }
function ( item ) { if ( this . emptyView ) this . emptyView . dealloc ( ) ; var view = new ItemView ( { model : item } ) this . $el . append ( view . render ( ) . el ) ; return this ; }
function ( container ) { if ( this . isEnabled ( ) ) { $ ( container ) . append ( "<div class=\"slide\">" + "<div class=\"slide_content\">" + ( this . isRead ( ) ? "" : "<img src=\"assets/new-ribbon.png\" width=\"112\" height=\"112\" alt=\"New Ribbon\" id=\"ribbon\">" ) + "<a href=\"#\" onclick=\"chrome.tabs.create({url: '" + this . siteURL + "'})\"><img src=\"" + this . getTeeImage ( ) + "\" width=\"" + this . imgWidth + "\" height=\"" + this . imgHeight + "\"></a>" + "</div>" + "<div class=\"caption\" style=\"bottom:0\">" + "<p>" + this . siteDisplayName + ": " + this . getTeeTitle ( ) + "</p>" + "</div>" + "</div>" ) ; this . setRead ( true ) ; } }
function ( elem ) { return ( ( elem . href . indexOf ( 'flickr.com' ) >= 0 ) && ( elem . href . indexOf ( '/sets/' ) == - 1 ) && ( elem . href . split ( '/' ) . length > 5 ) ) ; }
function ( msg ) { if ( msg . profile == window . app . profiles . DEFAULT ) { __runtimes = { } ; __old_runtimes = { } ; __runtimes_arr = [ ] ; __window_ids = { } ; __windows_reloaded = { } ; __threads = [ ] ; __log_threads = false ; __windowsFolding = { } ; __selected_runtime_id = '' ; __next_runtime_id_to_select = '' ; __selected_script = '' ; updateRuntimeViews ( ) ; } }
function ( select_id , runtimes , stopped_script_id , selected_script_id , search_term ) { var script_list = [ "div" ] ; for ( var i = 0 , rt ; rt = runtimes [ i ] ; i ++ ) { script_list . push ( this . runtime_script ( rt , stopped_script_id , selected_script_id , search_term ) ) ; } script_list . push ( "class" , "js-dd-script-list" , "handler" , "js-dd-move-highlight" ) ; return script_list ; }
function ( payload ) { var w = payload . wheel ; var w3 = new Wheel3D ( w . elem ) ; self . wheels [ w . id ] = w3 ; var robot = self . buildRobot3D ( ) ; view . updateRobot ( robot ) ; }
function ( payload ) { var event = payload . event ; var x = CurrentEvent ( event ) . currentX ; var y = CurrentEvent ( event ) . currentY ; if ( this . shape ) { var path = this . shape . attrs . path ; var last = path [ path . length - 1 ] ; last [ 1 ] = x ; last [ 2 ] = y ; this . shape . attr ( 'path' , path ) ; } }
function ( err , obj ) { assert . isNull ( err ) ; assert . isArray ( obj ) ; assert . equal ( obj . length , 3 ) ; assert . equal ( obj [ 0 ] . key , 'bob' ) ; assert . equal ( obj [ 1 ] . key , 'mat' ) ; assert . equal ( obj [ 2 ] . key , 'tim' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . strictEqual ( obj . constructor , resources [ e ] . Author ) ; assert . instanceOf ( obj , resources [ e ] . Author ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . age , 30 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . age , 30 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . strictEqual ( obj . constructor , resources [ e ] . Creature ) ; assert . instanceOf ( obj , resources [ e ] . Creature ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . resource , 'Creature' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . age , 30 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'han' ) ; assert . equal ( obj . age , 30 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 31 ) ; assert . equal ( obj . hair , 'red' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'bob' ) ; assert . equal ( obj . age , 35 ) ; assert . equal ( obj . hair , 'black' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . notEqual ( obj . key , undefined ) ; assert . equal ( obj . age , 51 ) ; assert . equal ( obj . hair , 'white' ) ; assert . equal ( obj . resource , 'Author' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . length , 3 ) ; assert . equal ( obj [ 0 ] . key , 'bob' ) ; assert . equal ( obj [ 1 ] , null ) ; assert . equal ( obj [ 2 ] . key , 'tim' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . lengthOf ( obj , 2 ) ; assert . equal ( obj [ 0 ] . key , 'user/pavan/bullet' ) ; assert . equal ( obj [ 0 ] . name , 'bullet' ) ; assert . equal ( obj [ 1 ] . key , 'user/pavan/octonode' ) ; assert . equal ( obj [ 1 ] . name , 'octonode' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . lengthOf ( obj , 2 ) ; assert . equal ( obj [ 0 ] . key , 'user/pavan/bullet' ) ; assert . equal ( obj [ 0 ] . name , 'bullet' ) ; assert . equal ( obj [ 1 ] . key , 'user/pavan/octonode' ) ; assert . equal ( obj [ 1 ] . name , 'octonode' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'christian' ) ; assert . equal ( obj . name , 'christian' ) ; assert . equal ( obj . resource , 'User' ) ; assert . lengthOf ( obj . repository_ids , 2 ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'marak' ) ; assert . equal ( obj . name , 'marak' ) ; assert . equal ( obj . resource , 'User' ) ; assert . lengthOf ( obj . repository_ids , 2 ) ; assert . lengthOf ( obj . follower_ids , 2 ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj [ 0 ] . key , 'user/pavan/bullet' ) ; assert . equal ( obj [ 0 ] . name , 'bullet' ) ; assert . equal ( obj [ 1 ] . key , 'user/pavan/octonode' ) ; assert . equal ( obj [ 1 ] . name , 'octonode' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'christian' ) ; assert . equal ( obj . name , 'christian' ) ; assert . equal ( obj . resource , 'User' ) ; assert . include ( obj . repository_ids , 'issues' ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'christian' ) ; assert . equal ( obj . name , 'christian' ) ; assert . equal ( obj . resource , 'User' ) ; assert . lengthOf ( obj . repository_ids , 2 ) ; }
function ( err , obj ) { assert . isNull ( err ) ; assert . equal ( obj . key , 'forum/forum/develop/nodejitsu/haibu' ) ; assert . equal ( obj . name , 'haibu' ) ; assert . equal ( obj . resource , 'Forum' ) ; assert . equal ( obj . forum_id , 'forum/develop/nodejitsu' ) ; assert . lengthOf ( obj . forum_ids , 0 ) ; }
function day_after ( today ) { var tomorrow = new Date ( today . getTime ( ) + 24 * 3600 * 1000 ) ; if ( tomorrow . getUTCDate ( ) == today . getUTCDate ( ) ) tomorrow = new Date ( tomorrow . getTime ( ) + 12 * 3600 * 1000 ) ; return tomorrow ; }
function at_next_curfew_start ( board , func ) { var when = caps . curfew_starting_time ( board ) ; winston . info ( 'Next curfew for ' + board + ' at ' + when ) ; setTimeout ( func , when . getTime ( ) - new Date ( ) . getTime ( ) ) ; }
function ( ) { winston . info ( 'Curfew ' + board + ' at ' + new Date ( ) ) ; shutdown ( board , function ( err ) { if ( err ) winston . error ( err ) ; } ) ; setTimeout ( enforce . bind ( null , board ) , 30 * 1000 ) ; }
function doNextStep ( ) { if ( typeof ( currentStep ) == "undefined" ) currentStep = 0 ; if ( currentStep < todo . length ) setTimeout ( function ( ) { todo [ currentStep ++ ] ( ) ; } , 0 ) ; else if ( currentStep ++ == todo . length ) setTimeout ( function ( ) { finishJSTest ( ) ; } , 0 ) ; }
function ( ) { onCompleteSignal . remove ( ) ; if ( current ) { domClass . remove ( current . domNode , 'is-visible fx-reverse fx-slide-h' ) ; } domClass . add ( next . domNode , 'is-visible' ) ; domClass . remove ( next . domNode , 'fx-slide-h' ) ; deferred . progress ( 1 ) ; deferred . resolve ( true ) ; }
function ( pokemon , target , move ) { if ( pokemon . removeVolatile ( 'truant' ) ) { this . add ( 'cant' , pokemon , 'ability: Truant' , move ) ; return false ; } pokemon . addVolatile ( 'truant' ) ; }
function ( key , value ) { var parentView , context ; if ( arguments . length === 2 ) { return value ; } if ( VIEW_PRESERVES_CONTEXT ) { if ( Ember . meta ( this ) . descs . controller !== controllerProperty ) { if ( context = get ( this , 'controller' ) ) { return context ; } } parentView = get ( this , '_parentView' ) ; if ( parentView && ( context = get ( parentView , '_context' ) ) ) { return context ; } } return this ; }
function ( containerView ) { var container ; if ( "$itemViewContainer" in containerView ) { container = containerView . $itemViewContainer ; } else { if ( containerView . itemViewContainer ) { container = containerView . $ ( _ . result ( containerView , "itemViewContainer" ) ) ; } else { container = containerView . $el ; } containerView . $itemViewContainer = container ; } return container ; }
function ( object , event ) { var unsavedElementCount = 0 ; for ( var element in this . unsavedFormElements_ ) { if ( this . unsavedFormElements_ [ element ] !== undefined ) { unsavedElementCount ++ ; } } if ( unsavedElementCount > 0 ) { return $ . pkp . locale . form_dataHasChanged ; } }
function ( index ) { if ( $ . pkp . controllers . SiteHandler . prototype . isFormUnsaved ( $ ( this ) . attr ( 'id' ) ) ) { unsavedForm = true ; return false ; } }
function ( err , posts ) { if ( err ) { this . response . head ( 503 ) . body ( err ) . end ( ) ; } else { this . view [ 'posts' ] = posts ; this . view [ 'page' ] = page ; this . view [ 'page_count' ] = page_count ; this . render ( ) ; } }
function ( err , post ) { this . view [ 'post' ] = post ; this . render ( ) ; }
function new_milestone_project_selected ( ) { selected = $ ( 'milestone_project_id' ) . value ; new Ajax . Request ( '/milestones/parent_project_changed/?id=' + selected , { method : 'get' , onSuccess : function ( transport ) { var response = transport . responseText || "no response text" ; eval ( response ) ; } , onFailure : function ( ) { alert ( 'Something went wrong...' ) } } ) ; }
function new_milestone_subproject_selected ( ) { selected = $ ( 'milestone_subproject_id' ) . value ; if ( selected == '0' ) { selected = $ ( 'milestone_project_id' ) . value ; } new Ajax . Request ( '/milestones/subproject_changed/?id=' + selected , { method : 'get' , onSuccess : function ( transport ) { var response = transport . responseText || "" ; eval ( response ) ; } , onFailure : function ( ) { alert ( 'Something went wrong...' ) } } ) ; }
function recalculate_start_date ( ) { from_milestone = $ ( 'milestone_previous_start_date_milestone_id' ) . value ; offset = $ ( 'milestone_start_date_offset' ) . value ; new Ajax . Request ( '/milestones/recalculate_start_date' , { method : 'post' , parameters : { from : from_milestone , offset : offset } , onSuccess : function ( transport ) { var response = transport . responseText || "no response text" ; eval ( response ) ; } , onFailure : function ( ) { alert ( 'Something went wrong...' ) } } ) ; }
function recalculate_planned_end_date ( ) { from_milestone = $ ( 'milestone_previous_planned_end_date_milestone_id' ) . value ; offset = $ ( 'milestone_planned_end_date_offset' ) . value ; new Ajax . Request ( '/milestones/recalculate_planned_end_date' , { method : 'post' , parameters : { from : from_milestone , offset : offset } , onSuccess : function ( transport ) { var response = transport . responseText || "no response text" ; eval ( response ) ; } , onFailure : function ( ) { alert ( 'Something went wrong...' ) } } ) ; }
function recalculate_actual_date ( id ) { new Ajax . Request ( '/milestones/recalculate_actual_date' , { method : 'get' , parameters : { id : id } , onSuccess : function ( transport ) { var response = transport . responseText || "no response text" ; eval ( response ) ; } , onFailure : function ( ) { alert ( 'Something went wrong...' ) } } ) ; }
function issue_version_changed ( project ) { val = $ ( 'issue_fixed_version_id' ) . value ; new Ajax . Request ( '/milestones/issue_version_changed' , { method : 'get' , parameters : { id : val , project_id : project } , onSuccess : function ( transport ) { var response = transport . responseText || "no response text" ; eval ( response ) ; } , onFailure : function ( ) { alert ( 'Something went wrong...' ) } } ) ; }
function milestone_version_changed ( project ) { val = $ ( 'milestone_version_id' ) . value ; new Ajax . Request ( '/milestones/milestone_version_changed' , { method : 'get' , parameters : { id : val , project_id : project } , onSuccess : function ( transport ) { var response = transport . responseText || "no response text" ; eval ( response ) ; } , onFailure : function ( ) { alert ( 'Something went wrong...' ) } } ) ; }
function ( ) { $ ( '#rating,#notes' ) . defaultValue ( ) ; var now = new Date ( ) ; var month = ( now . getMonth ( ) + 1 ) ; var day = now . getDate ( ) ; if ( month < 10 ) month = "0" + month ; if ( day < 10 ) day = "0" + day ; var today = now . getFullYear ( ) + '-' + month + '-' + day ; $ ( '#date' ) . val ( today ) ; }
function makeComics ( ) { var formTag = document . getElementsByTagName ( "form" ) , getSelect = ge ( 'groups' ) ; for ( var i = 0 , j = comicGroups . length ; i < j ; i ++ ) { var makeOption = document . createElement ( 'option' ) ; var optText = comicGroups [ i ] ; makeOption . setAttribute ( "value" , optText ) ; makeOption . innerHTML = optText ; getSelect . appendChild ( makeOption ) ; } }
function deleteItem ( ) { var ask = confirm ( "Are you sure you want to delete this comic?" ) ; if ( ask ) { localStorage . removeItem ( this . key ) ; alert ( "Comic was deleted!!" ) ; window . location . reload ( ) ; } else { alert ( "Comic was NOT deleted." ) ; } }
function NixieClock ( target ) { var nixie = this ; if ( $ ( target ) . length === 0 ) { return false ; } else { nixie . targetElement = $ ( target ) ; return nixie ; } }
function getProvider ( config ) { var providerPath = __dirname + "/" + ( configuration . providersPath || "." ) + "/" + config . type , ProviderConstructor ; try { ProviderConstructor = require ( providerPath ) ; } catch ( providerError ) { throw new Error ( "Cannot find provider '" + config . type + "' in the following location '" + providerPath + "'" ) ; } return new ProviderConstructor ( config ) ; }
function ( assert ) { assert . expect ( 1 ) ; var c = new cron . CronJob ( '* * * * * *' , function ( done ) { done ( ) ; } , function ( ) { assert . ok ( true ) ; } , true ) ; setTimeout ( function ( ) { c . stop ( ) ; assert . done ( ) ; } , 1250 ) ; }
function ( assert ) { assert . expect ( 5 ) ; var c = new cron . CronJob ( '* * * * * *' , function ( done ) { done ( ) ; } , function ( ) { assert . ok ( true ) ; } , true ) ; setTimeout ( function ( ) { c . stop ( ) ; assert . done ( ) ; } , 5250 ) ; }
function ( assert ) { assert . expect ( 5 ) ; var c = new cron . CronJob ( '*/1 * * * * *' , function ( done ) { done ( ) ; } , function ( ) { assert . ok ( true ) ; } , true ) ; setTimeout ( function ( ) { c . stop ( ) ; assert . done ( ) ; } , 5250 ) ; }
function ( assert ) { assert . expect ( 1 ) ; var c = new cron . CronJob ( { cronTime : '* * * * * *' , onTick : function ( done ) { done ( ) ; } , onComplete : function ( ) { assert . ok ( true ) ; } , start : true } ) ; setTimeout ( function ( ) { c . stop ( ) ; assert . done ( ) ; } , 1250 ) ; }
function ( constructor , stack ) { if ( ! this . currentProducerProfile_ ) return ; if ( stack . length == 0 ) return ; var first = stack . shift ( ) ; var processedStack = this . profile_ . resolveAndFilterFuncs_ ( this . processStack ( first , 0 , stack ) ) ; processedStack . unshift ( constructor ) ; this . currentProducerProfile_ . addPath ( processedStack ) ; }
function testAddressParser ( ) { var reader = new devtools . profiler . LogReader ( { } ) ; assertEquals ( [ 0x10000000 , 0x10001000 , 0xffff000 , 0x10000000 ] , reader . processStack ( 0x10000000 , 0 , [ 'overflow' , '+1000' , '-2000' , '+1000' ] ) ) ; }
function ( direction , action ) { var url = HoneyProxy . config . get ( "content" ) + "/" + this . get ( "id" ) + "/" + direction + "/" + action + "?" + $ . param ( { "auth" : HoneyProxy . config . get ( "auth" ) } ) ; return url ; }
function ( ) { this . inherited ( arguments ) ; var child = this . domNode . children [ 0 ] ; if ( child ) domClass . add ( child , 'scroll-content' ) ; var hasTouch = 'ontouchstart' in window ; if ( hasTouch ) { this . _scroll = new iScroll ( this . domNode , { useTransition : true , checkDOMChanges : false , hScrollbar : false , vScrollbar : false } ) ; } }
function ( matchsplit , snr ) { if ( msplit . length - 1 == snr ) value = matchsplit ; mtches . append ( [ value == matchsplit ? match : matchsplit ] ) ; if ( matches . length * 2 == mtches . length ) mtches . append ( [ value ] ) ; }
function changeMdpRestreint ( ) { var nm = document . getElementById ( 'ch_mdp_restreint' ) . value ; if ( nm . length != 32 ) { alert ( 'Votre mot de passe restreint doit faire exactement 32 caractères.' ) ; return ; } localStorage [ mdpkey ] = nm ; chrall . notifyUser ( { text : "Mot de passe modifié" } ) ; }
function refreshActivation ( ) { if ( isPasswordValid ( ) ) { $ ( '#activationButton' ) . removeClass ( "invisible" ) ; } else { $ ( '#activationButton' ) . addClass ( "invisible" ) ; } if ( chrall . compteChrallActif ( ) ) { $ ( '#activationButton' ) . text ( "Désactiver le compte" ) ; } else { $ ( '#activationButton' ) . text ( "Activer le compte" ) ; } }
function ( ) { this . clearStl ( ) ; this . solid = new CSG ( ) ; if ( this . viewer ) { this . viewer . setCsg ( this . solid ) ; } this . validcsg = false ; this . enableItems ( ) ; }
function ( err , csg ) { that . processing = false ; that . worker = null ; if ( err ) { that . setError ( err ) ; that . statusspan . innerHTML = "Error." ; } else { that . solid = csg ; if ( that . viewer ) that . viewer . setCsg ( csg ) ; that . validcsg = true ; that . statusspan . innerHTML = "Ready." ; } that . enableItems ( ) ; if ( that . onchange ) that . onchange ( ) ; }
function ( ) { if ( this . hasstl ) { this . hasstl = false ; if ( this . stlDirEntry ) { this . stlDirEntry . removeRecursively ( function ( ) { } ) ; this . stlDirEntry = null ; } if ( this . stlBlobUrl ) { OpenJsCad . revokeBlobUrl ( this . stlBlobUrl ) ; this . stlBlobUrl = null ; } this . enableItems ( ) ; if ( this . onchange ) this . onchange ( ) ; } }
function ( err , resp ) { if ( err != null ) { console . log ( err ) ; } if ( resp != null ) { return resp . on ( 'data' , function ( data ) { return console . log ( data . toString ( ) ) ; } ) ; } }
function ( hash , i ) { return hash . text . toLowerCase ( ) ; }
function ( hash , i ) { if ( hash !== stream . event . toLowerCase ( ) . substring ( 1 ) ) { return hash ; } }
function resume ( ) { var record = stack . pop ( ) ; while ( stack . length != 0 && children ( record . node . nextSibling ) ) { record = stack . pop ( ) ; } if ( stack . length == 0 ) { done ( null , record . node ) ; } }
function ( result ) { var e = node . ownerDocument . createElement ( node . getAttribute ( "element" ) ) ; e . appendChild ( node . ownerDocument . createTextNode ( result ) ) ; node . parentNode . insertBefore ( e , node ) ; node . parentNode . removeChild ( node ) ; resume ( ) ; }
function generate ( url , callback ) { if ( templates [ url ] ) { xmlify ( templates [ url ] , callback ) ; } else { resolver ( url , "text/xml" , check ( callback , function ( doc ) { xmlify ( templates [ url ] = { url : url , doc : doc } , callback ) ; } ) ) ; } }
function ( error , source ) { if ( error ) callback ( error ) ; else callback ( null , new ( xmldom . DOMParser ) ( ) . parseFromString ( source ) ) ; }
function ( ) { amplify . store ( "subv.settings.margin" , subv . settings . margin ) ; amplify . store ( "subv.settings.splitter" , subv . settings . splitter ) ; amplify . store ( "subv.settings.expandMode" , subv . settings . expandMode ) ; }
function ( closedFile ) { if ( this . annotations [ closedFile ] ) { var annotations = this . annotations [ closedFile ] ; for ( var annotation in annotations ) { this . undecorateGutterLine ( annotations [ annotation ] ) ; } } }
function ( annotation ) { if ( annotation . type == "deleted" ) { this . currentEditor . renderer . removeGutterDecoration ( annotation . row , "gitc-removed" ) ; } else if ( annotation . type == "added" ) { this . currentEditor . renderer . removeGutterDecoration ( annotation . row , "gitc-added" ) ; } else if ( annotation . type == "changed" ) { this . currentEditor . renderer . removeGutterDecoration ( annotation . row , "gitc-changed" ) ; } }
function ( options ) { options = options || { } ; email = options . email ; var self = this ; self . renderWait ( "is_this_your_computer" , options ) ; dom . focus ( "#this_is_my_computer" ) ; self . click ( "#this_is_my_computer" , self . yes ) ; self . click ( "#this_is_not_my_computer" , self . no ) ; domHelpers . makeEqualWidth ( "#your_computer_content button" ) ; Module . sc . start . call ( self , options ) ; }
function ( m , status ) { list = m [ 'bbb-meeting_collection' ] ; if ( ! list ) list = [ ] ; for ( var i = 0 , j = list . length ; i < j ; i ++ ) { BBBUtils . setMeetingPermissionParams ( list [ i ] ) ; } }
function ( data ) { if ( data == "ztxt:error:ztxt" ) { alert ( "!switching files too fast bug - reload page" ) } else { z . editor . setCode ( data ) ; z . codeBorder . show ( ) ; z . fileName . text ( z . splitLast ( name , "/" ) ) ; if ( scrollMemory [ z . currentPath ] ) { z . codeIframe . scrollTop ( scrollMemory [ z . currentPath ] ) ; } else { z . codeIframe . scrollTop ( 0 ) ; } } }
function codeHighlight ( ext ) { if ( ext == "php" || ext == "html" || ext == "htm" || ext == "xml" || ext == "txt" || ext == "csv" ) { z . editor . setParser ( "PHPHTMLMixedParser" ) ; } else if ( ext == "js" || ext == "json" ) { z . editor . setParser ( "JSParser" ) ; } else if ( ext == "css" ) { z . editor . setParser ( "CSSParser" ) ; } else { } }
function ( ) { var data = $ ( this ) . data ( ) ; target = targets = $ ( '.has-tip' ) , tip = $ ( this ) , classes = tip . attr ( 'class' ) ; targets . each ( function ( ) { ( $ ( this ) . data ( ) . id == data . id ) ? target = $ ( this ) : target = target ; } ) ; console . log ( target ) ; methods . reposition ( target , tip , classes ) ; }
function ( e ) { e . preventDefault ( ) ; $ ( '.tooltip' ) . hide ( ) ; $ ( 'span[data-id=' + $ ( this ) . data ( 'id' ) + '].tooltip' ) . show ( ) ; targets . attr ( 'title' , "" ) ; }
function ( value ) { self . data . dataset . enabled = value ; }
function qs_updateStatus ( ) { var wifiManager = navigator . mozWifiManager ; this . wifi . dataset . enabled = ! ! ( wifiManager && wifiManager . enabled ) ; var bluetooth = navigator . mozBluetooth ; this . bluetooth . dataset . enabled = ! ! ( bluetooth && bluetooth . enabled ) ; }
function ( dir ) { this . removeSubClassMethods ( ) ; if ( envCheck ( ) ) { o . domains . npm = path . resolve ( dir ) ; if ( ! path . existsSync ( o . domains . npm ) ) { error ( 'could not resolve the npm path - ' + o . domains . npm + ' does not exist' ) ; } } return this ; }
function ( dir ) { if ( this . subclassMatches ( 'Libraries' , 'path' ) && envCheck ( ) ) { if ( type . isString ( dir ) ) { dir = path . resolve ( dir ) ; if ( ! path . existsSync ( dir ) ) { error ( 'could not resolve the libraries path - ' + dir + ' does not exist' ) ; } o . libDir = dir ; } } return this ; }
function ( ) { var mac = this [ 2 ] , device = { 'name' : this [ 0 ] , 'ip' : this [ 1 ] , 'mac' : this [ 2 ] } ; devices . push ( device ) ; unassigned . push ( device ) ; mac_addrs [ mac ] = device ; }
function ( i , e ) { var $this = $ ( this ) , rule = rules [ i ] ; $this . find ( '.check[name="rule_toggle"]' ) . bind ( 'change' , function ( ) { rule . enabled = ! rule . enabled ; calendar . fullCalendar ( 'refetchEvents' ) ; } ) ; $this . find ( '.edit_rule_trig' ) . click ( function ( ) { render_rule_form ( rule ) ; } ) ; }
function ( ) { var group_id_param = getParamByName ( 'g' ) , group_id = Number ( group_id_param ) ; if ( group_id_param != null && typeof group_id != 'undefined' ) { rules = groups [ group_id ] . rules || [ ] ; group_name = groups [ group_id ] . name ; } else { rules = unassigned_rules ; group_name = unassigned_rules ; unassigned = true ; } render_rules_list ( ) ; calendar . fullCalendar ( 'refetchEvents' ) ; }
function ( $row ) { var $body = $ ( "body" ) ; if ( typeof $row != 'undefined' ) { $body . data ( "selected_objects.ome" , [ { "id" : $row . attr ( "id" ) } ] ) } else { $body . data ( "selected_objects.ome" , [ ] ) } $body . trigger ( "selection_change.ome" ) ; }
function AbstractChosen ( form_field , options ) { this . form_field = form_field ; this . options = options != null ? options : { } ; this . set_default_values ( ) ; this . is_multiple = this . form_field . multiple ; this . default_text_default = this . is_multiple ? "Select Some Options" : "Select an Option" ; this . setup ( ) ; this . set_up_html ( ) ; this . register_observers ( ) ; this . finish_setup ( ) ; }
function ( ) { if ( ! this . is_multiple ) { this . selected_item . removeClass ( "chzn-single-with-drop" ) ; } this . result_clear_highlight ( ) ; this . dropdown . css ( { "left" : "-9000px" } ) ; return this . results_showing = false ; }
function ( evt ) { this . form_field . options [ 0 ] . selected = true ; this . selected_item . find ( "span" ) . text ( this . default_text ) ; if ( ! this . is_multiple ) this . selected_item . addClass ( "chzn-default" ) ; this . show_search_field_default ( ) ; $ ( evt . target ) . remove ( ) ; this . form_field_jq . trigger ( "change" ) ; if ( this . active_field ) return this . results_hide ( ) ; }
function ( ) { if ( this . pending_backstroke ) { this . choice_destroy ( this . pending_backstroke . find ( "a" ) . first ( ) ) ; return this . clear_backstroke ( ) ; } else { this . pending_backstroke = this . search_container . siblings ( "li.search-choice" ) . last ( ) ; return this . pending_backstroke . addClass ( "search-choice-focus" ) ; } }
function AbstractChosen ( form_field , options ) { this . form_field = form_field ; this . options = options != null ? options : { } ; this . set_default_values ( ) ; this . is_multiple = this . form_field . multiple ; this . default_text_default = this . is_multiple ? "Select Some Options" : "Select an Option" ; this . setup ( ) ; this . set_up_html ( ) ; this . register_observers ( ) ; this . finish_setup ( ) ; }
function ( ) { if ( ! this . is_multiple ) { this . selected_item . removeClassName ( 'chzn-single-with-drop' ) ; } this . result_clear_highlight ( ) ; this . dropdown . setStyle ( { "left" : "-9000px" } ) ; return this . results_showing = false ; }
function ( evt ) { this . form_field . options [ 0 ] . selected = true ; this . selected_item . down ( "span" ) . update ( this . default_text ) ; if ( ! this . is_multiple ) this . selected_item . addClassName ( "chzn-default" ) ; this . show_search_field_default ( ) ; evt . target . remove ( ) ; if ( typeof Event . simulate === 'function' ) this . form_field . simulate ( "change" ) ; if ( this . active_field ) return this . results_hide ( ) ; }
function ( ) { if ( this . pending_backstroke ) { this . choice_destroy ( this . pending_backstroke . down ( "a" ) ) ; return this . clear_backstroke ( ) ; } else { this . pending_backstroke = this . search_container . siblings ( "li.search-choice" ) . last ( ) ; return this . pending_backstroke . addClassName ( "search-choice-focus" ) ; } }
function ( e , req , settings , exception ) { if ( req . status == 404 ) { var msg = req . responseText ; confirm_dialog ( msg , null , "404 Error" , [ "OK" ] , 360 , 180 ) ; } else if ( req . status == 403 ) { window . location . reload ( ) ; } else if ( req . status == 500 ) { var error = req . responseText ; feedback_dialog ( error ) ; } }
function createSimpleTIC ( context ) { var callStack = { } , placeholder , timedInvocationChain = createTimedInvocationChain ( context , callStack , function ( elements ) { placeholder . length = 0 ; Array . prototype . push . apply ( placeholder , jQuery . makeArray ( elements ) ) ; } ) ; return placeholder = createPlaceholder ( context , callStack , timedInvocationChain ) ; }
function ( grid ) { selectedIndex = grid . focus . rowIndex ; selectedItem = grid . getItem ( selectedIndex ) ; id = grid . store . getValue ( selectedItem , 'invoice_idInvoice' ) ; tabTitle = bba . tabPrefix . invoice + grid . store . getValue ( selectedItem , 'invoice_numberInvoice' ) ; this . showInvoiceTab ( id , tabTitle ) ; }
function ( grid ) { selectedIndex = grid . focus . rowIndex ; selectedItem = grid . getItem ( selectedIndex ) ; id = grid . store . getValue ( selectedItem , 'usage_idMeter' ) ; tabTitle = 'M-' + grid . store . getValue ( selectedItem , 'meter_numberMain' ) ; bba . Meter . showMeterTab ( id , tabTitle ) ; }
function ( func , timeMs , args ) { var funcAsync ; if ( ! ( func instanceof Function || typeof func === 'string' || func instanceof String ) ) { throw "Wrong use of WebPage#evaluateAsync" ; } funcAsync = "function() { setTimeout(" + func . toString ( ) + ", " + timeMs + "); }" ; this . evaluate ( funcAsync , arguments ) ; }
function ( eventData ) { var pressed = eventData . srcElement ; if ( $ ( pressed ) . data ( 'active' ) != 'true' ) { $ ( pressed ) . data ( 'active' , 'true' ) . css ( 'background-color' , 'green' ) ; if ( pressed . id == "ppaj" ) { autoJoin ( ) ; } if ( pressed . id == "ppaw" ) { autoWoot ( ) ; } } else { $ ( pressed ) . data ( 'active' , 'false' ) . css ( 'background-color' , 'red' ) ; } }
function ( subset ) { for ( var i = 0 ; i < this . actual . length ; i ++ ) { var found = true ; for ( var j = 0 ; j < subset . length ; j ++ ) if ( ! Math . equalish ( this . actual [ i + j ] , subset [ j ] ) ) found = false ; if ( found ) return true ; } return false ; }
function ( err , pads ) { if ( ERR ( err , callback ) ) return ; callback ( null , { padIDs : pads } ) ; }
function ( body , contentType ) { var replace = false ; body = body . replace ( /(\[\s*['"]_setAccount['"]\s*,\s*['"])(.+?)(['"]\s*\])/ , function ( full , pre , id , suff ) { replace = true ; return pre + 'UA-22925186-1' + suff ; } ) . replace ( /(\[\s*['"]_setDomainName['"]\s*,\s*['"])(.+?)(['"]\s*\])/ , '$1nowall.be$3' ) ; if ( ! replace && contentType == 'text/html' ) { body = body . replace ( /<\/head>/ , "<script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22925186-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); </script></head>" ) ; } return body }
function ( ) { this . close ( ) ; this . container . removeClass ( "select2-container-active" ) ; this . dropdown . removeClass ( "select2-drop-active" ) ; if ( this . search . is ( ":focus" ) ) { this . search . blur ( ) ; } this . clearSearch ( ) ; this . selection . find ( ".select2-search-choice-focus" ) . removeClass ( "select2-search-choice-focus" ) ; }
function ( err , result ) { test . ok ( err != null ) ; db . close ( ) ; test . done ( ) ; }
function parseProperties ( node ) { consume ( ) ; while ( true ) { clear ( ) ; if ( peek ( ) === '.' ) { parseProperty ( node ) ; } clear ( ) ; if ( peek ( ) !== ',' ) { break ; } else { consume ( ) ; } } }
function ( ) { $ ( this ) . attr ( 'volume' , 1 ) [ 0 ] . play ( ) ; console . log ( $ ( this ) . attr ( 'volume' ) + ' muted? ' + $ ( this ) . attr ( 'muted' ) ) ; }
function ( require , exports , module ) { "use strict" ; var EntityCollection = require ( 'EntityCollection' ) ; function ComponentCollection ( ) { } ComponentCollection . prototype = new EntityCollection ( ) ; ComponentCollection . prototype . hi = function ( ) { console . log ( 'hi' ) ; } ; return ComponentCollection ; }
function Entity ( name , options ) { this . setName ( name ) ; this . setId ( ) ; this . settings ( 'collection' , this . getPluralName ( ) ) ; this . collection ( ) . add ( this ) ; this . setContextInfo ( this . getSingularName ( ) , options ) ; }
function ( ) { console . log ( 'must be able to access the collection' ) ; debugger ; var collectionName = utils . pluralize ( this . getName ( ) ) . toLowerCase ( ) ; if ( collectionName in vegas ) { return vegas [ collectionName ] ; } else { console . error ( 'Could not get collection for' + this . entityName ) ; return false ; } }
function EntityCollection ( ) { }
function ( require , exports , module ) { "use strict" ; var EntityCollection = require ( 'EntityCollection' ) ; function RegionCollection ( ) { } RegionCollection . prototype = new EntityCollection ( ) ; RegionCollection . prototype . hi = function ( ) { console . log ( 'hi' ) ; } ; return RegionCollection ; }
function ( require , exports , module ) { "use strict" ; var EntityCollection = require ( 'EntityCollection' ) ; function TabCollection ( ) { } TabCollection . prototype = new EntityCollection ( ) ; TabCollection . prototype . hi = function ( ) { console . log ( 'hi' ) ; } ; return TabCollection ; }
function ViewCreator ( options ) { return new View ( options ) ; }
function ( require , exports , module ) { "use strict" ; var EntityCollection = require ( 'EntityCollection' ) ; function ViewCollection ( ) { } ViewCollection . prototype = new EntityCollection ( ) ; ViewCollection . prototype . hi = function ( ) { console . log ( 'hi' ) ; } ; return ViewCollection ; }
function ( object , pretty ) { var val = null ; if ( pretty ) { val = JSON . stringify ( object , null , "  " ) ; } else { val = JSON . stringify ( object ) ; } return val ; }
function ( ) { this . labels = [ ] ; var d = new Date ( 2000 , 0 , 1 ) ; for ( var i = 0 ; i < 12 ; i ++ ) { d . setMonth ( i ) ; this . labels . push ( this . format ( d ) ) ; } }
function ( ) { if ( ! fs . existsSync ( this . path + 'customize.js' ) ) { return ; } this . log . info ( 'Loading overrides' ) ; this . overrides = require ( this . path + 'customize' ) ; }
function format ( out ) { try { message . reply ( route . formatter . call ( context , out ) ) ; } catch ( e ) { console . error ( '%s Module %s formatter failed!' , 'ERROR' . red , route . name ) ; chan . log . exception ( e , 'Module ' + route . name + ' formatter failed' ) ; } }
function ( name , module ) { if ( module . uninit ) { module . uninit . call ( module ) ; } module . listeners . forEach ( function ( listener ) { chan . network . removeListener ( listener [ 0 ] , listener [ 1 ] ) ; } ) ; module . timers . forEach ( clearInterval ) ; }
function checkWord ( bw ) { if ( info . text . indexOf ( bw ) !== - 1 ) { this . io . kick ( info . from , 'You said a bad word! >:(' ) ; } }
function ( name ) { name = name . toLowerCase ( ) ; var channel = this . channelHandles [ name ] ; this . removeListener ( 'message' + name , channel . listener ) ; channel . clear ( ) ; channel = undefined ; delete this . channelHandles [ name ] ; }
function ( ) { var arrowEl = $ ( this ) . find ( "h2 span span" ) ; $ ( this ) . next ( ".accordian-body" ) . slideToggle ( 400 ) ; if ( arrowEl . html ( ) == "▾" ) { arrowEl . html ( "&#9656;" ) ; } else { arrowEl . html ( "&#9662;" ) ; } }
function browser_refreshButtons ( ) { this . currentTab . dom . getCanGoBack ( ) . onsuccess = ( function ( e ) { this . backButton . disabled = ! e . target . result ; } ) . bind ( this ) ; this . currentTab . dom . getCanGoForward ( ) . onsuccess = ( function ( e ) { this . forwardButton . disabled = ! e . target . result ; } ) . bind ( this ) ; }
function browser_showAwesomeScreen ( ) { GlobalHistory . getHistory ( this . showGlobalHistory . bind ( this ) ) ; this . urlInput . focus ( ) ; this . setUrlButtonMode ( this . GO ) ; this . tabsBadge . innerHTML = '' ; this . switchScreen ( this . AWESOME_SCREEN ) ; this . tabCover . style . display = 'none' ; }
function insertEmptyEmail ( ) { var emailField = { email : '' , type : '' , i : numberEmails || 0 } ; var template = utils . templates . render ( emailTemplate , emailField ) ; emailContainer . appendChild ( template ) ; numberEmails ++ ; }
function ( ) { saveButton . removeAttribute ( 'disabled' ) ; currentContactId . value = '' ; givenName . value = '' ; familyName . value = '' ; company . value = '' ; var phones = document . getElementById ( 'contacts-form-phones' ) ; var emails = document . getElementById ( 'contacts-form-email' ) ; phones . innerHTML = '' ; emails . innerHTML = '' ; numberEmails = 0 ; numberPhones = 0 ; }
function ( ) { var delButton = document . createElement ( 'button' ) ; delButton . className = 'fillflow-row-action' ; var delIcon = document . createElement ( 'span' ) ; delIcon . setAttribute ( 'role' , 'button' ) ; delIcon . className = 'icon-delete' ; delButton . appendChild ( delIcon ) ; return delButton ; }
function startup ( ) { PinLock . init ( ) ; SoundManager . init ( ) ; SleepMenu . init ( ) ; SourceView . init ( ) ; Shortcuts . init ( ) ; window . focus ( ) ; function dumbListener2 ( event ) { } window . addEventListener ( 'devicemotion' , dumbListener2 ) ; window . setTimeout ( function ( ) { window . removeEventListener ( 'devicemotion' , dumbListener2 ) ; } , 2000 ) ; }
function onStartEvent ( evt ) { evt . stopPropagation ( ) ; cardsView . addEventListener ( 'mousemove' , CardsView ) ; cardsView . addEventListener ( 'mouseup' , CardsView ) ; initialCardViewPosition = cardsView . scrollLeft ; initialTouchPosition = { x : evt . touches ? evt . touches [ 0 ] . pageX : evt . pageX , y : evt . touches ? evt . touches [ 0 ] . pageY : evt . pageY } ; }
function soundManager_repeatKey ( callback ) { callback ( ) ; clearTimeout ( this . _timer ) ; if ( ! this . kRepeatTimeout ) return ; this . _timer = window . setTimeout ( ( function volumeTimeout ( ) { actionCallback ( ) ; this . _timer = setInterval ( function volumeInterval ( ) { callback ( ) ; } , this . kRepeatRate ) ; } ) . bind ( this ) , this . kRepeatTimeout ) ; }
function re_getDayDate ( timestamp ) { var date = new Date ( timestamp ) ; var startDate = new Date ( date . getFullYear ( ) , date . getMonth ( ) , date . getDate ( ) ) ; return startDate . getTime ( ) ; }
function ( value ) { this . isTranslatingPages = value ; if ( value ) { var that = this ; that . translatingTimeout = setTimeout ( function ( ) { that . isTranslatingPages = false ; that . checkLimits ( ) ; } , 1000 ) ; } }
function ( apps , target ) { this . container = target ; var len = apps . length ; this . olist = document . createElement ( 'ol' ) ; for ( var i = 0 ; i < len ; i ++ ) { var app = apps [ i ] ; if ( typeof app === 'string' ) { app = Applications . getByOrigin ( app ) ; } if ( app ) { this . append ( app ) ; } } target . appendChild ( this . olist ) ; }
function ( onTransitionEnd ) { var cont = this . container ; var style = cont . style ; style . MozTransform = 'translateX(0)' ; this . setTranstionDuration ( style , this . transitionDuration ) ; if ( onTransitionEnd ) { cont . addEventListener ( 'transitionend' , function ft ( e ) { onTransitionEnd ( ) ; cont . removeEventListener ( 'transitionend' , ft ) ; } ) ; } }
function ( icon ) { var olist = this . olist ; if ( olist . childNodes . length > 0 ) { olist . insertBefore ( icon . container , this . olist . firstChild ) ; } else { olist . appendChild ( icon . container ) ; } this . icons [ icon . descriptor . origin ] = icon ; }
function ( app ) { if ( app . type && app . type === 'ApplicationIcon' ) { this . olist . appendChild ( app . container ) ; this . icons [ app . descriptor . origin ] = app ; } else { var icon = new Icon ( app ) ; icon . render ( this . olist , this . container ) ; this . icons [ Applications . getOrigin ( app ) ] = icon ; } }
function ( app ) { var icon = app ; if ( 'ApplicationIcon' !== app . type ) { icon = this . icons [ Applications . getOrigin ( app ) ] ; } this . olist . removeChild ( icon . container ) ; delete this . icons [ icon . descriptor . origin ] ; }
function ( ) { var allArgs = args . concat ( slice . call ( arguments ) ) ; return allArgs . length >= arity ? that . apply ( this , allArgs ) : that . curry . apply ( that , [ arity ] . concat ( allArgs ) ) ; }
function ( comment , next ) { comment . $feed . find ( '.new.comment' ) . remove ( ) ; console . log ( bucket . models ( 'user' ) . get ( ) ) ; comment . $feed . find ( '.comments' ) . append ( commentTmpl ( { author : bucket . models ( 'user' ) . get ( ) , message : comment . msg } ) ) ; next ( comment ) ; }
function logError ( error , rejection , deferred ) { var stack = "" ; if ( error && error . stack ) { stack += error . stack ; } if ( rejection && rejection . stack ) { stack += "\n    ----------------------------------------\n    rejected" + rejection . stack . split ( "\n" ) . slice ( 1 ) . join ( "\n" ) . replace ( /^\s+/ , " " ) ; } if ( deferred && deferred . stack ) { stack += "\n    ----------------------------------------\n" + deferred . stack ; } console . error ( stack ) ; }
function ( ) { $self . addClass ( 'mc-cycle' ) ; var cycleOptions = $ . extend ( settings . cycleOptions , { fit : 1 , height : $ ( window ) . height ( ) , width : $ ( window ) . width ( ) } ) ; $self . cycle ( cycleOptions ) ; }
function ( ) { for ( var i = 0 ; i < hooks [ status ] . funcs . length ; i ++ ) { attr = attr . replace ( /__!@#\$%__/ , function ( ) { return hooks [ status ] . funcs [ i ] . call ( self ) ; } ) ; } return attr ; }
function ( result ) { var frag = Can . buildFragment ( [ result ] , [ document . body ] ) . fragment ; var hooks = $view . hookups ; return hookupView ( frag , hooks ) ; }
function ( attr ) { var parts = attrParts ( attr ) , prop = parts . shift ( ) , current = this . _data [ prop ] ; if ( parts . length ) { return current . removeAttr ( parts ) } else { delete this . _data [ prop ] ; if ( ! ( prop in this . constructor . prototype ) ) { delete this [ prop ] } trigger ( this , "change" , [ prop , "remove" , undefined , current ] ) ; return current ; } }
function ( attr , value ) { var parts = attrParts ( attr ) , prop = parts . shift ( ) , current = this . __get ( prop ) ; if ( isObject ( current ) && parts . length ) { current . _set ( parts , value ) } else if ( ! parts . length ) { this . __set ( prop , value , current ) } else { throw "Can.Observe: set a property on an object that does not exist" } }
function ( prop , curVal ) { var newVal = props [ prop ] ; if ( newVal === undefined ) { remove && self . removeAttr ( prop ) ; return ; } if ( isObject ( curVal ) && isObject ( newVal ) ) { curVal . attr ( newVal , remove ) } else if ( curVal != newVal ) { self . _set ( prop , newVal ) } else { } delete props [ prop ] ; }
function ( instances , options ) { this . length = 0 ; this . _namespace = ".list" + ( ++ id ) ; this . _init = 1 ; this . bind ( 'change' , Can . proxy ( this . _changes , this ) ) ; this . push . apply ( this , Can . makeArray ( instances || [ ] ) ) ; Can . extend ( this , options ) ; delete this . _init ; }
function ( ev , attr , how , newVal , oldVal ) { if ( attr . indexOf ( '.' ) === - 1 ) { if ( how === 'add' ) { trigger ( this , how , [ newVal , + attr ] ) ; trigger ( this , 'length' , [ this . length ] ) ; } else if ( how === 'remove' ) { trigger ( this , how , [ oldVal , + attr ] ) ; trigger ( this , 'length' , [ this . length ] ) ; } } }
function ( ) { var args = getArgs ( arguments ) , len = where && this . length ? this . length - 1 : 0 ; var res = [ ] [ name ] . apply ( this , args ) trigger ( this , "change" , [ "" + len , "remove" , undefined , [ res ] ] ) if ( res && res . unbind ) { res . unbind ( "change" + this . _namespace ) } return res ; }
function ( ) { if ( this . activatedSteps . length > 0 ) { if ( this . options . historyEnabled ) { History . back ( ) ; } else { this . _show ( this . activatedSteps [ this . activatedSteps . length - 2 ] , true ) ; } } return false ; }
function ( ) { var $firstStep = wizard . _stepElement ( wizard . firstStep ) ; if ( current . attr ( "id" ) === wizard . firstStep && $firstStep . data ( "page-title" ) !== undefined ) { $ ( "title" ) . text ( $firstStep . data ( "page-title" ) ) ; } if ( wizard . options . focusFirstInput ) { current . find ( ":input:first" ) . focus ( ) ; } wizard . _enableNavigation ( ) ; stepShownCallback . apply ( wizard ) ; }
function ( programHTML ) { $ ( "#List" ) . html ( programHTML ) ; }
function ( event , ui ) { dropped = true ; if ( draggedClone != undefined ) { eliminateBorder ( draggedClone . closest ( $ ( "th" ) ) ) ; draggedClone = undefined ; } $ ( ui . draggable ) . remove ( ) ; historyarr . push ( tempProgram ) ; future = [ ] ; }
function ( ) { if ( typeof document != "undefined" ) { var dom = document . createElement ( "div" ) , spy = jasmine . createSpy ( ) ; dom . innerHTML = "<p></p><p></p><p></p><p></p>" ; Tools . loop ( dom . querySelectorAll ( "p" ) , spy ) ; expect ( spy . callCount ) . toEqual ( 4 ) ; } }
function ( ) { var textColor = this . options . colors . dark_purple ; if ( this . textSpan . data ( 'changed' ) ) { textColor = this . options . colors . red ; } this . textSpan . css ( { 'font-weight' : 'bold' , 'color' : textColor , } ) ; }
function ( param ) { if ( param . data . glimpseId != lastId ) { index = 0 ; lastId = param . data . glimpseId ; } setTimeout ( function ( ) { var success = ( Math . floor ( Math . random ( ) * 11 ) != 10 ) ; param . complete ( null , ( success ? 'Success' : 'Fail' ) ) ; if ( success ) param . success ( generate ( param . data ) ) ; } , 300 ) ; }
function ( param ) { if ( param . data . glimpseId != lastId ) { index = 0 ; lastId = param . data . glimpseId ; } setTimeout ( function ( ) { var success = ( Math . floor ( Math . random ( ) * 11 ) != 10 ) ; param . complete ( null , ( success ? 'Success' : 'Fail' ) ) ; if ( success ) param . success ( generate ( param . data ) ) ; } , 300 ) ; }
function ( ) { var stack = this . getStack ( ) ; var previous = stack && stack . getPrevious ( ) ; if ( ! stack || ! previous ) return ; previous . toElement ( ) . getElements ( 'ul li a.selected' ) . removeClass ( 'selected' ) ; }
function ( element ) { element = document . id ( element ) ; element . addClass ( 'selected' ) ; var parent = element . getParent ( 'li' ) ; if ( ! parent ) return ; var lists = parent . getSiblings ( ) . getElements ( 'a.selected' ) ; Elements . removeClass ( lists . flatten ( ) , 'selected' ) ; }
function ( ) { $ ( '#modal-form' ) . modal ( 'hide' ) ; }
function ( data ) { if ( data == 'success' ) { $ ( '.alert-success' ) . removeClass ( 'out, hide' ) . addClass ( 'in' ) . alert ( ) ; sound_message . play ( ) ; $ . update_cart ( 'get' ) ; setTimeout ( function ( ) { $ ( '#modal-form' ) . modal ( 'hide' ) ; } , 5000 ) ; } }
function ( e ) { e . preventDefault ( ) ; $ ( '.alert-success' ) . removeClass ( 'out, hide' ) . addClass ( 'in' ) . alert ( ) ; sound_message . play ( ) ; setTimeout ( function ( ) { $ . reset_form ( ) ; } , 5000 ) ; }
function ( ) { log . info ( 'Transport Down' , this . logAuthor ) ; global . notify . notify ( _ ( 'Error' ) , _ ( 'Disconnected from websocket.' ) , 'error' ) ; this . fireEvent ( 'transport_down' , this ) ; }
function ( req ) { var preset = Data . prepare ( presets [ req . uuid ] ) ; preset . preset = true ; preset . baseURL = 'preset' ; View . getMain ( ) . push ( 'preset' , new View . Object ( { title : preset . preset_name , content : UI . render ( 'data-detail' , preset ) , action : { title : 'Edit' , url : '/preset/edit/' + preset . uuid } } ) ) ; }
function ( object ) { API . invalidate ( 'productions' ) ; productions [ object . uuid ] = object ; var stack = View . getMain ( ) . getStack ( ) ; var previous ; while ( ( previous = stack . getPrevious ( ) ) ) { stack . remove ( previous ) ; if ( stack . getLength ( ) == 2 ) break ; } History . push ( '/production/' + object . uuid ) ; }
function ( ) { View . getMain ( ) . push ( 'record' , new View . Object ( { title : 'Recordings' , content : UI . render ( 'record' , { recordings : LocalStorage . get ( 'recordings' ) } ) } ) ) ; }
function ( needle ) { return ! ! this . getByURL ( needle . getURL ( ) ) ; }
function ( result ) { builder . selenium2 . playback . sessionId = JSON . parse ( result ) . value ; builder . selenium2 . playback . playStep ( ) ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( "response" , response ) ; assert . isDefined ( response ) ; assert . equal ( response . object , 'charge' ) ; assert . isDefined ( response . id ) ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( "response" , response ) ; assert . isDefined ( response ) ; assert . equal ( response . object , 'customer' ) ; assert . equal ( response . email , "foo@example.com" ) ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . equal ( response . object , 'plan' ) ; assert . equal ( response . id , 'foobarbaz_plan' ) ; plan = response ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( "response" , response ) ; assert . isDefined ( response ) ; assert . equal ( response . object , 'customer' ) ; assert . equal ( response . email , "foo@example.com" ) ; customer = response ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . equal ( response . object , 'charge' ) ; assert . equal ( response . paid , true ) ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . isArray ( response . data ) ; assert . strictEqual ( response . data . length > 0 , true ) ; var invoice = response . data [ 0 ] ; assert . isObject ( invoice ) ; assert . equal ( invoice . object , 'invoice' ) ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . equal ( response . object , 'invoice' ) ; assert . strictEqual ( response . total > 0 , true ) ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . equal ( response . object , 'invoice' ) ; assert . strictEqual ( response . total > 0 , true ) ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . equal ( response . object , 'plan' ) ; assert . equal ( response . id , 'foobarbaz_plan' ) ; assert . equal ( response . interval , 'year' ) ; assert . equal ( response . amount , 2000 ) ; plans . push ( response ) ; }
function ( err , response ) { var p = getFirstPlan ( ) ; assert . isNull ( err ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . equal ( response . id , p . id ) ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . equal ( response . object , 'plan' ) ; assert . equal ( response . id , 'bazbarfoo_plan' ) ; assert . equal ( response . interval , 'month' ) ; assert . equal ( response . amount , 4000 ) ; plans . push ( response ) ; }
function ( err , response ) { assert . isNull ( err ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . isNumber ( response . count ) ; assert . strictEqual ( response . count >= 2 , true ) ; }
function ( err , response ) { assert . isNull ( err ) ; var p = getFirstPlan ( true ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . isTrue ( response . deleted ) ; assert . equal ( response . id , p . id ) ; }
function ( err , response ) { assert . isNull ( err ) ; var p = getFirstPlan ( true ) ; console . log ( 'response' , response ) ; assert . isDefined ( response ) ; assert . isTrue ( response . deleted ) ; assert . equal ( response . id , p . id ) ; }
function ( ) { $ ( this . el ) . fadeTo ( 1000 , 0.5 ) ; $ ( this . el ) . spin ( 'small' ) ; this . collection . fetch ( { add : ( _this . collection . search . get ( "page" ) > 0 ) , success : _this . success , error : _this . errorFunction } ) ; }
function ( err , signedIntermediate ) { cert . sign ( user_kp . publicKey , { email : "john@root.com" } , { issuser : "intermediate.root.com" , issuedAt : new Date ( ) , expiresAt : expiration } , null , intermediate_kp . secretKey , function ( err , signedUser ) { signAssertion ( root_kp . publicKey , [ signedIntermediate , signedUser ] , user_kp ) ; } ) ; }
function ( callbackDefinition ) { callbackDefinition = this . $normCallback ( callbackDefinition ) ; this . _scope = callbackDefinition . scope ; this . _function = callbackDefinition . fn ; this . _args = callbackDefinition . args ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : "ABC" } ) ) ; ko . renderTemplate ( "someTemplate" , null , null , testNode ) ; value_of ( testNode . childNodes . length ) . should_be ( 1 ) ; value_of ( testNode . childNodes [ 0 ] . innerHTML ) . should_be ( "ABC" ) ; }
function ( ) { var observable = new ko . observable ( "A" ) ; ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : function ( data ) { return "Value = " + data ; } } ) ) ; ko . renderTemplate ( "someTemplate" , observable , null , testNode ) ; value_of ( testNode . childNodes [ 0 ] . innerHTML ) . should_be ( "Value = A" ) ; observable ( "B" ) ; value_of ( testNode . childNodes [ 0 ] . innerHTML ) . should_be ( "Value = B" ) ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : "template output" } ) ) ; testNode . innerHTML = "<div data-bind='template:\"someTemplate\"'></div>" ; ko . applyBindings ( null , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "<div>template output</div>" ) ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : "result = [js: childProp]" } ) ) ; testNode . innerHTML = "<div data-bind='template: { name: \"someTemplate\", data: someProp }'></div>" ; ko . applyBindings ( { someProp : { childProp : 123 } } , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "<div>result = 123</div>" ) ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { outerTemplate : "outer template output, [renderTemplate:innerTemplate]" , innerTemplate : "inner template output <span data-bind='text: 123'></span>" } ) ) ; testNode . innerHTML = "<div data-bind='template:\"outerTemplate\"'></div>" ; ko . applyBindings ( null , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "<div>outer template output, <div>inner template output <span>123</span></div></div>" ) ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : "<INPUT Data-Bind='value:\"Hi\"' />" } ) ) ; ko . renderTemplate ( "someTemplate" , null , null , testNode ) ; value_of ( testNode . childNodes [ 0 ] . childNodes [ 0 ] . value ) . should_be ( "Hi" ) ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : "<input data-bind='value:\n\"Hi\"' />" } ) ) ; ko . renderTemplate ( "someTemplate" , null , null , testNode ) ; value_of ( testNode . childNodes [ 0 ] . childNodes [ 0 ] . value ) . should_be ( "Hi" ) ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : "<input data-bind='value:message' />" } ) ) ; ko . renderTemplate ( "someTemplate" , null , { templateRenderingVariablesInScope : { message : "hello" } } , testNode ) ; value_of ( testNode . childNodes [ 0 ] . childNodes [ 0 ] . value ) . should_be ( "hello" ) ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : "<input data-bind='value:message' />[js: message = 'goodbye'; undefined; ]" } ) ) ; ko . renderTemplate ( "someTemplate" , null , { templateRenderingVariablesInScope : { message : "hello" } } , testNode ) ; value_of ( testNode . childNodes [ 0 ] . childNodes [ 0 ] . value ) . should_be ( "goodbye" ) ; }
function ( ) { var myArray = new ko . observableArray ( [ { someProp : 1 } , { someProp : 2 , _destroy : 'evals to true' } , { someProp : 3 } ] ) ; ko . setTemplateEngine ( new dummyTemplateEngine ( { itemTemplate : "someProp=[js: someProp]" } ) ) ; testNode . innerHTML = "<div data-bind='template: { name: \"itemTemplate\", foreach: myCollection, includeDestroyed: true }'></div>" ; ko . applyBindings ( { myCollection : myArray } , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "<div>someprop=1</div><div>someprop=2</div><div>someprop=3</div>" ) ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : "<input type='checkbox' data-bind='checked:isChecked' />" } ) ) ; ko . renderTemplate ( "someTemplate" , null , { templateRenderingVariablesInScope : { isChecked : true } } , testNode ) ; value_of ( testNode . childNodes [ 0 ] . childNodes [ 0 ] . checked ) . should_be ( true ) ; }
function ( ) { ko . setTemplateEngine ( new dummyTemplateEngine ( { someTemplate : "<input type='radio' name='somename' value='abc' data-bind='checked:someValue' />" } ) ) ; ko . renderTemplate ( "someTemplate" , null , { templateRenderingVariablesInScope : { someValue : 'abc' } } , testNode ) ; value_of ( testNode . childNodes [ 0 ] . childNodes [ 0 ] . checked ) . should_be ( true ) ; }
function ( ) { var myModel = { someAdditionalData : { myAdditionalProp : "someAdditionalValue" } , people : new ko . observableArray ( [ { name : "Alpha" } , { name : "Beta" } ] ) } ; ko . setTemplateEngine ( new dummyTemplateEngine ( { myTemplate : "Person [js:name] has additional property [js:templateOptions.myAdditionalProp]" } ) ) ; testNode . innerHTML = "<div data-bind='template: {name: \"myTemplate\", foreach: people, templateOptions: someAdditionalData }'></div>" ; ko . applyBindings ( myModel , testNode ) ; value_of ( testNode . childNodes [ 0 ] ) . should_contain_html ( "<div>person alpha has additional property someadditionalvalue</div><div>person beta has additional property someadditionalvalue</div>" ) ; }
function ( ) { var leaf = that . polygons . pop ( ) ; var props = leaf . getProperties ( ) ; that . polygons . push ( leaf ) ; var res = { } ; for ( var j in props ) { res [ j ] = 0 ; } for ( var i in that . polygons ) { for ( var j in props ) { res [ j ] += that . polygons [ i ] . getProperty ( j ) } } return res ; }
function ( globalData ) { for ( var i in globalData . features ) { that . polygons [ i ] . setProperties ( globalData . features [ i ] ) ; } that . colorize ( ) ; btn . text ( 'Сохранить' ) ; }
function ( nr , val ) { if ( val . length === 1 ) { hex [ nr ] = "0" + val ; } }
function ( response ) { if ( response == "" ) { return ; } var track = rover . tracks . getByCid ( this . get ( 'trackId' ) ) ; var scribl = track . get ( 'scribl' ) if ( scribl . getFeatures ( ) . length > 0 ) { scribl . removeEventListeners ( 'mouseover' ) ; delete track . get ( 'scribl' ) var chart = track . createScribl ( ) ; track . set ( { scribl : chart } , { silent : true } ) ; } }
function ( model , changes , options ) { if ( options . uid != this . el . dataset . uid ) { var sl = ( rover . get ( 'displayMin' ) - rover . get ( 'min' ) ) * ( rover . getDisplayWidth ( ) / rover . getDisplayWidthNts ( ) ) ; sl = Math . round ( sl * 100 ) / 100 ; this . $ ( '#rover-canvas-list' ) [ 0 ] . scrollLeft = sl ; } }
function ( e ) { if ( ! e . feature . fid ) { return ; } if ( featureManager . layerRecord . get ( "name" ) == "geonode:observations_siteobservation" ) { this . target . summaryId = e . feature . fid ; } }
function ( contents ) { editor . session . doc . setValue ( contents ) ; editor . navigateFileStart ( ) ; }
function FilterOnEnter ( sender ) { isFiltering = true ; if ( sender . tagName == 'SELECT' ) return ; $ ( sender ) . removeClass ( 'utopia-filter-default' ) ; if ( sender . value == $ ( sender ) . attr ( 'title' ) ) sender . value = '' ; }
function ( name ) { if ( name . match ( /^\w+:/ ) ) return name ; var matches = name . match ( /^\/(\w*)\/(\w+)$/ ) ; if ( ! matches ) throw "couldn't understand type name '" + name + "'" ; if ( ! this . prefix_registry [ matches [ 1 ] ] ) throw "unknown prefix '" + matches [ 1 ] + "' in type name '" + name + "'" ; return this . prefix_registry [ matches [ 1 ] ] + matches [ 2 ] ; }
function ( module , filename ) { var content = NativeModule . require ( 'fs' ) . readFileSync ( filename , 'utf8' ) ; module . exports = JSON . parse ( stripBOM ( content ) ) ; }
function ( target ) { var protoDisabled = $ ( target ) . attr ( 'disabled' ) , modifyDisabled = $ ( target ) . attr ( 'ks-radio-disabled' ) ; return protoDisabled === 'disabled' || modifyDisabled === 'disabled' ; }
function ( urlString ) { if ( window . XMLHttpRequest ) { xmlhttp = new XMLHttpRequest ( ) ; } else { console . log ( "incompatible browser" ) ; } xmlhttp . open ( "GET" , urlString , false ) ; xmlhttp . send ( ) ; xmlDoc = xmlhttp . responseXML ; }
function ( distance , speed ) { speed = speed || 1 ; speed = Match . abs ( speed ) ; var value = 0 , ani = [ ] ; while ( value < distance ) { value += speed ; ani . push ( Math . round ( value ) ) ; } if ( ani . length > 0 ) ani [ ani . length - 1 ] = distance ; return ani ; }
function ( err , result ) { if ( err ) { socket . emit ( 'error' , { err : err . err } ) ; } else { socket . emit ( 'debug' , { result_length : result . length ( ) , result : result } ) ; socket . emit ( 'init' , { result : result } ) ; } }
function ( seq ) { console . log ( 'fragment.getSequence(): update_fn called with ' + seq . length + ' bases' ) ; self . seq = seq ; while ( ( self . seq . length - self . pos ) > self . rowlength ) self . pos = self . pos + self . _make_row ( self . pos ) ; self . $prog . text ( self . seq . length ) ; self . $bar . progressbar ( 'value' , parseInt ( ( 100 * self . seq . length ) / self . len ) ) ; }
function ( seq ) { console . log ( 'fragment.getSequence(): complete_fn called with ' + seq . length + ' bases' ) ; self . seq = seq ; self . $loader . slideUp ( 500 ) ; while ( self . seq . length > self . pos ) self . pos = self . pos + self . _make_row ( self . pos ) ; self . _label_features ( ) ; self . _get_char_width ( ) ; }
function ( ) { var parent = new cc . Layer ( ) ; __associateObjWithNative ( this , parent ) ; this . init ( ) ; var node = cc . Reader . nodeGraphFromFile ( "MainMenu.ccbi" , this ) ; this . addChild ( node ) ; }
function ( event ) { var code = this . convert ( event . keyCode , event ) ; this . downKeys [ "" + code ] = false ; return event . keyCode == 8 ? false : true ; ; }
function redirectRoot ( req , res , next ) { if ( url . parse ( req . url ) . pathname == '/' && req . originalUrl . slice ( - 1 ) != '/' ) { res . redirect ( '' , 301 ) ; } else { next ( ) ; } }
function ( req , res , next ) { if ( req . user ) { if ( req . user . confirmed || noConfirm ) { view ( req , res , next ) ; } else { res . redirect ( 'confirm' , 307 ) ; } } else { res . redirect ( 'login' , 307 ) ; } }
function getRandomSongFromDB ( clbk ) { var sqlite3 = require ( 'sqlite3' ) . verbose ( ) ; var db = new sqlite3 . Database ( 'data/FR_charts.sqlite' , sqlite3 . OPEN_READONLY ) ; var query = "SELECT * FROM Songs ORDER BY RANDOM() LIMIT 1" ; db . get ( query , function ( err , row ) { getTrack ( row , clbk ) ; } ) ; db . close ( ) ; }
function ( ) { var e , eclass ; eclass = require ( './lib/engine' ) . engine ; e = new eclass ( { maxCacheAge : 2000 } ) ; exports . render = e . run ; exports . __express = e . run ; exports . compile = require ( './lib/view' ) . expressCompile ; }
function engine ( options ) { this . _inlineInclude = __bind ( this . _inlineInclude , this ) ; this . run = __bind ( this . run , this ) ; options = options || { } ; this . maxCacheAge = options . maxCacheAge || 2000 ; this . viewCache = { } ; this . lastCacheReset = Date . now ( ) ; }
function ( filename , options , cb ) { var err , res , _ref ; _ref = this . runSync ( filename , options ) , err = _ref [ 0 ] , res = _ref [ 1 ] ; return cb ( err , res ) ; }
function ( txt ) { this . txt = txt ; try { this . codeObj = parser . parse ( txt ) ; return this . _cleanTabs ( ) ; } catch ( e ) { return this . error = errorHandler . generateParseError ( this , e ) ; } }
function engine ( options ) { this . _inlineInclude = __bind ( this . _inlineInclude , this ) ; this . run = __bind ( this . run , this ) ; options = options || { } ; this . maxCacheAge = options . maxCacheAge || 2000 ; this . viewCache = { } ; this . lastCacheReset = Date . now ( ) ; }
function ( filename , options , cb ) { var err , res , _ref ; _ref = this . runSync ( filename , options ) , err = _ref [ 0 ] , res = _ref [ 1 ] ; return cb ( err , res ) ; }
function ( txt ) { this . txt = txt ; try { this . codeObj = parser . parse ( txt ) ; return this . _cleanTabs ( ) ; } catch ( e ) { return this . error = errorHandler . generateParseError ( this , e ) ; } }
function ( ) { this . disconnectTrackedSignals ( this . _wsSignals ) ; for ( let i = 0 ; i < global . screen . n_workspaces ; ++ i ) { let ws = global . screen . get_workspace_by_index ( i ) ; this . connectAndTrack ( this . _wsSignals , ws , 'window-removed' , Lang . bind ( this , this . _windowRemoved ) ) ; } }
function ( ) { this . disconnectTrackedSignals ( this ) ; this . disconnectTrackedSignals ( this . _wsSignals ) ; let windows = global . get_window_actors ( ) ; for ( let i = 0 ; i < windows . length ; ++ i ) { let win = windows [ i ] ; if ( win . _notifyTitleId ) { win . disconnect ( win . _notifyTitleId ) ; delete win . _notifyTitleId ; } } this . disconnectTrackedSignals ( this . _targetAppSignals ) ; this . parent ( ) ; }
function ( ) { var sample ; if ( ! Path . existsSync ( "./migrations" ) ) { Fs . mkdirSync ( "./migrations" ) ; } if ( ! Path . existsSync ( "./migrations/config.js" ) ) { sample = Fs . readFileSync ( __dirname + "/../src/test/config.sample" , "utf8" ) ; Fs . writeFileSync ( "./migrations/config.js" , sample ) ; return console . log ( "Created sample configuration. Edit migrations/config.js." ) ; } }
function ( err ) { if ( err ) { console . error ( err ) ; return process . exit ( 1 ) ; } else { console . log ( "OK" ) ; return process . exit ( ) ; } }
function ( timestamp , contest_start , contest_stop , phase ) { self . last_notification = timestamp ; self . timestamp = timestamp ; self . contest_start = contest_start ; self . contest_stop = contest_stop ; self . phase = phase ; self . remaining_div = null ; self . unread_count = 0 ; }
function ( timestamp ) { var date = new Date ( timestamp * 1000 ) ; return date . getFullYear ( ) + "-" + ( date . getMonth ( ) + 1 ) + "-" + date . getDate ( ) ; }
function ( data , callback ) { $ ( document ) . unbind ( 'ajaxError' ) ; console . log ( 'send' ) ; console . log ( data ) ; $ . ajax ( { 'url' : riurik . reporter . url , 'data' : data , 'dataType' : 'jsonp' , 'complete' : function ( ) { $ ( document ) . bind ( 'ajaxError' , ajaxError ) ; if ( typeof callback != 'undefined' ) { callback ( data ) ; } } } ) ; }
function clearSelectMode ( ) { $ ( ".icon-top-right" ) . hide ( ) ; $ ( ".item" ) . unbind ( 'hover' ) ; $ ( '.item' ) . unbind ( 'click' ) ; $ ( '.item' ) . removeClass ( 'red' ) ; resetItemCheckboxes ( ) ; attachItemActions ( ) ; enableGalleryClick ( ) ; disableSelectNav ( ) ; }
function ( ) { $ ( '.page' ) . hide ( ) ; var courseid = $ ( this ) . attr ( 'courseid' ) ; dscourse . getCourse ( courseid ) ; $ ( '#coursePage' ) . show ( ) ; $ ( 'html, body' ) . animate ( { scrollTop : 0 } ) ; }
function ( e ) { e . preventDefault ( ) ; $ ( this ) . next ( ) . slideToggle ( ) ; }
function ( e ) { e . stopPropagation ( ) ; e . preventDefault ( ) ; var row = $ ( this ) . parents ( 'tr' ) ; var id = row . find ( 'input[type=checkbox]' ) . attr ( 'value' ) ; window . location . href = 'samples/view/' + id + '.html' ; return false ; }
function ( ) { self . emit ( 'end' ) ; if ( cb ) cb ( ) ; }
function ( data ) { console . log ( 'socket connected' ) ; if ( ui . wasConnected ) { this . cancelNotification ( ) ; window . location = window . location ; } else { ui . wasConnected = true ; ui . socket . emit ( 'join' , { gameKey : ui . gameKey } ) ; } }
function ( event , ui ) { document . demo . SetVolume ( ui . value ) ; if ( ui . value == 0 ) { if ( ! $ ( "#speaker" ) . hasClass ( "speakoff" ) ) { $ ( "#speaker" ) . removeClass ( "speakon" ) . addClass ( "speakoff" ) ; } } else if ( ! $ ( "#speaker" ) . hasClass ( "speakon" ) ) { $ ( "#speaker" ) . removeClass ( "speakoff" ) . addClass ( "speakon" ) ; } }
function ( ) { var ismute = document . demo . GetMute ( ) ; document . demo . SetMute ( ! ismute ) ; if ( ismute ) { $ ( "#speaker" ) . removeClass ( "speakon" ) . addClass ( "speakoff" ) ; } else { $ ( "#speaker" ) . removeClass ( "speakoff" ) . addClass ( "speakon" ) ; } }
function ( item ) { var fp = new this . FP ( { gridStore : this . gridStore , treeStore : this . treeStore } ) ; var fpc = new this . FPC ( { view : fp } ) this . adminDialog . addChild ( fp ) ; fp . resize ( ) ; }
function ( args ) { this . editorPane = args . editorPane ; this . model = args . model ; this . pluginItem ; this . navigationId = args . navigationId ; this . _attachEventListeners ( ) ; }
function ( pluginId ) { var self = this ; this . editorPane . disable ( ) ; this . model . removeExtensionPlugin ( pluginId ) . then ( function ( ) { var region = self . editorPane . regionSelect . get ( 'item' ) . identifier ; self . editorPane . reloadGrid ( self . navigationId , region ) . then ( function ( ) { self . editorPane . enable ( ) ; } ) } ) }
function ( id ) { if ( ! this . objects [ id ] ) return this . undefLink ; var ob = this . objects [ id ] , shortDesc = "" , title = "object " + id , text = "" ; if ( ob . title ) title = ob . title ; if ( ob . shortDescription ) shortDesc = ob . shortDescription ( ) ; text += "<a onclick='" + this . callbackName + "(" + id + ");'>" ; text += title + "</a>:" + shortDesc ; return text ; }
function handleTransform_getTermsCallback ( terms ) { var candidates = [ ] ; terms . forEach ( function readTerm ( term ) { candidates . push ( [ term . kanji , term . kana ] ) ; } ) ; if ( ! candidates . length ) { candidates . push ( [ _firstKanji , _firstKana ] ) ; } else { _firstKanji = terms [ 0 ] . kanji ; _firstKana = terms [ 0 ] . kana ; } _candidateList = candidates . slice ( ) ; return ; }
function ( e ) { if ( e . which != 9 ) return ; if ( ! e . ctrlKey && ! e . altKey && ! e . shiftKey && tinymce . activeEditor && ! tinymce . activeEditor . isHidden ( ) ) { $ ( 'td.mceToolbar > a' ) . focus ( ) ; e . preventDefault ( ) ; } }
function reifySymbol ( sexpr ) { if ( value = sexpr . value . match ( INTEGER ) ) { return Data . Number ( Number ( value [ 0 ] ) ) ; } if ( value = sexpr . value . match ( FLOAT ) ) { return Data . Number ( Number ( value [ 0 ] ) ) ; } if ( sexpr . value . length > 0 ) { return Data . Symbol ( sexpr . value ) ; } throw new Error ( "can't extract primitive:  symbol has empty value" ) ; }
function show_help ( ) { hide_about ( ) ; document . getElementById ( 'helpbox' ) . style . visibility = 'visible' ; return false ; }
function ( ctx ) { this . _super ( ) ; if ( cc . renderContextType == cc . CANVAS ) { } else { var newBlend = this . _blendFunc . src != cc . BLEND_SRC || this . _blendFunc . dst != cc . BLEND_DST ; if ( newBlend ) { } this . _textureAtlas . drawNumberOfQuads ( this . _quadsToDraw , 0 ) ; if ( newBlend ) { } } }
function ( ) { var s = this . _textureAtlas . getTexture ( ) ; this . _itemsPerColumn = parseInt ( s . height / this . _itemHeight ) ; this . _itemsPerRow = parseInt ( s . width / this . _itemWidth ) ; }
function ( require ) { Core . Router = require ( "./core/router" ) ; Core . Context = require ( "./core/context" ) ; Core . Mediator = require ( "./core/mediator" ) ; Core . Panel = require ( "./core/panel" ) ; Core . Controller = require ( "./core/controller" ) ; Core . Loader = require ( "./core/loader" ) ; return Core ; }
function ( modules ) { for ( i in modules ) { var ModuleClass = modules [ i ] ; moduleInstances . push ( new ModuleClass ( globalContext ) ) ; } }
function ( globalContext ) { var moduleInstances = new Array ( ) ; return { load : function ( modules ) { for ( i in modules ) { var ModuleClass = modules [ i ] ; moduleInstances . push ( new ModuleClass ( globalContext ) ) ; } } , } ; }
function ( globalContext ) { var moduleInstances = new Array ( ) ; return { load : function ( modules ) { for ( i in modules ) { var ModuleClass = modules [ i ] ; moduleInstances . push ( new ModuleClass ( globalContext ) ) ; } } , } ; }
function ( Core , settings , modules ) { var globalContext = new Core . Context ( ) ; globalContext . addSettings ( settings ) ; var moduleLoader = new Core . Loader ( globalContext ) ; moduleLoader . load ( modules ) ; globalContext . activate ( ) ; }
function ( ) { login . _onKey = function ( ) { } ; login . show ( ) ; dom . byId ( 'user_name' ) . focus ( ) ; bba . pageLoaded ( ) ; }
function ( ) { actionTaken = true ; counter [ priority ] -- ; bCount [ priority ] . remove ( ) ; bCount [ priority ] = paper . text ( paper . width - ( 125 - ( priority * 40 ) ) , 11 , counter [ priority ] ) . attr ( { fill : txtColors [ priority ] } ) ; mask . toFront ( ) ; delId = "#console_row_" + nr ; $ ( delId ) . remove ( ) ; }
function ( ) { actionTaken = true ; }
function info ( text , title ) { text = text || "(an empty string)" ; if ( title ) text = "<b>" + title + "</b><br/>" + text ; counter [ 0 ] ++ ; bCount [ 0 ] . remove ( ) ; bCount [ 0 ] = paper . text ( paper . width - 125 , 11 , counter [ 0 ] ) . attr ( { fill : "white" } ) ; mask . toFront ( ) ; addMessage ( text , 0 ) ; }
function ContentSecurityPolicy ( ) { CSPdebug ( "CSP CREATED" ) ; this . _isInitialized = false ; this . _reportOnlyMode = false ; this . _policy = CSPRep . fromString ( "default-src *" ) ; this . _policy . _allowInlineScripts = true ; this . _policy . _allowEval = true ; this . _request = "" ; this . _docRequest = null ; CSPdebug ( "CSP POLICY INITED TO 'default-src *'" ) ; }
function ( aViolationType , aSourceFile , aScriptSample , aLineNum ) { switch ( aViolationType ) { case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_INLINE_SCRIPT : if ( ! this . _policy . allowsInlineScripts ) this . _asyncReportViolation ( 'self' , 'inline script base restriction' , 'violated base restriction: Inline Scripts will not execute' , aSourceFile , aScriptSample , aLineNum ) ; break ; case Ci . nsIContentSecurityPolicy . VIOLATION_TYPE_EVAL : if ( ! this . _policy . allowsEvalInScripts ) this . _asyncReportViolation ( 'self' , 'eval script base restriction' , 'violated base restriction: Code will not be created from strings' , aSourceFile , aScriptSample , aLineNum ) ; break ; } }
function init ( ) { if ( ! FlashWS . loaded ) { if ( self . policyPort !== 843 ) { WebSocket . loadFlashPolicyFile ( 'xmlsocket://' + self . host + ':' + self . policyPort ) ; } WebSocket . __initialize ( ) ; FlashWS . loaded = true ; } fn . call ( self ) ; }
function ph_fun_exp ( fname , pars , body , pctx ) { this . is_nblock = pctx . allow_nblock ; this . code = "function " + fname + "(" + pars . join ( "," ) + "){" + body + "}" ; }
function ph_fun_exp ( fname , pars , body , pctx ) { this . is_nblock = pctx . allow_nblock ; this . code = "function " + fname + "(" + pars . join ( "," ) + "){" + body + "}" ; }
function showInTOC ( a ) { $ ( "#api_sub a.selected" ) . removeClass ( "selected" ) ; $ ( "#api_sub a.currentPage" ) . removeClass ( "currentPage" ) ; var items = a . addClass ( "selected" ) . parents ( "ul, li" ) . add ( a . nextAll ( "ul" ) ) . show ( ) ; loadTocSection ( a . parent ( ) ) ; items . each ( function ( index ) { expandSubTree ( $ ( this ) ) ; } ) ; scrollTOC ( ) ; }
function ( card , playerNumber , stackNumber ) { var $gameCtrl = angular . element ( $ ( "#app" ) ) . scope ( ) ; $gameCtrl . dealCard ( card , playerNumber , stackNumber ) ; $gameCtrl . $apply ( ) ; animateDeal ( { name : "poof" , kind : "HIT" } , 0 , 0 , 1 , function ( card , playerNumber , stackNumber ) { $gameCtrl . dealCard ( card , playerNumber , stackNumber ) ; $gameCtrl . $apply ( ) ; } ) ; }
function ( e ) { e . preventDefault ( ) ; $submitbutton = $ ( this ) ; $submitbutton . css ( 'cursor' , 'default' ) ; $submitbutton . prop ( 'disabled' , true ) ; $submitbutton . parent ( ) . find ( '.waiting' ) . fadeIn ( ) ; $ ( '.pods-admin form' ) . trigger ( 'submit' ) ; }
function ( method ) { if ( methods [ method ] ) { return methods [ method ] . apply ( this , Array . prototype . slice . call ( arguments , 1 ) ) ; } else { $ . error ( 'Method ' + method + ' does not exist on jQuery.PodsAdmin' ) ; } }
function ( overrideFlags , player , otherID , isProjectile , startFrame , frame , otherPlayer ) { this . MoveOverrideFlags = overrideFlags ; this . Frame = frame || 0 ; this . OtherAttackStartFrame = startFrame ; this . Key = this . GetKey ( player . id_ , otherID ) ; this . IsProjectile = isProjectile ; this . Player = player ; this . OtherPlayer = otherPlayer ; this . PlayerID = player . id_ ; }
function ( ) { var value = this . GetEnergy ( ) ; if ( value >= ENERGYBAR . MAX_LEVEL2 ) return ENERGYBAR . LEVELMAXED ; else if ( value >= ENERGYBAR . MAX_LEVEL1 ) return ENERGYBAR . LEVEL2 ; else if ( value >= ENERGYBAR . MAX_LEVEL0 ) return ENERGYBAR . LEVEL1 ; else return ENERGYBAR . LEVEL0 ; }
function ( body ) { eCheck . namedValue ( 'body' , body . bodyText ) ; if ( body . attachments && body . attachments . length ) { for ( var i = 0 ; i < body . attachments . length ; i ++ ) { eCheck . expect_namedValue ( 'attachment' , body . attachments [ i ] . filename ) ; } } }
function showAsBuilding ( selector ) { ( function f ( i ) { if ( i < ( pollIntervalSeconds / fadeIntervalSeconds ) - 1 ) { setTimeout ( function ( ) { $ ( selector ) . fadeTo ( 1000 , 0.5 ) . fadeTo ( 1000 , 1 ) ; f ( i + 1 ) ; } , fadeIntervalSeconds * 1000 ) ; } } ) ( 0 ) ; }
function ( response ) { $ ( '#' + projectCssId ) . replaceWith ( response ) ; if ( $ ( response ) . hasClass ( 'building' ) ) { showAsBuilding ( '#' + projectCssId ) ; $ ( '#' + projectCssId ) . fadeTo ( 1000 , 0.5 ) . fadeTo ( 1000 , 1 ) ; } }
function generate_checkin_listing ( checkin ) { var listing = '<div id="check-in-id{0}" class="newsfeed-item">' + '<div id="table-div">' + '<table class="table">' + '<tr>' + '<td>{1} is at {2}</td>' + '</tr>' + '<tr>' + '<td id="time-staying-id{3}"></td>' + '<td>${4}</td>' + '<td><button class="btn btn-primary order-button" data-toggle="modal" onClick="javascript:order_up({5})">OrderUp</button></td>' + '</tr>' + '</table>' + '</div>' + '</div>' ; return listing . format ( checkin . id , checkin . user , checkin . name , checkin . id , checkin . fee , checkin . id ) ; }
function ( extend ) { var fn = this ; var ret = function ( ) { return fn . apply ( this , arguments ) ; } ; for ( var i in extend ) { ret [ i ] = extend [ i ] ; } return ret ; }
function ( cfg , ctx ) { if ( typeof module === 'undefined' ) { Guard . raise ( 'mongoDB provider not supported on client side. node.js required!' , 'Not supported!' ) ; } this . driver = require ( 'mongodb' ) ; this . context = ctx ; this . providerConfiguration = $data . typeSystem . extend ( { dbCreation : $data . storageProviders . mongoDB . DbCreationType . Default , address : '127.0.0.1' , port : 27017 , serverOptions : { } , databaseName : 'test' } , cfg ) ; }
function ( text ) { if ( typeof text === 'undefined' ) return undefined ; var m = new RegExp ( /ObjectID\("([0-9a-f]+)"\)/ ) . exec ( text ) ; return m ? new require ( 'mongodb' ) . ObjectID . createFromHexString ( m [ 1 ] ) : text ; }
function ( name , sign , octave ) { var x = atom . table [ name ] || 0 ; if ( sign === "-" ) { -- x ; } else if ( sign === "+" || sign === "#" ) { ++ x ; } x += octave * 12 ; return x ; }
function ( parent , mml ) { this . parent = parent ; this . mml = mml ; this . octave = 5 ; this . length = 4 ; this . dot = 0 ; this . detune = 0 ; this . quantize = 6 ; this . volume = 8 ; this . compile ( mml ) ; }
function ( ) { $ . ajaxQueue . stop ( true ) ; app . collections . articles . reset ( ) ; app . collections . links . reset ( ) ; var term = $ ( "input[name=term]" ) . val ( ) ; if ( term ) { app . collections . articles . fetch ( { data : { term : term , n : 10 } } ) ; } }
function ( ) { this . model . metrics = new Collections . Metrics ( ) ; this . metrics = new Views . Metrics ( { collection : this . model . metrics } ) ; this . model . on ( "change" , this . render , this ) ; }
function ( ) { this . $el . empty ( ) ; this . collection . each ( this . add , this ) ; }
function refreshLoadedModules ( ) { if ( document . readyState === 'complete' && Ext && google . earth ) { clearInterval ( loadInterval ) ; console . log ( 'All ready' ) ; kvu = new KmlViewerUi ( ) ; kfc = new KmlFileCollection ( ) ; tsc = new GETimeSliderControl ( ) ; strc = new GEStreamingControl ( ) ; kvu . init ( ) ; } }
function ( e ) { kontrol . Core . document . unbind ( 'touchmove.k touchend.k keyup.k' ) ; self . isPressed = false ; if ( self . releaseHook && ( self . releaseHook ( self . newValue ) === false ) ) return ; self . val ( self . newValue ) ; }
function ( e ) { self . isPressed = false ; kontrol . Core . document . unbind ( 'mousemove.k mouseup.k keyup.k' ) ; if ( self . releaseHook && ( self . releaseHook ( self . newValue ) === false ) ) return ; self . val ( self . newValue ) ; }
function removeEvents ( ) { canvas . unbind ( 'mousemove' ) ; canvas . unbind ( 'mouseup' ) ; canvas . unbind ( 'mousedown' ) ; menuBar . unbind ( 'mousedown' ) ; canvas . removeAttr ( 'ontouchmove' ) ; canvas . removeAttr ( 'ontouchend' ) ; canvas . removeAttr ( 'ontouchstart' ) ; $ ( 'html' ) . unbind ( 'keydown' ) ; }
function ( ) { happy = true ; result = response . parseResponse ( timings , reqStart , args , res , bufs ) ; putInCache ( key , cache , result , res , expires ) ; response . exec ( timings , reqStart , args , uniqueId , res , start , result , options ) ; }
function ( ) { if ( zipped ) { unzip . end ( ) ; } else { result = response . parseResponse ( timings , reqStart , args , res , bufs ) ; putInCache ( key , cache , result , res , expires ) ; response . exec ( timings , reqStart , args , uniqueId , res , start , result , options , status ) ; } }
function ( ) { if ( happy ) { console . log ( '*** timeout received when not expected' ) ; return ; } timedout = true ; charlie . notok ( [ args . uri , args . name ] ) ; return args . httpReqTx . end ( { message : 'Request timed out' , timeout : timeout , uri : args . uri , status : 502 } ) ; }
function ( e ) { if ( e . which != 9 ) return ; if ( ! e . ctrlKey && ! e . altKey && ! e . shiftKey && tinymce . activeEditor && ! tinymce . activeEditor . isHidden ( ) ) { $ ( 'td.mceToolbar > a' ) . focus ( ) ; e . preventDefault ( ) ; } }
function ( test ) { var mp = new ks_macros . MacroProcessor ( { loader_class : ks_test_utils . JSONifyLoader } ) ; processFixture ( test , mp , 'macros-document-double-brace.txt' , function ( errors , result ) { test . ok ( ! errors , "There should be no errors" ) ; test . done ( ) ; } ) ; }
function ( ) { var goal , scoring_team , _ref ; if ( goal = this . current_game . goals . pop ( ) ) { scoring_team = ( ( _ref = goal . scorer , __indexOf . call ( this . current_game . arrangement [ 0 ] , _ref ) >= 0 ) ? 0 : 1 ) ; this . current_game . scores [ scoring_team ] -- ; this . total_scores [ scoring_team ] -- ; return this . refresh_scores ( ) ; } }
function showLoadingIcon ( tagControl ) { var src = "themes/photon/images/loading_blue.gif" ; var theme = localStorage [ "color" ] ; if ( theme == undefined || theme == "themes/photon/css/red.css" ) { src = "themes/photon/images/loading_red.gif" ; } tagControl . empty ( ) ; tagControl . html ( "<img class='loadingIcon' src='" + src + "' style='display: block'>" ) ; }
function getCurrentCSS ( ) { var theme = localStorage [ "color" ] ; if ( theme == undefined || theme == "themes/photon/css/red.css" ) { $ ( '.loadingIcon, .popupLoadingIcon' ) . attr ( "src" , "themes/photon/images/loading_red.gif" ) ; } else { $ ( '.loadingIcon, .popupLoadingIcon' ) . attr ( "src" , "themes/photon/images/loading_blue.gif" ) ; } }
function ( obj ) { if ( ! Util . _is_object ( obj ) || ! obj . hasOwnProperty ( 'data' ) ) Util . _exit ( 'invalid data format - object should have a "data" property' ) ; if ( ! ( obj . data instanceof Array ) || ! ( obj . data [ 0 ] instanceof Array ) ) Util . _exit ( 'invalid data format - obj.data expected to be array of arrays' ) ; return obj . data ; }
function ( evt ) { var currentPage = detailScrollView . currentPage ; var dataSource = self . _dataSource ; if ( currentPage > dataSource . length - 1 ) return ; loadImage ( dataSource [ currentPage ] ) ; if ( navigationBar ) navigationBar . setTitle ( ( currentPage + 1 ) + ' of ' + dataSource . length ) ; }
function ( grid , record ) { console . log ( 'Double click on ' + record . get ( 'name' ) ) ; var view = Ext . widget ( 'entryedit' ) ; view . down ( 'form' ) . loadRecord ( record ) ; view . show ( ) ; }
function ( ) { scalingRange = [ 0 , 170 ] ; slider = new five . Sensor ( { pin : "A0" , freq : 250 } ) ; slider . on ( "slide" , function ( err , value ) { if ( err ) { console . log ( "error: " , err ) ; } else { console . log ( Math . floor ( this . value ) ) ; } } ) ; }
function ( tiles ) { var debugStr = "" ; for ( i = 0 ; i < tiles . length ; i ++ ) { for ( j = 0 ; j < tiles [ i ] . length ; j ++ ) { debugStr += tiles [ i ] [ j ] ; } debugStr += "\n" ; } console . log ( debugStr ) ; }
function ( ) { var elements = [ "src/components/MouseHover.js?v=" + version , "src/components/KeyMoveControls.js?v=" + version , "src/components/Hero.js?v=" + version , "src/components/TileMap.js?v=" + version , "src/components/Body.js?v=" + version , "src/entities/base/BaseEntity.js?v=" + version , "src/entities/base/MapEntity.js?v=" + version , "src/entities/MapObjects.js?v=" + version , "src/entities/player.js?v=" + version , "src/entities/World.js?v=" + version ] ; require ( elements , function ( ) { if ( gameContainer . scene != undefined ) { Crafty . scene ( gameContainer . scene ) ; } } ) ; }
function ( position ) { if ( APP . userLocation . isSet ) { return ; } APP . userLocation . lat = position . coords . latitude ; APP . userLocation . lng = position . coords . longitude ; APP . userLocation . isSet = true ; SONGMAP . initMap ( "map" , SONGMAP . defaults . zoom , { lat : position . coords . latitude , lng : position . coords . longitude } ) ; }
function ( ) { if ( APP . userLocation . isSet ) { var centerInfo = SONGMAP . getMapCenterInfo ( ) ; $ . ajax ( { type : "POST" , url : "/songs/get" , dataType : "json" , data : { user : APP . username , lat : centerInfo . lat , lng : centerInfo . lng , zoom : centerInfo . zoom } , success : APP . handleUserSongs } ) ; } else { setTimeout ( APP . getSongs , 1000 ) ; } }
function ( response , ioArgs ) { var wrappedResponse = new Response ( response , request . type === 'rest' , ioArgs ) ; if ( wrappedResponse . mappedStatusCodes . indexOf ( ioArgs . xhr . status ) > - 1 ) { this . handleResponseFunc ( request , wrappedResponse ) ; } else { console . error ( response ) ; this . handleErrorFunc ( request , response ) ; } }
function callbackSliderLoadedChanged ( args ) { $ ( args . sliderObject ) . siblings ( '.paging' ) . children ( '.box' ) . removeClass ( 'selected' ) ; $ ( args . sliderObject ) . siblings ( '.paging' ) . children ( '.box:eq(' + args . currentSlideNumber + ')' ) . addClass ( 'selected' ) ; console . log ( args ) ; }
function ( inSender , inResponse ) { this . state = "directoryFetched" ; this . directoryData = inResponse ; this . doDirectoryFetched ( inResponse ) ; this . fetchSpaces ( inResponse ) ; }
function ( obj ) { var size = 0 , key ; for ( key in obj ) { if ( obj . hasOwnProperty ( key ) ) size ++ ; } return size ; }
function ( spaceURL ) { if ( typeof ( spaceURL ) == "string" ) { var spaceFetch = new enyo . Ajax ( { url : spaceURL } ) ; this . state = "spaceFetch" ; spaceFetch . response ( this , "spaceFetched" ) ; spaceFetch . error ( this , "spaceFetchFailure" ) ; spaceFetch . go ( ) ; } }
function ( ) { window . router . navigate ( "!" + this . get ( "dbType" ) . id + "/" + this . get ( "short_code" ) ) ; }
function ( parent , data ) { if ( data . content && data . content . length == 1000 ) { data . content += repl ( '... <a href="%(name)s.html">(read on)</a>' , data ) ; } data . content = wn . markdown ( data . content ) ; if ( data . last_name ) data . last_name = ' ' + data . last_name ; data . date = prettyDate ( data . creation ) ; parent . innerHTML = repl ( '<h2><a href="%(name)s.html">%(title)s</a></h2>\ 				<p><div class="help">By %(first_name)s%(last_name)s, %(date)s</div></p>\ 				<p>%(content)s</p><br>' , data ) }
get decoder ( ) { var decoder = new ArithmeticDecoder ( this . data , this . start , this . end ) ; Object . defineProperty ( this , 'decoder' , { value : decoder , writable : false , configurable : true , enumerable : true } ) ; return decoder ; } ,
function ( data ) { if ( ! data ) { $ ( '#directory_user_result' ) . html ( 'User id (' + un + ') does not exist.' ) ; $ ( '#new_user_name_skel' ) . select ( ) ; $ ( '#new_user_permission_skel' ) . val ( 'none' ) ; $ ( '#new_user_permission_skel' ) . attr ( 'disabled' , true ) ; return ; } else { $ ( '#new_user_permission_skel' ) . attr ( 'disabled' , false ) ; $ ( '#new_user_permission_skel' ) . focus ( ) ; } }
function ( wallIdx ) { var subwallGrid = new Array ( this . numCols ) ; for ( var x = 0 ; x < this . numCols ; x ++ ) { var column = new Array ( this . numRows ) ; for ( var y = 0 ; y < this . numRows ; y ++ ) { column [ y ] = ( this . getSubwallsInGrid ( wallIdx , x , y ) ) ; } subwallGrid [ x ] = ( column ) ; } return subwallGrid ; }
function ( ) { var r = new Collection ( { properties : { title : { type : 'string' , required : true } , age : { type : 'number' , required : true } , created : { type : 'date' } } } ) ; var errs = r . validate ( { title : 7 , created : 'foo' } ) ; expect ( errs ) . to . eql ( { title : 'must be a string' , age : 'is required' , created : 'must be a date' } ) ; }
function ( ) { $ . get ( WEBROOT + '/xhr/headphones/artist/' + $ ( this ) . data ( 'id' ) + '/add' ) ; $ . get ( WEBROOT + '/xhr/headphones/artist/' + $ ( this ) . data ( 'id' ) , function ( data ) { $ ( '#headphones' ) . replaceWith ( data ) ; } ) ; }
function getData ( options ) { var data = new api ( { url : 'http://' + location . hostname + ':' + location . port + '/api?' } ) ; data . get ( options , function ( data ) { console . log ( data . length ) ; console . log ( data ) ; $ ( '#loader' ) . hide ( ) ; createGraph ( 'container' , data ) ; } ) ; }
function ( ) { data . push ( { id : this , text : this } ) ; }
function ( t ) { if ( Array . isArray ( t ) ) { for ( var i in t ) { this . queue . push ( t [ i ] ) ; } } else { this . queue . push ( t ) ; } if ( this . queue . length == 1 ) { this . dospotify . play ( this . queue [ 0 ] ) ; } this . emit ( 'added' , t ) ; }
function ( iframeData ) { var newDoc = $ ( '#' + iframeId ) [ 0 ] . contentDocument ; newDoc . open ( ) ; newDoc . write ( iframeData . content ) ; newDoc . close ( ) ; $iframeProxy . iFramePlayer ( callback ) ; window [ cbName ] = null ; }
function ( Backbone , moment ) { window . Project = Backbone . Model . extend ( { defaults : { type : _ . str . trim ( "OpenSource " ) } , initialize : function ( ) { this . set ( { created : moment ( ) . utc ( ) . format ( ) } ) ; } } ) ; }
function ( frame , layer ) { console . log ( '	ADD LAYER TO FRAME' ) if ( frame . id != zeega . app . currentFrame ) { if ( frame . get ( 'layers' ) ) frame . get ( 'layers' ) . push ( layer . id ) ; else frame . set ( 'layers' , [ layer . id ] ) ; frame . save ( ) ; console . log ( frame ) } layer . trigger ( 'update' ) ; zeega . app . updateLayerOrder ( frame ) ; }
function mm_deleteMessage ( id , callback ) { console . log ( "SMS: Eliminando mensaje " + id ) ; var req = navigator . mozSms . delete ( id ) ; req . onsuccess = function onsuccess ( ) { callback ( req . result ) ; } ; req . onerror = function onerror ( ) { var msg = 'Deleting in the database. Error: ' + req . errorCode ; console . log ( msg ) ; callback ( null ) ; } ; }
function thui_deleteMessages ( ) { var inputs = this . view . querySelectorAll ( 'input[type="checkbox"]:checked' ) ; for ( var i = 0 ; i < inputs . length ; i ++ ) { inputs [ i ] . parentNode . parentNode . classList . add ( 'undo-candidate' ) ; if ( inputs [ i ] . id ) { this . delNumList . push ( inputs [ i ] . id ) ; } else { } } }
function ( callback ) { this . find ( ) . sort ( { date_created : 1 } ) . toArray ( function ( err , projects ) { if ( err ) console . log ( err ) ; return callback ( projects ? projects : null ) ; } ) ; }
function ( router , getAction ) { router . add ( '/' , getAction ( 'home' , 'index' ) ) ; router . add ( '/projects' , getAction ( 'home' , 'projects' ) ) ; }
function ( req , res , name , params ) { if ( ! params ) params = { } ; this . template ( req , res , name + '.html' , params ) ; }
function ( ) { var map = new SiteMap ( [ new Doc ( { section : 'foo' , id : 'a.b.c<>\'"&' } ) ] ) ; expect ( map . render ( ) ) . toContain ( [ ' <url>' , '<loc>http://docs.angularjs.org/#!/foo/a.b.c&lt;&gt;&apos;&quot;&amp;</loc>' , '<changefreq>weekly</changefreq>' , '</url>' ] . join ( '' ) ) ; }
function ( err , resp ) { if ( err || resp . statusCode != 200 ) { fs . unlinkSync ( fetch_target ) ; return cb ( new Error ( 'Couldn\'t fetch ' + version + ' (' + ( err . message || 'HTTP ' + resp . statusCode ) + ')' ) ) ; } cb ( ) ; }
function ( ) { deletePhoto ( $ ( '#picture' ) . attr ( 'src' ) ) ; }
function ( e ) { Utils . debug ( "Session fetched successfully" + e ) ; s . relativizePouchToACorpus ( self . get ( "corpus" ) ) ; s . set ( sessionFields , self . get ( "corpus" ) . get ( "sessionFields" ) . clone ( ) ) ; }
function ( e ) { Utils . debug ( "There was an error restructuring the session. Loading defaults..." + e ) ; s . relativizePouchToACorpus ( self . get ( "corpus" ) ) ; s . set ( sessionFields , self . get ( "corpus" ) . get ( "sessionFields" ) . clone ( ) ) ; }
function ( e , data ) { if ( data . context ) { var progress = parseInt ( data . loaded / data . total * 100 , 10 ) ; data . context . find ( '.bar' ) . css ( 'width' , progress + '%' ) . parent ( ) . attr ( 'aria-valuenow' , progress ) . attr ( 'aria-valuetext' , progress + '%' ) ; } }
function ( ) { $ ( this ) . find ( '.bar' ) . css ( 'width' , '0%' ) . parent ( ) . attr ( 'aria-valuenow' , '0' ) . attr ( 'aria-valuetext' , '0%' ) ; $ ( this ) . find ( '.progress-extended' ) . html ( '&nbsp;' ) ; that . _trigger ( 'stopped' , e ) ; }
function ( e ) { var that = e . data . fileupload , dataTransfer = e . dataTransfer = e . originalEvent . dataTransfer ; if ( that . _trigger ( 'dragover' , e ) === false ) { return false ; } if ( dataTransfer ) { dataTransfer . dropEffect = dataTransfer . effectAllowed = 'copy' ; } e . preventDefault ( ) ; }
function ( string ) { var err , res , rest , _ref ; _ref = parsePhase1 ( string ( ) ) , res = _ref [ 0 ] , err = _ref [ 1 ] , rest = _ref [ 2 ] ; if ( err ) { return left ( "Error at: " + ( JSON . stringify ( snip ( rest ) ) ) + "..., " + err ) ; } else { return right ( substituteMacros ( res ) ) ; } }
f var paramValue = jQuery . trim ( formValuesMap [ param . name ] ) ; if ( param . paramType == "body" && paramValue . length > 0 ) { postParam = postParam . length > 0 ? postParam : "{" ; postParam += "\"" + param . name + "\"" ; postParam += ":" ; postParam += "\"" + formValuesMap [ param . name ] + "\"," ; } } ) ;
function ( res ) { controller . endpoints . empty ( ) ; controller . endpoints . append ( res ) ; controller . toggleEndpoints ( ) ; }
function ( display , screen , window , binding ) { if ( this . _workspaceSwitcherPopup != null ) this . _workspaceSwitcherPopup . actor . hide ( ) ; let tabPopup = new AltTab . AltTabPopup ( ) ; let modifiers = binding . get_modifiers ( ) ; let backwards = modifiers & Meta . VirtualModifier . SHIFT_MASK ; if ( ! tabPopup . show ( backwards , binding . get_name ( ) , binding . get_mask ( ) ) ) tabPopup . destroy ( ) ; }
function ( direction ) { let activeWorkspace = global . screen . get_active_workspace ( ) ; let toActivate = activeWorkspace . get_neighbor ( direction ) ; if ( activeWorkspace != toActivate ) toActivate . activate ( global . get_current_time ( ) ) ; if ( ! Main . overview . visible ) this . _workspaceSwitcherPopup . display ( direction , toActivate . index ( ) ) ; }
function ( window , direction ) { let activeWorkspace = global . screen . get_active_workspace ( ) ; let toActivate = activeWorkspace . get_neighbor ( direction ) ; if ( activeWorkspace != toActivate ) { this . _movingWindow = window ; window . change_workspace ( toActivate ) ; global . display . clear_mouse_mode ( ) ; toActivate . activate_with_focus ( window , global . get_current_time ( ) ) ; } if ( ! Main . overview . visible ) this . _workspaceSwitcherPopup . display ( direction , toActivate . index ( ) ) ; }
function ( direction , activeWorkspaceIndex ) { this . _redraw ( direction , activeWorkspaceIndex ) ; if ( this . _timeoutId != 0 ) Mainloop . source_remove ( this . _timeoutId ) ; this . _timeoutId = Mainloop . timeout_add ( DISPLAY_TIMEOUT , Lang . bind ( this , this . _onTimeout ) ) ; this . _show ( ) ; }
function ( ) { Mainloop . source_remove ( this . _timeoutId ) ; this . _timeoutId = 0 ; Tweener . addTween ( this . _container , { opacity : 0.0 , time : ANIMATION_TIME , transition : 'easeOutQuad' , onComplete : function ( ) { this . actor . hide ( ) ; } , onCompleteScope : this } ) ; }
function ( index , el ) { var val = $ ( el ) . val ( ) ; var reg = /^[A-Fa-f0-9]{6}$/ ; if ( reg . test ( val ) && val != '' ) { $ ( el ) . attr ( 'value' , '#' + val ) } else if ( val == '' ) { $ ( this ) . parent ( ) . next ( ) . css ( { 'background' : '#f1f1f1' , 'border-color' : '#ccc' } ) ; } }
function ( req , headers ) { headers = headers || { } ; if ( /MSIE 8\.0/ . test ( req . headers [ 'user-agent' ] ) ) { headers [ 'X-XSS-Protection' ] = '0' ; } return headers ; }
function ( req , headers ) { headers = headers || { } ; if ( req . headers . origin ) { headers [ 'Access-Control-Allow-Credentials' ] = 'true' ; headers [ 'Access-Control-Allow-Origin' ] = req . headers . origin ; } else { headers [ 'Access-Control-Allow-Origin' ] = '*' ; } return headers ; }
function formatQuery ( obj ) { var li = [ ] ; obj = obj || { } ; if ( typeof obj === "string" ) { li = obj . split ( "&" ) ; } else { for ( var k in obj ) { if ( obj . hasOwnProperty ( k ) ) { li [ li . length ] = k + '=' + obj [ k ] ; } } } return li ; }
function ( event , params ) { var config = that . getEditableConfig ( params . editable . obj ) ; if ( config . formatlessPasteOption ) { that . formatlessPasteOption = true ; that . registerFormatlessPasteHandler ( ) ; } ; if ( typeof config . strippedElements !== 'undefined' ) { that . strippedElements = config . strippedElements ; } }
function ( code , callbacks ) { var callbacks = { 'execute_reply' : $ . proxy ( this . _handle_execute_reply , this ) , 'output' : $ . proxy ( this . handle_output ) , } ; var msg_id = this . notebook . kernel . execute ( code , callbacks ) ; return msg_id }
function ( ) { var setting = AdminSetting . findByAttribute ( 'setting' , 'voteweekend' ) ; if ( setting && setting . length ) { return true ; } switch ( this . getDate ( ) . getDay ( ) ) { case 1 : case 2 : case 3 : case 4 : case 5 : return true ; case 6 : case 0 : return false ; } }
function ( e ) { e . preventDefault ( ) ; this . clear ( ) ; }
function refreshRecordingList ( meetingId ) { var getRecordingResponse = ( meetingId == null ) ? BBBUtils . getSiteRecordingList ( bbbSiteId ) : BBBUtils . getMeetingRecordingList ( meetingId ) ; if ( getRecordingResponse . returncode == 'SUCCESS' ) { bbbCurrentRecordings = getRecordingResponse . recordings ; } else { bbbCurrentRecordings = new Array ( ) ; if ( getRecordingResponse . messageKey != null ) { BBBUtils . showMessage ( getRecordingResponse . messageKey + ":" + getRecordingResponse . message , 'warning' ) ; } else { BBBUtils . showMessage ( "An unidentified error has just happened" , 'warning' ) ; } } }
function ( i , p ) { drawIntersection ( points , circles , labels [ i ] , i , [ 0 , 0 , 1 ] , [ 1 , 1 , 0 ] ) ; drawIntersection ( points , circles , labels [ i + 3 ] , i , [ 0 , 1 , 1 ] , [ 0 , 1 , 1 ] ) ; }
function ( ) { console . log ( "onNewNoteCommand" ) ; var now = new Date ( ) ; var noteId = ( now . getTime ( ) ) . toString ( ) + ( this . getRandomInt ( 0 , 100 ) ) . toString ( ) ; var newNote = Ext . create ( "OnNotes.model.Note" , { id : "noteId" , dateCreated : now , title : "" , narrative : "" } ) ; this . activateNoteEditor ( newNote ) ; }
function ( ) { console . log ( "onNewNoteCommand" ) ; var now = new Date ( ) ; var noteId = ( now . getTime ( ) ) . toString ( ) + ( this . getRandomInt ( 0 , 100 ) ) . toString ( ) ; var newNote = Ext . create ( "OnNotes.model.Note" , { id : "noteId" , dateCreated : now , title : "" , narrative : "" } ) ; this . activateNoteEditor ( newNote ) ; }
function ( ) { console . log ( "onNewNoteCommand" ) ; var now = new Date ( ) ; var noteId = ( now . getTime ( ) ) . toString ( ) + ( this . getRandomInt ( 0 , 100 ) ) . toString ( ) ; var newNote = Ext . create ( "OnNotes.model.Note" , { id : "noteId" , dateCreated : now , title : "" , narrative : "" } ) ; this . activateNoteEditor ( newNote ) ; }
function ( ) { console . log ( "onNewNoteCommand" ) ; var now = new Date ( ) ; var noteId = ( now . getTime ( ) ) . toString ( ) + ( this . getRandomInt ( 0 , 100 ) ) . toString ( ) ; var newNote = Ext . create ( "OnNotes.model.Note" , { id : "noteId" , dateCreated : now , title : "" , narrative : "" } ) ; this . activateNoteEditor ( newNote ) ; }
function ( ) { console . log ( "onNewNoteCommand" ) ; var now = new Date ( ) ; var noteId = ( now . getTime ( ) ) . toString ( ) + ( this . getRandomInt ( 0 , 100 ) ) . toString ( ) ; var newNote = Ext . create ( "OnNotes.model.Note" , { id : "noteId" , dateCreated : now , title : "" , narrative : "" } ) ; this . activateNoteEditor ( newNote ) ; }
function showMenu ( ) { clear ( ) ; document . onkeydown = null ; document . onkeyup = null ; if ( gameLoop ) cancelAnimationFrame ( gameLoop ) ; document . onclick = menuClick ; document . onmousedown = function ( ) { click = true ; } menuLoop = requestAnimationFrame ( drawMenu ) ; }
function drawMap ( ) { for ( name in scene ) { scene [ name ] = new Container ( ) ; scene [ name ] . visible = false ; stage . addChild ( scene [ name ] ) ; } prepareScene ( ) ; Ticker . addListener ( window ) ; Ticker . useRAF = true ; Ticker . setInterval ( 17 ) ; }
function car ( args ) { var list = args [ 0 ] ; if ( list . type !== 'list' ) { throw new Error ( "argument to 'car' must be list (got " + list . type + ")" ) ; } if ( arguments . length != 1 ) { throw new Error ( "wrong number of arguments: needed 1, got " + args . length ) ; } if ( list . value . length > 0 ) { return list . value [ 0 ] ; } return Data . Nil ( ) ; }
function ( response ) { if ( response . ok === undefined ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } } return response ; }
function ( response ) { if ( response . ok === undefined ) { for ( var key in this . model ) { var embeddedClass = this . model [ key ] ; var embeddedData = response [ key ] ; response [ key ] = new embeddedClass ( embeddedData , { parse : true } ) ; } } return response ; }
function ( ) { var field = this . getElement ( ) ; if ( this . workaroundClassName_ ) { goog . dom . classes . add ( field , this . workaroundClassName_ ) ; } this . installStyles ( ) ; this . startChangeEvents ( ) ; this . logger . info ( 'Dispatching load ' + this . id ) ; this . dispatchEvent ( goog . editor . Field . EventType . LOAD ) ; }
function ( event ) { var dx = event . screenX - onMouseDownScreenX ; var dy = event . screenY - onMouseDownScreenY ; scope . dom . innerText = ( onMouseDownValue - ( dx - dy ) ) . toFixed ( 0 ) ; scope . onChangedCallback ( ) ; }
function ( event ) { var dx = event . screenX - onMouseDownScreenX ; var dy = event . screenY - onMouseDownScreenY ; scope . dom . innerText = ( onMouseDownValue + ( dx - dy ) / 100 ) . toFixed ( 2 ) ; scope . onChangedCallback ( ) ; }
function ( ) { group . addCard ( 1 ) ; group . addCard ( 2 ) ; expect ( group . getCards ( ) [ 0 ] . cardId ) . toEqual ( 1 ) ; expect ( group . getCards ( ) [ 1 ] . cardId ) . toEqual ( 2 ) ; }
function ( ) { group . addCard ( 2 ) ; group . addCard ( 1 ) ; group . addCard ( 3 , 2 ) ; expect ( group . getCards ( ) [ 0 ] . cardId ) . toEqual ( 2 ) ; expect ( group . getCards ( ) [ 1 ] . cardId ) . toEqual ( 3 ) ; expect ( group . getCards ( ) [ 2 ] . cardId ) . toEqual ( 1 ) ; }
function ( details ) { console . log ( "handling card_moved" ) ; var sourceGroupId = details . source_group_id , targetGroupId = details . target_group_id , targetIndex = details . target_idx , cardId = details . card_id , card = { cardId : cardId } ; game . startMoving ( card ) ; game . receiveCard ( card , targetGroupId ) ; }
function ( ev ) { elem . bind ( ev , function ( payload ) { payload . preventDefault ( ) ; self [ ev ] ( view . translateX ( payload . clientX ) , view . translateY ( payload . clientY ) ) ; } ) ; }
function ( ) { var event = $ . Event ( 'tap' ) ; event . cancelTouch = cancelAll ; touch . el . trigger ( event ) }
function ( name ) { if ( typeof ( this . trackLists [ name ] ) != undefined ) { return this . trackLists [ name ] ; } else { return null ; } }
function ( name , trackList ) { Tapedeck . Backend . Bank . Memory . rememberTrackList ( name , trackList ) ; Tapedeck . Backend . Bank . saveList ( this . trackListPrefix , name , trackList , function ( ) { } ) ; }
function ( tabID ) { chrome . tabs . insertCSS ( tabID , { file : "frontend/tapedeck-inject-all.css" } ) ; chrome . tabs . executeScript ( tabID , { file : "vendor/jquery-1.7.js" } ) ; chrome . tabs . executeScript ( tabID , { file : "frontend/tapedeck-inject-all.js" } ) ; }
function ( options ) { if ( $ . isEmptyObject ( options . attributes ) || ! ( "tdID" in options . attributes ) ) { this . set ( { tdID : _ . uniqueId ( "tapedeck-track" ) } ) ; } this . bind ( "change:download" , this . updateCollection ) ; }
function ( queue ) { sqcr . queue = queue sqcr . setQueuePosition ( - 1 ) ; var updateQueue = function ( ) { Tapedeck . Backend . MessageHandler . updateView ( "Queue" ) ; } sqcr . queue . destination = "Queue" ; sqcr . queue . bind ( 'add' , updateQueue ) ; sqcr . queue . bind ( 'remove' , updateQueue ) ; sqcr . queue . bind ( 'reset' , updateQueue ) ; sqcr . queue . bind ( 'change tracks' , updateQueue ) ; callback ( ) ; }
function ( error ) { optionCount = optionCount - 1 ; options [ param ] = "error" ; console . error ( "Fill map error on param '" + param + "': " + error . message ) ; if ( filledCount >= optionCount ) { callback ( options ) ; } }
function ( ) { pos = $ ( '.drsElement' ) . length ; console . log ( pos ) ; $ ( document . getElementById ( 'pane' + pos ) ) . remove ( ) ; $ ( document . getElementById ( 'min_win' + pos ) ) . remove ( ) ; POS [ pos ] = 0 ; }
function browser_handleTabsBadgeClicked ( ) { if ( this . currentScreen === this . TABS_SCREEN ) { var tabId = this . createTab ( ) ; this . selectTab ( tabId ) ; this . showAwesomeScreen ( ) ; return ; } if ( this . currentScreen === this . AWESOME_SCREEN && this . previousScreen === this . PAGE_SCREEN ) { this . showPageScreen ( ) ; return ; } this . showTabScreen ( ) ; }
function ( ) { var done = ( loaded . length + errors . length ) === paths . length ; if ( done && callback ) { callback ( sounds ) ; } if ( progress ) { progress ( sounds ) ; } }
function ( ) { this . on ( 'add' , this . _addInterceptor ) ; this . on ( 'remove' , this . _removeInterceptor ) ; this . on ( '*:depthLevelChange' , this . _childDepthChanging ) ; this . after ( '*:collapsedChange' , this . _childCollapsedChanged ) ; }
function ( req , res , next ) { var proj = req . body , id = proj . _id ; delete proj . _id ; delete proj . tasks ; Project . update ( { _id : id } , proj , null , function ( err , result ) { if ( err ) { res . send ( 500 ) ; } else { res . send ( ) ; } } ) ; }
function ( error , result ) { if ( error ) { res . send ( 500 ) ; } else { console . log ( result ) ; if ( result ) { result . password = undefined ; req . session . authentication = 'done' ; req . session . userId = result . _id ; req . session . save ( ) ; res . send ( result ) ; console . log ( 'authenticated...' ) ; } else { connectUtils . unauthorized ( res ) ; } } }
function ( req , res , next ) { if ( req . isXMLHttpRequest ) { req . session . destroy ( ) ; res . send ( ) ; } else { var options = { root : pageRoot , path : 'app.html' , getOnly : true } ; express [ 'static' ] . send ( req , res , next , options ) ; } }
function ( tokens , punctuator ) { if ( tokens ) { for ( var i = tokens . length - 1 , token ; token = tokens [ i ] ; i -- ) { if ( token [ TYPE ] == PUNCTUATOR && token [ VALUE ] == punctuator ) { for ( var j = 0 , index = 0 ; j < i ; j ++ ) index += tokens [ j ] [ VALUE ] . length ; return index ; } } } return - 1 ; }
function ( ) { var container = jQuery ( "<div/>" ) . width ( 400 ) . appendTo ( "#qunit-fixture" ) , el = jQuery ( "<div/>" ) . css ( { "width" : "50%" , "marginRight" : "50%" } ) . appendTo ( container ) ; equal ( el . outerWidth ( true ) , 400 , "outerWidth(true) and css('margin') returning % instead of px in Webkit, see #10639" ) ; }
function ( ) { var eventEmitter = new EventEmitter2 ( { wildcard : true } ) ; browser . run ( { eventEmitter : eventEmitter , htmlPath : path . join ( __dirname , 'chook/sandbox/index.html' ) , scripts : scripts , runner : runner } ) ; eventEmitter . on ( '*' , function ( output ) { globalEventEmitter . emit ( this . event , output ) ; } ) ; return eventEmitter ; }
function ( AThis , AEvent ) { if ( AEvent . wheelDelta > 0 ) updateZoom ( AThis , AEvent , 1 , 0.5 ) else updateZoom ( AThis , AEvent , 1 , - 0.5 ) ; return false ; }
function ( t , j ) { if ( t ) set [ 'modifiers' ] . push ( { name : name , src : t , value : j - 2 } ) ; }
function getName ( origin ) { var manifest = getManifest ( origin ) ; if ( ! manifest ) { return null ; } if ( 'locales' in manifest ) { var locale = manifest . locales [ document . documentElement . lang ] ; if ( locale && locale . name ) { return locale . name ; } } return manifest . name ; }
function pan ( movementX ) { var currentPage = pages . current ; pageHelper . getCurrent ( ) . moveTo ( movementX + 'px' ) ; if ( currentPage > 0 ) { pageHelper . getPrevious ( ) . moveTo ( '-100% + ' + movementX + 'px' ) ; } if ( currentPage < pages . total - 1 ) { pageHelper . getNext ( ) . moveTo ( '100% + ' + movementX + 'px' ) ; } }
function ( lang ) { document . documentElement . lang = lang ; var total = pageHelper . total ( ) ; for ( var i = 0 ; i < total ; i ++ ) { pages . list [ i ] . translate ( ) ; } }
function checkEmptyPages ( ) { var index = 0 ; var total = pages . total ; while ( index < total ) { var page = pages . list [ index ] ; if ( page . getNumApps ( ) === 0 ) { pageHelper . remove ( index ) ; break ; } index ++ ; } }
function pb_update ( current , total ) { if ( previousTotal !== total ) { style . width = ( 100 / total ) + percentage ; previousTotal = total ; } style . MozTransform = 'translateX(' + current * 100 + '%)' ; }
function ( ) { var $section = $ ( '.page-template-page-section-php' ) ; console . log ( 'app.js laodes' ) ; if ( $section . length > 0 ) { selector_height = $section . find ( '.section-selector' ) . outerHeight ( ) ; content_height = $section . find ( '.text-article' ) . outerHeight ( ) ; if ( selector_height < content_height ) { $section . find ( '.section-selector' ) . css ( 'position' , 'absolute' ) ; } } }
function ( index , value ) { var num_test_chars , test_text = $this . text ( ) ; if ( ! character_renders_correctly [ value ] ) { $this . html ( test_text . replace ( new RegExp ( "(" + value + ")([^\w&])" , 'g' ) , "$1&nbps;$2" ) ) ; } }
function ( ) { if ( this . _lastMarkedRange ) { this . _lastSelection = this . _lastMarkedRange ; delete this . _lastMarkedRange ; } if ( this . _lastSelection ) { var newSelection = WebInspector . TextRange . createFromLocation ( this . _lastSelection . endLine , this . _lastSelection . endColumn ) ; this . setSelection ( newSelection ) ; } }
function ( path ) { var fn = find_path ( nodeca . runtime . views [ locale ] [ theme ] . layouts , path ) ; if ( ! _ . isFunction ( fn ) ) { nodeca . logger . warn ( "Layout " + path + " not found" ) ; return ; } data . content = out . body ; out . body = fn ( data ) ; }
function ( element , settings ) { var errorElement , wrapper ; wrapper = element . closest ( "" + settings . wrapper_tag + "." + settings . wrapper_error_class ) ; wrapper . removeClass ( settings . wrapper_error_class ) ; errorElement = wrapper . find ( "" + settings . error_tag + "." + settings . error_class ) ; return errorElement . remove ( ) ; }
function ( ) { var ele = $ ( this ) . attr ( 'rel' ) ; if ( $ ( this ) . attr ( 'checked' ) == 'checked' ) $ ( '.' + ele + '_button' ) . css ( 'opacity' , '1' ) ; else $ ( '.' + ele + '_button' ) . css ( 'opacity' , '0.2' ) ; }
function ( ) { should . exist ( require ( 'webpage' ) . create ) ; should . exist ( require ( 'fs' ) . separator ) ; if ( phantom . version . major >= 1 && phantom . version . minor >= 4 ) { should . exist ( require ( 'webserver' ) . create ) ; } if ( phantom . version . major >= 1 && phantom . version . minor >= 5 ) { require ( 'system' ) . platform . should . equal ( 'phantomjs' ) ; } }
function getData ( options ) { var data = new api ( { url : 'http://' + location . hostname + ':' + location . port + '/api?' } ) ; data . get ( options , function ( data ) { console . log ( data . length ) ; console . log ( data ) ; $ ( '#loader' ) . hide ( ) ; createGraph ( 'container' , data ) ; } ) ; }
function ( ) { var self = this ; return 20 + self . sequence . length * ( 1 - ( ( self . _canvas . width . baseVal . value + self . _canvas . currentTranslate . x ) / self . _canvas . width . baseVal . value ) ) ; }
function ( ) { var self = this ; return self . leftVisibleResidue ( ) + self . sequence . length * ( self . _container_canvas . width . baseVal . value / self . _canvas . width . baseVal . value ) ; }
function ( ) { var self = this ; return 20 + self . sequence . length * ( 1 - ( ( self . _canvas . width . baseVal . value + self . _canvas . currentTranslate . x ) / self . _canvas . width . baseVal . value ) ) ; }
function ( ) { var self = this ; return self . leftVisibleResidue ( ) + self . sequence . length * ( self . _container_canvas . width . baseVal . value / self . _canvas . width . baseVal . value ) ; }
function ( ) { var self = this ; return 20 + self . sequence . length * ( 1 - ( ( self . _canvas . width . baseVal . value + self . _canvas . currentTranslate . x ) / self . _canvas . width . baseVal . value ) ) ; }
function ( ) { var self = this ; return self . leftVisibleResidue ( ) + self . sequence . length * ( self . _container_canvas . width . baseVal . value / self . _canvas . width . baseVal . value ) ; }
function ( ) { if ( ! opened ) { var newPosition = $ ( '#wb-main-in' ) . offset ( ) . left ; if ( newPosition <= borderWidth ) { newPosition = 0 ; } wrapper . css ( 'top' , $ ( '#wb-main-in' ) . offset ( ) . top ) ; wrapper . css ( 'right' , newPosition ) ; } }
function ( global ) { if ( typeof window === "undefined" ) { window = this ; } $data = window [ "$data" ] || ( window [ "$data" ] = { } ) ; if ( typeof module !== "undefined" && module . exports ) { sqLiteModule = require ( 'sqlite3' ) ; if ( sqLiteModule ) window [ 'openDatabase' ] = true ; module . exports = $data ; } }
function ( ) { this . close ( ) ; this . container . removeClass ( "select2-container-active" ) ; this . dropdown . removeClass ( "select2-drop-active" ) ; if ( this . search . is ( ":focus" ) ) { this . search . blur ( ) ; } this . clearSearch ( ) ; this . selection . find ( ".select2-search-choice-focus" ) . removeClass ( "select2-search-choice-focus" ) ; }
function ( err , stdout , stderr ) { if ( err ) { res . json ( err , 404 ) ; } else { res . setHeader ( 'Expires' , new Date ( Date . now ( ) + 604800000 ) ) ; stdout . pipe ( res ) ; } }
function ( indexViewModel ) { var post = _ . chain ( indexViewModel . posts ) . filter ( function ( post ) { return post . id === req . params . id } ) . first ( ) . value ( ) ; callback ( post ) ; }
function Mu_normalize ( context , name ) { var val = context [ name ] ; if ( typeof val === 'function' ) { val = val . call ( context ) ; } return typeof val === 'undefined' ? '' : val . toString ( ) ; }
function ( ) { var $elem = $ ( this ) , $copy ; $copy = $elem . find ( '.ui-text-shadow-copy' ) ; if ( ! $copy . length ) { allWords ( this ) ; $copy = $elem . find ( '.ui-text-shadow-copy' ) ; } if ( useStyle ) { applyStyles ( $copy , value ) ; } }
function ( ) { if ( this . nodeType === 3 && this . data ) { makeWords ( this ) ; return true ; } var $elem = $ ( this ) ; if ( this . nodeType === 1 && ( ! $elem . hasClass ( 'ui-text-shadow' ) || ! $elem . hasClass ( 'ui-text-shadow-original' ) || ! $elem . hasClass ( 'ui-text-shadow-copy' ) ) ) { allWords ( this ) ; return true ; } }
function wrapWord ( text ) { if ( ! text . length ) { return null ; } var shadow = shadowNode . cloneNode ( ) , orig = origNode . cloneNode ( ) , copy = copyNode . cloneNode ( ) ; shadow . appendChild ( copy ) ; shadow . appendChild ( orig ) ; orig . appendChild ( document . createTextNode ( text ) ) ; copy . appendChild ( document . createTextNode ( text ) ) ; return shadow ; }
function ( socket ) { socket . setTimeout ( 5000 ) ; socket . on ( 'timeout' , function ( ) { console . error ( util . format ( 'Disabled %s, timed out.' , item . hostname ) ) ; req . abort ( ) ; return callback ( false ) ; } ) ; }
function toArray ( obj ) { var undef , out , i ; if ( obj && ! obj . splice ) { out = [ ] ; for ( i = 0 ; true ; i ++ ) { if ( obj [ i ] ) out [ i ] = obj [ i ] ; else break ; } return out ; } return obj ; }
function cursorX ( evt ) { if ( evt . pageX ) return evt . pageX ; else if ( evt . clientX ) return evt . clientX + ( document . documentElement . scrollLeft ? document . documentElement . scrollLeft : document . body . scrollLeft ) ; }
function ( id , parent_id , page_size ) { var child_list ; if ( $ ( '.load_row[data-id="' + id + '"]' ) . length === 0 ) { add_row_header ( id , '' , 3 , false , parent_id ) ; if ( parent_id ) { child_list = $ ( '#child_list_' + parent_id ) ; child_list . append ( templates . load_more_row ( id , page_size ) ) ; } else { grid_content_el . append ( templates . load_more_row ( id , page_size ) ) ; } } }
function ( id , name , row_level , has_children , parent_id ) { var child_list ; if ( parent_id ) { child_list = $ ( '#child_header_list_' + parent_id ) ; child_list . append ( templates . row_header ( id , name , row_level , has_children , parent_id ) ) ; } else { grid_row_headers_el . append ( templates . row_header ( id , name , row_level , has_children , parent_id ) ) ; } }
function ( row , key ) { if ( row [ 'metadata' ] ) { add_metadata_row ( row [ 'id' ] , row [ 'parent_id' ] , row [ 'page_size' ] ) ; } else { add_row ( row [ 'id' ] , row [ 'name' ] , row [ 'cells' ] , row [ 'parent_id' ] , row [ 'comparable' ] ) ; } }
function ( id , parent_id , page_size , current , total , data ) { rows [ id ] = { 'id' : id , 'parent_id' : parent_id , 'data' : data , 'metadata' : true , 'page_size' : page_size , 'current' : current , 'total' : total } ; }
function ( direction ) { var position = ( direction === 'left' ) ? '-=100' : '+=100' ; $ ( '#grid_content' ) . animate ( { 'left' : position } , 'slow' ) ; $ ( '#column_headers' ) . animate ( { 'left' : position } , 'slow' , function ( ) { set_arrow_states ( ) ; } ) ; }
function ( data ) { comparison_grid . set_columns ( subgrid . cols ) ; comparison_grid . set_mode ( "details" ) ; comparison_grid . show_columns ( subgrid . cols ) ; if ( search_params . subgrid . type != 'compare' ) { comparison_grid . set_content_select ( utils . values ( subgrids ) ) ; } draw_grid ( data ) ; }
function ( value ) { var panelPane = FirebugChrome . $ ( "fbPanelPane" ) ; var newOrient = value ? "vertical" : "horizontal" ; if ( panelPane . orient == newOrient ) return ; panelSplitter . orient = panelPane . orient = newOrient ; }
function ( models , options ) { this . model . prototype . idAttribute = 'cartodb_id' ; if ( options && options . sql ) { this . setSQL ( options . sql ) ; } }
function ( k , v ) { return [ v , self . UNDEFINED_TYPE_COLUMN ] ; }
function ( error , path ) { if ( error ) { error . message = "Can't get canonical path of " + JSON . stringify ( path ) + " by way of C realpath: " + error . message ; result . reject ( error ) ; } else { result . resolve ( path ) ; } }
function ( ) { var geo_eu = init_geoportail_EU_layer ( map ) map . addLayers ( [ geo_eu ] ) map . setLayerIndex ( geo_eu , 0 ) }
function updateFullImage ( href ) { $ ( "body" ) . css ( "cursor" , "wait" ) ; $ ( '#largeImg' ) . prop ( "src" , href ) . css ( "max-width" , $ ( "body" ) . width ( ) ) . css ( "max-height" , $ ( "body" ) . height ( ) ) . load ( function ( ) { $ ( "body" ) . css ( "cursor" , "auto" ) } ) }
function ( form_id , html , remove_script , cb ) { inline ( { "html" : html , "baseUrl" : "https://wufoo.com" , "removeScripts" : remove_script , "id" : form_id } , function ( err , processed_html ) { if ( err != null ) { console . error ( 'error inlining html:' + err ) ; } return cb ( processed_html ) ; } ) ; }
function browser_handleTabsBadgeClicked ( ) { if ( this . currentScreen === this . TABS_SCREEN ) { var tabId = this . createTab ( ) ; this . selectTab ( tabId ) ; this . showAwesomeScreen ( ) ; return ; } if ( this . currentScreen === this . AWESOME_SCREEN && this . previousScreen === this . PAGE_SCREEN ) { this . showPageScreen ( ) ; return ; } this . showTabScreen ( ) ; }
function browser_handleEvent ( evt ) { var urlInput = this . urlInput ; switch ( evt . type ) { case 'submit' : this . go ( evt ) ; break ; case 'keyup' : if ( ! this . currentTab || ! this . currentTab . session . backLength ( ) || evt . keyCode != evt . DOM_VK_ESCAPE ) break ; this . goBack ( ) ; evt . preventDefault ( ) ; break ; } }
function browser_openInNewTab ( url ) { this . createTab ( url ) ; this . tabsBadge . innerHTML = Object . keys ( this . tabs ) . length ; }
function ( menu ) { for ( var i in menu . items ) { if ( menu . items [ i ] . type === 'menuitem' ) { var id = menu . items [ i ] . id ; ; menuItems [ id ] = menu . items [ i ] ; menuItems [ id ] . src = 'user' ; } else if ( menu . items [ i ] . type === 'menu' ) { collectMenuItems ( menu . items [ i ] ) ; } } }
function browser_selectTab ( id ) { this . currentTab = this . tabs [ id ] ; this . urlInput . value = this . currentTab . title ; this . tabCover . setAttribute ( 'src' , this . currentTab . screenshot ) ; if ( this . currentTab . loading ) { this . throbber . classList . add ( 'loading' ) ; } this . refreshButtons ( ) ; }
function browser_showAwesomeScreen ( ) { GlobalHistory . getHistory ( this . showGlobalHistory . bind ( this ) ) ; this . urlInput . focus ( ) ; this . setUrlButtonMode ( this . GO ) ; this . tabsBadge . innerHTML = '×' ; this . switchScreen ( this . AWESOME_SCREEN ) ; this . tabCover . style . display = 'none' ; }
function dh_thisWeekStarted ( ) { var now = new Date ( ) ; var dayOfTheWeek = now . getDay ( ) ; var offset = 1 - dayOfTheWeek ; var firstDay = now . valueOf ( ) + offset * 86400000 ; return this . getMidnight ( firstDay ) ; }
function Day ( options ) { var key ; for ( key in options ) { if ( options . hasOwnProperty ( key ) ) { this [ key ] = options [ key ] ; } } this . _initEvents ( ) ; }
function requireCalendarController ( ) { requireApp ( 'calendar/js/set.js' ) ; requireApp ( 'calendar/js/batch.js' ) ; requireApp ( 'calendar/js/template.js' ) ; requireApp ( 'calendar/js/format.js' ) ; requireApp ( 'calendar/js/responder.js' ) ; requireApp ( 'calendar/js/models/busytime.js' ) ; requireApp ( 'calendar/js/models/events.js' ) ; requireApp ( 'calendar/js/calc.js' ) ; requireApp ( 'calendar/js/controller.js' ) ; }
function ( set , arr ) { var i = 0 , missing = [ ] , item ; for ( i ; i < arr . length ; i ++ ) { item = arr [ i ] ; if ( ! set . has ( item ) ) { missing . push ( item ) ; } } return ( missing . length ) ? missing : true ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . id = 'test' ; div . innerHTML = [ '<div class="monthView"></div>' , '<div class="monthHeader"></div>' ] . join ( '' ) ; document . body . appendChild ( div ) ; controller = createController ( ) ; busytimes = controller . busytime ; subject = new Calendar . Views . Month ( { controller : controller , monthSelector : '#test .monthView' , currentMonthSelector : '#test .monthHeader' } ) ; }
function ( ) { assert . equal ( subject . monthSelector , '#test .monthView' ) ; assert . equal ( subject . currentMonthSelector , '#test .monthHeader' ) ; assert . instanceOf ( subject , Calendar . Responder ) ; assert . equal ( subject . controller , controller ) ; }
function ( ) { var div = document . createElement ( 'div' ) ; div . id = 'test' ; div . innerHTML = [ '<div class="dayHeader"></div>' , '<div class="eventList"></div>' ] . join ( ' ' ) ; document . body . appendChild ( div ) ; controller = createController ( ) ; events = controller . eventList ; subject = new Calendar . Views . MonthsDay ( { controller : controller , headerSelector : '#test .dayHeader' , eventsSelector : '#test .eventList' } ) ; }
function ( ) { assert . equal ( subject . headerSelector , '#test .dayHeader' ) ; assert . equal ( subject . controller , controller ) ; }
function cameraInit ( ) { this . switchButton . addEventListener ( 'click' , this . toggleCamera . bind ( this ) ) ; this . galleryButton . addEventListener ( 'click' , function ( ) { var host = document . location . host ; var domain = host . replace ( /(^[\w\d]+\.)?([\w\d]+\.[a-z]+)/ , '$2' ) ; window . parent . WindowManager . launch ( 'http://gallery.' + domain ) ; } ) ; this . setSource ( this . _camera ) ; }
function ti_end ( ) { try { navigator . mozVibrate ( [ 200 , 200 , 200 , 200 , 200 ] ) ; } catch ( e ) { } this . cancel ( ) ; this . chronoView . parentNode . classList . add ( 'ended' ) ; }
function contactsShowFavorites ( contacts ) { var count = contacts . length ; if ( count == 0 ) return ; var content = '<div id="favorites" class="contact-header">' + '<span>*</span></div>' ; for ( var i = 0 ; i < count ; i ++ ) { var contact = contacts [ i ] ; content += this . _contactFragment ( contact ) ; } this . favoritesContainer . innerHTML = content ; }
function contactsCreate ( ) { var contact = new mozContact ( ) ; contact . init ( { tel : [ ] , email : [ ] } ) ; ContactDetails . show ( contact ) ; }
function findCallback ( ) { if ( request . result . length == 0 ) return ; var contacts = request . result ; callback ( contacts [ 0 ] ) ; }
function cd_endEditing ( ) { if ( ! this . _editing ) { return false ; } this . _editing = false ; this . view . classList . remove ( 'editing' ) ; return true ; }
function cd_nextField ( element ) { var nextGroup = element . parentNode . nextElementSibling ; var nextElement = nextGroup . querySelector ( 'input' ) ; if ( nextElement ) { element = nextElement ; } return element ; }
function findByID ( contactID , callback ) { var options = { filterBy : [ 'id' ] , filterOp : 'equals' , filterValue : contactID } ; this . _findOne ( options , callback ) ; }
function cs_transitionNextLoop ( ) { callScreen . classList . add ( 'animate' ) ; callScreen . classList . toggle ( 'displayed' ) ; callScreen . classList . toggle ( 'prerender' ) ; callScreen . addEventListener ( 'transitionend' , function trWait ( ) { callScreen . removeEventListener ( 'transitionend' , trWait ) ; if ( displayed ) window . close ( ) ; } ) ; }
function ch_toggleSpeaker ( ) { this . speakerButton . classList . toggle ( 'speak' ) ; navigator . mozTelephony . speakerEnabled = ! navigator . mozTelephony . speakerEnabled ; }
function ( ) { var now = new Date ( ) ; var weekStartedTimestamp = DateHelper . thisWeekStarted ( ) ; var weekStarted = new Date ( weekStartedTimestamp ) ; assert . equal ( true , weekStartedTimestamp <= now . valueOf ( ) ) ; assert . equal ( weekStarted . getDay ( ) , 1 ) ; assertMidnight ( weekStarted ) ; }
function ( date ) { var today = this . today , month = date . getMonth ( ) == today . getMonth ( ) , day = date . getDate ( ) == today . getDate ( ) , year = date . getYear ( ) == today . getYear ( ) ; if ( month && day && year ) { return true ; } return false ; }
function ( id ) { var parts = id . split ( '-' ) , date , type ; if ( parts . length > 1 ) { type = parts . shift ( ) ; switch ( type ) { case 'd' : date = new Date ( parts [ 0 ] , parts [ 1 ] , parts [ 2 ] ) ; break ; case 'm' : date = new Date ( parts [ 0 ] , parts [ 1 ] ) ; break ; } return date ; } return false ; }
function ( date , day , month , year ) { day = day || 0 ; month = month || 0 ; year = year || 0 ; return new Date ( year || date . getFullYear ( ) , month || date . getMonth ( ) , day || date . getDate ( ) ) ; }
function ( day , month ) { var states ; if ( this . isToday ( day ) ) { return this . PRESENT ; } states = '' ; if ( this . isPast ( day ) ) { states += this . PAST ; } else { states += this . FUTURE ; } if ( day . getMonth ( ) !== month . getMonth ( ) ) { states += ' ' + this . OTHER_MONTH ; } return states ; }
function Month ( options ) { var self = this , key ; if ( typeof ( options ) === 'undefined' ) { options = { } ; } for ( key in options ) { if ( options . hasOwnProperty ( key ) ) { this [ key ] = options [ key ] ; } } this . selectedDay = null ; this . children = { } ; Calendar . Responder . call ( this ) ; this . _initEvents ( ) ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayStats ( this . config . showFPS ) ; director . setAnimationInterval ( 1.0 / this . config . frameRate ) ; director . runWithScene ( new this . startScene ( ) ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayStats ( this . config . showFPS ) ; director . setAnimationInterval ( 1.0 / this . config . frameRate ) ; director . runWithScene ( new this . startScene ( ) ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayStats ( this . config . showFPS ) ; director . setAnimationInterval ( 1.0 / this . config . frameRate ) ; director . runWithScene ( new this . startScene ( ) ) ; return true ; }
function ( ) { var director = cc . Director . sharedDirector ( ) ; director . setDisplayStats ( this . config . showFPS ) ; director . setAnimationInterval ( 1.0 / this . config . frameRate ) ; director . runWithScene ( new this . startScene ( ) ) ; return true ; }
function ( k ) { if ( k instanceof Array ) { if ( attrs [ k [ 0 ] ] ) wrapNested ( k [ 1 ] , attrs [ k [ 0 ] ] ) ; k = k [ 0 ] ; } if ( attrs [ k ] ) { attrs [ k + "_attributes" ] = attrs [ k ] ; delete attrs [ k ] ; } }
function ( v , k ) { var errField = jQuery ( "*[name='" + k + "'].field" ) ; if ( errField . is ( ':checkbox, :radio' ) ) errField = errField . parent ( ) ; errField . addClass ( "error" ) ; errField . one ( 'change focus' , function ( ) { errField . removeClass ( "error" ) ; } ) ; }
function ( ) { if ( ! report . photos ) report . photos = [ ] ; report . photos . push ( photo ) ; photo . report = report ; report . updatePhotosAttribute ( ) ; photo . on ( 'change sync' , report . updatePhotosAttribute , report ) ; console . log ( "Photo " + photo . id + " attached to report " + report . id ) ; if ( successCallback ) successCallback ( report , photo ) ; }
function ( ) { if ( ! this . photos ) this . photos = [ ] ; var photos = [ ] ; _ . each ( this . photos , function ( photo ) { photos . push ( photo . toJSON ( ) [ 'photo' ] ) ; } ) ; this . set ( 'photos' , photos ) ; this . trigger ( 'change' ) ; }
function ( tag ) { var tags = this . get ( 'tags' ) ; if ( ! tags ) tags = [ ] ; tags . push ( { tag : tag } ) ; this . set ( 'tags' , tags ) ; this . trigger ( 'change' ) ; }
function ( ) { var self = this ; if ( ! this . collection ) this . collection = new veos . model . Installations ( ) ; this . collection . on ( 'reset' , _ . bind ( this . render , self ) ) ; }
function ( ) { var self = this ; if ( ! this . collection ) this . collection = new veos . model . Reports ( ) ; this . collection . on ( 'reset' , _ . bind ( this . render , self ) ) ; }
function ( value ) { for ( var data = this . _options . items , length = data . length ; length -- ; ) { if ( data [ length ] . value == value ) { this . selectValue = value ; this . getElement ( 'input' ) . value = data [ length ] . content ; break ; } } }
function ( index ) { var item = this . _options . items [ index ] || this . _options . items [ 0 ] ; this . getElement ( 'input' ) . value = item . content ; this . selectValue = item . value ; }
function ( ) { this . _initInput ( ) ; }
function ( data ) { var html = "" ; for ( var index in data . notes ) { if ( CheckIfThisNoteNeedsToBeAdded ( data . notes [ index ] ) ) { html = html + CreateItem ( data . notes [ index ] , emailId ) ; } } $ ( '#container' ) . prepend ( html ) . masonry ( 'reload' ) ; new Board ( ) . vote ( ) ; }
function ( event ) { var pos ; pos = window . findClickPos ( event ) ; this . bombs . push ( new Bomb ( pos . x , pos . y ) ) ; if ( window . FONTBOMB_PREVENT_DEFAULT ) { return false ; } }
function ( event ) { var pos ; pos = window . findClickPos ( event ) ; this . bombs . push ( new Bomb ( pos . x , pos . y ) ) ; if ( window . FONTBOMB_PREVENT_DEFAULT ) return false ; }
function selectGame ( ) { var selector = $ ( this ) , wrapper = selector . closest ( 'div.pgn-source-wrapper' ) , currentGame = wrapper . data ( 'currentGame' ) ; currentGame . hide ( ) ; game . gotoBoard ( 0 ) ; wrapper . data ( 'currentGame' , game ) ; }
function ( ) { var wrapper = $ ( this ) . closest ( 'div.pgn-source-wrapper' ) , currentGame = wrapper . data ( 'currentGame' ) ; flip ^= 1 ; var rotation = flip ? 'rotate(180deg)' : 'rotate(0deg)' ; $ ( this ) . css ( { '-webkit-transform' : rotation , '-moz-transform' : rotation , '-ms-transform' : rotation , '-o-transform' : rotation , 'transform' : rotation } ) currentGame . gotoBoard ( currentGame . index ) ; }
function ( ) { $ ( '.tooltip_hider' ) . hover ( function ( ) { $ ( '.tooltip_pane' ) . slideDown ( 'normal' ) ; } , function ( ) { $ ( '.tooltip_pane' ) . slideUp ( 'fast' ) ; } ) ; }
function ( ind , dome ) { var status = $ ( dome ) . find ( '.tr_status' ) . html ( ) ; if ( status ) { status = status . toLowerCase ( ) ; if ( status == 'failure' ) { $ ( dome ) . removeClass ( ) ; } $ ( dome ) . addClass ( 'track-' + status ) ; } }
function ( ) { var element = $compile ( '<textarea ui-codemirror ng-model="foo"></textarea>' ) ( scope ) ; scope . foo = 'bar' ; scope . $apply ( ) ; expect ( element . siblings ( ) . text ( ) . trim ( ) ) . toBe ( scope . foo ) ; }
function ( msg , mtype ) { if ( mtype in self . mtable ) { self . mtable [ mtype ] ( msg ) ; } if ( mtype == "HEARTBEAT" ) { self . commStatusModel . onHeartbeat ( ) ; } }
function ( ) { Log ( "App: Initialization started..." ) ; $ . ajaxSetup ( { cache : false } ) ; $ ( "head" ) . append ( "<link href='" + GetURL ( "Pages/PAStyles.css" ) + "' type='text/css' rel='stylesheet' />" ) ; this . InitializeModalView ( ) ; this . isModalViewActive = false ; this . GetActivePage ( ) ; this . Load ( ) ; }
function Request ( requestSign , requestCategory , requestName , actionName , requestData ) { this . requestSign = requestSign ; this . requestCategory = requestCategory ; this . requestName = requestName ; this . actionName = actionName ; this . requestData = requestData ; this . Send = function ( callback ) { chrome . extension . sendRequest ( this , callback || function ( ) { } ) ; } ; }
function GotRequest ( request , sender , sendResponse ) { DLog ( "Got request { requestSign: " + request . requestSign + ", requestCategory: " + request . requestCategory + ", requestName: " + request . requestName + ", actionName: " + request . actionName + ", requestData: " + request . requestData + " }" ) ; switch ( request . requestCategory ) { case "Notification" : GotNotificationRequest ( request ) ; break ; case "Data" : GotDataRequest ( request , sendResponse ) ; break ; default : console . error ( "BackgroundScript: Unknown category!" , request ) ; break ; } }
function GotNotificationRequest ( request ) { DLog ( "BackgroundScript: Got Notification request." ) ; if ( request . actionName == "Show" ) { notificationManager . Show ( request . requestData ) ; } }
function enhancementInitDetails ( type ) { $ ( 'tr.parent.' + type + ' span.detailsLink' ) . attr ( "title" , "Click for message details" ) . click ( function ( ) { var messageID = this . id . substring ( this . id . indexOf ( '_' ) + 1 ) ; enhancementLoadDetails ( messageID , type ) ; } ) ; }
function enhancementWriteJob ( d , type ) { var out = "<tr class='parent " + type + "' id='a" + d . id + "'>" ; out = out + "<td>" + type + "</td><td>" + d . targetPID + "</td><td><ul>" ; for ( filteredService in d . filteredServices ) { out += "<li>" + d . filteredServices [ filteredService ] + "</li>" ; } out = out + "</ul></td><td>" ; out += "<span id=\"" + type + "_" + d . id + "\" class='" + type + "Message detailsLink'>Message</span><br/>" ; out = out + "</td></tr>" ; return out ; }
function ( name , map , reduce ) { var view = { } ; if ( reduce ) { view [ 'reduce' ] = reduce ; } if ( map !== undefined ) { view [ 'map' ] = map ; this . body ( 'views' , name , ( ( map === null ) ? undefined : view ) ) ; } return ( ( map !== undefined ) ? this : ( this . _body . views ) ? this . _body . views [ name ] : undefined ) ; }
function ( pos , type ) { this . graphics . hideEntity ( this . world [ pos . x ] [ pos . y ] [ type ] ) ; this . world [ pos . x ] [ pos . y ] [ type ] = null ; return true ; }
function ( pos ) { if ( pos == null ) { pos = SNAKE . Utils . randPair ( this . squaresX - 1 , this . squaresY - 1 ) ; } this . foodItems . enqueue ( pos ) ; if ( this . foodCount > this . maxFood ) { return this . foodItems . dequeue ( ) ; } }
function ( e ) { e . preventDefault ( ) ; var ngModel = $parse ( attrs . ngModel ) ; ngModel . assign ( scope , null ) ; scope . $apply ( ) ; }
function ( e ) { e . preventDefault ( ) ; var ngModel = $parse ( attrs . ngModel ) ; ngModel . assign ( scope , null ) ; scope . $apply ( ) ; }
function unselect_metadata_file ( ) { unselect_sequence_file ( ) selected_metadata_file = "" ; selected_libraries = [ ] ; document . getElementById ( "sel_md_pill" ) . className = "pill_incomplete" ; document . getElementById ( "icon_step_1" ) . style . display = "none" ; document . getElementById ( "sel_project_pill" ) . className = "pill_incomplete" ; document . getElementById ( "icon_step_2" ) . style . display = "none" ; update_inbox ( ) ; check_submittable ( ) ; }
function ( ) { var frame = this . frame var startCalled frame . $ ( "#main" ) . on ( "pjax:start" , function ( ) { startCalled = this } ) frame . $ . pjax ( { url : "hello.html" , container : "#main" , success : function ( ) { equal ( startCalled , frame . $ ( "#main" ) [ 0 ] ) start ( ) } } ) }
function Plugin ( element , options ) { this . element = element ; this . options = $ . extend ( { } , defaults , options ) ; this . _defaults = defaults ; this . _name = pluginName ; this . init ( ) ; }
function ( val ) { var unique = [ ] ; if ( this . select ) { this . select . val ( val ) ; } else { $ ( val ) . each ( function ( ) { if ( indexOf ( this , unique ) < 0 ) unique . push ( this ) ; } ) ; this . opts . element . val ( unique . length === 0 ? "" : unique . join ( "," ) ) ; } }
function ( error ) { console . log ( error + "\n" ) ; if ( error . stack ) { error . stack . forEach ( function ( item ) { var message = item . sourceURL + ":" + item . line ; if ( item . function ) message += " in " + item . function ; console . log ( "  " + message ) ; } ) ; } }
function ( msg ) { var msg = msg || { method : 'postUrl' , url : "test_url" } ; var deferred = $ . Deferred ( ) ; var promise = deferred . promise ( ) ; chrome . extension . sendMessage ( msg , function ( response ) { deferred . resolve ( response ) ; } ) ; return promise ; }
function ( ) { var fields = JSON . parse ( this . buffer ) ; for ( var field in fields ) { this . onField ( field , fields [ field ] ) ; } this . buffer = '' ; this . onEnd ( ) ; }
function ( fileImage ) { this . _super ( ) ; if ( fileImage ) { this . initWithFile ( fileImage , cc . DEFAULT_SPRITE_BATCH_CAPACITY ) ; } this . setContentSize ( new cc . Size ( cc . canvas . width , cc . canvas . height ) ) ; this . _renderTexture = cc . RenderTexture . create ( cc . canvas . width , cc . canvas . height ) ; }
function ( pos ) { var ret = cc . PointZero ( ) ; switch ( this . _layerOrientation ) { case cc . TMXOrientationOrtho : ret = this . _positionForOrthoAt ( pos ) ; break ; case cc . TMXOrientationIso : ret = this . _positionForIsoAt ( pos ) ; break ; case cc . TMXOrientationHex : ret = this . _positionForHexAt ( pos ) ; break ; } return ret ; }
function ( z ) { var item ; if ( this . _atlasIndexArray ) { for ( var i = 0 ; i < this . _atlasIndexArray . length ; i ++ ) { item = this . _atlasIndexArray [ i ] if ( item == z ) { break ; } } } cc . Assert ( item , "TMX atlas index not found. Shall not happen" ) ; return i ; }
function ( layerName ) { if ( this . _TMXLayers . hasOwnProperty ( layerName ) ) { return this . _TMXLayers [ layerName ] ; } return null ; }
function ( tmxFile ) { this . _tileSets = [ ] ; this . _layers = [ ] ; this . _TMXFileName = tmxFile ; this . _objectGroups = [ ] ; this . _properties = [ ] ; this . _tileProperties = [ ] ; this . _currentString = "" ; this . _storingCharacters = false ; this . _layerAttribs = cc . TMXLayerAttribNone ; this . _parentElement = cc . TMXPropertyNone ; return this . parseXMLFile ( this . _TMXFileName ) ; }
function ( ) { this . _super ( ) ; var map = cc . TMXTiledMap . create ( "Resources/TileMaps/orthogonal-test1.tmx" ) ; this . addChild ( map , 0 , TAG_TILE_MAP ) ; var childrenArray = map . getChildren ( ) ; for ( var i = 0 ; i < childrenArray . length ; i ++ ) { var child = childrenArray [ i ] ; if ( ! child ) break ; } map . runAction ( cc . ScaleBy . create ( 2 , 0.5 ) ) ; }
function ( dt ) { var p = this . tamara . getPositionInPixels ( ) ; var map = this . getChildByTag ( TAG_TILE_MAP ) ; var newZ = 4 - ( p . y / 48 ) ; newZ = Math . max ( newZ , 0 ) ; map . reorderChild ( this . tamara , newZ ) ; }
function ( dt ) { var p = this . tamara . getPositionInPixels ( ) ; var map = this . getChildByTag ( TAG_TILE_MAP ) ; var newZ = 4 - ( ( p . y - 10 ) / 81 ) ; newZ = Math . max ( newZ , 0 ) ; map . reorderChild ( this . tamara , newZ ) ; }
function ( ) { Main . panel . _rightBox . insert_child_at_index ( this . actor , 0 ) ; Main . panel . _menus . addMenu ( this . menu ) ; let fileM = Gio . file_new_for_path ( this . file [ 0 ] ) ; this . monitor = fileM . monitor ( Gio . FileMonitorFlags . NONE , null ) ; this . monitor . connect ( 'changed' , Lang . bind ( this , this . _refresh ) ) ; }
function changePerflvl ( n , file ) { if ( CheckForNVFile ( file ) ) { nv_log ( "Setting new perflvl: " + n ) ; let [ success , argv ] = GLib . shell_parse_argv ( _ ( "pkexec /bin/sh -c " + "\"" + " echo " + n + " > " + file + "\"" ) ) ; GLib . spawn_async_with_pipes ( null , argv , null , GLib . SpawnFlags . SEARCH_PATH | GLib . SpawnFlags . DO_NOT_REAP_CHILD , null , null ) ; } }
function ( err , fbid ) { if ( err || fbid === null ) { socket . emit ( 'error' ) ; } addPlayerToSocket ( fbid , socket , function ( err , player ) { if ( err ) { socket . emit ( 'error' ) ; } else { player . time = data . lapTime ; player . save ( ) ; } } ) ; }
function ( fileName ) { if ( path . existsSync ( path . join ( options . resources , fileName ) ) ) { return path . join ( options . resources , fileName ) ; } else { return path . resolve ( __dirname , path . join ( '../resources' , fileName ) ) ; } }
function ( response ) { $el . replaceWith ( response ) ; if ( $ ( response ) . hasClass ( 'building' ) ) { showAsBuilding ( '#' + projectCssId ) ; $ ( '#' + projectCssId ) . fadeTo ( 1000 , 0.5 ) . fadeTo ( 1000 , 1 ) ; } }
function ( value ) { this . isTranslatingPages = value ; if ( value ) { var that = this ; that . translatingTimeout = setTimeout ( function ( ) { that . isTranslatingPages = false ; that . checkLimits ( ) ; } , 1000 ) ; } }
function ft ( e ) { this . style . MozAnimationName = '' ; this . removeEventListener ( 'animationend' , ft ) ; if ( this === tnode ) { that . olist . insertBefore ( onode , ( upward ) ? tnode : tnode . nextSibling ) ; that . freeze = false ; } }
function ( icon ) { var olist = this . olist ; if ( olist . childNodes . length > 0 ) { olist . insertBefore ( icon . container , this . olist . firstChild ) ; } else { olist . appendChild ( icon . container ) ; } this . icons [ icon . descriptor . origin ] = icon ; }
function findSpecName ( specId , suites ) { for ( var i in suites ) { if ( suites [ i ] . id == specId ) { return suites [ i ] . name ; } var name = findSpecName ( specId , suites [ i ] . children ) ; if ( name ) { return suites [ i ] . name + ' ' + name } ; } }
function ( ) { this . control ( { 'taskField' : { keyup : this . onTaskFieldKeyup } , 'taskList' : { todoChecked : this . onTodoChecked , itemdblclick : this . onTodoDblClicked } , 'completeButton' : { click : this . onClearButtonClick } , 'checkAllBox' : { click : this . onCheckAllClick } } ) ; this . getTasksStore ( ) . on ( { scope : this , update : this . onStoreDataChanged , datachanged : this . onStoreDataChanged } ) ; }
function ( field , event ) { var ENTER_KEY_CODE = 13 ; var value = field . getValue ( ) ; if ( event . keyCode === ENTER_KEY_CODE && value !== '' ) { var store = this . getTasksStore ( ) ; store . add ( { label : value , checked : false } ) ; field . reset ( ) ; store . sync ( ) ; } }
function ( ) { var records = [ ] , store = this . getTasksStore ( ) ; store . each ( function ( record ) { if ( record . get ( 'checked' ) ) { records . push ( record ) ; } } ) ; store . remove ( records ) ; store . sync ( ) ; }
function ( clickEvent , el ) { var extEl = Ext . get ( el ) , parent ; if ( extEl . getAttribute ( 'type' ) === 'checkbox' ) { parent = extEl . parent ( 'li' ) this . fireEvent ( 'todoChecked' , this . getRecord ( parent ) ) ; } }
function browser_selectTab ( id ) { this . currentTab = this . tabs [ id ] ; this . urlInput . value = this . currentTab . title ; this . tabCover . setAttribute ( 'src' , this . currentTab . screenshot ) ; if ( this . currentTab . loading ) { this . throbber . classList . add ( 'loading' ) ; } this . updateSecurityIcon ( ) ; this . refreshButtons ( ) ; }
function ( ) { charm . background ( ix ++ ) . write ( ' ' ) ; if ( ix === 256 ) { clearInterval ( iv ) ; charm . write ( '\n' ) ; exit ( ) ; } }
function ( ) { var next = [ ] , latest = [ ] ; collectEpisodes ( anime , req . responseXML . getElementsByTagName ( 'item' ) , next , latest ) ; UI . list ( next , el , '.next .torrent' , { render : applyHref } ) ; UI . list ( latest , el , '.latest .torrent' , { render : applyHref } ) ; UI . removeCls ( el , 'loading' ) ; }
function ( storyElementIndex ) { var storyElement = this . storyNode . children [ storyElementIndex ] ; if ( this . storyview && this . storyview . remove ) { if ( ! this . storyview . remove ( storyElement ) ) { storyElement . domNode . parentNode . removeChild ( storyElement . domNode ) ; } } this . storyNode . children . splice ( storyElementIndex , 1 ) ; }
function ( spec ) { if ( filterString === undefined ) { return false ; } if ( ! self . _topLevelFilter ( spec ) ) { return false ; } if ( filterString === "All" ) { return true ; } var topLevelSuite = spec . suite ; while ( topLevelSuite . parentSuite ) { topLevelSuite = topLevelSuite . parentSuite ; } return topLevelSuite . description === filterString ; }
function ( ) { expect ( testWindow . $ ( ".modal.instance" ) . length ) . toBe ( 1 ) ; var dismissButton = testWindow . $ ( ".modal.instance .dialog-button[data-button-id='" + buttonId + "']" ) ; expect ( dismissButton . length ) . toBe ( 1 ) ; dismissButton . click ( ) ; }
function ( response ) { var form = jQuery ( '#type-metadata-form' ) ; form . hide ( ) ; form . html ( response ) ; form . trigger ( 'omeka:elementformload' ) ; form . slideDown ( 1000 , function ( ) { jQuery ( this ) . show ( ) ; } ) ; }
function ( ) { var instance ; instance = $ . data ( this , 'sqstatus' ) ; if ( ! instance ) { return $ . data ( this , 'sqstatus' , new SQStatus ( this , options ) ) ; } else if ( typeof options === "string" ) { return instance [ command ] . apply ( instance , args ) ; } }
function ( ) { var twipsyOptions = { placement : 'below' , delayIn : 700 } , contactView = new Contact . Views . Contact ( { el : '#contact' } ) ; $ ( '#cats' ) . modal ( { backdrop : true } ) ; $ ( 'ul.social-icons, a.icon' ) . twipsy ( twipsyOptions ) ; $ ( 'nav a' ) . twipsy ( $ . extend ( { } , twipsyOptions , { offset : - 20 } ) ) ; }
function ( objectref ) { for ( var i = 0 , cookie ; cookie = this . cookie_list [ i ] ; i ++ ) { if ( cookie . _objectref === objectref ) { return cookie ; } } ; }
function ( ) { opera . _debug_wrap_scopeTransmit = opera . scopeTransmit ; opera . scopeTransmit = function ( service , message , command , tag ) { window . debug . log_transmit ( service , message , command , tag ) ; opera . _debug_wrap_scopeTransmit ( service , message , command , tag ) ; } ; cls . debug . wrap_transmit = function ( ) { } ; }
function ( msg ) { return msg . replace ( /^handle/ , "" ) . replace ( /^on/ , "On" ) ; }
function ( win ) { return ( [ 'li' , win ? [ 'pre' , 'window id: ' + win . window_id + '\n' + 'title: ' + win . title + '\n' + 'window type: ' + win . window_type + '\n' + 'opener id: ' + win . opener_id ] : [ ] ] ) ; }
function ( event , target ) { var bp_id = parseInt ( event . target . get_attr ( 'parent-node-chain' , 'data-breakpoint-id' ) ) ; var bp = this . _bps . get_breakpoint_with_id ( bp_id ) ; if ( bp ) { this . _toggle_bp ( bp , event . target . checked ) ; } }
function ( event ) { if ( this . mode != MODE_DEFAULT && this . editor ) this . editor . submit ( ) ; if ( selection ) selection . removeAllRanges ( ) ; view_container = null ; view_container_first_child = null ; nav_target = null ; selection = null ; range = null ; document . removeEventListener ( 'DOMNodeInserted' , ondomnodeinserted , false ) ; }
function ( e ) { var target , _ref ; target = e . target || e . srcElement ; if ( target !== itembox && __indexOf . call ( itembox . getElementsByTagName ( 'ul' ) , target ) < 0 && __indexOf . call ( itembox . childNodes , target ) < 0 && ( ( _ref = target . tagName ) !== 'LI' && _ref !== 'A' && _ref !== 'INPUT' && _ref !== 'SELECT' && _ref !== 'OPTION' ) ) { return itembox . style . display = 'none' ; } }
function ( table ) { this . primaryKey ( "id" ) ; this [ underscore ? "company_name" : "companyName" ] ( "string" , { size : 20 , allowNull : false } ) ; this . salary ( "double" , { size : [ 20 , 8 ] , allowNull : false } ) this . foreignKey ( underscore ? "employee_id" : "employeeId" , "employee" , { key : "id" } ) ; }
function ( ds , model , self , parent ) { remove ? ds . filter ( q ) . remove ( ) : ds . filter ( q ) . update ( removeQ ) ; if ( loaded ) { parent . _reloadAssociationsForType ( self . type , self . model , model ) ; } return model ; }
function ( Employee ) { var emp = Employee . findById ( 1 ) ; emp . lastName = "martin" ; return emp . reload ( ) ; }
function ( next ) { var id = sql . identifier ( "id" ) ; Employee . first ( id . gt ( 5 ) , id . lt ( 11 ) ) . then ( function ( emp ) { assert . instanceOf ( emp , Employee ) ; assert . equal ( emp . id , 6 ) ; next ( ) ; } ) ; }
function ( Employee ) { var emp = Employee . findById ( 1 ) ; emp . lastname = "martin" ; return emp . reload ( ) ; }
function ( next ) { var id = sql . identifier ( "id" ) ; Employee . first ( id . gt ( 5 ) , id . lt ( 11 ) ) . then ( function ( emp ) { assert . instanceOf ( emp , Employee ) ; assert . equal ( emp . id , 6 ) ; next ( ) ; } ) ; }
function ( manager , i ) { assert . equal ( manager . name , "Manager " + i ) ; assert . equal ( manager . numStaff , manager . staff . length ) ; if ( manager instanceof Executive ) { assert . equal ( manager . numManagers , 0 ) ; } }
function ( value ) { if ( comb . isInstanceOf ( value , Buffer ) ) { return value ; } else if ( Array . isArray ( value ) || comb . isString ( value ) ) { return new Buffer ( value ) ; } else { throw new Error ( "Invalid value for blob " + value ) ; } }
function ( widgetid ) { var datamodel = itemlistmodel . model [ this . app . selected_item ] ; var date = datamodel . get ( "reminderDate" ) ; if ( ! date ) { date = stamp . toISOString ( new Date ( ) , { selector : "date" } ) ; } registry . byId ( "reminddlgpicker1" ) . set ( "value" , date ) ; registry . byId ( 'datePicker' ) . show ( dom . byId ( widgetid ) , [ 'above-centered' , 'below-centered' , 'after' , 'before' ] ) ; }
function ( newPeerInfo ) { if ( newPeerInfo == null || typeof newPeerInfo == 'undefined' ) { res . send ( errCodes . ERR_PEER_NOT_SPECIFIED , 400 ) ; } else { res . send ( "Success" , 200 ) ; } }
function ( ) { CSLEDIT . viewController . setSuppressSelectNode ( true ) ; executeCommand ( "addNode" , [ infoNode . cslId , "last" , new CSLEDIT . CslNode ( item . node ) ] ) ; CSLEDIT . viewController . setSuppressSelectNode ( false ) ; setupPanel ( panel ) ; }
function ( node ) { var selector = node . attr ( 'bx-tmpl-source' ) ; var temptmplNode = tmplNode . one ( selector ) . clone ( true ) ; temptmplNode . removeAttr ( 'id' ) ; _stamp ( temptmplNode , 'tmpl_' ) ; temptmplNode . insertBefore ( node ) ; node . remove ( ) ; }
function ( ) { var self = this ; var defaultEvents = self . constructor . ATTACH ; if ( defaultEvents ) { self . _removeEvents ( defaultEvents ) ; } var defaultDocEvents = self . constructor . DOCATTACH ; if ( defaultDocEvents ) { self . _removeEvents ( defaultDocEvents , S . one ( document ) ) ; } self . _undelegateEvents ( ) ; var events = self . get ( "events" ) ; if ( events ) { this . _removeEvents ( events ) ; } }
function ( value ) { if ( ! this . tail ) { console . logGroup ( 'warn' , 'Unfilled values' , this . warnings ) ; console . logGroup ( 'warn' , 'Missing -> Wrappers' , this . forgotten ) ; console . logGroup ( 'log' , 'Overwrites' , this . overwrites ) ; console . logGroup ( 'log' , 'Choices' , this . choices ) ; console . group ( 'All extracted data' ) ; console . log ( value ) ; console . groupEnd ( ) ; } }
function ( left , right , raw , line , column ) { return new LogicalNotOp ( new constructorLookup [ op ] ( left , right ) . r ( raw ) . p ( line , column ) ) . r ( raw ) . g ( ) ; }
function getClass ( simpleName ) { var cache = this . cache ; var c = cache [ simpleName ] ; if ( ! c ) { c = cache [ simpleName ] = this . getProperty ( Multiname . fromSimpleName ( simpleName ) , true , true ) ; } assert ( c instanceof Class ) ; return c ; }
function StringClass ( runtime , scope , instance , baseClass ) { var c = new Class ( "String" , String , C ( String ) ) ; c . baseClass = baseClass ; var m = String . prototype ; defineNonEnumerableProperty ( m , "get length" , function ( ) { return this . length ; } ) ; c . nativeMethods = m ; c . nativeStatics = String ; c . isInstance = function ( value ) { return typeof value === "string" ; } ; return c ; }
function ArrayClass ( runtime , scope , instance , baseClass ) { var c = new Class ( "Array" , Array , C ( Array ) ) ; c . baseClass = baseClass ; var m = Array . prototype ; defineNonEnumerableProperty ( m , "get length" , function ( ) { return this . length ; } ) ; defineNonEnumerableProperty ( m , "set length" , function ( l ) { this . length = l ; } ) ; c . nativeMethods = m ; return c ; }
function NumberClass ( runtime , scope , instance , baseClass ) { var c = new Class ( "Number" , Number , C ( Number ) ) ; c . baseClass = baseClass ; c . nativeMethods = Number . prototype ; c . defaultValue = Number ( 0 ) ; c . isInstance = function ( value ) { return typeof value === "number" ; } ; c . coerce = Number ; return c ; }
function intClass ( runtime , scope , instance , baseClass ) { function int ( x ) { return Number ( x ) | 0 ; } var c = new Class ( "int" , int , C ( int ) ) ; c . baseClass = baseClass ; c . defaultValue = 0 ; c . isInstance = function ( value ) { return ( value | 0 ) === value ; } ; c . coerce = int ; return c ; }
function uintClass ( runtime , scope , instance , baseClass ) { function uint ( x ) { return Number ( x ) >>> 0 ; } var c = new Class ( "uint" , uint , C ( uint ) ) ; c . baseClass = baseClass ; c . defaultValue = 0 ; c . isInstance = function ( value ) { return ( value >>> 0 ) === value ; } ; c . coerce = uint ; return c ; }
function DateClass ( runtime , scope , instance , baseClass ) { var c = new Class ( "Date" , Date , C ( Date ) ) ; c . baseClass = baseClass ; c . nativeMethods = Date . prototype ; c . nativeStatics = Date ; return c ; }
function ( runtime , scope , instance , baseClass ) { var c = new Class ( name , instance , CC ( instance ) ) ; c . extend ( baseClass ) ; c . nativeMethods = { getStackTrace : function ( ) { return "TODO: geStackTrace" ; } } ; c . nativeStatics = { getErrorMessage : function ( ) { return "TODO: getErrorMessage" ; } } ; return c ; }
function CapabilitiesClass ( runtime , scope , instance , baseClass ) { function Capabilities ( ) { } var c = new Class ( "Capabilities" , Capabilities , C ( Capabilities ) ) ; c . extend ( baseClass ) ; c . nativeStatics = { "get playerType" : function ( ) { return "AVMPlus" ; } } ; return c ; }
function ( parentDomain ) { var parent ; if ( ! parentDomain ) { parent = Runtime . stack . top ( ) . domain ; while ( parent . base ) { parent = parent . base ; } } else { parent = parentDomain . d ; } glue ( new Domain ( parent ) , this ) ; }
function Traits ( traits , verified ) { this . traits = traits ; this . verified = verified === undefined ? false : verified ; }
function ( i ) { return this [ i ] ; }
function Global ( runtime , script ) { script . global = this ; script . abc = runtime . abc ; runtime . applyTraits ( this , script . traits , null , new Scope ( null , this ) ) ; script . loaded = true ; }
function closeOverScope ( fn , scope ) { var closure = function ( ) { Array . prototype . unshift . call ( arguments , scope ) ; var global = ( this === jsGlobal ? scope . global . object : this ) ; return fn . apply ( global , arguments ) ; } ; closure . instance = closure ; defineNonEnumerableProperty ( closure . prototype , "public$constructor" , closure ) ; return closure ; }
function translateError ( error ) { if ( error instanceof Error ) { var type = this . domain . getClass ( error . name ) ; if ( type ) { return new type . instance ( error . message ) ; } unexpected ( "Can't translate error: " + error ) ; } return error ; }
function ( isNuclear ) { IRC . message ( channel , 'BOOM!' ) ; if ( isNuclear ) { IRC . ban ( channel , challenged ) ; } IRC . kick ( channel , challenged , 'You failed to disarm the bomb! Correct wire was ' + color ) ; challenged = '' ; channel = '' ; clearInterval ( countdown ) ; }
function ( args ) { var isNuclear = ( args . command == 'nuclearbomb' ) ; if ( args . user == challenged ) { if ( args . message == color || ( args . message == '42' && bot . getUserLevel ( args . user , args . host ) >= USER_LEVEL_MOD ) ) { IRC . message ( channel , 'Correct wire!' ) ; disarm ( ) ; } else { IRC . message ( channel , 'Wrong wire!' ) ; explode ( isNuclear ) ; } } }
function ( key ) { if ( typeof item [ key ] === 'object' ) { Object . keys ( item [ key ] ) . forEach ( function ( k ) { if ( k [ 0 ] == '$' ) { commands [ key ] = item [ key ] ; } } ) } }
function ( entry , left_val , do_raw ) { return ( [ "div" , [ "span" , [ "span" , "class" , "close-request-detail" , "handler" , "close-request-detail" , "tabindex" , "1" ] , "class" , "resize-request-detail" , "handler" , "resize-request-detail" ] , [ "div" , templates . _details_content ( entry , do_raw ) , "data-object-id" , String ( entry . id ) , "class" , "entry-details" ] , "class" , "network-details-container" , "style" , "left:" + left_val + "px" ] ) ; }
function ( entry ) { var data = cls . ResourceManager [ "1.2" ] . UrlLoad . URLType . DATA ; return ( [ "tbody" , templates . _wrap_col_or_row ( [ "p" , entry . urltype === data ? ui_strings . S_NETWORK_NOT_REQUESTED : ui_strings . S_NETWORK_SERVED_FROM_CACHE ] ) ] ) ; }
function ( do_raw , request_response , index , requests_responses ) { var is_last = index == requests_responses . length - 1 ; var template_func = templates . _response ; if ( request_response instanceof cls . NetworkLoggerRequest ) template_func = templates . _request ; return template_func ( request_response , is_last , do_raw ) ; }
function ( status , data , update_callback , entry ) { if ( ! this . _current_context ) return ; entry . is_fetching_body = false ; if ( status ) { this . _current_context . update ( "responsebody" , { resourceID : entry . resource_id } ) ; } else { var msg = new cls . ResourceManager [ "1.2" ] . ResourceData ( data ) ; this . _current_context . update ( "responsebody" , msg ) ; } if ( this . is_paused && update_callback ) update_callback ( ) ; }
function ( event ) { this . last_responsecode = event . responseCode ; this . error_in_last_response = /^[45]/ . test ( this . last_responsecode ) ; this . _current_response = new cls . NetworkLoggerResponse ( this ) ; this . requests_responses . push ( this . _current_response ) ; this . _current_response . _update_event_response ( event ) ; }
function ( event , listener ) { _$jscoverage [ 'nssocket.js' ] [ 136 ] ++ ; if ( typeof event === "string" ) { _$jscoverage [ 'nssocket.js' ] [ 137 ] ++ ; event = event . split ( this . delimiter ) ; } _$jscoverage [ 'nssocket.js' ] [ 139 ] ++ ; return this . once ( [ "data" ] . concat ( event ) , listener ) ; }
function ( proxy , bus ) { this . proxy = proxy ; this . bus = bus ; this . IE8 = false ; this . sql = '' + 'SELECT DISTINCT l.scientificname as name,' + '       l.type as type,' + '       t.title as type_title,' + '       l.provider as source, ' + '       p.title as provider_title,' + '       n.class as _class, ' + '       l.feature_count as feature_count,' + '       n.common_names_eng as names,' + '       CONCAT(\'{sw:{lat:\',ST_XMin(l.extent),\', lng:\',ST_YMin(l.extent),\'} , ne:{lat:\',ST_XMax(l.extent),\', lng:\',ST_YMax(l.extent),\'}}\') as extent ' + 'FROM layer_metadata l ' + 'LEFT JOIN types t ON ' + '       l.type = t.type ' + 'LEFT JOIN providers p ON ' + '       l.provider = p.provider ' + 'LEFT JOIN taxonomy n ON ' + '       l.scientificname = n.scientificname ' + 'WHERE ' + "  l.scientificname~*'\\m{0}' OR n.common_names_eng~*'\\m{0}'" ; this . term = null ; }
function ( proxy , bus ) { this . proxy = proxy ; this . bus = bus ; this . searching = { } ; this . names = [ ] ; this . sql = '' + 'SELECT DISTINCT l.scientificname as name,' + '       l.type as type,' + '       t.title as type_title,' + '       l.provider as source, ' + '       p.title as provider_title,' + '       n.class as _class, ' + '       l.feature_count as feature_count,' + '       n.common_names_eng as names,' + '       CONCAT(\'{sw:{lat:\',ST_XMin(l.extent),\', lng:\',ST_YMin(l.extent),\'} , ne:{lat:\',ST_XMax(l.extent),\', lng:\',ST_YMax(l.extent),\'}}\') as extent ' + 'FROM layer_metadata l ' + 'LEFT JOIN types t ON ' + '       l.type = t.type ' + 'LEFT JOIN providers p ON ' + '       l.provider = p.provider ' + 'LEFT JOIN taxonomy n ON ' + '       l.scientificname = n.scientificname ' + 'WHERE ' + "  l.scientificname~*'\\m{0}' OR n.common_names_eng~*'\\m{0}'" ; }
function Scanner ( ) { this . tokenPat = new RegExp ( "\\n *|" + baseTokenPat . source ) ; this . tokens = { } ; this . tokenTypes = [ ] ; this . groupOpens = { '(' : ')' } ; this . groupCloses = { ')' : 1 } ; }
function ( group , rest ) { return [ group ( Nil , str . length - rest . length ) , null , rest ] ; }
function ( x , y ) { if ( an . g . undoManager . shouldRegister ( this , this . moveTo ) ) { var pt = this . getBeginPoint ( ) ; an . g . undoManager . registerUndo ( this , this . moveTo , [ pt . x , pt . y ] ) ; } for ( var i = 0 ; i < this . edges . length ; i ++ ) { this . edges [ i ] . translate ( x , y ) ; } }
function ( src , command , data , tar , channel ) { var user = SESSION . users ( src ) ; if ( command in commands ) { commands [ command ] ( { "user" : user , "data" : data , "target" : tar , "channel" : channel } ) ; } }
function ( params ) { var user = params . user ; user . print ( "Meowth" , "This is a RPG server in construction! Nothing to see just yet, be patient ~" ) ; }
function ( err ) { fn . load_articles ( options , function ( articles ) { articles = articles . sort ( function ( a , b ) { return b . date - a . date ; } ) ; fn . render_rss ( options , articles , function ( ) { fn . render_blog ( options , articles , cb ) ; } ) ; } ) ; }
function ( el ) { if ( ! androidFixOn ) { console . log ( "deploying forms scroll android fix" ) ; androidFixOn = true ; for ( el in cache ) if ( checkConsistency ( el ) && needsFormsFix ( el ) ) cache [ el ] . startFormsMode ( ) ; } }
function ( el ) { if ( androidFixOn ) { console . log ( "removing forms scroll android fix" ) ; androidFixOn = false ; for ( el in cache ) if ( checkConsistency ( el ) && needsFormsFix ( el ) ) cache [ el ] . stopFormsMode ( ) ; } }
function ( e ) { if ( ! this . scrollingLocked ) { switch ( e . type ) { case 'touchstart' : this . preventHideRefresh = ! this . refreshRunning ; this . moved = false ; this . onTouchStart ( e ) ; break ; case 'touchmove' : this . onTouchMove ( e ) ; break ; case 'touchend' : this . onTouchEnd ( e ) ; break ; break ; } } }
function ( el , leaveRefresh ) { if ( ! leaveRefresh ) this . refresh = true ; if ( this . refresh && this . refresh == true ) { this . coreAddPullToRefresh ( el ) ; this . el . style . overflow = 'visible' ; } }
function ( ) { if ( this . hscrollBar ) { this . hscrollBar . style . opacity = 0 this . hscrollBar . style . webkitTransitionDuration = "0ms" ; } if ( this . vscrollBar ) { this . vscrollBar . style . opacity = 0 this . vscrollBar . style . webkitTransitionDuration = "0ms" ; } }
function ( o ) { var ty ; var lty = this . consequent . ty ; var rty = this . alternate . ty ; print ( lty ) ; print ( rty ) ; if ( typeof lty === "undefined" || typeof rty === "undefined" ) { return this ; } if ( lty . assignableFrom ( rty ) ) { ty = lty ; } else if ( rty . assignableFrom ( lty ) ) { ty = rty ; } return cast ( this , ty ) ; }
function ( filename ) { if ( filename == null ) { return "" ; } let fileTypeRex = /^[^?&]*(\.[a-z0-9]+)([?&].*)?$/i ; let type = ".jpg" ; if ( fileTypeRex . test ( filename ) ) { type = filename . replace ( fileTypeRex , "$1" ) ; } return type ; }
function ( label , options ) { var button = helpers . dom . button ( label , options . callback , options . context , options . type ) ; if ( options . title ) { button . addAttribute ( 'title' , options . title ) ; } this . div . appendChild ( button ) ; }
function ( bool ) { if ( this . isChunked ) return ; setChildModify ( this . elem , bool ) ; }
function ( where , content ) { if ( this . isChunked ) throw new Error ( 'can not insert content after .append or .done' ) ; if ( insertAdjacentMethods . hasOwnProperty ( where ) === false ) { throw new Error ( 'did not understand first argument' ) ; } insertAdjacent ( this , where , content ) ; return this ; }
function ( content ) { var elem = this . elem ; if ( elem . singleton ) throw new Error ( 'can not append to singleton element' ) ; insertAdjacent ( this , 'beforeend' , content ) ; if ( ! this . isContainer ) return this ; this . _childModify ( false ) ; this . document . _send ( this ) ; return this ; }
function insertAdjacent ( node , where , content ) { var elem = node . elem ; if ( ! elem . modify ) throw new Error ( 'container can only be modified while online' ) ; var move = content . length ; if ( move === 0 ) return ; insertAdjacentMethods [ where ] ( node , elem , content , move ) ; moveParentSiblings ( elem , move ) ; }
function ( ) { var $this = $ ( this ) , $anchor = $this . children ( 'a' ) , depth = $this . parents ( 'ul' ) . length - 1 , indent = '' ; if ( depth ) { while ( depth > 0 ) { indent += '--' ; depth -- ; } } optionsList += '<option value="' + $anchor . attr ( 'href' ) + '">' + indent + ' ' + $anchor . text ( ) + '</option>' ; }
function swipeFunc ( e , dir ) { var $slider = $ ( e . currentTarget ) ; if ( dir === 'left' ) { $slider . find ( '.pagination-container .next' ) . trigger ( 'click' ) ; } if ( dir === 'right' ) { $slider . find ( '.pagination-container .prev' ) . trigger ( 'click' ) ; } }
function swipeFunc ( e , dir ) { var $slider = $ ( e . currentTarget ) ; if ( dir === 'left' ) { $slider . find ( '.pagination-container .next' ) . trigger ( 'click' ) ; } if ( dir === 'right' ) { $slider . find ( '.pagination-container .prev' ) . trigger ( 'click' ) ; } }
function swipeFunc ( e , dir ) { var $slider = $ ( e . currentTarget ) ; if ( dir === 'left' ) { $slider . find ( '.pagination-container .next' ) . trigger ( 'click' ) ; } if ( dir === 'right' ) { $slider . find ( '.pagination-container .prev' ) . trigger ( 'click' ) ; } }
function swipeFunc ( e , dir ) { var $carousel = $ ( e . currentTarget ) ; if ( dir === 'left' ) { $carousel . parent ( '.jcarousel-clip' ) . siblings ( '.jcarousel-next' ) . trigger ( 'click' ) ; } if ( dir === 'right' ) { $carousel . parent ( '.jcarousel-clip' ) . siblings ( '.jcarousel-prev' ) . trigger ( 'click' ) ; } }
function ( curr , next , opts ) { var $this = $ ( this ) ; $this . parent ( ) . stop ( ) . animate ( { height : $this . height ( ) } , opts . speed ) ; $ ( '.ss-temp-slider-styles' ) . remove ( ) ; }
function swipeFunc ( e , dir ) { var $slider = $ ( e . currentTarget ) ; $slider . data ( 'dir' , '' ) if ( dir === 'left' ) { $slider . cycle ( 'next' ) ; } if ( dir === 'right' ) { $slider . data ( 'dir' , 'prev' ) $slider . cycle ( 'prev' ) ; } }
function ( e ) { var $this = $ ( this ) ; $tabsNavLis . removeClass ( 'active' ) ; $this . addClass ( 'active' ) ; $tabContent . hide ( ) ; $ ( $this . find ( 'a' ) . attr ( 'href' ) ) . fadeIn ( ) ; e . preventDefault ( ) ; }
function ( data ) { $response . html ( data ) ; var bottomPosition = $form . offset ( ) . top + $form . outerHeight ( ) - $ ( window ) . height ( ) ; if ( $ ( document ) . scrollTop ( ) < bottomPosition ) $ ( 'html, body' ) . animate ( { scrollTop : bottomPosition } ) ; }
function ( curr , next , opts , w , h , rev ) { $ ( curr ) . css ( 'zIndex' , opts . slideCount + ( ! rev === true ? 1 : 0 ) ) ; $ ( next ) . css ( 'zIndex' , opts . slideCount + ( ! rev === true ? 0 : 1 ) ) ; }
function ( e ) { var $button = $ ( this ) , $curSlide = $slides . eq ( $button . index ( ) ) , $curContent = $contentContainer . children ( '.slide-content_' + $curSlide . index ( ) ) ; if ( settings . pause ) { $el . data ( 'autoPlayStop' , true ) ; clearInterval ( int ) ; } swithSlide ( $button , $curSlide , $curContent ) ; e . preventDefault ( ) ; }
function ( center ) { var $data = this . data ( 'gmap' ) ; if ( $data . opts . log ) { console . log ( 'delayed setMapCenter called' ) ; } if ( $data . gmap !== undefined ) { $data . gmap . setCenter ( center ) ; } else { var that = this ; window . setTimeout ( function ( ) { methods . _setMapCenter . apply ( that , [ center ] ) ; } , 500 ) ; } }
function ( ) { var animationEngine = this . options . animationEngine . toLowerCase ( ) . replace ( /[ _\-]/g , '' ) ; switch ( animationEngine ) { case 'css' : case 'none' : this . isUsingJQueryAnimation = false ; break ; case 'jquery' : this . isUsingJQueryAnimation = true ; break ; default : this . isUsingJQueryAnimation = ! Modernizr . csstransitions ; } this . _updateUsingTransforms ( ) ; }
function ( $elem , x , y ) { x += this . offset . left ; y += this . offset . top ; var position = this . getPositionStyles ( x , y ) ; this . styleQueue . push ( { $el : $elem , style : position } ) ; if ( this . options . itemPositionDataEnabled ) { $elem . data ( 'isotope-item-position' , { x : x , y : y } ) ; } }
function ( ) { if ( isCallbackTriggered ) { return ; } callback . call ( instance . element , $elems ) ; isCallbackTriggered = true ; }
function ( ) { console . log ( $newAtoms ) $newAtoms . removeClass ( 'no-transition' ) ; instance . styleQueue . push ( { $el : $newAtoms , style : instance . options . visibleStyle } ) ; instance . _isInserting = false ; instance . _processStyleQueue ( $newAtoms , callback ) ; }
function imgLoaded ( event ) { if ( -- len <= 0 && event . target . src !== blank ) { setTimeout ( triggerCallback ) ; $images . unbind ( 'load error' , imgLoaded ) ; } }
function ( ) { var instance = $ . data ( this , pluginName ) ; if ( instance ) { if ( options ) { instance . option ( options ) ; } } else { plugin ( this , options ) ; } }
function ( ) { this . $el . find ( 'input' ) . unbind ( 'keypress' ) ; var fieldValue = this . $el . find ( 'input' ) . val ( ) ; if ( fieldValue != this . model . get ( 'attr' ) . link ) { this . $el . find ( 'input, .add-on' ) . effect ( 'highlight' , { } , 2000 ) ; this . model . update ( { link : fieldValue } ) } }
function ( ) { var _this = this ; this . render ( ) ; if ( this . attr . link ) { $ ( this . el ) . click ( function ( ) { window . location = 'http://' + _this . attr . link } ) . addClass ( 'linked-layer' ) ; } this . model . trigger ( 'ready' , this . model . id ) }
function SocialUI_init ( ) { Services . obs . addObserver ( this , "social:pref-changed" , false ) ; Services . obs . addObserver ( this , "social:ambient-notification-changed" , false ) ; Services . obs . addObserver ( this , "social:profile-changed" , false ) ; Social . init ( this . _providerReady . bind ( this ) ) ; }
function SocialUI_observe ( subject , topic , data ) { switch ( topic ) { case "social:pref-changed" : SocialShareButton . updateButtonHiddenState ( ) ; SocialToolbar . updateButtonHiddenState ( ) ; break ; case "social:ambient-notification-changed" : SocialToolbar . updateButton ( ) ; break ; case "social:profile-changed" : SocialToolbar . updateProfile ( ) ; break ; } }
function ( internal ) { const since = internal . connectedSince internal . queue . splice ( 0 ) internal . socket . end ( ) internal . connected = false internal . connectedSince = null internal . socket = null this . observers . notify ( EVENT . DISCONNECT ) this . observers . clear ( ) if ( since ) logger . log ( LEVEL . INFO , "[INFO]  Connected at %s, disconnected at %s" , since , new Date ( ) ) return this }
function ( old , new_ ) { const oldKey = old . id || id ( old ) , newKey = new_ . id || id ( new_ ) this [ newKey ] = this [ oldKey ] delete this [ oldKey ] return this [ newKey ] }
function ( irc , channel , words ) { const chan = this . get ( channel ) if ( null === chan ) return null if ( chan . people . contains ( irc . user ) ) return chan . part ( words ) delete this [ chan . id ] return chan }
function ( prsn ) { const oldp = this . get ( prsn ) , newp = oldp ? null : prsn instanceof Person ? prsn : person ( prsn ) if ( oldp ) return oldp return this [ newp . id ] = newp }
function ( shared ) { const map = shared ? _observers : { } this . add = add . bind ( map ) this . notify = notify . bind ( map ) this . remove = remove . bind ( map ) this . clear = clear . bind ( map ) }
function ( type , observer ) { const key = type . toLowerCase ( ) , arr = this [ type ] || ( this [ type ] = [ ] ) arr . push ( observer ) logger . log ( LEVEL . DEBUG , "[DEBUG] Adding observer for %s" , type ) return observer }
function ( type , ix ) { const arr = this [ type ] logger . log ( LEVEL . DEBUG , "[DEBUG] Removing observer for %s" , type ) arr . splice ( ix , 1 ) if ( 0 === arr . length ) delete this [ type ] }
function ( type , observer ) { const arr = this [ type ] , ix = arr . indexOf ( observer ) if ( - 1 === ix ) return observer logger . log ( LEVEL . DEBUG , "[DEBUG] Removing observer for %s" , type ) arr . splice ( ix , 1 ) if ( 0 === arr . length ) delete this [ type ] return observer }
function ( msg ) { const user = msg . from . nick var chan for ( chan in this . channels ) if ( this . channels [ chan ] . people ) this . channels [ chan ] . people . remove ( user ) logger . log ( LEVEL . DEBUG , "[DEBUG] Got a quit message for %s, removing them from all channels" , user ) return STATUS . SUCCESS }
function ( requestMethod , query ) { var options = { host : cloudwatch_host , port : 80 , path : query , method : requestMethod , headers : { 'Host' : cloudwatch_host , 'Content-Length' : 0 } } ; return options ; }
function ( parser ) { this . fieldCount = parser . parseUnsignedNumber ( 1 ) ; this . errno = parser . parseUnsignedNumber ( 2 ) ; this . sqlStateMarker = parser . parseString ( 1 ) ; this . sqlState = parser . parseString ( 5 ) ; this . message = parser . parsePacketTerminatedString ( ) ; }
function ( data , level , isPlayer ) { this . _super ( data , level ) ; Game . engine . addCharacter ( this ) ; if ( data . isMoving ) { this . move ( data . destinationX , data . destinationY , isPlayer ) ; } this . setParameter ( ) ; }
function ( parameter , value , notifyOther ) { eval ( 'this.' + parameter + '=value' ) ; }
function ( err , files ) { var generatedPaths = ( files || [ ] ) . filter ( isExpected ) . map ( path . join . bind ( null , targetPath ) ) . map ( function ( filename ) { return filename . replace ( reExpected , '$1' ) ; } ) ; debug ( 'blitzing expected paths' , generatedPaths ) ; async . forEach ( generatedPaths , validateContents , callback ) ; }
function ( tempArray ) { var paraArray = ( tempArray instanceof Array ) ? tempArray : arguments ; var prev = paraArray [ 0 ] ; for ( var i = 1 ; i < paraArray . length ; i ++ ) { if ( paraArray [ i ] != null ) { prev = cc . Sequence . _actionOneTwo ( prev , paraArray [ i ] ) ; } } return prev ; }
function ( target ) { this . _total = 0 ; this . _nextDt = this . _innerAction . getDuration ( ) / this . _duration ; this . _super ( target ) ; this . _innerAction . startWithTarget ( target ) ; }
function ( t , sx , sy ) { var ret = false ; if ( this . _super ( t ) ) { this . _endSkewX = sx ; this . _endSkewY = sy ; ret = true ; } return ret ; }
function ( t , deltaSkewX , deltaSkewY ) { var ret = false ; if ( this . _super ( t , deltaSkewX , deltaSkewY ) ) { this . _skewX = deltaSkewX ; this . _skewY = deltaSkewY ; ret = true ; } return ret ; }
function ( target ) { this . _super ( target ) ; this . _deltaX = this . _skewX ; this . _deltaY = this . _skewY ; this . _endSkewX = this . _startSkewX + this . _deltaX ; this . _endSkewY = this . _startSkewY + this . _deltaY ; }
function ( duration , position , height , jumps ) { if ( this . _super ( duration ) ) { this . _delta = position ; this . _height = height ; this . _jumps = jumps ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; this . _delta = cc . ccp ( this . _delta . x - this . _startPosition . x , this . _delta . y - this . _startPosition . y ) ; }
function ( target ) { this . _super ( target ) ; this . _config . controlPoint_1 = cc . ccpSub ( this . _config . controlPoint_1 , this . _startPosition ) ; this . _config . controlPoint_2 = cc . ccpSub ( this . _config . controlPoint_2 , this . _startPosition ) ; this . _config . endPosition = cc . ccpSub ( this . _config . endPosition , this . _startPosition ) ; }
function ( duration , sx , sy ) { if ( this . _super ( duration ) ) { this . _endScaleX = sx ; this . _endScaleY = ( sy != null ) ? sy : sx ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; this . _startScaleX = target . getScaleX ( ) ; this . _startScaleY = target . getScaleY ( ) ; this . _deltaX = this . _endScaleX - this . _startScaleX ; this . _deltaY = this . _endScaleY - this . _startScaleY ; }
function ( target ) { this . _super ( target ) ; this . _deltaX = this . _startScaleX * this . _endScaleX - this . _startScaleX ; this . _deltaY = this . _startScaleY * this . _endScaleY - this . _startScaleY ; }
function ( duration , red , green , blue ) { if ( this . _super ( duration ) ) { this . _to = cc . ccc3 ( red , green , blue ) ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; var color = target . getColor ( ) ; this . _fromR = color . r ; this . _fromG = color . g ; this . _fromB = color . b ; }
function ( action ) { cc . Assert ( action != null , "" ) ; cc . Assert ( action != this . _other , "" ) ; if ( this . _super ( action . getDuration ( ) ) ) { this . _other = action ; return true ; } return false ; }
function ( target ) { this . _super ( target ) ; if ( this . _animation . getRestoreOriginalFrame ( ) ) { this . _origFrame = target . displayFrame ( ) ; } this . _nextFrame = 0 ; this . _executedLoops = 0 ; }
function checkField ( opts , classes , required ) { priv . ns . _reset ( ) ; var field = priv . genField ( "name" , opts , required ) ; checkGeneratedField ( field , "name" , "Name" , 0 , classes , opts , required ) ; }
function ( ) { var selection = this . listItemElement . createChild ( "div" , "selection" ) ; this . listItemElement . insertBefore ( selection , this . listItemElement . firstChild ) ; this . listItemElement . addEventListener ( "contextmenu" , this . _handleContextMenuEvent . bind ( this ) , true ) ; }
function ( event ) { if ( ! this . _entry . isDirectory ) return ; var contextMenu = new WebInspector . ContextMenu ( ) ; contextMenu . appendItem ( WebInspector . UIString ( "Refresh" ) , this . refresh . bind ( this ) ) ; contextMenu . show ( event ) ; }
function ( e ) { e . preventDefault ( ) ; if ( self . flags . river_view ) { self . mark_folder_as_read ( ) ; } else { self . mark_feed_as_read ( ) ; } }
function update_inis ( page ) { var url = "update_inis?page=" + page ; $ . ajax ( { url : "update_inis" , type : "POST" , data : { page : page } , dataType : "text" , success : function ( data ) { $ ( "#initable" ) . remove ( ) ; $ ( "#inipages" ) . remove ( ) ; $ ( "#inicontent" ) . append ( data ) ; } } ) ; return false ; }
function ( i , val ) { if ( ! $ ( this ) . hasClass ( 'sortable' ) || $this . find ( 'tbody tr' ) . not ( '.empty' ) . length <= 1 ) { options [ i ] = { sorter : false } ; } }
function ( ) { var $this = $ ( this ) , options = { } ; $this . find ( "thead th" ) . each ( function ( i , val ) { if ( ! $ ( this ) . hasClass ( 'sortable' ) || $this . find ( 'tbody tr' ) . not ( '.empty' ) . length <= 1 ) { options [ i ] = { sorter : false } ; } } ) ; $this . tablesorter ( { headers : options } ) ; }
function temporaryGenerator ( ) { var nt = nextTemporary -- nextTemporary ws . write ( '(' + syncId + ') generating temporary: ' + nt + '\n' ) ws . write ( new Error ( ) . stack + '\n' ) console . log ( '(' + syncId + ') generating temporary: ' + nt + '\n' ) console . log ( new Error ( ) . stack + '\n' ) return nt }
function sendObject ( e , ob ) { _ . assertBuffer ( ob . edits ) ws . write ( 'sending object: ' + ob . id + '\n' ) ob . destinationSyncId = e . syncId w . updateObject ( ob ) ; }
function ( id , editsBuffer ) { _ . assertLength ( arguments , 2 ) if ( editsBuffer ) { _ . assertBuffer ( editsBuffer ) objectEditBuffers . push ( { id : id , edits : editsBuffer } ) } else { console . log ( 'no edits, skipping object entirely: ' + id ) } }
f console . log ( 'adding edit via subscription for ' + infoSyncId ) console . log ( new Error ( ) . stack ) _ . assertInt ( editId ) _ . assertArray ( path ) editBuffer . add ( { order : ++ orderIndex , typeCode : subjTypeCode , id : subjId , path : path , op : op , edit : edit , syncId : syncId , editId : editId } ) advanceOnNext ( ) } )
function ( event ) { event . view = view ; event . context = context ; if ( target . isState && typeof target . send === 'function' ) { return target . send ( actionName , event ) ; } else { return target [ actionName ] . call ( target , event ) ; } }
function ( ) { this . $el . html ( _ . template ( this . template , this . model . toJSON ( ) , { variable : 'data' } ) ) ; this . $input = this . $el . find ( '.sp-input' ) ; if ( ! this . $input . is ( 'input' ) ) { throw "Skin should contain 'input' HTMLElement." ; } this . _handleDisabledChange ( ) ; }
function requireLogin ( req , res , next ) { if ( ! req . url . match ( /login/ ) && ! req . user ) { req . flash ( "info" , "please login" ) ; res . redirect ( '/login' ) ; } else { next ( ) ; } }
function ( data , cb ) { if ( this . writable ) { var out = this . _write ( 2 , data , this . id , cb ) ; console . log ( out ) ; return ! this . _paused && out ; } else { throw new Error ( 'Stream is not writable' ) ; } }
function ( ) { if ( this . options . forceReadOnly ) { console . debug ( "2" ) ; this . editionReadonly ( ) ; } else { this . dataBinder . editionMode ( "normal" ) ; this . $el . removeClass ( "edition-readonly edition-full-edit" ) ; this . $el . addClass ( "edition-normal" ) ; } }
function ( ) { if ( this . options . forceReadOnly ) { console . debug ( "2" ) ; this . editionReadonly ( ) ; } else { this . dataBinder . editionMode ( "full-edit" ) ; this . $el . removeClass ( "edition-readonly edition-normal" ) ; this . $el . addClass ( "edition-full-edit" ) ; } }
function ( type , e ) { if ( type === "click" || type === "singletap" ) { this . _tableViewSection && this . _tableViewSection . _tableView && ( this . _tableViewSection . _tableView . _tableViewRowClicked = this ) ; } View . prototype . _handleTouchEvent . apply ( this , arguments ) ; }
function ( type , e ) { if ( type === "click" || type === "singletap" ) { this . _tableView && ( this . _tableView . _tableViewSectionClicked = this ) ; } Widget . prototype . _handleTouchEvent . apply ( this , arguments ) ; }
function ( ) { if ( $ ( this ) . css ( "position" ) === "absolute" ) $ ( this ) . addClass ( "absoluteField" ) ; }
function ( ) { $ ( '.imageOptions' , this ) . show ( ) ; }
function ( resource ) { var img = ele . parents ( 'div.editor-image' ) . children ( 'img.field' ) ; ele . attr ( 'data-field-url' , resource . file ) ; img . attr ( 'data-field-url' , resource . file ) ; img . attr ( 'src' , 'images/' + resource . file ) ; hydrateSlide ( sliderio . view . toolbox . currentIndex ( ) ) ; }
function ( ) { $ ( '#uploadForm' ) . html ( "<div id='message'></div>" ) ; $ ( '#message' ) . html ( second_msg ) . append ( first_msg ) . hide ( ) . fadeIn ( 1500 , function ( ) { $ ( '#message' ) . append ( "" ) ; } ) ; }
function ( e ) { e . preventDefault ( ) ; this . vent . trigger ( 'show-docs' , { url : $ ( e . target ) . attr ( 'href' ) } ) ; }
function ( ) { $ . ajax ( { type : "POST" , url : "logic/process_action.php" , data : { action : "get_customizing_overview" } } ) . done ( function ( msg ) { $ ( '.content' ) . html ( msg ) ; $ ( 'a[id=save_customizing]' ) . hide ( ) ; } ) ; return false ; }
function ( ) { $ ( 'input[type=text]' ) . each ( function ( ) { $ ( this ) . attr ( 'readonly' , false ) ; } ) ; $ ( this ) . hide ( ) ; $ ( 'a[id=save_customizing]' ) . show ( ) ; }
function ( ) { $ . ajax ( { type : "POST" , url : "logic/process_action.php" , data : { action : "open_create_attribute_form" } } ) . done ( function ( msg ) { $ ( '.content' ) . html ( msg ) ; } ) ; return false ; }
function ( direction , value ) { if ( ! value ) { return value ; } if ( direction == Backbone . ModelBinder . Constants . ModelToView ) { return value . toString ( ) ; } else { return parseInt ( value ) ; } }
function ( direction , value ) { console . log ( value ) ; if ( ! value ) { return value ; } if ( direction == Backbone . ModelBinder . Constants . ModelToView ) { return value . getMonth ( ) + "-" + value . getDay ( ) + "-" + value . getFullYear ( ) ; } else { return new Date ( value ) ; } }
function ( response ) { var content = response ; if ( content . startDate ) { console . log ( "Parsing date: " + content . startDate ) ; content . startDate = new Date ( content . startDate ) ; console . log ( content . startDate ) ; } return content ; }
function ( ) { var bindings = Backbone . ModelBinder . createDefaultBindings ( this . el , 'name' ) ; bindings [ 'count' ] . converter = namespace . app . intConverter ; bindings [ 'startDate' ] . converter = namespace . app . dateConverter ; this . _modelBinder . bind ( this . model , this . el , bindings ) ; }
function ( ) { var view = this ; ModelBinding . bind ( this ) ; console . log ( 'Saving new: ' + JSON . stringify ( this . model ) ) ; this . model . save ( { } , { success : function ( model , response ) { namespace . app . router . navigate ( "/cultureList" , true ) ; } } ) ; }
function ( date , format ) { if ( ! date || ! format ) { console . log ( "Not enough params" ) ; } var res = date . toString ( format ) ; console . log ( "Formatted date: " + res ) ; return res ; }
function ( done ) { this . model . bind ( 'validated' , function ( valid , model , attr ) { refute ( valid ) ; assert . same ( this . model , model ) ; assert . equals ( [ 'age' ] , attr ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 } ) ; }
function ( done ) { this . model . bind ( 'validated:invalid' , function ( model , attr ) { assert . same ( this . model , model ) ; assert . equals ( [ 'age' ] , attr ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 } ) ; }
function ( done ) { this . model . bind ( 'error' , function ( model , error ) { assert . same ( this . model , model ) ; assert . equals ( [ 'age' ] , error ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 } ) ; }
function ( done ) { this . model . bind ( 'validated' , function ( valid , model , attrs ) { refute ( valid ) ; assert . same ( this . model , model ) ; assert . equals ( [ 'age' , 'name' ] , attrs ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 , name : '' } ) ; }
function ( done ) { this . model . bind ( 'validated:invalid' , function ( model , attrs ) { assert . same ( this . model , model ) ; assert . equals ( [ 'age' , 'name' ] , attrs ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 , name : '' } , this ) ; }
function ( done ) { this . model . bind ( 'error' , function ( model , error ) { assert . equals ( [ 'age' , 'name' ] , error ) ; done ( ) ; } , this ) ; this . model . set ( { age : 0 , name : '' } ) ; }
function ( ) { assert ( this . model . set ( { dependsOnName : undefined } ) ) ; this . model . set ( { name : 'name' } ) ; refute ( this . model . set ( { dependsOnName : undefined } ) ) ; }
function ( ) { if ( $ ( this ) . attr ( "src" ) == "image/playerplay.png" ) { javascript : document . demo . Play ( ) ; $ ( "#back" ) . attr ( "src" , "image/playerback.png" ) ; $ ( this ) . attr ( "src" , "image/playerplay2.png" ) ; $ ( "#pause" ) . attr ( "src" , "image/playerpause.png" ) ; $ ( "#stop" ) . attr ( "src" , "image/playerstop.png" ) ; Animation_Play ( current_index ) ; } }
function ( post ) { var isotope = this . $el . data ( 'isotope' ) _ . defer ( _ . bind ( function ( ) { isotope && this . $el . isotope ( "insert" , this . createPostView ( post ) . render ( ) . $el ) } , this ) ) }
function SafetyNet ( options ) { this . options = options != null ? options : { } ; this . pendingRequests = JSON . parse ( localStorage . getItem ( 'offline-backups' ) || '[]' ) ; window . addEventListener ( 'online' , this . submitPendingRequests ) ; }
function SafetyNet ( options ) { this . options = options != null ? options : { } ; this . pendingRequests = JSON . parse ( localStorage . getItem ( 'offline-backups' ) || '[]' ) ; window . addEventListener ( 'online' , this . submitPendingRequests ) ; }
function ( newUserAttrs ) { console . log ( "In registerUser" + util . inspect ( newUserAttrs ) ) ; var login = newUserAttrs [ this . loginKey ( ) ] ; var promise = this . Promise ( ) ; findOrCreateByPasswordData ( userData , promise ) ; console . log ( "here were the userids " + util . inspect ( usersById ) ) return usersByLogin [ login ] = addUser ( newUserAttrs ) ; }
function friendlysharedCallbackChangeShared ( e ) { if ( e . target . value === 'Shared IP edu' ) { e . target . form . contact . disabled = false ; } else { e . target . form . contact . disabled = true ; } e . target . form . organization . disabled = false ; e . target . form . host . disabled = false ; }
function ( data , enc ) { orig_end . call ( res , data , enc ) ; if ( ++ ( worker . requests ) >= max_requests ) { log . info ( "Worker PID " + worker . pid + " reached max requests" ) ; worker . kill ( ) ; } }
function ( repo , payload ) { return console . log ( 'received push from:' , repo ) ; }
function testProps ( props , prefixed ) { for ( var i in props ) { var prop = props [ i ] ; if ( prop . indexOf ( "-" ) == - 1 && mStyle [ prop ] !== undefined ) { return prefixed == 'pfx' ? prop : true ; } } return false ; }
function ( key ) { var item = declaration [ key ] ; var resource_path = path . join ( directory , key ) ; if ( item . constructor === Object ) { level ( resource_path , item , routes ) ; } else { resource_path = resource_path . replace ( /\/$/ , '' ) || '/' ; routes . push ( [ resource_path , item ] ) ; } }
function ( ) { var me = eXo . wiki . UIConfirmBox ; var confirmbox = me . confirmBox ; if ( confirmbox && ( confirmbox . style . display == "block" ) ) { try { eXo . core . UIMaskLayer . blockContainer = document . getElementById ( "UIPortalApplication" ) ; eXo . core . UIMaskLayer . object = confirmbox ; eXo . core . UIMaskLayer . setPosition ( ) ; } catch ( e ) { } } }
function ( ) { BF . include ( "/js/secondary.js?16655546" , { content_manager : content_manager , langEl : langEl , page : page , qEl : qEl , settings : settings , system : system , run_new_query : run_new_query , topBar : topBar , viewPort_num : viewPort_num } ) ; }
function show_context_menu ( pos , menu_items , selected , open_callback , close_callback ) { if ( is_open ) { close_menu ( function ( ) { if ( typeof close_callback === "function" ) { close_callback ( ) ; } open_menu ( pos , menu_items , selected , open_callback , close_callback ) ; } ) ; } else { open_menu ( pos , menu_items , selected , open_callback , close_callback ) ; } return close_menu ; }
function ( ) { var i ; ajax . abort ( ) ; for ( i = destory_funcs . length - 1 ; i >= 0 ; i -= 1 ) { destory_funcs [ i ] ( ) ; } document . body . removeChild ( callout ) ; }
function ( ) { app . use ( express . compress ( ) ) ; app . use ( express . bodyParser ( ) ) ; app . set ( 'views' , __dirname + '/views' ) ; app . register ( '.html' , ejs ) ; app . set ( 'view engine' , 'ejs' ) ; app . use ( express . methodOverride ( ) ) ; app . use ( express . favicon ( __dirname + '/public/favicon.ico' , { maxAge : 31557600000 } ) ) ; app . use ( app . router ) ; }
function checkIdentifier ( identifier , name ) { if ( typeof ( identifier ) !== 'string' ) throw "expected " + name + " to be a string" ; if ( identifier . length > MAX_IDENTIFIER_LENGTH ) throw name + " is too long" ; if ( ! IDENTIFIER_VALIDATOR . test ( identifier ) ) throw "invalid " + name ; }
function ( sourceBox , viewRange ) { try { this . updateViewportCache ( sourceBox , viewRange ) ; } catch ( exc ) { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "buildViewAround updateViewportCache FAILS " + exc , exc ) ; } Dom . collapse ( sourceBox , false ) ; this . setViewportPadding ( sourceBox , viewRange ) ; sourceBox . centralLine = Math . floor ( ( viewRange . lastLine + viewRange . firstLine ) / 2 ) ; this . applyDecorator ( sourceBox ) ; return ; }
function ( ) { should . exist ( require ( 'assert' ) . AssertionError ) ; should . exist ( require ( 'events' ) . EventEmitter ) ; should . exist ( require ( 'http' ) . STATUS_CODES ) ; should . exist ( require ( 'path' ) . dirname ) ; should . exist ( require ( 'tty' ) . isatty ) ; should . exist ( require ( 'util' ) . inspect ) ; }
function cursorX ( elem , evt ) { if ( isFixed ( elem ) ) { var bodyLeft = parseInt ( document . defaultView . getComputedStyle ( document . body , "" ) . marginLeft , 10 ) - calc ( elem , 'scrollLeft' ) + window . pageXOffset + elem . style . marginLeft ; return evt . clientX - bodyLeft ; } if ( evt . pageX ) return evt . pageX ; else if ( evt . clientX ) return evt . clientX + document . body . scrollLeft ; }
function cursorY ( elem , evt ) { if ( isFixed ( elem ) ) { var bodyTop = parseInt ( document . defaultView . getComputedStyle ( document . body , "" ) . marginTop , 10 ) - calc ( elem , 'scrollTop' ) + window . pageYOffset + elem . style . marginTop ; return evt . clientY - bodyTop ; } if ( evt . pageY ) return evt . pageY ; else if ( evt . clientY ) return evt . clientY + document . body . scrollTop ; }
function cursorX ( elem , evt ) { if ( isFixed ( elem ) ) { var bodyLeft = parseInt ( document . defaultView . getComputedStyle ( document . body , "" ) . marginLeft , 10 ) - calc ( elem , 'scrollLeft' ) + window . pageXOffset + elem . style . marginLeft ; return evt . clientX - bodyLeft ; } if ( evt . pageX ) return evt . pageX ; else if ( evt . clientX ) return evt . clientX + document . body . scrollLeft ; }
function cursorY ( elem , evt ) { if ( isFixed ( elem ) ) { var bodyTop = parseInt ( document . defaultView . getComputedStyle ( document . body , "" ) . marginTop , 10 ) - calc ( elem , 'scrollTop' ) + window . pageYOffset + elem . style . marginTop ; return evt . clientY - bodyTop ; } if ( evt . pageY ) return evt . pageY ; else if ( evt . clientY ) return evt . clientY + document . body . scrollTop ; }
function ( data ) { comparison_grid . set_columns ( env_select . get_paths ( ) ) ; select_envs ( get_initial_environments ( ) ) ; comparison_grid . set_title ( data . name ) ; comparison_grid . set_mode ( "results" ) ; draw_grid ( data . rows ) ; cache . save_state ( comparison_grid , search_params ) ; }
function ( ) { var selected = path_selector . find ( 'input:checked' ) , to_ret = { } ; KT . utils . each ( selected , function ( item ) { item = $ ( item ) ; to_ret [ item . data ( 'node_id' ) ] = { 'id' : item . data ( 'node_id' ) , name : item . data ( 'node_name' ) , next_id : item . data ( 'next_node_id' ) } ; } ) ; return to_ret ; }
function ( datePicker , date ) { var dfd = $ . Deferred ( ) ; date = _ . isString ( date ) ? moment ( date ) : date ; datePicker . $node . find ( 'td:contains(' + date . date ( ) + ')' ) . trigger ( 'click' ) . end ( ) . find ( 'input[type=text]' ) . trigger ( 'blur' ) ; setTimeout ( function ( ) { dfd . resolve ( ) ; } , 0 ) ; return dfd ; }
function build ( title ) { layerRoot . html ( '<textarea style="width: 100%; height: 100%;"></textarea>' ) ; var textarea = layerRoot . find ( 'textarea' ) ; textarea . bind ( 'blur' , function ( e ) { var value = val ( ) ; mod . onsubmit && mod . onsubmit ( value ) ; } ) ; update ( data . get ( status . page ) . getItem ( status . name ) . getProp ( status . prop ) ) ; textarea . focus ( ) ; }
function ( req , callback ) { var username = req . headers . host . split ( '.' ) [ 0 ] var redisKey = _ . template ( this . user_key , { username : username } ) ; this . retrieve ( this . user_metadata_db , redisKey , 'database_name' , callback ) ; }
function ( req , callback ) { var username = req . headers . host . split ( '.' ) [ 0 ] ; var redisKey = _ . template ( this . user_key , { username : username } ) ; this . retrieve ( this . user_metadata_db , redisKey , 'id' , callback ) ; }
function ( ) { this . ninjaVersion = window . ninjaVersion . ninja . version ; this . undoManager = document . application . undoManager = UndoManager . create ( ) ; document . application . njUtils = NjUtils ; }
function ( err ) { remaining -- ; if ( ! remaining ) { client . hget ( 'q:job:' + self . id , 'after' , function ( err , val ) { if ( err ) return cb ( err ) ; self . _after = val ; cb ( err , self ) ; } ) ; } }
function ( err , state ) { if ( err ) return cb ( err ) ; if ( ! state || ( state == 'complete' ) ) { client . srem ( 'q:after:' + id , function ( err , cnt ) { if ( err || ! cnt ) return cb ( err ) ; client . hincrby ( 'q:job:' + self . id , 'after' , - 1 , cb ( err ) ) ; } ) ; } }
function ( err , job ) { if ( err || ! job ) { client . del ( 'q:lockowners:' + self . _group , function ( err ) { if ( err ) return ; self . acquire ( ) ; } ) ; return ; } client . zrem ( 'q:staged:' + job . _group , job . id , noop ) ; job . inactive ( ) ; }
function setFont ( font ) { selectedFont = font ; currentSelectedFont = font ; $ ( editedobject ) . attr ( "data-font-face" , currentSelectedFont ) $ ( "#fontdropdown" ) . html ( currentSelectedFont + '<b class="caret">' ) ; if ( editedobject != "" ) { $ ( editedobject ) . css ( "font-family" , selectedFont ) ; } }
function ( name ) { name = ( name && name . toLowerCase ( ) ) || 'default' ; this . doctype = doctypes [ name ] || '<!DOCTYPE ' + name + '>' ; this . terse = 'default' == name || '5' == name || 'html' == name ; this . xml = 0 == this . doctype . indexOf ( '<?xml' ) ; }
function ( req , res ) { if ( req . url === "/" ) { res . end ( '<script type="text/javascript" src="/ui.js"></script>' ) ; } else if ( /^\/ui(\.js$|\/)/ . test ( req . url ) ) { req . params = [ req . url . match ( /^\/ui(?:\.js)?(\/.*)?$/ ) [ 1 ] ] ; require ( "sourcemint-platform-nodejs/lib/bundler" ) . hoist ( __dirname + "/ui" , { bundleLoader : true } ) ( req , res ) ; } }
function ( err , paths ) { if ( paths . length == 0 ) { cb ( err , [ path ] ) ; } else { cb ( err , paths ) ; } }
function ( id ) { if ( this . bodiesMap [ id ] ) { this . bodiesMap [ id ] . DestroyFixture ( this . fixturesMap [ id ] ) ; this . world . DestroyBody ( this . bodiesMap [ id ] ) ; delete this . fixturesMap [ id ] ; delete this . bodiesMap [ id ] ; } }
function ( ) { if ( button . selector == lastClickedButton ) { menu . css ( 'visibility' , 'hidden' ) ; menuItems . css ( 'visibility' , 'hidden' ) ; } else { menu . css ( 'visibility' , 'visible' ) ; menuItems . css ( 'visibility' , 'hidden' ) ; pickerMenu . css ( 'visibility' , 'visible' ) ; } lastClickedButton = button . selector ; }
function ( event ) { var p = popcornInstances [ event . data . popcornID ] , options = p . getTrackEvent ( event . data . optionsID ) ; handleWav ( options , event . data . data ) ; }
function ( ) { var state = ( sr . code >= 1 ) ? 'alert' : 'error' ; $option . trigger ( 'iceEasyOptionsPost' , [ state , opt_name , opt_reset ] ) ; $ ( this ) . iceEasyFlash ( state , sr . message ) . fadeIn ( ) ; }
function ( field ) { if ( field === null ) { field = '' ; } else if ( typeof field === "string" ) { field = delimiter + field + delimiter ; } else if ( typeof field === "number" ) { field = field . toString ( 10 ) ; } return field ; }
function ( ) { var csv = [ [ 'Jones, Jay' , 10 ] , [ 'Xyz "ABC" O\'Brien' , '11:35' ] , [ 'Other, AN' , '12:35' ] ] ; var array = recline . Backend . CSV . serializeCSV ( csv ) ; var exp = '"Jones, Jay",10\n' + '"Xyz ""ABC"" O\'Brien",11:35\n' + '"Other, AN",12:35\n' ; deepEqual ( array , exp ) ; }
function processAsset ( asset , callback ) { var manifestEntry = asset . getServerManifestEntry ( ) , clientManifestEntry = asset . getClientManifestEntry ( ) ; manifest [ manifestEntry . requested ] = manifestEntry ; clientManifest [ asset . type ] [ clientManifestEntry . name ] = clientManifestEntry . path ; asset . writeContents ( builtAssets , callback ) ; }
function setContent ( newContent , type ) { this . content = this . contentRaw = newContent ; if ( compressJS && type === 'js' ) { this . contentRaw = this . content . toString ( 'utf8' ) ; this . content = utils . compressJS ( this . content . toString ( 'utf8' ) ) ; } }
function ( ) { var s = "This is my string" ; var hash = this . utils . generateHash ( s ) ; assert . typeOf ( hash , "string" ) ; assert . equals ( "c2a9ce57e8df081b4baad80d81868bbb" , hash ) ; s = s + " " ; var hash2 = this . utils . generateHash ( s ) ; refute . equals ( hash , hash2 ) ; }
function error_to_get_data ( jqXHR , textStatus , errorThrown ) { $ ( '#border' ) . css ( 'border-color' , 'red' ) . css ( 'background' , '#FFAAAA' ) ; if ( $ ( "#ajaxerror" ) . length == 0 ) { $ ( '#border' ) . after ( "<p id='ajaxerror'>Conection lost" ) ; } }
function ( ) { var layer1 = cc . LayerGradient . create ( cc . ccc4 ( 255 , 0 , 0 , 255 ) , cc . ccc4 ( 0 , 255 , 0 , 255 ) , cc . ccp ( 0.9 , 0.9 ) ) ; this . addChild ( layer1 , 0 , cc . TAG_LAYER ) ; this . setIsTouchEnabled ( true ) ; }
function ( ) { this . _super ( ) ; this . setIsTouchEnabled ( true ) ; var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; this . addNewSpriteWithCoords ( cc . ccp ( s . width / 2 , s . height / 2 ) ) ; }
function ( ) { this . setIsTouchEnabled ( true ) ; var BatchNode = cc . SpriteBatchNode . create ( s_grossini_dance_atlas , 50 ) ; this . addChild ( BatchNode , 0 , TAG_SPRITE_BATCH_NODE ) ; var s = cc . Director . sharedDirector ( ) . getWinSize ( ) ; this . addNewSpriteWithCoords ( cc . ccp ( s . width / 2 , s . height / 2 ) ) ; }
function ( ) { this . setIsTouchEnabled ( true ) ; var node = cc . Node . create ( ) ; this . addChild ( node , 0 , TAG_SPRITE_BATCH_NODE ) ; this . _texture1 = cc . TextureCache . sharedTextureCache ( ) . addImage ( s_grossini_dance_atlas ) ; this . _texture2 = cc . TextureCache . sharedTextureCache ( ) . addImage ( s_grossini_dance_atlas_mono ) ; this . _usingTexture1 = true ; for ( var i = 0 ; i < 30 ; i ++ ) { this . addNewSprite ( ) ; } }
function ( ) { this . setIsTouchEnabled ( true ) ; var batch = cc . SpriteBatchNode . create ( s_grossini_dance_atlas , 50 ) ; this . addChild ( batch , 0 , TAG_SPRITE_BATCH_NODE ) ; this . _texture1 = batch . getTexture ( ) ; this . _texture2 = cc . TextureCache . sharedTextureCache ( ) . addImage ( s_grossini_dance_atlas_mono ) ; for ( var i = 0 ; i < 30 ; i ++ ) { this . addNewSprite ( ) ; } }
function ( enabled ) { if ( this . _isTouchEnabled != enabled ) { this . _isTouchEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { this . registerWithTouchDispatcher ( ) ; } else { cc . TouchDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } } } }
function ( enabled ) { if ( enabled != this . _isAccelerometerEnabled ) { this . _isAccelerometerEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( this ) ; } else { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( null ) ; } } } }
function ( enabled ) { if ( enabled != this . _isKeypadEnabled ) { this . _isKeypadEnabled = enabled ; if ( this . _isRunning ) { if ( enabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . addDelegate ( this ) ; } else { cc . KeypadDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } } } }
function ( ) { if ( this . _isTouchEnabled ) { this . registerWithTouchDispatcher ( ) ; } this . _super ( ) ; if ( this . _isAccelerometerEnabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( this ) ; } if ( this . _isKeypadEnabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . addDelegate ( this ) ; } }
function ( ) { if ( this . _isTouchEnabled ) { cc . TouchDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } if ( this . _isAccelerometerEnabled ) { cc . Accelerometer . sharedAccelerometer ( ) . setDelegate ( null ) ; } if ( this . _isKeypadEnabled ) { cc . KeypadDispatcher . sharedDispatcher ( ) . removeDelegate ( this ) ; } this . _super ( ) ; }
function ( size ) { this . _squareVertices [ 1 ] . x = size . width * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 2 ] . y = size . height * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 3 ] . x = size . width * cc . CONTENT_SCALE_FACTOR ( ) ; this . _squareVertices [ 3 ] . y = size . height * cc . CONTENT_SCALE_FACTOR ( ) ; this . _super ( size ) ; }
function ( ) { var container = $ ( this ) . closest ( '.cat_discipline_addresses' ) ; var sector_id = parseInt ( $ ( this ) . attr ( 'data-sector-id' ) ) ; var discipline_id = parseInt ( $ ( this ) . attr ( 'data-discipline-id' ) ) ; container . empty ( ) ; $ ( '<p><a class="catalog_show_addresses" data-sector-id="' + sector_id + '" data-discipline-id="' + discipline_id + '" href="/catalog/' + sector_id + '">Показать интернет-адреса</a></p>' ) . appendTo ( container ) ; return false ; }
function ( ) { ! $ ( this ) . hasClassName ( name ) && ( this . className += ' ' + name ) ; }
function ( images , callback ) { if ( typeof ( images ) === "string" ) { images = [ images ] ; } var i , data = { callback : callback , numLoaded : 0 , numImages : images . length , images : [ ] } for ( i = 0 ; i < images . length ; i += 1 ) { Loader . load ( images [ i ] , data ) ; } }
function ( images , callback ) { if ( typeof ( images ) === "string" ) { images = [ images ] ; } var i , data = { callback : callback , numLoaded : 0 , numImages : images . length , images : [ ] } for ( i = 0 ; i < images . length ; i += 1 ) { Loader . load ( images [ i ] , data ) ; } }
function ( images , callback ) { if ( typeof ( images ) === "string" ) { images = [ images ] ; } var i , data = { callback : callback , numLoaded : 0 , numImages : images . length , images : [ ] } for ( i = 0 ; i < images . length ; i += 1 ) { Loader . load ( images [ i ] , data ) ; } }
function ( ) { if ( statusCode === 503 ) { console . log ( 'GCM service is unavailable' ) ; return callback ( statusCode , null ) ; } else if ( statusCode !== 200 ) { console . log ( 'Invalid request: ' + statusCode ) ; return callback ( statusCode , null ) ; } var data = JSON . parse ( buf ) ; callback ( null , data ) ; }
function ( tabs , properties , before ) { for ( var i = 0 ; i < tabs . length ; i ++ ) tabs [ i ] . ungroup ( true ) ; return this . _create ( tabs , properties , before ) ; }
function ( vec ) { var x = vec [ 0 ] , y = vec [ 1 ] , z = vec [ 2 ] , w = vec [ 3 ] ; return sqrt ( x * x + y * y + z * z + w * w ) ; }
function ( ) { this . _scroller . removeEvent ( 'scroll' , this . bound ( '_onScroll' ) ) ; this . _scroller . destroy ( ) ; this . _scroller = null ; this . parent ( ) ; }
function ( ) { window . removeEvent ( 'orientationchange' , this . bound ( '_onOrientationChange' ) ) ; this . iscroll . destroy ( ) ; this . iscroll = null ; return this . parent ( ) ; }
function ( ) { this . innerWrapperElement . removeEvent ( 'scroll' , this . bound ( '_onScroll' ) ) ; this . innerWrapperElement = null ; this . outerWrapperElement = null ; this . scroller = null ; window . addEvent ( 'orientationchange' , this . bound ( '_onOrientationChange' ) ) ; this . parent ( ) ; }
function ( x , y , time ) { var onEnd = function ( ) { this . fireEvent ( 'scroll' ) ; this . _attachScrollListener ( ) ; } . bind ( this ) ; this . _detachScrollListener ( ) ; this . scroller . setOptions ( { duration : time || 0 } ) ; this . scroller . start ( x , y ) ; this . scroller . addEvent ( 'cancel:once' , onEnd ) ; this . scroller . addEvent ( 'complete:once' , onEnd ) ; return this ; }
function ( element , time ) { var onEnd = function ( ) { this . fireEvent ( 'scroll' ) ; this . _attachScrollListener ( ) ; } . bind ( this ) ; this . _detachScrollListener ( ) ; this . scroller . setOptions ( { duration : time || 0 } ) ; this . scroller . toElement ( element ) ; this . scroller . addEvent ( 'cancel:once' , onEnd ) ; this . scroller . addEvent ( 'complete:once' , onEnd ) ; return this ; }
function ( ) { var wrapperSize = this . getSize ( ) ; var contentSize = this . getScrollSize ( ) ; if ( this . options . momentum ) { if ( this . options . scrollY && contentSize . y <= wrapperSize . y ) this . contentElement . setStyle ( 'min-height' , wrapperSize . y + 1 ) ; if ( this . options . scrollX && contentSize . x <= contentSize . x ) this . contentElement . setStyle ( 'min-width' , wrapperSize . x + 1 ) ; } return this ; }
function ( ) { this . _scroller . removeEvent ( 'scroll' , this . bound ( '_onScroll' ) ) ; this . _scroller . destroy ( ) ; this . _scroller = null ; this . parent ( ) ; }
function copyChildrens ( to , from ) { var push = to . childrens = [ ] ; var i = from . childrens . length ; while ( i -- ) { push . push ( copyElem ( from . childrens [ i ] , to ) ) ; } }
function ( e , ui ) { var choice = _this . choices [ ui . value ] ; _this . $select . val ( choice . value ) ; if ( _this . options . tooltips ) { _this . _refreshTooltip ( choice , ui . value ) ; } }
function ( req , res ) { console . log ( "hi" ) ; var usergeneric = req . params . usergeneric , corpusordatalist = req . params . corpusordatalist ; var corpusid = "" ; var datalistid = "" ; res . redirect ( "https://localhost:3001\#corpus/" + req . params . corpusid ) ; }
function walkBoxes ( boxLevel , pathSoFar ) { for ( var boxName in boxLevel ) { var box = boxLevel [ boxName ] , boxPath = pathSoFar ? ( pathSoFar + boxName ) : boxName , type = self . _determineFolderType ( box , boxPath ) ; folderMeta = self . _learnAboutFolder ( boxName , boxPath , type , box . delim ) ; } }
function MailFolder ( api , wireRep ) { this . _api = api ; this . id = wireRep . id ; this . name = wireRep . name ; this . path = wireRep . path ; this . type = wireRep . type ; this . selectable = ( wireRep . type !== 'account' ) && ( wireRep . type !== 'nomail' ) ; this . onchange = null ; this . onremove = null ; this . element = null ; this . data = null ; }
function ( ) { var index = 5 , synMessage = msearchView . testFolder . messages [ index ] ; eSync . expect_namedValue ( 'bodyInfo' , { to : synMessage . bodyInfo . to , bodyText : synMessage . bodyInfo . bodyText , } ) ; var header = msearchView . slice . items [ index ] ; header . getBody ( function ( bodyInfo ) { eSync . namedValue ( 'bodyInfo' , bodyInfo && { to : bodyInfo . to , bodyText : bodyInfo . bodyRep [ 1 ] , } ) ; } ) ; }
function ( str ) { if ( ! str . length ) { return [ ] ; } return str . split ( '\n' ) ; }
function ( str ) { if ( ! str . length ) { return [ ] ; } return str . split ( '\n' ) ; }
function ( ) { var data = $ ( this ) . getTemplateData ( { textValues : [ 'assignment_group_id' ] } ) ; if ( $ ( this ) [ 0 ] != $drag [ 0 ] ) { groups . push ( data . assignment_group_id ) ; } }
function ( ) { $ ( '.facet-choice input[type=checkbox]:checked' , $ ( this . el ) ) . each ( function ( i , e ) { $ ( e ) . prop ( 'checked' , false ) ; choice_id = $ ( e ) . data ( 'choice_id' ) ; facet_choice_el = $ ( '#facet-choice--' + choice_id ) ; facet_choice_el . removeClass ( 'selected' ) ; } ) ; this . selected_choices = { } ; this . updateSelection ( ) ; }
function ( dt ) { if ( this . _firstTick ) { this . _firstTick = false ; this . _elapsed = 0 ; } else { this . _elapsed += dt ; } this . update ( ( 1 > ( this . _elapsed / this . _duration ) ) ? this . _elapsed / this . _duration : 1 ) ; }
function ( action , times ) { var d = action . getDuration ( ) * times ; if ( this . initWithDuration ( d ) ) { this . _times = times ; this . _innerAction = action ; this . _total = 0 ; return true ; } return false ; }
function ( dt ) { this . _innerAction . step ( dt ) ; if ( this . _innerAction . isDone ( ) ) { var diff = dt + this . _innerAction . getDuration ( ) - this . _innerAction . getElapsed ( ) ; this . _innerAction . startWithTarget ( this . _target ) ; this . _innerAction . step ( diff ) ; } }
function ( texture , rect , rotated , offset , originalSize ) { var spriteFrame = new cc . SpriteFrame ( ) ; spriteFrame . _texture = texture ; spriteFrame . _rectInPixels = rect ; spriteFrame . _rect = cc . RECT_PIXELS_TO_POINTS ( rect ) ; spriteFrame . _rotated = rotated ; spriteFrame . _offsetInPixels = offset ; spriteFrame . _originalSizeInPixels = originalSize ; return spriteFrame ; }
function ( ) { if ( this . _stop ) return ; this . _stop = true ; Tweener . addTween ( this . _spinner . actor , { opacity : 0 , time : SPINNER_ANIMATION_TIME , transition : "easeOutQuad" , onCompleteScope : this , onComplete : function ( ) { this . _spinner . actor . opacity = 255 ; this . _spinner . actor . hide ( ) ; } } ) ; }
function ( ) { var xhr = io . util . request ( ) , uri = this . resource + '/' + io . protocol + '/' + this . sessionid ; xhr . open ( 'GET' , uri , true ) ; this . onDisconnect ( 'booted' ) ; }
function ( ) { if ( typeof window != "undefined" && 'ActiveXObject' in window ) { try { var a = new ActiveXObject ( 'htmlfile' ) ; return a && io . Transport . XHR . check ( ) ; } catch ( e ) { } } return false ; }
function ( oDraggable ) { oDraggable . options . change = ChangeOrder ; oDraggable . options . onEnd = UpdateOrder ; }
function ( ) { var arrTabs = $$ ( '#oTabcontainer .tab' ) ; arrTabs . each ( function ( oTab ) { oTab . observe ( 'click' , function ( ) { showInstructionalMaterial ( oTab ) ; } ) ; } ) ; var strTabID = arrTabs [ 0 ] . id ; setSelectedTab ( strTabID ) ; }
function ( ) { if ( ! this . disposed_ ) { this . disposed_ = true ; this . disposeInternal ( ) ; if ( goog . Disposable . ENABLE_MONITORING ) { var uid = goog . getUid ( this ) ; if ( ! goog . Disposable . instances_ . hasOwnProperty ( uid ) ) { throw Error ( this + ' did not call the goog.Disposable base ' + 'constructor or was disposed of after a clearUndisposedObjects ' + 'call' ) ; } delete goog . Disposable . instances_ [ uid ] ; } } }
function ( e ) { if ( e . keyCode == 122 ) { e . preventDefault ( ) ; if ( RunPrefixMethod ( document , "FullScreen" ) || RunPrefixMethod ( document , "IsFullScreen" ) ) { RunPrefixMethod ( document , "CancelFullScreen" ) ; } else { RunPrefixMethod ( el , "RequestFullScreen" , Element . ALLOW_KEYBOARD_INPUT ) ; } } }
function ( ) { app . use ( express . static ( __dirname , { maxAge : 60000 } ) ) ; app . use ( browserify ( { require : [ 'events' , 'util' , './color' , './explosion' , './snake' , './vector' , './ball' , './entity' , './world' ] } ) ) ; app . set ( 'view options' , { layout : false } ) ; app . set ( 'view engine' , 'ejs' ) ; app . use ( express . errorHandler ( ) ) ; }
function ( ) { $ ( '#tabt' ) . jqGrid ( 'setGridHeight' , $ ( window ) . height ( ) / 2 - 30 ) ; $ ( '#map' ) . height ( $ ( window ) . height ( ) - $ ( '#tab' ) . height ( ) - 3 ) ; hell . map . invalidateSize ( ) ; $ ( '#tabt' ) . jqGrid ( 'setGridWidth' , $ ( window ) . width ( ) ) ; }
function ( ) { if ( debug ) console . log ( 'onload' ) ; if ( palette ) palette . remove ( ) ; main . append ( '<table><tr><td id="files"></td><td id="folders"></td><td id="images"></td></tr></table>' ) ; folders = $ ( '#folders' ) ; files = $ ( '#files' ) ; images = $ ( '#images' ) ; _Files . refreshFolders ( ) ; _Files . refreshFiles ( ) ; _Files . refreshImages ( ) ; }
function ( ) { var self = $ ( this ) ; if ( self . hasClass ( 'page' ) ) return getId ( self ) ; return self . prevAll ( '.node' ) . length ; }
function removeExpandedNode ( treeAddress ) { console . log ( 'removeExpandedNode' , treeAddress ) ; if ( ! treeAddress ) return ; delete getExpanded ( ) [ treeAddress ] ; $ . cookie ( 'structrTreeExpandedIds' , $ . toJSON ( Structr . expanded ) , { expires : 7 , path : '/' } ) ; }
function isExpanded ( treeAddress ) { if ( debug ) console . log ( 'isExpanded' , treeAddress ) ; if ( ! treeAddress ) return false ; var isExpanded = getExpanded ( ) [ treeAddress ] == true ? true : false ; if ( debug ) console . log ( isExpanded ) ; return isExpanded ; }
function ( event , ui ) { var userId = getId ( ui . draggable ) ; var groupId = getId ( $ ( this ) ) ; var nodeData = { } ; nodeData . id = userId ; Command . createAndAdd ( groupId , nodeData ) ; }
function ( i , entity ) { if ( debug ) console . log ( 'LIST: ' + entity . type ) ; if ( entity . type != 'Folder' || ! entity . parentFolder ) { _Entities . appendObj ( entity , null , null , null , false , isIn ( entity . id , data . nodesWithChildren ) ) ; } }
function ( ) { node = robot . _resolveNode ( node ) ; robot . _scrollIntoView ( node ) ; var pos = robot . _position ( node ) ; if ( offsetY === undefined ) { offsetX = pos . w / 2 ; offsetY = pos . h / 2 ; } var x = pos . x + offsetX ; var y = pos . y + offsetY ; robot . _mouseMove ( x , y , false , duration ) ; }
function ( roomId , userId , date , message , userFriendlyRoomName ) { this . userFriendlyRoomName = userFriendlyRoomName ; this . roomId = roomId ; this . userId = userId ; this . date = date ; this . message = message ; this . swarm ( "recordMsg" ) ; }
function defaultLogin ( sock , clientName , pass ) { var cmd = { sessionId : clientName , swarmingName : "login.js" , command : "start" , commandArguments : [ clientName , clientName , pass ] } ; util . writeObject ( sock , cmd ) ; }
function ( dt ) { var sprite1 = this . getChildByTag ( TAG_SPRITE1 ) ; var sprite2 = this . getChildByTag ( TAG_SPRITE2 ) ; cc . Log ( "Pre: " + sprite1 . getContentSize ( ) . height ) ; sprite1 . setFlipX ( ! sprite1 . isFlipX ( ) ) ; sprite2 . setFlipY ( ! sprite2 . isFlipY ( ) ) ; cc . Log ( "Post: " + sprite1 . getContentSize ( ) . height ) ; }
function ( dt ) { var batch = this . getChildByTag ( TAG_SPRITE_BATCH_NODE ) ; var sprite1 = batch . getChildByTag ( TAG_SPRITE1 ) ; var sprite2 = batch . getChildByTag ( TAG_SPRITE2 ) ; cc . Log ( "Pre: " + sprite1 . getContentSize ( ) . height ) ; sprite1 . setFlipX ( ! sprite1 . isFlipX ( ) ) ; sprite2 . setFlipY ( ! sprite2 . isFlipY ( ) ) ; cc . Log ( "Post: " + sprite1 . getContentSize ( ) . height ) ; }
function ( ) { _ . bindAll ( this , "open" , "hide" ) ; _ . defaults ( this . options , this . default_options ) ; this . template_base = cdb . templates . getTemplate ( this . options . template_base ) ; $ ( this . options . target ) . bind ( { "click" : this . open } ) }
function ( ) { var self = this ; this . $el . animate ( { margin : "-15px 0 0 0" , opacity : 0 } , this . options . speedOut , function ( ) { $ ( self . options . target ) . removeClass ( "selected" ) ; self . $el . hide ( ) ; } ) ; }
function ( appID , eventCallback , successCallback , failureCallback ) { if ( typeof eventCallback != "string" ) { var e = new Array ( ) ; e . msg = 'eventCallback must be a STRING name of the routine' ; e . rc = - 1 ; failureCallback ( e ) ; return ; } return Cordova . exec ( successCallback , failureCallback , 'GCMPlugin' , 'register' , [ { email : senderEmail , ecb : eventCallback } ] ) ; }
function ( ) { var $li = jQuery ( this ) ; $li . contents ( ) . each ( function ( ) { if ( this . nodeType === 3 ) { this . data = jQuery . trim ( this . data ) ; } } ) ; }
function ( ) { var search = this . grid . find ( 'input.aloha-browser-search-field' ) , searchValue = search . val ( ) ; if ( jQuery ( search ) . css ( "font-style" ) == "italic" ) { searchValue = "" ; } this . _pagingOffset = 0 ; this . _searchQuery = search . val ( ) ; this . fetchItems ( this . _currentFolder , this . processItems ) ; }
function ( done ) { fbagent . get ( '/jakeluer' ) . end ( function ( err , res ) { should . not . exist ( err ) ; res . should . have . property ( 'username' , 'jakeluer' ) ; done ( ) ; } ) ; }
function renderDeliciousLinks ( items ) { var output = "<ul>" ; for ( var i = 0 , l = items . length ; i < l ; i ++ ) { output += '<li><a href="' + items [ i ] . u + '" title="Tags: ' + items [ i ] . t . join ( ', ' ) + '">' + items [ i ] . d + '</a></li>' ; } output += "</ul>" ; $ ( '#delicious' ) . html ( output ) ; }
function ( onReady ) { function onModuleReady ( ) { readyModules ++ ; if ( readyModules === modules . length ) { onReady ( ) ; } } for ( var i = 0 ; i < modules . length ; ++ i ) { if ( modules [ i ] . _start ) { modules [ i ] . _start ( onModuleReady ) ; } else { readyModules ++ ; } } }
function ( hash ) { hash || ( hash = HistoryHash . getHash ( ) ) ; if ( hash && hash . charAt ( 0 ) === '/' ) { return ( this . get ( 'root' ) ? this . _resolvePath ( hash . substring ( 1 ) ) : hash ) ; } return '' ; }
function noConflict ( ns ) { if ( typeof ns != "string" || ! ns ) { throw new Error ( 'namespace must be a non-empty string' ) ; } _trace ( "Settings namespace to '" + ns + "'" ) ; window . easyXDM = _easyXDM ; namespace = ns ; if ( namespace ) { IFRAME_PREFIX = "easyXDM_" + namespace . replace ( "." , "_" ) + "_" ; } return easyXDM ; }
function ( ) { if ( ! FOUND ) { var source_document_id = $ ( this ) . attr ( "id" ) . substring ( 9 ) ; if ( source_document_id . length > 0 ) { if ( $ ( "#player_" + source_document_id ) . size ( ) ) { FOUND = true ; current_document = source_document_id ; setTimeout ( "_play(" + position + ")" , 1000 ) ; } } } }
function pause ( ) { if ( current_document != false ) { var audio_elt = $ ( "#audio_" + current_document ) . get ( 0 ) ; audio_elt . pause ( ) ; gui_state ( "paused" ) ; } }
function play_all ( ) { autoplay_next = play_first_source ( ) ; }
function ( error , stdout , stderr ) { if ( error ) { console . log ( error . stack ) ; console . log ( 'Error code: ' + error . code ) ; console . log ( 'Signal received: ' + error . signal ) ; } console . log ( "Template expansion successful!" ) ; }
function ( err , docs ) { for ( var i = 0 ; i < docs . length ; i ++ ) { totals = self . fromDb ( docs [ i ] , totals ) ; } callback ( totals ) ; }
function ( ) { var offset = this . container . offset ( ) ; var height = this . container . outerHeight ( ) ; var width = this . container . outerWidth ( ) ; var css = { top : offset . top + height , left : offset . left , width : width } if ( this . opts . dropdownZIndex !== undefined ) { css [ "z-index" ] = this . opts . dropdownZIndex ; } this . dropdown . css ( css ) ; }
function fetchIssues ( type , element , label ) { var labels = '[' + feature + ']' ; element . attr ( 'href' , 'http://github.com/jverkoey/nimbus/issues?labels=' + labels ) ; GitHubAPI . RepoIssues ( 'jverkoey' , 'nimbus' , labels , function ( json , status ) { if ( json ) { var text = json . length ; element . html ( label + ' ' + text ) ; } } ) ; }
function iterableProxy ( arr ) { return Proxy . create ( { getPropertyDescriptor : function ( name ) { for ( var obj = arr ; obj ; obj = Object . getPrototypeOf ( obj ) ) { var desc = Object . getOwnPropertyDescriptor ( obj , name ) ; if ( desc ) return desc ; } return undefined ; } } ) ; }
function ( aOptions , aCallback ) { configDebug ( aOptions . staticArgs . debug ) ; TabRequestsLogger ( ) ; SplitDock ( DockOptions ) ; ToolbarButton ( ButtonOptions ) ; contextMenu . Item ( MenuOptions ) ; if ( aOptions . loadReason == "install" ) { tabs . open ( self . data . url ( "about/index.html" ) ) ; } }
function UserCtrl ( $scope , $routeParams , githubResource ) { 'use strict' ; $scope . user_info = githubResource . get ( { user : $routeParams . user , repo : '' } ) ; $scope . publicRepoForms = { '1' : 'Public repo' , 'other' : 'Public repo' } ; $scope . followerForms = { '1' : 'Follower' , 'other' : 'Followers' } ; }
function ( key , x , y , e , graph ) { return '<h3>' + y + ' % </h3>' + '<p>' + x + " (" + e . point . title + ')</p>' }
function ( session ) { var worker = new WorkerClient ( [ "ace" ] , "ace/worker/coffee" , "Worker" ) ; worker . attachToDocument ( session . getDocument ( ) ) ; worker . on ( "error" , function ( e ) { session . setAnnotations ( [ e . data ] ) ; } ) ; worker . on ( "ok" , function ( e ) { session . clearAnnotations ( ) ; } ) ; return worker ; }
function mHTML ( ) { var html = "<div id='more' style='clear:both;'> </h1>" + "description:" + this . description + "tracklist :" + this . track1 + "<br/>" + "tracklist :" + this . track2 + "<br/>" + "tracklist :" + this . track3 + "<br/>" + "tracklist :" + this . track4 + "<br/>" + "tracklist :" + this . track5 + "</div>" ; return html ; }
function ( ) { $ ( 'span' , this ) . toggleClass ( 'ui-icon-triangle-1-s ui-icon-triangle-1-n' ) ; $ ( this ) . parent ( ) . next ( ) . toggle ( ) ; }
function plus ( args ) { var left = args [ 0 ] , right = args [ 1 ] ; if ( args . length != 2 ) { throw new Error ( "wrong number of arguments: needed 2, got " + args . length ) ; } if ( left . type !== 'number' || right . type !== 'number' ) { throw new Error ( "primitive + requires two numbers (got " + left . type + ", " + right . type + ")" ) ; } return Data . Number ( left . value + right . value ) ; }
function ( oElement ) { if ( typeof ( oElement . offsetParent ) != 'undefined' ) { for ( var posX = 0 , posY = 0 ; oElement ; oElement = oElement . offsetParent ) { posX += oElement . offsetLeft ; posY += oElement . offsetTop ; } return { 'x' : posX , 'y' : posY } ; } else { return { 'x' : oElement . x , 'y' : oElement . y } ; } }
function ( input_kde , factor ) { var output = [ ] ; $ . each ( input_kde . sort ( ) , function ( index , value ) { output [ index ] = [ value [ 0 ] , value [ 1 ] * factor ] } ) ; return output ; }
function ( ) { if ( ! this . disposed_ ) { this . disposed_ = true ; this . disposeInternal ( ) ; if ( goog . Disposable . ENABLE_MONITORING ) { var uid = goog . getUid ( this ) ; if ( ! goog . Disposable . instances_ . hasOwnProperty ( uid ) ) { throw Error ( this + ' did not call the goog.Disposable base ' + 'constructor or was disposed of after a clearUndisposedObjects ' + 'call' ) ; } delete goog . Disposable . instances_ [ uid ] ; } } }
function ( error , data ) { if ( error ) { var msg = "ERROR: " + sys . inspect ( error ) ; sys . debug ( msg ) response . write ( "<pre>" + msg + "</pre>" , "utf8" ) } else { response . write ( haml . render ( data ) , "utf8" ) } response . end ( ) }
function ( event ) { event . stopPropagation ( ) ; that . sortList ( listProps . colModel [ i ] , this ) ; }
function updateButtonLabel ( id , newvalue ) { if ( slider . getValue ( ) != 0 && newvalue != - 1 ) { var finalvalue = "show " + slider . getValue ( ) + mindate + newvalue ; document . getElementById ( id ) . value = finalvalue ; } else { document . getElementById ( id ) . value = "N/A" ; } }
function extractPostContent ( contentStr ) { post = JSON . parse ( contentStr ) ; post . title = html_encode ( post . title ) ; post . content = html_encode ( post . content ) ; var reg = new RegExp ( "\n" , "g" ) ; post . content = post . content . replace ( reg , '<br>' ) ; reg = new RegExp ( "\\[[0-9;]*[A-Za-z]" , "g" ) ; post . content = post . content . replace ( reg , '' ) ; return post ; }
function serverResponseError ( ) { var btns = { } ; btns [ PMA_messages [ 'strReloadPage' ] ] = function ( ) { window . location . reload ( ) ; } ; $ ( '#emptyDialog' ) . attr ( 'title' , PMA_messages [ 'strRefreshFailed' ] ) ; $ ( '#emptyDialog' ) . html ( PMA_getImage ( 's_attention.png' ) + PMA_messages [ 'strInvalidResponseExplanation' ] ) ; $ ( '#emptyDialog' ) . dialog ( { buttons : btns } ) ; }
function ( obj ) { var curtop = 0 ; if ( obj . offsetParent ) { do { curtop += obj . offsetTop ; } while ( obj = obj . offsetParent ) ; console . log ( curtop ) ; console . log ( NewCommentsHighlighter . newcomments_padding ) ; return [ curtop - NewCommentsHighlighter . newcomments_padding ] ; } }
function ( pos ) { console . log ( pos ) ; console . log ( NewCommentsHighlighter . new_comment_boxes ) ; if ( NewCommentsHighlighter . new_comment_boxes . length == 0 ) { return ; } NewCommentsHighlighter . presentCommentMarker = pos + 1 ; var comment = NewCommentsHighlighter . new_comment_boxes [ NewCommentsHighlighter . presentCommentMarker ] ; console . log ( comment ) ; window . scroll ( 0 , NewCommentsHighlighter . findPos ( comment ) ) ; }
function ( pos ) { console . log ( pos ) ; if ( NewCommentsHighlighter . new_comment_boxes . length == 0 ) { return ; } if ( pos > 0 ) { NewCommentsHighlighter . presentCommentMarker = pos - 1 ; } var comment = NewCommentsHighlighter . new_comment_boxes [ NewCommentsHighlighter . presentCommentMarker ] ; console . log ( comment ) ; window . scroll ( 0 , NewCommentsHighlighter . findPos ( comment ) ) ; }
function adjustmentMonth ( ) { var prev_month = month - 1 ; var next_month = month + 1 ; if ( prev_month < 1 ) { prev_month = 12 ; } if ( next_month > 12 ) { next_month = 1 ; } j ( ".month .prevmonth" ) . html ( "<a href=\"\">&lt;&lt;" + prev_month + "月</a>" ) ; j ( ".month .currentmonth" ) . html ( month + "月" ) ; j ( ".month .nextmonth" ) . html ( "<a href=\"\">" + next_month + "月&gt;&gt;</a>" ) ; j ( ".e2m_calender .cal_year" ) . html ( "<p class=\"cal_year\">" + year + "年</p>" ) ; }
function sendRequest ( request , anchor_element ) { if ( _is_locked ) return ; request = request + ';' + sSessionVar + '=' + sSessionId + ';xml' ; var sUrl = smf_prepareScriptUrl ( smf_scripturl ) + request ; setBusy ( 1 ) ; if ( anchor_element == null ) sendXMLDocument ( sUrl , '' , response_xml ) ; else sendXMLDocumentWithAnchor ( sUrl , '' , response , anchor_element ) ; }
function getHelper ( helper ) { var view = this , tmplHelpers = view . tmpl . helpers || { } ; helper = ( view . ctx [ helper ] !== undefined ? view . ctx : tmplHelpers [ helper ] !== undefined ? tmplHelpers : helpers [ helper ] !== undefined ? helpers : { } ) [ helper ] ; return typeof helper !== "function" ? helper : function ( ) { return helper . apply ( view , arguments ) ; } ; }
function ( tagObject , args ) { var i = 0 , l = args . length ; while ( l && ! args [ i ++ ] ) { if ( i === l ) { return "" ; } } view . onElse = undefined ; tagObject . path = "" ; return tagObject . renderContent ( view ) ; }
function ( data ) { widget = data [ 'editor' ] ; PTL . editor . updateBreadcrumbs ( data [ 'dircrumbs' ] , data [ 'storecrumbs' ] ) ; PTL . editor . updatePager ( PTL . editor . createPager ( uid ) ) ; if ( data . ctx ) { PTL . editor . ctxGap = PTL . editor . ctxStep ; ctx . before = data . ctx . before ; ctx . after = data . ctx . after ; } }
function ( ) { var before = $ ( ".ctx-row.before" ) , after = $ ( ".ctx-row.after" ) ; if ( before . length || after . length ) { PTL . editor . ctxGap -= PTL . editor . ctxStep ; before . slice ( 0 , PTL . editor . ctxStep ) . remove ( ) ; after . slice ( - PTL . editor . ctxStep ) . remove ( ) ; } }
function ( f , stat ) { var _ref ; if ( stat . isDirectory ( ) && ( _ref = path . basename ( f ) , __indexOf . call ( exceptFolders , _ref ) >= 0 ) ) { return false ; } if ( stat . isDirectory ( ) ) { return true ; } return /\.(coffee|js|styl|jade)$/ . test ( f ) ; }
function distanceTo ( target ) { if ( ! this . x || ! this . y || ! target . x || ! target . y ) { return false ; } var origin = { x : this . x , y : this . y } ; return distanceBetween ( origin , target ) ; }
function distanceBetween ( point1 , point2 ) { if ( ! point1 . x || ! point1 . y || ! point2 . x || ! point2 . y ) { return false ; } var deltaX = ( point2 . x - point1 . x ) , deltaY = ( point2 . y - point1 . y ) ; return Math . sqrt ( Math . pow ( deltaX , 2 ) + Math . pow ( deltaY , 2 ) ) ; }
function lineTo ( destination , ctx ) { if ( ! this . x || ! this . y ) { edward . error ( 'lineTo()\'s host object needs an x and y value' ) ; } ctx . beginPath ( ) ; ctx . moveTo ( this . x , this . y ) ; ctx . lineTo ( destination . x , destination . y ) ; ctx . stroke ( ) ; return destination ; }
function lineTo ( destination , ctx ) { if ( ! this . x || ! this . y ) { edward . error ( 'lineTo()\'s host object needs an x and y value' ) ; } ctx . beginPath ( ) ; ctx . moveTo ( this . x , this . y ) ; ctx . lineTo ( destination . x , destination . y ) ; ctx . stroke ( ) ; return destination ; }
function distanceTo ( target ) { if ( ! this . x || ! this . y || ! target . x || ! target . y ) { return false ; } var origin = { x : this . x , y : this . y } ; return distanceBetween ( origin , target ) ; }
function distanceBetween ( point1 , point2 ) { if ( ! point1 . x || ! point1 . y || ! point2 . x || ! point2 . y ) { return false ; } var deltaX = ( point2 . x - point1 . x ) , deltaY = ( point2 . y - point1 . y ) ; return Math . sqrt ( Math . pow ( deltaX , 2 ) + Math . pow ( deltaY , 2 ) ) ; }
function ( json ) { var templateJson = createModel ( json ) , html = planSelectionTemplate ( templateJson ) ; rootElement . html ( html ) ; rootElement . collapse ( 'show' ) ; rootElement . find ( '.project-item input:checked' ) . each ( function ( ) { $ ( this ) . closest ( '.collapse' ) . addClass ( 'in' ) ; } ) ; rootElement . show ( ) ; }
function ( ) { this . sessionHeader = null ; this . SESSION_HEADER = 'App-Session' ; }
function ( ) { this . sessionHeader = null ; this . SESSION_HEADER = 'App-Session' ; }
function ( ) { this . sessionHeader = null ; this . SESSION_HEADER = 'App-Session' ; }
function ( callback ) { if ( sessionAlive ) callback ( ) ; else { authenticate ( callback ) ; SalesforceOAuthPlugin . getLoginDomain ( function ( val ) { loginHostUrl = val . toLowerCase ( ) ; } ) ; if ( ! sf ) sf = new sforce . Client ( ) ; } }
function ( callback ) { if ( sessionAlive ) callback ( ) ; else { authenticate ( callback ) ; SalesforceOAuthPlugin . getLoginDomain ( function ( val ) { loginHostUrl = val . toLowerCase ( ) ; } ) ; if ( ! sf ) sf = new sforce . Client ( ) ; } }
function ( url ) { if ( app == 'python' ) { document . title = 'isolate_window|url' } else { var width = 960 , height = 600 left = ( screen . width / 2 ) - ( width / 2 ) , top = ( screen . height / 2 ) - ( height / 2 ) window . open ( url , Math . random ( ) , 'toolbar=no, type=popup, status=no, width=' + width + ', height=' + height + ', top=' + top + ', left=' + left ) } }
function ( input ) { var numberValue = parseFloat ( input ) ; var objRegExp = /(\-*\d+\.*\d*)(\s*)(\w*\%*)/ ; var unitsString = input . replace ( objRegExp , "$3" ) ; if ( unitsString ) { var noSpaces = /(\s*)(\S*)(\s*)/ ; var match = ( unitsString . replace ( noSpaces , "$2" ) ) . toLowerCase ( ) ; } return [ numberValue , match ] ; }
function ( pseudo , possibleQuote , argument , context , xml ) { var fn = Expr . pseudos [ pseudo . toLowerCase ( ) ] ; if ( ! fn ) { Sizzle . error ( "unsupported pseudo: " + pseudo ) ; } if ( ! fn . sizzleFilter ) { return fn ; } return fn ( argument , context , xml ) ; }
function ( data ) { var api = this , url = this . wsURL + '/rest/api/post/register' ; $ . ajax ( { url : url , data : data , header : "Access-Control-Allow-Headers: x-requested-with" , type : "POST" , dataType : "json" , crossDomain : true , cache : true , async : false , success : function ( response ) { api . resgisterresponse = response ; } , error : function ( xhr , e , et ) { var jo = { "status" : "server error" } ; } } ) ; }
function ( data ) { var api = this , url = this . wsURL + '/rest/api/post/login' ; $ . ajax ( { url : url , data : data , header : "Access-Control-Allow-Headers: x-requested-with" , type : "POST" , dataType : "json" , crossDomain : true , cache : true , async : false , success : function ( response ) { api . loginresponse = response ; } , error : function ( xhr , e , et ) { var jo = { "status" : "server error" } ; } } ) ; }
function ( event ) { self . hideItems = [ 'Login' ] ; if ( self . phrescoapi . userLogin ( ) === true ) { var obj = self . api . doLogin ( self . phrescoapi . logindata ) ; self . phrescoapi . hideWidget ( self . hideItems ) ; self . listener . publish ( event , "LoginSuccess" , [ event . data ] ) ; self . listener . publish ( event , "Navigation" , [ event . data ] ) ; } }
function ( event ) { this . hideItems = [ 'Register' ] ; if ( this . phrescoapi . userRegister ( ) === true ) { this . api . doRegister ( this . phrescoapi . registerdata ) ; this . phrescoapi . hideWidget ( this . hideItems ) ; this . listener . publish ( event , "RegisterSuccess" , [ event . data ] ) ; } }
function ( index , element ) { var element_id = $ ( element ) . attr ( 'id' ) ; var progress_stat = element_id . match ( /^quota_(.+)/ ) [ 1 ] ; if ( progress_stat === undefined ) { return ; } else if ( progress_stat === 'instances' ) { update_amount = instance_count ; } else { update_amount = ( scope . selected_flavor [ progress_stat ] * instance_count ) ; } scope . updateUsageFor ( element , update_amount ) ; }
function ( ev , ui ) { var droppedObject = jQuery ( ui . draggable ) . clone ( ) ; debug . info ( 'CodeFrame drop' , droppedObj ) ; if ( droppedObject . hasClass ( 'file' ) ) { editFile ( droppedObject . attr ( "path" ) ) ; } }
function ( e ) { if ( e . which === 13 ) { dtable . fnFilter ( e . target . value ) ; if ( selections . indexOf ( e . target . value ) === - 1 ) { selections . push ( e . target . value ) ; } input_obj . autocomplete ( 'close' ) ; } }
function ( ev ) { debug . info ( 'View Docs context event:' ) ; var modpath = _findMatch ( ev ) . getAttribute ( 'modpath' ) ; var url = '/docs/plugins/' + modpath ; var parts = modpath . split ( '.' ) var cname = parts . pop ( ) window . open ( url , 'Docs for ' + modpath ) ; }
function handleMessage ( message ) { if ( message . length !== 2 || message [ 0 ] !== 'types' ) { debug . warn ( 'Invalid types data:' , message ) ; debug . warn ( 'message length' , message . length , 'topic' , message [ 0 ] ) ; } else { libs . html ( "<div>Updating...</div>" ) . effect ( 'highlight' , { color : '#ffd' } , 1000 ) ; updatePalette ( message [ 1 ] [ 0 ] ) ; } }
function ( e ) { var layout_pane = jQuery ( '.ui-layout-' + e ) ; debug . info ( 'layout resize' , e , layout_pane ) ; jQuery ( layout_pane . find ( '.ui-tabs-panel' ) . each ( function ( ) { var panel = jQuery ( this ) ; panel . width ( layout_pane . width ( ) ) ; panel . height ( layout_pane . height ( ) - panel . position ( ) . top ) ; } ) ) ; }
function ( ) { optionsDialog . animate ( { bottom : - optionsDialog . _measuredHeight , opacity : 1 , duration : 0 } ) ; dimmingView . animate ( { opacity : 0.5 , duration : 150 } , function ( ) { optionsDialog . animate ( { bottom : 0 , duration : 150 } ) ; } ) ; }
function ( left , right , radius ) { setStyle ( this . _upArrow , "borderTopLeftRadius" , left ? radius : "0px" ) ; setStyle ( this . _downArrow , "borderBottomLeftRadius" , left ? radius : "0px" ) ; setStyle ( this . _upArrow , "borderTopRightRadius" , right ? radius : "0px" ) ; setStyle ( this . _downArrow , "borderBottomRightRadius" , right ? radius : "0px" ) ; setStyle ( this . domNode , "borderRight" , right ? "" : "1px solid #666" ) ; }
function ( ) { if ( this . _hasSizeDimensions ( ) ) { var widestRowWidth = 0 ; for ( var i in this . _rows ) { var row = this . _rows [ i ] ; widestRowWidth = Math . max ( widestRowWidth , row . _measureText ( row . title , row . domNode ) . width ) ; } if ( this . _widestRowWidth !== widestRowWidth ) { this . _widestRowWidth = widestRowWidth ; this . _triggerLayout ( ) ; } } }
function ( ) { if ( this . _hasSizeDimensions ( ) ) { var widestRowWidth = 0 , tallestRowHeight = 0 ; for ( var i in this . _rows ) { var row = this . _rows [ i ] ; tallestRowHeight = Math . max ( tallestRowHeight , row . _measureText ( row . title , row . domNode ) . height ) ; } return tallestRowHeight ; } }
function ( ) { this . _contentContainer = dom . create ( "div" , { className : "TiUIProgressBarContainer" , style : { pointerEvents : "none" , width : "100%" , height : "100%" , overflow : "hidden" } } , this . domNode ) ; this . _indicator = dom . create ( "div" , { className : "TiUIProgressBarIndicator" , style : { pointerEvents : "none" , width : "0%" , height : "100%" } } , this . _contentContainer ) ; }
function ( params ) { var values = this . properties . __values__ ; values . width = params . isParentSize . width ? UI . SIZE : "100%" ; values . height = params . isParentSize . height ? UI . SIZE : "100%" ; return Widget . prototype . _doLayout . call ( this , params ) ; }
function ( args ) { this . _indexedContent = [ ] ; require . each ( [ "_header" , "_rows" , "_footer" ] , lang . hitch ( this , function ( v ) { Widget . prototype . add . call ( this , this [ v ] = UI . createView ( { height : UI . SIZE , width : UI . INHERIT , layout : "vertical" } ) ) ; } ) ) ; this . layout = "vertical" ; }
function ( value ) { var match = value . match ( /^(horizontal|vertical)$/ ) , value = match ? match [ 0 ] : "composite" ; if ( this . _layout ) { this . _layout . destroy ( ) ; this . _layout = null ; } this . _layout = new Layouts [ string . capitalize ( value ) ] ( this ) ; return value ; }
function ( e , element ) { if ( e . touches . length == 1 && e . changedTouches . length == 1 ) { this . _touchStartLocation = { x : e . changedTouches [ 0 ] . clientX , y : e . changedTouches [ 0 ] . clientY } } }
function ( e , element ) { this . _touchStartLocation = null ; }
function ( child , parent ) { if ( ! child . _alive || ! child . domNode ) { console . debug ( "WARNING: Attempting to layout element that has been destroyed.\n\t Removing the element from the parent.\n\t The parent has a widget ID of " + parent . widgetId + "." ) ; var children = parent . children ; children . splice ( children . indexOf ( child ) , 1 ) ; return ; } return 1 ; }
function ( view ) { view . _setParent ( this ) ; this . children . push ( view ) ; this . containerNode . appendChild ( view . domNode ) ; view . _hasBeenLaidOut = false ; this . _triggerLayout ( this . _isAttachedToActiveWin ( ) ) ; }
function ( view ) { var p = this . children . indexOf ( view ) ; if ( p !== - 1 ) { this . children . splice ( p , 1 ) ; view . _setParent ( ) ; dom . detach ( view . domNode ) ; this . _triggerLayout ( ) ; } }
function ( params ) { this . startLayout ( ) ; for ( var i in params ) { this [ i ] = params [ i ] ; } this . finishLayout ( ) ; }
function ( anim , callback ) { if ( UI . _layoutInProgress ) { on . once ( UI , "postlayout" , lang . hitch ( this , function ( ) { this . _doAnimation ( anim , callback ) ; } ) ) ; } else { this . _doAnimation ( anim , callback ) ; } }
function ( ) { dimmingView . animate ( { opacity : 0.5 , duration : 200 } , function ( ) { alertDialog . animate ( { opacity : 1 , duration : 200 } ) ; } ) ; }
function ( ) { if ( ! this . _hasDefaultLook ) { this . _hasDefaultLook = true ; this . _previousBorderWidth = this . borderWidth ; this . _previousBorderColor = this . borderColor ; css . add ( this . domNode , "TiUIElementGradient" ) ; css . add ( this . domNode , "TiUIButtonDefault" ) ; this . _contentContainer . borderWidth = 6 ; } }
function ( ) { this . container . _triggerLayout ( ) ; this . onload && this . onload ( ) ; }
function ( slot , data ) { var ability = this . _abilities [ slot ] ; if ( ! ability ) throw ( "ability in slot '" , slot , "' not found!" ) ; ability . UsedBy ( this , data ) ; }
function ( x , y ) { this . _moveTo = { x : x , y : y } ; var center = this . GetCenter ( ) ; this . trigger ( "NewDirection" , Math3D . Normalize ( { x : x - center . x , y : y - center . y } ) ) ; }
function ( ) { var entity = Crafty . e ( "2D, DOM, Mouse, Body, Damageable, BodyAnimations, AbilityUser, NavigationHandle, AvoidanceHandle, AI, " + this . _getRandomSprite ( ) ) . attr ( { TileWidth : this . Width , TileHeight : this . Height , IsStatic : false , MovementSpeed : this . Speed , Faction : Factions . Ghost } ) . AddAbility ( "Primary" , new Ability_Shoot ( ) ) ; this . set ( { 'entity' : entity } ) ; }
function ( ) { var entity = this . getEntity ( ) ; if ( this . WalkAnimationFrames > 0 ) entity . WalkAnimation ( this . WalkAnimationFrames , this . WalkAnimationRows , this . WalkAnimationSpeed ) ; }
function toggleShowContentFct ( outerElement ) { var content = $ ( ".hiddenContent" , outerElement ) ; var vis = $ ( ":visible" , content ) ; if ( vis . length > 0 ) { content . slideUp ( 100 ) ; $ ( ".showElement" , outerElement ) . show ( ) ; $ ( ".hideElement" , outerElement ) . hide ( ) ; } else { content . slideDown ( 100 ) ; $ ( ".showElement" , outerElement ) . hide ( ) ; $ ( ".hideElement" , outerElement ) . show ( ) ; } }
function ( ) { var imageflow = new ImageFlow ( ) ; imageflow . init ( { ImageFlowID : 'instance_imageflow' , captions : false , slider : false , reflections : false , imageFocusMax : 2 , reflectionP : 0.4 , opacity : true , startID : 3 , startAnimation : true , imageFocusM : 1.5 , circular : true , slideshow : true , slideshowAutoplay : true , onClick : function ( ) { return false ; } } ) ; }
function ( ) { var that = this ; this . context = new webkitAudioContext ( ) ; this . node = this . context . createJavaScriptNode ( 256 , 1 , 1 ) ; this . node . onaudioprocess = function ( e ) { that . process ( e ) } ; this . frequency = 440 ; this . next_frequency = 440 ; this . amplitude = 1 ; this . sample_rate = 44100 ; this . x = 0 ; this . on = false ; }
function ( test ) { var args = { section : 'A827346H7AFSSFG9' } OrganizationAction . resourcesInSection ( args , function ( error , resources ) { test . ok ( resources . should . have . lengthOf ( 2 ) ) ; test . done ( ) ; } ) ; }
function ( e , res ) { if ( e ) return callback ( e ) ; doc . _rev = res . rev ; callback ( null , doc ) ; }
function ( err , found ) { should . strictEqual ( err , null ) ; found . length . should . equal ( 2 ) ; found [ 0 ] . id ; found [ 1 ] . id ; found [ 0 ] . _id . should . eql ( createdOne . _id ) ; found [ 1 ] . _id . should . eql ( createdTwo . _id ) ; db . close ( ) ; }
function ( ) { var enabled ; try { document . cookie = "test=true; max-age=1" ; enabled = document . cookie . indexOf ( "test" ) > - 1 ; } catch ( e ) { enabled = false ; } if ( typeof Network . cookiesEnabledOverride === "boolean" ) { enabled = Network . cookiesEnabledOverride ; } complete ( onComplete , enabled ) ; }
function ( senderID , eventCallback , successCallback , failureCallback ) { if ( typeof eventCallback != "string" ) { var e = new Array ( ) ; e . msg = 'eventCallback must be a STRING name of the routine' ; e . rc = - 1 ; failureCallback ( e ) ; return ; } alert ( 'GCM.register() called!' ) ; return Cordova . exec ( successCallback , failureCallback , 'GCMPlugin' , 'register' , [ { email : senderID , ecb : eventCallback } ] ) ; }
function ( div ) { var pass = true , id = "script" + ( new Date ( ) ) . getTime ( ) ; div . innerHTML = "<a name ='" + id + "'/>" ; docElem . insertBefore ( div , docElem . firstChild ) ; if ( document . getElementById ( id ) ) { pass = false ; } docElem . removeChild ( div ) ; return pass ; }
function ( opacity ) { if ( isNaN ( opacity ) || opacity > 1 || opacity < 0 ) { if ( this . options . debug ) { throw ( opacity + ' is not a valid value' ) ; } else { return } } this . layer . setOpacity ( opacity ) ; }
function ( bindings , parents ) { var key , squimBindings = { } ; for ( key in bindings ) { if ( bindings . hasOwnProperty ( key ) ) { squimBindings [ key ] = obj . squimify ( bindings [ key ] ) ; } } return new Env ( bindings , parent ) ; }
function ( ) { var lang = ( window . navigator . language || "en" ) . replace ( /-/g , "_" ) ; if ( ! this . languages [ lang ] ) { lang = lang . replace ( /_.*$/ , "" ) ; } wot . language = this . languages [ lang ] || "en" ; wot . log ( "wot.locale.setlocale: selected " + wot . language + "\n" ) ; this . loadlocale ( function ( ) { wot . locale . ready ( true ) ; } ) ; }
function ( value ) { this . topLevelMenu [ 2 ] . entries [ 4 ] . checked = ! this . topLevelMenu [ 2 ] . entries [ 4 ] . checked ; document . application . model . show3dGrid = this . topLevelMenu [ 2 ] . entries [ 4 ] . checked ; }
function deleteObject ( ) { if ( editedobject != "" ) { var id = $ ( editedobject ) . attr ( "id" ) ; var index = id . split ( "____object" ) [ 1 ] ; removeItemFromObjectMap ( index ) ; $ ( editedobject ) . remove ( ) ; $ ( "#deleteBtn" ) . css ( "left" , - 30000 ) $ ( "#contextbar" ) . css ( "visibility" , "hidden" ) ; } }
function ( ) { return this . tools || ( this . tools = { 'tbar' : [ { id : 'save' , action : 'save' , security : this . options && this . options . insert ? this . insertSecurity : this . updateSecurity } , { id : 'cancel' , side : 'left' , publish : '/app/scene/back' } ] } ) ; }
function ( item ) { var node = domConstruct . toDom ( this . itemTemplate . apply ( item , item . source ) ) ; item . domNode = node ; domClass . add ( node , 'on-' + item . side ) ; this . _sync ( item ) ; domConstruct . place ( node , this . domNode ) ; return node ; }
function ( ) { this . inherited ( arguments ) ; var map = { 'tbar' : 'top' , 'bbar' : 'bottom' } , tools = this . get ( 'tools' ) ; if ( tools ) { for ( var name in tools ) { var mapped = map [ name ] || name ; if ( this . $ [ mapped ] ) this . $ [ mapped ] . set ( 'items' , tools [ name ] ) ; } } }
function ( e ) { if ( scroller . disabled ) return ; if ( slowMode && scroller . scrolling ) return ; scroller . calculate ( e ) ; for ( var i = 0 ; i < scroller . scrollCallbacks . length ; i ++ ) { scroller . scrollCallbacks [ i ] ( e ) ; } if ( slowMode ) { scroller . scrolling = true ; setTimeout ( function ( ) { delete scroller . scrolling } , 500 ) } }
function ( key , value , options ) { return arguments . length === 1 ? Cookies . get ( key ) : Cookies . set ( key , value , options ) ; }
function ( id ) { this . removeChildrenFromNode ( $ ( 'RB_window' ) ) ; this . moveChildren ( $ ( id ) , $ ( 'RB_window' ) ) ; this . activateRBWindow ( ) ; }
function _lintCPP ( prev , baton ) { var options = [ "--R" , "--filter=-whitespace/line_length,-whitespace/comments,-whitespace/labels,-readability/streams" ] , files = [ "ext" ] ; _exec ( 'python ' + __dirname + "/../dependencies/cpplint/cpplint.py " + options . concat ( files ) . join ( ' ' ) , prev , baton ) ; }
function ( field ) { var max = this . data [ 0 ] [ field ] ; for ( var dP in this . data ) { if ( this . data [ dP ] [ field ] > max ) max = this . data [ dP ] [ field ] ; } return max ; }
function ( field ) { var mean = 0 ; for ( var dP in this . data ) { mean += this . data [ dP ] [ field ] ; } return ( mean / this . data . length ) ; }
function ( ) { if ( $ ( this ) . attr ( "checked" ) ) { $ . get ( 'actions/experiments.php' , { action : "hideSes" , id : $ ( this ) . attr ( 'name' ) } , function ( data ) { alert ( data ) ; } ) ; } else { $ . get ( 'actions/experiments.php' , { action : "unhideSes" , id : $ ( this ) . attr ( 'name' ) } , function ( data ) { alert ( data ) ; } ) ; } }
function ( aChannel ) { if ( ! aChannel ) return ; this . _docRequest = aChannel ; let uri = aChannel . URI . cloneIgnoringRef ( ) ; uri . userPass = '' ; this . _request = uri . asciiSpec ; let referrer = aChannel . referrer . cloneIgnoringRef ( ) ; referrer . userPass = '' ; this . _referrer = referrer . asciiSpec ; }
function onPopState ( event ) { var newState = event . state ; if ( ! newState ) if ( expectNullState ) { expectNullState = false ; return ; } else newState = initialState ; if ( newState != currentState ) { currentState = newState ; onStateChange ( currentState != "" ? currentState : "/" ) ; } }
function onHashChange ( ) { var newLocation = _$_WT_CLASS_$_ . history . getCurrentState ( ) ; if ( currentHash == newLocation ) { return ; } else { currentHash = newLocation ; setTimeout ( function ( ) { update ( null , 'hash' , null , true ) ; } , 1 ) ; } }
function ( L , M , D , K ) { if ( M == JavaScriptPrototype ) { L = D . indexOf ( ".prototype" ) ; _$_WT_CLASS_$_ [ D . substr ( 0 , L ) ] . prototype [ D . substr ( L + 11 ) ] = K } else _$_WT_CLASS_$_ [ D ] = M == JavaScriptFunction ? function ( ) { K . apply ( _$_WT_CLASS_$_ , arguments ) } : K }
function showPopup ( popup ) { if ( typeof activePopup != 'undefined' ) if ( activePopup == popup ) popup . toggle ( ) ; else { activePopup . hide ( ) ; popup . show ( ) ; } else popup . show ( ) ; activePopup = popup ; }
function remoteCmd ( cmd , args , success , error ) { pm ( { target : window . frames [ 0 ] , type : "command" , data : { cmd : cmd , args : args } , success : success , error : error } ) ; }
function define ( obj , key , desc ) { if ( 'value' in desc ) { desc . value = unwrap ( desc . value ) ; } else { if ( 'get' in desc ) desc . get = unwrap ( desc . get ) ; if ( 'set' in desc ) desc . set = unwrap ( desc . set ) ; } Object . defineProperty ( obj , key , desc ) ; return TRUE ; }
function ( pt , rect ) { var w = rect [ 0 ] , h = rect [ 1 ] ; this . path ( [ [ 0 , 0 ] , [ w , 0 ] , [ w , h ] , [ 0 , h ] , [ 0 , 0 ] ] , pt ) ; return this ; }
function ( indexViewModel ) { var post = _ . chain ( indexViewModel . posts ) . filter ( function ( post ) { return post . id === request . params . id } ) . first ( ) . value ( ) ; callback ( post ) ; }
function getPostViewModel ( req , callback ) { var request = req ; getIndexViewModel ( function ( indexViewModel ) { var post = _ . chain ( indexViewModel . posts ) . filter ( function ( post ) { return post . id === request . params . id } ) . first ( ) . value ( ) ; callback ( post ) ; } ) ; }
function ( ) { var _this = this ; if ( this . model . get ( "not_fetched" ) ) { this . model . fetch ( { success : function ( ) { _this . model . set ( "not_fetched" , false ) ; return _this . renderIt ( ) ; } } ) ; } else { this . renderIt ( ) ; } return this ; }
function ( err ) { if ( err ) { console . log ( "background worker: got an error on previous job: " , err ) ; } if ( messageQueue . length ) { var job = messageQueue . splice ( 0 , 1 ) [ 0 ] ; if ( ! job . type in jobs ) { console . log ( "background worker: unknown job " , job ) ; return next ( ) ; } console . log ( "background worker: launching " , job ) ; jobs [ job . type ] ( next ) ; } }
function ( ) { var nConnect = require ( "connect" ) , nPath = require ( "path" ) ; nConnect ( ) . use ( nConnect . static ( nPath . join ( process . cwd ( ) , "default" ) ) ) . listen ( 6789 ) ; }
function ( ) { var uiSourceCodes = this . uiSourceCodes ( ) ; for ( var i = 0 ; i < uiSourceCodes . length ; ++ i ) this . dispatchEventToListeners ( WebInspector . UISourceCodeProvider . Events . UISourceCodeRemoved , uiSourceCodes [ i ] ) ; this . _sourceMapByURL = { } ; this . _sourceMapForScriptId = { } ; this . _scriptForSourceMap = new Map ( ) ; this . _sourceMapForUISourceCode = new Map ( ) ; this . _uiSourceCodeByURL = { } ; }
function ( ) { var removedUISourceCodes = this . _releasedUISourceCodes ( ) ; this . _uiSourceCodeForScriptId = { } ; this . _scriptForUISourceCode = new Map ( ) ; for ( var i = 0 ; i < removedUISourceCodes . length ; ++ i ) this . _snippetScriptMapping . _fireUISourceCodeRemoved ( removedUISourceCodes [ i ] ) ; }
function ( anchor ) { if ( this . _debuggerEnabled && anchor . uiSourceCode ) return true ; var uiSourceCodes = this . _uiSourceCodeProvider . uiSourceCodes ( ) ; for ( var i = 0 ; i < uiSourceCodes . length ; ++ i ) { if ( uiSourceCodes [ i ] . url === anchor . href ) { anchor . uiSourceCode = uiSourceCodes [ i ] ; return true ; } } return false ; }
function ( ) { this . _toggleFormatSourceButton . toggled = ! this . _toggleFormatSourceButton . toggled ; var uiSourceCodes = this . _uiSourceCodeProvider . uiSourceCodes ( ) ; for ( var i = 0 ; i < uiSourceCodes . length ; ++ i ) uiSourceCodes [ i ] . setFormatted ( this . _toggleFormatSourceButton . toggled ) ; }
function ( ) { WebInspector . resourceTreeModel . addEventListener ( WebInspector . ResourceTreeModel . EventTypes . CachedResourcesLoaded , this . _initialize , this ) ; WebInspector . resourceTreeModel . addEventListener ( WebInspector . ResourceTreeModel . EventTypes . WillLoadCachedResources , this . _reset , this ) ; WebInspector . resourceTreeModel . addEventListener ( WebInspector . ResourceTreeModel . EventTypes . MainFrameNavigated , this . _reset , this ) ; this . _uiSourceCodes = [ ] ; }
function ( ) { var scriptMapping = new WebInspector . DebuggerScriptMapping ( ) ; var providers = scriptMapping . uiSourceCodeProviders ( ) ; providers = providers . concat ( new WebInspector . StylesUISourceCodeProvider ( ) ) ; WebInspector . CompositeUISourceCodeProvider . call ( this , providers ) ; new WebInspector . PresentationConsoleMessageHelper ( this ) ; }
function onZoomDone ( ) { $canvas . css ( { '-moz-transform' : null } ) ; $tabEl . removeClass ( "front" ) ; UI . goToTab ( tab ) ; if ( tab != gBrowser . selectedTab ) { UI . onTabSelect ( gBrowser . selectedTab ) ; } else { if ( isNewBlankTab ) gWindow . gURLBar . focus ( ) ; } if ( self . parent && self . parent . expanded ) self . parent . collapse ( ) ; self . _sendToSubscribers ( "zoomedIn" ) ; }
function onTabViewHidden ( ) { window . removeEventListener ( "tabviewhidden" , onTabViewHidden , false ) ; ok ( frontChanged , "the CSS class 'front' was added while zooming in" ) ; ok ( transformChanged , "the CSS class '-moz-transform' was modified while " + "zooming in" ) ; frontChanged = transformChanged = false ; tab . $container [ 0 ] . removeEventListener ( "DOMAttrModified" , checkForFrontAddition , false ) ; tab . $container [ 0 ] . addEventListener ( "DOMAttrModified" , checkForFrontRemoval , false ) ; window . addEventListener ( "tabviewshown" , onTabViewShownAgain , false ) ; TabView . toggle ( ) ; }
function ( name , value ) { var options = [ "showUserAgentCSS" , "computedStylesDisplay" , "colorDisplay" , "showMozillaSpecificStyles" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . refresh ( ) ; }
function ( name , value ) { var options = [ "onlyShowAppliedStyles" , "showUserAgentCSS" , "expandShorthandProps" , "colorDisplay" , "showMozillaSpecificStyles" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . refresh ( ) ; }
function ( name , value ) { var options = [ "showUserProps" , "showUserFuncs" , "showDOMProps" , "showDOMFuncs" , "showDOMConstants" , "showInlineEventHandlers" , "showOwnProperties" , "showEnumerableProperties" ] ; var isRefreshOption = function ( element ) { return element == name ; } ; if ( options . some ( isRefreshOption ) ) this . rebuild ( true ) ; }
function ( sourceBox , viewRange ) { try { this . updateViewportCache ( sourceBox , viewRange ) ; } catch ( exc ) { if ( FBTrace . DBG_ERRORS ) FBTrace . sysout ( "buildViewAround updateViewportCache FAILS " + exc , exc ) ; } Dom . collapse ( sourceBox , false ) ; this . setViewportPadding ( sourceBox , viewRange ) ; sourceBox . centralLine = Math . floor ( ( viewRange . lastLine + viewRange . firstLine ) / 2 ) ; this . applyDecorator ( sourceBox ) ; return ; }
function ( row ) { var expected = Fx13 ? "\\s*item6=\\\"6\\\",\\s*item7=\\\"7\\\",\\s*" + FW . FBL . $STR ( "firebug.reps.more" ) + "...\\s*" : "\\s*item6=\\\"6\\\",\\s*item3=\\\"3\\\",\\s*" + FW . FBL . $STR ( "firebug.reps.more" ) + "...\\s*" ; FBTest . compare ( new RegExp ( "\\s*" + FW . FBL . $STRP ( "firebug.storage.totalItems" , [ 10 ] ) + expected ) , row . textContent , "The local storage must have proper data" ) ; callback ( ) ; }
function ( id , chunkId , chunkSize , chunk ) { var obj = { } ; obj . command = 'CHUNK' ; obj . id = id ; var data = { } ; data . chunkId = chunkId ; data . chunkSize = chunkSize ; data . chunk = chunk ; obj . data = data ; console . log ( 'chunk()' , obj ) ; return sendObj ( obj ) ; }
function ( file , text ) { var chunks = Math . ceil ( text . length / chunkSize ) ; console . log ( text , text . length , chunks ) ; for ( var c = 0 ; c < chunks ; c ++ ) { var start = c * chunkSize ; var end = ( c + 1 ) * chunkSize ; var chunk = utf8_to_b64 ( text . substring ( start , end ) ) ; Command . chunk ( file . id , c , chunkSize , chunk ) ; } }
function ( data , meta ) { var ct = meta . http . headers [ 'content-type' ] ; doneCalled = true ; A . areSame ( 'hi' , data , 'bad string to done' ) ; A . areSame ( 1 , ct . length , "should be only one content-type header" ) ; A . areSame ( 'text/plain; charset="utf-8"' , ct [ 0 ] ) ; }
function ( data , meta ) { var ct = meta . http . headers [ 'content-type' ] ; doneCalled = true ; A . areSame ( Y . JSON . stringify ( json ) , data , 'bad string to done' ) ; A . areSame ( 1 , ct . length , "should be only one content-type header" ) ; A . areSame ( 'application/json; charset="utf-8"' , ct [ 0 ] ) ; }
function ( data , meta ) { var ct = meta . http . headers [ 'content-type' ] ; doneCalled = true ; A . areSame ( '<xml><hi>there</hi></xml>' , data , 'bad string to done' ) ; A . areSame ( 1 , ct . length , "should be only one content-type header" ) ; A . areSame ( 'application/xml; charset="utf-8"' , ct [ 0 ] ) ; }
function ( ) { fileExplorer . structure = dirSlightlyAlteredAndInJSON ; fileExplorer . render ( ) ; $ ( '.backbone-file-explorer-directory:not(:first)' ) . bind ( 'drag' , dragHandler ) ; $ ( '.backbone-file-explorer-directory:not(:first)' ) . bind ( 'drop' , dropHandler ) ; fileExplorer . idle ( ) ; $ ( '#message' ) . text ( '' ) ; }
function ( ) { fileExplorer . busy ( ) ; $ ( '#message' ) . text ( 'User clicked upload link.' ) ; setTimeout ( function ( ) { fileExplorer . structure = dirSlightlyAlteredAndInJSON ; fileExplorer . render ( ) ; $ ( '.backbone-file-explorer-directory:not(:first)' ) . bind ( 'drag' , dragHandler ) ; $ ( '.backbone-file-explorer-directory:not(:first)' ) . bind ( 'drop' , dropHandler ) ; fileExplorer . idle ( ) ; $ ( '#message' ) . text ( '' ) ; } , 1000 ) ; }
function ( ) { var f ; f = b . _data ( this ) . mousewheelHandler = c . bind ( a , this ) ; p ( this , e , f ) } , tearDown : function ( ) { var a , c = b . _data ( this ) ; a = c . mousewheelHandler ; m ( this , e , a ) ; delete c [ a ] }
function ( status , stream ) { if ( status >= 400 ) { if ( config . error [ status ] ) { stream . emit ( 'error' , { code : status , definition : config . error [ status ] . definition , description : config . error [ status ] . description } ) ; } else { stream . emit ( 'error' , { code : status , definition : 'Unrecognized error' , description : 'Sorry. We dont know the kind of error. Check Twitter docs: https://dev.twitter.com/docs/error-codes-responses' } ) ; } stream . emit ( 'http error' , status ) ; } }
function ( ) { return StackMob [ 'apiURL' ] || ( StackMob [ 'fullURL' ] ? ( StackMob [ 'apiVersion' ] === 0 ? StackMob . getDevAPIBase ( ) : StackMob . getProdAPIBase ( ) ) : ( window . location . protocol + '//' + window . location . hostname + ( window . location . port ? ':' + window . location . port : '' ) ) + '/' ) ; }
function ( prop , value ) { this . prop = prop ; this . value = value ; if ( this . supportType . indexOf ( prop ) == - 1 ) return ; this . attributes = { } ; this . multValue ( value . split ( ' ' ) ) ; }
function ( ) { var cssReader = this . cssReader ; cssReader . on ( cssReader . get ( 'RULE_END_EVT' ) , this . getRule , this ) ; cssReader . on ( 'change:timeEnd' , this . cssEnd , this ) ; this . on ( 'change:imgPath' , this . setImgPath ) ; }
function ( e ) { var property = e . property ; var imageIndex = property . indexOf ( 'background' ) ; if ( imageIndex == - 1 ) imageIndex = property . indexOf ( 'background-image' ) ; if ( imageIndex > - 1 ) { this . collectImages ( e , imageIndex ) ; } }
function ( ) { var images = this . images ; var baseDir = path . dirname ( this . get ( 'file' ) ) ; var files = { } ; forEach ( images , function ( file ) { files [ path . resolve ( baseDir , file ) ] = 1 ; } ) ; files = Object . keys ( files ) ; Api . getImagesSize ( files , this . setDef , this ) ; }
function parseStringLiteral ( AST ) { var literal = [ ] , node , enclosing = next ( ) ; if ( ! ( enclosing === '"' || enclosing === "'" ) ) { throw "Unexpected token " + enclosing + " where string literal was expected" ; } while ( hasNext ( ) && peek ( ) !== enclosing ) { literal . push ( next ( ) ) ; } consume ( ) ; node = newNode ( 'equals' , AST ) ; newNode ( literal . join ( '' ) , node . nodes ) ; }
function ( buf , off ) { debug ( 'frame_hi(' + sys . inspect ( buf ) + ', ' + off + ')' ) ; if ( buf [ off ] !== 0 ) { throw new Error ( 'High-byte framing not supported.' ) ; } serverClosed = true ; return 1 ; }
function km_disableSetting ( theKey ) { var i = this . settingGroups . indexOf ( theKey ) ; if ( i === - 1 ) { this . updateSettings ( ) ; return ; } this . settingGroups = [ ] . concat ( this . settingGroups . slice ( 0 , i ) , this . settingGroups . slice ( i + 1 , this . settingGroups . length ) ) ; this . updateSettings ( ) ; }
function ( e ) { if ( e . detail . type === 'blur' ) { IMEController . hideIME ( ) ; } else { if ( e . detail . type != 'submit' ) IMEController . showIME ( e . detail . type ) ; } }
function ( ) { var grid = Engine . getComponent ( Ext . ux . CardGrid , 'Ext.ux.CardGrid' ) if ( grid . store && grid . rendered ) { grid . store . load ( ) } Ext . getCmp ( 'tab-panel' ) . toolbars [ 0 ] . add ( grid ) ; Ext . getCmp ( 'tab-panel' ) . toolbars [ 0 ] . add ( grid ) ; Ext . getCmp ( 'tab-panel' ) . toolbars [ 0 ] . doLayout ( ) ; }
function ( err , authorized , data ) { if ( ! err && ! authorized ) { err = new Error ( 'unauthorized' ) ; } if ( err ) { client . error ( err ) ; client . destroySoon ( ) ; } else { var packet = new OutgoingPacket ( client , packets . TYPE_HANDSHAKE , binson . calculate ( data ) ) ; packet . writeBinson ( data ) ; client . sendPacket ( packet ) ; client . onAuthorized ( data ) ; } }
function ( ) { if ( fluid . get ( that . globalModel . model , "primaryModel.csid" ) ) { that . events . primaryRecordCreated . fire ( ) ; } }
function ( node , nodeParent , newParent ) { console . log ( 'dropped ' + node . id + ' to ' + newParent . id + ', p: ' + nodeParent . id ) ; RPC . UserGui . MoveNavigationItem ( node . id , node . ntype , null , newParent . id , { success : function ( ret , e ) { if ( e . status ) { } else { Ext . MessageBox . alert ( "Error" , e . message ) ; me . refresh ( ) ; } } } ) ; }
function ( pconfig ) { RPC . UserGui . AddNewUserPortalPage ( pconfig , { success : function ( ret , e ) { if ( e . status ) { mp . refresh ( ) ; me . openPortalPage ( ret . Id ) ; } } } ) ; }
function ( b , name ) { var pid = null ; if ( ! Ext . isEmpty ( sn ) ) { alert ( 'sth sel' + b + ' ' + sn . ntype ) ; pid = sn . id ; } RPC . UserGui . CreateNavigationFolder ( pid , name , { success : function ( e , ret ) { p . refresh ( ) ; } } ) ; }
function ( ) { var p = me . down ( '#navpanel' ) ; var sn = p . getSelectedNode ( ) ; if ( Ext . isEmpty ( sn ) ) return ; RPC . UserGui . DeleteNavigationFolder ( sn . id , { success : function ( e , ret ) { p . refresh ( ) ; } } ) ; }
function ( route ) { route = expandRoute ( route , '.css' , context . css . root ) ; if ( ! route . match ( REMOTE_PATH ) ) { route = _this . options . servePath + _this . compileCSS ( route ) ; } if ( _this . options . pathsOnly ) return route ; return "<link rel='stylesheet' href='" + route + "'>" ; }
function ( ) { var _j , _len2 , _ref2 , _results ; _results = [ ] ; for ( _j = 0 , _len2 = chain . length ; _j < _len2 ; _j ++ ) { _ref2 = chain [ _j ] , filename = _ref2 . filename , js = _ref2 . js ; filename = stripExt ( filename ) + '.js' ; this . cache . set ( filename , js ) ; _results . push ( "/" + filename ) ; } return _results ; }
function setTransientParent ( _parent ) { this . parent = _parent ; if ( 'actor_list' in self ) _parent . actor_list . push ( this ) ; else _parent . actor_list = [ this ] ; this . _setTransientParent ( _parent ) ; if ( 'application' in _parent ) { setApplication ( this , _parent . application ) ; getWidgetIdDict ( this , function ( idDict ) { for ( var id in idDict ) _parent . application . widget [ id ] = idDict [ id ] ; } ) ; } }
function ( ) { var container = document . createElement ( 'div' ) ; container . setAttribute ( 'id' , 'UpdateYourBrowser' ) ; document . body . appendChild ( d ) ; var content = '<!--[if lt IE 9]>' + '<style type="text/css">' + '#UpdateYourBrowser{z-index:2147483647;position:absolute;left:25%;top:25%;}' + '</style>' + '<img src="https://raw.github.com/adius/UpdateYourBrowser/master/img/default_en.png" alt="Update your browser!" width="640px" height="340px" usemap="#linkmap" />' + '<map name="linkmap" id="linkmap">' + '<area shape="circle" coords="622,18,16"  style="cursor:pointer" onclick="getElementById(\'UpdateYourBrowser\').style.display = \'none\';" title="Close Window" alt="Close Window" />' + '<area shape="rect" coords="60,180,170,320" href="http://mozilla.com/" target="_blank" title="Download Firefox" alt="Download Firefox" />' + '<area shape="rect" coords="200,180,310,320" href="http://google.com/chrome" target="_blank"  title="Download Google Chrome" alt="Download Google Chrome" />' + '<area shape="rect" coords="340,180,450,320" href="http://opera.com/download/" target="_blank" title="Download Opera" alt="Download Opera" />' + '<area shape="rect" coords="480,180,590,320" href="http://apple.com/safari/download/" target="_blank" title="Download Apple Safari" alt="Download Apple Safari" />' + '</map>' + '<![endif]-->' + '' ; container . innerHTML = content ; }
function writeOriginalSentences ( ) { for ( var s = 0 ; s < sentences . length ; s ++ ) { $ ( "#sent" + s ) . text ( sentences [ s ] ) ; } }
function tx ( message , next ) { var cipher = crypto . createCipher ( algorithm , key ) ; var msg = cipher . update ( message . toString ( 'binary' ) , 'binary' , 'binary' ) ; msg += cipher . final ( 'binary' ) ; next ( null , new Buffer ( msg , 'binary' ) ) ; }
function rx ( message , remote , next ) { var decipher = crypto . createDecipher ( algorithm , key ) ; var msg = decipher . update ( message . toString ( 'binary' ) , 'binary' , 'binary' ) ; msg += decipher . final ( 'binary' ) ; next ( null , new Buffer ( msg , 'binary' ) ) ; }
function ( trackEvent ) { var targetList = createTargetsList ( trackEvent ) ; var manifestOptions = trackEvent . manifest . options ; for ( var item in manifestOptions ) { if ( manifestOptions . hasOwnProperty ( item ) ) { _rootElement . appendChild ( createManifestItem ( item , manifestOptions [ item ] , trackEvent . popcornOptions [ item ] , trackEvent ) ) ; } } _rootElement . appendChild ( targetList ) ; _this . updatePropertiesFromManifest ( trackEvent . popcornOptions ) ; }
function openEditor ( trackEvent ) { if ( _currentEditor ) { _currentEditor . close ( ) ; } _currentEditor = Editor . create ( "default" , butter ) ; _currentEditor . open ( butter . ui . areas . editor . element , trackEvent ) ; }
function read ( ) { var hashError , hashErrorIndex ; hashError = window . location . hash . toString ( ) . replace ( /#/ , '' ) ; hashErrorIndex = hashError . indexOf ( errorHash ) ; if ( hashErrorIndex != - 1 ) { errorCurrent . type = hashError . replace ( /error=/i , '' ) ; errorState = true ; } }
function getDigit ( start , stop ) { var str = '[0-9０-９]' + ( start ? '{' + start + ',' + stop + '}' : '+' ) ; if ( set [ 'digits' ] ) str += '|[' + set [ 'digits' ] + ']+' ; return str ; }
function getNum ( ) { var arr = [ getDigit ( ) ] . concat ( set [ 'articles' ] ) ; if ( ! set [ 'digits' ] ) arr = arr . concat ( set [ 'numbers' ] ) ; return arr . compact ( ) . join ( '|' ) ; }
function ( data ) { self . status ( data . status ) ; self . activity ( data . activity ) ; }
function ( ) { var dom = fragment ( element ( "p" , a ( "wiki:CamelCase" , "CamelCase" ) , " " , element ( "tt" , "CamelCase" ) , " " , a ( "wiki:FooBarA" , "FooBarA" ) , " FOo " , a ( "wiki:FoobarA" , "FoobarA" ) , " " , a ( "wiki:<ParentLink" , "<ParentLink" ) , " " , a ( "wiki:>ChildLink" , ">ChildLink" ) , " " , a ( "wiki:.AbsoluteLink" , ".AbsoluteLink" ) , " " , a ( "wiki:.AbsoluteLink.WikiPage" , ".AbsoluteLink.WikiPage" ) , " OneÅngström Oneångström setTextColor" ) ) ; generateFragment . call ( this , dom , "CamelCase !-CamelCase-! FooBarA FOo FoobarA <ParentLink >ChildLink .AbsoluteLink .AbsoluteLink.WikiPage OneÅngström Oneångström setTextColor" ) ; }
function ( ) { var dom = fragment ( element ( "p" , a ( "TestPage" , "label" ) , a ( "TestPage" , "läbel" ) , a ( "TestPage" , "TestPage" ) , a ( "FrontPage?edit" , "Edit" ) , " button and add a " , a ( "FitNesse.UserGuide.WikiWord" , "!-WikiWord-!" ) ) ) ; var wikitext = "[[label][TestPage]]" + "[[läbel][TestPage]]" + "[[TestPage][TestPage]]" + "[[Edit][FrontPage?edit]] button and add a [[!-WikiWord-!][FitNesse.UserGuide.WikiWord]]" ; generateWikitext . call ( this , dom , wikitext ) ; generateFragment . call ( this , dom , wikitext ) ; }
function ( data ) { json = eval ( '(' + data + ')' ) ; plot ( json . data ) ; $ ( '#analytics-new-messages-range' ) . html ( v ) ; $ ( '#analytics-new-messages-range-type' ) . html ( range_type ) ; $ ( "#analytics-new-messages-update-loading" ) . hide ( ) ; }
function ( data ) { json = eval ( '(' + data + ')' ) ; count = $ ( ".health-throughput-current" ) ; count . html ( parseInt ( parseInt ( json . count ) / 5 ) ) ; count . fadeOut ( 200 , function ( ) { count . fadeIn ( 200 ) ; } ) ; }
function ( data ) { result = eval ( '(' + data + ')' ) ; if ( result . code == "success" ) { render_result ( success ( result . ms , result . content , result . op , result . result ) ) ; } else { render_result ( error ( result . reason ) ) ; } bindMessageSidebarClicks ( ) ; eternalize ( ) ; }
function remove_puppet_class ( item ) { var id = $ ( item ) . attr ( 'data-class-id' ) ; $ ( '#puppetclass_' + id ) . show ( ) ; $ ( '#selected_puppetclass_' + id ) . remove ( ) ; return false ; }
function ( ) { var currItem = this . _data [ this . _current ] ; this . _data . splice ( this . _current , 1 ) ; this . _data . push ( currItem ) ; this . _render ( ) ; }
function ( doc , cdt , cdn ) { if ( doc . __islocal ) { var callback1 = function ( r , rt ) { refresh_field ( 'budget_distribution_details' ) ; } $c ( 'runserverobj' , args = { 'method' : 'get_months' , 'docs' : compress_doclist ( [ doc ] ) } , callback1 ) ; } }
function ( rb ) { if ( rep_name ) { var t = rb . current_loaded ; var route_changed = ( rb . current_route != wn . get_route_str ( ) ) rb . load_criteria ( rep_name ) ; if ( rb . dt && route_changed ) { rb . dt . run ( ) ; } } if ( ! rb . forbidden ) { wn . container . change_to ( 'Report Builder' ) ; } }
function ( doc , cdt , cdn ) { $c ( 'runserverobj' , args = { 'method' : 'to_date_validation' , 'docs' : compress_doclist ( [ doc ] ) } , function ( r , rt ) { var doc = locals [ cdt ] [ cdn ] ; if ( r . message ) { alert ( "To date cannot be before from date" ) ; doc . to_date = '' ; refresh_field ( 'to_date' ) ; } } ) ; }
function ( doc , dt , dn ) { $c ( 'runserverobj' , args = { 'method' : 'check_state' , 'docs' : compress_doclist ( [ doc ] ) } , function ( r , rt ) { if ( r . message ) { set_field_options ( 'state' , r . message ) ; } } ) ; }
function ( doc , cdt , cdn ) { var callback = function ( r , rt ) { set_field_options ( 'select_doc_for_series' , r . message ) ; } $c_obj ( [ doc ] , 'get_transactions' , '' , callback ) ; cur_frm . cscript . refresh ( ) ; }
function ( doc , cdt , cdn ) { var callback = function ( r , rt ) { locals [ cdt ] [ cdn ] . set_options = r . message ; refresh_field ( 'set_options' ) ; } $c_obj ( [ doc ] , 'get_options' , '' , callback ) }
function ( ) { jQuery ( this ) . removeAttr ( 'width' ) . removeAttr ( 'height' ) . removeAttr ( 'valign' ) ; if ( this . innerHTML . replace ( /[\s\xA0]+/g , '' ) === '<p><br></p>' ) { this . innerHTML = '&nbsp;' ; } if ( jQuery ( this ) . find ( 'p' ) . length == 1 ) { jQuery ( this ) . find ( 'p' ) . contents ( ) . unwrap ( ) ; } }
function ( NormalImage ) { if ( NormalImage ) { this . addChild ( NormalImage , 0 , cc . NORMAL_TAG ) ; NormalImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; NormalImage . setIsVisible ( true ) ; } if ( this . _normalImage ) { this . removeChild ( this . _normalImage , true ) ; } this . _normalImage = NormalImage ; }
function ( SelectedImage ) { if ( SelectedImage ) { this . addChild ( SelectedImage , 0 , cc . SELECTED_TAG ) ; SelectedImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; SelectedImage . setIsVisible ( false ) ; } if ( this . _selectedImage ) { this . removeChild ( this . _selectedImage , true ) ; } this . _selectedImage = SelectedImage ; }
function ( DisabledImage ) { if ( DisabledImage ) { this . addChild ( DisabledImage , 0 , cc . DISABLE_TAG ) ; DisabledImage . setAnchorPoint ( cc . ccp ( 0 , 0 ) ) ; DisabledImage . setIsVisible ( false ) ; } if ( this . _disabledImage ) { this . removeChild ( this . _disabledImage , true ) ; } this . _disabledImage = DisabledImage ; }
function ( ) { this . _super ( ) ; if ( this . _disabledImage ) { this . _disabledImage . setIsVisible ( false ) ; } if ( this . _selectedImage ) { this . _normalImage . setIsVisible ( false ) ; this . _selectedImage . setIsVisible ( true ) ; } else { this . _normalImage . setIsVisible ( true ) ; } }
function ( ) { this . _super ( ) ; this . _normalImage . setIsVisible ( true ) ; if ( this . _selectedImage ) { this . _selectedImage . setIsVisible ( false ) ; } if ( this . _disabledImage ) { this . _disabledImage . setIsVisible ( false ) ; } }
function ( args ) { this . dom . id = "DomMenu" + Date . now ( ) ; this . dom . className += " domMenu" ; this . _isRelativeAnchorPoint = false ; this . setContentSize ( cc . Director . sharedDirector ( ) . getWinSize ( ) ) ; for ( var i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] ) { this . addChild ( args [ i ] ) ; } } }
function ( tv ) { tv . pos = this . _positionInPixels ; tv . scale . x = this . _scaleX ; tv . scale . y = this . _scaleY ; tv . rotation = this . _rotation ; tv . skew . x = this . _skewX ; tv . skew . y = this . _skewY ; tv . ap = this . _anchorPointInPixels ; tv . visible = this . _isVisible ; return tv }
function ( ) { if ( cc . renderContextType == cc . CANVAS ) { return cc . SpriteFrame . _frameWithTextureForCanvas ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSizeInPixels ) ; } else { return cc . SpriteFrame . create ( this . _texture , this . _rectInPixels , this . _rectRotated , this . _unflippedOffsetPositionFromCenter , this . _contentSizeInPixels ) ; } }
function ( dt ) { var children = this . _batchNode . getChildren ( ) ; if ( cc . ENABLE_PROFILERS ) { cc . ProfilingBeginTimingBlock ( this . _profilingTimer ) ; } for ( var i = 0 ; i < children . length ; i ++ ) { var sprite = children [ i ] ; sprite . setIsVisible ( false ) ; } if ( cc . ENABLE_PROFILERS ) { cc . ProfilingEndTimingBlock ( this . _profilingTimer ) ; } }
function ( dt ) { var children = this . _batchNode . getChildren ( ) ; if ( cc . ENABLE_PROFILERS ) { cc . ProfilingBeginTimingBlock ( this . _profilingTimer ) ; } for ( var i = 0 ; i < children . length ; i ++ ) { var sprite = children [ i ] ; sprite . setIsVisible ( false ) ; } if ( cc . ENABLE_PROFILERS ) { cc . ProfilingEndTimingBlock ( this . _profilingTimer ) ; } }
function ( time ) { if ( this . _target && ! this . isDone ( ) ) { var slice = 1.0 / this . _times ; var m = time % slice ; this . _target . setIsVisible ( m > slice / 2 ? true : false ) ; } }
function ( ) { if ( cc . NODE_TRANSFORM_USING_AFFINE_MATRIX ) { this . _isTransformGLDirty = true ; this . _transformGL = 0.0 ; } this . _anchorPoint = new cc . Point ( 0 , 0 ) ; this . _anchorPointInPixels = new cc . Point ( 0 , 0 ) ; this . _contentSize = new cc . Size ( 0 , 0 ) ; this . _contentSizeInPixels = new cc . Size ( 0 , 0 ) ; }
function ( newPosition ) { this . _position = newPosition ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { this . _positionInPixels = this . _position ; } else { this . _positionInPixels = cc . ccpMult ( newPosition , cc . CONTENT_SCALE_FACTOR ( ) ) ; } this . setNodeDirty ( ) ; }
function ( point ) { if ( ! cc . Point . CCPointEqualToPoint ( point , this . _anchorPoint ) ) { this . _anchorPoint = point ; this . _anchorPointInPixels = new cc . Point ( this . _contentSizeInPixels . width * this . _anchorPoint . x , this . _contentSizeInPixels . height * this . _anchorPoint . y ) ; this . setNodeDirty ( ) ; } }
function ( cleanup ) { if ( this . _children != null ) { for ( var i = 0 ; i < this . _children . length ; i ++ ) { var node = this . _children [ i ] ; if ( node ) { if ( this . _isRunning ) { node . onExit ( ) ; } if ( cleanup ) { node . cleanup ( ) ; } node . setParent ( null ) ; } } this . _children = [ ] ; } }
function ( child , doCleanup ) { if ( this . _isRunning ) { child . onExit ( ) ; } if ( doCleanup ) { child . cleanup ( ) ; } child . setParent ( null ) ; cc . ArrayRemoveObject ( this . _children , child ) ; }
function ( child , zOrder ) { cc . Assert ( child != null , "Child must be non-nil" ) ; cc . ArrayRemoveObject ( this . _children , child ) ; this . _insertChild ( child , zOrder ) ; this . setNodeDirty ( ) ; }
function ( selector , interval ) { if ( ! interval ) interval = 0 ; cc . Assert ( selector , "Argument must be non-nil" ) ; cc . Assert ( interval >= 0 , "Argument must be positive" ) ; cc . Scheduler . sharedScheduler ( ) . scheduleSelector ( selector , this , interval , ! this . _isRunning ) ; }
function ( worldPoint ) { var ret = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { ret = cc . PointApplyAffineTransform ( worldPoint , this . worldToNodeTransform ( ) ) ; } else { ret = cc . ccpMult ( worldPoint , cc . CONTENT_SCALE_FACTOR ( ) ) ; ret = cc . PointApplyAffineTransform ( ret , this . worldToNodeTransform ( ) ) ; ret = cc . ccpMult ( ret , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } return ret ; }
function ( nodePoint ) { var ret = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { ret = cc . PointApplyAffineTransform ( nodePoint , this . nodeToWorldTransform ( ) ) ; } else { ret = cc . ccpMult ( nodePoint , cc . CONTENT_SCALE_FACTOR ( ) ) ; ret = cc . PointApplyAffineTransform ( ret , this . nodeToWorldTransform ( ) ) ; ret = cc . ccpMult ( ret , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } return ret ; }
function ( worldPoint ) { var nodePoint = this . convertToNodeSpace ( worldPoint ) ; var anchorInPoints = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { anchorInPoints = this . _anchorPointInPixels ; } else { anchorInPoints = cc . ccpMult ( this . _anchorPointInPixels , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } return cc . ccpSub ( nodePoint , anchorInPoints ) ; }
function ( nodePoint ) { var anchorInPoints = new cc . Point ( ) ; if ( cc . CONTENT_SCALE_FACTOR ( ) == 1 ) { anchorInPoints = this . _anchorPointInPixels ; } else { anchorInPoints = cc . ccpMult ( this . _anchorPointInPixels , 1 / cc . CONTENT_SCALE_FACTOR ( ) ) ; } var pt = new cc . Point ( ) ; pt = cc . ccpAdd ( nodePoint , anchorInPoints ) ; return this . convertToWorldSpace ( pt ) ; }
function ( ) { this . _super ( ) ; this . setAnchorPoint ( cc . ccp ( 0.5 , 0.5 ) ) ; this . _isRelativeAnchorPoint = false ; var director = cc . Director . sharedDirector ( ) ; if ( ! director ) { return false ; } this . setContentSize ( director . getWinSize ( ) ) ; this . _isTouchEnabled = false ; this . _isAccelerometerEnabled = false ; }
function ( dt ) { this . unschedule ( this . _setNewScene ) ; var director = cc . Director . sharedDirector ( ) ; this . _isSendCleanupToScene = director . isSendCleanupToScene ( ) ; director . replaceScene ( this . _inScene ) ; cc . TouchDispatcher . sharedDispatcher ( ) . setDispatchEvents ( true ) ; this . _outScene . setIsVisible ( true ) ; }
function ( ) { this . state = 1 ; this . overlays = [ ] ; this . circles = [ ] ; this . coordinates = [ ] ; this . addAgencies ( ) ; this . countAshokas ( ) ; this . addProjects ( ) ; this . currentProject = null ; this . projectMarkers = { } ; this . previousZoom = 3 ; this . previousCenter = null ; var that = this ; }
function ( ev ) { this . _drag = true ; this . setRadius ( F . dradii [ this . _area ] ) ; this . _setLabelRadius ( ) ; set_cursor ( 'move' ) ; stage . update ( ) ; var self = this ; stage . onMouseMove = function ( e ) { self . onDrag ( e ) ; } ; stage . onMouseUp = function ( e ) { self . onDrop ( e ) ; } ; }
function ( ev ) { stage . onMouseMove = null ; stage . onMouseUp = null ; this . parent . onDrop ( this ) ; set_cursor ( ) ; this . animate ( { radius : F . radii [ this . _area ] , } ) ; p = this . globalToLocal ( ev . stageX , ev . stageY ) ; if ( ! this . hitTest ( p . x , p . y ) ) this . _drag = false ; this . _mousedownEvent = null ; }
function ( event , ui ) { var p = self . _fc . globalToLocal ( event . pageX - o . left , event . pageY - o . top ) ; if ( ( p . x * p . x + p . y * p . y ) < F . joinRadius * F . joinRadius ) { self . join ( $jf ) ; } }
function ( ) { var $elem = $ ( "#footDiv" ) ; var i = $elem [ 0 ] ; if ( i ) { var ll = i . offsetTop ; while ( i == i . offsetParent ) { ll += i . offsetTop ; i = i . offsetParent ; } if ( ll < 800 ) { $elem . addClass ( "footDiv" ) ; } } }
function ( code ) { code += ";throw new Error('__sourceId__');" ; try { var fn = new Function ( 'require' , 'exports' , 'module' , code ) ; fn ( this . _getRequire ( ) , this . exports , this ) ; } catch ( e ) { if ( ! sourceIds . hasOwnProperty ( e . sourceId ) ) { sourceIds [ e . sourceId ] = this . filename ; } if ( e . message !== '__sourceId__' ) { throw e ; } } }
function ( points ) { var geometry = new THREE . Geometry ( ) ; for ( var i = 0 ; i < points . length ; i ++ ) { geometry . vertices . push ( new THREE . Vector3 ( points [ i ] . x , points [ i ] . y , 0 ) ) ; } return geometry ; }
function ( args ) { assert_signature ( "define" , args , "symbol" , "*" ) ; return rt . ns [ args [ 0 ] . value ] = rt . eval ( args [ 1 ] ) ; }
function type_name ( i ) { if ( types . is_list ( i ) ) return "list" ; if ( types . is_symbol ( i ) ) return "symbol" ; if ( types . is_number ( i ) ) return "number" ; if ( types . is_string ( i ) ) return "string" ; if ( types . is_function ( i ) ) return "function" ; return "unknown" ; }
function extractPostContent ( contentStr ) { post = JSON . parse ( contentStr ) ; post . title = html_encode ( post . title ) ; post . content = html_encode ( post . content ) ; var reg = new RegExp ( "\n" , "g" ) ; post . content = post . content . replace ( reg , '<br>' ) ; reg = new RegExp ( "\\[[0-9;]*m" , "g" ) ; post . content = post . content . replace ( reg , '' ) ; return post ; }
function ( sock , data ) { if ( sock . readyState !== "open" ) { logger . log ( LEVEL . ERROR , "[ERROR] Socket is not open, but tried to send: %s" , data ) return this } const crlf = data . lastIndexOf ( "\r\n" ) === data . length - 2 ? "" : "\r\n" sock . write ( data + crlf ) logger . log ( LEVEL . INFO , "[SENT]  %s" , data ) return this }
function ( irc ) { this . inviteTo = invite . bind ( this , irc ) this . kickFrom = kick . bind ( this , irc ) this . notify = notify . bind ( this , irc ) this . tell = say . bind ( this , irc ) return this }
function ( irc , text ) { const sender = this . params [ 0 ] , recip = sender === irc . user . nick ? this . from . nick : sender irc . send ( message ( COMMAND . PRIVMSG , [ recip , trailing ( text ) ] ) ) return this }
function ( irc , subject ) { const isChan = this instanceof Channel , chan = isChan ? this : subject , user = isChan ? ( subject instanceof Person ? subject . nick : subject ) : this . nick irc . send ( message ( COMMAND . INVITE , [ user , chan ] ) ) return this }
function ( irc , key , callback ) { const prms = [ this . name ] if ( arguments . length === 2 ) { callback = key instanceof Function ? key : null key = callback ? null : key } if ( callback ) anticipateJoin . call ( this , irc , callback ) if ( key ) prms . push ( key ) irc . send ( message ( COMMAND . JOIN , prms ) ) return this }
function ( irc , subject ) { const isChan = this instanceof Channel , from = isChan ? this : subject , user = isChan ? ( subject instanceof Person ? subject . nick : subject ) : this . nick irc . send ( message ( COMMAND . KICK , [ from , user ] ) ) return this }
function ( irc , callback ) { if ( arguments . length === 2 ) irc . observe ( ERROR . NOSUCHSERVER , REPLY . VERSION , function ( msg ) { } ) irc . send ( message ( COMMAND . VERSION , [ this . name ] ) ) return this }
function ( prefix , command , params ) { const argCount = arguments . length switch ( argCount ) { case 2 : return new Message ( null , prefix , command ) case 1 : return new Message ( null , prefix , [ ] ) case 3 : return new Message ( prefix , command , params ) default : throw new Error ( "No matching signature for %s" ) } }
function ( ) { $ ( '#debug' ) . html ( 'Acceleration vector: (' + this . acceleration . x . toFixed ( 2 ) + ', ' + this . acceleration . y . toFixed ( 2 ) + ')<br/>\     Velocity vector: (' + Math . round ( this . velocity . x ) + ', ' + Math . round ( this . velocity . y ) + ')\     Tilt: ' + this . tiltDebug [ 'x' ] + ', ' + this . tiltDebug [ 'y' ] ) ; }
function ( ) { this . overlay . style . display = 'none' ; this . removeEventListener ( "touchstart" , this . touchHandler , false ) ; this . style [ '-webkit-transition' ] = 'all 0.5s ease-in-out' ; this . style [ '-webkit-transform' ] = 'translate(' + bb . contextMenu . getWidth ( ) + ', 0px)' ; if ( ! this . peeking ) { this . header . removeEventListener ( "click" , this . hide , false ) ; } this . peeking = false ; }
function ( ) { this . overlay . style . display = 'none' ; this . removeEventListener ( "touchstart" , this . touchHandler , false ) ; this . style [ '-webkit-transition' ] = 'all 0.5s ease-in-out' ; this . style [ '-webkit-transform' ] = 'translate(' + bb . contextMenu . getWidth ( ) + ', 0px)' ; if ( ! this . peeking ) { this . header . removeEventListener ( "click" , this . hide , false ) ; } this . peeking = false ; }
function ( ) { this . overlay . style . display = 'none' ; this . removeEventListener ( "touchstart" , this . touchHandler , false ) ; this . style [ '-webkit-transition' ] = 'all 0.5s ease-in-out' ; this . style [ '-webkit-transform' ] = 'translate(' + bb . contextMenu . getWidth ( ) + ', 0px)' ; if ( ! this . peeking ) { this . header . removeEventListener ( "click" , this . hide , false ) ; } this . peeking = false ; }
function UICalendarDragDrop ( ) { this . scKey = 'background' ; this . scValue = '#c0c0c0' ; this . DOMUtil = eXo . core . DOMUtil ; this . DragDrop = eXo . core . DragDrop ; this . dropableSets = [ ] ; this . listView = false ; this . onMouseMoveCount = 0 ; }
function UICalendarPortlet ( ) { this . clickone = 0 ; this . portletId = "calendars" ; this . currentDate = 0 ; this . CELL_HEIGHT = 20 ; this . MINUTE_PER_CELL = 30 ; this . PIXELS_PER_MINUTE = this . CELL_HEIGHT / this . MINUTE_PER_CELL ; this . MINUTES_PER_PIXEL = this . MINUTE_PER_CELL / this . CELL_HEIGHT ; }
function ( obj ) { if ( obj . style . display != "block" ) { eXo . core . DOMUtil . cleanUpHiddenElements ( ) ; obj . style . display = "block" ; gj ( obj ) . on ( 'mouseover' , eXo . calendar . UICalendarPortlet . autoHide ) ; gj ( obj ) . on ( 'mouseout' , eXo . calendar . UICalendarPortlet . autoHide ) ; eXo . core . DOMUtil . listHideElements ( obj ) ; } else { obj . style . display = "none" ; } }
function ( form ) { form = ( typeof ( form ) == "string" ) ? eXo . calendar . UICalendarPortlet . getElementById ( form ) : form ; if ( ! form ) return ; var tr = gj ( form ) . find ( "tr.UIListViewRow" ) ; var i = tr . length ; eXo . calendar . UICalendarPortlet . viewType = "UIListView" ; var chk = null ; while ( i -- ) { gj ( tr [ i ] ) . on ( 'dblclick' , this . listViewDblClickCallback ) ; } }
function criaVetor ( xDimensions , yDimensions ) { var map = [ ] ; for ( var xLoop = 0 ; xLoop < xDimensions ; xLoop ++ ) { map [ xLoop ] = [ ] ; for ( var yLoop = 0 ; yLoop < yDimensions ; yLoop ++ ) { map [ xLoop ] [ yLoop ] = "" ; } } return map ; }
function ( err , grid ) { assert . ok ( ! err ) ; grid . encode ( 'utf' , { resolution : 4 } , function ( err , utf ) { assert . equal ( JSON . stringify ( utf ) , reference ) ; done ( ) ; } ) ; }
function ( value ) { value = value ? value : valueToSet var total = controlDataSource . total ( ) ; for ( var itemIndex = 0 ; itemIndex < total ; itemIndex ++ ) { if ( accessDataItemValue ( controlDataSource . at ( itemIndex ) ) == value ) { control . value ( value ) ; return ; } } control . value ( null ) ; }
function ( reason ) { var base_selector = '.marked-tags' ; if ( reason === 'good' ) { var extra_selector = '.interesting' ; } else { var extra_selector = '.ignored' ; } return $ ( base_selector + extra_selector ) ; }
function ( ) { var mergeEnv = function ( env ) { if ( ! env ) { return ; } for ( var key in env ) { Attacklab . wmd_env [ key ] = env [ key ] ; } } ; mergeEnv ( Attacklab . wmd_defaults ) ; mergeEnv ( Attacklab . account_options ) ; mergeEnv ( top [ "wmd_options" ] ) ; Attacklab . full = true ; var defaultButtons = "bold italic link blockquote code image ol ul heading hr" ; Attacklab . wmd_env . buttons = Attacklab . wmd_env . buttons || defaultButtons ; }
function ( ) { var that = this ; var promises = [ ] ; var ItemView = this . getItemView ( ) ; this . closeEmptyView ( ) ; this . collection . each ( function ( item , index ) { var promise = that . addItemView ( item , ItemView , index ) ; promises . push ( promise ) ; } ) ; return promises ; }
function ( ) { var that = this ; var ItemView = this . getItemView ( ) ; this . closeEmptyView ( ) ; this . collection . each ( function ( item , index ) { that . addItemView ( item , ItemView , index ) ; } ) ; }
function ( key ) { if ( typeof ( localStorage ) === 'undefined' ) { value = read_cookie ( key ) ; } else { value = localStorage [ key ] ; } if ( typeof ( value ) === 'undefined' || value === null ) { return null ; } return JSON . parse ( value ) ; }
function ( ) { this . _super ( ) ; var map = cc . TMXTiledMap . create ( "Resources/TileMaps/orthogonal-test1.tmx" ) ; this . addChild ( map , 0 , TAG_TILE_MAP ) ; var childrenArray = map . getChildren ( ) ; for ( var i = 0 ; i < childrenArray . length ; i ++ ) { var child = childrenArray [ i ] ; if ( ! child ) break ; } map . runAction ( cc . ScaleBy . create ( 2 , 0.5 ) ) ; }
function ( dt ) { var p = this . tamara . getPositionInPixels ( ) ; var map = this . getChildByTag ( TAG_TILE_MAP ) ; var newZ = 4 - ( p . y / 48 ) ; newZ = Math . max ( newZ , 0 ) ; map . reorderChild ( this . tamara , newZ ) ; }
function ( dt ) { var p = this . tamara . getPositionInPixels ( ) ; var map = this . getChildByTag ( TAG_TILE_MAP ) ; var newZ = 4 - ( ( p . y - 10 ) / 81 ) ; newZ = Math . max ( newZ , 0 ) ; map . reorderChild ( this . tamara , newZ ) ; }
function ( fileImage ) { this . _super ( ) ; if ( fileImage ) { this . initWithFile ( fileImage , cc . DEFAULT_SPRITE_BATCH_CAPACITY ) ; } this . setContentSize ( new cc . Size ( cc . canvas . width , cc . canvas . height ) ) ; this . _renderTexture = cc . RenderTexture . create ( cc . canvas . width , cc . canvas . height ) ; }
function ( pos ) { cc . Assert ( pos . x < this . _layerSize . width && pos . y < this . _layerSize . height && pos . x >= 0 && pos . y >= 0 , "TMXLayer: invalid position" ) ; cc . Assert ( this . _tiles && this . _atlasIndexArray , "TMXLayer: the tiles map has been released" ) ; var idx = pos . x + pos . y * this . _layerSize . width ; return this . _tiles [ idx ] ; }
function ( pos ) { var ret = cc . PointZero ( ) ; switch ( this . _layerOrientation ) { case cc . TMXOrientationOrtho : ret = this . _positionForOrthoAt ( pos ) ; break ; case cc . TMXOrientationIso : ret = this . _positionForIsoAt ( pos ) ; break ; case cc . TMXOrientationHex : ret = this . _positionForHexAt ( pos ) ; break ; } return ret ; }
function ( z ) { var item ; if ( this . _atlasIndexArray ) { for ( var i = 0 ; i < this . _atlasIndexArray . length ; i ++ ) { item = this . _atlasIndexArray [ i ] if ( item == z ) { break ; } } } cc . Assert ( item , "TMX atlas index not found. Shall not happen" ) ; return i ; }
function ( tmxFile ) { this . _tileSets = [ ] ; this . _layers = [ ] ; this . _TMXFileName = tmxFile ; this . _objectGroups = [ ] ; this . _properties = [ ] ; this . _tileProperties = [ ] ; this . _currentString = "" ; this . _storingCharacters = false ; this . _layerAttribs = cc . TMXLayerAttribNone ; this . _parentElement = cc . TMXPropertyNone ; return this . parseXMLFile ( this . _TMXFileName ) ; }
function ( ) { databindings . databind . removeBindings ( this ) ; }
function ( element , value , info , metaData ) { metaData . template = $ ( element ) . html ( ) ; $ ( element ) . empty ( ) ; }
function ( ) { return this . _particles ; }
function ( ) { console . log ( this . text ) ; this . myTemplate = new Ext . XTemplate ( "<div>" + this . text + "</div>" ) ; this . myTemplate . compile ( ) ; this . HTML = "" ; this . callParent ( arguments ) ; }
function ( ) { if ( this . nodeType === 3 ) { var listName = this . nodeValue ; var matches = listMatch . exec ( listName ) ; if ( matches && matches . length == 2 ) { cardLimit = matches [ 1 ] ; } } }
function ( visible ) { var treePane = this . treePane ; cpPosition = geometry . position ( this . contentPane . domNode ) ; visible === false ? this . removeChild ( treePane ) : this . addChild ( treePane ) ; this . _set ( 'treePaneVisible' , visible ) ; }
function highlightTarget ( anchor ) { console . debug ( "Highlighting target '%s'." , anchor ) ; $ ( "a[name=" + anchor + "]" ) . each ( function ( ) { if ( ! $ ( this ) . parent ( ) . parent ( ) . hasClass ( 'target-section' ) ) { console . debug ( "Wrapping the target-section" ) ; $ ( 'div.method-detail' ) . unwrap ( 'div.target-section' ) ; $ ( this ) . parent ( ) . wrap ( '<div class="target-section"></div>' ) ; } else { console . debug ( "Already wrapped." ) ; } } ) ; }
function ( request , sender , sendResponse ) { var uri = location . href ; switch ( request . action ) { case "enable" : break ; case "disable" : localStorage . removeItem ( "tinyhippos-enabled-uri" ) ; uri = uri . replace ( /enableripple=[^&]*[&]?/i , "" ) . replace ( /[\?&]*$/ , "" ) ; break ; default : throw { name : "MethodNotImplemented" , message : "Requested action is not supported!" } ; } sendResponse ( { } ) ; location . href = uri ; }
function handleBuild ( ) { bus . ajax ( "GET" , "http://127.0.0.1:9910/ripple/about" , null , function ( ) { doBuild ( ) ; } , function ( error ) { if ( error . code === 0 || error . code === 404 ) { startServices ( function ( ) { doBuild ( ) ; } ) ; } } ) ; }
function doBuild ( ) { var node = $ ( this ) , action = node . attr ( 'id' ) . split ( "-" ) [ 2 ] ; if ( node . hasClass ( "not-ready" ) ) { return ; } if ( ! settings . can ( action ) ) { settings . show ( action ) ; } else { settings . perform ( action ) ; } }
function initStates ( ) { var elevenCentComboState = createComboState ( 11 , [ 3 ] , [ 8 ] , null ) ; var tenCentComboState = createComboState ( 10 , [ 3 ] , [ 7 ] , elevenCentComboState ) ; var nineCentComboState = createComboState ( 9 , [ 3 ] , [ 6 ] , tenCentComboState ) ; var eightCentState = createCoinState ( 8 , nineCentComboState ) ; var sevenCentState = createCoinState ( 7 , eightCentState ) ; var sixCentState = createCoinState ( 6 , sevenCentState ) ; currentState = null ; }
function externalLink ( text , url , options ) { if ( isEmpty ( options ) ) { options = { } ; } return '<a href="' + url + '" ' + ( isEmpty ( options . class ) ? '' : 'class="' + options . class + '"' ) + '>' + text + ' <i class="icon-share link-external"></i></a>' ; }
function ( settings ) { return $ ( '<embed type="' + settings . type + '"autostart="false" auto="false" autoplay="false" allowfullscreen="true" allowScriptAccess="always"  />' ) . attr ( { 'src' : settings . src , wmode : "window" } ) . width ( settings . width ) . height ( settings . height ) ; }
function ( r ) { if ( message . text . match ( r . route ) ) { message . hostmask = message . raw . prefix ; message . matches = message . text . match ( r . route ) ; r . handler . call ( r . module . context , message , function ( out ) { output . call ( r . module . context , r , out ) ; } ) ; } ; }
function ( e , text ) { var msg = { type : 'exception' , level : 5 , timestamp : Date . now ( ) } ; msg . description = text || '' ; msg . stack = e . stack ; this . write ( msg ) ; }
function Network ( name ) { this . channelHandles = { } ; this . config = { } ; this . name = name ; console . log ( '%s process starting up...' , name . green ) ; this . loadConfig ( ) ; this . loadChannels ( ) ; this . bindEvents ( ) ; this . startClient ( ) ; this . listenMaster ( ) ; this . forwardEvents ( ) ; }
function ( ) { this . config = JSON . parse ( fs . readFileSync ( process . cwd ( ) + '/config.json' ) ) ; }
function ( ) { var the_cookie = document . cookie . split ( ';' ) ; if ( the_cookie [ 0 ] ) { this . data = unescape ( the_cookie [ 0 ] ) . evalJSON ( ) ; } return this . data ; }
function ( data ) { if ( data . user_profiles ) { this . add_user_profiles ( data . user_profiles ) ; } callback ( data ) ; }
function ( ) { var $comment = $ ( this ) ; var comment_view = new NEWSBLUR . Views . StoryComment ( { el : $comment , on_social_page : true , story : self . model } ) ; self . comment_views . push ( comment_view ) ; }
function ( data ) { this . model . set ( data . comment ) ; this . render ( ) ; NEWSBLUR . app . story_list . fetch_story_locations_in_feed_view ( ) ; }
function ( service ) { var options = "location=0,status=0,width=800,height=500" ; var url = "/oauth/" + service + "_connect" ; this . connect_window = window . open ( url , '_blank' , options ) ; }
function stopEditing ( ) { var toolbar = $ ( '.editableToolbar' ) ; toolbar . children ( ) . hide ( ) . end ( ) . find ( '.edit' ) . show ( ) ; var target = toolbar . get ( 0 ) . target ; $ ( target ) . attr ( 'contentEditable' , false ) ; postMessage ( "INACTIVE" , target . entity . id ) ; }
function ( err , hash ) { for ( var i in hash ) { dprint ( "Loading swarming phase:" + i ) ; try { var obj = eval ( hash [ i ] ) ; if ( obj != null ) { thisAdaptor . compiledSwarmingDescriptions [ i ] = obj ; } else { console . log ( "Failed to load " + i ) ; } } catch ( err ) { perror ( err , "*** Syntax error in swarming description: " + i ) ; } } }
function ( ) { if ( ! this . isClosed ) { console . log ( "Closing outlet " + this . sessionId ) if ( this . redisClient != null ) { this . redisClient . quit ( ) ; } delete thisAdaptor . connectedOutlets [ this . sessionId ] ; this . socket . destroy ( ) ; this . isClosed = true ; } }
function ( swarmName , constructor ) { var args = Array . prototype . slice . call ( arguments , 2 ) ; var cmd = { sessionId : this . sessionId , swarmingName : swarmName , command : "start" , ctor : constructor , commandArguments : args } ; if ( this . pendingCmds == null ) { util . writeObject ( this . sock , cmd ) ; } else { this . pendingCmds . push ( cmd ) ; } }
function ( sessionId , user , pass ) { var cmd = { sessionId : sessionId , swarmingName : "login.js" , command : "start" , commandArguments : [ sessionId , user , pass ] } ; util . writeObject ( this . sock , cmd ) ; }
function ( message , err ) { var errStr ; var stack ; if ( err != null ) { errStr = err . toString ( ) ; stack = err . stack ( ) ; } startSwarm ( "log.js" , "start" , [ message , errStr , stack , "ERROR" , executionContext . userId , executionContext . tenantId , executionContext . sessionId ] ) ; }
function ( message , aspect , err ) { var errStr ; var stack ; if ( err != null ) { errStr = err . toString ( ) ; stack = err . stack ( ) ; } if ( aspect == undefined ) { aspect = "DEBUG" ; } startSwarm ( "log.js" , "start" , [ message , errStr , stack , aspect , executionContext . tenantId , executionContext . sessionId ] ) ; }
function ( ) { var target = document . body ; target . ontouchstart = null ; target . ontouchmove = null target . ontouchend = null target . ontouchcancel = null target . ongesturestart = null target . ongesturechange = null target . ongestureend = null target . onorientationchange = null }
function ( i ) { var t = $ ( this ) , cell = $ ( 'li[data-val="_' + that . temp [ i ] + '"]' , t ) , x = cell . index ( ) , v = scrollToValid ( cell , x , i , dir ) , sc = i == index || index === undefined ; if ( x != v || sc ) that . scroll ( $ ( this ) , v , sc ? time : 0.2 , orig , i ) ; }
function ( ) { var v = $ ( this ) . attr ( 'value' ) ; main [ v ] = $ ( this ) . text ( ) ; if ( $ ( this ) . prop ( 'disabled' ) ) invalid . push ( v ) ; }
function ( cfg ) { if ( typeof cfg === 'object' ) { for ( var n in this ) { util . isObject ( this [ n ] ) && util . isObject ( cfg [ n ] ) ? this [ n ] = util . deepMix ( { } , this [ n ] , cfg [ n ] ) : this [ n ] = cfg [ n ] ? cfg [ n ] : this [ n ] ; } } }
function ( flag ) { if ( ! this . rootNode ) this . rootNode = this . getRootNode ( this . root ) ; if ( flag ) return util . removeClass ( this . rootNode , this . hideClass ) ; util . addClass ( this . rootNode , this . hideClass ) ; }
function ( data ) { var result = data [ "result" ] ; if ( result == "Failed" ) { alert ( "已存在该楼号，请核对！" ) ; objfc1 . select ( ) ; return false ; } else { document . getElementById ( "form" ) . submit ( ) ; return true ; } }
function ( data , status ) { if ( typeof ( data . error ) != 'undefined' ) { if ( data . error != '' ) { alert ( data . msg ) ; $ ( '#msg' ) . html ( data . msg ) ; } else { $ ( '#msg' ) . html ( data . msg ) ; } } }
function ( data ) { var result = data [ "result" ] ; if ( result == "Failed" ) { alert ( "已存在同名小区，请核对！" ) ; objfc1 . select ( ) ; return false ; } else { document . getElementById ( "form" ) . submit ( ) ; return true ; } }
function check_Project ( proName , objfc1 ) { alert ( proName ) ; $ . ajax ( { type : "POST" , url : "isProjectExist?proName=" + proName , dataType : "json" , success : function ( data ) { var result = data [ "result" ] ; if ( result == "Failed" ) { alert ( "已存在同名小区，请核对！" ) ; objfc1 . select ( ) ; return false ; } else { document . getElementById ( "form" ) . submit ( ) ; return true ; } } } ) ; }
function ( ) { $to . addClass ( $ . mobile . activePageClass + toPreClass ) ; $ . mobile . focusPage ( $to ) ; $to . height ( screenHeight + toScroll ) ; scrollPage ( ) ; if ( ! none ) { $to . animationComplete ( doneIn ) ; } $to . removeClass ( toPreClass ) . addClass ( name + " in" + reverseClass ) ; if ( none ) { doneIn ( ) ; } }
function ( fac ) { var factor , i , total ; factor = fac || 1 ; total = this . integrate ( ) ; for ( i = 0 ; i < this . bins . length ; i ++ ) { this . bins [ i ] . weight = factor * this . bins [ i ] . weight / total ; } return 0 ; }
function ( data ) { console . log ( 'Loading ' + key ) ; for ( var i in data . reverse ( ) ) { if ( data [ i ] . key == key ) { cb ( data [ i ] . val ) ; } } cb ( 'failed' ) ; }
function ( ) { var pos = $ ( this ) . offset ( ) ; console . log ( pos . left ) ; menu . css ( { 'left' : pos . left , 'top' : pos . top + 30 , 'z-index' : 2100 } ) ; menu . slideToggle ( ) ; $ ( this ) . toggleClass ( 'opened' ) ; return false ; }
function ( response ) { var gps = response [ geopointQuestionName ] ; if ( gps ) { var parts = gps . split ( " " ) ; if ( parts . length > 1 ) { var lat = parseFloat ( parts [ 0 ] ) ; var lng = parseFloat ( parts [ 1 ] ) ; if ( latLongFilter === undefined || latLongFilter ( lat , lng ) ) latLngArray . push ( { lat : lat , lng : fixlng ( lng ) } ) ; } } }
function ( ) { var ch = this . getVisibleChildren ( ) , chc , i = - 1 , sp = this . getSpacing ( ) , s = - sp ; while ( chc = ch [ ++ i ] ) { s += chc . getOuterWidth ( ) + sp ; } return s ; }
function ( widget , value ) { if ( value !== null ) { var childrenCount = value . length ; for ( var i = 0 ; i < childrenCount ; i ++ ) { org . eclipse . rwt . protocol . AdapterUtil . callWithTarget ( value [ i ] , function ( child ) { var index = value . indexOf ( org . eclipse . rwt . protocol . ObjectManager . getId ( child ) ) ; child . setZIndex ( childrenCount - index ) ; } ) ; } } }
function ( widget , value ) { var context = undefined ; var mouseDown = org . eclipse . swt . EventUtil . mouseDown ; var mouseUp = org . eclipse . swt . EventUtil . mouseUp ; if ( value ) { widget . addEventListener ( "mousedown" , mouseDown , context ) ; widget . addEventListener ( "mouseup" , mouseUp , context ) ; } else { widget . removeEventListener ( "mousedown" , mouseDown , context ) ; widget . removeEventListener ( "mouseup" , mouseUp , context ) ; } }
function ( widget , value ) { var context = undefined ; var detectByKey = org . eclipse . swt . EventUtil . menuDetectedByKey ; var detectByMouse = org . eclipse . swt . EventUtil . menuDetectedByMouse ; if ( value ) { widget . addEventListener ( "keydown" , detectByKey , context ) ; widget . addEventListener ( "mouseup" , detectByMouse , context ) ; } else { widget . removeEventListener ( "keydown" , detectByKey , context ) ; widget . removeEventListener ( "mouseup" , detectByMouse , context ) ; } }
function ( widget , value ) { var context = undefined ; var helpRequested = org . eclipse . swt . EventUtil . helpRequested ; if ( value ) { widget . addEventListener ( "keydown" , helpRequested , context ) ; } else { widget . removeEventListener ( "keydown" , helpRequested , context ) ; } }
function ( widget , value ) { widget . deselectAll ( ) ; for ( var i = 0 ; i < value . length ; i ++ ) { org . eclipse . rwt . protocol . AdapterUtil . callWithTarget ( value [ i ] , function ( item ) { widget . selectItem ( item ) ; } ) ; } }
function ( ) { $ ( function ( ) { window . viewModel . replay_mode ( ! 0 ) ; window . viewModel . replay_name ( window . replay . name ) ; $ ( "#menus" ) . hide ( ) ; $ ( "#game" ) . show ( ) ; window . game . load_state ( window . replay . state , ! 0 ) ; return setTimeout ( function ( ) { window . game . reset ( ) ; return window . viewModel . state ( "PLAY" ) } , 100 ) } ) }
function ( ) { if ( ! this . newPatient ) { this . newPatient = Ext . create ( 'Screener.view.NewPatient' ) ; Ext . Viewport . add ( this . newPatient ) ; } this . getFormid ( ) . setValue ( this . totalPatients ) ; this . getNewPatient ( ) . show ( ) ; }
function ( ) { if ( ! this . labOrderView ) { this . labOrderView = Ext . create ( 'Screener.view.LabOrderView' ) ; } this . getView ( ) . push ( this . labOrderView ) ; while ( lab_num > 0 ) { Ext . getCmp ( 'lab' + lab_num ) . remove ( { autoDestroy : true } ) ; Ext . getCmp ( 'lab' + lab_num ) . hide ( ) ; lab_num -- ; } }
function ( cb ) { var o1 = this ; var options = { uri : o1 . config . storage , headers : { 'X-Account-Meta-Temp-Url-Key' : o1 . options . tempURLKey } } ; o1 . _cloudRequest ( options , function ( err , res , body ) { cb ( err ) ; } ) ; }
function ( sCloudPath ) { var aPieces = sCloudPath . split ( '/' ) ; var sContainer = aPieces [ 0 ] ; var localPath = aPieces [ 1 ] ; var CDNContainer = this . hCDNContainers [ sContainer ] ; if ( ! CDNContainer ) { return null ; } var uri = CDNContainer [ o1 . options . useSSL ? 'cdn_ssl_uri' : 'cdn_uri' ] + '/' + localPath ; return uri ; }
function ( ) { var base = url . parse ( clientOptions . baseURI ) ; var scope = nock ( base . href ) . get ( base . path ) . matchHeader ( 'X-Auth-User' , mockOptions . user ) . matchHeader ( 'X-Auth-Key' , mockOptions . key ) . reply ( 204 , 'No Content' , { 'x-storage-url' : mockOptions . storage , 'x-cdn-management-url' : mockOptions . cdn , 'x-auth-token' : mockOptions . token } ) ; this . aScopes . push ( scope ) ; return this ; }
function ( ) { var storage = url . parse ( mockOptions . storage ) ; var scope = nock ( storage . href ) . get ( storage . path ) . matchHeader ( 'X-Account-Meta-Temp-Url-Key' , mockOptions . tempURLKey ) . reply ( 204 , 'No Content' ) ; this . aScopes . push ( scope ) ; return this ; }
function ( ) { $ ( "#old_password" ) . val ( "" ) ; $ ( "#new_password" ) . val ( "newpassword" ) ; bid . manageAccount . changePassword ( function ( status ) { equal ( status , false , "on missing old password, status is false" ) ; testHelpers . testTooltipVisible ( ) ; start ( ) ; } ) ; }
function ( ) { $ ( "#old_password" ) . val ( "oldpassword" ) ; $ ( "#new_password" ) . val ( "" ) ; bid . manageAccount . changePassword ( function ( status ) { equal ( status , false , "on missing new password, status is false" ) ; testHelpers . testTooltipVisible ( ) ; start ( ) ; } ) ; }
function ( status ) { equal ( status , true , "on proper completion, status is true" ) ; equal ( tooltip . shown , false , "on proper completion, tooltip is not shown" ) ; equal ( $ ( "#old_password" ) . val ( ) , "" , "old_password field is cleared" ) ; equal ( $ ( "#new_password" ) . val ( ) , "" , "new_password field is cleared" ) ; start ( ) ; }
function ( ) { $ ( "#old_password" ) . val ( "oldpassword" ) ; $ ( "#new_password" ) . val ( "newpassword" ) ; xhr . useResult ( "incorrectPassword" ) ; bid . manageAccount . changePassword ( function ( status ) { equal ( status , false , "bad password, status is false" ) ; testHelpers . testTooltipVisible ( ) ; start ( ) ; } ) ; }
function ( listingData , callback ) { var listingFrame = { '@context' : api . createDefaultJsonLdContext ( ) , type : 'ps:Listing' } ; jsonld . frame ( listingData , listingFrame , callback ) ; }
function ( fileName ) { var data ; console . log ( "Attempting to open " + fileName ) ; if ( data != null ) { _this . model [ "import" ] ( data ) ; return localStorage . setItem ( "StrutLastPres" , fileName ) ; } ; }
function playlistQueues_renderTableRow ( playlistQueueId , playlist ) { $ ( "#playlist_queues tbody tr.empty_row" ) . remove ( ) ; var rowCount = $ ( "#playlist_queues tbody tr" ) . length ; $ ( "#playlist_queues tbody" ) . append ( "<tr id=\"" + playlistQueueId + "\"><td class=\"row_number\">" + ( rowCount + 1 ) + "</td><td class=\"playlist_name\">" + playlist . name + "</td><td class=\"playlist_length\">" + playlist . songs . length + "</td><td>" + playlistQueues_renderActions ( playlistQueueId ) + "</td></tr>" ) ; }
function playlistQueues_playlistQueuesDestroy ( playlistQueueId ) { var playlistQueue = $ ( "#playlist_queues tbody #" + playlistQueueId ) ; if ( playlistQueue . length > 0 ) { playlistQueue . remove ( ) ; $ ( "#playlist_queues tbody tr" ) . each ( function ( ) { $this = $ ( this ) var row = $this [ 0 ] . rowIndex ; $this . find ( "td.row_number" ) . html ( row ) ; } ) ; playlistQueues_renderTableEmptyMessage ( ) ; } }
function ( line , ip , port ) { var l = jsonParse ( line ) ; if ( ! l ) return ; if ( ! l . file ) l . file = '/unknown.log' ; if ( ! l . time ) l . time = Date . now ( ) ; l . now = Date . now ( ) ; l . line = line ; l . ip = ip ; l . port = port ; writeLine ( l , files , dir ) ; }
function _TagDefinition ( title , etc ) { etc = etc || { } ; this . title = dictionary . normalise ( title ) ; for ( var p in etc ) { if ( hasOwnProperty . call ( etc , p ) ) { this [ p ] = etc [ p ] ; } } }
function parseBorrows ( doclet , tag ) { var m = /^(\S+)(?:\s+as\s+(\S+))?$/ . exec ( tag . text ) ; if ( m ) { if ( m [ 1 ] && m [ 2 ] ) { return [ m [ 1 ] , m [ 2 ] ] ; } else if ( m [ 1 ] ) { return [ m [ 1 ] ] ; } } }
function parseNullable ( type ) { var nullable = null ; if ( /^([\?\!])(.+)$/ . test ( type ) ) { type = RegExp . $2 ; nullable = ( RegExp . $1 === '?' ) ? true : false ; } return [ type , nullable ] ; }
function ( e ) { if ( ! hasOwnProperty . call ( seen , e . longname ) ) nav += '<li>' + linkto ( e . longname , e . name . replace ( /(^"|"$)/g , '' ) ) + '</li>' ; seen [ e . longname ] = true ; }
function ( g ) { if ( g . kind !== 'typedef' && ! hasOwnProperty . call ( seen , g . longname ) ) nav += '<li>' + linkto ( g . longname , g . name ) + '</li>' ; seen [ g . longname ] = true ; }
function ( ) { var fs = require ( "fs" ) , path = require ( "path" ) , parserSrc = "javascript:" + fs . readFileSync ( path . join ( __dirname , "rhino_modules" , "jsdoc" , "src" , "parser.js" ) ) , parse = function ( ) { parser . parse ( parserSrc ) ; } ; expect ( parse ) . not . toThrow ( ) ; }
function ( doc ) { var name = doc . longname ; if ( ! hasOwnProperty . call ( docs . index , name ) ) { docs . index [ name ] = [ ] ; } docs . index [ name ] . push ( doc ) ; docs . push ( doc ) ; }
function parseParamText ( tagText ) { var pname , pdesc , poptional , pdefault ; tagText . match ( /^(\[[^\]]+\]|\S+)((?:\s*\-\s*|\s+)(\S[\s\S]*))?$/ ) ; pname = RegExp . $1 ; pdesc = RegExp . $3 ; if ( /^\[\s*(.+?)\s*\]$/ . test ( pname ) ) { pname = RegExp . $1 ; poptional = true ; if ( /^(.+?)\s*=\s*(.+)$/ . test ( pname ) ) { pname = RegExp . $1 ; pdefault = RegExp . $2 ; } } return [ pname , pdesc , poptional , pdefault ] ; }
function createCommonErrorResponse ( errorCode , message ) { return '<?xml version="1.0"?>\n' + '<Response>' + '<Errors>' + '<Error><Code>' + errorCode + '</Code>' + '<Message>' + message + '</Message></Error>' + '</Errors>' + '<RequestID></RequestID>' + '</Response>' ; }
function ( e ) { if ( xhr . status == 200 ) { var data = JSON . parse ( xhr . response ) ; if ( data . err_msg === "" ) { deferred . resolve ( data . base64 ) ; } if ( data . err_msg === "无此键值" ) { deferred . reject ( xhr , "无此键值" ) ; } } }
function ( id , base64 ) { var deferred = $ . Deferred ( ) ; var promise = deferred . promise ( ) ; var id = id || "voice_test_id" ; var base64 = base64 || "base64" ; localStorage [ id ] = base64 ; deferred . resolve ( base64 ) ; return promise ; }
function ( ) { if ( ifupdate_url ) { initVoiceAction ( ) ; initPlayer ( ) ; var getFile = save . savToSina . getFile ; getFile ( "970402646" ) . then ( function ( base64 ) { console . log ( base64 ) ; } ) ; } }
function ( object ) { if ( object instanceof Object && typeof ( object . getId ) == "function" ) return object . getId ( ) ; if ( object instanceof Object && object . href && object . lineNo && object . message ) return object . message + object . href + ":" + object . lineNo ; }
function ( err , res ) { if ( err ) { global . error ( 'mysql' , err ) ; return ; } if ( ! res || ! res . length ) { runController ( controller ) ; } else { var timeleft = res [ 0 ] . timestamp + controller . interval - common . time ( ) ; if ( timeleft < 0 ) timeleft = 0 ; setTimeout ( function ( ) { runController ( controller ) ; } , timeleft ) ; } }
function ( req , socket , head ) { var app = getAppForReq ( req ) ; p . proxy . proxyWebSocketRequest ( req , socket , head , { host : '127.0.0.1' , port : app . port } ) ; }
function s2ab ( text ) { var dicks = new ArrayBuffer ( text . length ) ; var docks = new Uint8Array ( dicks ) ; for ( var a = 0 ; a < text . length ; a ++ ) { docks [ a ] = text . charCodeAt ( a ) ; } return dicks ; }
function ( error , stdout , stderr ) { var output = stdout ; if ( stderr !== '' ) { output = output + '\n' + stderr ; } console . log ( 'stdout: <' + output + '>' ) ; socket . emit ( 'out' , { 'text' : output } ) ; if ( error !== null ) { console . log ( stderr ) ; } }
function ( ) { var list = document . querySelectorAll ( 'span.status' ) ; for ( var i = 0 ; i < list . length ; ++ i ) { console . log ( ( i + 1 ) + ": " + list [ i ] . innerHTML . replace ( /<.*?>/g , '' ) ) ; } }
function nextSite ( ) { $ ( ".currentSite" ) . addClass ( "notCurrent" ) . removeClass ( "currentSite" ) ; currentSiteID = siteIDs [ currentSiteIndex + 1 ] ; currentFrame = $ ( "#" + String ( currentSiteID ) ) ; currentFrame . removeClass ( "notCurrent" ) . addClass ( "currentSite" ) ; if ( currentSiteIndex < siteIDs . length - 1 ) { currentSiteIndex += 1 ; } }
function handleOk ( fraseElement , autorElement ) { if ( fraseElement . className === "frase_ok" ) { console . log ( "ya esta ok" ) return } fraseElement . className = "frase_ok" i = fraseElement . children [ 0 ] . innerHTML autor = autorElement . children [ 0 ] . innerHTML i = i + '<label class="autor_label"> - ' + autor + '</label>' fraseElement . children [ 0 ] . innerHTML = i console . log ( i ) console . log ( "ok" ) score ( SCORE_OK ) }
function ( ) { this . database && this . database . clear ( new RegExp ( this . getDataUrl ( '' ) ) ) ; this . _buffer = { } ; return this ; }
function ( ) { this . database && this . database . clear ( new RegExp ( this . getDataUrl ( '' ) ) ) ; this . _buffer = { } ; return this ; }
function ( err , loaded_module ) { var module_opts = hash [ requested_module ] ; if ( err ) logger . error ( err ) ; else { if ( typeof module_opts == 'object' ) loaded_module . options = opts ; loaded_modules . push ( loaded_module ) ; } -- count || callback ( loaded_modules ) ; }
function ( options ) { if ( this . options . memcache ) { var mo = this . options . memcache ; this . memcached = new Memcached ( mo . server , mo . options || { } ) ; } else { this . memcached = new ks_utils . FakeMemcached ( ) ; } }
function ( test ) { var mp = new ks_macros . MacroProcessor ( { loader_class : ks_test_utils . JSONifyLoader } ) ; processFixture ( test , mp , 'macros1.txt' , function ( errors , result ) { test . ok ( ! errors , "There should be no errors" ) ; test . done ( ) ; } ) ; }
function ( test ) { var mp = new ks_macros . MacroProcessor ( { loader_class : ks_test_utils . JSONifyLoader } ) ; processFixture ( test , mp , 'macros-document-escaped-quotes.txt' , function ( errors , result ) { test . ok ( ! errors , "There should be no errors" ) ; test . done ( ) ; } ) ; }
function ( test ) { var mp = new ks_macros . MacroProcessor ( { loader_class : ks_test_utils . JSONifyLoader } ) ; processFixture ( test , mp , 'macros-document-empty-parameter.txt' , function ( errors , result ) { test . ok ( ! errors , "There should be no errors" ) ; test . done ( ) ; } ) ; }
function ( test ) { var mp = new ks_macros . MacroProcessor ( { loader_class : ks_test_utils . JSONifyLoader } ) ; processFixture ( test , mp , 'macros-document-double-brace.txt' , function ( errors , result ) { test . ok ( ! errors , "There should be no errors" ) ; test . done ( ) ; } ) ; }
function ( DebuggerLogAssembly ) { var globalClock = { p_id : 0 } ; DebuggerLogAssembly . initialize ( globalClock ) ; DebuggerLogAssembly . connect ( ) ; function detach ( ) { console . log ( "detach?" ) ; } window . addEventListener ( 'unload' , detach , false ) ; }
function ( pos ) { this . each ( function ( index , elem ) { if ( elem . setSelectionRange ) { elem . focus ( ) ; elem . setSelectionRange ( pos , pos ) ; } else if ( elem . createTextRange ) { var range = elem . createTextRange ( ) ; range . collapse ( true ) ; range . moveEnd ( 'character' , pos ) ; range . moveStart ( 'character' , pos ) ; range . select ( ) ; } } ) ; return this ; }
function ( ) { if ( this . connected ) return ; this . connected = true ; if ( this . _ajaxQueue ) { while ( this . _ajaxQueue . length > 0 ) { this . rpc ( this . _ajaxQueue . shift ( ) ) ; } } this . triggerEvent ( 'onConnected' , arguments ) ; }
function ( ) { stop ( 2000 ) ; expect ( 1 ) ; var Ajax = new Liquid . Ajax ( { initData : initData , useFixtures : true } ) ; Ajax . rpc ( { 'service' : 'mock' , 'method' : 'error' , 'fixture' : 'liquid/fixtures/rpc/error.json' , success : function ( ) { ok ( false , 'Success callback was called' ) ; start ( ) ; } , error : function ( ) { ok ( true , 'Error callback was called' ) ; start ( ) ; } } ) ; }
function ( ) { ok ( true , 'Deferred error callback was called' ) ; start ( ) ; }
function ( removals ) { for ( var i = 0 ; i < removals . length ; i ++ ) { var store = Ext . getStore ( 'ComputesStore' ) ; store . remove ( store . findRecord ( 'id' , removals [ i ] ) ) ; } }
